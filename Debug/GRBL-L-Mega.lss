
GRBL-L-Mega.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800200  00800200  000084e4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00008470  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000d17  00800200  00800200  000084e4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000084e4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00008514  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000688  00000000  00000000  00008554  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000adc5  00000000  00000000  00008bdc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002b8e  00000000  00000000  000139a1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000061ea  00000000  00000000  0001652f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000015e8  00000000  00000000  0001c71c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002116  00000000  00000000  0001dd04  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006f73  00000000  00000000  0001fe1a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000006a0  00000000  00000000  00026d8d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	92 c2       	rjmp	.+1316   	; 0x526 <__ctors_end>
       2:	00 00       	nop
       4:	a3 c2       	rjmp	.+1350   	; 0x54c <__bad_interrupt>
       6:	00 00       	nop
       8:	a1 c2       	rjmp	.+1346   	; 0x54c <__bad_interrupt>
       a:	00 00       	nop
       c:	9f c2       	rjmp	.+1342   	; 0x54c <__bad_interrupt>
       e:	00 00       	nop
      10:	9d c2       	rjmp	.+1338   	; 0x54c <__bad_interrupt>
      12:	00 00       	nop
      14:	9b c2       	rjmp	.+1334   	; 0x54c <__bad_interrupt>
      16:	00 00       	nop
      18:	99 c2       	rjmp	.+1330   	; 0x54c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	97 c2       	rjmp	.+1326   	; 0x54c <__bad_interrupt>
      1e:	00 00       	nop
      20:	95 c2       	rjmp	.+1322   	; 0x54c <__bad_interrupt>
      22:	00 00       	nop
      24:	0c 94 10 30 	jmp	0x6020	; 0x6020 <__vector_9>
      28:	91 c2       	rjmp	.+1314   	; 0x54c <__bad_interrupt>
      2a:	00 00       	nop
      2c:	0c 94 e5 39 	jmp	0x73ca	; 0x73ca <__vector_11>
      30:	0c 94 2d 30 	jmp	0x605a	; 0x605a <__vector_12>
      34:	8b c2       	rjmp	.+1302   	; 0x54c <__bad_interrupt>
      36:	00 00       	nop
      38:	89 c2       	rjmp	.+1298   	; 0x54c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	87 c2       	rjmp	.+1294   	; 0x54c <__bad_interrupt>
      3e:	00 00       	nop
      40:	85 c2       	rjmp	.+1290   	; 0x54c <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 ed 18 	jmp	0x31da	; 0x31da <__vector_17>
      48:	81 c2       	rjmp	.+1282   	; 0x54c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	7f c2       	rjmp	.+1278   	; 0x54c <__bad_interrupt>
      4e:	00 00       	nop
      50:	7d c2       	rjmp	.+1274   	; 0x54c <__bad_interrupt>
      52:	00 00       	nop
      54:	7b c2       	rjmp	.+1270   	; 0x54c <__bad_interrupt>
      56:	00 00       	nop
      58:	79 c2       	rjmp	.+1266   	; 0x54c <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0c 94 eb 1a 	jmp	0x35d6	; 0x35d6 <__vector_23>
      60:	75 c2       	rjmp	.+1258   	; 0x54c <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 17 14 	jmp	0x282e	; 0x282e <__vector_25>
      68:	0c 94 db 13 	jmp	0x27b6	; 0x27b6 <__vector_26>
      6c:	6f c2       	rjmp	.+1246   	; 0x54c <__bad_interrupt>
      6e:	00 00       	nop
      70:	6d c2       	rjmp	.+1242   	; 0x54c <__bad_interrupt>
      72:	00 00       	nop
      74:	6b c2       	rjmp	.+1238   	; 0x54c <__bad_interrupt>
      76:	00 00       	nop
      78:	69 c2       	rjmp	.+1234   	; 0x54c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	67 c2       	rjmp	.+1230   	; 0x54c <__bad_interrupt>
      7e:	00 00       	nop
      80:	65 c2       	rjmp	.+1226   	; 0x54c <__bad_interrupt>
      82:	00 00       	nop
      84:	63 c2       	rjmp	.+1222   	; 0x54c <__bad_interrupt>
      86:	00 00       	nop
      88:	61 c2       	rjmp	.+1218   	; 0x54c <__bad_interrupt>
      8a:	00 00       	nop
      8c:	0c 94 99 3d 	jmp	0x7b32	; 0x7b32 <__vector_35>
      90:	5d c2       	rjmp	.+1210   	; 0x54c <__bad_interrupt>
      92:	00 00       	nop
      94:	5b c2       	rjmp	.+1206   	; 0x54c <__bad_interrupt>
      96:	00 00       	nop
      98:	59 c2       	rjmp	.+1202   	; 0x54c <__bad_interrupt>
      9a:	00 00       	nop
      9c:	57 c2       	rjmp	.+1198   	; 0x54c <__bad_interrupt>
      9e:	00 00       	nop
      a0:	55 c2       	rjmp	.+1194   	; 0x54c <__bad_interrupt>
      a2:	00 00       	nop
      a4:	53 c2       	rjmp	.+1190   	; 0x54c <__bad_interrupt>
      a6:	00 00       	nop
      a8:	51 c2       	rjmp	.+1186   	; 0x54c <__bad_interrupt>
      aa:	00 00       	nop
      ac:	4f c2       	rjmp	.+1182   	; 0x54c <__bad_interrupt>
      ae:	00 00       	nop
      b0:	4d c2       	rjmp	.+1178   	; 0x54c <__bad_interrupt>
      b2:	00 00       	nop
      b4:	4b c2       	rjmp	.+1174   	; 0x54c <__bad_interrupt>
      b6:	00 00       	nop
      b8:	49 c2       	rjmp	.+1170   	; 0x54c <__bad_interrupt>
      ba:	00 00       	nop
      bc:	47 c2       	rjmp	.+1166   	; 0x54c <__bad_interrupt>
      be:	00 00       	nop
      c0:	45 c2       	rjmp	.+1162   	; 0x54c <__bad_interrupt>
      c2:	00 00       	nop
      c4:	43 c2       	rjmp	.+1158   	; 0x54c <__bad_interrupt>
      c6:	00 00       	nop
      c8:	41 c2       	rjmp	.+1154   	; 0x54c <__bad_interrupt>
      ca:	00 00       	nop
      cc:	3f c2       	rjmp	.+1150   	; 0x54c <__bad_interrupt>
      ce:	00 00       	nop
      d0:	3d c2       	rjmp	.+1146   	; 0x54c <__bad_interrupt>
      d2:	00 00       	nop
      d4:	3b c2       	rjmp	.+1142   	; 0x54c <__bad_interrupt>
      d6:	00 00       	nop
      d8:	39 c2       	rjmp	.+1138   	; 0x54c <__bad_interrupt>
      da:	00 00       	nop
      dc:	37 c2       	rjmp	.+1134   	; 0x54c <__bad_interrupt>
      de:	00 00       	nop
      e0:	35 c2       	rjmp	.+1130   	; 0x54c <__bad_interrupt>
      e2:	00 00       	nop
      e4:	cd 07       	cpc	r28, r29
      e6:	cd 07       	cpc	r28, r29
      e8:	cd 07       	cpc	r28, r29
      ea:	cd 07       	cpc	r28, r29
      ec:	ae 07       	cpc	r26, r30
      ee:	45 11       	cpse	r20, r5
      f0:	45 11       	cpse	r20, r5
      f2:	45 11       	cpse	r20, r5
      f4:	45 11       	cpse	r20, r5
      f6:	45 11       	cpse	r20, r5
      f8:	a2 07       	cpc	r26, r18
      fa:	45 11       	cpse	r20, r5
      fc:	45 11       	cpse	r20, r5
      fe:	45 11       	cpse	r20, r5
     100:	45 11       	cpse	r20, r5
     102:	45 11       	cpse	r20, r5
     104:	45 11       	cpse	r20, r5
     106:	f7 07       	cpc	r31, r23
     108:	f7 07       	cpc	r31, r23
     10a:	f7 07       	cpc	r31, r23
     10c:	18 08       	sbc	r1, r8
     10e:	18 08       	sbc	r1, r8
     110:	45 11       	cpse	r20, r5
     112:	45 11       	cpse	r20, r5
     114:	45 11       	cpse	r20, r5
     116:	45 11       	cpse	r20, r5
     118:	45 11       	cpse	r20, r5
     11a:	45 11       	cpse	r20, r5
     11c:	a2 07       	cpc	r26, r18
     11e:	45 11       	cpse	r20, r5
     120:	a2 07       	cpc	r26, r18
     122:	45 11       	cpse	r20, r5
     124:	45 11       	cpse	r20, r5
     126:	45 11       	cpse	r20, r5
     128:	45 11       	cpse	r20, r5
     12a:	45 11       	cpse	r20, r5
     12c:	45 11       	cpse	r20, r5
     12e:	45 11       	cpse	r20, r5
     130:	cd 07       	cpc	r28, r29
     132:	45 11       	cpse	r20, r5
     134:	43 08       	sbc	r4, r3
     136:	45 11       	cpse	r20, r5
     138:	45 11       	cpse	r20, r5
     13a:	1e 08       	sbc	r1, r14
     13c:	45 11       	cpse	r20, r5
     13e:	45 11       	cpse	r20, r5
     140:	45 11       	cpse	r20, r5
     142:	45 11       	cpse	r20, r5
     144:	45 11       	cpse	r20, r5
     146:	1e 08       	sbc	r1, r14
     148:	45 11       	cpse	r20, r5
     14a:	45 11       	cpse	r20, r5
     14c:	45 11       	cpse	r20, r5
     14e:	ae 07       	cpc	r26, r30
     150:	37 08       	sbc	r3, r7
     152:	37 08       	sbc	r3, r7
     154:	37 08       	sbc	r3, r7
     156:	37 08       	sbc	r3, r7
     158:	37 08       	sbc	r3, r7
     15a:	37 08       	sbc	r3, r7
     15c:	45 11       	cpse	r20, r5
     15e:	3d 08       	sbc	r3, r13
     160:	45 11       	cpse	r20, r5
     162:	45 11       	cpse	r20, r5
     164:	45 11       	cpse	r20, r5
     166:	45 11       	cpse	r20, r5
     168:	45 11       	cpse	r20, r5
     16a:	45 11       	cpse	r20, r5
     16c:	45 11       	cpse	r20, r5
     16e:	45 11       	cpse	r20, r5
     170:	45 11       	cpse	r20, r5
     172:	45 11       	cpse	r20, r5
     174:	45 11       	cpse	r20, r5
     176:	45 11       	cpse	r20, r5
     178:	45 11       	cpse	r20, r5
     17a:	45 11       	cpse	r20, r5
     17c:	45 11       	cpse	r20, r5
     17e:	45 11       	cpse	r20, r5
     180:	45 11       	cpse	r20, r5
     182:	45 11       	cpse	r20, r5
     184:	d3 07       	cpc	r29, r19
     186:	45 11       	cpse	r20, r5
     188:	45 11       	cpse	r20, r5
     18a:	45 11       	cpse	r20, r5
     18c:	45 11       	cpse	r20, r5
     18e:	45 11       	cpse	r20, r5
     190:	45 11       	cpse	r20, r5
     192:	45 11       	cpse	r20, r5
     194:	45 11       	cpse	r20, r5
     196:	45 11       	cpse	r20, r5
     198:	fd 07       	cpc	r31, r29
     19a:	fd 07       	cpc	r31, r29
     19c:	a2 07       	cpc	r26, r18
     19e:	12 08       	sbc	r1, r2
     1a0:	12 08       	sbc	r1, r2
     1a2:	6e 08       	sbc	r6, r14
     1a4:	6e 08       	sbc	r6, r14
     1a6:	6e 08       	sbc	r6, r14
     1a8:	7d 08       	sbc	r7, r13
     1aa:	7d 08       	sbc	r7, r13
     1ac:	7d 08       	sbc	r7, r13
     1ae:	5f 11       	cpse	r21, r15
     1b0:	94 08       	sbc	r9, r4
     1b2:	94 08       	sbc	r9, r4
     1b4:	94 08       	sbc	r9, r4
     1b6:	5f 11       	cpse	r21, r15
     1b8:	5f 11       	cpse	r21, r15
     1ba:	5f 11       	cpse	r21, r15
     1bc:	5f 11       	cpse	r21, r15
     1be:	5f 11       	cpse	r21, r15
     1c0:	5f 11       	cpse	r21, r15
     1c2:	5f 11       	cpse	r21, r15
     1c4:	5f 11       	cpse	r21, r15
     1c6:	5f 11       	cpse	r21, r15
     1c8:	5f 11       	cpse	r21, r15
     1ca:	5f 11       	cpse	r21, r15
     1cc:	5f 11       	cpse	r21, r15
     1ce:	5f 11       	cpse	r21, r15
     1d0:	5f 11       	cpse	r21, r15
     1d2:	5f 11       	cpse	r21, r15
     1d4:	5f 11       	cpse	r21, r15
     1d6:	5f 11       	cpse	r21, r15
     1d8:	5f 11       	cpse	r21, r15
     1da:	5f 11       	cpse	r21, r15
     1dc:	5f 11       	cpse	r21, r15
     1de:	6e 08       	sbc	r6, r14
     1e0:	d4 08       	sbc	r13, r4
     1e2:	63 11       	cpse	r22, r3
     1e4:	63 11       	cpse	r22, r3
     1e6:	de 08       	sbc	r13, r14
     1e8:	eb 08       	sbc	r14, r11
     1ea:	f8 08       	sbc	r15, r8
     1ec:	05 09       	sbc	r16, r5
     1ee:	63 11       	cpse	r22, r3
     1f0:	09 09       	sbc	r16, r9
     1f2:	63 11       	cpse	r22, r3
     1f4:	17 09       	sbc	r17, r7
     1f6:	63 11       	cpse	r22, r3
     1f8:	21 09       	sbc	r18, r1
     1fa:	2b 09       	sbc	r18, r11
     1fc:	35 09       	sbc	r19, r5
     1fe:	63 11       	cpse	r22, r3
     200:	63 11       	cpse	r22, r3
     202:	63 11       	cpse	r22, r3
     204:	45 09       	sbc	r20, r5
     206:	52 09       	sbc	r21, r2
     208:	5f 09       	sbc	r21, r15
     20a:	58 14       	cp	r5, r8
     20c:	5c 14       	cp	r5, r12
     20e:	64 14       	cp	r6, r4
     210:	bb 14       	cp	r11, r11
     212:	bb 14       	cp	r11, r11
     214:	bb 14       	cp	r11, r11
     216:	bb 14       	cp	r11, r11
     218:	bb 14       	cp	r11, r11
     21a:	bb 14       	cp	r11, r11
     21c:	bb 14       	cp	r11, r11
     21e:	bb 14       	cp	r11, r11
     220:	bb 14       	cp	r11, r11
     222:	6d 14       	cp	r6, r13
     224:	71 14       	cp	r7, r1
     226:	75 14       	cp	r7, r5
     228:	79 14       	cp	r7, r9
     22a:	7d 14       	cp	r7, r13
     22c:	81 14       	cp	r8, r1
     22e:	85 14       	cp	r8, r5
     230:	89 14       	cp	r8, r9
     232:	bb 14       	cp	r11, r11
     234:	8d 14       	cp	r8, r13
     236:	91 14       	cp	r9, r1
     238:	95 14       	cp	r9, r5
     23a:	99 14       	cp	r9, r9
     23c:	9d 14       	cp	r9, r13
     23e:	a1 14       	cp	r10, r1
     240:	bb 14       	cp	r11, r11
     242:	a5 14       	cp	r10, r5
     244:	a9 14       	cp	r10, r9
     246:	f1 25       	eor	r31, r1
     248:	f7 25       	eor	r31, r7
     24a:	fa 25       	eor	r31, r10
     24c:	ff 25       	eor	r31, r15
     24e:	04 26       	eor	r0, r20
     250:	12 26       	eor	r1, r18
     252:	20 26       	eor	r2, r16
     254:	d3 26       	eor	r13, r19
     256:	d3 26       	eor	r13, r19
     258:	d3 26       	eor	r13, r19
     25a:	31 26       	eor	r3, r17
     25c:	34 26       	eor	r3, r20
     25e:	3d 26       	eor	r3, r29
     260:	46 26       	eor	r4, r22
     262:	d3 26       	eor	r13, r19
     264:	d3 26       	eor	r13, r19
     266:	d3 26       	eor	r13, r19
     268:	d3 26       	eor	r13, r19
     26a:	d3 26       	eor	r13, r19
     26c:	d3 26       	eor	r13, r19
     26e:	56 26       	eor	r5, r22
     270:	66 26       	eor	r6, r22
     272:	76 26       	eor	r7, r22
     274:	84 26       	eor	r8, r20
     276:	87 26       	eor	r8, r23
     278:	90 26       	eor	r9, r16
     27a:	99 26       	eor	r9, r25
     27c:	a0 26       	eor	r10, r16
     27e:	d3 26       	eor	r13, r19
     280:	d3 26       	eor	r13, r19
     282:	a9 26       	eor	r10, r25
     284:	b4 26       	eor	r11, r20
     286:	bf 26       	eor	r11, r31
     288:	0c 35       	cpi	r16, 0x5C	; 92
     28a:	10 35       	cpi	r17, 0x50	; 80
     28c:	14 35       	cpi	r17, 0x54	; 84
     28e:	18 35       	cpi	r17, 0x58	; 88
     290:	1c 35       	cpi	r17, 0x5C	; 92
     292:	20 35       	cpi	r18, 0x50	; 80
     294:	24 35       	cpi	r18, 0x54	; 84
     296:	28 35       	cpi	r18, 0x58	; 88
     298:	2c 35       	cpi	r18, 0x5C	; 92
     29a:	30 35       	cpi	r19, 0x50	; 80
     29c:	34 35       	cpi	r19, 0x54	; 84
     29e:	08 4a       	sbci	r16, 0xA8	; 168
     2a0:	d7 3b       	cpi	r29, 0xB7	; 183
     2a2:	3b ce       	rjmp	.-906    	; 0xffffff1a <__eeprom_end+0xff7eff1a>
     2a4:	01 6e       	ori	r16, 0xE1	; 225
     2a6:	84 bc       	out	0x24, r8	; 36
     2a8:	bf fd       	.word	0xfdbf	; ????
     2aa:	c1 2f       	mov	r28, r17
     2ac:	3d 6c       	ori	r19, 0xCD	; 205
     2ae:	74 31       	cpi	r23, 0x14	; 20
     2b0:	9a bd       	out	0x2a, r25	; 42
     2b2:	56 83       	std	Z+6, r21	; 0x06
     2b4:	3d da       	rcall	.-2950   	; 0xfffff730 <__eeprom_end+0xff7ef730>
     2b6:	3d 00       	.word	0x003d	; ????
     2b8:	c7 7f       	andi	r28, 0xF7	; 247
     2ba:	11 be       	out	0x31, r1	; 49
     2bc:	d9 e4       	ldi	r29, 0x49	; 73
     2be:	bb 4c       	sbci	r27, 0xCB	; 203
     2c0:	3e 91       	ld	r19, -X
     2c2:	6b aa       	std	Y+51, r6	; 0x33
     2c4:	aa be       	out	0x3a, r10	; 58
     2c6:	00 00       	nop
     2c8:	00 80       	ld	r0, Z
     2ca:	3f 05       	cpc	r19, r15
     2cc:	a8 4c       	sbci	r26, 0xC8	; 200
     2ce:	cd b2       	in	r12, 0x1d	; 29
     2d0:	d4 4e       	sbci	r29, 0xE4	; 228
     2d2:	b9 38       	cpi	r27, 0x89	; 137
     2d4:	36 a9       	ldd	r19, Z+54	; 0x36
     2d6:	02 0c       	add	r0, r2
     2d8:	50 b9       	out	0x00, r21	; 0
     2da:	91 86       	std	Z+9, r9	; 0x09
     2dc:	88 08       	sbc	r8, r8
     2de:	3c a6       	std	Y+44, r3	; 0x2c
     2e0:	aa aa       	std	Y+50, r10	; 0x32
     2e2:	2a be       	out	0x3a, r2	; 58
     2e4:	00 00       	nop
     2e6:	00 80       	ld	r0, Z
     2e8:	3f 00       	.word	0x003f	; ????

000002ea <__trampolines_end>:
     2ea:	00 00       	nop
     2ec:	7a 43       	sbci	r23, 0x3A	; 58
     2ee:	00 00       	nop
     2f0:	7a 43       	sbci	r23, 0x3A	; 58
     2f2:	00 00       	nop
     2f4:	7a 43       	sbci	r23, 0x3A	; 58
     2f6:	00 00       	nop
     2f8:	fa 43       	sbci	r31, 0x3A	; 58
     2fa:	00 00       	nop
     2fc:	fa 43       	sbci	r31, 0x3A	; 58
     2fe:	00 00       	nop
     300:	fa 43       	sbci	r31, 0x3A	; 58
     302:	00 a0       	ldd	r0, Z+32	; 0x20
     304:	0c 47       	sbci	r16, 0x7C	; 124
     306:	00 a0       	ldd	r0, Z+32	; 0x20
     308:	0c 47       	sbci	r16, 0x7C	; 124
     30a:	00 a0       	ldd	r0, Z+32	; 0x20
     30c:	0c 47       	sbci	r16, 0x7C	; 124
     30e:	00 00       	nop
     310:	48 c3       	rjmp	.+1680   	; 0x9a2 <mc_arc+0x31a>
     312:	00 00       	nop
     314:	48 c3       	rjmp	.+1680   	; 0x9a6 <mc_arc+0x31e>
     316:	00 00       	nop
     318:	48 c3       	rjmp	.+1680   	; 0x9aa <mc_arc+0x322>
     31a:	0a 00       	.word	0x000a	; ????
     31c:	00 19       	sub	r16, r0
     31e:	01 0a       	sbc	r0, r17
     320:	d7 23       	and	r29, r23
     322:	3c 6f       	ori	r19, 0xFC	; 252
     324:	12 03       	mulsu	r17, r18
     326:	3b 00       	.word	0x003b	; ????
     328:	00 7a       	andi	r16, 0xA0	; 160
     32a:	44 00       	.word	0x0044	; ????
     32c:	00 00       	nop
     32e:	00 00       	nop
     330:	00 00       	nop
     332:	00 c8       	rjmp	.-4096   	; 0xfffff334 <__eeprom_end+0xff7ef334>
     334:	41 00       	.word	0x0041	; ????
     336:	00 fa       	bst	r0, 0
     338:	43 fa       	bst	r4, 3
     33a:	00 00       	nop
     33c:	00 80       	ld	r0, Z
     33e:	3f 7c       	Address 0x0000033e is out of bounds.
.word	0xffff	; ????

0000033f <__c.2794>:
     33f:	7c 53 69 3a 00                                      |Si:.

00000344 <__c.2792>:
     344:	7c 53 70 3a 00                                      |Sp:.

00000349 <__c.2790>:
     349:	7c 41 3a 00                                         |A:.

0000034d <__c.2786>:
     34d:	7c 4f 76 3a 00                                      |Ov:.

00000352 <__c.2784>:
     352:	7c 57 43 4f 3a 00                                   |WCO:.

00000358 <__c.2782>:
     358:	7c 50 6e 3a 00                                      |Pn:.

0000035d <__c.2777>:
     35d:	7c 46 53 3a 00                                      |FS:.

00000362 <__c.2775>:
     362:	7c 4c 6e 3a 00                                      |Ln:.

00000367 <__c.2771>:
     367:	7c 42 66 3a 00                                      |Bf:.

0000036c <__c.2769>:
     36c:	7c 57 50 6f 73 3a 00                                |WPos:.

00000373 <__c.2767>:
     373:	7c 4d 50 6f 73 3a 00                                |MPos:.

0000037a <__c.2761>:
     37a:	53 6c 65 65 70 00                                   Sleep.

00000380 <__c.2758>:
     380:	44 6f 6f 72 3a 00                                   Door:.

00000386 <__c.2755>:
     386:	43 68 65 63 6b 00                                   Check.

0000038c <__c.2752>:
     38c:	41 6c 61 72 6d 00                                   Alarm.

00000392 <__c.2749>:
     392:	48 6f 6d 65 00                                      Home.

00000397 <__c.2746>:
     397:	4a 6f 67 00                                         Jog.

0000039b <__c.2743>:
     39b:	48 6f 6c 64 3a 00                                   Hold:.

000003a1 <__c.2740>:
     3a1:	52 75 6e 00                                         Run.

000003a5 <__c.2736>:
     3a5:	49 64 6c 65 00                                      Idle.

000003aa <__c.2723>:
     3aa:	5b 4f 50 54 3a 00                                   [OPT:.

000003b0 <__c.2721>:
     3b0:	5b 56 45 52 3a 31 2e 31 67 2e 32 30 31 38 30 38     [VER:1.1g.201808
     3c0:	31 33 2e 4d 65 67 61 3a 00                          13.Mega:.

000003c9 <__c.2712>:
     3c9:	24 4e 00                                            $N.

000003cc <__c.2560>:
     3cc:	20 4d 00                                             M.

000003cf <__c.2556>:
     3cf:	20 47 00                                             G.

000003d2 <__c.2706>:
     3d2:	20 53 00                                             S.

000003d5 <__c.2704>:
     3d5:	20 46 00                                             F.

000003d8 <__c.2702>:
     3d8:	20 54 00                                             T.

000003db <__c.2692>:
     3db:	33 38 2e 00                                         38..

000003df <__c.2690>:
     3df:	5b 47 43 3a 47 00                                   [GC:G.

000003e5 <__c.2686>:
     3e5:	5b 54 4c 4f 3a 00                                   [TLO:.

000003eb <__c.2684>:
     3eb:	5b 47 39 32 3a 00                                   [G92:.

000003f1 <__c.2678>:
     3f1:	33 30 00                                            30.

000003f4 <__c.2674>:
     3f4:	32 38 00                                            28.

000003f7 <__c.2671>:
     3f7:	5b 47 00                                            [G.

000003fa <__c.2664>:
     3fa:	5b 50 52 42 3a 00                                   [PRB:.

00000400 <__c.2644>:
     400:	5b 48 4c 50 3a 24 24 20 24 23 20 24 47 20 24 49     [HLP:$$ $# $G $I
     410:	20 24 4e 20 24 78 3d 76 61 6c 20 24 4e 78 3d 6c      $N $x=val $Nx=l
     420:	69 6e 65 20 24 4a 3d 6c 69 6e 65 20 24 53 4c 50     ine $J=line $SLP
     430:	20 24 43 20 24 58 20 24 48 20 7e 20 21 20 3f 20      $C $X $H ~ ! ? 
     440:	63 74 72 6c 2d 78 5d 0d 0a 00                       ctrl-x]...

0000044a <__c.2640>:
     44a:	0d 0a 47 72 62 6c 20 31 2e 31 67 20 5b 27 24 27     ..Grbl 1.1g ['$'
     45a:	20 66 6f 72 20 68 65 6c 70 5d 0d 0a 00               for help]...

00000467 <__c.2636>:
     467:	53 6c 65 65 70 69 6e 67 00                          Sleeping.

00000470 <__c.2633>:
     470:	52 65 73 74 6f 72 69 6e 67 20 73 70 69 6e 64 6c     Restoring spindl
     480:	65 00                                               e.

00000482 <__c.2630>:
     482:	52 65 73 74 6f 72 69 6e 67 20 64 65 66 61 75 6c     Restoring defaul
     492:	74 73 00                                            ts.

00000495 <__c.2627>:
     495:	50 67 6d 20 45 6e 64 00                             Pgm End.

0000049d <__c.2624>:
     49d:	43 68 65 63 6b 20 4c 69 6d 69 74 73 00              Check Limits.

000004aa <__c.2621>:
     4aa:	43 68 65 63 6b 20 44 6f 6f 72 00                    Check Door.

000004b5 <__c.2618>:
     4b5:	44 69 73 61 62 6c 65 64 00                          Disabled.

000004be <__c.2615>:
     4be:	45 6e 61 62 6c 65 64 00                             Enabled.

000004c6 <__c.2612>:
     4c6:	43 61 75 74 69 6f 6e 3a 20 55 6e 6c 6f 63 6b 65     Caution: Unlocke
     4d6:	64 00                                               d.

000004d8 <__c.2609>:
     4d8:	27 24 48 27 7c 27 24 58 27 20 74 6f 20 75 6e 6c     '$H'|'$X' to unl
     4e8:	6f 63 6b 00                                         ock.

000004ec <__c.2605>:
     4ec:	52 65 73 65 74 20 74 6f 20 63 6f 6e 74 69 6e 75     Reset to continu
     4fc:	65 00                                               e.

000004fe <__c.2602>:
     4fe:	5b 4d 53 47 3a 00                                   [MSG:.

00000504 <__c.2597>:
     504:	7c 53 73 3a 20 00                                   |Ss: .

0000050a <__c.2595>:
     50a:	53 69 3a 20 00                                      Si: .

0000050f <__c.2591>:
     50f:	41 4c 41 52 4d 3a 00                                ALARM:.

00000516 <__c.2550>:
     516:	0d 0a 00                                            ...

00000519 <__c.2586>:
     519:	65 72 72 6f 72 3a 00                                error:.

00000520 <__c.2582>:
     520:	6f 6b 0d 0a 00 00                                   ok....

00000526 <__ctors_end>:
     526:	11 24       	eor	r1, r1
     528:	1f be       	out	0x3f, r1	; 63
     52a:	cf ef       	ldi	r28, 0xFF	; 255
     52c:	d1 e2       	ldi	r29, 0x21	; 33
     52e:	de bf       	out	0x3e, r29	; 62
     530:	cd bf       	out	0x3d, r28	; 61
     532:	00 e0       	ldi	r16, 0x00	; 0
     534:	0c bf       	out	0x3c, r16	; 60

00000536 <__do_clear_bss>:
     536:	2f e0       	ldi	r18, 0x0F	; 15
     538:	a0 e0       	ldi	r26, 0x00	; 0
     53a:	b2 e0       	ldi	r27, 0x02	; 2
     53c:	01 c0       	rjmp	.+2      	; 0x540 <.do_clear_bss_start>

0000053e <.do_clear_bss_loop>:
     53e:	1d 92       	st	X+, r1

00000540 <.do_clear_bss_start>:
     540:	a7 31       	cpi	r26, 0x17	; 23
     542:	b2 07       	cpc	r27, r18
     544:	e1 f7       	brne	.-8      	; 0x53e <.do_clear_bss_loop>
     546:	03 d0       	rcall	.+6      	; 0x54e <main>
     548:	0c 94 36 42 	jmp	0x846c	; 0x846c <_exit>

0000054c <__bad_interrupt>:
     54c:	59 cd       	rjmp	.-1358   	; 0x0 <__vectors>

0000054e <main>:


int main(void)
{
  // Initialize system upon power-up.
  serial_init();   // Setup serial baud rate and interrupts
     54e:	0e 94 b2 13 	call	0x2764	; 0x2764 <serial_init>
  settings_init(); // Load Grbl settings from EEPROM
     552:	0e 94 2e 27 	call	0x4e5c	; 0x4e5c <settings_init>
  stepper_init();  // Configure stepper pins and interrupt timers
     556:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <stepper_init>
  system_init();   // Configure pinout pins and pin-change interrupt
     55a:	0e 94 ba 39 	call	0x7374	; 0x7374 <system_init>

  memset(sys_position,0,sizeof(sys_position)); // Clear machine position.
     55e:	8c e0       	ldi	r24, 0x0C	; 12
     560:	e7 e3       	ldi	r30, 0x37	; 55
     562:	fc e0       	ldi	r31, 0x0C	; 12
     564:	df 01       	movw	r26, r30
     566:	1d 92       	st	X+, r1
     568:	8a 95       	dec	r24
     56a:	e9 f7       	brne	.-6      	; 0x566 <main+0x18>
  sei(); // Enable interrupts
     56c:	78 94       	sei
  // Initialize system state.
  #ifdef FORCE_INITIALIZATION_ALARM
    // Force Grbl into an ALARM state upon a power-cycle or hard reset.
    sys.state = STATE_ALARM;
  #else
    sys.state = STATE_IDLE;
     56e:	10 92 16 0c 	sts	0x0C16, r1	; 0x800c16 <sys>
  // Grbl initialization loop upon power-up or a system abort. For the latter, all processes
  // will return to this loop to be cleanly re-initialized.
  for(;;) {

    // Reset system variables.
    uint8_t prior_state = sys.state;
     572:	c6 e1       	ldi	r28, 0x16	; 22
     574:	dc e0       	ldi	r29, 0x0C	; 12
    memset(&sys, 0, sizeof(system_t)); // Clear system struct variable.
     576:	0f 2e       	mov	r0, r31
     578:	f2 e1       	ldi	r31, 0x12	; 18
     57a:	df 2e       	mov	r13, r31
     57c:	f0 2d       	mov	r31, r0
    sys.state = prior_state;
    sys.f_override = DEFAULT_FEED_OVERRIDE;  // Set to 100%
     57e:	14 e6       	ldi	r17, 0x64	; 100
    sys.r_override = DEFAULT_RAPID_OVERRIDE; // Set to 100%
    sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE; // Set to 100%
		memset(sys_probe_position,0,sizeof(sys_probe_position)); // Clear probe position.
     580:	0f 2e       	mov	r0, r31
     582:	fb e2       	ldi	r31, 0x2B	; 43
     584:	ef 2e       	mov	r14, r31
     586:	fc e0       	ldi	r31, 0x0C	; 12
     588:	ff 2e       	mov	r15, r31
     58a:	f0 2d       	mov	r31, r0
     58c:	0c e0       	ldi	r16, 0x0C	; 12
  // Grbl initialization loop upon power-up or a system abort. For the latter, all processes
  // will return to this loop to be cleanly re-initialized.
  for(;;) {

    // Reset system variables.
    uint8_t prior_state = sys.state;
     58e:	88 81       	ld	r24, Y
    memset(&sys, 0, sizeof(system_t)); // Clear system struct variable.
     590:	fe 01       	movw	r30, r28
     592:	9d 2d       	mov	r25, r13
     594:	11 92       	st	Z+, r1
     596:	9a 95       	dec	r25
     598:	e9 f7       	brne	.-6      	; 0x594 <main+0x46>
    sys.state = prior_state;
     59a:	88 83       	st	Y, r24
    sys.f_override = DEFAULT_FEED_OVERRIDE;  // Set to 100%
     59c:	1f 83       	std	Y+7, r17	; 0x07
    sys.r_override = DEFAULT_RAPID_OVERRIDE; // Set to 100%
     59e:	18 87       	std	Y+8, r17	; 0x08
    sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE; // Set to 100%
     5a0:	19 87       	std	Y+9, r17	; 0x09
		memset(sys_probe_position,0,sizeof(sys_probe_position)); // Clear probe position.
     5a2:	d7 01       	movw	r26, r14
     5a4:	e0 2f       	mov	r30, r16
     5a6:	1d 92       	st	X+, r1
     5a8:	ea 95       	dec	r30
     5aa:	e9 f7       	brne	.-6      	; 0x5a6 <main+0x58>
    sys_probe_state = 0;
     5ac:	10 92 2a 0c 	sts	0x0C2A, r1	; 0x800c2a <sys_probe_state>
    sys_rt_exec_state = 0;
     5b0:	10 92 29 0c 	sts	0x0C29, r1	; 0x800c29 <sys_rt_exec_state>
    sys_rt_exec_alarm = 0;
     5b4:	10 92 43 0c 	sts	0x0C43, r1	; 0x800c43 <sys_rt_exec_alarm>
    sys_rt_exec_motion_override = 0;
     5b8:	10 92 15 0c 	sts	0x0C15, r1	; 0x800c15 <sys_rt_exec_motion_override>
    sys_rt_exec_accessory_override = 0;
     5bc:	10 92 28 0c 	sts	0x0C28, r1	; 0x800c28 <sys_rt_exec_accessory_override>
	
	sys_index_pulse_count=0;
     5c0:	10 92 45 0c 	sts	0x0C45, r1	; 0x800c45 <sys_index_pulse_count>
	sys_synchronization_pulse_count=0;
     5c4:	10 92 11 0c 	sts	0x0C11, r1	; 0x800c11 <sys_synchronization_pulse_count>
     5c8:	10 92 12 0c 	sts	0x0C12, r1	; 0x800c12 <sys_synchronization_pulse_count+0x1>
     5cc:	10 92 13 0c 	sts	0x0C13, r1	; 0x800c13 <sys_synchronization_pulse_count+0x2>
     5d0:	10 92 14 0c 	sts	0x0C14, r1	; 0x800c14 <sys_synchronization_pulse_count+0x3>

    // Reset Grbl primary systems.
    serial_reset_read_buffer(); // Clear serial read buffer
     5d4:	0e 94 ce 14 	call	0x299c	; 0x299c <serial_reset_read_buffer>
    gc_init(); // Set g-code parser to default state
     5d8:	02 d4       	rcall	.+2052   	; 0xdde <gc_init>
    spindle_init();
     5da:	0e 94 2d 12 	call	0x245a	; 0x245a <spindle_init>
    coolant_init();
     5de:	0e 94 6f 13 	call	0x26de	; 0x26de <coolant_init>
    limits_init();
     5e2:	0e 94 ac 2f 	call	0x5f58	; 0x5f58 <limits_init>
    probe_init();
     5e6:	0e 94 55 34 	call	0x68aa	; 0x68aa <probe_init>
    sleep_init();
     5ea:	0e 94 87 3d 	call	0x7b0e	; 0x7b0e <sleep_init>
    plan_reset(); // Clear block buffer and planner variables
     5ee:	0e 94 c7 28 	call	0x518e	; 0x518e <plan_reset>
    st_reset(); // Clear stepper subsystem variables.
     5f2:	0e 94 41 1b 	call	0x3682	; 0x3682 <st_reset>

    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
     5f6:	0e 94 6f 2d 	call	0x5ade	; 0x5ade <plan_sync_position>
    gc_sync_position();
     5fa:	03 d4       	rcall	.+2054   	; 0xe02 <gc_sync_position>

    // Print welcome message. Indicates an initialization has occured at power-up or with a reset.
    report_init_message();
     5fc:	0e 94 3a 35 	call	0x6a74	; 0x6a74 <report_init_message>

    // Start Grbl main loop. Processes program inputs and executes them.
    protocol_main_loop();
     600:	0e 94 e1 17 	call	0x2fc2	; 0x2fc2 <protocol_main_loop>
     604:	c4 cf       	rjmp	.-120    	; 0x58e <main+0x40>

00000606 <mc_line>:
// NOTE: This is the primary gateway to the grbl planner. All line motions, including arc line
// segments, must pass through this routine before being passed to the planner. The seperation of
// mc_line and plan_buffer_line is done primarily to place non-planner-type functions from being
// in the planner and to let backlash compensation or canned cycle integration simple and direct.
void mc_line(float *target, plan_line_data_t *pl_data)
{
     606:	ef 92       	push	r14
     608:	ff 92       	push	r15
     60a:	0f 93       	push	r16
     60c:	1f 93       	push	r17
     60e:	cf 93       	push	r28
     610:	df 93       	push	r29
     612:	8c 01       	movw	r16, r24
     614:	7b 01       	movw	r14, r22
  // If enabled, check for soft limit violations. Placed here all line motions are picked up
  // from everywhere in Grbl.
  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
     616:	80 91 05 0f 	lds	r24, 0x0F05	; 0x800f05 <settings+0x45>
     61a:	85 ff       	sbrs	r24, 5
     61c:	07 c0       	rjmp	.+14     	; 0x62c <mc_line+0x26>
    // NOTE: Block jog state. Jogging is a special case and soft limits are handled independently.
    if (sys.state != STATE_JOG) { limits_soft_check(target); }
     61e:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
     622:	80 32       	cpi	r24, 0x20	; 32
     624:	39 f0       	breq	.+14     	; 0x634 <mc_line+0x2e>
     626:	c8 01       	movw	r24, r16
     628:	0e 94 80 32 	call	0x6500	; 0x6500 <limits_soft_check>
  }

  // If in check gcode mode, prevent motion by blocking planner. Soft limits still work.
  if (sys.state == STATE_CHECK_MODE) { return; }
     62c:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
     630:	82 30       	cpi	r24, 0x02	; 2
     632:	19 f1       	breq	.+70     	; 0x67a <mc_line+0x74>

  // If the buffer is full: good! That means we are well ahead of the robot.
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
    if (sys.abort) { return; } // Bail, if system abort.
     634:	c6 e1       	ldi	r28, 0x16	; 22
     636:	dc e0       	ldi	r29, 0x0C	; 12
  // parser and planner are separate from the system machine positions, this is doable.

  // If the buffer is full: good! That means we are well ahead of the robot.
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
     638:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail, if system abort.
     63c:	89 81       	ldd	r24, Y+1	; 0x01
     63e:	81 11       	cpse	r24, r1
     640:	1c c0       	rjmp	.+56     	; 0x67a <mc_line+0x74>
    if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffer is full.
     642:	0e 94 16 29 	call	0x522c	; 0x522c <plan_check_full_buffer>
     646:	88 23       	and	r24, r24
     648:	19 f0       	breq	.+6      	; 0x650 <mc_line+0x4a>
     64a:	0e 94 d3 14 	call	0x29a6	; 0x29a6 <protocol_auto_cycle_start>
    else { break; }
  } while (1);
     64e:	f4 cf       	rjmp	.-24     	; 0x638 <mc_line+0x32>

  // Plan and queue motion into planner buffer
  if (plan_buffer_line(target, pl_data) == PLAN_EMPTY_BLOCK) {
     650:	b7 01       	movw	r22, r14
     652:	c8 01       	movw	r24, r16
     654:	0e 94 54 2a 	call	0x54a8	; 0x54a8 <plan_buffer_line>
     658:	81 11       	cpse	r24, r1
     65a:	0f c0       	rjmp	.+30     	; 0x67a <mc_line+0x74>
    if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
     65c:	80 91 05 0f 	lds	r24, 0x0F05	; 0x800f05 <settings+0x45>
     660:	81 ff       	sbrs	r24, 1
     662:	0b c0       	rjmp	.+22     	; 0x67a <mc_line+0x74>
      // Correctly set spindle state, if there is a coincident position passed. Forces a buffer
      // sync while in M3 laser mode only.
      if (pl_data->condition & PL_COND_FLAG_SPINDLE_CW) {
     664:	f7 01       	movw	r30, r14
     666:	84 85       	ldd	r24, Z+12	; 0x0c
     668:	84 ff       	sbrs	r24, 4
     66a:	07 c0       	rjmp	.+14     	; 0x67a <mc_line+0x74>
        spindle_sync(PL_COND_FLAG_SPINDLE_CW, pl_data->spindle_speed);
     66c:	44 81       	ldd	r20, Z+4	; 0x04
     66e:	55 81       	ldd	r21, Z+5	; 0x05
     670:	66 81       	ldd	r22, Z+6	; 0x06
     672:	77 81       	ldd	r23, Z+7	; 0x07
     674:	80 e1       	ldi	r24, 0x10	; 16
     676:	0e 94 43 13 	call	0x2686	; 0x2686 <spindle_sync>
      }
    }
  }
}
     67a:	df 91       	pop	r29
     67c:	cf 91       	pop	r28
     67e:	1f 91       	pop	r17
     680:	0f 91       	pop	r16
     682:	ff 90       	pop	r15
     684:	ef 90       	pop	r14
     686:	08 95       	ret

00000688 <mc_arc>:
// The arc is approximated by generating a huge number of tiny, linear segments. The chordal tolerance
// of each segment is configured in settings.arc_tolerance, which is defined to be the maximum normal
// distance from segment to the circle when the end points both lie on the circle.
void mc_arc(float *target, plan_line_data_t *pl_data, float *position, float *offset, float radius,
  uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc)
{
     688:	2f 92       	push	r2
     68a:	3f 92       	push	r3
     68c:	4f 92       	push	r4
     68e:	5f 92       	push	r5
     690:	6f 92       	push	r6
     692:	7f 92       	push	r7
     694:	8f 92       	push	r8
     696:	9f 92       	push	r9
     698:	af 92       	push	r10
     69a:	bf 92       	push	r11
     69c:	cf 92       	push	r12
     69e:	df 92       	push	r13
     6a0:	ef 92       	push	r14
     6a2:	ff 92       	push	r15
     6a4:	0f 93       	push	r16
     6a6:	1f 93       	push	r17
     6a8:	cf 93       	push	r28
     6aa:	df 93       	push	r29
     6ac:	cd b7       	in	r28, 0x3d	; 61
     6ae:	de b7       	in	r29, 0x3e	; 62
     6b0:	e2 97       	sbiw	r28, 0x32	; 50
     6b2:	0f b6       	in	r0, 0x3f	; 63
     6b4:	f8 94       	cli
     6b6:	de bf       	out	0x3e, r29	; 62
     6b8:	0f be       	out	0x3f, r0	; 63
     6ba:	cd bf       	out	0x3d, r28	; 61
     6bc:	9a ab       	std	Y+50, r25	; 0x32
     6be:	89 ab       	std	Y+49, r24	; 0x31
     6c0:	78 8b       	std	Y+16, r23	; 0x10
     6c2:	6f 87       	std	Y+15, r22	; 0x0f
     6c4:	5e 87       	std	Y+14, r21	; 0x0e
     6c6:	4d 87       	std	Y+13, r20	; 0x0d
     6c8:	39 01       	movw	r6, r18
     6ca:	ed 82       	std	Y+5, r14	; 0x05
     6cc:	fe 82       	std	Y+6, r15	; 0x06
     6ce:	0f 83       	std	Y+7, r16	; 0x07
     6d0:	18 87       	std	Y+8, r17	; 0x08
     6d2:	89 8a       	std	Y+17, r8	; 0x11
  float center_axis0 = position[axis_0] + offset[axis_0];
     6d4:	d1 2c       	mov	r13, r1
     6d6:	cc 0c       	add	r12, r12
     6d8:	dd 1c       	adc	r13, r13
     6da:	cc 0c       	add	r12, r12
     6dc:	dd 1c       	adc	r13, r13
     6de:	ca 01       	movw	r24, r20
     6e0:	8c 0d       	add	r24, r12
     6e2:	9d 1d       	adc	r25, r13
     6e4:	9e 8b       	std	Y+22, r25	; 0x16
     6e6:	8d 8b       	std	Y+21, r24	; 0x15
     6e8:	d9 01       	movw	r26, r18
     6ea:	ac 0d       	add	r26, r12
     6ec:	bd 1d       	adc	r27, r13
     6ee:	be a7       	std	Y+46, r27	; 0x2e
     6f0:	ad a7       	std	Y+45, r26	; 0x2d
     6f2:	2d 90       	ld	r2, X+
     6f4:	3d 90       	ld	r3, X+
     6f6:	4d 90       	ld	r4, X+
     6f8:	5c 90       	ld	r5, X
     6fa:	fc 01       	movw	r30, r24
     6fc:	20 81       	ld	r18, Z
     6fe:	31 81       	ldd	r19, Z+1	; 0x01
     700:	42 81       	ldd	r20, Z+2	; 0x02
     702:	53 81       	ldd	r21, Z+3	; 0x03
     704:	c2 01       	movw	r24, r4
     706:	b1 01       	movw	r22, r2
     708:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
     70c:	6f 8b       	std	Y+23, r22	; 0x17
     70e:	78 8f       	std	Y+24, r23	; 0x18
     710:	89 8f       	std	Y+25, r24	; 0x19
     712:	9a 8f       	std	Y+26, r25	; 0x1a
  float center_axis1 = position[axis_1] + offset[axis_1];
     714:	0a 2d       	mov	r16, r10
     716:	10 e0       	ldi	r17, 0x00	; 0
     718:	00 0f       	add	r16, r16
     71a:	11 1f       	adc	r17, r17
     71c:	00 0f       	add	r16, r16
     71e:	11 1f       	adc	r17, r17
     720:	8d 85       	ldd	r24, Y+13	; 0x0d
     722:	9e 85       	ldd	r25, Y+14	; 0x0e
     724:	80 0f       	add	r24, r16
     726:	91 1f       	adc	r25, r17
     728:	9c 8f       	std	Y+28, r25	; 0x1c
     72a:	8b 8f       	std	Y+27, r24	; 0x1b
     72c:	d3 01       	movw	r26, r6
     72e:	a0 0f       	add	r26, r16
     730:	b1 1f       	adc	r27, r17
     732:	b8 ab       	std	Y+48, r27	; 0x30
     734:	af a7       	std	Y+47, r26	; 0x2f
     736:	8d 90       	ld	r8, X+
     738:	9d 90       	ld	r9, X+
     73a:	ad 90       	ld	r10, X+
     73c:	bc 90       	ld	r11, X
     73e:	fc 01       	movw	r30, r24
     740:	20 81       	ld	r18, Z
     742:	31 81       	ldd	r19, Z+1	; 0x01
     744:	42 81       	ldd	r20, Z+2	; 0x02
     746:	53 81       	ldd	r21, Z+3	; 0x03
     748:	c5 01       	movw	r24, r10
     74a:	b4 01       	movw	r22, r8
     74c:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
     750:	6d 8f       	std	Y+29, r22	; 0x1d
     752:	7e 8f       	std	Y+30, r23	; 0x1e
     754:	8f 8f       	std	Y+31, r24	; 0x1f
     756:	98 a3       	std	Y+32, r25	; 0x20
  float r_axis0 = -offset[axis_0];  // Radius vector from center to current location
     758:	d2 01       	movw	r26, r4
     75a:	c1 01       	movw	r24, r2
     75c:	b0 58       	subi	r27, 0x80	; 128
     75e:	89 83       	std	Y+1, r24	; 0x01
     760:	9a 83       	std	Y+2, r25	; 0x02
     762:	ab 83       	std	Y+3, r26	; 0x03
     764:	bc 83       	std	Y+4, r27	; 0x04
  float r_axis1 = -offset[axis_1];
     766:	d5 01       	movw	r26, r10
     768:	c4 01       	movw	r24, r8
     76a:	b0 58       	subi	r27, 0x80	; 128
     76c:	89 87       	std	Y+9, r24	; 0x09
     76e:	9a 87       	std	Y+10, r25	; 0x0a
     770:	ab 87       	std	Y+11, r26	; 0x0b
     772:	bc 87       	std	Y+12, r27	; 0x0c
  float rt_axis0 = target[axis_0] - center_axis0;
     774:	e9 a9       	ldd	r30, Y+49	; 0x31
     776:	fa a9       	ldd	r31, Y+50	; 0x32
     778:	ec 0d       	add	r30, r12
     77a:	fd 1d       	adc	r31, r13
     77c:	2f 89       	ldd	r18, Y+23	; 0x17
     77e:	38 8d       	ldd	r19, Y+24	; 0x18
     780:	49 8d       	ldd	r20, Y+25	; 0x19
     782:	5a 8d       	ldd	r21, Y+26	; 0x1a
     784:	60 81       	ld	r22, Z
     786:	71 81       	ldd	r23, Z+1	; 0x01
     788:	82 81       	ldd	r24, Z+2	; 0x02
     78a:	93 81       	ldd	r25, Z+3	; 0x03
     78c:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
     790:	6b 01       	movw	r12, r22
     792:	7c 01       	movw	r14, r24
  float rt_axis1 = target[axis_1] - center_axis1;
     794:	e9 a9       	ldd	r30, Y+49	; 0x31
     796:	fa a9       	ldd	r31, Y+50	; 0x32
     798:	e0 0f       	add	r30, r16
     79a:	f1 1f       	adc	r31, r17
     79c:	2d 8d       	ldd	r18, Y+29	; 0x1d
     79e:	3e 8d       	ldd	r19, Y+30	; 0x1e
     7a0:	4f 8d       	ldd	r20, Y+31	; 0x1f
     7a2:	58 a1       	ldd	r21, Y+32	; 0x20
     7a4:	60 81       	ld	r22, Z
     7a6:	71 81       	ldd	r23, Z+1	; 0x01
     7a8:	82 81       	ldd	r24, Z+2	; 0x02
     7aa:	93 81       	ldd	r25, Z+3	; 0x03
     7ac:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
     7b0:	4b 01       	movw	r8, r22
     7b2:	5c 01       	movw	r10, r24

  // CCW angle between position and target from circle center. Only one atan2() trig computation required.
  float angular_travel = atan2(r_axis0*rt_axis1-r_axis1*rt_axis0, r_axis0*rt_axis0+r_axis1*rt_axis1);
     7b4:	a7 01       	movw	r20, r14
     7b6:	96 01       	movw	r18, r12
     7b8:	69 81       	ldd	r22, Y+1	; 0x01
     7ba:	7a 81       	ldd	r23, Y+2	; 0x02
     7bc:	8b 81       	ldd	r24, Y+3	; 0x03
     7be:	9c 81       	ldd	r25, Y+4	; 0x04
     7c0:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     7c4:	2b 01       	movw	r4, r22
     7c6:	3c 01       	movw	r6, r24
     7c8:	a5 01       	movw	r20, r10
     7ca:	94 01       	movw	r18, r8
     7cc:	69 85       	ldd	r22, Y+9	; 0x09
     7ce:	7a 85       	ldd	r23, Y+10	; 0x0a
     7d0:	8b 85       	ldd	r24, Y+11	; 0x0b
     7d2:	9c 85       	ldd	r25, Y+12	; 0x0c
     7d4:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     7d8:	9b 01       	movw	r18, r22
     7da:	ac 01       	movw	r20, r24
     7dc:	c3 01       	movw	r24, r6
     7de:	b2 01       	movw	r22, r4
     7e0:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
     7e4:	2b 01       	movw	r4, r22
     7e6:	3c 01       	movw	r6, r24
     7e8:	a5 01       	movw	r20, r10
     7ea:	94 01       	movw	r18, r8
     7ec:	69 81       	ldd	r22, Y+1	; 0x01
     7ee:	7a 81       	ldd	r23, Y+2	; 0x02
     7f0:	8b 81       	ldd	r24, Y+3	; 0x03
     7f2:	9c 81       	ldd	r25, Y+4	; 0x04
     7f4:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     7f8:	4b 01       	movw	r8, r22
     7fa:	5c 01       	movw	r10, r24
     7fc:	a7 01       	movw	r20, r14
     7fe:	96 01       	movw	r18, r12
     800:	69 85       	ldd	r22, Y+9	; 0x09
     802:	7a 85       	ldd	r23, Y+10	; 0x0a
     804:	8b 85       	ldd	r24, Y+11	; 0x0b
     806:	9c 85       	ldd	r25, Y+12	; 0x0c
     808:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     80c:	9b 01       	movw	r18, r22
     80e:	ac 01       	movw	r20, r24
     810:	c5 01       	movw	r24, r10
     812:	b4 01       	movw	r22, r8
     814:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
     818:	a3 01       	movw	r20, r6
     81a:	92 01       	movw	r18, r4
     81c:	0e 94 5f 3e 	call	0x7cbe	; 0x7cbe <atan2>
     820:	4b 01       	movw	r8, r22
     822:	5c 01       	movw	r10, r24
  if (is_clockwise_arc) { // Correct atan2 output per direction
     824:	29 96       	adiw	r28, 0x09	; 9
     826:	8f ad       	ldd	r24, Y+63	; 0x3f
     828:	29 97       	sbiw	r28, 0x09	; 9
     82a:	88 23       	and	r24, r24
     82c:	a9 f0       	breq	.+42     	; 0x858 <mc_arc+0x1d0>
    if (angular_travel >= -ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel -= 2*M_PI; }
     82e:	2d eb       	ldi	r18, 0xBD	; 189
     830:	37 e3       	ldi	r19, 0x37	; 55
     832:	46 e0       	ldi	r20, 0x06	; 6
     834:	55 eb       	ldi	r21, 0xB5	; 181
     836:	c5 01       	movw	r24, r10
     838:	b4 01       	movw	r22, r8
     83a:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
     83e:	88 23       	and	r24, r24
     840:	fc f0       	brlt	.+62     	; 0x880 <mc_arc+0x1f8>
     842:	2b ed       	ldi	r18, 0xDB	; 219
     844:	3f e0       	ldi	r19, 0x0F	; 15
     846:	49 ec       	ldi	r20, 0xC9	; 201
     848:	50 e4       	ldi	r21, 0x40	; 64
     84a:	c5 01       	movw	r24, r10
     84c:	b4 01       	movw	r22, r8
     84e:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
     852:	4b 01       	movw	r8, r22
     854:	5c 01       	movw	r10, r24
     856:	14 c0       	rjmp	.+40     	; 0x880 <mc_arc+0x1f8>
  } else {
    if (angular_travel <= ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel += 2*M_PI; }
     858:	2d eb       	ldi	r18, 0xBD	; 189
     85a:	37 e3       	ldi	r19, 0x37	; 55
     85c:	46 e0       	ldi	r20, 0x06	; 6
     85e:	55 e3       	ldi	r21, 0x35	; 53
     860:	c5 01       	movw	r24, r10
     862:	b4 01       	movw	r22, r8
     864:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
     868:	18 16       	cp	r1, r24
     86a:	54 f0       	brlt	.+20     	; 0x880 <mc_arc+0x1f8>
     86c:	2b ed       	ldi	r18, 0xDB	; 219
     86e:	3f e0       	ldi	r19, 0x0F	; 15
     870:	49 ec       	ldi	r20, 0xC9	; 201
     872:	50 e4       	ldi	r21, 0x40	; 64
     874:	c5 01       	movw	r24, r10
     876:	b4 01       	movw	r22, r8
     878:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
     87c:	4b 01       	movw	r8, r22
     87e:	5c 01       	movw	r10, r24
  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
     880:	c0 90 f9 0e 	lds	r12, 0x0EF9	; 0x800ef9 <settings+0x39>
     884:	d0 90 fa 0e 	lds	r13, 0x0EFA	; 0x800efa <settings+0x3a>
     888:	e0 90 fb 0e 	lds	r14, 0x0EFB	; 0x800efb <settings+0x3b>
     88c:	f0 90 fc 0e 	lds	r15, 0x0EFC	; 0x800efc <settings+0x3c>
     890:	2d 81       	ldd	r18, Y+5	; 0x05
     892:	3e 81       	ldd	r19, Y+6	; 0x06
     894:	4f 81       	ldd	r20, Y+7	; 0x07
     896:	58 85       	ldd	r21, Y+8	; 0x08
     898:	ca 01       	movw	r24, r20
     89a:	b9 01       	movw	r22, r18
     89c:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
     8a0:	2b 01       	movw	r4, r22
     8a2:	3c 01       	movw	r6, r24
     8a4:	a7 01       	movw	r20, r14
     8a6:	96 01       	movw	r18, r12
     8a8:	c3 01       	movw	r24, r6
     8aa:	b2 01       	movw	r22, r4
     8ac:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
     8b0:	a7 01       	movw	r20, r14
     8b2:	96 01       	movw	r18, r12
     8b4:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     8b8:	0e 94 90 41 	call	0x8320	; 0x8320 <sqrt>
     8bc:	6b 01       	movw	r12, r22
     8be:	7c 01       	movw	r14, r24

  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
     8c0:	20 e0       	ldi	r18, 0x00	; 0
     8c2:	30 e0       	ldi	r19, 0x00	; 0
     8c4:	40 e0       	ldi	r20, 0x00	; 0
     8c6:	5f e3       	ldi	r21, 0x3F	; 63
     8c8:	c5 01       	movw	r24, r10
     8ca:	b4 01       	movw	r22, r8
     8cc:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     8d0:	2d 81       	ldd	r18, Y+5	; 0x05
     8d2:	3e 81       	ldd	r19, Y+6	; 0x06
     8d4:	4f 81       	ldd	r20, Y+7	; 0x07
     8d6:	58 85       	ldd	r21, Y+8	; 0x08
     8d8:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     8dc:	9f 77       	andi	r25, 0x7F	; 127
     8de:	a7 01       	movw	r20, r14
     8e0:	96 01       	movw	r18, r12
     8e2:	0e 94 cc 3e 	call	0x7d98	; 0x7d98 <__divsf3>
     8e6:	0e 94 a2 3f 	call	0x7f44	; 0x7f44 <floor>
     8ea:	0e 94 39 3f 	call	0x7e72	; 0x7e72 <__fixunssfsi>
     8ee:	6b 01       	movw	r12, r22
     8f0:	7c 01       	movw	r14, r24
     8f2:	3b 01       	movw	r6, r22
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );

  if (segments) {
     8f4:	61 15       	cp	r22, r1
     8f6:	71 05       	cpc	r23, r1
     8f8:	09 f4       	brne	.+2      	; 0x8fc <mc_arc+0x274>
     8fa:	87 c1       	rjmp	.+782    	; 0xc0a <mc_arc+0x582>
    // Multiply inverse feed_rate to compensate for the fact that this movement is approximated
    // by a number of discrete segments. The inverse feed_rate should be correct for the sum of
    // all segments.
    if (pl_data->condition & PL_COND_FLAG_INVERSE_TIME) { 
     8fc:	af 85       	ldd	r26, Y+15	; 0x0f
     8fe:	b8 89       	ldd	r27, Y+16	; 0x10
     900:	1c 96       	adiw	r26, 0x0c	; 12
     902:	1c 91       	ld	r17, X
     904:	13 ff       	sbrs	r17, 3
     906:	18 c0       	rjmp	.+48     	; 0x938 <mc_arc+0x2b0>
      pl_data->feed_rate *= segments; 
     908:	80 e0       	ldi	r24, 0x00	; 0
     90a:	90 e0       	ldi	r25, 0x00	; 0
     90c:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__floatunsisf>
     910:	9b 01       	movw	r18, r22
     912:	ac 01       	movw	r20, r24
     914:	ef 85       	ldd	r30, Y+15	; 0x0f
     916:	f8 89       	ldd	r31, Y+16	; 0x10
     918:	60 81       	ld	r22, Z
     91a:	71 81       	ldd	r23, Z+1	; 0x01
     91c:	82 81       	ldd	r24, Z+2	; 0x02
     91e:	93 81       	ldd	r25, Z+3	; 0x03
     920:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     924:	af 85       	ldd	r26, Y+15	; 0x0f
     926:	b8 89       	ldd	r27, Y+16	; 0x10
     928:	6d 93       	st	X+, r22
     92a:	7d 93       	st	X+, r23
     92c:	8d 93       	st	X+, r24
     92e:	9c 93       	st	X, r25
     930:	13 97       	sbiw	r26, 0x03	; 3
      bit_false(pl_data->condition,PL_COND_FLAG_INVERSE_TIME); // Force as feed absolute mode over arc segments.
     932:	17 7f       	andi	r17, 0xF7	; 247
     934:	1c 96       	adiw	r26, 0x0c	; 12
     936:	1c 93       	st	X, r17
    }
    
    float theta_per_segment = angular_travel/segments;
     938:	b6 01       	movw	r22, r12
     93a:	80 e0       	ldi	r24, 0x00	; 0
     93c:	90 e0       	ldi	r25, 0x00	; 0
     93e:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__floatunsisf>
     942:	6b 01       	movw	r12, r22
     944:	7c 01       	movw	r14, r24
     946:	9b 01       	movw	r18, r22
     948:	ac 01       	movw	r20, r24
     94a:	c5 01       	movw	r24, r10
     94c:	b4 01       	movw	r22, r8
     94e:	0e 94 cc 3e 	call	0x7d98	; 0x7d98 <__divsf3>
     952:	69 a7       	std	Y+41, r22	; 0x29
     954:	7a a7       	std	Y+42, r23	; 0x2a
     956:	8b a7       	std	Y+43, r24	; 0x2b
     958:	9c a7       	std	Y+44, r25	; 0x2c
    float linear_per_segment = (target[axis_linear] - position[axis_linear])/segments;
     95a:	b9 89       	ldd	r27, Y+17	; 0x11
     95c:	8b 2e       	mov	r8, r27
     95e:	91 2c       	mov	r9, r1
     960:	88 0c       	add	r8, r8
     962:	99 1c       	adc	r9, r9
     964:	88 0c       	add	r8, r8
     966:	99 1c       	adc	r9, r9
     968:	4d 84       	ldd	r4, Y+13	; 0x0d
     96a:	5e 84       	ldd	r5, Y+14	; 0x0e
     96c:	48 0c       	add	r4, r8
     96e:	59 1c       	adc	r5, r9
     970:	e9 a9       	ldd	r30, Y+49	; 0x31
     972:	fa a9       	ldd	r31, Y+50	; 0x32
     974:	e8 0d       	add	r30, r8
     976:	f9 1d       	adc	r31, r9
     978:	d2 01       	movw	r26, r4
     97a:	2d 91       	ld	r18, X+
     97c:	3d 91       	ld	r19, X+
     97e:	4d 91       	ld	r20, X+
     980:	5c 91       	ld	r21, X
     982:	60 81       	ld	r22, Z
     984:	71 81       	ldd	r23, Z+1	; 0x01
     986:	82 81       	ldd	r24, Z+2	; 0x02
     988:	93 81       	ldd	r25, Z+3	; 0x03
     98a:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
     98e:	a7 01       	movw	r20, r14
     990:	96 01       	movw	r18, r12
     992:	0e 94 cc 3e 	call	0x7d98	; 0x7d98 <__divsf3>
     996:	69 8b       	std	Y+17, r22	; 0x11
     998:	7a 8b       	std	Y+18, r23	; 0x12
     99a:	8b 8b       	std	Y+19, r24	; 0x13
     99c:	9c 8b       	std	Y+20, r25	; 0x14
       without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
       a correction, the planner should have caught up to the lag caused by the initial mc_arc overhead.
       This is important when there are successive arc motions.
    */
    // Computes: cos_T = 1 - theta_per_segment^2/2, sin_T = theta_per_segment - theta_per_segment^3/6) in ~52usec
    float cos_T = 2.0 - theta_per_segment*theta_per_segment;
     99e:	29 a5       	ldd	r18, Y+41	; 0x29
     9a0:	3a a5       	ldd	r19, Y+42	; 0x2a
     9a2:	4b a5       	ldd	r20, Y+43	; 0x2b
     9a4:	5c a5       	ldd	r21, Y+44	; 0x2c
     9a6:	ca 01       	movw	r24, r20
     9a8:	b9 01       	movw	r22, r18
     9aa:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     9ae:	9b 01       	movw	r18, r22
     9b0:	ac 01       	movw	r20, r24
     9b2:	60 e0       	ldi	r22, 0x00	; 0
     9b4:	70 e0       	ldi	r23, 0x00	; 0
     9b6:	80 e0       	ldi	r24, 0x00	; 0
     9b8:	90 e4       	ldi	r25, 0x40	; 64
     9ba:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
     9be:	6b 01       	movw	r12, r22
     9c0:	7c 01       	movw	r14, r24
    float sin_T = theta_per_segment*0.16666667*(cos_T + 4.0);
     9c2:	2b ea       	ldi	r18, 0xAB	; 171
     9c4:	3a ea       	ldi	r19, 0xAA	; 170
     9c6:	4a e2       	ldi	r20, 0x2A	; 42
     9c8:	5e e3       	ldi	r21, 0x3E	; 62
     9ca:	69 a5       	ldd	r22, Y+41	; 0x29
     9cc:	7a a5       	ldd	r23, Y+42	; 0x2a
     9ce:	8b a5       	ldd	r24, Y+43	; 0x2b
     9d0:	9c a5       	ldd	r25, Y+44	; 0x2c
     9d2:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     9d6:	4b 01       	movw	r8, r22
     9d8:	5c 01       	movw	r10, r24
     9da:	20 e0       	ldi	r18, 0x00	; 0
     9dc:	30 e0       	ldi	r19, 0x00	; 0
     9de:	40 e8       	ldi	r20, 0x80	; 128
     9e0:	50 e4       	ldi	r21, 0x40	; 64
     9e2:	c7 01       	movw	r24, r14
     9e4:	b6 01       	movw	r22, r12
     9e6:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
     9ea:	9b 01       	movw	r18, r22
     9ec:	ac 01       	movw	r20, r24
     9ee:	c5 01       	movw	r24, r10
     9f0:	b4 01       	movw	r22, r8
     9f2:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     9f6:	69 a3       	std	Y+33, r22	; 0x21
     9f8:	7a a3       	std	Y+34, r23	; 0x22
     9fa:	8b a3       	std	Y+35, r24	; 0x23
     9fc:	9c a3       	std	Y+36, r25	; 0x24
    cos_T *= 0.5;
     9fe:	20 e0       	ldi	r18, 0x00	; 0
     a00:	30 e0       	ldi	r19, 0x00	; 0
     a02:	40 e0       	ldi	r20, 0x00	; 0
     a04:	5f e3       	ldi	r21, 0x3F	; 63
     a06:	c7 01       	movw	r24, r14
     a08:	b6 01       	movw	r22, r12
     a0a:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     a0e:	6d a3       	std	Y+37, r22	; 0x25
     a10:	7e a3       	std	Y+38, r23	; 0x26
     a12:	8f a3       	std	Y+39, r24	; 0x27
     a14:	98 a7       	std	Y+40, r25	; 0x28
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;

    for (i = 1; i<segments; i++) { // Increment (segments-1).
     a16:	b2 e0       	ldi	r27, 0x02	; 2
     a18:	6b 16       	cp	r6, r27
     a1a:	71 04       	cpc	r7, r1
     a1c:	08 f4       	brcc	.+2      	; 0xa20 <mc_arc+0x398>
     a1e:	f5 c0       	rjmp	.+490    	; 0xc0a <mc_arc+0x582>
     a20:	10 e0       	ldi	r17, 0x00	; 0
     a22:	22 24       	eor	r2, r2
     a24:	23 94       	inc	r2
     a26:	31 2c       	mov	r3, r1
      position[axis_linear] += linear_per_segment;

      mc_line(position, pl_data);

      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
     a28:	c9 84       	ldd	r12, Y+9	; 0x09
     a2a:	da 84       	ldd	r13, Y+10	; 0x0a
     a2c:	eb 84       	ldd	r14, Y+11	; 0x0b
     a2e:	fc 84       	ldd	r15, Y+12	; 0x0c
    uint16_t i;
    uint8_t count = 0;

    for (i = 1; i<segments; i++) { // Increment (segments-1).

      if (count < N_ARC_CORRECTION) {
     a30:	1c 30       	cpi	r17, 0x0C	; 12
     a32:	08 f0       	brcs	.+2      	; 0xa36 <mc_arc+0x3ae>
     a34:	44 c0       	rjmp	.+136    	; 0xabe <mc_arc+0x436>
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
     a36:	a7 01       	movw	r20, r14
     a38:	96 01       	movw	r18, r12
     a3a:	6d a1       	ldd	r22, Y+37	; 0x25
     a3c:	7e a1       	ldd	r23, Y+38	; 0x26
     a3e:	8f a1       	ldd	r24, Y+39	; 0x27
     a40:	98 a5       	ldd	r25, Y+40	; 0x28
     a42:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     a46:	4b 01       	movw	r8, r22
     a48:	5c 01       	movw	r10, r24
     a4a:	29 81       	ldd	r18, Y+1	; 0x01
     a4c:	3a 81       	ldd	r19, Y+2	; 0x02
     a4e:	4b 81       	ldd	r20, Y+3	; 0x03
     a50:	5c 81       	ldd	r21, Y+4	; 0x04
     a52:	69 a1       	ldd	r22, Y+33	; 0x21
     a54:	7a a1       	ldd	r23, Y+34	; 0x22
     a56:	8b a1       	ldd	r24, Y+35	; 0x23
     a58:	9c a1       	ldd	r25, Y+36	; 0x24
     a5a:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     a5e:	a5 01       	movw	r20, r10
     a60:	94 01       	movw	r18, r8
     a62:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
     a66:	96 2e       	mov	r9, r22
     a68:	a7 2e       	mov	r10, r23
     a6a:	b8 2e       	mov	r11, r24
     a6c:	09 2f       	mov	r16, r25
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
     a6e:	29 81       	ldd	r18, Y+1	; 0x01
     a70:	3a 81       	ldd	r19, Y+2	; 0x02
     a72:	4b 81       	ldd	r20, Y+3	; 0x03
     a74:	5c 81       	ldd	r21, Y+4	; 0x04
     a76:	6d a1       	ldd	r22, Y+37	; 0x25
     a78:	7e a1       	ldd	r23, Y+38	; 0x26
     a7a:	8f a1       	ldd	r24, Y+39	; 0x27
     a7c:	98 a5       	ldd	r25, Y+40	; 0x28
     a7e:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     a82:	69 83       	std	Y+1, r22	; 0x01
     a84:	7a 83       	std	Y+2, r23	; 0x02
     a86:	8b 83       	std	Y+3, r24	; 0x03
     a88:	9c 83       	std	Y+4, r25	; 0x04
     a8a:	a7 01       	movw	r20, r14
     a8c:	96 01       	movw	r18, r12
     a8e:	69 a1       	ldd	r22, Y+33	; 0x21
     a90:	7a a1       	ldd	r23, Y+34	; 0x22
     a92:	8b a1       	ldd	r24, Y+35	; 0x23
     a94:	9c a1       	ldd	r25, Y+36	; 0x24
     a96:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     a9a:	9b 01       	movw	r18, r22
     a9c:	ac 01       	movw	r20, r24
     a9e:	69 81       	ldd	r22, Y+1	; 0x01
     aa0:	7a 81       	ldd	r23, Y+2	; 0x02
     aa2:	8b 81       	ldd	r24, Y+3	; 0x03
     aa4:	9c 81       	ldd	r25, Y+4	; 0x04
     aa6:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
     aaa:	69 83       	std	Y+1, r22	; 0x01
     aac:	7a 83       	std	Y+2, r23	; 0x02
     aae:	8b 83       	std	Y+3, r24	; 0x03
     ab0:	9c 83       	std	Y+4, r25	; 0x04
        r_axis1 = r_axisi;
        count++;
     ab2:	1f 5f       	subi	r17, 0xFF	; 255

      if (count < N_ARC_CORRECTION) {
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
        r_axis1 = r_axisi;
     ab4:	c9 2c       	mov	r12, r9
     ab6:	da 2c       	mov	r13, r10
     ab8:	eb 2c       	mov	r14, r11
     aba:	f0 2e       	mov	r15, r16
     abc:	66 c0       	rjmp	.+204    	; 0xb8a <mc_arc+0x502>
        count++;
      } else {
        // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments. ~375 usec
        // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
        cos_Ti = cos(i*theta_per_segment);
     abe:	b1 01       	movw	r22, r2
     ac0:	80 e0       	ldi	r24, 0x00	; 0
     ac2:	90 e0       	ldi	r25, 0x00	; 0
     ac4:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__floatunsisf>
     ac8:	29 a5       	ldd	r18, Y+41	; 0x29
     aca:	3a a5       	ldd	r19, Y+42	; 0x2a
     acc:	4b a5       	ldd	r20, Y+43	; 0x2b
     ace:	5c a5       	ldd	r21, Y+44	; 0x2c
     ad0:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     ad4:	6b 01       	movw	r12, r22
     ad6:	7c 01       	movw	r14, r24
     ad8:	0e 94 c9 3e 	call	0x7d92	; 0x7d92 <cos>
     adc:	6d 83       	std	Y+5, r22	; 0x05
     ade:	7e 83       	std	Y+6, r23	; 0x06
     ae0:	8f 83       	std	Y+7, r24	; 0x07
     ae2:	98 87       	std	Y+8, r25	; 0x08
        sin_Ti = sin(i*theta_per_segment);
     ae4:	c7 01       	movw	r24, r14
     ae6:	b6 01       	movw	r22, r12
     ae8:	0e 94 86 41 	call	0x830c	; 0x830c <sin>
     aec:	69 87       	std	Y+9, r22	; 0x09
     aee:	7a 87       	std	Y+10, r23	; 0x0a
     af0:	8b 87       	std	Y+11, r24	; 0x0b
     af2:	9c 87       	std	Y+12, r25	; 0x0c
        r_axis0 = -offset[axis_0]*cos_Ti + offset[axis_1]*sin_Ti;
     af4:	ed a5       	ldd	r30, Y+45	; 0x2d
     af6:	fe a5       	ldd	r31, Y+46	; 0x2e
     af8:	c0 80       	ld	r12, Z
     afa:	d1 80       	ldd	r13, Z+1	; 0x01
     afc:	e2 80       	ldd	r14, Z+2	; 0x02
     afe:	f3 80       	ldd	r15, Z+3	; 0x03
     b00:	f7 fa       	bst	r15, 7
     b02:	f0 94       	com	r15
     b04:	f7 f8       	bld	r15, 7
     b06:	f0 94       	com	r15
     b08:	af a5       	ldd	r26, Y+47	; 0x2f
     b0a:	b8 a9       	ldd	r27, Y+48	; 0x30
     b0c:	8d 90       	ld	r8, X+
     b0e:	9d 90       	ld	r9, X+
     b10:	ad 90       	ld	r10, X+
     b12:	bc 90       	ld	r11, X
     b14:	a7 01       	movw	r20, r14
     b16:	96 01       	movw	r18, r12
     b18:	6d 81       	ldd	r22, Y+5	; 0x05
     b1a:	7e 81       	ldd	r23, Y+6	; 0x06
     b1c:	8f 81       	ldd	r24, Y+7	; 0x07
     b1e:	98 85       	ldd	r25, Y+8	; 0x08
     b20:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     b24:	69 83       	std	Y+1, r22	; 0x01
     b26:	7a 83       	std	Y+2, r23	; 0x02
     b28:	8b 83       	std	Y+3, r24	; 0x03
     b2a:	9c 83       	std	Y+4, r25	; 0x04
     b2c:	a5 01       	movw	r20, r10
     b2e:	94 01       	movw	r18, r8
     b30:	69 85       	ldd	r22, Y+9	; 0x09
     b32:	7a 85       	ldd	r23, Y+10	; 0x0a
     b34:	8b 85       	ldd	r24, Y+11	; 0x0b
     b36:	9c 85       	ldd	r25, Y+12	; 0x0c
     b38:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     b3c:	9b 01       	movw	r18, r22
     b3e:	ac 01       	movw	r20, r24
     b40:	69 81       	ldd	r22, Y+1	; 0x01
     b42:	7a 81       	ldd	r23, Y+2	; 0x02
     b44:	8b 81       	ldd	r24, Y+3	; 0x03
     b46:	9c 81       	ldd	r25, Y+4	; 0x04
     b48:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
     b4c:	69 83       	std	Y+1, r22	; 0x01
     b4e:	7a 83       	std	Y+2, r23	; 0x02
     b50:	8b 83       	std	Y+3, r24	; 0x03
     b52:	9c 83       	std	Y+4, r25	; 0x04
        r_axis1 = -offset[axis_0]*sin_Ti - offset[axis_1]*cos_Ti;
     b54:	a7 01       	movw	r20, r14
     b56:	96 01       	movw	r18, r12
     b58:	69 85       	ldd	r22, Y+9	; 0x09
     b5a:	7a 85       	ldd	r23, Y+10	; 0x0a
     b5c:	8b 85       	ldd	r24, Y+11	; 0x0b
     b5e:	9c 85       	ldd	r25, Y+12	; 0x0c
     b60:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     b64:	6b 01       	movw	r12, r22
     b66:	7c 01       	movw	r14, r24
     b68:	a5 01       	movw	r20, r10
     b6a:	94 01       	movw	r18, r8
     b6c:	6d 81       	ldd	r22, Y+5	; 0x05
     b6e:	7e 81       	ldd	r23, Y+6	; 0x06
     b70:	8f 81       	ldd	r24, Y+7	; 0x07
     b72:	98 85       	ldd	r25, Y+8	; 0x08
     b74:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     b78:	9b 01       	movw	r18, r22
     b7a:	ac 01       	movw	r20, r24
     b7c:	c7 01       	movw	r24, r14
     b7e:	b6 01       	movw	r22, r12
     b80:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
     b84:	6b 01       	movw	r12, r22
     b86:	7c 01       	movw	r14, r24
        count = 0;
     b88:	10 e0       	ldi	r17, 0x00	; 0
      }

      // Update arc_target location
      position[axis_0] = center_axis0 + r_axis0;
     b8a:	2f 89       	ldd	r18, Y+23	; 0x17
     b8c:	38 8d       	ldd	r19, Y+24	; 0x18
     b8e:	49 8d       	ldd	r20, Y+25	; 0x19
     b90:	5a 8d       	ldd	r21, Y+26	; 0x1a
     b92:	69 81       	ldd	r22, Y+1	; 0x01
     b94:	7a 81       	ldd	r23, Y+2	; 0x02
     b96:	8b 81       	ldd	r24, Y+3	; 0x03
     b98:	9c 81       	ldd	r25, Y+4	; 0x04
     b9a:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
     b9e:	ed 89       	ldd	r30, Y+21	; 0x15
     ba0:	fe 89       	ldd	r31, Y+22	; 0x16
     ba2:	60 83       	st	Z, r22
     ba4:	71 83       	std	Z+1, r23	; 0x01
     ba6:	82 83       	std	Z+2, r24	; 0x02
     ba8:	93 83       	std	Z+3, r25	; 0x03
      position[axis_1] = center_axis1 + r_axis1;
     baa:	2d 8d       	ldd	r18, Y+29	; 0x1d
     bac:	3e 8d       	ldd	r19, Y+30	; 0x1e
     bae:	4f 8d       	ldd	r20, Y+31	; 0x1f
     bb0:	58 a1       	ldd	r21, Y+32	; 0x20
     bb2:	c7 01       	movw	r24, r14
     bb4:	b6 01       	movw	r22, r12
     bb6:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
     bba:	ab 8d       	ldd	r26, Y+27	; 0x1b
     bbc:	bc 8d       	ldd	r27, Y+28	; 0x1c
     bbe:	6d 93       	st	X+, r22
     bc0:	7d 93       	st	X+, r23
     bc2:	8d 93       	st	X+, r24
     bc4:	9c 93       	st	X, r25
     bc6:	13 97       	sbiw	r26, 0x03	; 3
      position[axis_linear] += linear_per_segment;
     bc8:	29 89       	ldd	r18, Y+17	; 0x11
     bca:	3a 89       	ldd	r19, Y+18	; 0x12
     bcc:	4b 89       	ldd	r20, Y+19	; 0x13
     bce:	5c 89       	ldd	r21, Y+20	; 0x14
     bd0:	f2 01       	movw	r30, r4
     bd2:	60 81       	ld	r22, Z
     bd4:	71 81       	ldd	r23, Z+1	; 0x01
     bd6:	82 81       	ldd	r24, Z+2	; 0x02
     bd8:	93 81       	ldd	r25, Z+3	; 0x03
     bda:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
     bde:	d2 01       	movw	r26, r4
     be0:	6d 93       	st	X+, r22
     be2:	7d 93       	st	X+, r23
     be4:	8d 93       	st	X+, r24
     be6:	9c 93       	st	X, r25
     be8:	13 97       	sbiw	r26, 0x03	; 3

      mc_line(position, pl_data);
     bea:	6f 85       	ldd	r22, Y+15	; 0x0f
     bec:	78 89       	ldd	r23, Y+16	; 0x10
     bee:	8d 85       	ldd	r24, Y+13	; 0x0d
     bf0:	9e 85       	ldd	r25, Y+14	; 0x0e
     bf2:	09 dd       	rcall	.-1518   	; 0x606 <mc_line>

      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
     bf4:	80 91 17 0c 	lds	r24, 0x0C17	; 0x800c17 <sys+0x1>
     bf8:	81 11       	cpse	r24, r1
     bfa:	0c c0       	rjmp	.+24     	; 0xc14 <mc_arc+0x58c>
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;

    for (i = 1; i<segments; i++) { // Increment (segments-1).
     bfc:	bf ef       	ldi	r27, 0xFF	; 255
     bfe:	2b 1a       	sub	r2, r27
     c00:	3b 0a       	sbc	r3, r27
     c02:	62 14       	cp	r6, r2
     c04:	73 04       	cpc	r7, r3
     c06:	09 f0       	breq	.+2      	; 0xc0a <mc_arc+0x582>
     c08:	13 cf       	rjmp	.-474    	; 0xa30 <mc_arc+0x3a8>
      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
    }
  }
  // Ensure last segment arrives at target location.
  mc_line(target, pl_data);
     c0a:	6f 85       	ldd	r22, Y+15	; 0x0f
     c0c:	78 89       	ldd	r23, Y+16	; 0x10
     c0e:	89 a9       	ldd	r24, Y+49	; 0x31
     c10:	9a a9       	ldd	r25, Y+50	; 0x32
     c12:	f9 dc       	rcall	.-1550   	; 0x606 <mc_line>
}
     c14:	e2 96       	adiw	r28, 0x32	; 50
     c16:	0f b6       	in	r0, 0x3f	; 63
     c18:	f8 94       	cli
     c1a:	de bf       	out	0x3e, r29	; 62
     c1c:	0f be       	out	0x3f, r0	; 63
     c1e:	cd bf       	out	0x3d, r28	; 61
     c20:	df 91       	pop	r29
     c22:	cf 91       	pop	r28
     c24:	1f 91       	pop	r17
     c26:	0f 91       	pop	r16
     c28:	ff 90       	pop	r15
     c2a:	ef 90       	pop	r14
     c2c:	df 90       	pop	r13
     c2e:	cf 90       	pop	r12
     c30:	bf 90       	pop	r11
     c32:	af 90       	pop	r10
     c34:	9f 90       	pop	r9
     c36:	8f 90       	pop	r8
     c38:	7f 90       	pop	r7
     c3a:	6f 90       	pop	r6
     c3c:	5f 90       	pop	r5
     c3e:	4f 90       	pop	r4
     c40:	3f 90       	pop	r3
     c42:	2f 90       	pop	r2
     c44:	08 95       	ret

00000c46 <mc_dwell>:


// Execute dwell in seconds.
void mc_dwell(float seconds)
{
     c46:	cf 92       	push	r12
     c48:	df 92       	push	r13
     c4a:	ef 92       	push	r14
     c4c:	ff 92       	push	r15
  if (sys.state == STATE_CHECK_MODE) { return; }
     c4e:	20 91 16 0c 	lds	r18, 0x0C16	; 0x800c16 <sys>
     c52:	22 30       	cpi	r18, 0x02	; 2
     c54:	49 f0       	breq	.+18     	; 0xc68 <mc_dwell+0x22>
     c56:	6b 01       	movw	r12, r22
     c58:	7c 01       	movw	r14, r24
  protocol_buffer_synchronize();
     c5a:	0e 94 94 18 	call	0x3128	; 0x3128 <protocol_buffer_synchronize>
  delay_sec(seconds, DELAY_MODE_DWELL);
     c5e:	40 e0       	ldi	r20, 0x00	; 0
     c60:	c7 01       	movw	r24, r14
     c62:	b6 01       	movw	r22, r12
     c64:	0e 94 5b 2e 	call	0x5cb6	; 0x5cb6 <delay_sec>
}
     c68:	ff 90       	pop	r15
     c6a:	ef 90       	pop	r14
     c6c:	df 90       	pop	r13
     c6e:	cf 90       	pop	r12
     c70:	08 95       	ret

00000c72 <mc_homing_cycle>:

// Perform homing cycle to locate and set machine zero. Only '$H' executes this command.
// NOTE: There should be no motions in the buffer and Grbl must be in an idle state before
// executing the homing cycle. This prevents incorrect buffered plans after homing.
void mc_homing_cycle(uint8_t cycle_mask)
{
     c72:	cf 93       	push	r28
     c74:	c8 2f       	mov	r28, r24
      system_set_exec_alarm(EXEC_ALARM_HARD_LIMIT);
      return;
    }
  #endif

  limits_disable(); // Disable hard limits pin change register for cycle duration
     c76:	0e 94 a1 2f 	call	0x5f42	; 0x5f42 <limits_disable>

  // -------------------------------------------------------------------------------------
  // Perform homing routine. NOTE: Special motion case. Only system reset works.
  
  #ifdef HOMING_SINGLE_AXIS_COMMANDS
    if (cycle_mask) { limits_go_home(cycle_mask); } // Perform homing cycle based on mask.
     c7a:	cc 23       	and	r28, r28
     c7c:	21 f0       	breq	.+8      	; 0xc86 <mc_homing_cycle+0x14>
     c7e:	8c 2f       	mov	r24, r28
     c80:	0e 94 68 30 	call	0x60d0	; 0x60d0 <limits_go_home>
     c84:	06 c0       	rjmp	.+12     	; 0xc92 <mc_homing_cycle+0x20>
    else
  #endif
  {
    // Search to engage all axes limit switches at faster homing seek rate.
    limits_go_home(HOMING_CYCLE_0);  // Homing cycle 0
     c86:	81 e0       	ldi	r24, 0x01	; 1
     c88:	0e 94 68 30 	call	0x60d0	; 0x60d0 <limits_go_home>
    #ifdef HOMING_CYCLE_1
      limits_go_home(HOMING_CYCLE_1);  // Homing cycle 1
     c8c:	84 e0       	ldi	r24, 0x04	; 4
     c8e:	0e 94 68 30 	call	0x60d0	; 0x60d0 <limits_go_home>
    #ifdef HOMING_CYCLE_2
      limits_go_home(HOMING_CYCLE_2);  // Homing cycle 2
    #endif
  }

  protocol_execute_realtime(); // Check for reset and set system abort.
     c92:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <protocol_execute_realtime>
  if (sys.abort) { return; } // Did not complete. Alarm state set by mc_alarm.
     c96:	80 91 17 0c 	lds	r24, 0x0C17	; 0x800c17 <sys+0x1>
     c9a:	81 11       	cpse	r24, r1
     c9c:	05 c0       	rjmp	.+10     	; 0xca8 <mc_homing_cycle+0x36>

  // Homing cycle complete! Setup system for normal operation.
  // -------------------------------------------------------------------------------------

  // Sync gcode parser and planner positions to homed position.
  gc_sync_position();
     c9e:	b1 d0       	rcall	.+354    	; 0xe02 <gc_sync_position>
  plan_sync_position();
     ca0:	0e 94 6f 2d 	call	0x5ade	; 0x5ade <plan_sync_position>

  // If hard limits feature enabled, re-enable hard limits pin change register after homing cycle.
  limits_init();
     ca4:	0e 94 ac 2f 	call	0x5f58	; 0x5f58 <limits_init>
}
     ca8:	cf 91       	pop	r28
     caa:	08 95       	ret

00000cac <mc_probe_cycle>:


// Perform tool length probe cycle. Requires probe switch.
// NOTE: Upon probe failure, the program will be stopped and placed into ALARM state.
uint8_t mc_probe_cycle(float *target, plan_line_data_t *pl_data, uint8_t parser_flags)
{
     cac:	df 92       	push	r13
     cae:	ef 92       	push	r14
     cb0:	ff 92       	push	r15
     cb2:	0f 93       	push	r16
     cb4:	1f 93       	push	r17
     cb6:	cf 93       	push	r28
     cb8:	df 93       	push	r29
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return(GC_PROBE_CHECK_MODE); }
     cba:	20 91 16 0c 	lds	r18, 0x0C16	; 0x800c16 <sys>
     cbe:	22 30       	cpi	r18, 0x02	; 2
     cc0:	09 f4       	brne	.+2      	; 0xcc4 <mc_probe_cycle+0x18>
     cc2:	5c c0       	rjmp	.+184    	; 0xd7c <mc_probe_cycle+0xd0>
     cc4:	d4 2e       	mov	r13, r20
     cc6:	7b 01       	movw	r14, r22
     cc8:	8c 01       	movw	r16, r24

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
     cca:	0e 94 94 18 	call	0x3128	; 0x3128 <protocol_buffer_synchronize>
  if (sys.abort) { return(GC_PROBE_ABORT); } // Return if system reset has been issued.
     cce:	80 91 17 0c 	lds	r24, 0x0C17	; 0x800c17 <sys+0x1>
     cd2:	81 11       	cpse	r24, r1
     cd4:	55 c0       	rjmp	.+170    	; 0xd80 <mc_probe_cycle+0xd4>

  // Initialize probing control variables
  uint8_t is_probe_away = bit_istrue(parser_flags,GC_PARSER_PROBE_IS_AWAY);
  uint8_t is_no_error = bit_istrue(parser_flags,GC_PARSER_PROBE_IS_NO_ERROR);
  sys.probe_succeeded = false; // Re-initialize probe history before beginning cycle.
     cd6:	10 92 1b 0c 	sts	0x0C1B, r1	; 0x800c1b <sys+0x5>
  probe_configure_invert_mask(is_probe_away);
     cda:	d3 fa       	bst	r13, 3
     cdc:	88 27       	eor	r24, r24
     cde:	80 f9       	bld	r24, 0
     ce0:	0e 94 44 34 	call	0x6888	; 0x6888 <probe_configure_invert_mask>

  // After syncing, check if probe is already triggered. If so, halt and issue alarm.
  // NOTE: This probe initialization error applies to all probing cycles.
  if ( probe_get_state() ) { // Check probe pin state.
     ce4:	0e 94 62 34 	call	0x68c4	; 0x68c4 <probe_get_state>
     ce8:	88 23       	and	r24, r24
     cea:	51 f0       	breq	.+20     	; 0xd00 <mc_probe_cycle+0x54>
    system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_INITIAL);
     cec:	84 e0       	ldi	r24, 0x04	; 4
     cee:	0e 94 5d 3d 	call	0x7aba	; 0x7aba <system_set_exec_alarm>
    protocol_execute_realtime();
     cf2:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <protocol_execute_realtime>
    probe_configure_invert_mask(false); // Re-initialize invert mask before returning.
     cf6:	80 e0       	ldi	r24, 0x00	; 0
     cf8:	0e 94 44 34 	call	0x6888	; 0x6888 <probe_configure_invert_mask>
    return(GC_PROBE_FAIL_INIT); // Nothing else to do but bail.
     cfc:	82 e0       	ldi	r24, 0x02	; 2
     cfe:	43 c0       	rjmp	.+134    	; 0xd86 <mc_probe_cycle+0xda>
  }

  // Setup and queue probing motion. Auto cycle-start should not start the cycle.
  mc_line(target, pl_data);
     d00:	b7 01       	movw	r22, r14
     d02:	c8 01       	movw	r24, r16
     d04:	80 dc       	rcall	.-1792   	; 0x606 <mc_line>

  // Activate the probing state monitor in the stepper module.
  sys_probe_state = PROBE_ACTIVE;
     d06:	81 e0       	ldi	r24, 0x01	; 1
     d08:	80 93 2a 0c 	sts	0x0C2A, r24	; 0x800c2a <sys_probe_state>

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
     d0c:	82 e0       	ldi	r24, 0x02	; 2
     d0e:	0e 94 f5 3a 	call	0x75ea	; 0x75ea <system_set_exec_state_flag>
  do {
    protocol_execute_realtime();
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
     d12:	c6 e1       	ldi	r28, 0x16	; 22
     d14:	dc e0       	ldi	r29, 0x0C	; 12
  sys_probe_state = PROBE_ACTIVE;

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
  do {
    protocol_execute_realtime();
     d16:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <protocol_execute_realtime>
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
     d1a:	89 81       	ldd	r24, Y+1	; 0x01
     d1c:	81 11       	cpse	r24, r1
     d1e:	32 c0       	rjmp	.+100    	; 0xd84 <mc_probe_cycle+0xd8>
  } while (sys.state != STATE_IDLE);
     d20:	88 81       	ld	r24, Y
     d22:	81 11       	cpse	r24, r1
     d24:	f8 cf       	rjmp	.-16     	; 0xd16 <mc_probe_cycle+0x6a>

  // Probing cycle complete!

  // Set state variables and error out, if the probe failed and cycle with error is enabled.
  if (sys_probe_state == PROBE_ACTIVE) {
     d26:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <sys_probe_state>
     d2a:	81 30       	cpi	r24, 0x01	; 1
     d2c:	81 f4       	brne	.+32     	; 0xd4e <mc_probe_cycle+0xa2>
    if (is_no_error) { memcpy(sys_probe_position, sys_position, sizeof(sys_position)); }
     d2e:	d4 fe       	sbrs	r13, 4
     d30:	0a c0       	rjmp	.+20     	; 0xd46 <mc_probe_cycle+0x9a>
     d32:	8c e0       	ldi	r24, 0x0C	; 12
     d34:	e7 e3       	ldi	r30, 0x37	; 55
     d36:	fc e0       	ldi	r31, 0x0C	; 12
     d38:	ab e2       	ldi	r26, 0x2B	; 43
     d3a:	bc e0       	ldi	r27, 0x0C	; 12
     d3c:	01 90       	ld	r0, Z+
     d3e:	0d 92       	st	X+, r0
     d40:	8a 95       	dec	r24
     d42:	e1 f7       	brne	.-8      	; 0xd3c <mc_probe_cycle+0x90>
     d44:	07 c0       	rjmp	.+14     	; 0xd54 <mc_probe_cycle+0xa8>
    else { system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_CONTACT); }
     d46:	85 e0       	ldi	r24, 0x05	; 5
     d48:	0e 94 5d 3d 	call	0x7aba	; 0x7aba <system_set_exec_alarm>
     d4c:	03 c0       	rjmp	.+6      	; 0xd54 <mc_probe_cycle+0xa8>
  } else {
    sys.probe_succeeded = true; // Indicate to system the probing cycle completed successfully.
     d4e:	81 e0       	ldi	r24, 0x01	; 1
     d50:	80 93 1b 0c 	sts	0x0C1B, r24	; 0x800c1b <sys+0x5>
  }
  sys_probe_state = PROBE_OFF; // Ensure probe state monitor is disabled.
     d54:	10 92 2a 0c 	sts	0x0C2A, r1	; 0x800c2a <sys_probe_state>
  probe_configure_invert_mask(false); // Re-initialize invert mask.
     d58:	80 e0       	ldi	r24, 0x00	; 0
     d5a:	0e 94 44 34 	call	0x6888	; 0x6888 <probe_configure_invert_mask>
  protocol_execute_realtime();   // Check and execute run-time commands
     d5e:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <protocol_execute_realtime>

  // Reset the stepper and planner buffers to remove the remainder of the probe motion.
  st_reset(); // Reset step segment buffer.
     d62:	0e 94 41 1b 	call	0x3682	; 0x3682 <st_reset>
  plan_reset(); // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
     d66:	0e 94 c7 28 	call	0x518e	; 0x518e <plan_reset>
  plan_sync_position(); // Sync planner position to current machine position.
     d6a:	0e 94 6f 2d 	call	0x5ade	; 0x5ade <plan_sync_position>
// Perform tool length probe cycle. Requires probe switch.
// NOTE: Upon probe failure, the program will be stopped and placed into ALARM state.
uint8_t mc_probe_cycle(float *target, plan_line_data_t *pl_data, uint8_t parser_flags)
{
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return(GC_PROBE_CHECK_MODE); }
     d6e:	81 e0       	ldi	r24, 0x01	; 1
     d70:	90 91 1b 0c 	lds	r25, 0x0C1B	; 0x800c1b <sys+0x5>
     d74:	91 11       	cpse	r25, r1
     d76:	07 c0       	rjmp	.+14     	; 0xd86 <mc_probe_cycle+0xda>
     d78:	80 e0       	ldi	r24, 0x00	; 0
     d7a:	05 c0       	rjmp	.+10     	; 0xd86 <mc_probe_cycle+0xda>
     d7c:	80 e0       	ldi	r24, 0x00	; 0
     d7e:	03 c0       	rjmp	.+6      	; 0xd86 <mc_probe_cycle+0xda>

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
  if (sys.abort) { return(GC_PROBE_ABORT); } // Return if system reset has been issued.
     d80:	82 e0       	ldi	r24, 0x02	; 2
     d82:	01 c0       	rjmp	.+2      	; 0xd86 <mc_probe_cycle+0xda>

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
  do {
    protocol_execute_realtime();
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
     d84:	82 e0       	ldi	r24, 0x02	; 2
    report_probe_parameters();
  #endif

  if (sys.probe_succeeded) { return(GC_PROBE_FOUND); } // Successful probe cycle.
  else { return(GC_PROBE_FAIL_END); } // Failed to trigger probe within travel. With or without error.
}
     d86:	df 91       	pop	r29
     d88:	cf 91       	pop	r28
     d8a:	1f 91       	pop	r17
     d8c:	0f 91       	pop	r16
     d8e:	ff 90       	pop	r15
     d90:	ef 90       	pop	r14
     d92:	df 90       	pop	r13
     d94:	08 95       	ret

00000d96 <mc_reset>:
// lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
// realtime abort command and hard limits. So, keep to a minimum.
void mc_reset()
{
  // Only this function can set the system reset. Helps prevent multiple kill calls.
  if (bit_isfalse(sys_rt_exec_state, EXEC_RESET)) {
     d96:	80 91 29 0c 	lds	r24, 0x0C29	; 0x800c29 <sys_rt_exec_state>
     d9a:	84 fd       	sbrc	r24, 4
     d9c:	1f c0       	rjmp	.+62     	; 0xddc <mc_reset+0x46>
    system_set_exec_state_flag(EXEC_RESET);
     d9e:	80 e1       	ldi	r24, 0x10	; 16
     da0:	0e 94 f5 3a 	call	0x75ea	; 0x75ea <system_set_exec_state_flag>

    // Kill spindle and coolant.
    spindle_stop();
     da4:	0e 94 22 12 	call	0x2444	; 0x2444 <spindle_stop>
    coolant_stop();
     da8:	0e 94 66 13 	call	0x26cc	; 0x26cc <coolant_stop>

    // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
    // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
    // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
    // violated, by which, all bets are off.
    if ((sys.state & (STATE_CYCLE | STATE_HOMING | STATE_JOG)) ||
     dac:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
     db0:	98 2f       	mov	r25, r24
     db2:	9c 72       	andi	r25, 0x2C	; 44
     db4:	21 f4       	brne	.+8      	; 0xdbe <mc_reset+0x28>
     db6:	90 91 1a 0c 	lds	r25, 0x0C1A	; 0x800c1a <sys+0x4>
     dba:	96 70       	andi	r25, 0x06	; 6
     dbc:	79 f0       	breq	.+30     	; 0xddc <mc_reset+0x46>
    		(sys.step_control & (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION))) {
      if (sys.state == STATE_HOMING) { 
     dbe:	84 30       	cpi	r24, 0x04	; 4
     dc0:	41 f4       	brne	.+16     	; 0xdd2 <mc_reset+0x3c>
        if (!sys_rt_exec_alarm) {system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_RESET); }
     dc2:	80 91 43 0c 	lds	r24, 0x0C43	; 0x800c43 <sys_rt_exec_alarm>
     dc6:	81 11       	cpse	r24, r1
     dc8:	07 c0       	rjmp	.+14     	; 0xdd8 <mc_reset+0x42>
     dca:	86 e0       	ldi	r24, 0x06	; 6
     dcc:	0e 94 5d 3d 	call	0x7aba	; 0x7aba <system_set_exec_alarm>
     dd0:	03 c0       	rjmp	.+6      	; 0xdd8 <mc_reset+0x42>
      } else { system_set_exec_alarm(EXEC_ALARM_ABORT_CYCLE); }
     dd2:	83 e0       	ldi	r24, 0x03	; 3
     dd4:	0e 94 5d 3d 	call	0x7aba	; 0x7aba <system_set_exec_alarm>
      st_go_idle(); // Force kill steppers. Position has likely been lost.
     dd8:	0c 94 bf 18 	jmp	0x317e	; 0x317e <st_go_idle>
     ddc:	08 95       	ret

00000dde <gc_init>:
#define FAIL(status) return(status);


void gc_init()
{
  memset(&gc_state, 0, sizeof(parser_state_t));
     dde:	80 e4       	ldi	r24, 0x40	; 64
     de0:	e6 e4       	ldi	r30, 0x46	; 70
     de2:	fc e0       	ldi	r31, 0x0C	; 12
     de4:	df 01       	movw	r26, r30
     de6:	1d 92       	st	X+, r1
     de8:	8a 95       	dec	r24
     dea:	e9 f7       	brne	.-6      	; 0xde6 <gc_init+0x8>

  // Load default G54 coordinate system.
  if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) {
     dec:	6a e6       	ldi	r22, 0x6A	; 106
     dee:	7c e0       	ldi	r23, 0x0C	; 12
     df0:	80 e0       	ldi	r24, 0x00	; 0
     df2:	0e 94 82 25 	call	0x4b04	; 0x4b04 <settings_read_coord_data>
     df6:	81 11       	cpse	r24, r1
     df8:	03 c0       	rjmp	.+6      	; 0xe00 <gc_init+0x22>
    report_status_message(STATUS_SETTING_READ_FAIL);
     dfa:	87 e0       	ldi	r24, 0x07	; 7
     dfc:	0c 94 c6 34 	jmp	0x698c	; 0x698c <report_status_message>
     e00:	08 95       	ret

00000e02 <gc_sync_position>:

// Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
// limit pull-off routines.
void gc_sync_position()
{
  system_convert_array_steps_to_mpos(gc_state.position,sys_position);
     e02:	67 e3       	ldi	r22, 0x37	; 55
     e04:	7c e0       	ldi	r23, 0x0C	; 12
     e06:	8e e5       	ldi	r24, 0x5E	; 94
     e08:	9c e0       	ldi	r25, 0x0C	; 12
     e0a:	0c 94 76 3a 	jmp	0x74ec	; 0x74ec <system_convert_array_steps_to_mpos>
     e0e:	08 95       	ret

00000e10 <gc_execute_line>:
// characters and signed floating point values (no whitespace). Comments and block delete
// characters have been removed. In this function, all units and positions are converted and
// exported to grbl's internal functions in terms of (mm, mm/min) and absolute machine
// coordinates, respectively.
uint8_t gc_execute_line(char *line)
{
     e10:	2f 92       	push	r2
     e12:	3f 92       	push	r3
     e14:	4f 92       	push	r4
     e16:	5f 92       	push	r5
     e18:	6f 92       	push	r6
     e1a:	7f 92       	push	r7
     e1c:	8f 92       	push	r8
     e1e:	9f 92       	push	r9
     e20:	af 92       	push	r10
     e22:	bf 92       	push	r11
     e24:	cf 92       	push	r12
     e26:	df 92       	push	r13
     e28:	ef 92       	push	r14
     e2a:	ff 92       	push	r15
     e2c:	0f 93       	push	r16
     e2e:	1f 93       	push	r17
     e30:	cf 93       	push	r28
     e32:	df 93       	push	r29
     e34:	cd b7       	in	r28, 0x3d	; 61
     e36:	de b7       	in	r29, 0x3e	; 62
     e38:	e1 97       	sbiw	r28, 0x31	; 49
     e3a:	0f b6       	in	r0, 0x3f	; 63
     e3c:	f8 94       	cli
     e3e:	de bf       	out	0x3e, r29	; 62
     e40:	0f be       	out	0x3f, r0	; 63
     e42:	cd bf       	out	0x3d, r28	; 61
     e44:	8c 01       	movw	r16, r24
     updates these modes and commands as the block line is parser and will only be used and
     executed after successful error-checking. The parser block struct also contains a block
     values struct, word tracking variables, and a non-modal commands tracker for the new
     block. This struct contains all of the necessary information to execute the block. */

  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
     e46:	8a e3       	ldi	r24, 0x3A	; 58
     e48:	e6 e8       	ldi	r30, 0x86	; 134
     e4a:	fc e0       	ldi	r31, 0x0C	; 12
     e4c:	df 01       	movw	r26, r30
     e4e:	1d 92       	st	X+, r1
     e50:	8a 95       	dec	r24
     e52:	e9 f7       	brne	.-6      	; 0xe4e <gc_execute_line+0x3e>
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
     e54:	8b e0       	ldi	r24, 0x0B	; 11
     e56:	e6 e4       	ldi	r30, 0x46	; 70
     e58:	fc e0       	ldi	r31, 0x0C	; 12
     e5a:	a7 e8       	ldi	r26, 0x87	; 135
     e5c:	bc e0       	ldi	r27, 0x0C	; 12
     e5e:	01 90       	ld	r0, Z+
     e60:	0d 92       	st	X+, r0
     e62:	8a 95       	dec	r24
     e64:	e1 f7       	brne	.-8      	; 0xe5e <gc_execute_line+0x4e>
  uint16_t command_words = 0; // Tracks G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Tracks value words.
  uint8_t gc_parser_flags = GC_PARSER_NONE;

  // Determine if the line is a jogging motion or a normal g-code block.
  if (line[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
     e66:	f8 01       	movw	r30, r16
     e68:	80 81       	ld	r24, Z
     e6a:	84 32       	cpi	r24, 0x24	; 36
     e6c:	11 f0       	breq	.+4      	; 0xe72 <gc_execute_line+0x62>
     e6e:	0c 94 af 11 	jmp	0x235e	; 0x235e <__stack+0x15f>
    // Set G1 and G94 enforced modes to ensure accurate error checks.
    gc_parser_flags |= GC_PARSER_JOG_MOTION;
    gc_block.modal.motion = MOTION_MODE_LINEAR;
     e72:	e6 e8       	ldi	r30, 0x86	; 134
     e74:	fc e0       	ldi	r31, 0x0C	; 12
     e76:	81 e0       	ldi	r24, 0x01	; 1
     e78:	81 83       	std	Z+1, r24	; 0x01
    gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
     e7a:	12 82       	std	Z+2, r1	; 0x02
  uint8_t char_counter;
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
     e7c:	83 e0       	ldi	r24, 0x03	; 3
     e7e:	89 83       	std	Y+1, r24	; 0x01
  uint8_t gc_parser_flags = GC_PARSER_NONE;

  // Determine if the line is a jogging motion or a normal g-code block.
  if (line[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
    // Set G1 and G94 enforced modes to ensure accurate error checks.
    gc_parser_flags |= GC_PARSER_JOG_MOTION;
     e80:	f1 e0       	ldi	r31, 0x01	; 1
     e82:	fc a3       	std	Y+36, r31	; 0x24
						if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
						gc_block.values.t = int_value;
						break;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
     e84:	21 2c       	mov	r2, r1
     e86:	31 2c       	mov	r3, r1
     e88:	e1 2c       	mov	r14, r1
     e8a:	f1 2c       	mov	r15, r1
     e8c:	1b a2       	std	Y+35, r1	; 0x23
     e8e:	19 a2       	std	Y+33, r1	; 0x21
     e90:	1a a2       	std	Y+34, r1	; 0x22
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
     e92:	cc 24       	eor	r12, r12
     e94:	c3 94       	inc	r12
     e96:	d1 2c       	mov	r13, r1

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
     e98:	0f 2e       	mov	r0, r31
     e9a:	f1 e6       	ldi	r31, 0x61	; 97
     e9c:	8f 2e       	mov	r8, r31
     e9e:	f3 e0       	ldi	r31, 0x03	; 3
     ea0:	9f 2e       	mov	r9, r31
     ea2:	f0 2d       	mov	r31, r0
     ea4:	18 a3       	std	Y+32, r17	; 0x20
     ea6:	0f 8f       	std	Y+31, r16	; 0x1f
     ea8:	37 c2       	rjmp	.+1134   	; 0x1318 <gc_execute_line+0x508>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.

    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
     eaa:	9f eb       	ldi	r25, 0xBF	; 191
     eac:	91 0f       	add	r25, r17
     eae:	9a 31       	cpi	r25, 0x1A	; 26
     eb0:	10 f0       	brcs	.+4      	; 0xeb6 <gc_execute_line+0xa6>
     eb2:	0c 94 41 11 	jmp	0x2282	; 0x2282 <__stack+0x83>
    char_counter++;
     eb6:	8f 5f       	subi	r24, 0xFF	; 255
     eb8:	89 83       	std	Y+1, r24	; 0x01
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
     eba:	ae 01       	movw	r20, r28
     ebc:	4e 5f       	subi	r20, 0xFE	; 254
     ebe:	5f 4f       	sbci	r21, 0xFF	; 255
     ec0:	be 01       	movw	r22, r28
     ec2:	6f 5f       	subi	r22, 0xFF	; 255
     ec4:	7f 4f       	sbci	r23, 0xFF	; 255
     ec6:	8f 8d       	ldd	r24, Y+31	; 0x1f
     ec8:	98 a1       	ldd	r25, Y+32	; 0x20
     eca:	0e 94 95 2d 	call	0x5b2a	; 0x5b2a <read_float>
     ece:	88 23       	and	r24, r24
     ed0:	11 f4       	brne	.+4      	; 0xed6 <gc_execute_line+0xc6>
     ed2:	0c 94 43 11 	jmp	0x2286	; 0x2286 <__stack+0x87>
    // accurate than the NIST gcode requirement of x10 when used for commands, but not quite
    // accurate enough for value words that require integers to within 0.0001. This should be
    // a good enough comprimise and catch most all non-integer errors. To make it compliant,
    // we would simply need to change the mantissa to int16, but this add compiled flash space.
    // Maybe update this later.
    int_value = trunc(value);
     ed6:	4a 80       	ldd	r4, Y+2	; 0x02
     ed8:	5b 80       	ldd	r5, Y+3	; 0x03
     eda:	6c 80       	ldd	r6, Y+4	; 0x04
     edc:	7d 80       	ldd	r7, Y+5	; 0x05
     ede:	c3 01       	movw	r24, r6
     ee0:	b2 01       	movw	r22, r4
     ee2:	0e 94 d1 41 	call	0x83a2	; 0x83a2 <trunc>
     ee6:	0e 94 39 3f 	call	0x7e72	; 0x7e72 <__fixunssfsi>
     eea:	a6 2e       	mov	r10, r22
    mantissa =  round(100*(value - int_value)); // Compute mantissa for Gxx.x commands.
     eec:	70 e0       	ldi	r23, 0x00	; 0
     eee:	80 e0       	ldi	r24, 0x00	; 0
     ef0:	90 e0       	ldi	r25, 0x00	; 0
     ef2:	0e 94 67 3f 	call	0x7ece	; 0x7ece <__floatsisf>
     ef6:	9b 01       	movw	r18, r22
     ef8:	ac 01       	movw	r20, r24
     efa:	c3 01       	movw	r24, r6
     efc:	b2 01       	movw	r22, r4
     efe:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
     f02:	20 e0       	ldi	r18, 0x00	; 0
     f04:	30 e0       	ldi	r19, 0x00	; 0
     f06:	48 ec       	ldi	r20, 0xC8	; 200
     f08:	52 e4       	ldi	r21, 0x42	; 66
     f0a:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
     f0e:	0e 94 66 41 	call	0x82cc	; 0x82cc <round>
     f12:	0e 94 39 3f 	call	0x7e72	; 0x7e72 <__fixunssfsi>
     f16:	86 2f       	mov	r24, r22
     f18:	97 2f       	mov	r25, r23
     f1a:	9c 01       	movw	r18, r24
    // NOTE: Rounding must be used to catch small floating point errors.

    // Check if the g-code word is supported or errors due to modal group violations or has
    // been repeated in the g-code block. If ok, update the command or record its value.
    switch(letter) {
     f1c:	17 34       	cpi	r17, 0x47	; 71
     f1e:	21 f0       	breq	.+8      	; 0xf28 <gc_execute_line+0x118>
     f20:	1d 34       	cpi	r17, 0x4D	; 77
     f22:	09 f4       	brne	.+2      	; 0xf26 <gc_execute_line+0x116>
     f24:	c9 c0       	rjmp	.+402    	; 0x10b8 <gc_execute_line+0x2a8>
     f26:	30 c1       	rjmp	.+608    	; 0x1188 <gc_execute_line+0x378>
      /* 'G' and 'M' Command Words: Parse commands and check for modal group violations.
         NOTE: Modal group numbers are defined in Table 4 of NIST RS274-NGC v3, pg.20 */

      case 'G':
        // Determine 'G' command and its modal group
        switch(int_value) {
     f28:	8a 2d       	mov	r24, r10
     f2a:	90 e0       	ldi	r25, 0x00	; 0
     f2c:	8f 35       	cpi	r24, 0x5F	; 95
     f2e:	91 05       	cpc	r25, r1
     f30:	10 f0       	brcs	.+4      	; 0xf36 <gc_execute_line+0x126>
     f32:	0c 94 45 11 	jmp	0x228a	; 0x228a <__stack+0x8b>
     f36:	fc 01       	movw	r30, r24
     f38:	88 27       	eor	r24, r24
     f3a:	ee 58       	subi	r30, 0x8E	; 142
     f3c:	ff 4f       	sbci	r31, 0xFF	; 255
     f3e:	8f 4f       	sbci	r24, 0xFF	; 255
     f40:	0c 94 12 42 	jmp	0x8424	; 0x8424 <__tablejump2__>
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
     f44:	21 15       	cp	r18, r1
     f46:	31 05       	cpc	r19, r1
     f48:	11 f0       	breq	.+4      	; 0xf4e <gc_execute_line+0x13e>
     f4a:	0c 94 b3 11 	jmp	0x2366	; 0x2366 <__stack+0x167>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
     f4e:	4a a1       	ldd	r20, Y+34	; 0x22
     f50:	44 23       	and	r20, r20
     f52:	11 f4       	brne	.+4      	; 0xf58 <gc_execute_line+0x148>
     f54:	0c 94 bb 11 	jmp	0x2376	; 0x2376 <__stack+0x177>
     f58:	0c 94 47 11 	jmp	0x228e	; 0x228e <__stack+0x8f>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
     f5c:	a6 e8       	ldi	r26, 0x86	; 134
     f5e:	bc e0       	ldi	r27, 0x0C	; 12
     f60:	ac 92       	st	X, r10
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
     f62:	bc e1       	ldi	r27, 0x1C	; 28
     f64:	ab 16       	cp	r10, r27
     f66:	31 f0       	breq	.+12     	; 0xf74 <gc_execute_line+0x164>
     f68:	ee e1       	ldi	r30, 0x1E	; 30
     f6a:	ae 16       	cp	r10, r30
     f6c:	19 f0       	breq	.+6      	; 0xf74 <gc_execute_line+0x164>
     f6e:	fc e5       	ldi	r31, 0x5C	; 92
     f70:	af 12       	cpse	r10, r31
     f72:	8b c0       	rjmp	.+278    	; 0x108a <gc_execute_line+0x27a>
              if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
     f74:	21 15       	cp	r18, r1
     f76:	31 05       	cpc	r19, r1
     f78:	51 f0       	breq	.+20     	; 0xf8e <gc_execute_line+0x17e>
     f7a:	2a 30       	cpi	r18, 0x0A	; 10
     f7c:	31 05       	cpc	r19, r1
     f7e:	39 f0       	breq	.+14     	; 0xf8e <gc_execute_line+0x17e>
     f80:	0c 94 49 11 	jmp	0x2292	; 0x2292 <__stack+0x93>
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     f84:	21 e0       	ldi	r18, 0x01	; 1
     f86:	2a a3       	std	Y+34, r18	; 0x22
     f88:	02 c0       	rjmp	.+4      	; 0xf8e <gc_execute_line+0x17e>
     f8a:	31 e0       	ldi	r19, 0x01	; 1
     f8c:	3a a3       	std	Y+34, r19	; 0x22
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
              if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
              gc_block.non_modal_command += mantissa;
     f8e:	6a 0d       	add	r22, r10
     f90:	a6 e8       	ldi	r26, 0x86	; 134
     f92:	bc e0       	ldi	r27, 0x0C	; 12
     f94:	6c 93       	st	X, r22
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
     f96:	80 e0       	ldi	r24, 0x00	; 0
     f98:	7f c0       	rjmp	.+254    	; 0x1098 <gc_execute_line+0x288>
            }                
            break;
          case 0: case 1: case 2: case 3: case 38:
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
     f9a:	ba a1       	ldd	r27, Y+34	; 0x22
     f9c:	b1 11       	cpse	r27, r1
     f9e:	0c 94 4b 11 	jmp	0x2296	; 0x2296 <__stack+0x97>
            axis_command = AXIS_COMMAND_MOTION_MODE;
     fa2:	e2 e0       	ldi	r30, 0x02	; 2
     fa4:	ea a3       	std	Y+34, r30	; 0x22
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
            gc_block.modal.motion = int_value;
     fa6:	a0 92 87 0c 	sts	0x0C87, r10	; 0x800c87 <gc_block+0x1>
            if (int_value == 38){
     faa:	f6 e2       	ldi	r31, 0x26	; 38
     fac:	af 12       	cpse	r10, r31
     fae:	6f c0       	rjmp	.+222    	; 0x108e <gc_execute_line+0x27e>
              if (!((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))) {
     fb0:	24 31       	cpi	r18, 0x14	; 20
     fb2:	31 05       	cpc	r19, r1
     fb4:	59 f0       	breq	.+22     	; 0xfcc <gc_execute_line+0x1bc>
     fb6:	2e 31       	cpi	r18, 0x1E	; 30
     fb8:	31 05       	cpc	r19, r1
     fba:	41 f0       	breq	.+16     	; 0xfcc <gc_execute_line+0x1bc>
     fbc:	28 32       	cpi	r18, 0x28	; 40
     fbe:	31 05       	cpc	r19, r1
     fc0:	29 f0       	breq	.+10     	; 0xfcc <gc_execute_line+0x1bc>
     fc2:	22 33       	cpi	r18, 0x32	; 50
     fc4:	31 05       	cpc	r19, r1
     fc6:	11 f0       	breq	.+4      	; 0xfcc <gc_execute_line+0x1bc>
     fc8:	0c 94 4d 11 	jmp	0x229a	; 0x229a <__stack+0x9b>
                FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
              }
              gc_block.modal.motion += (mantissa/10)+100;
     fcc:	26 2f       	mov	r18, r22
     fce:	37 2f       	mov	r19, r23
     fd0:	ad ec       	ldi	r26, 0xCD	; 205
     fd2:	bc ec       	ldi	r27, 0xCC	; 204
     fd4:	0e 94 1a 42 	call	0x8434	; 0x8434 <__umulhisi3>
     fd8:	96 95       	lsr	r25
     fda:	87 95       	ror	r24
     fdc:	96 95       	lsr	r25
     fde:	87 95       	ror	r24
     fe0:	96 95       	lsr	r25
     fe2:	87 95       	ror	r24
     fe4:	86 57       	subi	r24, 0x76	; 118
     fe6:	80 93 87 0c 	sts	0x0C87, r24	; 0x800c87 <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE;
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
     fea:	81 e0       	ldi	r24, 0x01	; 1
     fec:	55 c0       	rjmp	.+170    	; 0x1098 <gc_execute_line+0x288>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
            }  
            break;
          case 17: case 18: case 19:
            word_bit = MODAL_GROUP_G2;
            gc_block.modal.plane_select = int_value - 17;
     fee:	6f ee       	ldi	r22, 0xEF	; 239
     ff0:	6a 0d       	add	r22, r10
     ff2:	60 93 8b 0c 	sts	0x0C8B, r22	; 0x800c8b <gc_block+0x5>
              gc_block.modal.motion += (mantissa/10)+100;
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
            }  
            break;
          case 17: case 18: case 19:
            word_bit = MODAL_GROUP_G2;
     ff6:	82 e0       	ldi	r24, 0x02	; 2
            gc_block.modal.plane_select = int_value - 17;
            break;
     ff8:	4b c0       	rjmp	.+150    	; 0x1090 <gc_execute_line+0x280>
          case 90: case 91:
            if (mantissa == 0) {
     ffa:	21 15       	cp	r18, r1
     ffc:	31 05       	cpc	r19, r1
     ffe:	31 f4       	brne	.+12     	; 0x100c <gc_execute_line+0x1fc>
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
    1000:	66 ea       	ldi	r22, 0xA6	; 166
    1002:	6a 0d       	add	r22, r10
    1004:	60 93 8a 0c 	sts	0x0C8A, r22	; 0x800c8a <gc_block+0x4>
            word_bit = MODAL_GROUP_G2;
            gc_block.modal.plane_select = int_value - 17;
            break;
          case 90: case 91:
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
    1008:	83 e0       	ldi	r24, 0x03	; 3
    100a:	46 c0       	rjmp	.+140    	; 0x1098 <gc_execute_line+0x288>
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
    100c:	2a 30       	cpi	r18, 0x0A	; 10
    100e:	31 05       	cpc	r19, r1
    1010:	11 f0       	breq	.+4      	; 0x1016 <gc_execute_line+0x206>
    1012:	0c 94 4f 11 	jmp	0x229e	; 0x229e <__stack+0x9f>
    1016:	2a e5       	ldi	r18, 0x5A	; 90
    1018:	a2 16       	cp	r10, r18
    101a:	11 f4       	brne	.+4      	; 0x1020 <gc_execute_line+0x210>
    101c:	0c 94 51 11 	jmp	0x22a2	; 0x22a2 <__stack+0xa3>
          case 90: case 91:
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
    1020:	84 e0       	ldi	r24, 0x04	; 4
    1022:	3a c0       	rjmp	.+116    	; 0x1098 <gc_execute_line+0x288>
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
            gc_block.modal.feed_rate = 94 - int_value;
    1024:	8e e5       	ldi	r24, 0x5E	; 94
    1026:	8a 19       	sub	r24, r10
    1028:	80 93 88 0c 	sts	0x0C88, r24	; 0x800c88 <gc_block+0x2>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
    102c:	85 e0       	ldi	r24, 0x05	; 5
            gc_block.modal.feed_rate = 94 - int_value;
            break;
    102e:	30 c0       	rjmp	.+96     	; 0x1090 <gc_execute_line+0x280>
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
            gc_block.modal.units = 21 - int_value;
    1030:	85 e1       	ldi	r24, 0x15	; 21
    1032:	8a 19       	sub	r24, r10
    1034:	80 93 89 0c 	sts	0x0C89, r24	; 0x800c89 <gc_block+0x3>
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
            gc_block.modal.feed_rate = 94 - int_value;
            break;
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
    1038:	86 e0       	ldi	r24, 0x06	; 6
            gc_block.modal.units = 21 - int_value;
            break;
    103a:	2a c0       	rjmp	.+84     	; 0x1090 <gc_execute_line+0x280>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
    103c:	4a a1       	ldd	r20, Y+34	; 0x22
    103e:	41 11       	cpse	r20, r1
    1040:	0c 94 53 11 	jmp	0x22a6	; 0x22a6 <__stack+0xa7>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
    1044:	81 e3       	ldi	r24, 0x31	; 49
    1046:	a8 12       	cpse	r10, r24
    1048:	06 c0       	rjmp	.+12     	; 0x1056 <gc_execute_line+0x246>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
    104a:	10 92 8c 0c 	sts	0x0C8C, r1	; 0x800c8c <gc_block+0x6>
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
    104e:	88 e0       	ldi	r24, 0x08	; 8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
    1050:	93 e0       	ldi	r25, 0x03	; 3
    1052:	9a a3       	std	Y+34, r25	; 0x22
    1054:	21 c0       	rjmp	.+66     	; 0x1098 <gc_execute_line+0x288>
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
            } else if (mantissa == 10) { // G43.1
    1056:	2a 30       	cpi	r18, 0x0A	; 10
    1058:	31 05       	cpc	r19, r1
    105a:	11 f0       	breq	.+4      	; 0x1060 <gc_execute_line+0x250>
    105c:	0c 94 55 11 	jmp	0x22aa	; 0x22aa <__stack+0xab>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
    1060:	a1 e0       	ldi	r26, 0x01	; 1
    1062:	a0 93 8c 0c 	sts	0x0C8C, r26	; 0x800c8c <gc_block+0x6>
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
    1066:	88 e0       	ldi	r24, 0x08	; 8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
    1068:	b3 e0       	ldi	r27, 0x03	; 3
    106a:	ba a3       	std	Y+34, r27	; 0x22
    106c:	15 c0       	rjmp	.+42     	; 0x1098 <gc_execute_line+0x288>
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59:
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
    106e:	6a ec       	ldi	r22, 0xCA	; 202
    1070:	6a 0d       	add	r22, r10
    1072:	60 93 8d 0c 	sts	0x0C8D, r22	; 0x800c8d <gc_block+0x7>
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59:
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
    1076:	89 e0       	ldi	r24, 0x09	; 9
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
            break;
    1078:	0b c0       	rjmp	.+22     	; 0x1090 <gc_execute_line+0x280>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
    107a:	23 2b       	or	r18, r19
    107c:	11 f0       	breq	.+4      	; 0x1082 <gc_execute_line+0x272>
    107e:	0c 94 57 11 	jmp	0x22ae	; 0x22ae <__stack+0xaf>
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
    1082:	8a e0       	ldi	r24, 0x0A	; 10
    1084:	09 c0       	rjmp	.+18     	; 0x1098 <gc_execute_line+0x288>
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
            gc_block.modal.units = 21 - int_value;
            break;
          case 40:
            word_bit = MODAL_GROUP_G7;
    1086:	87 e0       	ldi	r24, 0x07	; 7
    1088:	03 c0       	rjmp	.+6      	; 0x1090 <gc_execute_line+0x280>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
    108a:	80 e0       	ldi	r24, 0x00	; 0
    108c:	01 c0       	rjmp	.+2      	; 0x1090 <gc_execute_line+0x280>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE;
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
    108e:	81 e0       	ldi	r24, 0x01	; 1
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    1090:	23 2b       	or	r18, r19
    1092:	11 f0       	breq	.+4      	; 0x1098 <gc_execute_line+0x288>
    1094:	0c 94 59 11 	jmp	0x22b2	; 0x22b2 <__stack+0xb3>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1098:	f6 01       	movw	r30, r12
    109a:	02 c0       	rjmp	.+4      	; 0x10a0 <gc_execute_line+0x290>
    109c:	ee 0f       	add	r30, r30
    109e:	ff 1f       	adc	r31, r31
    10a0:	8a 95       	dec	r24
    10a2:	e2 f7       	brpl	.-8      	; 0x109c <gc_execute_line+0x28c>
    10a4:	97 01       	movw	r18, r14
    10a6:	2e 23       	and	r18, r30
    10a8:	3f 23       	and	r19, r31
    10aa:	23 2b       	or	r18, r19
    10ac:	11 f0       	breq	.+4      	; 0x10b2 <gc_execute_line+0x2a2>
    10ae:	0c 94 5b 11 	jmp	0x22b6	; 0x22b6 <__stack+0xb7>
        command_words |= bit(word_bit);
    10b2:	ee 2a       	or	r14, r30
    10b4:	ff 2a       	or	r15, r31
        break;
    10b6:	30 c1       	rjmp	.+608    	; 0x1318 <gc_execute_line+0x508>

      case 'M':

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    10b8:	23 2b       	or	r18, r19
    10ba:	11 f0       	breq	.+4      	; 0x10c0 <gc_execute_line+0x2b0>
    10bc:	0c 94 5d 11 	jmp	0x22ba	; 0x22ba <__stack+0xbb>
        switch(int_value) {
    10c0:	8a 2d       	mov	r24, r10
    10c2:	90 e0       	ldi	r25, 0x00	; 0
    10c4:	8f 31       	cpi	r24, 0x1F	; 31
    10c6:	91 05       	cpc	r25, r1
    10c8:	10 f0       	brcs	.+4      	; 0x10ce <gc_execute_line+0x2be>
    10ca:	0c 94 5f 11 	jmp	0x22be	; 0x22be <__stack+0xbf>
    10ce:	fc 01       	movw	r30, r24
    10d0:	88 27       	eor	r24, r24
    10d2:	ef 52       	subi	r30, 0x2F	; 47
    10d4:	ff 4f       	sbci	r31, 0xFF	; 255
    10d6:	8f 4f       	sbci	r24, 0xFF	; 255
    10d8:	0c 94 12 42 	jmp	0x8424	; 0x8424 <__tablejump2__>
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
            switch(int_value) {
    10dc:	aa 20       	and	r10, r10
    10de:	21 f0       	breq	.+8      	; 0x10e8 <gc_execute_line+0x2d8>
    10e0:	f1 e0       	ldi	r31, 0x01	; 1
    10e2:	af 16       	cp	r10, r31
    10e4:	e1 f1       	breq	.+120    	; 0x115e <gc_execute_line+0x34e>
    10e6:	05 c0       	rjmp	.+10     	; 0x10f2 <gc_execute_line+0x2e2>
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
    10e8:	23 e0       	ldi	r18, 0x03	; 3
    10ea:	20 93 8e 0c 	sts	0x0C8E, r18	; 0x800c8e <gc_block+0x8>

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
    10ee:	8b e0       	ldi	r24, 0x0B	; 11
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
    10f0:	3b c0       	rjmp	.+118    	; 0x1168 <gc_execute_line+0x358>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
    10f2:	a0 92 8e 0c 	sts	0x0C8E, r10	; 0x800c8e <gc_block+0x8>

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
    10f6:	8b e0       	ldi	r24, 0x0B	; 11
    10f8:	37 c0       	rjmp	.+110    	; 0x1168 <gc_execute_line+0x358>
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
            switch(int_value) {
    10fa:	34 e0       	ldi	r19, 0x04	; 4
    10fc:	a3 16       	cp	r10, r19
    10fe:	59 f0       	breq	.+22     	; 0x1116 <gc_execute_line+0x306>
    1100:	45 e0       	ldi	r20, 0x05	; 5
    1102:	a4 16       	cp	r10, r20
    1104:	69 f0       	breq	.+26     	; 0x1120 <gc_execute_line+0x310>
    1106:	83 e0       	ldi	r24, 0x03	; 3
    1108:	a8 12       	cpse	r10, r24
    110a:	2b c0       	rjmp	.+86     	; 0x1162 <gc_execute_line+0x352>
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    110c:	80 e1       	ldi	r24, 0x10	; 16
    110e:	80 93 90 0c 	sts	0x0C90, r24	; 0x800c90 <gc_block+0xa>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
    1112:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    1114:	29 c0       	rjmp	.+82     	; 0x1168 <gc_execute_line+0x358>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    1116:	80 e2       	ldi	r24, 0x20	; 32
    1118:	80 93 90 0c 	sts	0x0C90, r24	; 0x800c90 <gc_block+0xa>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
    111c:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    111e:	24 c0       	rjmp	.+72     	; 0x1168 <gc_execute_line+0x358>
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    1120:	10 92 90 0c 	sts	0x0C90, r1	; 0x800c90 <gc_block+0xa>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
    1124:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    1126:	20 c0       	rjmp	.+64     	; 0x1168 <gc_execute_line+0x358>
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
            switch(int_value) {      
    1128:	98 e0       	ldi	r25, 0x08	; 8
    112a:	a9 16       	cp	r10, r25
    112c:	69 f0       	breq	.+26     	; 0x1148 <gc_execute_line+0x338>
    112e:	a9 e0       	ldi	r26, 0x09	; 9
    1130:	aa 16       	cp	r10, r26
    1132:	89 f0       	breq	.+34     	; 0x1156 <gc_execute_line+0x346>
    1134:	b7 e0       	ldi	r27, 0x07	; 7
    1136:	ab 12       	cpse	r10, r27
    1138:	16 c0       	rjmp	.+44     	; 0x1166 <gc_execute_line+0x356>
              case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
    113a:	80 91 8f 0c 	lds	r24, 0x0C8F	; 0x800c8f <gc_block+0x9>
    113e:	80 68       	ori	r24, 0x80	; 128
    1140:	80 93 8f 0c 	sts	0x0C8F, r24	; 0x800c8f <gc_block+0x9>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1144:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {      
              case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
    1146:	10 c0       	rjmp	.+32     	; 0x1168 <gc_execute_line+0x358>
              case 8: gc_block.modal.coolant |= COOLANT_FLOOD_ENABLE; break;
    1148:	80 91 8f 0c 	lds	r24, 0x0C8F	; 0x800c8f <gc_block+0x9>
    114c:	80 64       	ori	r24, 0x40	; 64
    114e:	80 93 8f 0c 	sts	0x0C8F, r24	; 0x800c8f <gc_block+0x9>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1152:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {      
              case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
              case 8: gc_block.modal.coolant |= COOLANT_FLOOD_ENABLE; break;
    1154:	09 c0       	rjmp	.+18     	; 0x1168 <gc_execute_line+0x358>
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break; // M9 disables both M7 and M8.
    1156:	10 92 8f 0c 	sts	0x0C8F, r1	; 0x800c8f <gc_block+0x9>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    115a:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {      
              case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
              case 8: gc_block.modal.coolant |= COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break; // M9 disables both M7 and M8.
    115c:	05 c0       	rjmp	.+10     	; 0x1168 <gc_execute_line+0x358>

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
    115e:	8b e0       	ldi	r24, 0x0B	; 11
    1160:	03 c0       	rjmp	.+6      	; 0x1168 <gc_execute_line+0x358>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
    1162:	8c e0       	ldi	r24, 0x0C	; 12
    1164:	01 c0       	rjmp	.+2      	; 0x1168 <gc_execute_line+0x358>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1166:	8d e0       	ldi	r24, 0x0D	; 13
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
        }

        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1168:	f6 01       	movw	r30, r12
    116a:	02 c0       	rjmp	.+4      	; 0x1170 <gc_execute_line+0x360>
    116c:	ee 0f       	add	r30, r30
    116e:	ff 1f       	adc	r31, r31
    1170:	8a 95       	dec	r24
    1172:	e2 f7       	brpl	.-8      	; 0x116c <gc_execute_line+0x35c>
    1174:	97 01       	movw	r18, r14
    1176:	2e 23       	and	r18, r30
    1178:	3f 23       	and	r19, r31
    117a:	23 2b       	or	r18, r19
    117c:	11 f0       	breq	.+4      	; 0x1182 <gc_execute_line+0x372>
    117e:	0c 94 61 11 	jmp	0x22c2	; 0x22c2 <__stack+0xc3>
        command_words |= bit(word_bit);
    1182:	ee 2a       	or	r14, r30
    1184:	ff 2a       	or	r15, r31
        break;
    1186:	c8 c0       	rjmp	.+400    	; 0x1318 <gc_execute_line+0x508>
      default:

        /* Non-Command Words: This initial parsing phase only checks for repeats of the remaining
           legal g-code words and stores their value. Error-checking is performed later since some
           words (I,J,K,L,P,R) have multiple connotations and/or depend on the issued commands. */
        switch(letter){
    1188:	81 2f       	mov	r24, r17
    118a:	90 e0       	ldi	r25, 0x00	; 0
    118c:	fc 01       	movw	r30, r24
    118e:	e6 54       	subi	r30, 0x46	; 70
    1190:	f1 09       	sbc	r31, r1
    1192:	e5 31       	cpi	r30, 0x15	; 21
    1194:	f1 05       	cpc	r31, r1
    1196:	10 f0       	brcs	.+4      	; 0x119c <gc_execute_line+0x38c>
    1198:	0c 94 63 11 	jmp	0x22c6	; 0x22c6 <__stack+0xc7>
    119c:	88 27       	eor	r24, r24
    119e:	e0 51       	subi	r30, 0x10	; 16
    11a0:	ff 4f       	sbci	r31, 0xFF	; 255
    11a2:	8f 4f       	sbci	r24, 0xFF	; 255
    11a4:	0c 94 12 42 	jmp	0x8424	; 0x8424 <__tablejump2__>
          // case 'A': // Not supported
          // case 'B': // Not supported
          // case 'C': // Not supported
          // case 'D': // Not supported
          case 'F': word_bit = WORD_F; gc_block.values.f = value; break;
    11a8:	40 92 92 0c 	sts	0x0C92, r4	; 0x800c92 <gc_block+0xc>
    11ac:	50 92 93 0c 	sts	0x0C93, r5	; 0x800c93 <gc_block+0xd>
    11b0:	60 92 94 0c 	sts	0x0C94, r6	; 0x800c94 <gc_block+0xe>
    11b4:	70 92 95 0c 	sts	0x0C95, r7	; 0x800c95 <gc_block+0xf>
    11b8:	80 e0       	ldi	r24, 0x00	; 0
    11ba:	8d c0       	rjmp	.+282    	; 0x12d6 <gc_execute_line+0x4c6>
          // case 'H': // Not supported
          case 'I': word_bit = WORD_I; gc_block.values.ijk[X_AXIS] = value; ijk_words |= (1<<X_AXIS); break;
    11bc:	40 92 96 0c 	sts	0x0C96, r4	; 0x800c96 <gc_block+0x10>
    11c0:	50 92 97 0c 	sts	0x0C97, r5	; 0x800c97 <gc_block+0x11>
    11c4:	60 92 98 0c 	sts	0x0C98, r6	; 0x800c98 <gc_block+0x12>
    11c8:	70 92 99 0c 	sts	0x0C99, r7	; 0x800c99 <gc_block+0x13>
    11cc:	fb a1       	ldd	r31, Y+35	; 0x23
    11ce:	f1 60       	ori	r31, 0x01	; 1
    11d0:	fb a3       	std	Y+35, r31	; 0x23
    11d2:	81 e0       	ldi	r24, 0x01	; 1
    11d4:	80 c0       	rjmp	.+256    	; 0x12d6 <gc_execute_line+0x4c6>
          case 'J': word_bit = WORD_J; gc_block.values.ijk[Y_AXIS] = value; ijk_words |= (1<<Y_AXIS); break;
    11d6:	40 92 9a 0c 	sts	0x0C9A, r4	; 0x800c9a <gc_block+0x14>
    11da:	50 92 9b 0c 	sts	0x0C9B, r5	; 0x800c9b <gc_block+0x15>
    11de:	60 92 9c 0c 	sts	0x0C9C, r6	; 0x800c9c <gc_block+0x16>
    11e2:	70 92 9d 0c 	sts	0x0C9D, r7	; 0x800c9d <gc_block+0x17>
    11e6:	2b a1       	ldd	r18, Y+35	; 0x23
    11e8:	22 60       	ori	r18, 0x02	; 2
    11ea:	2b a3       	std	Y+35, r18	; 0x23
    11ec:	82 e0       	ldi	r24, 0x02	; 2
    11ee:	73 c0       	rjmp	.+230    	; 0x12d6 <gc_execute_line+0x4c6>
          case 'K': word_bit = WORD_K; gc_block.values.ijk[Z_AXIS] = value; ijk_words |= (1<<Z_AXIS); break;
    11f0:	40 92 9e 0c 	sts	0x0C9E, r4	; 0x800c9e <gc_block+0x18>
    11f4:	50 92 9f 0c 	sts	0x0C9F, r5	; 0x800c9f <gc_block+0x19>
    11f8:	60 92 a0 0c 	sts	0x0CA0, r6	; 0x800ca0 <gc_block+0x1a>
    11fc:	70 92 a1 0c 	sts	0x0CA1, r7	; 0x800ca1 <gc_block+0x1b>
    1200:	3b a1       	ldd	r19, Y+35	; 0x23
    1202:	34 60       	ori	r19, 0x04	; 4
    1204:	3b a3       	std	Y+35, r19	; 0x23
    1206:	83 e0       	ldi	r24, 0x03	; 3
    1208:	66 c0       	rjmp	.+204    	; 0x12d6 <gc_execute_line+0x4c6>
          case 'L': word_bit = WORD_L; gc_block.values.l = int_value; break;
    120a:	a0 92 a2 0c 	sts	0x0CA2, r10	; 0x800ca2 <gc_block+0x1c>
    120e:	84 e0       	ldi	r24, 0x04	; 4
    1210:	62 c0       	rjmp	.+196    	; 0x12d6 <gc_execute_line+0x4c6>
          case 'N': word_bit = WORD_N; gc_block.values.n = trunc(value); break;
    1212:	c3 01       	movw	r24, r6
    1214:	b2 01       	movw	r22, r4
    1216:	0e 94 34 3f 	call	0x7e68	; 0x7e68 <__fixsfsi>
    121a:	60 93 a3 0c 	sts	0x0CA3, r22	; 0x800ca3 <gc_block+0x1d>
    121e:	70 93 a4 0c 	sts	0x0CA4, r23	; 0x800ca4 <gc_block+0x1e>
    1222:	80 93 a5 0c 	sts	0x0CA5, r24	; 0x800ca5 <gc_block+0x1f>
    1226:	90 93 a6 0c 	sts	0x0CA6, r25	; 0x800ca6 <gc_block+0x20>
    122a:	85 e0       	ldi	r24, 0x05	; 5
    122c:	54 c0       	rjmp	.+168    	; 0x12d6 <gc_execute_line+0x4c6>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
    122e:	40 92 a7 0c 	sts	0x0CA7, r4	; 0x800ca7 <gc_block+0x21>
    1232:	50 92 a8 0c 	sts	0x0CA8, r5	; 0x800ca8 <gc_block+0x22>
    1236:	60 92 a9 0c 	sts	0x0CA9, r6	; 0x800ca9 <gc_block+0x23>
    123a:	70 92 aa 0c 	sts	0x0CAA, r7	; 0x800caa <gc_block+0x24>
    123e:	86 e0       	ldi	r24, 0x06	; 6
    1240:	4a c0       	rjmp	.+148    	; 0x12d6 <gc_execute_line+0x4c6>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
    1242:	40 92 ab 0c 	sts	0x0CAB, r4	; 0x800cab <gc_block+0x25>
    1246:	50 92 ac 0c 	sts	0x0CAC, r5	; 0x800cac <gc_block+0x26>
    124a:	60 92 ad 0c 	sts	0x0CAD, r6	; 0x800cad <gc_block+0x27>
    124e:	70 92 ae 0c 	sts	0x0CAE, r7	; 0x800cae <gc_block+0x28>
    1252:	87 e0       	ldi	r24, 0x07	; 7
    1254:	40 c0       	rjmp	.+128    	; 0x12d6 <gc_execute_line+0x4c6>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
    1256:	40 92 af 0c 	sts	0x0CAF, r4	; 0x800caf <gc_block+0x29>
    125a:	50 92 b0 0c 	sts	0x0CB0, r5	; 0x800cb0 <gc_block+0x2a>
    125e:	60 92 b1 0c 	sts	0x0CB1, r6	; 0x800cb1 <gc_block+0x2b>
    1262:	70 92 b2 0c 	sts	0x0CB2, r7	; 0x800cb2 <gc_block+0x2c>
    1266:	88 e0       	ldi	r24, 0x08	; 8
    1268:	36 c0       	rjmp	.+108    	; 0x12d6 <gc_execute_line+0x4c6>
          case 'T': word_bit = WORD_T; 
						if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
    126a:	20 e0       	ldi	r18, 0x00	; 0
    126c:	30 e0       	ldi	r19, 0x00	; 0
    126e:	4f e7       	ldi	r20, 0x7F	; 127
    1270:	53 e4       	ldi	r21, 0x43	; 67
    1272:	c3 01       	movw	r24, r6
    1274:	b2 01       	movw	r22, r4
    1276:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    127a:	18 16       	cp	r1, r24
    127c:	14 f4       	brge	.+4      	; 0x1282 <gc_execute_line+0x472>
    127e:	0c 94 65 11 	jmp	0x22ca	; 0x22ca <__stack+0xcb>
						gc_block.values.t = int_value;
    1282:	a0 92 b3 0c 	sts	0x0CB3, r10	; 0x800cb3 <gc_block+0x2d>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; 
    1286:	89 e0       	ldi	r24, 0x09	; 9
						if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
						gc_block.values.t = int_value;
						break;
    1288:	26 c0       	rjmp	.+76     	; 0x12d6 <gc_execute_line+0x4c6>
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
    128a:	40 92 b4 0c 	sts	0x0CB4, r4	; 0x800cb4 <gc_block+0x2e>
    128e:	50 92 b5 0c 	sts	0x0CB5, r5	; 0x800cb5 <gc_block+0x2f>
    1292:	60 92 b6 0c 	sts	0x0CB6, r6	; 0x800cb6 <gc_block+0x30>
    1296:	70 92 b7 0c 	sts	0x0CB7, r7	; 0x800cb7 <gc_block+0x31>
    129a:	49 a1       	ldd	r20, Y+33	; 0x21
    129c:	41 60       	ori	r20, 0x01	; 1
    129e:	49 a3       	std	Y+33, r20	; 0x21
    12a0:	8a e0       	ldi	r24, 0x0A	; 10
    12a2:	19 c0       	rjmp	.+50     	; 0x12d6 <gc_execute_line+0x4c6>
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
    12a4:	40 92 b8 0c 	sts	0x0CB8, r4	; 0x800cb8 <gc_block+0x32>
    12a8:	50 92 b9 0c 	sts	0x0CB9, r5	; 0x800cb9 <gc_block+0x33>
    12ac:	60 92 ba 0c 	sts	0x0CBA, r6	; 0x800cba <gc_block+0x34>
    12b0:	70 92 bb 0c 	sts	0x0CBB, r7	; 0x800cbb <gc_block+0x35>
    12b4:	89 a1       	ldd	r24, Y+33	; 0x21
    12b6:	82 60       	ori	r24, 0x02	; 2
    12b8:	89 a3       	std	Y+33, r24	; 0x21
    12ba:	8b e0       	ldi	r24, 0x0B	; 11
    12bc:	0c c0       	rjmp	.+24     	; 0x12d6 <gc_execute_line+0x4c6>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
    12be:	40 92 bc 0c 	sts	0x0CBC, r4	; 0x800cbc <gc_block+0x36>
    12c2:	50 92 bd 0c 	sts	0x0CBD, r5	; 0x800cbd <gc_block+0x37>
    12c6:	60 92 be 0c 	sts	0x0CBE, r6	; 0x800cbe <gc_block+0x38>
    12ca:	70 92 bf 0c 	sts	0x0CBF, r7	; 0x800cbf <gc_block+0x39>
    12ce:	99 a1       	ldd	r25, Y+33	; 0x21
    12d0:	94 60       	ori	r25, 0x04	; 4
    12d2:	99 a3       	std	Y+33, r25	; 0x21
    12d4:	8c e0       	ldi	r24, 0x0C	; 12
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        }

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    12d6:	56 01       	movw	r10, r12
    12d8:	08 2e       	mov	r0, r24
    12da:	02 c0       	rjmp	.+4      	; 0x12e0 <gc_execute_line+0x4d0>
    12dc:	aa 0c       	add	r10, r10
    12de:	bb 1c       	adc	r11, r11
    12e0:	0a 94       	dec	r0
    12e2:	e2 f7       	brpl	.-8      	; 0x12dc <gc_execute_line+0x4cc>
    12e4:	91 01       	movw	r18, r2
    12e6:	2a 21       	and	r18, r10
    12e8:	3b 21       	and	r19, r11
    12ea:	23 2b       	or	r18, r19
    12ec:	09 f0       	breq	.+2      	; 0x12f0 <gc_execute_line+0x4e0>
    12ee:	ef c7       	rjmp	.+4062   	; 0x22ce <__stack+0xcf>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
    12f0:	d4 01       	movw	r26, r8
    12f2:	02 c0       	rjmp	.+4      	; 0x12f8 <gc_execute_line+0x4e8>
    12f4:	b5 95       	asr	r27
    12f6:	a7 95       	ror	r26
    12f8:	8a 95       	dec	r24
    12fa:	e2 f7       	brpl	.-8      	; 0x12f4 <gc_execute_line+0x4e4>
    12fc:	a0 ff       	sbrs	r26, 0
    12fe:	0a c0       	rjmp	.+20     	; 0x1314 <gc_execute_line+0x504>
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    1300:	20 e0       	ldi	r18, 0x00	; 0
    1302:	30 e0       	ldi	r19, 0x00	; 0
    1304:	a9 01       	movw	r20, r18
    1306:	c3 01       	movw	r24, r6
    1308:	b2 01       	movw	r22, r4
    130a:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    130e:	88 23       	and	r24, r24
    1310:	0c f4       	brge	.+2      	; 0x1314 <gc_execute_line+0x504>
    1312:	df c7       	rjmp	.+4030   	; 0x22d2 <__stack+0xd3>
        }
        value_words |= bit(word_bit); // Flag to indicate parameter assigned.
    1314:	2a 28       	or	r2, r10
    1316:	3b 28       	or	r3, r11
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
  else { char_counter = 0; }

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    1318:	89 81       	ldd	r24, Y+1	; 0x01
    131a:	ef 8d       	ldd	r30, Y+31	; 0x1f
    131c:	f8 a1       	ldd	r31, Y+32	; 0x20
    131e:	e8 0f       	add	r30, r24
    1320:	f1 1d       	adc	r31, r1
    1322:	10 81       	ld	r17, Z
    1324:	11 11       	cpse	r17, r1
    1326:	c1 cd       	rjmp	.-1150   	; 0xeaa <gc_execute_line+0x9a>

  // [0. Non-specific/common error-checks and miscellaneous setup]:

  // Determine implicit axis command conditions. Axis words have been passed, but no explicit axis
  // command has been sent. If so, set axis command to current motion mode.
  if (axis_words) {
    1328:	b9 a1       	ldd	r27, Y+33	; 0x21
    132a:	bb 23       	and	r27, r27
    132c:	29 f0       	breq	.+10     	; 0x1338 <gc_execute_line+0x528>
    if (!axis_command) { axis_command = AXIS_COMMAND_MOTION_MODE; } // Assign implicit motion-mode
    132e:	ea a1       	ldd	r30, Y+34	; 0x22
    1330:	e1 11       	cpse	r30, r1
    1332:	02 c0       	rjmp	.+4      	; 0x1338 <gc_execute_line+0x528>
    1334:	f2 e0       	ldi	r31, 0x02	; 2
    1336:	fa a3       	std	Y+34, r31	; 0x22
  }

  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    1338:	25 fe       	sbrs	r2, 5
    133a:	0e c0       	rjmp	.+28     	; 0x1358 <gc_execute_line+0x548>
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    133c:	80 91 a3 0c 	lds	r24, 0x0CA3	; 0x800ca3 <gc_block+0x1d>
    1340:	90 91 a4 0c 	lds	r25, 0x0CA4	; 0x800ca4 <gc_block+0x1e>
    1344:	a0 91 a5 0c 	lds	r26, 0x0CA5	; 0x800ca5 <gc_block+0x1f>
    1348:	b0 91 a6 0c 	lds	r27, 0x0CA6	; 0x800ca6 <gc_block+0x20>
    134c:	81 38       	cpi	r24, 0x81	; 129
    134e:	96 49       	sbci	r25, 0x96	; 150
    1350:	a8 49       	sbci	r26, 0x98	; 152
    1352:	b1 05       	cpc	r27, r1
    1354:	0c f0       	brlt	.+2      	; 0x1358 <gc_execute_line+0x548>
    1356:	bf c7       	rjmp	.+3966   	; 0x22d6 <__stack+0xd7>
  // [1. Comments ]: MSG's NOT SUPPORTED. Comment handling performed by protocol.

  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  // NOTE: For jogging, ignore prior feed rate mode. Enforce G94 and check for required F word.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    1358:	3c a1       	ldd	r19, Y+36	; 0x24
    135a:	33 23       	and	r19, r19
    135c:	e1 f0       	breq	.+56     	; 0x1396 <gc_execute_line+0x586>
    if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); }
    135e:	20 fe       	sbrs	r2, 0
    1360:	bc c7       	rjmp	.+3960   	; 0x22da <__stack+0xdb>
    if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    1362:	80 91 89 0c 	lds	r24, 0x0C89	; 0x800c89 <gc_block+0x3>
    1366:	81 30       	cpi	r24, 0x01	; 1
    1368:	09 f0       	breq	.+2      	; 0x136c <gc_execute_line+0x55c>
    136a:	54 c0       	rjmp	.+168    	; 0x1414 <gc_execute_line+0x604>
    136c:	06 e8       	ldi	r16, 0x86	; 134
    136e:	1c e0       	ldi	r17, 0x0C	; 12
    1370:	23 e3       	ldi	r18, 0x33	; 51
    1372:	33 e3       	ldi	r19, 0x33	; 51
    1374:	4b ec       	ldi	r20, 0xCB	; 203
    1376:	51 e4       	ldi	r21, 0x41	; 65
    1378:	d8 01       	movw	r26, r16
    137a:	1c 96       	adiw	r26, 0x0c	; 12
    137c:	6d 91       	ld	r22, X+
    137e:	7d 91       	ld	r23, X+
    1380:	8d 91       	ld	r24, X+
    1382:	9c 91       	ld	r25, X
    1384:	1f 97       	sbiw	r26, 0x0f	; 15
    1386:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    138a:	f8 01       	movw	r30, r16
    138c:	64 87       	std	Z+12, r22	; 0x0c
    138e:	75 87       	std	Z+13, r23	; 0x0d
    1390:	86 87       	std	Z+14, r24	; 0x0e
    1392:	97 87       	std	Z+15, r25	; 0x0f
    1394:	3f c0       	rjmp	.+126    	; 0x1414 <gc_execute_line+0x604>
  } else {
    if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    1396:	80 91 88 0c 	lds	r24, 0x0C88	; 0x800c88 <gc_block+0x2>
    139a:	81 30       	cpi	r24, 0x01	; 1
    139c:	61 f4       	brne	.+24     	; 0x13b6 <gc_execute_line+0x5a6>
      // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
      if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    139e:	fa a1       	ldd	r31, Y+34	; 0x22
    13a0:	f2 30       	cpi	r31, 0x02	; 2
    13a2:	c1 f5       	brne	.+112    	; 0x1414 <gc_execute_line+0x604>
        if ((gc_block.modal.motion != MOTION_MODE_NONE) && (gc_block.modal.motion != MOTION_MODE_SEEK)) {
    13a4:	80 91 87 0c 	lds	r24, 0x0C87	; 0x800c87 <gc_block+0x1>
    13a8:	80 35       	cpi	r24, 0x50	; 80
    13aa:	a1 f1       	breq	.+104    	; 0x1414 <gc_execute_line+0x604>
    13ac:	88 23       	and	r24, r24
    13ae:	91 f1       	breq	.+100    	; 0x1414 <gc_execute_line+0x604>
          if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    13b0:	20 fe       	sbrs	r2, 0
    13b2:	95 c7       	rjmp	.+3882   	; 0x22de <__stack+0xdf>
    13b4:	2f c0       	rjmp	.+94     	; 0x1414 <gc_execute_line+0x604>
      // value in the block. If no F word is passed with a motion command that requires a feed rate, this will error
      // out in the motion modes error-checking. However, if no F word is passed with NO motion command that requires
      // a feed rate, we simply move on and the state feed rate value gets updated to zero and remains undefined.
    } else { // = G94
      // - In units per mm mode: If F word passed, ensure value is in mm/min, otherwise push last state value.
      if (gc_state.modal.feed_rate == FEED_RATE_MODE_UNITS_PER_MIN) { // Last state is also G94
    13b6:	80 91 47 0c 	lds	r24, 0x0C47	; 0x800c47 <gc_state+0x1>
    13ba:	81 11       	cpse	r24, r1
    13bc:	2b c0       	rjmp	.+86     	; 0x1414 <gc_execute_line+0x604>
        if (bit_istrue(value_words,bit(WORD_F))) {
    13be:	20 fe       	sbrs	r2, 0
    13c0:	19 c0       	rjmp	.+50     	; 0x13f4 <gc_execute_line+0x5e4>
          if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    13c2:	80 91 89 0c 	lds	r24, 0x0C89	; 0x800c89 <gc_block+0x3>
    13c6:	81 30       	cpi	r24, 0x01	; 1
    13c8:	29 f5       	brne	.+74     	; 0x1414 <gc_execute_line+0x604>
    13ca:	06 e8       	ldi	r16, 0x86	; 134
    13cc:	1c e0       	ldi	r17, 0x0C	; 12
    13ce:	23 e3       	ldi	r18, 0x33	; 51
    13d0:	33 e3       	ldi	r19, 0x33	; 51
    13d2:	4b ec       	ldi	r20, 0xCB	; 203
    13d4:	51 e4       	ldi	r21, 0x41	; 65
    13d6:	d8 01       	movw	r26, r16
    13d8:	1c 96       	adiw	r26, 0x0c	; 12
    13da:	6d 91       	ld	r22, X+
    13dc:	7d 91       	ld	r23, X+
    13de:	8d 91       	ld	r24, X+
    13e0:	9c 91       	ld	r25, X
    13e2:	1f 97       	sbiw	r26, 0x0f	; 15
    13e4:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    13e8:	f8 01       	movw	r30, r16
    13ea:	64 87       	std	Z+12, r22	; 0x0c
    13ec:	75 87       	std	Z+13, r23	; 0x0d
    13ee:	86 87       	std	Z+14, r24	; 0x0e
    13f0:	97 87       	std	Z+15, r25	; 0x0f
    13f2:	10 c0       	rjmp	.+32     	; 0x1414 <gc_execute_line+0x604>
        } else {
          gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
    13f4:	80 91 55 0c 	lds	r24, 0x0C55	; 0x800c55 <gc_state+0xf>
    13f8:	90 91 56 0c 	lds	r25, 0x0C56	; 0x800c56 <gc_state+0x10>
    13fc:	a0 91 57 0c 	lds	r26, 0x0C57	; 0x800c57 <gc_state+0x11>
    1400:	b0 91 58 0c 	lds	r27, 0x0C58	; 0x800c58 <gc_state+0x12>
    1404:	80 93 92 0c 	sts	0x0C92, r24	; 0x800c92 <gc_block+0xc>
    1408:	90 93 93 0c 	sts	0x0C93, r25	; 0x800c93 <gc_block+0xd>
    140c:	a0 93 94 0c 	sts	0x0C94, r26	; 0x800c94 <gc_block+0xe>
    1410:	b0 93 95 0c 	sts	0x0C95, r27	; 0x800c95 <gc_block+0xf>
    }
  }
  // bit_false(value_words,bit(WORD_F)); // NOTE: Single-meaning value word. Set at end of error-checking.

  // [4. Set spindle speed ]: S is negative (done.)
  if (bit_isfalse(value_words,bit(WORD_S))) { gc_block.values.s = gc_state.spindle_speed; }
    1414:	30 fc       	sbrc	r3, 0
    1416:	10 c0       	rjmp	.+32     	; 0x1438 <gc_execute_line+0x628>
    1418:	80 91 51 0c 	lds	r24, 0x0C51	; 0x800c51 <gc_state+0xb>
    141c:	90 91 52 0c 	lds	r25, 0x0C52	; 0x800c52 <gc_state+0xc>
    1420:	a0 91 53 0c 	lds	r26, 0x0C53	; 0x800c53 <gc_state+0xd>
    1424:	b0 91 54 0c 	lds	r27, 0x0C54	; 0x800c54 <gc_state+0xe>
    1428:	80 93 af 0c 	sts	0x0CAF, r24	; 0x800caf <gc_block+0x29>
    142c:	90 93 b0 0c 	sts	0x0CB0, r25	; 0x800cb0 <gc_block+0x2a>
    1430:	a0 93 b1 0c 	sts	0x0CB1, r26	; 0x800cb1 <gc_block+0x2b>
    1434:	b0 93 b2 0c 	sts	0x0CB2, r27	; 0x800cb2 <gc_block+0x2c>
      }
    }
  #endif

  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    1438:	80 91 86 0c 	lds	r24, 0x0C86	; 0x800c86 <gc_block>
    143c:	84 30       	cpi	r24, 0x04	; 4
    143e:	21 f4       	brne	.+8      	; 0x1448 <gc_execute_line+0x638>
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    1440:	26 fe       	sbrs	r2, 6
    1442:	4f c7       	rjmp	.+3742   	; 0x22e2 <__stack+0xe3>
    bit_false(value_words,bit(WORD_P));
    1444:	e8 94       	clt
    1446:	26 f8       	bld	r2, 6
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    1448:	80 91 8b 0c 	lds	r24, 0x0C8B	; 0x800c8b <gc_block+0x5>
    144c:	88 23       	and	r24, r24
    144e:	49 f0       	breq	.+18     	; 0x1462 <gc_execute_line+0x652>
    1450:	81 30       	cpi	r24, 0x01	; 1
    1452:	09 f4       	brne	.+2      	; 0x1456 <gc_execute_line+0x646>
    1454:	98 c7       	rjmp	.+3888   	; 0x2386 <__stack+0x187>
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
      axis_linear = X_AXIS;
    1456:	1f a6       	std	Y+47, r1	; 0x2f
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
    1458:	f2 e0       	ldi	r31, 0x02	; 2
    145a:	fe a3       	std	Y+38, r31	; 0x26
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
    145c:	21 e0       	ldi	r18, 0x01	; 1
    145e:	2d a3       	std	Y+37, r18	; 0x25
    1460:	97 c7       	rjmp	.+3886   	; 0x2390 <__stack+0x191>
  }

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    1462:	80 91 89 0c 	lds	r24, 0x0C89	; 0x800c89 <gc_block+0x3>
    1466:	81 30       	cpi	r24, 0x01	; 1
    1468:	a1 f5       	brne	.+104    	; 0x14d2 <gc_execute_line+0x6c2>
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    146a:	32 e0       	ldi	r19, 0x02	; 2
    146c:	3f a7       	std	Y+47, r19	; 0x2f

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    146e:	41 e0       	ldi	r20, 0x01	; 1
    1470:	4e a3       	std	Y+38, r20	; 0x26
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    1472:	1d a2       	std	Y+37, r1	; 0x25
    1474:	0f 2e       	mov	r0, r31
    1476:	f6 e8       	ldi	r31, 0x86	; 134
    1478:	af 2e       	mov	r10, r31
    147a:	fc e0       	ldi	r31, 0x0C	; 12
    147c:	bf 2e       	mov	r11, r31
    147e:	f0 2d       	mov	r31, r0
    1480:	00 e0       	ldi	r16, 0x00	; 0
    1482:	10 e0       	ldi	r17, 0x00	; 0
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
      if (bit_istrue(axis_words,bit(idx)) ) {
    1484:	89 a1       	ldd	r24, Y+33	; 0x21
    1486:	c8 2e       	mov	r12, r24
    1488:	d1 2c       	mov	r13, r1
    148a:	c6 01       	movw	r24, r12
    148c:	00 2e       	mov	r0, r16
    148e:	02 c0       	rjmp	.+4      	; 0x1494 <gc_execute_line+0x684>
    1490:	95 95       	asr	r25
    1492:	87 95       	ror	r24
    1494:	0a 94       	dec	r0
    1496:	e2 f7       	brpl	.-8      	; 0x1490 <gc_execute_line+0x680>
    1498:	80 ff       	sbrs	r24, 0
    149a:	12 c0       	rjmp	.+36     	; 0x14c0 <gc_execute_line+0x6b0>
        gc_block.values.xyz[idx] *= MM_PER_INCH;
    149c:	23 e3       	ldi	r18, 0x33	; 51
    149e:	33 e3       	ldi	r19, 0x33	; 51
    14a0:	4b ec       	ldi	r20, 0xCB	; 203
    14a2:	51 e4       	ldi	r21, 0x41	; 65
    14a4:	d5 01       	movw	r26, r10
    14a6:	9e 96       	adiw	r26, 0x2e	; 46
    14a8:	6d 91       	ld	r22, X+
    14aa:	7d 91       	ld	r23, X+
    14ac:	8d 91       	ld	r24, X+
    14ae:	9c 91       	ld	r25, X
    14b0:	d1 97       	sbiw	r26, 0x31	; 49
    14b2:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    14b6:	f5 01       	movw	r30, r10
    14b8:	66 a7       	std	Z+46, r22	; 0x2e
    14ba:	77 a7       	std	Z+47, r23	; 0x2f
    14bc:	80 ab       	std	Z+48, r24	; 0x30
    14be:	91 ab       	std	Z+49, r25	; 0x31
    14c0:	0f 5f       	subi	r16, 0xFF	; 255
    14c2:	1f 4f       	sbci	r17, 0xFF	; 255
    14c4:	f4 e0       	ldi	r31, 0x04	; 4
    14c6:	af 0e       	add	r10, r31
    14c8:	b1 1c       	adc	r11, r1

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    14ca:	03 30       	cpi	r16, 0x03	; 3
    14cc:	11 05       	cpc	r17, r1
    14ce:	e9 f6       	brne	.-70     	; 0x148a <gc_execute_line+0x67a>
    14d0:	05 c0       	rjmp	.+10     	; 0x14dc <gc_execute_line+0x6cc>
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    14d2:	22 e0       	ldi	r18, 0x02	; 2
    14d4:	2f a7       	std	Y+47, r18	; 0x2f

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    14d6:	31 e0       	ldi	r19, 0x01	; 1
    14d8:	3e a3       	std	Y+38, r19	; 0x26
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    14da:	1d a2       	std	Y+37, r1	; 0x25
  // [14. Cutter length compensation ]: G43 NOT SUPPORTED, but G43.1 and G49 are.
  // [G43.1 Errors]: Motion command in same line.
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    14dc:	4a a1       	ldd	r20, Y+34	; 0x22
    14de:	43 30       	cpi	r20, 0x03	; 3
    14e0:	41 f4       	brne	.+16     	; 0x14f2 <gc_execute_line+0x6e2>
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
    14e2:	80 91 8c 0c 	lds	r24, 0x0C8C	; 0x800c8c <gc_block+0x6>
    14e6:	81 30       	cpi	r24, 0x01	; 1
    14e8:	21 f4       	brne	.+8      	; 0x14f2 <gc_execute_line+0x6e2>
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    14ea:	89 a1       	ldd	r24, Y+33	; 0x21
    14ec:	84 30       	cpi	r24, 0x04	; 4
    14ee:	09 f0       	breq	.+2      	; 0x14f2 <gc_execute_line+0x6e2>
    14f0:	fa c6       	rjmp	.+3572   	; 0x22e6 <__stack+0xe7>
  // TODO: An EEPROM read of the coordinate data may require a buffer sync when the cycle
  // is active. The read pauses the processor temporarily and may cause a rare crash. For
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  float block_coord_system[N_AXIS];
  memcpy(block_coord_system,gc_state.coord_system,sizeof(gc_state.coord_system));
    14f2:	8c e0       	ldi	r24, 0x0C	; 12
    14f4:	ea e6       	ldi	r30, 0x6A	; 106
    14f6:	fc e0       	ldi	r31, 0x0C	; 12
    14f8:	de 01       	movw	r26, r28
    14fa:	16 96       	adiw	r26, 0x06	; 6
    14fc:	01 90       	ld	r0, Z+
    14fe:	0d 92       	st	X+, r0
    1500:	8a 95       	dec	r24
    1502:	e1 f7       	brne	.-8      	; 0x14fc <gc_execute_line+0x6ec>
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    1504:	f1 fe       	sbrs	r15, 1
    1506:	11 c0       	rjmp	.+34     	; 0x152a <gc_execute_line+0x71a>
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    1508:	80 91 8d 0c 	lds	r24, 0x0C8D	; 0x800c8d <gc_block+0x7>
    150c:	87 30       	cpi	r24, 0x07	; 7
    150e:	08 f0       	brcs	.+2      	; 0x1512 <gc_execute_line+0x702>
    1510:	ec c6       	rjmp	.+3544   	; 0x22ea <__stack+0xeb>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    1512:	90 91 4c 0c 	lds	r25, 0x0C4C	; 0x800c4c <gc_state+0x6>
    1516:	89 17       	cp	r24, r25
    1518:	41 f0       	breq	.+16     	; 0x152a <gc_execute_line+0x71a>
      if (!(settings_read_coord_data(gc_block.modal.coord_select,block_coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    151a:	be 01       	movw	r22, r28
    151c:	6a 5f       	subi	r22, 0xFA	; 250
    151e:	7f 4f       	sbci	r23, 0xFF	; 255
    1520:	0e 94 82 25 	call	0x4b04	; 0x4b04 <settings_read_coord_data>
    1524:	88 23       	and	r24, r24
    1526:	09 f4       	brne	.+2      	; 0x152a <gc_execute_line+0x71a>
    1528:	e2 c6       	rjmp	.+3524   	; 0x22ee <__stack+0xef>
  // [19. Remaining non-modal actions ]: Check go to predefined position, set G10, or set axis offsets.
  // NOTE: We need to separate the non-modal commands that are axis word-using (G10/G28/G30/G92), as these
  // commands all treat axis words differently. G10 as absolute offsets or computes current position as
  // the axis value, G92 similarly to G10 L20, and G28/30 as an intermediate target position that observes
  // all the current coordinate system and G92 offsets.
  switch (gc_block.non_modal_command) {
    152a:	b0 90 86 0c 	lds	r11, 0x0C86	; 0x800c86 <gc_block>
    152e:	9a e0       	ldi	r25, 0x0A	; 10
    1530:	b9 16       	cp	r11, r25
    1532:	29 f0       	breq	.+10     	; 0x153e <gc_execute_line+0x72e>
    1534:	ac e5       	ldi	r26, 0x5C	; 92
    1536:	ba 16       	cp	r11, r26
    1538:	09 f4       	brne	.+2      	; 0x153c <gc_execute_line+0x72c>
    153a:	9a c0       	rjmp	.+308    	; 0x1670 <gc_execute_line+0x860>
    153c:	0e c1       	rjmp	.+540    	; 0x175a <gc_execute_line+0x94a>
    case NON_MODAL_SET_COORDINATE_DATA:
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    153e:	b9 a1       	ldd	r27, Y+33	; 0x21
    1540:	bb 23       	and	r27, r27
    1542:	09 f4       	brne	.+2      	; 0x1546 <gc_execute_line+0x736>
    1544:	d6 c6       	rjmp	.+3500   	; 0x22f2 <__stack+0xf3>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    1546:	c1 01       	movw	r24, r2
    1548:	80 75       	andi	r24, 0x50	; 80
    154a:	99 27       	eor	r25, r25
    154c:	89 2b       	or	r24, r25
    154e:	09 f4       	brne	.+2      	; 0x1552 <gc_execute_line+0x742>
    1550:	d2 c6       	rjmp	.+3492   	; 0x22f6 <__stack+0xf7>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
    1552:	60 91 a7 0c 	lds	r22, 0x0CA7	; 0x800ca7 <gc_block+0x21>
    1556:	70 91 a8 0c 	lds	r23, 0x0CA8	; 0x800ca8 <gc_block+0x22>
    155a:	80 91 a9 0c 	lds	r24, 0x0CA9	; 0x800ca9 <gc_block+0x23>
    155e:	90 91 aa 0c 	lds	r25, 0x0CAA	; 0x800caa <gc_block+0x24>
    1562:	0e 94 d1 41 	call	0x83a2	; 0x83a2 <trunc>
    1566:	0e 94 39 3f 	call	0x7e72	; 0x7e72 <__fixunssfsi>
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    156a:	67 30       	cpi	r22, 0x07	; 7
    156c:	08 f0       	brcs	.+2      	; 0x1570 <gc_execute_line+0x760>
    156e:	c5 c6       	rjmp	.+3466   	; 0x22fa <__stack+0xfb>
      if (gc_block.values.l != 20) {
    1570:	80 91 a2 0c 	lds	r24, 0x0CA2	; 0x800ca2 <gc_block+0x1c>
    1574:	84 31       	cpi	r24, 0x14	; 20
    1576:	29 f0       	breq	.+10     	; 0x1582 <gc_execute_line+0x772>
        if (gc_block.values.l == 2) {
    1578:	82 30       	cpi	r24, 0x02	; 2
    157a:	09 f0       	breq	.+2      	; 0x157e <gc_execute_line+0x76e>
    157c:	c0 c6       	rjmp	.+3456   	; 0x22fe <__stack+0xff>
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    157e:	27 fc       	sbrc	r2, 7
    1580:	c0 c6       	rjmp	.+3456   	; 0x2302 <__stack+0x103>
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
      }
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
    1582:	ef ea       	ldi	r30, 0xAF	; 175
    1584:	2e 22       	and	r2, r30

      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
    1586:	66 23       	and	r22, r22
    1588:	19 f0       	breq	.+6      	; 0x1590 <gc_execute_line+0x780>
    158a:	61 50       	subi	r22, 0x01	; 1
    158c:	6f 8f       	std	Y+31, r22	; 0x1f
    158e:	03 c0       	rjmp	.+6      	; 0x1596 <gc_execute_line+0x786>
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
    1590:	f0 91 8d 0c 	lds	r31, 0x0C8D	; 0x800c8d <gc_block+0x7>
    1594:	ff 8f       	std	Y+31, r31	; 0x1f
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    1596:	66 e9       	ldi	r22, 0x96	; 150
    1598:	7c e0       	ldi	r23, 0x0C	; 12
    159a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    159c:	0e 94 82 25 	call	0x4b04	; 0x4b04 <settings_read_coord_data>
    15a0:	88 23       	and	r24, r24
    15a2:	09 f4       	brne	.+2      	; 0x15a6 <gc_execute_line+0x796>
    15a4:	b0 c6       	rjmp	.+3424   	; 0x2306 <__stack+0x107>

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
          if (gc_block.values.l == 20) {
    15a6:	20 91 a2 0c 	lds	r18, 0x0CA2	; 0x800ca2 <gc_block+0x1c>
    15aa:	2f a3       	std	Y+39, r18	; 0x27
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            // WPos = MPos - WCS - G92 - TLO  ->  WCS = MPos - G92 - TLO - WPos
            gc_block.values.ijk[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.ijk[idx] -= gc_state.tool_length_offset; }
    15ac:	40 90 82 0c 	lds	r4, 0x0C82	; 0x800c82 <gc_state+0x3c>
    15b0:	50 90 83 0c 	lds	r5, 0x0C83	; 0x800c83 <gc_state+0x3d>
    15b4:	60 90 84 0c 	lds	r6, 0x0C84	; 0x800c84 <gc_state+0x3e>
    15b8:	70 90 85 0c 	lds	r7, 0x0C85	; 0x800c85 <gc_state+0x3f>
    15bc:	06 e8       	ldi	r16, 0x86	; 134
    15be:	1c e0       	ldi	r17, 0x0C	; 12
    15c0:	0f 2e       	mov	r0, r31
    15c2:	f6 e4       	ldi	r31, 0x46	; 70
    15c4:	cf 2e       	mov	r12, r31
    15c6:	fc e0       	ldi	r31, 0x0C	; 12
    15c8:	df 2e       	mov	r13, r31
    15ca:	f0 2d       	mov	r31, r0
    15cc:	a1 2c       	mov	r10, r1
    15ce:	b1 2c       	mov	r11, r1
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
    15d0:	39 a1       	ldd	r19, Y+33	; 0x21
    15d2:	83 2e       	mov	r8, r19
    15d4:	91 2c       	mov	r9, r1
    15d6:	c4 01       	movw	r24, r8
    15d8:	0a 2c       	mov	r0, r10
    15da:	02 c0       	rjmp	.+4      	; 0x15e0 <gc_execute_line+0x7d0>
    15dc:	95 95       	asr	r25
    15de:	87 95       	ror	r24
    15e0:	0a 94       	dec	r0
    15e2:	e2 f7       	brpl	.-8      	; 0x15dc <gc_execute_line+0x7cc>
    15e4:	80 ff       	sbrs	r24, 0
    15e6:	36 c0       	rjmp	.+108    	; 0x1654 <gc_execute_line+0x844>
          if (gc_block.values.l == 20) {
    15e8:	4f a1       	ldd	r20, Y+39	; 0x27
    15ea:	44 31       	cpi	r20, 0x14	; 20
    15ec:	51 f5       	brne	.+84     	; 0x1642 <gc_execute_line+0x832>
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            // WPos = MPos - WCS - G92 - TLO  ->  WCS = MPos - G92 - TLO - WPos
            gc_block.values.ijk[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
    15ee:	d6 01       	movw	r26, r12
    15f0:	d0 96       	adiw	r26, 0x30	; 48
    15f2:	2d 91       	ld	r18, X+
    15f4:	3d 91       	ld	r19, X+
    15f6:	4d 91       	ld	r20, X+
    15f8:	5c 91       	ld	r21, X
    15fa:	d3 97       	sbiw	r26, 0x33	; 51
    15fc:	58 96       	adiw	r26, 0x18	; 24
    15fe:	6d 91       	ld	r22, X+
    1600:	7d 91       	ld	r23, X+
    1602:	8d 91       	ld	r24, X+
    1604:	9c 91       	ld	r25, X
    1606:	5b 97       	sbiw	r26, 0x1b	; 27
    1608:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    160c:	f8 01       	movw	r30, r16
    160e:	26 a5       	ldd	r18, Z+46	; 0x2e
    1610:	37 a5       	ldd	r19, Z+47	; 0x2f
    1612:	40 a9       	ldd	r20, Z+48	; 0x30
    1614:	51 a9       	ldd	r21, Z+49	; 0x31
    1616:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    161a:	d8 01       	movw	r26, r16
    161c:	50 96       	adiw	r26, 0x10	; 16
    161e:	6d 93       	st	X+, r22
    1620:	7d 93       	st	X+, r23
    1622:	8d 93       	st	X+, r24
    1624:	9c 93       	st	X, r25
    1626:	53 97       	sbiw	r26, 0x13	; 19
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.ijk[idx] -= gc_state.tool_length_offset; }
    1628:	b2 e0       	ldi	r27, 0x02	; 2
    162a:	ab 12       	cpse	r10, r27
    162c:	13 c0       	rjmp	.+38     	; 0x1654 <gc_execute_line+0x844>
    162e:	a3 01       	movw	r20, r6
    1630:	92 01       	movw	r18, r4
    1632:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    1636:	f8 01       	movw	r30, r16
    1638:	60 8b       	std	Z+16, r22	; 0x10
    163a:	71 8b       	std	Z+17, r23	; 0x11
    163c:	82 8b       	std	Z+18, r24	; 0x12
    163e:	93 8b       	std	Z+19, r25	; 0x13
    1640:	09 c0       	rjmp	.+18     	; 0x1654 <gc_execute_line+0x844>
          } else {
            // L2: Update coordinate system axis to programmed value.
            gc_block.values.ijk[idx] = gc_block.values.xyz[idx];
    1642:	f8 01       	movw	r30, r16
    1644:	86 a5       	ldd	r24, Z+46	; 0x2e
    1646:	97 a5       	ldd	r25, Z+47	; 0x2f
    1648:	a0 a9       	ldd	r26, Z+48	; 0x30
    164a:	b1 a9       	ldd	r27, Z+49	; 0x31
    164c:	80 8b       	std	Z+16, r24	; 0x10
    164e:	91 8b       	std	Z+17, r25	; 0x11
    1650:	a2 8b       	std	Z+18, r26	; 0x12
    1652:	b3 8b       	std	Z+19, r27	; 0x13
    1654:	ff ef       	ldi	r31, 0xFF	; 255
    1656:	af 1a       	sub	r10, r31
    1658:	bf 0a       	sbc	r11, r31
    165a:	0c 5f       	subi	r16, 0xFC	; 252
    165c:	1f 4f       	sbci	r17, 0xFF	; 255
    165e:	24 e0       	ldi	r18, 0x04	; 4
    1660:	c2 0e       	add	r12, r18
    1662:	d1 1c       	adc	r13, r1
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    1664:	33 e0       	ldi	r19, 0x03	; 3
    1666:	a3 16       	cp	r10, r19
    1668:	b1 04       	cpc	r11, r1
    166a:	09 f0       	breq	.+2      	; 0x166e <gc_execute_line+0x85e>
    166c:	b4 cf       	rjmp	.-152    	; 0x15d6 <gc_execute_line+0x7c6>
    166e:	a2 c6       	rjmp	.+3396   	; 0x23b4 <__stack+0x1b5>
        } // Else, keep current stored value.
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1670:	49 a1       	ldd	r20, Y+33	; 0x21
    1672:	44 23       	and	r20, r20
    1674:	09 f4       	brne	.+2      	; 0x1678 <gc_execute_line+0x868>
    1676:	49 c6       	rjmp	.+3218   	; 0x230a <__stack+0x10b>
    1678:	0f 2e       	mov	r0, r31
    167a:	f6 e4       	ldi	r31, 0x46	; 70
    167c:	af 2e       	mov	r10, r31
    167e:	fc e0       	ldi	r31, 0x0C	; 12
    1680:	bf 2e       	mov	r11, r31
    1682:	f0 2d       	mov	r31, r0
    1684:	4e 01       	movw	r8, r28
    1686:	86 e0       	ldi	r24, 0x06	; 6
    1688:	88 0e       	add	r8, r24
    168a:	91 1c       	adc	r9, r1
    168c:	06 e8       	ldi	r16, 0x86	; 134
    168e:	1c e0       	ldi	r17, 0x0C	; 12
    1690:	c1 2c       	mov	r12, r1
    1692:	d1 2c       	mov	r13, r1

      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
    1694:	64 2e       	mov	r6, r20
    1696:	71 2c       	mov	r7, r1
    1698:	c3 01       	movw	r24, r6
    169a:	0c 2c       	mov	r0, r12
    169c:	02 c0       	rjmp	.+4      	; 0x16a2 <gc_execute_line+0x892>
    169e:	95 95       	asr	r25
    16a0:	87 95       	ror	r24
    16a2:	0a 94       	dec	r0
    16a4:	e2 f7       	brpl	.-8      	; 0x169e <gc_execute_line+0x88e>
    16a6:	80 ff       	sbrs	r24, 0
    16a8:	3c c0       	rjmp	.+120    	; 0x1722 <gc_execute_line+0x912>
          // WPos = MPos - WCS - G92 - TLO  ->  G92 = MPos - WCS - TLO - WPos
          gc_block.values.xyz[idx] = gc_state.position[idx]-block_coord_system[idx]-gc_block.values.xyz[idx];
    16aa:	d4 01       	movw	r26, r8
    16ac:	2d 91       	ld	r18, X+
    16ae:	3d 91       	ld	r19, X+
    16b0:	4d 91       	ld	r20, X+
    16b2:	5c 91       	ld	r21, X
    16b4:	f5 01       	movw	r30, r10
    16b6:	60 8d       	ldd	r22, Z+24	; 0x18
    16b8:	71 8d       	ldd	r23, Z+25	; 0x19
    16ba:	82 8d       	ldd	r24, Z+26	; 0x1a
    16bc:	93 8d       	ldd	r25, Z+27	; 0x1b
    16be:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    16c2:	d8 01       	movw	r26, r16
    16c4:	9e 96       	adiw	r26, 0x2e	; 46
    16c6:	2d 91       	ld	r18, X+
    16c8:	3d 91       	ld	r19, X+
    16ca:	4d 91       	ld	r20, X+
    16cc:	5c 91       	ld	r21, X
    16ce:	d1 97       	sbiw	r26, 0x31	; 49
    16d0:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    16d4:	f8 01       	movw	r30, r16
    16d6:	66 a7       	std	Z+46, r22	; 0x2e
    16d8:	77 a7       	std	Z+47, r23	; 0x2f
    16da:	80 ab       	std	Z+48, r24	; 0x30
    16dc:	91 ab       	std	Z+49, r25	; 0x31
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
    16de:	f2 e0       	ldi	r31, 0x02	; 2
    16e0:	cf 12       	cpse	r12, r31
    16e2:	29 c0       	rjmp	.+82     	; 0x1736 <gc_execute_line+0x926>
    16e4:	86 01       	movw	r16, r12
    16e6:	00 0f       	add	r16, r16
    16e8:	11 1f       	adc	r17, r17
    16ea:	00 0f       	add	r16, r16
    16ec:	11 1f       	adc	r17, r17
    16ee:	0a 57       	subi	r16, 0x7A	; 122
    16f0:	13 4f       	sbci	r17, 0xF3	; 243
    16f2:	20 91 82 0c 	lds	r18, 0x0C82	; 0x800c82 <gc_state+0x3c>
    16f6:	30 91 83 0c 	lds	r19, 0x0C83	; 0x800c83 <gc_state+0x3d>
    16fa:	40 91 84 0c 	lds	r20, 0x0C84	; 0x800c84 <gc_state+0x3e>
    16fe:	50 91 85 0c 	lds	r21, 0x0C85	; 0x800c85 <gc_state+0x3f>
    1702:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    1706:	d8 01       	movw	r26, r16
    1708:	9e 96       	adiw	r26, 0x2e	; 46
    170a:	6d 93       	st	X+, r22
    170c:	7d 93       	st	X+, r23
    170e:	8d 93       	st	X+, r24
    1710:	9c 93       	st	X, r25
    1712:	d1 97       	sbiw	r26, 0x31	; 49
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    1714:	10 91 87 0c 	lds	r17, 0x0C87	; 0x800c87 <gc_block+0x1>
    1718:	10 35       	cpi	r17, 0x50	; 80
    171a:	09 f4       	brne	.+2      	; 0x171e <gc_execute_line+0x90e>
    171c:	f8 c5       	rjmp	.+3056   	; 0x230e <__stack+0x10f>
    171e:	1f 8e       	std	Y+31, r1	; 0x1f
    1720:	f8 c0       	rjmp	.+496    	; 0x1912 <gc_execute_line+0xb02>
        if (bit_istrue(axis_words,bit(idx)) ) {
          // WPos = MPos - WCS - G92 - TLO  ->  G92 = MPos - WCS - TLO - WPos
          gc_block.values.xyz[idx] = gc_state.position[idx]-block_coord_system[idx]-gc_block.values.xyz[idx];
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
        } else {
          gc_block.values.xyz[idx] = gc_state.coord_offset[idx];
    1722:	f5 01       	movw	r30, r10
    1724:	80 a9       	ldd	r24, Z+48	; 0x30
    1726:	91 a9       	ldd	r25, Z+49	; 0x31
    1728:	a2 a9       	ldd	r26, Z+50	; 0x32
    172a:	b3 a9       	ldd	r27, Z+51	; 0x33
    172c:	f8 01       	movw	r30, r16
    172e:	86 a7       	std	Z+46, r24	; 0x2e
    1730:	97 a7       	std	Z+47, r25	; 0x2f
    1732:	a0 ab       	std	Z+48, r26	; 0x30
    1734:	b1 ab       	std	Z+49, r27	; 0x31
    1736:	ff ef       	ldi	r31, 0xFF	; 255
    1738:	cf 1a       	sub	r12, r31
    173a:	df 0a       	sbc	r13, r31
    173c:	24 e0       	ldi	r18, 0x04	; 4
    173e:	a2 0e       	add	r10, r18
    1740:	b1 1c       	adc	r11, r1
    1742:	34 e0       	ldi	r19, 0x04	; 4
    1744:	83 0e       	add	r8, r19
    1746:	91 1c       	adc	r9, r1
    1748:	0c 5f       	subi	r16, 0xFC	; 252
    174a:	1f 4f       	sbci	r17, 0xFF	; 255
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]

      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    174c:	43 e0       	ldi	r20, 0x03	; 3
    174e:	c4 16       	cp	r12, r20
    1750:	d1 04       	cpc	r13, r1
    1752:	09 f0       	breq	.+2      	; 0x1756 <gc_execute_line+0x946>
    1754:	a1 cf       	rjmp	.-190    	; 0x1698 <gc_execute_line+0x888>
  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes

  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    1756:	1f 8e       	std	Y+31, r1	; 0x1f
    1758:	2d c6       	rjmp	.+3162   	; 0x23b4 <__stack+0x1b5>

      // At this point, the rest of the explicit axis commands treat the axis values as the traditional
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
    175a:	8a a1       	ldd	r24, Y+34	; 0x22
    175c:	83 30       	cpi	r24, 0x03	; 3
    175e:	09 f4       	brne	.+2      	; 0x1762 <gc_execute_line+0x952>
    1760:	90 c0       	rjmp	.+288    	; 0x1882 <gc_execute_line+0xa72>
        if (axis_words) {
    1762:	99 a1       	ldd	r25, Y+33	; 0x21
    1764:	99 23       	and	r25, r25
    1766:	09 f4       	brne	.+2      	; 0x176a <gc_execute_line+0x95a>
    1768:	8c c0       	rjmp	.+280    	; 0x1882 <gc_execute_line+0xa72>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    176a:	a0 90 8a 0c 	lds	r10, 0x0C8A	; 0x800c8a <gc_block+0x4>
    176e:	0f 2e       	mov	r0, r31
    1770:	f6 e4       	ldi	r31, 0x46	; 70
    1772:	cf 2e       	mov	r12, r31
    1774:	fc e0       	ldi	r31, 0x0C	; 12
    1776:	df 2e       	mov	r13, r31
    1778:	f0 2d       	mov	r31, r0
    177a:	06 e8       	ldi	r16, 0x86	; 134
    177c:	1c e0       	ldi	r17, 0x0C	; 12
    177e:	3e 01       	movw	r6, r28
    1780:	a6 e0       	ldi	r26, 0x06	; 6
    1782:	6a 0e       	add	r6, r26
    1784:	71 1c       	adc	r7, r1
    1786:	81 2c       	mov	r8, r1
    1788:	91 2c       	mov	r9, r1
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
            if ( bit_isfalse(axis_words,bit(idx)) ) {
    178a:	49 2e       	mov	r4, r25
    178c:	51 2c       	mov	r5, r1
    178e:	98 a2       	std	Y+32, r9	; 0x20
    1790:	8f 8e       	std	Y+31, r8	; 0x1f
    1792:	c2 01       	movw	r24, r4
    1794:	08 2c       	mov	r0, r8
    1796:	02 c0       	rjmp	.+4      	; 0x179c <gc_execute_line+0x98c>
    1798:	95 95       	asr	r25
    179a:	87 95       	ror	r24
    179c:	0a 94       	dec	r0
    179e:	e2 f7       	brpl	.-8      	; 0x1798 <gc_execute_line+0x988>
    17a0:	80 fd       	sbrc	r24, 0
    17a2:	0b c0       	rjmp	.+22     	; 0x17ba <gc_execute_line+0x9aa>
              gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
    17a4:	f6 01       	movw	r30, r12
    17a6:	80 8d       	ldd	r24, Z+24	; 0x18
    17a8:	91 8d       	ldd	r25, Z+25	; 0x19
    17aa:	a2 8d       	ldd	r26, Z+26	; 0x1a
    17ac:	b3 8d       	ldd	r27, Z+27	; 0x1b
    17ae:	f8 01       	movw	r30, r16
    17b0:	86 a7       	std	Z+46, r24	; 0x2e
    17b2:	97 a7       	std	Z+47, r25	; 0x2f
    17b4:	a0 ab       	std	Z+48, r26	; 0x30
    17b6:	b1 ab       	std	Z+49, r27	; 0x31
    17b8:	54 c0       	rjmp	.+168    	; 0x1862 <gc_execute_line+0xa52>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
    17ba:	f5 e3       	ldi	r31, 0x35	; 53
    17bc:	bf 16       	cp	r11, r31
    17be:	09 f4       	brne	.+2      	; 0x17c2 <gc_execute_line+0x9b2>
    17c0:	50 c0       	rjmp	.+160    	; 0x1862 <gc_execute_line+0xa52>
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    17c2:	a1 10       	cpse	r10, r1
    17c4:	3b c0       	rjmp	.+118    	; 0x183c <gc_execute_line+0xa2c>
                  gc_block.values.xyz[idx] += block_coord_system[idx] + gc_state.coord_offset[idx];
    17c6:	d6 01       	movw	r26, r12
    17c8:	d0 96       	adiw	r26, 0x30	; 48
    17ca:	2d 91       	ld	r18, X+
    17cc:	3d 91       	ld	r19, X+
    17ce:	4d 91       	ld	r20, X+
    17d0:	5c 91       	ld	r21, X
    17d2:	d3 97       	sbiw	r26, 0x33	; 51
    17d4:	f3 01       	movw	r30, r6
    17d6:	60 81       	ld	r22, Z
    17d8:	71 81       	ldd	r23, Z+1	; 0x01
    17da:	82 81       	ldd	r24, Z+2	; 0x02
    17dc:	93 81       	ldd	r25, Z+3	; 0x03
    17de:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    17e2:	d8 01       	movw	r26, r16
    17e4:	9e 96       	adiw	r26, 0x2e	; 46
    17e6:	2d 91       	ld	r18, X+
    17e8:	3d 91       	ld	r19, X+
    17ea:	4d 91       	ld	r20, X+
    17ec:	5c 91       	ld	r21, X
    17ee:	d1 97       	sbiw	r26, 0x31	; 49
    17f0:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    17f4:	9b 01       	movw	r18, r22
    17f6:	ac 01       	movw	r20, r24
    17f8:	f8 01       	movw	r30, r16
    17fa:	66 a7       	std	Z+46, r22	; 0x2e
    17fc:	77 a7       	std	Z+47, r23	; 0x2f
    17fe:	80 ab       	std	Z+48, r24	; 0x30
    1800:	91 ab       	std	Z+49, r25	; 0x31
                  if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_length_offset; }
    1802:	f2 e0       	ldi	r31, 0x02	; 2
    1804:	8f 12       	cpse	r8, r31
    1806:	2d c0       	rjmp	.+90     	; 0x1862 <gc_execute_line+0xa52>
    1808:	0f 8d       	ldd	r16, Y+31	; 0x1f
    180a:	18 a1       	ldd	r17, Y+32	; 0x20
    180c:	00 0f       	add	r16, r16
    180e:	11 1f       	adc	r17, r17
    1810:	00 0f       	add	r16, r16
    1812:	11 1f       	adc	r17, r17
    1814:	0a 57       	subi	r16, 0x7A	; 122
    1816:	13 4f       	sbci	r17, 0xF3	; 243
    1818:	60 91 82 0c 	lds	r22, 0x0C82	; 0x800c82 <gc_state+0x3c>
    181c:	70 91 83 0c 	lds	r23, 0x0C83	; 0x800c83 <gc_state+0x3d>
    1820:	80 91 84 0c 	lds	r24, 0x0C84	; 0x800c84 <gc_state+0x3e>
    1824:	90 91 85 0c 	lds	r25, 0x0C85	; 0x800c85 <gc_state+0x3f>
    1828:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    182c:	d8 01       	movw	r26, r16
    182e:	9e 96       	adiw	r26, 0x2e	; 46
    1830:	6d 93       	st	X+, r22
    1832:	7d 93       	st	X+, r23
    1834:	8d 93       	st	X+, r24
    1836:	9c 93       	st	X, r25
    1838:	d1 97       	sbiw	r26, 0x31	; 49
    183a:	23 c0       	rjmp	.+70     	; 0x1882 <gc_execute_line+0xa72>
                } else {  // Incremental mode
                  gc_block.values.xyz[idx] += gc_state.position[idx];
    183c:	f6 01       	movw	r30, r12
    183e:	20 8d       	ldd	r18, Z+24	; 0x18
    1840:	31 8d       	ldd	r19, Z+25	; 0x19
    1842:	42 8d       	ldd	r20, Z+26	; 0x1a
    1844:	53 8d       	ldd	r21, Z+27	; 0x1b
    1846:	d8 01       	movw	r26, r16
    1848:	9e 96       	adiw	r26, 0x2e	; 46
    184a:	6d 91       	ld	r22, X+
    184c:	7d 91       	ld	r23, X+
    184e:	8d 91       	ld	r24, X+
    1850:	9c 91       	ld	r25, X
    1852:	d1 97       	sbiw	r26, 0x31	; 49
    1854:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    1858:	f8 01       	movw	r30, r16
    185a:	66 a7       	std	Z+46, r22	; 0x2e
    185c:	77 a7       	std	Z+47, r23	; 0x2f
    185e:	80 ab       	std	Z+48, r24	; 0x30
    1860:	91 ab       	std	Z+49, r25	; 0x31
    1862:	ff ef       	ldi	r31, 0xFF	; 255
    1864:	8f 1a       	sub	r8, r31
    1866:	9f 0a       	sbc	r9, r31
    1868:	24 e0       	ldi	r18, 0x04	; 4
    186a:	c2 0e       	add	r12, r18
    186c:	d1 1c       	adc	r13, r1
    186e:	0c 5f       	subi	r16, 0xFC	; 252
    1870:	1f 4f       	sbci	r17, 0xFF	; 255
    1872:	34 e0       	ldi	r19, 0x04	; 4
    1874:	63 0e       	add	r6, r19
    1876:	71 1c       	adc	r7, r1
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    1878:	43 e0       	ldi	r20, 0x03	; 3
    187a:	84 16       	cp	r8, r20
    187c:	91 04       	cpc	r9, r1
    187e:	09 f0       	breq	.+2      	; 0x1882 <gc_execute_line+0xa72>
    1880:	86 cf       	rjmp	.-244    	; 0x178e <gc_execute_line+0x97e>
          }
        }
      }

      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {
    1882:	8e e1       	ldi	r24, 0x1E	; 30
    1884:	b8 16       	cp	r11, r24
    1886:	31 f0       	breq	.+12     	; 0x1894 <gc_execute_line+0xa84>
    1888:	95 e3       	ldi	r25, 0x35	; 53
    188a:	b9 16       	cp	r11, r25
    188c:	99 f1       	breq	.+102    	; 0x18f4 <gc_execute_line+0xae4>
    188e:	ac e1       	ldi	r26, 0x1C	; 28
    1890:	ba 12       	cpse	r11, r26
    1892:	35 c0       	rjmp	.+106    	; 0x18fe <gc_execute_line+0xaee>
        case NON_MODAL_GO_HOME_0: // G28
        case NON_MODAL_GO_HOME_1: // G30
          // [G28/30 Errors]: Cutter compensation is enabled.
          // Retreive G28/30 go-home position data (in machine coordinates) from EEPROM
          // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
    1894:	bc e1       	ldi	r27, 0x1C	; 28
    1896:	bb 12       	cpse	r11, r27
    1898:	09 c0       	rjmp	.+18     	; 0x18ac <gc_execute_line+0xa9c>
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    189a:	66 e9       	ldi	r22, 0x96	; 150
    189c:	7c e0       	ldi	r23, 0x0C	; 12
    189e:	86 e0       	ldi	r24, 0x06	; 6
    18a0:	0e 94 82 25 	call	0x4b04	; 0x4b04 <settings_read_coord_data>
    18a4:	88 23       	and	r24, r24
    18a6:	09 f4       	brne	.+2      	; 0x18aa <gc_execute_line+0xa9a>
    18a8:	34 c5       	rjmp	.+2664   	; 0x2312 <__stack+0x113>
    18aa:	78 c5       	rjmp	.+2800   	; 0x239c <__stack+0x19d>
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    18ac:	66 e9       	ldi	r22, 0x96	; 150
    18ae:	7c e0       	ldi	r23, 0x0C	; 12
    18b0:	87 e0       	ldi	r24, 0x07	; 7
    18b2:	0e 94 82 25 	call	0x4b04	; 0x4b04 <settings_read_coord_data>
    18b6:	88 23       	and	r24, r24
    18b8:	09 f4       	brne	.+2      	; 0x18bc <gc_execute_line+0xaac>
    18ba:	2d c5       	rjmp	.+2650   	; 0x2316 <__stack+0x117>
    18bc:	6f c5       	rjmp	.+2782   	; 0x239c <__stack+0x19d>
          }
          if (axis_words) {
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
    18be:	a9 01       	movw	r20, r18
    18c0:	08 2e       	mov	r0, r24
    18c2:	02 c0       	rjmp	.+4      	; 0x18c8 <gc_execute_line+0xab8>
    18c4:	55 95       	asr	r21
    18c6:	47 95       	ror	r20
    18c8:	0a 94       	dec	r0
    18ca:	e2 f7       	brpl	.-8      	; 0x18c4 <gc_execute_line+0xab4>
    18cc:	40 fd       	sbrc	r20, 0
    18ce:	0a c0       	rjmp	.+20     	; 0x18e4 <gc_execute_line+0xad4>
    18d0:	58 96       	adiw	r26, 0x18	; 24
    18d2:	4d 91       	ld	r20, X+
    18d4:	5d 91       	ld	r21, X+
    18d6:	6d 91       	ld	r22, X+
    18d8:	7c 91       	ld	r23, X
    18da:	5b 97       	sbiw	r26, 0x1b	; 27
    18dc:	40 8b       	std	Z+16, r20	; 0x10
    18de:	51 8b       	std	Z+17, r21	; 0x11
    18e0:	62 8b       	std	Z+18, r22	; 0x12
    18e2:	73 8b       	std	Z+19, r23	; 0x13
    18e4:	01 96       	adiw	r24, 0x01	; 1
    18e6:	14 96       	adiw	r26, 0x04	; 4
    18e8:	34 96       	adiw	r30, 0x04	; 4
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
          }
          if (axis_words) {
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
    18ea:	83 30       	cpi	r24, 0x03	; 3
    18ec:	91 05       	cpc	r25, r1
    18ee:	39 f7       	brne	.-50     	; 0x18be <gc_execute_line+0xaae>
  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes

  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    18f0:	1f 8e       	std	Y+31, r1	; 0x1f
    18f2:	60 c5       	rjmp	.+2752   	; 0x23b4 <__stack+0x1b5>
          // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
    18f4:	80 91 87 0c 	lds	r24, 0x0C87	; 0x800c87 <gc_block+0x1>
    18f8:	82 30       	cpi	r24, 0x02	; 2
    18fa:	08 f0       	brcs	.+2      	; 0x18fe <gc_execute_line+0xaee>
    18fc:	0e c5       	rjmp	.+2588   	; 0x231a <__stack+0x11b>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    18fe:	10 91 87 0c 	lds	r17, 0x0C87	; 0x800c87 <gc_block+0x1>
    1902:	10 35       	cpi	r17, 0x50	; 80
    1904:	29 f4       	brne	.+10     	; 0x1910 <gc_execute_line+0xb00>
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    1906:	e9 a1       	ldd	r30, Y+33	; 0x21
    1908:	e1 11       	cpse	r30, r1
    190a:	09 c5       	rjmp	.+2578   	; 0x231e <__stack+0x11f>
    190c:	1f 8e       	std	Y+31, r1	; 0x1f
    190e:	46 c2       	rjmp	.+1164   	; 0x1d9c <gc_execute_line+0xf8c>
    1910:	1f 8e       	std	Y+31, r1	; 0x1f

  // Check remaining motion modes, if axis word are implicit (exist and not used by G10/28/30/92), or
  // was explicitly commanded in the g-code block.
  } else if ( axis_command == AXIS_COMMAND_MOTION_MODE ) {
    1912:	fa a1       	ldd	r31, Y+34	; 0x22
    1914:	f2 30       	cpi	r31, 0x02	; 2
    1916:	09 f0       	breq	.+2      	; 0x191a <gc_execute_line+0xb0a>
    1918:	41 c2       	rjmp	.+1154   	; 0x1d9c <gc_execute_line+0xf8c>

    if (gc_block.modal.motion == MOTION_MODE_SEEK) {
    191a:	11 11       	cpse	r17, r1
    191c:	05 c0       	rjmp	.+10     	; 0x1928 <gc_execute_line+0xb18>
      // [G0 Errors]: Axis letter not configured or without real value (done.)
      // Axis words are optional. If missing, set axis command flag to ignore execution.
      if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    191e:	29 a1       	ldd	r18, Y+33	; 0x21
    1920:	21 11       	cpse	r18, r1
    1922:	3c c2       	rjmp	.+1144   	; 0x1d9c <gc_execute_line+0xf8c>
    1924:	1a a2       	std	Y+34, r1	; 0x22
    1926:	3a c2       	rjmp	.+1140   	; 0x1d9c <gc_execute_line+0xf8c>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    1928:	20 e0       	ldi	r18, 0x00	; 0
    192a:	30 e0       	ldi	r19, 0x00	; 0
    192c:	a9 01       	movw	r20, r18
    192e:	60 91 92 0c 	lds	r22, 0x0C92	; 0x800c92 <gc_block+0xc>
    1932:	70 91 93 0c 	lds	r23, 0x0C93	; 0x800c93 <gc_block+0xd>
    1936:	80 91 94 0c 	lds	r24, 0x0C94	; 0x800c94 <gc_block+0xe>
    193a:	90 91 95 0c 	lds	r25, 0x0C95	; 0x800c95 <gc_block+0xf>
    193e:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    1942:	88 23       	and	r24, r24
    1944:	09 f4       	brne	.+2      	; 0x1948 <gc_execute_line+0xb38>
    1946:	ed c4       	rjmp	.+2522   	; 0x2322 <__stack+0x123>

      switch (gc_block.modal.motion) {
    1948:	1c 38       	cpi	r17, 0x8C	; 140
    194a:	09 f4       	brne	.+2      	; 0x194e <gc_execute_line+0xb3e>
    194c:	0f c2       	rjmp	.+1054   	; 0x1d6c <gc_execute_line+0xf5c>
    194e:	40 f4       	brcc	.+16     	; 0x1960 <gc_execute_line+0xb50>
    1950:	12 30       	cpi	r17, 0x02	; 2
    1952:	a1 f0       	breq	.+40     	; 0x197c <gc_execute_line+0xb6c>
    1954:	13 30       	cpi	r17, 0x03	; 3
    1956:	a9 f0       	breq	.+42     	; 0x1982 <gc_execute_line+0xb72>
    1958:	11 30       	cpi	r17, 0x01	; 1
    195a:	09 f0       	breq	.+2      	; 0x195e <gc_execute_line+0xb4e>
    195c:	1f c2       	rjmp	.+1086   	; 0x1d9c <gc_execute_line+0xf8c>
    195e:	09 c0       	rjmp	.+18     	; 0x1972 <gc_execute_line+0xb62>
    1960:	1e 38       	cpi	r17, 0x8E	; 142
    1962:	09 f4       	brne	.+2      	; 0x1966 <gc_execute_line+0xb56>
    1964:	03 c2       	rjmp	.+1030   	; 0x1d6c <gc_execute_line+0xf5c>
    1966:	08 f4       	brcc	.+2      	; 0x196a <gc_execute_line+0xb5a>
    1968:	fe c1       	rjmp	.+1020   	; 0x1d66 <gc_execute_line+0xf56>
    196a:	1f 38       	cpi	r17, 0x8F	; 143
    196c:	09 f4       	brne	.+2      	; 0x1970 <gc_execute_line+0xb60>
    196e:	fb c1       	rjmp	.+1014   	; 0x1d66 <gc_execute_line+0xf56>
    1970:	15 c2       	rjmp	.+1066   	; 0x1d9c <gc_execute_line+0xf8c>
        case MOTION_MODE_LINEAR:
          // [G1 Errors]: Feed rate undefined. Axis letter not configured or without real value.
          // Axis words are optional. If missing, set axis command flag to ignore execution.
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    1972:	39 a1       	ldd	r19, Y+33	; 0x21
    1974:	31 11       	cpse	r19, r1
    1976:	12 c2       	rjmp	.+1060   	; 0x1d9c <gc_execute_line+0xf8c>
    1978:	1a a2       	std	Y+34, r1	; 0x22
    197a:	10 c2       	rjmp	.+1056   	; 0x1d9c <gc_execute_line+0xf8c>
          break;
        case MOTION_MODE_CW_ARC: 
          gc_parser_flags |= GC_PARSER_ARC_IS_CLOCKWISE; // No break intentional.
    197c:	4c a1       	ldd	r20, Y+36	; 0x24
    197e:	44 60       	ori	r20, 0x04	; 4
    1980:	4c a3       	std	Y+36, r20	; 0x24
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.

          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1982:	89 a1       	ldd	r24, Y+33	; 0x21
    1984:	88 23       	and	r24, r24
    1986:	09 f4       	brne	.+2      	; 0x198a <gc_execute_line+0xb7a>
    1988:	ce c4       	rjmp	.+2460   	; 0x2326 <__stack+0x127>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    198a:	bd a1       	ldd	r27, Y+37	; 0x25
    198c:	ab 2f       	mov	r26, r27
    198e:	b0 e0       	ldi	r27, 0x00	; 0
    1990:	b9 ab       	std	Y+49, r27	; 0x31
    1992:	a8 ab       	std	Y+48, r26	; 0x30
    1994:	ee a1       	ldd	r30, Y+38	; 0x26
    1996:	ce 2e       	mov	r12, r30
    1998:	d1 2c       	mov	r13, r1
    199a:	81 e0       	ldi	r24, 0x01	; 1
    199c:	90 e0       	ldi	r25, 0x00	; 0
    199e:	8c 01       	movw	r16, r24
    19a0:	0d a0       	ldd	r0, Y+37	; 0x25
    19a2:	02 c0       	rjmp	.+4      	; 0x19a8 <gc_execute_line+0xb98>
    19a4:	00 0f       	add	r16, r16
    19a6:	11 1f       	adc	r17, r17
    19a8:	0a 94       	dec	r0
    19aa:	e2 f7       	brpl	.-8      	; 0x19a4 <gc_execute_line+0xb94>
    19ac:	02 c0       	rjmp	.+4      	; 0x19b2 <gc_execute_line+0xba2>
    19ae:	88 0f       	add	r24, r24
    19b0:	99 1f       	adc	r25, r25
    19b2:	ea 95       	dec	r30
    19b4:	e2 f7       	brpl	.-8      	; 0x19ae <gc_execute_line+0xb9e>
    19b6:	08 2b       	or	r16, r24
    19b8:	19 2b       	or	r17, r25
    19ba:	f9 a1       	ldd	r31, Y+33	; 0x21
    19bc:	8f 2f       	mov	r24, r31
    19be:	90 e0       	ldi	r25, 0x00	; 0
    19c0:	80 23       	and	r24, r16
    19c2:	91 23       	and	r25, r17
    19c4:	89 2b       	or	r24, r25
    19c6:	09 f4       	brne	.+2      	; 0x19ca <gc_execute_line+0xbba>
    19c8:	b0 c4       	rjmp	.+2400   	; 0x232a <__stack+0x12b>

          // Calculate the change in position along each selected axis
          float x,y;
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
    19ca:	fd 01       	movw	r30, r26
    19cc:	ee 0f       	add	r30, r30
    19ce:	ff 1f       	adc	r31, r31
    19d0:	ee 0f       	add	r30, r30
    19d2:	ff 1f       	adc	r31, r31
    19d4:	ea 57       	subi	r30, 0x7A	; 122
    19d6:	f3 4f       	sbci	r31, 0xF3	; 243
    19d8:	aa 0f       	add	r26, r26
    19da:	bb 1f       	adc	r27, r27
    19dc:	aa 0f       	add	r26, r26
    19de:	bb 1f       	adc	r27, r27
    19e0:	a2 5a       	subi	r26, 0xA2	; 162
    19e2:	b3 4f       	sbci	r27, 0xF3	; 243
    19e4:	2d 91       	ld	r18, X+
    19e6:	3d 91       	ld	r19, X+
    19e8:	4d 91       	ld	r20, X+
    19ea:	5c 91       	ld	r21, X
    19ec:	66 a5       	ldd	r22, Z+46	; 0x2e
    19ee:	77 a5       	ldd	r23, Z+47	; 0x2f
    19f0:	80 a9       	ldd	r24, Z+48	; 0x30
    19f2:	91 a9       	ldd	r25, Z+49	; 0x31
    19f4:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    19f8:	6f a3       	std	Y+39, r22	; 0x27
    19fa:	78 a7       	std	Y+40, r23	; 0x28
    19fc:	89 a7       	std	Y+41, r24	; 0x29
    19fe:	9a a7       	std	Y+42, r25	; 0x2a
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target
    1a00:	f6 01       	movw	r30, r12
    1a02:	ee 0f       	add	r30, r30
    1a04:	ff 1f       	adc	r31, r31
    1a06:	ee 0f       	add	r30, r30
    1a08:	ff 1f       	adc	r31, r31
    1a0a:	ea 57       	subi	r30, 0x7A	; 122
    1a0c:	f3 4f       	sbci	r31, 0xF3	; 243
    1a0e:	d6 01       	movw	r26, r12
    1a10:	aa 0f       	add	r26, r26
    1a12:	bb 1f       	adc	r27, r27
    1a14:	aa 0f       	add	r26, r26
    1a16:	bb 1f       	adc	r27, r27
    1a18:	a2 5a       	subi	r26, 0xA2	; 162
    1a1a:	b3 4f       	sbci	r27, 0xF3	; 243
    1a1c:	2d 91       	ld	r18, X+
    1a1e:	3d 91       	ld	r19, X+
    1a20:	4d 91       	ld	r20, X+
    1a22:	5c 91       	ld	r21, X
    1a24:	66 a5       	ldd	r22, Z+46	; 0x2e
    1a26:	77 a5       	ldd	r23, Z+47	; 0x2f
    1a28:	80 a9       	ldd	r24, Z+48	; 0x30
    1a2a:	91 a9       	ldd	r25, Z+49	; 0x31
    1a2c:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    1a30:	6b a7       	std	Y+43, r22	; 0x2b
    1a32:	7c a7       	std	Y+44, r23	; 0x2c
    1a34:	8d a7       	std	Y+45, r24	; 0x2d
    1a36:	9e a7       	std	Y+46, r25	; 0x2e

          if (value_words & bit(WORD_R)) { // Arc Radius Mode
    1a38:	27 fe       	sbrs	r2, 7
    1a3a:	ea c0       	rjmp	.+468    	; 0x1c10 <gc_execute_line+0xe00>
            bit_false(value_words,bit(WORD_R));
    1a3c:	e8 94       	clt
    1a3e:	27 f8       	bld	r2, 7
            if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    1a40:	4c e0       	ldi	r20, 0x0C	; 12
    1a42:	50 e0       	ldi	r21, 0x00	; 0
    1a44:	64 eb       	ldi	r22, 0xB4	; 180
    1a46:	7c e0       	ldi	r23, 0x0C	; 12
    1a48:	8e e5       	ldi	r24, 0x5E	; 94
    1a4a:	9c e0       	ldi	r25, 0x0C	; 12
    1a4c:	0e 94 29 42 	call	0x8452	; 0x8452 <memcmp>
    1a50:	89 2b       	or	r24, r25
    1a52:	09 f4       	brne	.+2      	; 0x1a56 <gc_execute_line+0xc46>
    1a54:	6c c4       	rjmp	.+2264   	; 0x232e <__stack+0x12f>

            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
    1a56:	80 91 89 0c 	lds	r24, 0x0C89	; 0x800c89 <gc_block+0x3>
    1a5a:	81 30       	cpi	r24, 0x01	; 1
    1a5c:	a1 f4       	brne	.+40     	; 0x1a86 <gc_execute_line+0xc76>
    1a5e:	06 e8       	ldi	r16, 0x86	; 134
    1a60:	1c e0       	ldi	r17, 0x0C	; 12
    1a62:	23 e3       	ldi	r18, 0x33	; 51
    1a64:	33 e3       	ldi	r19, 0x33	; 51
    1a66:	4b ec       	ldi	r20, 0xCB	; 203
    1a68:	51 e4       	ldi	r21, 0x41	; 65
    1a6a:	d8 01       	movw	r26, r16
    1a6c:	95 96       	adiw	r26, 0x25	; 37
    1a6e:	6d 91       	ld	r22, X+
    1a70:	7d 91       	ld	r23, X+
    1a72:	8d 91       	ld	r24, X+
    1a74:	9c 91       	ld	r25, X
    1a76:	98 97       	sbiw	r26, 0x28	; 40
    1a78:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    1a7c:	f8 01       	movw	r30, r16
    1a7e:	65 a3       	std	Z+37, r22	; 0x25
    1a80:	76 a3       	std	Z+38, r23	; 0x26
    1a82:	87 a3       	std	Z+39, r24	; 0x27
    1a84:	90 a7       	std	Z+40, r25	; 0x28
                j = (y + (x * h_x2_div_d))/2
            */

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;
    1a86:	80 90 ab 0c 	lds	r8, 0x0CAB	; 0x800cab <gc_block+0x25>
    1a8a:	90 90 ac 0c 	lds	r9, 0x0CAC	; 0x800cac <gc_block+0x26>
    1a8e:	a0 90 ad 0c 	lds	r10, 0x0CAD	; 0x800cad <gc_block+0x27>
    1a92:	b0 90 ae 0c 	lds	r11, 0x0CAE	; 0x800cae <gc_block+0x28>
    1a96:	20 e0       	ldi	r18, 0x00	; 0
    1a98:	30 e0       	ldi	r19, 0x00	; 0
    1a9a:	40 e8       	ldi	r20, 0x80	; 128
    1a9c:	50 e4       	ldi	r21, 0x40	; 64
    1a9e:	c5 01       	movw	r24, r10
    1aa0:	b4 01       	movw	r22, r8
    1aa2:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    1aa6:	a5 01       	movw	r20, r10
    1aa8:	94 01       	movw	r18, r8
    1aaa:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    1aae:	4b 01       	movw	r8, r22
    1ab0:	5c 01       	movw	r10, r24
    1ab2:	2f a1       	ldd	r18, Y+39	; 0x27
    1ab4:	38 a5       	ldd	r19, Y+40	; 0x28
    1ab6:	49 a5       	ldd	r20, Y+41	; 0x29
    1ab8:	5a a5       	ldd	r21, Y+42	; 0x2a
    1aba:	ca 01       	movw	r24, r20
    1abc:	b9 01       	movw	r22, r18
    1abe:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    1ac2:	9b 01       	movw	r18, r22
    1ac4:	ac 01       	movw	r20, r24
    1ac6:	c5 01       	movw	r24, r10
    1ac8:	b4 01       	movw	r22, r8
    1aca:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    1ace:	4b 01       	movw	r8, r22
    1ad0:	5c 01       	movw	r10, r24
    1ad2:	2b a5       	ldd	r18, Y+43	; 0x2b
    1ad4:	3c a5       	ldd	r19, Y+44	; 0x2c
    1ad6:	4d a5       	ldd	r20, Y+45	; 0x2d
    1ad8:	5e a5       	ldd	r21, Y+46	; 0x2e
    1ada:	ca 01       	movw	r24, r20
    1adc:	b9 01       	movw	r22, r18
    1ade:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    1ae2:	9b 01       	movw	r18, r22
    1ae4:	ac 01       	movw	r20, r24
    1ae6:	c5 01       	movw	r24, r10
    1ae8:	b4 01       	movw	r22, r8
    1aea:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    1aee:	4b 01       	movw	r8, r22
    1af0:	5c 01       	movw	r10, r24

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    1af2:	20 e0       	ldi	r18, 0x00	; 0
    1af4:	30 e0       	ldi	r19, 0x00	; 0
    1af6:	a9 01       	movw	r20, r18
    1af8:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    1afc:	88 23       	and	r24, r24
    1afe:	0c f4       	brge	.+2      	; 0x1b02 <gc_execute_line+0xcf2>
    1b00:	18 c4       	rjmp	.+2096   	; 0x2332 <__stack+0x133>

            // Finish computing h_x2_div_d.
            h_x2_div_d = -sqrt(h_x2_div_d)/hypot_f(x,y); // == -(h * 2 / d)
    1b02:	c5 01       	movw	r24, r10
    1b04:	b4 01       	movw	r22, r8
    1b06:	0e 94 90 41 	call	0x8320	; 0x8320 <sqrt>
    1b0a:	4b 01       	movw	r8, r22
    1b0c:	5c 01       	movw	r10, r24
    1b0e:	2b a5       	ldd	r18, Y+43	; 0x2b
    1b10:	3c a5       	ldd	r19, Y+44	; 0x2c
    1b12:	4d a5       	ldd	r20, Y+45	; 0x2d
    1b14:	5e a5       	ldd	r21, Y+46	; 0x2e
    1b16:	6f a1       	ldd	r22, Y+39	; 0x27
    1b18:	78 a5       	ldd	r23, Y+40	; 0x28
    1b1a:	89 a5       	ldd	r24, Y+41	; 0x29
    1b1c:	9a a5       	ldd	r25, Y+42	; 0x2a
    1b1e:	0e 94 a3 2e 	call	0x5d46	; 0x5d46 <hypot_f>
    1b22:	9b 01       	movw	r18, r22
    1b24:	ac 01       	movw	r20, r24
    1b26:	c5 01       	movw	r24, r10
    1b28:	b4 01       	movw	r22, r8
    1b2a:	90 58       	subi	r25, 0x80	; 128
    1b2c:	0e 94 cc 3e 	call	0x7d98	; 0x7d98 <__divsf3>
    1b30:	4b 01       	movw	r8, r22
    1b32:	5c 01       	movw	r10, r24
            // Invert the sign of h_x2_div_d if the circle is counter clockwise (see sketch below)
            if (gc_block.modal.motion == MOTION_MODE_CCW_ARC) { h_x2_div_d = -h_x2_div_d; }
    1b34:	80 91 87 0c 	lds	r24, 0x0C87	; 0x800c87 <gc_block+0x1>
    1b38:	83 30       	cpi	r24, 0x03	; 3
    1b3a:	21 f4       	brne	.+8      	; 0x1b44 <gc_execute_line+0xd34>
    1b3c:	b7 fa       	bst	r11, 7
    1b3e:	b0 94       	com	r11
    1b40:	b7 f8       	bld	r11, 7
    1b42:	b0 94       	com	r11
            */
            // Negative R is g-code-alese for "I want a circle with more than 180 degrees of travel" (go figure!),
            // even though it is advised against ever generating such circles in a single line of g-code. By
            // inverting the sign of h_x2_div_d the center of the circles is placed on the opposite side of the line of
            // travel and thus we get the unadvisably long arcs as prescribed.
            if (gc_block.values.r < 0) {
    1b44:	40 90 ab 0c 	lds	r4, 0x0CAB	; 0x800cab <gc_block+0x25>
    1b48:	50 90 ac 0c 	lds	r5, 0x0CAC	; 0x800cac <gc_block+0x26>
    1b4c:	60 90 ad 0c 	lds	r6, 0x0CAD	; 0x800cad <gc_block+0x27>
    1b50:	70 90 ae 0c 	lds	r7, 0x0CAE	; 0x800cae <gc_block+0x28>
    1b54:	20 e0       	ldi	r18, 0x00	; 0
    1b56:	30 e0       	ldi	r19, 0x00	; 0
    1b58:	a9 01       	movw	r20, r18
    1b5a:	c3 01       	movw	r24, r6
    1b5c:	b2 01       	movw	r22, r4
    1b5e:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    1b62:	88 23       	and	r24, r24
    1b64:	84 f4       	brge	.+32     	; 0x1b86 <gc_execute_line+0xd76>
                h_x2_div_d = -h_x2_div_d;
    1b66:	b7 fa       	bst	r11, 7
    1b68:	b0 94       	com	r11
    1b6a:	b7 f8       	bld	r11, 7
    1b6c:	b0 94       	com	r11
                gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
    1b6e:	77 fa       	bst	r7, 7
    1b70:	70 94       	com	r7
    1b72:	77 f8       	bld	r7, 7
    1b74:	70 94       	com	r7
    1b76:	40 92 ab 0c 	sts	0x0CAB, r4	; 0x800cab <gc_block+0x25>
    1b7a:	50 92 ac 0c 	sts	0x0CAC, r5	; 0x800cac <gc_block+0x26>
    1b7e:	60 92 ad 0c 	sts	0x0CAD, r6	; 0x800cad <gc_block+0x27>
    1b82:	70 92 ae 0c 	sts	0x0CAE, r7	; 0x800cae <gc_block+0x28>
            }
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
    1b86:	08 a9       	ldd	r16, Y+48	; 0x30
    1b88:	19 a9       	ldd	r17, Y+49	; 0x31
    1b8a:	00 0f       	add	r16, r16
    1b8c:	11 1f       	adc	r17, r17
    1b8e:	00 0f       	add	r16, r16
    1b90:	11 1f       	adc	r17, r17
    1b92:	0a 56       	subi	r16, 0x6A	; 106
    1b94:	13 4f       	sbci	r17, 0xF3	; 243
    1b96:	2b a5       	ldd	r18, Y+43	; 0x2b
    1b98:	3c a5       	ldd	r19, Y+44	; 0x2c
    1b9a:	4d a5       	ldd	r20, Y+45	; 0x2d
    1b9c:	5e a5       	ldd	r21, Y+46	; 0x2e
    1b9e:	c5 01       	movw	r24, r10
    1ba0:	b4 01       	movw	r22, r8
    1ba2:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    1ba6:	9b 01       	movw	r18, r22
    1ba8:	ac 01       	movw	r20, r24
    1baa:	6f a1       	ldd	r22, Y+39	; 0x27
    1bac:	78 a5       	ldd	r23, Y+40	; 0x28
    1bae:	89 a5       	ldd	r24, Y+41	; 0x29
    1bb0:	9a a5       	ldd	r25, Y+42	; 0x2a
    1bb2:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    1bb6:	20 e0       	ldi	r18, 0x00	; 0
    1bb8:	30 e0       	ldi	r19, 0x00	; 0
    1bba:	40 e0       	ldi	r20, 0x00	; 0
    1bbc:	5f e3       	ldi	r21, 0x3F	; 63
    1bbe:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    1bc2:	d8 01       	movw	r26, r16
    1bc4:	6d 93       	st	X+, r22
    1bc6:	7d 93       	st	X+, r23
    1bc8:	8d 93       	st	X+, r24
    1bca:	9c 93       	st	X, r25
    1bcc:	13 97       	sbiw	r26, 0x03	; 3
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
    1bce:	86 01       	movw	r16, r12
    1bd0:	00 0f       	add	r16, r16
    1bd2:	11 1f       	adc	r17, r17
    1bd4:	00 0f       	add	r16, r16
    1bd6:	11 1f       	adc	r17, r17
    1bd8:	0a 56       	subi	r16, 0x6A	; 106
    1bda:	13 4f       	sbci	r17, 0xF3	; 243
    1bdc:	2f a1       	ldd	r18, Y+39	; 0x27
    1bde:	38 a5       	ldd	r19, Y+40	; 0x28
    1be0:	49 a5       	ldd	r20, Y+41	; 0x29
    1be2:	5a a5       	ldd	r21, Y+42	; 0x2a
    1be4:	c5 01       	movw	r24, r10
    1be6:	b4 01       	movw	r22, r8
    1be8:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    1bec:	2b a5       	ldd	r18, Y+43	; 0x2b
    1bee:	3c a5       	ldd	r19, Y+44	; 0x2c
    1bf0:	4d a5       	ldd	r20, Y+45	; 0x2d
    1bf2:	5e a5       	ldd	r21, Y+46	; 0x2e
    1bf4:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    1bf8:	20 e0       	ldi	r18, 0x00	; 0
    1bfa:	30 e0       	ldi	r19, 0x00	; 0
    1bfc:	40 e0       	ldi	r20, 0x00	; 0
    1bfe:	5f e3       	ldi	r21, 0x3F	; 63
    1c00:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    1c04:	f8 01       	movw	r30, r16
    1c06:	60 83       	st	Z, r22
    1c08:	71 83       	std	Z+1, r23	; 0x01
    1c0a:	82 83       	std	Z+2, r24	; 0x02
    1c0c:	93 83       	std	Z+3, r25	; 0x03
    1c0e:	c6 c0       	rjmp	.+396    	; 0x1d9c <gc_execute_line+0xf8c>

          } else { // Arc Center Format Offset Mode
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    1c10:	fb a1       	ldd	r31, Y+35	; 0x23
    1c12:	8f 2e       	mov	r8, r31
    1c14:	91 2c       	mov	r9, r1
    1c16:	08 21       	and	r16, r8
    1c18:	19 21       	and	r17, r9
    1c1a:	01 2b       	or	r16, r17
    1c1c:	09 f4       	brne	.+2      	; 0x1c20 <gc_execute_line+0xe10>
    1c1e:	8b c3       	rjmp	.+1814   	; 0x2336 <__stack+0x137>
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));
    1c20:	21 ef       	ldi	r18, 0xF1	; 241
    1c22:	22 22       	and	r2, r18

            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
    1c24:	80 91 89 0c 	lds	r24, 0x0C89	; 0x800c89 <gc_block+0x3>
    1c28:	81 30       	cpi	r24, 0x01	; 1
    1c2a:	41 f5       	brne	.+80     	; 0x1c7c <gc_execute_line+0xe6c>
    1c2c:	06 e8       	ldi	r16, 0x86	; 134
    1c2e:	1c e0       	ldi	r17, 0x0C	; 12
    1c30:	a1 2c       	mov	r10, r1
    1c32:	b1 2c       	mov	r11, r1
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
    1c34:	c4 01       	movw	r24, r8
    1c36:	0a 2c       	mov	r0, r10
    1c38:	02 c0       	rjmp	.+4      	; 0x1c3e <gc_execute_line+0xe2e>
    1c3a:	95 95       	asr	r25
    1c3c:	87 95       	ror	r24
    1c3e:	0a 94       	dec	r0
    1c40:	e2 f7       	brpl	.-8      	; 0x1c3a <gc_execute_line+0xe2a>
    1c42:	80 ff       	sbrs	r24, 0
    1c44:	12 c0       	rjmp	.+36     	; 0x1c6a <gc_execute_line+0xe5a>
    1c46:	23 e3       	ldi	r18, 0x33	; 51
    1c48:	33 e3       	ldi	r19, 0x33	; 51
    1c4a:	4b ec       	ldi	r20, 0xCB	; 203
    1c4c:	51 e4       	ldi	r21, 0x41	; 65
    1c4e:	d8 01       	movw	r26, r16
    1c50:	50 96       	adiw	r26, 0x10	; 16
    1c52:	6d 91       	ld	r22, X+
    1c54:	7d 91       	ld	r23, X+
    1c56:	8d 91       	ld	r24, X+
    1c58:	9c 91       	ld	r25, X
    1c5a:	53 97       	sbiw	r26, 0x13	; 19
    1c5c:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    1c60:	f8 01       	movw	r30, r16
    1c62:	60 8b       	std	Z+16, r22	; 0x10
    1c64:	71 8b       	std	Z+17, r23	; 0x11
    1c66:	82 8b       	std	Z+18, r24	; 0x12
    1c68:	93 8b       	std	Z+19, r25	; 0x13
    1c6a:	ff ef       	ldi	r31, 0xFF	; 255
    1c6c:	af 1a       	sub	r10, r31
    1c6e:	bf 0a       	sbc	r11, r31
    1c70:	0c 5f       	subi	r16, 0xFC	; 252
    1c72:	1f 4f       	sbci	r17, 0xFF	; 255
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));

            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    1c74:	23 e0       	ldi	r18, 0x03	; 3
    1c76:	a2 16       	cp	r10, r18
    1c78:	b1 04       	cpc	r11, r1
    1c7a:	e1 f6       	brne	.-72     	; 0x1c34 <gc_execute_line+0xe24>
              }
            }

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
    1c7c:	c6 01       	movw	r24, r12
    1c7e:	88 0f       	add	r24, r24
    1c80:	99 1f       	adc	r25, r25
    1c82:	88 0f       	add	r24, r24
    1c84:	99 1f       	adc	r25, r25
    1c86:	dc 01       	movw	r26, r24
    1c88:	aa 56       	subi	r26, 0x6A	; 106
    1c8a:	b3 4f       	sbci	r27, 0xF3	; 243
    1c8c:	6d 01       	movw	r12, r26
            float target_r = hypot_f(x,y);
    1c8e:	2d 91       	ld	r18, X+
    1c90:	3d 91       	ld	r19, X+
    1c92:	4d 91       	ld	r20, X+
    1c94:	5c 91       	ld	r21, X
    1c96:	6b a5       	ldd	r22, Y+43	; 0x2b
    1c98:	7c a5       	ldd	r23, Y+44	; 0x2c
    1c9a:	8d a5       	ldd	r24, Y+45	; 0x2d
    1c9c:	9e a5       	ldd	r25, Y+46	; 0x2e
    1c9e:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    1ca2:	4b 01       	movw	r8, r22
    1ca4:	5c 01       	movw	r10, r24
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
              }
            }

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
    1ca6:	08 a9       	ldd	r16, Y+48	; 0x30
    1ca8:	19 a9       	ldd	r17, Y+49	; 0x31
    1caa:	00 0f       	add	r16, r16
    1cac:	11 1f       	adc	r17, r17
    1cae:	00 0f       	add	r16, r16
    1cb0:	11 1f       	adc	r17, r17
    1cb2:	0a 56       	subi	r16, 0x6A	; 106
    1cb4:	13 4f       	sbci	r17, 0xF3	; 243
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
            float target_r = hypot_f(x,y);
    1cb6:	f8 01       	movw	r30, r16
    1cb8:	20 81       	ld	r18, Z
    1cba:	31 81       	ldd	r19, Z+1	; 0x01
    1cbc:	42 81       	ldd	r20, Z+2	; 0x02
    1cbe:	53 81       	ldd	r21, Z+3	; 0x03
    1cc0:	6f a1       	ldd	r22, Y+39	; 0x27
    1cc2:	78 a5       	ldd	r23, Y+40	; 0x28
    1cc4:	89 a5       	ldd	r24, Y+41	; 0x29
    1cc6:	9a a5       	ldd	r25, Y+42	; 0x2a
    1cc8:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    1ccc:	a5 01       	movw	r20, r10
    1cce:	94 01       	movw	r18, r8
    1cd0:	0e 94 a3 2e 	call	0x5d46	; 0x5d46 <hypot_f>
    1cd4:	4b 01       	movw	r8, r22
    1cd6:	5c 01       	movw	r10, r24

            // Compute arc radius for mc_arc. Defined from current location to center.
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]);
    1cd8:	d6 01       	movw	r26, r12
    1cda:	2d 91       	ld	r18, X+
    1cdc:	3d 91       	ld	r19, X+
    1cde:	4d 91       	ld	r20, X+
    1ce0:	5c 91       	ld	r21, X
    1ce2:	f8 01       	movw	r30, r16
    1ce4:	60 81       	ld	r22, Z
    1ce6:	71 81       	ldd	r23, Z+1	; 0x01
    1ce8:	82 81       	ldd	r24, Z+2	; 0x02
    1cea:	93 81       	ldd	r25, Z+3	; 0x03
    1cec:	0e 94 a3 2e 	call	0x5d46	; 0x5d46 <hypot_f>
    1cf0:	2b 01       	movw	r4, r22
    1cf2:	3c 01       	movw	r6, r24
    1cf4:	60 93 ab 0c 	sts	0x0CAB, r22	; 0x800cab <gc_block+0x25>
    1cf8:	70 93 ac 0c 	sts	0x0CAC, r23	; 0x800cac <gc_block+0x26>
    1cfc:	80 93 ad 0c 	sts	0x0CAD, r24	; 0x800cad <gc_block+0x27>
    1d00:	90 93 ae 0c 	sts	0x0CAE, r25	; 0x800cae <gc_block+0x28>

            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
    1d04:	9b 01       	movw	r18, r22
    1d06:	ac 01       	movw	r20, r24
    1d08:	c5 01       	movw	r24, r10
    1d0a:	b4 01       	movw	r22, r8
    1d0c:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    1d10:	4b 01       	movw	r8, r22
    1d12:	5c 01       	movw	r10, r24
    1d14:	e8 94       	clt
    1d16:	b7 f8       	bld	r11, 7
            if (delta_r > 0.005) {
    1d18:	2a e0       	ldi	r18, 0x0A	; 10
    1d1a:	37 ed       	ldi	r19, 0xD7	; 215
    1d1c:	43 ea       	ldi	r20, 0xA3	; 163
    1d1e:	5b e3       	ldi	r21, 0x3B	; 59
    1d20:	c5 01       	movw	r24, r10
    1d22:	b4 01       	movw	r22, r8
    1d24:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    1d28:	18 16       	cp	r1, r24
    1d2a:	c4 f5       	brge	.+112    	; 0x1d9c <gc_execute_line+0xf8c>
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    1d2c:	20 e0       	ldi	r18, 0x00	; 0
    1d2e:	30 e0       	ldi	r19, 0x00	; 0
    1d30:	40 e0       	ldi	r20, 0x00	; 0
    1d32:	5f e3       	ldi	r21, 0x3F	; 63
    1d34:	c5 01       	movw	r24, r10
    1d36:	b4 01       	movw	r22, r8
    1d38:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    1d3c:	18 16       	cp	r1, r24
    1d3e:	0c f4       	brge	.+2      	; 0x1d42 <gc_execute_line+0xf32>
    1d40:	fc c2       	rjmp	.+1528   	; 0x233a <__stack+0x13b>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    1d42:	2f e6       	ldi	r18, 0x6F	; 111
    1d44:	32 e1       	ldi	r19, 0x12	; 18
    1d46:	43 e8       	ldi	r20, 0x83	; 131
    1d48:	5a e3       	ldi	r21, 0x3A	; 58
    1d4a:	c3 01       	movw	r24, r6
    1d4c:	b2 01       	movw	r22, r4
    1d4e:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    1d52:	9b 01       	movw	r18, r22
    1d54:	ac 01       	movw	r20, r24
    1d56:	c5 01       	movw	r24, r10
    1d58:	b4 01       	movw	r22, r8
    1d5a:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    1d5e:	18 16       	cp	r1, r24
    1d60:	0c f4       	brge	.+2      	; 0x1d64 <gc_execute_line+0xf54>
    1d62:	ed c2       	rjmp	.+1498   	; 0x233e <__stack+0x13f>
    1d64:	1b c0       	rjmp	.+54     	; 0x1d9c <gc_execute_line+0xf8c>
            }
          }
          break;
        case MOTION_MODE_PROBE_TOWARD_NO_ERROR: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          gc_parser_flags |= GC_PARSER_PROBE_IS_NO_ERROR; // No break intentional.
    1d66:	fc a1       	ldd	r31, Y+36	; 0x24
    1d68:	f0 61       	ori	r31, 0x10	; 16
    1d6a:	fc a3       	std	Y+36, r31	; 0x24
        case MOTION_MODE_PROBE_TOWARD: case MOTION_MODE_PROBE_AWAY:
          if ((gc_block.modal.motion == MOTION_MODE_PROBE_AWAY) || 
    1d6c:	1e 58       	subi	r17, 0x8E	; 142
    1d6e:	12 30       	cpi	r17, 0x02	; 2
    1d70:	18 f4       	brcc	.+6      	; 0x1d78 <gc_execute_line+0xf68>
              (gc_block.modal.motion == MOTION_MODE_PROBE_AWAY_NO_ERROR)) { gc_parser_flags |= GC_PARSER_PROBE_IS_AWAY; }
    1d72:	2c a1       	ldd	r18, Y+36	; 0x24
    1d74:	28 60       	ori	r18, 0x08	; 8
    1d76:	2c a3       	std	Y+36, r18	; 0x24
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1d78:	39 a1       	ldd	r19, Y+33	; 0x21
    1d7a:	33 23       	and	r19, r19
    1d7c:	09 f4       	brne	.+2      	; 0x1d80 <gc_execute_line+0xf70>
    1d7e:	e1 c2       	rjmp	.+1474   	; 0x2342 <__stack+0x143>
          if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    1d80:	4c e0       	ldi	r20, 0x0C	; 12
    1d82:	50 e0       	ldi	r21, 0x00	; 0
    1d84:	64 eb       	ldi	r22, 0xB4	; 180
    1d86:	7c e0       	ldi	r23, 0x0C	; 12
    1d88:	8e e5       	ldi	r24, 0x5E	; 94
    1d8a:	9c e0       	ldi	r25, 0x0C	; 12
    1d8c:	0e 94 29 42 	call	0x8452	; 0x8452 <memcmp>
    1d90:	89 2b       	or	r24, r25
    1d92:	09 f4       	brne	.+2      	; 0x1d96 <gc_execute_line+0xf86>
    1d94:	d8 c2       	rjmp	.+1456   	; 0x2346 <__stack+0x147>
    1d96:	02 c0       	rjmp	.+4      	; 0x1d9c <gc_execute_line+0xf8c>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    1d98:	1f 8e       	std	Y+31, r1	; 0x1f
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
            }
          } else {
            axis_command = AXIS_COMMAND_NONE; // Set to none if no intermediate motion.
    1d9a:	1a a2       	std	Y+34, r1	; 0x22

  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    1d9c:	4c a1       	ldd	r20, Y+36	; 0x24
    1d9e:	41 70       	andi	r20, 0x01	; 1
    1da0:	d4 2e       	mov	r13, r20
    1da2:	8c a1       	ldd	r24, Y+36	; 0x24
    1da4:	80 ff       	sbrs	r24, 0
    1da6:	03 c0       	rjmp	.+6      	; 0x1dae <gc_execute_line+0xf9e>
    // Jogging only uses the F feed rate and XYZ value words. N is valid, but S and T are invalid.
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)));
    1da8:	c1 01       	movw	r24, r2
    1daa:	8e 7d       	andi	r24, 0xDE	; 222
    1dac:	03 c0       	rjmp	.+6      	; 0x1db4 <gc_execute_line+0xfa4>
  } else {
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words.
    1dae:	c1 01       	movw	r24, r2
    1db0:	8e 7d       	andi	r24, 0xDE	; 222
    1db2:	9c 7f       	andi	r25, 0xFC	; 252
  }
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words.
    1db4:	aa a1       	ldd	r26, Y+34	; 0x22
    1db6:	a1 11       	cpse	r26, r1
    1db8:	93 7e       	andi	r25, 0xE3	; 227
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    1dba:	89 2b       	or	r24, r25
    1dbc:	09 f0       	breq	.+2      	; 0x1dc0 <gc_execute_line+0xfb0>
    1dbe:	c5 c2       	rjmp	.+1418   	; 0x234a <__stack+0x14b>
  */

  // Initialize planner data struct for motion blocks.
  plan_line_data_t plan_data;
  plan_line_data_t *pl_data = &plan_data;
  memset(pl_data,0,sizeof(plan_line_data_t)); // Zero pl_data struct
    1dc0:	fe 01       	movw	r30, r28
    1dc2:	72 96       	adiw	r30, 0x12	; 18
    1dc4:	8d e0       	ldi	r24, 0x0D	; 13
    1dc6:	df 01       	movw	r26, r30
    1dc8:	1d 92       	st	X+, r1
    1dca:	8a 95       	dec	r24
    1dcc:	e9 f7       	brne	.-6      	; 0x1dc8 <gc_execute_line+0xfb8>

  // Intercept jog commands and complete error checking for valid jog commands and execute.
  // NOTE: G-code parser state is not updated, except the position to ensure sequential jog
  // targets are computed correctly. The final parser position after a jog is updated in
  // protocol_execute_realtime() when jogging completes or is canceled.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    1dce:	dd 20       	and	r13, r13
    1dd0:	59 f1       	breq	.+86     	; 0x1e28 <gc_execute_line+0x1018>
    // Only distance and unit modal commands and G53 absolute override command are allowed.
    // NOTE: Feed rate word and axis word checks have already been performed in STEP 3.
    if (command_words & ~(bit(MODAL_GROUP_G3) | bit(MODAL_GROUP_G6 | bit(MODAL_GROUP_G0))) ) { FAIL(STATUS_INVALID_JOG_COMMAND) };
    1dd2:	b6 eb       	ldi	r27, 0xB6	; 182
    1dd4:	eb 22       	and	r14, r27
    1dd6:	ef 28       	or	r14, r15
    1dd8:	09 f0       	breq	.+2      	; 0x1ddc <gc_execute_line+0xfcc>
    1dda:	b9 c2       	rjmp	.+1394   	; 0x234e <__stack+0x14f>
    if (!(gc_block.non_modal_command == NON_MODAL_ABSOLUTE_OVERRIDE || gc_block.non_modal_command == NON_MODAL_NO_ACTION)) { FAIL(STATUS_INVALID_JOG_COMMAND); }
    1ddc:	80 91 86 0c 	lds	r24, 0x0C86	; 0x800c86 <gc_block>
    1de0:	85 33       	cpi	r24, 0x35	; 53
    1de2:	11 f0       	breq	.+4      	; 0x1de8 <gc_execute_line+0xfd8>
    1de4:	81 11       	cpse	r24, r1
    1de6:	b5 c2       	rjmp	.+1386   	; 0x2352 <__stack+0x153>

    // Initialize planner data to current spindle and coolant modal state.
    pl_data->spindle_speed = gc_state.spindle_speed;
    1de8:	e6 e4       	ldi	r30, 0x46	; 70
    1dea:	fc e0       	ldi	r31, 0x0C	; 12
    1dec:	83 85       	ldd	r24, Z+11	; 0x0b
    1dee:	94 85       	ldd	r25, Z+12	; 0x0c
    1df0:	a5 85       	ldd	r26, Z+13	; 0x0d
    1df2:	b6 85       	ldd	r27, Z+14	; 0x0e
    1df4:	8e 8b       	std	Y+22, r24	; 0x16
    1df6:	9f 8b       	std	Y+23, r25	; 0x17
    1df8:	a8 8f       	std	Y+24, r26	; 0x18
    1dfa:	b9 8f       	std	Y+25, r27	; 0x19
    plan_data.condition = (gc_state.modal.spindle | gc_state.modal.coolant);
    1dfc:	91 85       	ldd	r25, Z+9	; 0x09
    1dfe:	80 85       	ldd	r24, Z+8	; 0x08
    1e00:	89 2b       	or	r24, r25
    1e02:	8e 8f       	std	Y+30, r24	; 0x1e

    uint8_t status = jog_execute(&plan_data, &gc_block);
    1e04:	66 e8       	ldi	r22, 0x86	; 134
    1e06:	7c e0       	ldi	r23, 0x0C	; 12
    1e08:	ce 01       	movw	r24, r28
    1e0a:	42 96       	adiw	r24, 0x12	; 18
    1e0c:	0e 94 aa 3d 	call	0x7b54	; 0x7b54 <jog_execute>
    if (status == STATUS_OK) { memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); }
    1e10:	81 11       	cpse	r24, r1
    1e12:	ed c2       	rjmp	.+1498   	; 0x23ee <__stack+0x1ef>
    1e14:	9c e0       	ldi	r25, 0x0C	; 12
    1e16:	e4 eb       	ldi	r30, 0xB4	; 180
    1e18:	fc e0       	ldi	r31, 0x0C	; 12
    1e1a:	ae e5       	ldi	r26, 0x5E	; 94
    1e1c:	bc e0       	ldi	r27, 0x0C	; 12
    1e1e:	01 90       	ld	r0, Z+
    1e20:	0d 92       	st	X+, r0
    1e22:	9a 95       	dec	r25
    1e24:	e1 f7       	brne	.-8      	; 0x1e1e <gc_execute_line+0x100e>
    1e26:	e3 c2       	rjmp	.+1478   	; 0x23ee <__stack+0x1ef>
    return(status);
  }
  
  // If in laser mode, setup laser power based on current and past parser conditions.
  if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    1e28:	80 91 05 0f 	lds	r24, 0x0F05	; 0x800f05 <settings+0x45>
    1e2c:	81 ff       	sbrs	r24, 1
    1e2e:	26 c0       	rjmp	.+76     	; 0x1e7c <gc_execute_line+0x106c>
    if ( !((gc_block.modal.motion == MOTION_MODE_LINEAR) || (gc_block.modal.motion == MOTION_MODE_CW_ARC) 
    1e30:	80 91 87 0c 	lds	r24, 0x0C87	; 0x800c87 <gc_block+0x1>
    1e34:	81 50       	subi	r24, 0x01	; 1
    1e36:	83 30       	cpi	r24, 0x03	; 3
    1e38:	18 f0       	brcs	.+6      	; 0x1e40 <gc_execute_line+0x1030>
        || (gc_block.modal.motion == MOTION_MODE_CCW_ARC)) ) {
      gc_parser_flags |= GC_PARSER_LASER_DISABLE;
    1e3a:	ec a1       	ldd	r30, Y+36	; 0x24
    1e3c:	e0 64       	ori	r30, 0x40	; 64
    1e3e:	ec a3       	std	Y+36, r30	; 0x24
    }

    // Any motion mode with axis words is allowed to be passed from a spindle speed update. 
    // NOTE: G1 and G0 without axis words sets axis_command to none. G28/30 are intentionally omitted.
    // TODO: Check sync conditions for M3 enabled motions that don't enter the planner. (zero length).
    if (axis_words && (axis_command == AXIS_COMMAND_MOTION_MODE)) { 
    1e40:	f9 a1       	ldd	r31, Y+33	; 0x21
    1e42:	ff 23       	and	r31, r31
    1e44:	39 f0       	breq	.+14     	; 0x1e54 <gc_execute_line+0x1044>
    1e46:	2a a1       	ldd	r18, Y+34	; 0x22
    1e48:	22 30       	cpi	r18, 0x02	; 2
    1e4a:	21 f4       	brne	.+8      	; 0x1e54 <gc_execute_line+0x1044>
      gc_parser_flags |= GC_PARSER_LASER_ISMOTION; 
    1e4c:	3c a1       	ldd	r19, Y+36	; 0x24
    1e4e:	30 68       	ori	r19, 0x80	; 128
    1e50:	3c a3       	std	Y+36, r19	; 0x24
    1e52:	14 c0       	rjmp	.+40     	; 0x1e7c <gc_execute_line+0x106c>
    } else {
      // M3 constant power laser requires planner syncs to update the laser when changing between
      // a G1/2/3 motion mode state and vice versa when there is no motion in the line.
      if (gc_state.modal.spindle == SPINDLE_ENABLE_CW) {
    1e54:	80 91 4f 0c 	lds	r24, 0x0C4F	; 0x800c4f <gc_state+0x9>
    1e58:	80 31       	cpi	r24, 0x10	; 16
    1e5a:	81 f4       	brne	.+32     	; 0x1e7c <gc_execute_line+0x106c>
        if ((gc_state.modal.motion == MOTION_MODE_LINEAR) || (gc_state.modal.motion == MOTION_MODE_CW_ARC) 
    1e5c:	80 91 46 0c 	lds	r24, 0x0C46	; 0x800c46 <gc_state>
    1e60:	81 50       	subi	r24, 0x01	; 1
    1e62:	83 30       	cpi	r24, 0x03	; 3
    1e64:	30 f4       	brcc	.+12     	; 0x1e72 <gc_execute_line+0x1062>
            || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
          if (bit_istrue(gc_parser_flags,GC_PARSER_LASER_DISABLE)) { 
    1e66:	4c a1       	ldd	r20, Y+36	; 0x24
    1e68:	46 ff       	sbrs	r20, 6
    1e6a:	08 c0       	rjmp	.+16     	; 0x1e7c <gc_execute_line+0x106c>
            gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC; // Change from G1/2/3 motion mode.
    1e6c:	40 62       	ori	r20, 0x20	; 32
    1e6e:	4c a3       	std	Y+36, r20	; 0x24
    1e70:	05 c0       	rjmp	.+10     	; 0x1e7c <gc_execute_line+0x106c>
          }
        } else {
          // When changing to a G1 motion mode without axis words from a non-G1/2/3 motion mode.
          if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_DISABLE)) { 
    1e72:	8c a1       	ldd	r24, Y+36	; 0x24
    1e74:	86 fd       	sbrc	r24, 6
    1e76:	02 c0       	rjmp	.+4      	; 0x1e7c <gc_execute_line+0x106c>
            gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC;
    1e78:	80 62       	ori	r24, 0x20	; 32
    1e7a:	8c a3       	std	Y+36, r24	; 0x24
    }
  }

  // [0. Non-specific/common error-checks and miscellaneous setup]:
  // NOTE: If no line number is present, the value is zero.
  gc_state.line_number = gc_block.values.n;
    1e7c:	a6 e8       	ldi	r26, 0x86	; 134
    1e7e:	bc e0       	ldi	r27, 0x0C	; 12
    1e80:	5d 96       	adiw	r26, 0x1d	; 29
    1e82:	4d 91       	ld	r20, X+
    1e84:	5d 91       	ld	r21, X+
    1e86:	6d 91       	ld	r22, X+
    1e88:	7c 91       	ld	r23, X
    1e8a:	90 97       	sbiw	r26, 0x20	; 32
    1e8c:	e6 e4       	ldi	r30, 0x46	; 70
    1e8e:	fc e0       	ldi	r31, 0x0C	; 12
    1e90:	44 8b       	std	Z+20, r20	; 0x14
    1e92:	55 8b       	std	Z+21, r21	; 0x15
    1e94:	66 8b       	std	Z+22, r22	; 0x16
    1e96:	77 8b       	std	Z+23, r23	; 0x17
  pl_data->line_number = gc_state.line_number; // Record data for planner use.
    1e98:	4a 8f       	std	Y+26, r20	; 0x1a
    1e9a:	5b 8f       	std	Y+27, r21	; 0x1b
    1e9c:	6c 8f       	std	Y+28, r22	; 0x1c
    1e9e:	7d 8f       	std	Y+29, r23	; 0x1d

  // [1. Comments feedback ]:  NOT SUPPORTED

  // [2. Set feed rate mode ]:
  gc_state.modal.feed_rate = gc_block.modal.feed_rate;
    1ea0:	12 96       	adiw	r26, 0x02	; 2
    1ea2:	8c 91       	ld	r24, X
    1ea4:	81 83       	std	Z+1, r24	; 0x01
  if (gc_state.modal.feed_rate) { pl_data->condition |= PL_COND_FLAG_INVERSE_TIME; } // Set condition flag for planner use.
    1ea6:	88 23       	and	r24, r24
    1ea8:	11 f0       	breq	.+4      	; 0x1eae <gc_execute_line+0x109e>
    1eaa:	88 e0       	ldi	r24, 0x08	; 8
    1eac:	8e 8f       	std	Y+30, r24	; 0x1e

  // [3. Set feed rate ]:
  gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
    1eae:	a6 e8       	ldi	r26, 0x86	; 134
    1eb0:	bc e0       	ldi	r27, 0x0C	; 12
    1eb2:	1c 96       	adiw	r26, 0x0c	; 12
    1eb4:	4d 91       	ld	r20, X+
    1eb6:	5d 91       	ld	r21, X+
    1eb8:	6d 91       	ld	r22, X+
    1eba:	7c 91       	ld	r23, X
    1ebc:	1f 97       	sbiw	r26, 0x0f	; 15
    1ebe:	e6 e4       	ldi	r30, 0x46	; 70
    1ec0:	fc e0       	ldi	r31, 0x0C	; 12
    1ec2:	47 87       	std	Z+15, r20	; 0x0f
    1ec4:	50 8b       	std	Z+16, r21	; 0x10
    1ec6:	61 8b       	std	Z+17, r22	; 0x11
    1ec8:	72 8b       	std	Z+18, r23	; 0x12
  pl_data->feed_rate = gc_state.feed_rate; // Record data for planner use.
    1eca:	4a 8b       	std	Y+18, r20	; 0x12
    1ecc:	5b 8b       	std	Y+19, r21	; 0x13
    1ece:	6c 8b       	std	Y+20, r22	; 0x14
    1ed0:	7d 8b       	std	Y+21, r23	; 0x15

  // [4. Set spindle speed ]:
  if ((gc_state.spindle_speed != gc_block.values.s) || bit_istrue(gc_parser_flags,GC_PARSER_LASER_FORCE_SYNC)) {
    1ed2:	99 96       	adiw	r26, 0x29	; 41
    1ed4:	8d 90       	ld	r8, X+
    1ed6:	9d 90       	ld	r9, X+
    1ed8:	ad 90       	ld	r10, X+
    1eda:	bc 90       	ld	r11, X
    1edc:	9c 97       	sbiw	r26, 0x2c	; 44
    1ede:	a5 01       	movw	r20, r10
    1ee0:	94 01       	movw	r18, r8
    1ee2:	63 85       	ldd	r22, Z+11	; 0x0b
    1ee4:	74 85       	ldd	r23, Z+12	; 0x0c
    1ee6:	85 85       	ldd	r24, Z+13	; 0x0d
    1ee8:	96 85       	ldd	r25, Z+14	; 0x0e
    1eea:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    1eee:	81 11       	cpse	r24, r1
    1ef0:	03 c0       	rjmp	.+6      	; 0x1ef8 <gc_execute_line+0x10e8>
    1ef2:	9c a1       	ldd	r25, Y+36	; 0x24
    1ef4:	95 ff       	sbrs	r25, 5
    1ef6:	21 c0       	rjmp	.+66     	; 0x1f3a <gc_execute_line+0x112a>
    if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
    1ef8:	80 91 4f 0c 	lds	r24, 0x0C4F	; 0x800c4f <gc_state+0x9>
    1efc:	88 23       	and	r24, r24
    1efe:	69 f0       	breq	.+26     	; 0x1f1a <gc_execute_line+0x110a>
      if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_ISMOTION)) {
    1f00:	ac a1       	ldd	r26, Y+36	; 0x24
    1f02:	aa 23       	and	r26, r26
    1f04:	54 f0       	brlt	.+20     	; 0x1f1a <gc_execute_line+0x110a>
        if (bit_istrue(gc_parser_flags,GC_PARSER_LASER_DISABLE)) {
    1f06:	a6 ff       	sbrs	r26, 6
    1f08:	05 c0       	rjmp	.+10     	; 0x1f14 <gc_execute_line+0x1104>
           spindle_sync(gc_state.modal.spindle, 0.0);
    1f0a:	40 e0       	ldi	r20, 0x00	; 0
    1f0c:	50 e0       	ldi	r21, 0x00	; 0
    1f0e:	ba 01       	movw	r22, r20
    1f10:	ba d3       	rcall	.+1908   	; 0x2686 <spindle_sync>
    1f12:	03 c0       	rjmp	.+6      	; 0x1f1a <gc_execute_line+0x110a>
        } else { spindle_sync(gc_state.modal.spindle, gc_block.values.s); }
    1f14:	b5 01       	movw	r22, r10
    1f16:	a4 01       	movw	r20, r8
    1f18:	b6 d3       	rcall	.+1900   	; 0x2686 <spindle_sync>
      }
    }
    gc_state.spindle_speed = gc_block.values.s; // Update spindle speed state.
    1f1a:	80 91 af 0c 	lds	r24, 0x0CAF	; 0x800caf <gc_block+0x29>
    1f1e:	90 91 b0 0c 	lds	r25, 0x0CB0	; 0x800cb0 <gc_block+0x2a>
    1f22:	a0 91 b1 0c 	lds	r26, 0x0CB1	; 0x800cb1 <gc_block+0x2b>
    1f26:	b0 91 b2 0c 	lds	r27, 0x0CB2	; 0x800cb2 <gc_block+0x2c>
    1f2a:	80 93 51 0c 	sts	0x0C51, r24	; 0x800c51 <gc_state+0xb>
    1f2e:	90 93 52 0c 	sts	0x0C52, r25	; 0x800c52 <gc_state+0xc>
    1f32:	a0 93 53 0c 	sts	0x0C53, r26	; 0x800c53 <gc_state+0xd>
    1f36:	b0 93 54 0c 	sts	0x0C54, r27	; 0x800c54 <gc_state+0xe>
  }
  // NOTE: Pass zero spindle speed for all restricted laser motions.
  if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_DISABLE)) {
    1f3a:	bc a1       	ldd	r27, Y+36	; 0x24
    1f3c:	b6 fd       	sbrc	r27, 6
    1f3e:	0c c0       	rjmp	.+24     	; 0x1f58 <gc_execute_line+0x1148>
    pl_data->spindle_speed = gc_state.spindle_speed; // Record data for planner use. 
    1f40:	80 91 51 0c 	lds	r24, 0x0C51	; 0x800c51 <gc_state+0xb>
    1f44:	90 91 52 0c 	lds	r25, 0x0C52	; 0x800c52 <gc_state+0xc>
    1f48:	a0 91 53 0c 	lds	r26, 0x0C53	; 0x800c53 <gc_state+0xd>
    1f4c:	b0 91 54 0c 	lds	r27, 0x0C54	; 0x800c54 <gc_state+0xe>
    1f50:	8e 8b       	std	Y+22, r24	; 0x16
    1f52:	9f 8b       	std	Y+23, r25	; 0x17
    1f54:	a8 8f       	std	Y+24, r26	; 0x18
    1f56:	b9 8f       	std	Y+25, r27	; 0x19
  } // else { pl_data->spindle_speed = 0.0; } // Initialized as zero already.
  
  // [5. Select tool ]: NOT SUPPORTED. Only tracks tool value.
  gc_state.tool = gc_block.values.t;
    1f58:	e6 e4       	ldi	r30, 0x46	; 70
    1f5a:	fc e0       	ldi	r31, 0x0C	; 12
    1f5c:	a6 e8       	ldi	r26, 0x86	; 134
    1f5e:	bc e0       	ldi	r27, 0x0C	; 12
    1f60:	9d 96       	adiw	r26, 0x2d	; 45
    1f62:	8c 91       	ld	r24, X
    1f64:	9d 97       	sbiw	r26, 0x2d	; 45
    1f66:	83 8b       	std	Z+19, r24	; 0x13

  // [6. Change tool ]: NOT SUPPORTED

  // [7. Spindle control ]:
  if (gc_state.modal.spindle != gc_block.modal.spindle) {
    1f68:	1a 96       	adiw	r26, 0x0a	; 10
    1f6a:	8c 91       	ld	r24, X
    1f6c:	91 85       	ldd	r25, Z+9	; 0x09
    1f6e:	98 17       	cp	r25, r24
    1f70:	49 f0       	breq	.+18     	; 0x1f84 <gc_execute_line+0x1174>
    // Update spindle control and apply spindle speed when enabling it in this block.
    // NOTE: All spindle state changes are synced, even in laser mode. Also, pl_data,
    // rather than gc_state, is used to manage laser state for non-laser motions.
    spindle_sync(gc_block.modal.spindle, pl_data->spindle_speed);
    1f72:	4e 89       	ldd	r20, Y+22	; 0x16
    1f74:	5f 89       	ldd	r21, Y+23	; 0x17
    1f76:	68 8d       	ldd	r22, Y+24	; 0x18
    1f78:	79 8d       	ldd	r23, Y+25	; 0x19
    1f7a:	85 d3       	rcall	.+1802   	; 0x2686 <spindle_sync>
    gc_state.modal.spindle = gc_block.modal.spindle;
    1f7c:	80 91 90 0c 	lds	r24, 0x0C90	; 0x800c90 <gc_block+0xa>
    1f80:	80 93 4f 0c 	sts	0x0C4F, r24	; 0x800c4f <gc_state+0x9>
  }
  pl_data->condition |= gc_state.modal.spindle; // Set condition flag for planner use.
    1f84:	e6 e4       	ldi	r30, 0x46	; 70
    1f86:	fc e0       	ldi	r31, 0x0C	; 12
    1f88:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1f8a:	81 85       	ldd	r24, Z+9	; 0x09
    1f8c:	89 2b       	or	r24, r25
    1f8e:	8e 8f       	std	Y+30, r24	; 0x1e

  // [8. Coolant control ]:
  if (gc_state.modal.coolant != gc_block.modal.coolant) {
    1f90:	80 91 8f 0c 	lds	r24, 0x0C8F	; 0x800c8f <gc_block+0x9>
    1f94:	90 85       	ldd	r25, Z+8	; 0x08
    1f96:	98 17       	cp	r25, r24
    // NOTE: Coolant M-codes are modal. Only one command per line is allowed. But, multiple states
    // can exist at the same time, while coolant disable clears all states.
    coolant_sync(gc_block.modal.coolant);
    1f98:	29 f0       	breq	.+10     	; 0x1fa4 <gc_execute_line+0x1194>
    1f9a:	cc d3       	rcall	.+1944   	; 0x2734 <coolant_sync>
    gc_state.modal.coolant = gc_block.modal.coolant;
    1f9c:	80 91 8f 0c 	lds	r24, 0x0C8F	; 0x800c8f <gc_block+0x9>
    1fa0:	80 93 4e 0c 	sts	0x0C4E, r24	; 0x800c4e <gc_state+0x8>
  }
  pl_data->condition |= gc_state.modal.coolant; // Set condition flag for planner use.
    1fa4:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1fa6:	80 91 4e 0c 	lds	r24, 0x0C4E	; 0x800c4e <gc_state+0x8>
    1faa:	89 2b       	or	r24, r25
    1fac:	8e 8f       	std	Y+30, r24	; 0x1e
      mc_override_ctrl_update(gc_state.modal.override);
    }
  #endif

  // [10. Dwell ]:
  if (gc_block.non_modal_command == NON_MODAL_DWELL) { mc_dwell(gc_block.values.p); }
    1fae:	80 91 86 0c 	lds	r24, 0x0C86	; 0x800c86 <gc_block>
    1fb2:	84 30       	cpi	r24, 0x04	; 4
    1fb4:	51 f4       	brne	.+20     	; 0x1fca <gc_execute_line+0x11ba>
    1fb6:	60 91 a7 0c 	lds	r22, 0x0CA7	; 0x800ca7 <gc_block+0x21>
    1fba:	70 91 a8 0c 	lds	r23, 0x0CA8	; 0x800ca8 <gc_block+0x22>
    1fbe:	80 91 a9 0c 	lds	r24, 0x0CA9	; 0x800ca9 <gc_block+0x23>
    1fc2:	90 91 aa 0c 	lds	r25, 0x0CAA	; 0x800caa <gc_block+0x24>
    1fc6:	0e 94 23 06 	call	0xc46	; 0xc46 <mc_dwell>

  // [11. Set active plane ]:
  gc_state.modal.plane_select = gc_block.modal.plane_select;
    1fca:	e6 e4       	ldi	r30, 0x46	; 70
    1fcc:	fc e0       	ldi	r31, 0x0C	; 12
    1fce:	a6 e8       	ldi	r26, 0x86	; 134
    1fd0:	bc e0       	ldi	r27, 0x0C	; 12
    1fd2:	15 96       	adiw	r26, 0x05	; 5
    1fd4:	8c 91       	ld	r24, X
    1fd6:	15 97       	sbiw	r26, 0x05	; 5
    1fd8:	84 83       	std	Z+4, r24	; 0x04

  // [12. Set length units ]:
  gc_state.modal.units = gc_block.modal.units;
    1fda:	13 96       	adiw	r26, 0x03	; 3
    1fdc:	8c 91       	ld	r24, X
    1fde:	82 83       	std	Z+2, r24	; 0x02

  // [14. Cutter length compensation ]: G43.1 and G49 supported. G43 NOT SUPPORTED.
  // NOTE: If G43 were supported, its operation wouldn't be any different from G43.1 in terms
  // of execution. The error-checking step would simply load the offset value into the correct
  // axis of the block XYZ value array.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates a change.
    1fe0:	ea a1       	ldd	r30, Y+34	; 0x22
    1fe2:	e3 30       	cpi	r30, 0x03	; 3
    1fe4:	71 f5       	brne	.+92     	; 0x2042 <gc_execute_line+0x1232>
    gc_state.modal.tool_length = gc_block.modal.tool_length;
    1fe6:	80 91 8c 0c 	lds	r24, 0x0C8C	; 0x800c8c <gc_block+0x6>
    1fea:	80 93 4b 0c 	sts	0x0C4B, r24	; 0x800c4b <gc_state+0x5>
    if (gc_state.modal.tool_length == TOOL_LENGTH_OFFSET_CANCEL) { // G49
    1fee:	81 11       	cpse	r24, r1
    1ff0:	08 c0       	rjmp	.+16     	; 0x2002 <gc_execute_line+0x11f2>
      gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] = 0.0;
    1ff2:	10 92 bc 0c 	sts	0x0CBC, r1	; 0x800cbc <gc_block+0x36>
    1ff6:	10 92 bd 0c 	sts	0x0CBD, r1	; 0x800cbd <gc_block+0x37>
    1ffa:	10 92 be 0c 	sts	0x0CBE, r1	; 0x800cbe <gc_block+0x38>
    1ffe:	10 92 bf 0c 	sts	0x0CBF, r1	; 0x800cbf <gc_block+0x39>
    } // else G43.1
    if ( gc_state.tool_length_offset != gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] ) {
    2002:	80 90 bc 0c 	lds	r8, 0x0CBC	; 0x800cbc <gc_block+0x36>
    2006:	90 90 bd 0c 	lds	r9, 0x0CBD	; 0x800cbd <gc_block+0x37>
    200a:	a0 90 be 0c 	lds	r10, 0x0CBE	; 0x800cbe <gc_block+0x38>
    200e:	b0 90 bf 0c 	lds	r11, 0x0CBF	; 0x800cbf <gc_block+0x39>
    2012:	a5 01       	movw	r20, r10
    2014:	94 01       	movw	r18, r8
    2016:	60 91 82 0c 	lds	r22, 0x0C82	; 0x800c82 <gc_state+0x3c>
    201a:	70 91 83 0c 	lds	r23, 0x0C83	; 0x800c83 <gc_state+0x3d>
    201e:	80 91 84 0c 	lds	r24, 0x0C84	; 0x800c84 <gc_state+0x3e>
    2022:	90 91 85 0c 	lds	r25, 0x0C85	; 0x800c85 <gc_state+0x3f>
    2026:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    202a:	88 23       	and	r24, r24
    202c:	51 f0       	breq	.+20     	; 0x2042 <gc_execute_line+0x1232>
      gc_state.tool_length_offset = gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS];
    202e:	80 92 82 0c 	sts	0x0C82, r8	; 0x800c82 <gc_state+0x3c>
    2032:	90 92 83 0c 	sts	0x0C83, r9	; 0x800c83 <gc_state+0x3d>
    2036:	a0 92 84 0c 	sts	0x0C84, r10	; 0x800c84 <gc_state+0x3e>
    203a:	b0 92 85 0c 	sts	0x0C85, r11	; 0x800c85 <gc_state+0x3f>
      system_flag_wco_change();
    203e:	0e 94 57 3a 	call	0x74ae	; 0x74ae <system_flag_wco_change>
    }
  }

  // [15. Coordinate system selection ]:
  if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    2042:	80 91 8d 0c 	lds	r24, 0x0C8D	; 0x800c8d <gc_block+0x7>
    2046:	90 91 4c 0c 	lds	r25, 0x0C4C	; 0x800c4c <gc_state+0x6>
    204a:	98 17       	cp	r25, r24
    204c:	69 f0       	breq	.+26     	; 0x2068 <gc_execute_line+0x1258>
    gc_state.modal.coord_select = gc_block.modal.coord_select;
    204e:	80 93 4c 0c 	sts	0x0C4C, r24	; 0x800c4c <gc_state+0x6>
    memcpy(gc_state.coord_system,block_coord_system,N_AXIS*sizeof(float));
    2052:	8c e0       	ldi	r24, 0x0C	; 12
    2054:	fe 01       	movw	r30, r28
    2056:	36 96       	adiw	r30, 0x06	; 6
    2058:	aa e6       	ldi	r26, 0x6A	; 106
    205a:	bc e0       	ldi	r27, 0x0C	; 12
    205c:	01 90       	ld	r0, Z+
    205e:	0d 92       	st	X+, r0
    2060:	8a 95       	dec	r24
    2062:	e1 f7       	brne	.-8      	; 0x205c <gc_execute_line+0x124c>
    system_flag_wco_change();
    2064:	0e 94 57 3a 	call	0x74ae	; 0x74ae <system_flag_wco_change>

  // [16. Set path control mode ]: G61.1/G64 NOT SUPPORTED
  // gc_state.modal.control = gc_block.modal.control; // NOTE: Always default.

  // [17. Set distance mode ]:
  gc_state.modal.distance = gc_block.modal.distance;
    2068:	e6 e8       	ldi	r30, 0x86	; 134
    206a:	fc e0       	ldi	r31, 0x0C	; 12
    206c:	84 81       	ldd	r24, Z+4	; 0x04
    206e:	80 93 49 0c 	sts	0x0C49, r24	; 0x800c49 <gc_state+0x3>

  // [18. Set retract mode ]: NOT SUPPORTED

  // [19. Go to predefined position, Set G10, or Set axis offsets ]:
  switch(gc_block.non_modal_command) {
    2072:	80 81       	ld	r24, Z
    2074:	86 32       	cpi	r24, 0x26	; 38
    2076:	09 f4       	brne	.+2      	; 0x207a <gc_execute_line+0x126a>
    2078:	46 c0       	rjmp	.+140    	; 0x2106 <gc_execute_line+0x12f6>
    207a:	38 f4       	brcc	.+14     	; 0x208a <gc_execute_line+0x127a>
    207c:	8c 31       	cpi	r24, 0x1C	; 28
    207e:	29 f1       	breq	.+74     	; 0x20ca <gc_execute_line+0x12ba>
    2080:	8e 31       	cpi	r24, 0x1E	; 30
    2082:	19 f1       	breq	.+70     	; 0x20ca <gc_execute_line+0x12ba>
    2084:	8a 30       	cpi	r24, 0x0A	; 10
    2086:	59 f0       	breq	.+22     	; 0x209e <gc_execute_line+0x128e>
    2088:	5f c0       	rjmp	.+190    	; 0x2148 <gc_execute_line+0x1338>
    208a:	8c 35       	cpi	r24, 0x5C	; 92
    208c:	09 f4       	brne	.+2      	; 0x2090 <gc_execute_line+0x1280>
    208e:	47 c0       	rjmp	.+142    	; 0x211e <gc_execute_line+0x130e>
    2090:	86 36       	cpi	r24, 0x66	; 102
    2092:	09 f4       	brne	.+2      	; 0x2096 <gc_execute_line+0x1286>
    2094:	50 c0       	rjmp	.+160    	; 0x2136 <gc_execute_line+0x1326>
    2096:	88 32       	cpi	r24, 0x28	; 40
    2098:	09 f0       	breq	.+2      	; 0x209c <gc_execute_line+0x128c>
    209a:	56 c0       	rjmp	.+172    	; 0x2148 <gc_execute_line+0x1338>
    209c:	3a c0       	rjmp	.+116    	; 0x2112 <gc_execute_line+0x1302>
    case NON_MODAL_SET_COORDINATE_DATA:
      settings_write_coord_data(coord_select,gc_block.values.ijk);
    209e:	66 e9       	ldi	r22, 0x96	; 150
    20a0:	7c e0       	ldi	r23, 0x0C	; 12
    20a2:	8f 8d       	ldd	r24, Y+31	; 0x1f
    20a4:	0e 94 df 24 	call	0x49be	; 0x49be <settings_write_coord_data>
      // Update system coordinate system if currently active.
      if (gc_state.modal.coord_select == coord_select) {
    20a8:	80 91 4c 0c 	lds	r24, 0x0C4C	; 0x800c4c <gc_state+0x6>
    20ac:	ff 8d       	ldd	r31, Y+31	; 0x1f
    20ae:	8f 13       	cpse	r24, r31
    20b0:	4b c0       	rjmp	.+150    	; 0x2148 <gc_execute_line+0x1338>
        memcpy(gc_state.coord_system,gc_block.values.ijk,N_AXIS*sizeof(float));
    20b2:	8c e0       	ldi	r24, 0x0C	; 12
    20b4:	e6 e9       	ldi	r30, 0x96	; 150
    20b6:	fc e0       	ldi	r31, 0x0C	; 12
    20b8:	aa e6       	ldi	r26, 0x6A	; 106
    20ba:	bc e0       	ldi	r27, 0x0C	; 12
    20bc:	01 90       	ld	r0, Z+
    20be:	0d 92       	st	X+, r0
    20c0:	8a 95       	dec	r24
    20c2:	e1 f7       	brne	.-8      	; 0x20bc <gc_execute_line+0x12ac>
        system_flag_wco_change();
    20c4:	0e 94 57 3a 	call	0x74ae	; 0x74ae <system_flag_wco_change>
    20c8:	3f c0       	rjmp	.+126    	; 0x2148 <gc_execute_line+0x1338>
      }
      break;
    case NON_MODAL_GO_HOME_0: case NON_MODAL_GO_HOME_1:
      // Move to intermediate position before going home. Obeys current coordinate system and offsets
      // and absolute and incremental modes.
      pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
    20ca:	8e 8d       	ldd	r24, Y+30	; 0x1e
    20cc:	81 60       	ori	r24, 0x01	; 1
    20ce:	8e 8f       	std	Y+30, r24	; 0x1e
      if (axis_command) { mc_line(gc_block.values.xyz, pl_data); }
    20d0:	2a a1       	ldd	r18, Y+34	; 0x22
    20d2:	22 23       	and	r18, r18
    20d4:	39 f0       	breq	.+14     	; 0x20e4 <gc_execute_line+0x12d4>
    20d6:	be 01       	movw	r22, r28
    20d8:	6e 5e       	subi	r22, 0xEE	; 238
    20da:	7f 4f       	sbci	r23, 0xFF	; 255
    20dc:	84 eb       	ldi	r24, 0xB4	; 180
    20de:	9c e0       	ldi	r25, 0x0C	; 12
    20e0:	0e 94 03 03 	call	0x606	; 0x606 <mc_line>
      mc_line(gc_block.values.ijk, pl_data);
    20e4:	be 01       	movw	r22, r28
    20e6:	6e 5e       	subi	r22, 0xEE	; 238
    20e8:	7f 4f       	sbci	r23, 0xFF	; 255
    20ea:	86 e9       	ldi	r24, 0x96	; 150
    20ec:	9c e0       	ldi	r25, 0x0C	; 12
    20ee:	0e 94 03 03 	call	0x606	; 0x606 <mc_line>
      memcpy(gc_state.position, gc_block.values.ijk, N_AXIS*sizeof(float));
    20f2:	8c e0       	ldi	r24, 0x0C	; 12
    20f4:	e6 e9       	ldi	r30, 0x96	; 150
    20f6:	fc e0       	ldi	r31, 0x0C	; 12
    20f8:	ae e5       	ldi	r26, 0x5E	; 94
    20fa:	bc e0       	ldi	r27, 0x0C	; 12
    20fc:	01 90       	ld	r0, Z+
    20fe:	0d 92       	st	X+, r0
    2100:	8a 95       	dec	r24
    2102:	e1 f7       	brne	.-8      	; 0x20fc <gc_execute_line+0x12ec>
      break;
    2104:	21 c0       	rjmp	.+66     	; 0x2148 <gc_execute_line+0x1338>
    case NON_MODAL_SET_HOME_0:
      settings_write_coord_data(SETTING_INDEX_G28,gc_state.position);
    2106:	6e e5       	ldi	r22, 0x5E	; 94
    2108:	7c e0       	ldi	r23, 0x0C	; 12
    210a:	86 e0       	ldi	r24, 0x06	; 6
    210c:	0e 94 df 24 	call	0x49be	; 0x49be <settings_write_coord_data>
      break;
    2110:	1b c0       	rjmp	.+54     	; 0x2148 <gc_execute_line+0x1338>
    case NON_MODAL_SET_HOME_1:
      settings_write_coord_data(SETTING_INDEX_G30,gc_state.position);
    2112:	6e e5       	ldi	r22, 0x5E	; 94
    2114:	7c e0       	ldi	r23, 0x0C	; 12
    2116:	87 e0       	ldi	r24, 0x07	; 7
    2118:	0e 94 df 24 	call	0x49be	; 0x49be <settings_write_coord_data>
      break;
    211c:	15 c0       	rjmp	.+42     	; 0x2148 <gc_execute_line+0x1338>
    case NON_MODAL_SET_COORDINATE_OFFSET:
      memcpy(gc_state.coord_offset,gc_block.values.xyz,sizeof(gc_block.values.xyz));
    211e:	8c e0       	ldi	r24, 0x0C	; 12
    2120:	e4 eb       	ldi	r30, 0xB4	; 180
    2122:	fc e0       	ldi	r31, 0x0C	; 12
    2124:	a6 e7       	ldi	r26, 0x76	; 118
    2126:	bc e0       	ldi	r27, 0x0C	; 12
    2128:	01 90       	ld	r0, Z+
    212a:	0d 92       	st	X+, r0
    212c:	8a 95       	dec	r24
    212e:	e1 f7       	brne	.-8      	; 0x2128 <gc_execute_line+0x1318>
      system_flag_wco_change();
    2130:	0e 94 57 3a 	call	0x74ae	; 0x74ae <system_flag_wco_change>
      break;
    2134:	09 c0       	rjmp	.+18     	; 0x2148 <gc_execute_line+0x1338>
    case NON_MODAL_RESET_COORDINATE_OFFSET:
      clear_vector(gc_state.coord_offset); // Disable G92 offsets by zeroing offset vector.
    2136:	8c e0       	ldi	r24, 0x0C	; 12
    2138:	e6 e7       	ldi	r30, 0x76	; 118
    213a:	fc e0       	ldi	r31, 0x0C	; 12
    213c:	df 01       	movw	r26, r30
    213e:	1d 92       	st	X+, r1
    2140:	8a 95       	dec	r24
    2142:	e9 f7       	brne	.-6      	; 0x213e <gc_execute_line+0x132e>
      system_flag_wco_change();
    2144:	0e 94 57 3a 	call	0x74ae	; 0x74ae <system_flag_wco_change>


  // [20. Motion modes ]:
  // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes.
  // Enter motion modes only if there are axis words or a motion mode command word in the block.
  gc_state.modal.motion = gc_block.modal.motion;
    2148:	80 91 87 0c 	lds	r24, 0x0C87	; 0x800c87 <gc_block+0x1>
    214c:	80 93 46 0c 	sts	0x0C46, r24	; 0x800c46 <gc_state>
  if (gc_state.modal.motion != MOTION_MODE_NONE) {
    2150:	80 35       	cpi	r24, 0x50	; 80
    2152:	09 f4       	brne	.+2      	; 0x2156 <gc_execute_line+0x1346>
    2154:	56 c0       	rjmp	.+172    	; 0x2202 <__stack+0x3>
    if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    2156:	ba a1       	ldd	r27, Y+34	; 0x22
    2158:	b2 30       	cpi	r27, 0x02	; 2
    215a:	09 f0       	breq	.+2      	; 0x215e <gc_execute_line+0x134e>
    215c:	52 c0       	rjmp	.+164    	; 0x2202 <__stack+0x3>
      uint8_t gc_update_pos = GC_UPDATE_POS_TARGET;
      if (gc_state.modal.motion == MOTION_MODE_LINEAR) {
    215e:	81 30       	cpi	r24, 0x01	; 1
    2160:	41 f4       	brne	.+16     	; 0x2172 <gc_execute_line+0x1362>
        mc_line(gc_block.values.xyz, pl_data);
    2162:	be 01       	movw	r22, r28
    2164:	6e 5e       	subi	r22, 0xEE	; 238
    2166:	7f 4f       	sbci	r23, 0xFF	; 255
    2168:	84 eb       	ldi	r24, 0xB4	; 180
    216a:	9c e0       	ldi	r25, 0x0C	; 12
    216c:	0e 94 03 03 	call	0x606	; 0x606 <mc_line>
    2170:	3a c0       	rjmp	.+116    	; 0x21e6 <gc_execute_line+0x13d6>
      } else if (gc_state.modal.motion == MOTION_MODE_SEEK) {
    2172:	81 11       	cpse	r24, r1
    2174:	0b c0       	rjmp	.+22     	; 0x218c <gc_execute_line+0x137c>
        pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
    2176:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2178:	81 60       	ori	r24, 0x01	; 1
    217a:	8e 8f       	std	Y+30, r24	; 0x1e
        mc_line(gc_block.values.xyz, pl_data);
    217c:	be 01       	movw	r22, r28
    217e:	6e 5e       	subi	r22, 0xEE	; 238
    2180:	7f 4f       	sbci	r23, 0xFF	; 255
    2182:	84 eb       	ldi	r24, 0xB4	; 180
    2184:	9c e0       	ldi	r25, 0x0C	; 12
    2186:	0e 94 03 03 	call	0x606	; 0x606 <mc_line>
    218a:	2d c0       	rjmp	.+90     	; 0x21e6 <gc_execute_line+0x13d6>
      } else if ((gc_state.modal.motion == MOTION_MODE_CW_ARC) || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
    218c:	82 50       	subi	r24, 0x02	; 2
    218e:	82 30       	cpi	r24, 0x02	; 2
    2190:	e8 f4       	brcc	.+58     	; 0x21cc <gc_execute_line+0x13bc>
        mc_arc(gc_block.values.xyz, pl_data, gc_state.position, gc_block.values.ijk, gc_block.values.r,
    2192:	e0 90 ab 0c 	lds	r14, 0x0CAB	; 0x800cab <gc_block+0x25>
    2196:	f0 90 ac 0c 	lds	r15, 0x0CAC	; 0x800cac <gc_block+0x26>
    219a:	00 91 ad 0c 	lds	r16, 0x0CAD	; 0x800cad <gc_block+0x27>
    219e:	10 91 ae 0c 	lds	r17, 0x0CAE	; 0x800cae <gc_block+0x28>
    21a2:	ec a1       	ldd	r30, Y+36	; 0x24
    21a4:	e2 fb       	bst	r30, 2
    21a6:	88 27       	eor	r24, r24
    21a8:	80 f9       	bld	r24, 0
    21aa:	8f 93       	push	r24
    21ac:	8f a4       	ldd	r8, Y+47	; 0x2f
    21ae:	ae a0       	ldd	r10, Y+38	; 0x26
    21b0:	cd a0       	ldd	r12, Y+37	; 0x25
    21b2:	26 e9       	ldi	r18, 0x96	; 150
    21b4:	3c e0       	ldi	r19, 0x0C	; 12
    21b6:	4e e5       	ldi	r20, 0x5E	; 94
    21b8:	5c e0       	ldi	r21, 0x0C	; 12
    21ba:	be 01       	movw	r22, r28
    21bc:	6e 5e       	subi	r22, 0xEE	; 238
    21be:	7f 4f       	sbci	r23, 0xFF	; 255
    21c0:	84 eb       	ldi	r24, 0xB4	; 180
    21c2:	9c e0       	ldi	r25, 0x0C	; 12
    21c4:	0e 94 44 03 	call	0x688	; 0x688 <mc_arc>
    21c8:	0f 90       	pop	r0
    21ca:	0d c0       	rjmp	.+26     	; 0x21e6 <gc_execute_line+0x13d6>
            axis_0, axis_1, axis_linear, bit_istrue(gc_parser_flags,GC_PARSER_ARC_IS_CLOCKWISE));
      } else {
        // NOTE: gc_block.values.xyz is returned from mc_probe_cycle with the updated position value. So
        // upon a successful probing cycle, the machine position and the returned value should be the same.
        #ifndef ALLOW_FEED_OVERRIDE_DURING_PROBE_CYCLES
          pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
    21cc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    21ce:	84 60       	ori	r24, 0x04	; 4
    21d0:	8e 8f       	std	Y+30, r24	; 0x1e
        #endif
        gc_update_pos = mc_probe_cycle(gc_block.values.xyz, pl_data, gc_parser_flags);
    21d2:	4c a1       	ldd	r20, Y+36	; 0x24
    21d4:	be 01       	movw	r22, r28
    21d6:	6e 5e       	subi	r22, 0xEE	; 238
    21d8:	7f 4f       	sbci	r23, 0xFF	; 255
    21da:	84 eb       	ldi	r24, 0xB4	; 180
    21dc:	9c e0       	ldi	r25, 0x0C	; 12
    21de:	0e 94 56 06 	call	0xcac	; 0xcac <mc_probe_cycle>
      }  
     
      // As far as the parser is concerned, the position is now == target. In reality the
      // motion control system might still be processing the action and the real tool position
      // in any intermediate location.
      if (gc_update_pos == GC_UPDATE_POS_TARGET) {
    21e2:	81 11       	cpse	r24, r1
    21e4:	0a c0       	rjmp	.+20     	; 0x21fa <gc_execute_line+0x13ea>
        memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); // gc_state.position[] = gc_block.values.xyz[]
    21e6:	8c e0       	ldi	r24, 0x0C	; 12
    21e8:	e4 eb       	ldi	r30, 0xB4	; 180
    21ea:	fc e0       	ldi	r31, 0x0C	; 12
    21ec:	ae e5       	ldi	r26, 0x5E	; 94
    21ee:	bc e0       	ldi	r27, 0x0C	; 12
    21f0:	01 90       	ld	r0, Z+
    21f2:	0d 92       	st	X+, r0
    21f4:	8a 95       	dec	r24
    21f6:	e1 f7       	brne	.-8      	; 0x21f0 <gc_execute_line+0x13e0>
    21f8:	04 c0       	rjmp	.+8      	; 0x2202 <__stack+0x3>
      } else if (gc_update_pos == GC_UPDATE_POS_SYSTEM) {
    21fa:	81 30       	cpi	r24, 0x01	; 1
    21fc:	11 f4       	brne	.+4      	; 0x2202 <__stack+0x3>
        gc_sync_position(); // gc_state.position[] = sys_position
    21fe:	0e 94 01 07 	call	0xe02	; 0xe02 <gc_sync_position>
  }

  // [21. Program flow ]:
  // M0,M1,M2,M30: Perform non-running program flow actions. During a program pause, the buffer may
  // refill and can only be resumed by the cycle start run-time command.
  gc_state.modal.program_flow = gc_block.modal.program_flow;
    2202:	80 91 8e 0c 	lds	r24, 0x0C8E	; 0x800c8e <gc_block+0x8>
    2206:	80 93 4d 0c 	sts	0x0C4D, r24	; 0x800c4d <gc_state+0x7>
  if (gc_state.modal.program_flow) {
    220a:	88 23       	and	r24, r24
    220c:	09 f4       	brne	.+2      	; 0x2210 <__stack+0x11>
    protocol_buffer_synchronize(); // Sync and finish all remaining buffered motions before moving on.
    220e:	ef c0       	rjmp	.+478    	; 0x23ee <__stack+0x1ef>
    2210:	8b d7       	rcall	.+3862   	; 0x3128 <protocol_buffer_synchronize>
    if (gc_state.modal.program_flow == PROGRAM_FLOW_PAUSED) {
    2212:	80 91 4d 0c 	lds	r24, 0x0C4D	; 0x800c4d <gc_state+0x7>
    2216:	83 30       	cpi	r24, 0x03	; 3
    2218:	49 f4       	brne	.+18     	; 0x222c <__stack+0x2d>
      if (sys.state != STATE_CHECK_MODE) {
    221a:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
    221e:	82 30       	cpi	r24, 0x02	; 2
        system_set_exec_state_flag(EXEC_FEED_HOLD); // Use feed hold for program pause.
    2220:	61 f1       	breq	.+88     	; 0x227a <__stack+0x7b>
    2222:	88 e0       	ldi	r24, 0x08	; 8
    2224:	0e 94 f5 3a 	call	0x75ea	; 0x75ea <system_set_exec_state_flag>
        protocol_execute_realtime(); // Execute suspend.
    2228:	b7 d5       	rcall	.+2926   	; 0x2d98 <protocol_execute_realtime>
    222a:	27 c0       	rjmp	.+78     	; 0x227a <__stack+0x7b>
    } else { // == PROGRAM_FLOW_COMPLETED
      // Upon program complete, only a subset of g-codes reset to certain defaults, according to
      // LinuxCNC's program end descriptions and testing. Only modal groups [G-code 1,2,3,5,7,12]
      // and [M-code 7,8,9] reset to [G1,G17,G90,G94,G40,G54,M5,M9,M48]. The remaining modal groups
      // [G-code 4,6,8,10,13,14,15] and [M-code 4,5,6] and the modal words [F,S,T,H] do not reset.
      gc_state.modal.motion = MOTION_MODE_LINEAR;
    222c:	e6 e4       	ldi	r30, 0x46	; 70
    222e:	fc e0       	ldi	r31, 0x0C	; 12
    2230:	81 e0       	ldi	r24, 0x01	; 1
    2232:	80 83       	st	Z, r24
      gc_state.modal.plane_select = PLANE_SELECT_XY;
    2234:	14 82       	std	Z+4, r1	; 0x04
      gc_state.modal.distance = DISTANCE_MODE_ABSOLUTE;
    2236:	13 82       	std	Z+3, r1	; 0x03
      gc_state.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
    2238:	11 82       	std	Z+1, r1	; 0x01
      // gc_state.modal.cutter_comp = CUTTER_COMP_DISABLE; // Not supported.
      gc_state.modal.coord_select = 0; // G54
    223a:	16 82       	std	Z+6, r1	; 0x06
      gc_state.modal.spindle = SPINDLE_DISABLE;
    223c:	11 86       	std	Z+9, r1	; 0x09
      gc_state.modal.coolant = COOLANT_DISABLE;
    223e:	10 86       	std	Z+8, r1	; 0x08
          gc_state.modal.override = OVERRIDE_PARKING_MOTION;
        #endif
      #endif

      #ifdef RESTORE_OVERRIDES_AFTER_PROGRAM_END
        sys.f_override = DEFAULT_FEED_OVERRIDE;
    2240:	e6 e1       	ldi	r30, 0x16	; 22
    2242:	fc e0       	ldi	r31, 0x0C	; 12
    2244:	84 e6       	ldi	r24, 0x64	; 100
    2246:	87 83       	std	Z+7, r24	; 0x07
        sys.r_override = DEFAULT_RAPID_OVERRIDE;
    2248:	80 87       	std	Z+8, r24	; 0x08
        sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE;
    224a:	81 87       	std	Z+9, r24	; 0x09
      #endif

      // Execute coordinate change and spindle/coolant stop.
      if (sys.state != STATE_CHECK_MODE) {
    224c:	80 81       	ld	r24, Z
    224e:	82 30       	cpi	r24, 0x02	; 2
    2250:	89 f0       	breq	.+34     	; 0x2274 <__stack+0x75>
        if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    2252:	6a e6       	ldi	r22, 0x6A	; 106
    2254:	7c e0       	ldi	r23, 0x0C	; 12
    2256:	80 e0       	ldi	r24, 0x00	; 0
    2258:	0e 94 82 25 	call	0x4b04	; 0x4b04 <settings_read_coord_data>
    225c:	88 23       	and	r24, r24
    225e:	09 f4       	brne	.+2      	; 0x2262 <__stack+0x63>
        system_flag_wco_change(); // Set to refresh immediately just in case something altered.
    2260:	7a c0       	rjmp	.+244    	; 0x2356 <__stack+0x157>
        spindle_set_state(SPINDLE_DISABLE,0.0);
    2262:	0e 94 57 3a 	call	0x74ae	; 0x74ae <system_flag_wco_change>
    2266:	40 e0       	ldi	r20, 0x00	; 0
    2268:	50 e0       	ldi	r21, 0x00	; 0
    226a:	ba 01       	movw	r22, r20
    226c:	80 e0       	ldi	r24, 0x00	; 0
        coolant_set_state(COOLANT_DISABLE);
    226e:	e1 d1       	rcall	.+962    	; 0x2632 <spindle_set_state>
    2270:	80 e0       	ldi	r24, 0x00	; 0
    2272:	3f d2       	rcall	.+1150   	; 0x26f2 <coolant_set_state>
      }
      report_feedback_message(MESSAGE_PROGRAM_END);
    2274:	88 e0       	ldi	r24, 0x08	; 8
    2276:	0e 94 fa 34 	call	0x69f4	; 0x69f4 <report_feedback_message>
    }
    gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; // Reset program flow.
    227a:	10 92 4d 0c 	sts	0x0C4D, r1	; 0x800c4d <gc_state+0x7>
  }

  // TODO: % to denote start of program.

  return(STATUS_OK);
    227e:	8d 2d       	mov	r24, r13
    2280:	b6 c0       	rjmp	.+364    	; 0x23ee <__stack+0x1ef>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.

    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
    2282:	81 e0       	ldi	r24, 0x01	; 1
    2284:	b4 c0       	rjmp	.+360    	; 0x23ee <__stack+0x1ef>
    char_counter++;
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
    2286:	82 e0       	ldi	r24, 0x02	; 2
    2288:	b2 c0       	rjmp	.+356    	; 0x23ee <__stack+0x1ef>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
    228a:	84 e1       	ldi	r24, 0x14	; 20
    228c:	b0 c0       	rjmp	.+352    	; 0x23ee <__stack+0x1ef>
        switch(int_value) {
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    228e:	88 e1       	ldi	r24, 0x18	; 24
    2290:	ae c0       	rjmp	.+348    	; 0x23ee <__stack+0x1ef>
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
              if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
    2292:	84 e1       	ldi	r24, 0x14	; 20
    2294:	ac c0       	rjmp	.+344    	; 0x23ee <__stack+0x1ef>
            }                
            break;
          case 0: case 1: case 2: case 3: case 38:
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    2296:	88 e1       	ldi	r24, 0x18	; 24
    2298:	aa c0       	rjmp	.+340    	; 0x23ee <__stack+0x1ef>
          case 80:
            word_bit = MODAL_GROUP_G1;
            gc_block.modal.motion = int_value;
            if (int_value == 38){
              if (!((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))) {
                FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
    229a:	84 e1       	ldi	r24, 0x14	; 20
    229c:	a8 c0       	rjmp	.+336    	; 0x23ee <__stack+0x1ef>
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
    229e:	84 e1       	ldi	r24, 0x14	; 20
    22a0:	a6 c0       	rjmp	.+332    	; 0x23ee <__stack+0x1ef>
    22a2:	84 e1       	ldi	r24, 0x14	; 20
    22a4:	a4 c0       	rjmp	.+328    	; 0x23ee <__stack+0x1ef>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
    22a6:	88 e1       	ldi	r24, 0x18	; 24
    22a8:	a2 c0       	rjmp	.+324    	; 0x23ee <__stack+0x1ef>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
            } else if (mantissa == 10) { // G43.1
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
    22aa:	84 e1       	ldi	r24, 0x14	; 20
    22ac:	a0 c0       	rjmp	.+320    	; 0x23ee <__stack+0x1ef>
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
    22ae:	84 e1       	ldi	r24, 0x14	; 20
    22b0:	9e c0       	rjmp	.+316    	; 0x23ee <__stack+0x1ef>
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    22b2:	87 e1       	ldi	r24, 0x17	; 23
    22b4:	9c c0       	rjmp	.+312    	; 0x23ee <__stack+0x1ef>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    22b6:	85 e1       	ldi	r24, 0x15	; 21
    22b8:	9a c0       	rjmp	.+308    	; 0x23ee <__stack+0x1ef>
        break;

      case 'M':

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    22ba:	87 e1       	ldi	r24, 0x17	; 23
    22bc:	98 c0       	rjmp	.+304    	; 0x23ee <__stack+0x1ef>
            case 56:
              word_bit = MODAL_GROUP_M9;
              gc_block.modal.override = OVERRIDE_PARKING_MOTION;
              break;
          #endif
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
    22be:	84 e1       	ldi	r24, 0x14	; 20
    22c0:	96 c0       	rjmp	.+300    	; 0x23ee <__stack+0x1ef>
        }

        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    22c2:	85 e1       	ldi	r24, 0x15	; 21
    22c4:	94 c0       	rjmp	.+296    	; 0x23ee <__stack+0x1ef>
						gc_block.values.t = int_value;
						break;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
    22c6:	84 e1       	ldi	r24, 0x14	; 20
    22c8:	92 c0       	rjmp	.+292    	; 0x23ee <__stack+0x1ef>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; 
						if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
    22ca:	86 e2       	ldi	r24, 0x26	; 38
    22cc:	90 c0       	rjmp	.+288    	; 0x23ee <__stack+0x1ef>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        }

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    22ce:	89 e1       	ldi	r24, 0x19	; 25
    22d0:	8e c0       	rjmp	.+284    	; 0x23ee <__stack+0x1ef>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    22d2:	84 e0       	ldi	r24, 0x04	; 4
    22d4:	8c c0       	rjmp	.+280    	; 0x23ee <__stack+0x1ef>
  }

  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    22d6:	8b e1       	ldi	r24, 0x1B	; 27
    22d8:	8a c0       	rjmp	.+276    	; 0x23ee <__stack+0x1ef>

  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  // NOTE: For jogging, ignore prior feed rate mode. Enforce G94 and check for required F word.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); }
    22da:	86 e1       	ldi	r24, 0x16	; 22
    22dc:	88 c0       	rjmp	.+272    	; 0x23ee <__stack+0x1ef>
  } else {
    if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
      // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
      if (axis_command == AXIS_COMMAND_MOTION_MODE) {
        if ((gc_block.modal.motion != MOTION_MODE_NONE) && (gc_block.modal.motion != MOTION_MODE_SEEK)) {
          if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    22de:	86 e1       	ldi	r24, 0x16	; 22
    22e0:	86 c0       	rjmp	.+268    	; 0x23ee <__stack+0x1ef>
    }
  #endif

  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    22e2:	8c e1       	ldi	r24, 0x1C	; 28
    22e4:	84 c0       	rjmp	.+264    	; 0x23ee <__stack+0x1ef>
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    22e6:	85 e2       	ldi	r24, 0x25	; 37
    22e8:	82 c0       	rjmp	.+260    	; 0x23ee <__stack+0x1ef>
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  float block_coord_system[N_AXIS];
  memcpy(block_coord_system,gc_state.coord_system,sizeof(gc_state.coord_system));
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    22ea:	8d e1       	ldi	r24, 0x1D	; 29
    22ec:	80 c0       	rjmp	.+256    	; 0x23ee <__stack+0x1ef>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
      if (!(settings_read_coord_data(gc_block.modal.coord_select,block_coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    22ee:	87 e0       	ldi	r24, 0x07	; 7
    22f0:	7e c0       	rjmp	.+252    	; 0x23ee <__stack+0x1ef>
  switch (gc_block.non_modal_command) {
    case NON_MODAL_SET_COORDINATE_DATA:
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    22f2:	8a e1       	ldi	r24, 0x1A	; 26
    22f4:	7c c0       	rjmp	.+248    	; 0x23ee <__stack+0x1ef>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    22f6:	8c e1       	ldi	r24, 0x1C	; 28
    22f8:	7a c0       	rjmp	.+244    	; 0x23ee <__stack+0x1ef>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    22fa:	8d e1       	ldi	r24, 0x1D	; 29
    22fc:	78 c0       	rjmp	.+240    	; 0x23ee <__stack+0x1ef>
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
    22fe:	84 e1       	ldi	r24, 0x14	; 20
    2300:	76 c0       	rjmp	.+236    	; 0x23ee <__stack+0x1ef>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    2302:	84 e1       	ldi	r24, 0x14	; 20
    2304:	74 c0       	rjmp	.+232    	; 0x23ee <__stack+0x1ef>
      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    2306:	87 e0       	ldi	r24, 0x07	; 7
    2308:	72 c0       	rjmp	.+228    	; 0x23ee <__stack+0x1ef>
        } // Else, keep current stored value.
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    230a:	8a e1       	ldi	r24, 0x1A	; 26
    230c:	70 c0       	rjmp	.+224    	; 0x23ee <__stack+0x1ef>

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    230e:	8f e1       	ldi	r24, 0x1F	; 31
    2310:	6e c0       	rjmp	.+220    	; 0x23ee <__stack+0x1ef>
        case NON_MODAL_GO_HOME_1: // G30
          // [G28/30 Errors]: Cutter compensation is enabled.
          // Retreive G28/30 go-home position data (in machine coordinates) from EEPROM
          // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    2312:	87 e0       	ldi	r24, 0x07	; 7
    2314:	6c c0       	rjmp	.+216    	; 0x23ee <__stack+0x1ef>
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    2316:	87 e0       	ldi	r24, 0x07	; 7
    2318:	6a c0       	rjmp	.+212    	; 0x23ee <__stack+0x1ef>
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
            FAIL(STATUS_GCODE_G53_INVALID_MOTION_MODE); // [G53 G0/1 not active]
    231a:	8e e1       	ldi	r24, 0x1E	; 30
    231c:	68 c0       	rjmp	.+208    	; 0x23ee <__stack+0x1ef>

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    231e:	8f e1       	ldi	r24, 0x1F	; 31
    2320:	66 c0       	rjmp	.+204    	; 0x23ee <__stack+0x1ef>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    2322:	86 e1       	ldi	r24, 0x16	; 22
    2324:	64 c0       	rjmp	.+200    	; 0x23ee <__stack+0x1ef>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.

          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    2326:	8a e1       	ldi	r24, 0x1A	; 26
    2328:	62 c0       	rjmp	.+196    	; 0x23ee <__stack+0x1ef>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    232a:	80 e2       	ldi	r24, 0x20	; 32
    232c:	60 c0       	rjmp	.+192    	; 0x23ee <__stack+0x1ef>
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target

          if (value_words & bit(WORD_R)) { // Arc Radius Mode
            bit_false(value_words,bit(WORD_R));
            if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    232e:	81 e2       	ldi	r24, 0x21	; 33
    2330:	5e c0       	rjmp	.+188    	; 0x23ee <__stack+0x1ef>

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    2332:	82 e2       	ldi	r24, 0x22	; 34
    2334:	5c c0       	rjmp	.+184    	; 0x23ee <__stack+0x1ef>
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));

          } else { // Arc Center Format Offset Mode
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    2336:	83 e2       	ldi	r24, 0x23	; 35
    2338:	5a c0       	rjmp	.+180    	; 0x23ee <__stack+0x1ef>
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]);

            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
            if (delta_r > 0.005) {
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    233a:	81 e2       	ldi	r24, 0x21	; 33
    233c:	58 c0       	rjmp	.+176    	; 0x23ee <__stack+0x1ef>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    233e:	81 e2       	ldi	r24, 0x21	; 33
    2340:	56 c0       	rjmp	.+172    	; 0x23ee <__stack+0x1ef>
              (gc_block.modal.motion == MOTION_MODE_PROBE_AWAY_NO_ERROR)) { gc_parser_flags |= GC_PARSER_PROBE_IS_AWAY; }
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    2342:	8a e1       	ldi	r24, 0x1A	; 26
    2344:	54 c0       	rjmp	.+168    	; 0x23ee <__stack+0x1ef>
          if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    2346:	81 e2       	ldi	r24, 0x21	; 33
    2348:	52 c0       	rjmp	.+164    	; 0x23ee <__stack+0x1ef>
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)));
  } else {
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words.
  }
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words.
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    234a:	84 e2       	ldi	r24, 0x24	; 36
    234c:	50 c0       	rjmp	.+160    	; 0x23ee <__stack+0x1ef>
  // targets are computed correctly. The final parser position after a jog is updated in
  // protocol_execute_realtime() when jogging completes or is canceled.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    // Only distance and unit modal commands and G53 absolute override command are allowed.
    // NOTE: Feed rate word and axis word checks have already been performed in STEP 3.
    if (command_words & ~(bit(MODAL_GROUP_G3) | bit(MODAL_GROUP_G6 | bit(MODAL_GROUP_G0))) ) { FAIL(STATUS_INVALID_JOG_COMMAND) };
    234e:	80 e1       	ldi	r24, 0x10	; 16
    2350:	4e c0       	rjmp	.+156    	; 0x23ee <__stack+0x1ef>
    if (!(gc_block.non_modal_command == NON_MODAL_ABSOLUTE_OVERRIDE || gc_block.non_modal_command == NON_MODAL_NO_ACTION)) { FAIL(STATUS_INVALID_JOG_COMMAND); }
    2352:	80 e1       	ldi	r24, 0x10	; 16
    2354:	4c c0       	rjmp	.+152    	; 0x23ee <__stack+0x1ef>
        sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE;
      #endif

      // Execute coordinate change and spindle/coolant stop.
      if (sys.state != STATE_CHECK_MODE) {
        if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    2356:	87 e0       	ldi	r24, 0x07	; 7
    2358:	4a c0       	rjmp	.+148    	; 0x23ee <__stack+0x1ef>

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    235a:	8f e1       	ldi	r24, 0x1F	; 31
    235c:	48 c0       	rjmp	.+144    	; 0x23ee <__stack+0x1ef>
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
  else { char_counter = 0; }
    235e:	19 82       	std	Y+1, r1	; 0x01
  uint8_t ijk_words = 0; // IJK tracking

  // Initialize command and value words and parser flags variables.
  uint16_t command_words = 0; // Tracks G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Tracks value words.
  uint8_t gc_parser_flags = GC_PARSER_NONE;
    2360:	1c a2       	std	Y+36, r1	; 0x24
    2362:	0c 94 42 07 	jmp	0xe84	; 0xe84 <gc_execute_line+0x74>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
    2366:	a6 e8       	ldi	r26, 0x86	; 134
    2368:	bc e0       	ldi	r27, 0x0C	; 12
    236a:	ac 92       	st	X, r10
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
    236c:	bc e1       	ldi	r27, 0x1C	; 28
    236e:	ab 12       	cpse	r10, r27
    2370:	27 c0       	rjmp	.+78     	; 0x23c0 <__stack+0x1c1>
    2372:	0c 94 bd 07 	jmp	0xf7a	; 0xf7a <gc_execute_line+0x16a>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
    2376:	e6 e8       	ldi	r30, 0x86	; 134
    2378:	fc e0       	ldi	r31, 0x0C	; 12
    237a:	a0 82       	st	Z, r10
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
    237c:	fc e1       	ldi	r31, 0x1C	; 28
    237e:	af 12       	cpse	r10, r31
    2380:	25 c0       	rjmp	.+74     	; 0x23cc <__stack+0x1cd>
    2382:	0c 94 c2 07 	jmp	0xf84	; 0xf84 <gc_execute_line+0x174>
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
    2386:	21 e0       	ldi	r18, 0x01	; 1
    2388:	2f a7       	std	Y+47, r18	; 0x2f
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
    238a:	1e a2       	std	Y+38, r1	; 0x26
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
    238c:	32 e0       	ldi	r19, 0x02	; 2
    238e:	3d a3       	std	Y+37, r19	; 0x25
  }

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    2390:	80 91 89 0c 	lds	r24, 0x0C89	; 0x800c89 <gc_block+0x3>
    2394:	81 30       	cpi	r24, 0x01	; 1
    2396:	09 f0       	breq	.+2      	; 0x239a <__stack+0x19b>
    2398:	a1 c8       	rjmp	.-3774   	; 0x14dc <gc_execute_line+0x6cc>
    239a:	6c c8       	rjmp	.-3880   	; 0x1474 <gc_execute_line+0x664>
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
          }
          if (axis_words) {
    239c:	49 a1       	ldd	r20, Y+33	; 0x21
    239e:	44 23       	and	r20, r20
    23a0:	f1 f0       	breq	.+60     	; 0x23de <__stack+0x1df>
    23a2:	a6 e4       	ldi	r26, 0x46	; 70
    23a4:	bc e0       	ldi	r27, 0x0C	; 12
    23a6:	e6 e8       	ldi	r30, 0x86	; 134
    23a8:	fc e0       	ldi	r31, 0x0C	; 12
    23aa:	80 e0       	ldi	r24, 0x00	; 0
    23ac:	90 e0       	ldi	r25, 0x00	; 0
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
    23ae:	24 2f       	mov	r18, r20
    23b0:	30 e0       	ldi	r19, 0x00	; 0
    23b2:	85 ca       	rjmp	.-2806   	; 0x18be <gc_execute_line+0xaae>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    23b4:	10 91 87 0c 	lds	r17, 0x0C87	; 0x800c87 <gc_block+0x1>
    23b8:	10 35       	cpi	r17, 0x50	; 80
    23ba:	09 f0       	breq	.+2      	; 0x23be <__stack+0x1bf>
    23bc:	aa ca       	rjmp	.-2732   	; 0x1912 <gc_execute_line+0xb02>
    23be:	cd cf       	rjmp	.-102    	; 0x235a <__stack+0x15b>
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
    23c0:	8e e1       	ldi	r24, 0x1E	; 30
    23c2:	a8 12       	cpse	r10, r24
    23c4:	0c 94 b7 07 	jmp	0xf6e	; 0xf6e <gc_execute_line+0x15e>
    23c8:	0c 94 bd 07 	jmp	0xf7a	; 0xf7a <gc_execute_line+0x16a>
    23cc:	9e e1       	ldi	r25, 0x1E	; 30
    23ce:	a9 16       	cp	r10, r25
    23d0:	11 f4       	brne	.+4      	; 0x23d6 <__stack+0x1d7>
    23d2:	0c 94 c5 07 	jmp	0xf8a	; 0xf8a <gc_execute_line+0x17a>
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
    23d6:	a1 e0       	ldi	r26, 0x01	; 1
    23d8:	aa a3       	std	Y+34, r26	; 0x22
    23da:	0c 94 b7 07 	jmp	0xf6e	; 0xf6e <gc_execute_line+0x15e>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    23de:	10 91 87 0c 	lds	r17, 0x0C87	; 0x800c87 <gc_block+0x1>
    23e2:	10 35       	cpi	r17, 0x50	; 80
    23e4:	09 f4       	brne	.+2      	; 0x23e8 <__stack+0x1e9>
    23e6:	d8 cc       	rjmp	.-1616   	; 0x1d98 <gc_execute_line+0xf88>
    23e8:	1f 8e       	std	Y+31, r1	; 0x1f
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
            }
          } else {
            axis_command = AXIS_COMMAND_NONE; // Set to none if no intermediate motion.
    23ea:	1a a2       	std	Y+34, r1	; 0x22
    23ec:	92 ca       	rjmp	.-2780   	; 0x1912 <gc_execute_line+0xb02>
  }

  // TODO: % to denote start of program.

  return(STATUS_OK);
}
    23ee:	e1 96       	adiw	r28, 0x31	; 49
    23f0:	0f b6       	in	r0, 0x3f	; 63
    23f2:	f8 94       	cli
    23f4:	de bf       	out	0x3e, r29	; 62
    23f6:	0f be       	out	0x3f, r0	; 63
    23f8:	cd bf       	out	0x3d, r28	; 61
    23fa:	df 91       	pop	r29
    23fc:	cf 91       	pop	r28
    23fe:	1f 91       	pop	r17
    2400:	0f 91       	pop	r16
    2402:	ff 90       	pop	r15
    2404:	ef 90       	pop	r14
    2406:	df 90       	pop	r13
    2408:	cf 90       	pop	r12
    240a:	bf 90       	pop	r11
    240c:	af 90       	pop	r10
    240e:	9f 90       	pop	r9
    2410:	8f 90       	pop	r8
    2412:	7f 90       	pop	r7
    2414:	6f 90       	pop	r6
    2416:	5f 90       	pop	r5
    2418:	4f 90       	pop	r4
    241a:	3f 90       	pop	r3
    241c:	2f 90       	pop	r2
    241e:	08 95       	ret

00002420 <spindle_get_state>:
uint8_t spindle_get_state()
{
  #ifdef INVERT_SPINDLE_ENABLE_PIN
    if (bit_isfalse(SPINDLE_ENABLE_PORT,(1<<SPINDLE_ENABLE_BIT)) && (SPINDLE_TCCRA_REGISTER & (1<<SPINDLE_COMB_BIT))) {
  #else
    if (bit_istrue(SPINDLE_ENABLE_PORT,(1<<SPINDLE_ENABLE_BIT)) && (SPINDLE_TCCRA_REGISTER & (1<<SPINDLE_COMB_BIT))) {
    2420:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2424:	89 2f       	mov	r24, r25
    2426:	88 70       	andi	r24, 0x08	; 8
    2428:	93 ff       	sbrs	r25, 3
    242a:	0b c0       	rjmp	.+22     	; 0x2442 <spindle_get_state+0x22>
    242c:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
    2430:	89 2f       	mov	r24, r25
    2432:	80 72       	andi	r24, 0x20	; 32
    2434:	95 ff       	sbrs	r25, 5
    2436:	05 c0       	rjmp	.+10     	; 0x2442 <spindle_get_state+0x22>
  #endif
    if (SPINDLE_DIRECTION_PORT & (1<<SPINDLE_DIRECTION_BIT)) { return(SPINDLE_STATE_CCW); }
    2438:	73 99       	sbic	0x0e, 3	; 14
    243a:	02 c0       	rjmp	.+4      	; 0x2440 <spindle_get_state+0x20>
    else { return(SPINDLE_STATE_CW); }
    243c:	81 e0       	ldi	r24, 0x01	; 1
    243e:	08 95       	ret
  #ifdef INVERT_SPINDLE_ENABLE_PIN
    if (bit_isfalse(SPINDLE_ENABLE_PORT,(1<<SPINDLE_ENABLE_BIT)) && (SPINDLE_TCCRA_REGISTER & (1<<SPINDLE_COMB_BIT))) {
  #else
    if (bit_istrue(SPINDLE_ENABLE_PORT,(1<<SPINDLE_ENABLE_BIT)) && (SPINDLE_TCCRA_REGISTER & (1<<SPINDLE_COMB_BIT))) {
  #endif
    if (SPINDLE_DIRECTION_PORT & (1<<SPINDLE_DIRECTION_BIT)) { return(SPINDLE_STATE_CCW); }
    2440:	82 e0       	ldi	r24, 0x02	; 2
    else { return(SPINDLE_STATE_CW); }
  }
	return(SPINDLE_STATE_DISABLE);
}
    2442:	08 95       	ret

00002444 <spindle_stop>:
// Disables the spindle and sets PWM output to zero when PWM variable spindle speed is enabled.
// Called by various main program and ISR routines. Keep routine small, fast, and efficient.
// Called by spindle_init(), spindle_set_speed(), spindle_set_state(), and mc_reset().
void spindle_stop()
{
  SPINDLE_TCCRA_REGISTER &= ~(1<<SPINDLE_COMB_BIT); // Disable PWM. Output voltage is zero.
    2444:	e0 ea       	ldi	r30, 0xA0	; 160
    2446:	f0 e0       	ldi	r31, 0x00	; 0
    2448:	80 81       	ld	r24, Z
    244a:	8f 7d       	andi	r24, 0xDF	; 223
    244c:	80 83       	st	Z, r24
  #ifdef INVERT_SPINDLE_ENABLE_PIN
    SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);  // Set pin to high
  #else
    SPINDLE_ENABLE_PORT &= ~(1<<SPINDLE_ENABLE_BIT); // Set pin to low
    244e:	e2 e0       	ldi	r30, 0x02	; 2
    2450:	f1 e0       	ldi	r31, 0x01	; 1
    2452:	80 81       	ld	r24, Z
    2454:	87 7f       	andi	r24, 0xF7	; 247
    2456:	80 83       	st	Z, r24
    2458:	08 95       	ret

0000245a <spindle_init>:


void spindle_init()
{    
  // Configure variable spindle PWM and enable pin, if required.
  SPINDLE_PWM_DDR |= (1<<SPINDLE_PWM_BIT); // Configure as PWM output pin.
    245a:	e1 e0       	ldi	r30, 0x01	; 1
    245c:	f1 e0       	ldi	r31, 0x01	; 1
    245e:	80 81       	ld	r24, Z
    2460:	80 61       	ori	r24, 0x10	; 16
    2462:	80 83       	st	Z, r24
  SPINDLE_TCCRA_REGISTER = SPINDLE_TCCRA_INIT_MASK; // Configure PWM output compare timer
    2464:	83 e0       	ldi	r24, 0x03	; 3
    2466:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
  SPINDLE_TCCRB_REGISTER = SPINDLE_TCCRB_INIT_MASK;
    246a:	8a e1       	ldi	r24, 0x1A	; 26
    246c:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
  SPINDLE_OCRA_REGISTER = SPINDLE_OCRA_TOP_VALUE; // Set the top value for 16-bit fast PWM mode
    2470:	80 e0       	ldi	r24, 0x00	; 0
    2472:	94 e0       	ldi	r25, 0x04	; 4
    2474:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
    2478:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
  SPINDLE_ENABLE_DDR |= (1<<SPINDLE_ENABLE_BIT); // Configure as output pin.
    247c:	80 81       	ld	r24, Z
    247e:	88 60       	ori	r24, 0x08	; 8
    2480:	80 83       	st	Z, r24
  SPINDLE_DIRECTION_DDR |= (1<<SPINDLE_DIRECTION_BIT); // Configure as output pin.
    2482:	6b 9a       	sbi	0x0d, 3	; 13

  pwm_gradient = SPINDLE_PWM_RANGE/(settings.rpm_max-settings.rpm_min);
    2484:	20 91 01 0f 	lds	r18, 0x0F01	; 0x800f01 <settings+0x41>
    2488:	30 91 02 0f 	lds	r19, 0x0F02	; 0x800f02 <settings+0x42>
    248c:	40 91 03 0f 	lds	r20, 0x0F03	; 0x800f03 <settings+0x43>
    2490:	50 91 04 0f 	lds	r21, 0x0F04	; 0x800f04 <settings+0x44>
    2494:	60 91 fd 0e 	lds	r22, 0x0EFD	; 0x800efd <settings+0x3d>
    2498:	70 91 fe 0e 	lds	r23, 0x0EFE	; 0x800efe <settings+0x3e>
    249c:	80 91 ff 0e 	lds	r24, 0x0EFF	; 0x800eff <settings+0x3f>
    24a0:	90 91 00 0f 	lds	r25, 0x0F00	; 0x800f00 <settings+0x40>
    24a4:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    24a8:	9b 01       	movw	r18, r22
    24aa:	ac 01       	movw	r20, r24
    24ac:	60 e0       	ldi	r22, 0x00	; 0
    24ae:	70 ec       	ldi	r23, 0xC0	; 192
    24b0:	8f e7       	ldi	r24, 0x7F	; 127
    24b2:	94 e4       	ldi	r25, 0x44	; 68
    24b4:	0e 94 cc 3e 	call	0x7d98	; 0x7d98 <__divsf3>
    24b8:	60 93 00 02 	sts	0x0200, r22	; 0x800200 <_edata>
    24bc:	70 93 01 02 	sts	0x0201, r23	; 0x800201 <_edata+0x1>
    24c0:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <_edata+0x2>
    24c4:	90 93 03 02 	sts	0x0203, r25	; 0x800203 <_edata+0x3>
  spindle_stop();
    24c8:	bd cf       	rjmp	.-134    	; 0x2444 <spindle_stop>
    24ca:	08 95       	ret

000024cc <spindle_set_speed>:

// Sets spindle speed PWM output and enable pin, if configured. Called by spindle_set_state()
// and stepper ISR. Keep routine small and efficient.
void spindle_set_speed(uint16_t pwm_value)
{
  SPINDLE_OCR_REGISTER = pwm_value; // Set PWM output level.
    24cc:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
    24d0:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
      #else
        SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
      #endif
    }
  #else
    if (pwm_value == SPINDLE_PWM_OFF_VALUE) {
    24d4:	89 2b       	or	r24, r25
    24d6:	31 f4       	brne	.+12     	; 0x24e4 <spindle_set_speed+0x18>
      SPINDLE_TCCRA_REGISTER &= ~(1<<SPINDLE_COMB_BIT); // Disable PWM. Output voltage is zero.
    24d8:	e0 ea       	ldi	r30, 0xA0	; 160
    24da:	f0 e0       	ldi	r31, 0x00	; 0
    24dc:	80 81       	ld	r24, Z
    24de:	8f 7d       	andi	r24, 0xDF	; 223
    24e0:	80 83       	st	Z, r24
    24e2:	08 95       	ret
    } else {
      SPINDLE_TCCRA_REGISTER |= (1<<SPINDLE_COMB_BIT); // Ensure PWM output is enabled.
    24e4:	e0 ea       	ldi	r30, 0xA0	; 160
    24e6:	f0 e0       	ldi	r31, 0x00	; 0
    24e8:	80 81       	ld	r24, Z
    24ea:	80 62       	ori	r24, 0x20	; 32
    24ec:	80 83       	st	Z, r24
    24ee:	08 95       	ret

000024f0 <spindle_compute_pwm_value>:

#else 

  // Called by spindle_set_state() and step segment generator. Keep routine small and efficient.
  uint16_t spindle_compute_pwm_value(float rpm) // Mega2560 PWM register is 16-bit.
  {
    24f0:	4f 92       	push	r4
    24f2:	5f 92       	push	r5
    24f4:	6f 92       	push	r6
    24f6:	7f 92       	push	r7
    24f8:	8f 92       	push	r8
    24fa:	9f 92       	push	r9
    24fc:	af 92       	push	r10
    24fe:	bf 92       	push	r11
    2500:	cf 92       	push	r12
    2502:	df 92       	push	r13
    2504:	ef 92       	push	r14
    2506:	ff 92       	push	r15
    2508:	2b 01       	movw	r4, r22
    250a:	3c 01       	movw	r6, r24
	uint16_t pwm_value;
	rpm *= (0.010*sys.spindle_speed_ovr); // Scale by spindle speed override value.
	// Calculate PWM register value based on rpm max/min settings and programmed rpm.
	if ((settings.rpm_min >= settings.rpm_max) || (rpm >= settings.rpm_max)) {
    250c:	80 90 01 0f 	lds	r8, 0x0F01	; 0x800f01 <settings+0x41>
    2510:	90 90 02 0f 	lds	r9, 0x0F02	; 0x800f02 <settings+0x42>
    2514:	a0 90 03 0f 	lds	r10, 0x0F03	; 0x800f03 <settings+0x43>
    2518:	b0 90 04 0f 	lds	r11, 0x0F04	; 0x800f04 <settings+0x44>
    251c:	c0 90 fd 0e 	lds	r12, 0x0EFD	; 0x800efd <settings+0x3d>
    2520:	d0 90 fe 0e 	lds	r13, 0x0EFE	; 0x800efe <settings+0x3e>
    2524:	e0 90 ff 0e 	lds	r14, 0x0EFF	; 0x800eff <settings+0x3f>
    2528:	f0 90 00 0f 	lds	r15, 0x0F00	; 0x800f00 <settings+0x40>
    252c:	a7 01       	movw	r20, r14
    252e:	96 01       	movw	r18, r12
    2530:	c5 01       	movw	r24, r10
    2532:	b4 01       	movw	r22, r8
    2534:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    2538:	88 23       	and	r24, r24
    253a:	cc f4       	brge	.+50     	; 0x256e <spindle_compute_pwm_value+0x7e>

  // Called by spindle_set_state() and step segment generator. Keep routine small and efficient.
  uint16_t spindle_compute_pwm_value(float rpm) // Mega2560 PWM register is 16-bit.
  {
	uint16_t pwm_value;
	rpm *= (0.010*sys.spindle_speed_ovr); // Scale by spindle speed override value.
    253c:	60 91 1f 0c 	lds	r22, 0x0C1F	; 0x800c1f <sys+0x9>
    2540:	70 e0       	ldi	r23, 0x00	; 0
    2542:	80 e0       	ldi	r24, 0x00	; 0
    2544:	90 e0       	ldi	r25, 0x00	; 0
    2546:	0e 94 67 3f 	call	0x7ece	; 0x7ece <__floatsisf>
    254a:	2a e0       	ldi	r18, 0x0A	; 10
    254c:	37 ed       	ldi	r19, 0xD7	; 215
    254e:	43 e2       	ldi	r20, 0x23	; 35
    2550:	5c e3       	ldi	r21, 0x3C	; 60
    2552:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    2556:	a3 01       	movw	r20, r6
    2558:	92 01       	movw	r18, r4
    255a:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    255e:	2b 01       	movw	r4, r22
    2560:	3c 01       	movw	r6, r24
	// Calculate PWM register value based on rpm max/min settings and programmed rpm.
	if ((settings.rpm_min >= settings.rpm_max) || (rpm >= settings.rpm_max)) {
    2562:	a7 01       	movw	r20, r14
    2564:	96 01       	movw	r18, r12
    2566:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    256a:	88 23       	and	r24, r24
    256c:	5c f0       	brlt	.+22     	; 0x2584 <spindle_compute_pwm_value+0x94>
	  // No PWM range possible. Set simple on/off spindle control pin state.
	  sys.spindle_speed = settings.rpm_max;
    256e:	c0 92 24 0c 	sts	0x0C24, r12	; 0x800c24 <sys+0xe>
    2572:	d0 92 25 0c 	sts	0x0C25, r13	; 0x800c25 <sys+0xf>
    2576:	e0 92 26 0c 	sts	0x0C26, r14	; 0x800c26 <sys+0x10>
    257a:	f0 92 27 0c 	sts	0x0C27, r15	; 0x800c27 <sys+0x11>
	  pwm_value = SPINDLE_PWM_MAX_VALUE;
    257e:	80 e0       	ldi	r24, 0x00	; 0
    2580:	94 e0       	ldi	r25, 0x04	; 4
    2582:	4a c0       	rjmp	.+148    	; 0x2618 <spindle_compute_pwm_value+0x128>
	} else if (rpm <= settings.rpm_min) {
    2584:	a5 01       	movw	r20, r10
    2586:	94 01       	movw	r18, r8
    2588:	c3 01       	movw	r24, r6
    258a:	b2 01       	movw	r22, r4
    258c:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    2590:	18 16       	cp	r1, r24
    2592:	fc f0       	brlt	.+62     	; 0x25d2 <spindle_compute_pwm_value+0xe2>
	  if (rpm == 0.0) { // S0 disables spindle
    2594:	20 e0       	ldi	r18, 0x00	; 0
    2596:	30 e0       	ldi	r19, 0x00	; 0
    2598:	a9 01       	movw	r20, r18
    259a:	c3 01       	movw	r24, r6
    259c:	b2 01       	movw	r22, r4
    259e:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    25a2:	81 11       	cpse	r24, r1
    25a4:	0b c0       	rjmp	.+22     	; 0x25bc <spindle_compute_pwm_value+0xcc>
		sys.spindle_speed = 0.0;
    25a6:	10 92 24 0c 	sts	0x0C24, r1	; 0x800c24 <sys+0xe>
    25aa:	10 92 25 0c 	sts	0x0C25, r1	; 0x800c25 <sys+0xf>
    25ae:	10 92 26 0c 	sts	0x0C26, r1	; 0x800c26 <sys+0x10>
    25b2:	10 92 27 0c 	sts	0x0C27, r1	; 0x800c27 <sys+0x11>
		pwm_value = SPINDLE_PWM_OFF_VALUE;
    25b6:	80 e0       	ldi	r24, 0x00	; 0
    25b8:	90 e0       	ldi	r25, 0x00	; 0
    25ba:	2e c0       	rjmp	.+92     	; 0x2618 <spindle_compute_pwm_value+0x128>
	  } else { // Set minimum PWM output
		sys.spindle_speed = settings.rpm_min;
    25bc:	80 92 24 0c 	sts	0x0C24, r8	; 0x800c24 <sys+0xe>
    25c0:	90 92 25 0c 	sts	0x0C25, r9	; 0x800c25 <sys+0xf>
    25c4:	a0 92 26 0c 	sts	0x0C26, r10	; 0x800c26 <sys+0x10>
    25c8:	b0 92 27 0c 	sts	0x0C27, r11	; 0x800c27 <sys+0x11>
		pwm_value = SPINDLE_PWM_MIN_VALUE;
    25cc:	81 e0       	ldi	r24, 0x01	; 1
    25ce:	90 e0       	ldi	r25, 0x00	; 0
    25d0:	23 c0       	rjmp	.+70     	; 0x2618 <spindle_compute_pwm_value+0x128>
	  }
	} else { 
	  // Compute intermediate PWM value with linear spindle speed model.
	  // NOTE: A nonlinear model could be installed here, if required, but keep it VERY light-weight.
	  sys.spindle_speed = rpm;
    25d2:	40 92 24 0c 	sts	0x0C24, r4	; 0x800c24 <sys+0xe>
    25d6:	50 92 25 0c 	sts	0x0C25, r5	; 0x800c25 <sys+0xf>
    25da:	60 92 26 0c 	sts	0x0C26, r6	; 0x800c26 <sys+0x10>
    25de:	70 92 27 0c 	sts	0x0C27, r7	; 0x800c27 <sys+0x11>
	  pwm_value = floor((rpm-settings.rpm_min)*pwm_gradient) + SPINDLE_PWM_MIN_VALUE;
    25e2:	a5 01       	movw	r20, r10
    25e4:	94 01       	movw	r18, r8
    25e6:	c3 01       	movw	r24, r6
    25e8:	b2 01       	movw	r22, r4
    25ea:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    25ee:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <_edata>
    25f2:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <_edata+0x1>
    25f6:	40 91 02 02 	lds	r20, 0x0202	; 0x800202 <_edata+0x2>
    25fa:	50 91 03 02 	lds	r21, 0x0203	; 0x800203 <_edata+0x3>
    25fe:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    2602:	0e 94 a2 3f 	call	0x7f44	; 0x7f44 <floor>
    2606:	20 e0       	ldi	r18, 0x00	; 0
    2608:	30 e0       	ldi	r19, 0x00	; 0
    260a:	40 e8       	ldi	r20, 0x80	; 128
    260c:	5f e3       	ldi	r21, 0x3F	; 63
    260e:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    2612:	0e 94 39 3f 	call	0x7e72	; 0x7e72 <__fixunssfsi>
    2616:	cb 01       	movw	r24, r22
	}
	return(pwm_value);
  }
    2618:	ff 90       	pop	r15
    261a:	ef 90       	pop	r14
    261c:	df 90       	pop	r13
    261e:	cf 90       	pop	r12
    2620:	bf 90       	pop	r11
    2622:	af 90       	pop	r10
    2624:	9f 90       	pop	r9
    2626:	8f 90       	pop	r8
    2628:	7f 90       	pop	r7
    262a:	6f 90       	pop	r6
    262c:	5f 90       	pop	r5
    262e:	4f 90       	pop	r4
    2630:	08 95       	ret

00002632 <spindle_set_state>:
// Immediately sets spindle running state with direction and spindle rpm via PWM, if enabled.
// Called by g-code parser spindle_sync(), parking retract and restore, g-code program end,
// sleep, and spindle stop override.
void spindle_set_state(uint8_t state, float rpm)
{
  if (sys.abort) { return; } // Block during abort.
    2632:	90 91 17 0c 	lds	r25, 0x0C17	; 0x800c17 <sys+0x1>
    2636:	91 11       	cpse	r25, r1
    2638:	25 c0       	rjmp	.+74     	; 0x2684 <spindle_set_state+0x52>
  if (state == SPINDLE_DISABLE) { // Halt or set spindle direction and rpm.
    263a:	81 11       	cpse	r24, r1
    263c:	0a c0       	rjmp	.+20     	; 0x2652 <spindle_set_state+0x20>
  
    sys.spindle_speed = 0.0;
    263e:	10 92 24 0c 	sts	0x0C24, r1	; 0x800c24 <sys+0xe>
    2642:	10 92 25 0c 	sts	0x0C25, r1	; 0x800c25 <sys+0xf>
    2646:	10 92 26 0c 	sts	0x0C26, r1	; 0x800c26 <sys+0x10>
    264a:	10 92 27 0c 	sts	0x0C27, r1	; 0x800c27 <sys+0x11>
    spindle_stop();
    264e:	fa de       	rcall	.-524    	; 0x2444 <spindle_stop>
    2650:	17 c0       	rjmp	.+46     	; 0x2680 <spindle_set_state+0x4e>
  
  } else {
  
    if (state == SPINDLE_ENABLE_CW) {
    2652:	80 31       	cpi	r24, 0x10	; 16
    2654:	11 f4       	brne	.+4      	; 0x265a <spindle_set_state+0x28>
      SPINDLE_DIRECTION_PORT &= ~(1<<SPINDLE_DIRECTION_BIT);
    2656:	73 98       	cbi	0x0e, 3	; 14
    2658:	0a c0       	rjmp	.+20     	; 0x266e <spindle_set_state+0x3c>
    } else {
      SPINDLE_DIRECTION_PORT |= (1<<SPINDLE_DIRECTION_BIT);
    265a:	73 9a       	sbi	0x0e, 3	; 14
    }

    // NOTE: Assumes all calls to this function is when Grbl is not moving or must remain off.
    if (settings.flags & BITFLAG_LASER_MODE) { 
    265c:	90 91 05 0f 	lds	r25, 0x0F05	; 0x800f05 <settings+0x45>
    2660:	91 ff       	sbrs	r25, 1
    2662:	05 c0       	rjmp	.+10     	; 0x266e <spindle_set_state+0x3c>
      if (state == SPINDLE_ENABLE_CCW) { rpm = 0.0; } // TODO: May need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE);
    2664:	80 32       	cpi	r24, 0x20	; 32
    2666:	19 f4       	brne	.+6      	; 0x266e <spindle_set_state+0x3c>
    2668:	40 e0       	ldi	r20, 0x00	; 0
    266a:	50 e0       	ldi	r21, 0x00	; 0
    266c:	ba 01       	movw	r22, r20
    }
    spindle_set_speed(spindle_compute_pwm_value(rpm));
    266e:	cb 01       	movw	r24, r22
    2670:	ba 01       	movw	r22, r20
    2672:	3e df       	rcall	.-388    	; 0x24f0 <spindle_compute_pwm_value>
    2674:	2b df       	rcall	.-426    	; 0x24cc <spindle_set_speed>

    #ifndef SPINDLE_ENABLE_OFF_WITH_ZERO_SPEED
      #ifdef INVERT_SPINDLE_ENABLE_PIN
        SPINDLE_ENABLE_PORT &= ~(1<<SPINDLE_ENABLE_BIT);
      #else
        SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
    2676:	e2 e0       	ldi	r30, 0x02	; 2
    2678:	f1 e0       	ldi	r31, 0x01	; 1
    267a:	80 81       	ld	r24, Z
    267c:	88 60       	ori	r24, 0x08	; 8
    267e:	80 83       	st	Z, r24
      #endif   
    #endif
  
  }
  
  sys.report_ovr_counter = 0; // Set to report change immediately
    2680:	10 92 21 0c 	sts	0x0C21, r1	; 0x800c21 <sys+0xb>
    2684:	08 95       	ret

00002686 <spindle_sync>:


// G-code parser entry-point for setting spindle state. Forces a planner buffer sync and bails 
// if an abort or check-mode is active.
void spindle_sync(uint8_t state, float rpm)
{
    2686:	cf 92       	push	r12
    2688:	df 92       	push	r13
    268a:	ef 92       	push	r14
    268c:	ff 92       	push	r15
    268e:	cf 93       	push	r28
  if (sys.state == STATE_CHECK_MODE) { return; }
    2690:	90 91 16 0c 	lds	r25, 0x0C16	; 0x800c16 <sys>
    2694:	92 30       	cpi	r25, 0x02	; 2
    2696:	41 f0       	breq	.+16     	; 0x26a8 <spindle_sync+0x22>
    2698:	6a 01       	movw	r12, r20
    269a:	7b 01       	movw	r14, r22
    269c:	c8 2f       	mov	r28, r24
  protocol_buffer_synchronize(); // Empty planner buffer to ensure spindle is set when programmed.
    269e:	44 d5       	rcall	.+2696   	; 0x3128 <protocol_buffer_synchronize>
  spindle_set_state(state,rpm);
    26a0:	b7 01       	movw	r22, r14
    26a2:	a6 01       	movw	r20, r12
    26a4:	8c 2f       	mov	r24, r28
    26a6:	c5 df       	rcall	.-118    	; 0x2632 <spindle_set_state>
}
    26a8:	cf 91       	pop	r28
    26aa:	ff 90       	pop	r15
    26ac:	ef 90       	pop	r14
    26ae:	df 90       	pop	r13
    26b0:	cf 90       	pop	r12
    26b2:	08 95       	ret

000026b4 <coolant_get_state>:
{
  uint8_t cl_state = COOLANT_STATE_DISABLE;
  #ifdef INVERT_COOLANT_FLOOD_PIN
    if (bit_isfalse(COOLANT_FLOOD_PORT,(1 << COOLANT_FLOOD_BIT))) {
  #else
    if (bit_istrue(COOLANT_FLOOD_PORT,(1 << COOLANT_FLOOD_BIT))) {
    26b4:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    26b8:	85 ff       	sbrs	r24, 5
    26ba:	02 c0       	rjmp	.+4      	; 0x26c0 <coolant_get_state+0xc>
  #endif
    cl_state |= COOLANT_STATE_FLOOD;
    26bc:	80 e4       	ldi	r24, 0x40	; 64
    26be:	01 c0       	rjmp	.+2      	; 0x26c2 <coolant_get_state+0xe>


// Returns current coolant output state. Overrides may alter it from programmed state.
uint8_t coolant_get_state()
{
  uint8_t cl_state = COOLANT_STATE_DISABLE;
    26c0:	80 e0       	ldi	r24, 0x00	; 0
    cl_state |= COOLANT_STATE_FLOOD;
  }
  #ifdef INVERT_COOLANT_MIST_PIN
    if (bit_isfalse(COOLANT_MIST_PORT,(1 << COOLANT_MIST_BIT))) {
  #else
    if (bit_istrue(COOLANT_MIST_PORT,(1 << COOLANT_MIST_BIT))) {
    26c2:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    26c6:	96 fd       	sbrc	r25, 6
  #endif
    cl_state |= COOLANT_STATE_MIST;
    26c8:	80 68       	ori	r24, 0x80	; 128
  }
  return(cl_state);
}
    26ca:	08 95       	ret

000026cc <coolant_stop>:
void coolant_stop()
{
  #ifdef INVERT_COOLANT_FLOOD_PIN
    COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
  #else
    COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    26cc:	e2 e0       	ldi	r30, 0x02	; 2
    26ce:	f1 e0       	ldi	r31, 0x01	; 1
    26d0:	80 81       	ld	r24, Z
    26d2:	8f 7d       	andi	r24, 0xDF	; 223
    26d4:	80 83       	st	Z, r24
  #endif
  #ifdef INVERT_COOLANT_MIST_PIN
    COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
  #else
    COOLANT_MIST_PORT &= ~(1 << COOLANT_MIST_BIT);
    26d6:	80 81       	ld	r24, Z
    26d8:	8f 7b       	andi	r24, 0xBF	; 191
    26da:	80 83       	st	Z, r24
    26dc:	08 95       	ret

000026de <coolant_init>:
#include "grbl.h"


void coolant_init()
{
  COOLANT_FLOOD_DDR |= (1 << COOLANT_FLOOD_BIT); // Configure as output pin.
    26de:	e1 e0       	ldi	r30, 0x01	; 1
    26e0:	f1 e0       	ldi	r31, 0x01	; 1
    26e2:	80 81       	ld	r24, Z
    26e4:	80 62       	ori	r24, 0x20	; 32
    26e6:	80 83       	st	Z, r24
  COOLANT_MIST_DDR |= (1 << COOLANT_MIST_BIT); // Configure as output pin.
    26e8:	80 81       	ld	r24, Z
    26ea:	80 64       	ori	r24, 0x40	; 64
    26ec:	80 83       	st	Z, r24
  coolant_stop();
    26ee:	ee cf       	rjmp	.-36     	; 0x26cc <coolant_stop>
    26f0:	08 95       	ret

000026f2 <coolant_set_state>:
// if enabled. Also sets a flag to report an update to a coolant state.
// Called by coolant toggle override, parking restore, parking retract, sleep mode, g-code
// parser program end, and g-code parser coolant_sync().
void coolant_set_state(uint8_t mode)
{
  if (sys.abort) { return; } // Block during abort.  
    26f2:	90 91 17 0c 	lds	r25, 0x0C17	; 0x800c17 <sys+0x1>
    26f6:	91 11       	cpse	r25, r1
    26f8:	1c c0       	rjmp	.+56     	; 0x2732 <coolant_set_state+0x40>
  
  if (mode & COOLANT_FLOOD_ENABLE) {
    26fa:	86 ff       	sbrs	r24, 6
    26fc:	06 c0       	rjmp	.+12     	; 0x270a <coolant_set_state+0x18>
    #ifdef INVERT_COOLANT_FLOOD_PIN
      COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    #else
      COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
    26fe:	e2 e0       	ldi	r30, 0x02	; 2
    2700:	f1 e0       	ldi	r31, 0x01	; 1
    2702:	90 81       	ld	r25, Z
    2704:	90 62       	ori	r25, 0x20	; 32
    2706:	90 83       	st	Z, r25
    2708:	05 c0       	rjmp	.+10     	; 0x2714 <coolant_set_state+0x22>
    #endif
	} else {
	  #ifdef INVERT_COOLANT_FLOOD_PIN
			COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
		#else
			COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    270a:	e2 e0       	ldi	r30, 0x02	; 2
    270c:	f1 e0       	ldi	r31, 0x01	; 1
    270e:	90 81       	ld	r25, Z
    2710:	9f 7d       	andi	r25, 0xDF	; 223
    2712:	90 83       	st	Z, r25
		#endif
	}
  
	if (mode & COOLANT_MIST_ENABLE) {
    2714:	88 23       	and	r24, r24
    2716:	34 f4       	brge	.+12     	; 0x2724 <coolant_set_state+0x32>
		#ifdef INVERT_COOLANT_MIST_PIN
			COOLANT_MIST_PORT &= ~(1 << COOLANT_MIST_BIT);
		#else
			COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
    2718:	e2 e0       	ldi	r30, 0x02	; 2
    271a:	f1 e0       	ldi	r31, 0x01	; 1
    271c:	80 81       	ld	r24, Z
    271e:	80 64       	ori	r24, 0x40	; 64
    2720:	80 83       	st	Z, r24
    2722:	05 c0       	rjmp	.+10     	; 0x272e <coolant_set_state+0x3c>
		#endif
	} else {
		#ifdef INVERT_COOLANT_MIST_PIN
			COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
		#else
			COOLANT_MIST_PORT &= ~(1 << COOLANT_MIST_BIT);
    2724:	e2 e0       	ldi	r30, 0x02	; 2
    2726:	f1 e0       	ldi	r31, 0x01	; 1
    2728:	80 81       	ld	r24, Z
    272a:	8f 7b       	andi	r24, 0xBF	; 191
    272c:	80 83       	st	Z, r24
		#endif
	}
	
  sys.report_ovr_counter = 0; // Set to report change immediately
    272e:	10 92 21 0c 	sts	0x0C21, r1	; 0x800c21 <sys+0xb>
    2732:	08 95       	ret

00002734 <coolant_sync>:


// G-code parser entry-point for setting coolant state. Forces a planner buffer sync and bails 
// if an abort or check-mode is active.
void coolant_sync(uint8_t mode)
{
    2734:	cf 93       	push	r28
  if (sys.state == STATE_CHECK_MODE) { return; }
    2736:	90 91 16 0c 	lds	r25, 0x0C16	; 0x800c16 <sys>
    273a:	92 30       	cpi	r25, 0x02	; 2
    273c:	21 f0       	breq	.+8      	; 0x2746 <coolant_sync+0x12>
    273e:	c8 2f       	mov	r28, r24
  protocol_buffer_synchronize(); // Ensure coolant turns on when specified in program.
    2740:	f3 d4       	rcall	.+2534   	; 0x3128 <protocol_buffer_synchronize>
  coolant_set_state(mode);
    2742:	8c 2f       	mov	r24, r28
    2744:	d6 df       	rcall	.-84     	; 0x26f2 <coolant_set_state>
}
    2746:	cf 91       	pop	r28
    2748:	08 95       	ret

0000274a <serial_get_rx_buffer_available>:
uint8_t serial_get_tx_buffer_count()
{
  uint8_t ttail = serial_tx_buffer_tail; // Copy to limit multiple calls to volatile
  if (serial_tx_buffer_head >= ttail) { return(serial_tx_buffer_head-ttail); }
  return (TX_RING_BUFFER - (ttail-serial_tx_buffer_head));
}
    274a:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <serial_rx_buffer_tail>
    274e:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <serial_rx_buffer_head>
    2752:	98 17       	cp	r25, r24
    2754:	20 f0       	brcs	.+8      	; 0x275e <serial_get_rx_buffer_available+0x14>
    2756:	98 1b       	sub	r25, r24
    2758:	89 2f       	mov	r24, r25
    275a:	80 95       	com	r24
    275c:	08 95       	ret
    275e:	81 50       	subi	r24, 0x01	; 1
    2760:	89 1b       	sub	r24, r25
    2762:	08 95       	ret

00002764 <serial_init>:
  #if BAUD_RATE < 57600
    uint16_t UBRR0_value = ((F_CPU / (8L * BAUD_RATE)) - 1)/2 ;
    UCSR0A &= ~(1 << U2X0); // baud doubler off  - Only needed on Uno XXX
  #else
    uint16_t UBRR0_value = ((F_CPU / (4L * BAUD_RATE)) - 1)/2;
    UCSR0A |= (1 << U2X0);  // baud doubler on for high baud rates, i.e. 115200
    2764:	e0 ec       	ldi	r30, 0xC0	; 192
    2766:	f0 e0       	ldi	r31, 0x00	; 0
    2768:	80 81       	ld	r24, Z
    276a:	82 60       	ori	r24, 0x02	; 2
    276c:	80 83       	st	Z, r24
  #endif
  UBRR0H = UBRR0_value >> 8;
    276e:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
  UBRR0L = UBRR0_value;
    2772:	80 e1       	ldi	r24, 0x10	; 16
    2774:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>

  // enable rx, tx, and interrupt on complete reception of a byte
  UCSR0B |= (1<<RXEN0 | 1<<TXEN0 | 1<<RXCIE0);
    2778:	e1 ec       	ldi	r30, 0xC1	; 193
    277a:	f0 e0       	ldi	r31, 0x00	; 0
    277c:	80 81       	ld	r24, Z
    277e:	88 69       	ori	r24, 0x98	; 152
    2780:	80 83       	st	Z, r24
    2782:	08 95       	ret

00002784 <serial_write>:


// Writes one byte to the TX serial buffer. Called by main program.
void serial_write(uint8_t data) {
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
    2784:	e0 91 05 02 	lds	r30, 0x0205	; 0x800205 <serial_tx_buffer_head>
    2788:	21 e0       	ldi	r18, 0x01	; 1
    278a:	2e 0f       	add	r18, r30
  if (next_head == TX_RING_BUFFER) { next_head = 0; }

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) {
    278c:	04 c0       	rjmp	.+8      	; 0x2796 <serial_write+0x12>
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.
    if (sys_rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
    278e:	90 91 29 0c 	lds	r25, 0x0C29	; 0x800c29 <sys_rt_exec_state>
    2792:	94 fd       	sbrc	r25, 4
    2794:	0f c0       	rjmp	.+30     	; 0x27b4 <serial_write+0x30>
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
  if (next_head == TX_RING_BUFFER) { next_head = 0; }

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) {
    2796:	90 91 04 02 	lds	r25, 0x0204	; 0x800204 <serial_tx_buffer_tail>
    279a:	29 17       	cp	r18, r25
    279c:	c1 f3       	breq	.-16     	; 0x278e <serial_write+0xa>
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.
    if (sys_rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
  }

  // Store data and advance head
  serial_tx_buffer[serial_tx_buffer_head] = data;
    279e:	f0 e0       	ldi	r31, 0x00	; 0
    27a0:	e0 54       	subi	r30, 0x40	; 64
    27a2:	f3 4f       	sbci	r31, 0xF3	; 243
    27a4:	80 83       	st	Z, r24
  serial_tx_buffer_head = next_head;
    27a6:	20 93 05 02 	sts	0x0205, r18	; 0x800205 <serial_tx_buffer_head>

  // Enable Data Register Empty Interrupt to make sure tx-streaming is running
  UCSR0B |=  (1 << UDRIE0);
    27aa:	e1 ec       	ldi	r30, 0xC1	; 193
    27ac:	f0 e0       	ldi	r31, 0x00	; 0
    27ae:	80 81       	ld	r24, Z
    27b0:	80 62       	ori	r24, 0x20	; 32
    27b2:	80 83       	st	Z, r24
    27b4:	08 95       	ret

000027b6 <__vector_26>:
}


// Data Register Empty Interrupt handler
ISR(SERIAL_UDRE)
{
    27b6:	1f 92       	push	r1
    27b8:	0f 92       	push	r0
    27ba:	0f b6       	in	r0, 0x3f	; 63
    27bc:	0f 92       	push	r0
    27be:	11 24       	eor	r1, r1
    27c0:	0b b6       	in	r0, 0x3b	; 59
    27c2:	0f 92       	push	r0
    27c4:	8f 93       	push	r24
    27c6:	9f 93       	push	r25
    27c8:	ef 93       	push	r30
    27ca:	ff 93       	push	r31
  uint8_t tail = serial_tx_buffer_tail; // Temporary serial_tx_buffer_tail (to optimize for volatile)
    27cc:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <serial_tx_buffer_tail>

  // Send a byte from the buffer
  UDR0 = serial_tx_buffer[tail];
    27d0:	e8 2f       	mov	r30, r24
    27d2:	f0 e0       	ldi	r31, 0x00	; 0
    27d4:	e0 54       	subi	r30, 0x40	; 64
    27d6:	f3 4f       	sbci	r31, 0xF3	; 243
    27d8:	90 81       	ld	r25, Z
    27da:	90 93 c6 00 	sts	0x00C6, r25	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>

  // Update tail position
  tail++;
    27de:	8f 5f       	subi	r24, 0xFF	; 255
  if (tail == TX_RING_BUFFER) { tail = 0; }

  serial_tx_buffer_tail = tail;
    27e0:	80 93 04 02 	sts	0x0204, r24	; 0x800204 <serial_tx_buffer_tail>

  // Turn off Data Register Empty Interrupt to stop tx-streaming if this concludes the transfer
  if (tail == serial_tx_buffer_head) { UCSR0B &= ~(1 << UDRIE0); }
    27e4:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <serial_tx_buffer_head>
    27e8:	89 13       	cpse	r24, r25
    27ea:	05 c0       	rjmp	.+10     	; 0x27f6 <__vector_26+0x40>
    27ec:	e1 ec       	ldi	r30, 0xC1	; 193
    27ee:	f0 e0       	ldi	r31, 0x00	; 0
    27f0:	80 81       	ld	r24, Z
    27f2:	8f 7d       	andi	r24, 0xDF	; 223
    27f4:	80 83       	st	Z, r24
}
    27f6:	ff 91       	pop	r31
    27f8:	ef 91       	pop	r30
    27fa:	9f 91       	pop	r25
    27fc:	8f 91       	pop	r24
    27fe:	0f 90       	pop	r0
    2800:	0b be       	out	0x3b, r0	; 59
    2802:	0f 90       	pop	r0
    2804:	0f be       	out	0x3f, r0	; 63
    2806:	0f 90       	pop	r0
    2808:	1f 90       	pop	r1
    280a:	18 95       	reti

0000280c <serial_read>:


// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
    280c:	90 91 06 02 	lds	r25, 0x0206	; 0x800206 <serial_rx_buffer_tail>
  if (serial_rx_buffer_head == tail) {
    2810:	80 91 07 02 	lds	r24, 0x0207	; 0x800207 <serial_rx_buffer_head>
    2814:	98 17       	cp	r25, r24
    2816:	49 f0       	breq	.+18     	; 0x282a <serial_read+0x1e>
    return SERIAL_NO_DATA;
  } else {
    uint8_t data = serial_rx_buffer[tail];
    2818:	e9 2f       	mov	r30, r25
    281a:	f0 e0       	ldi	r31, 0x00	; 0
    281c:	e0 54       	subi	r30, 0x40	; 64
    281e:	f2 4f       	sbci	r31, 0xF2	; 242
    2820:	80 81       	ld	r24, Z

    tail++;
    2822:	9f 5f       	subi	r25, 0xFF	; 255
    if (tail == RX_RING_BUFFER) { tail = 0; }
    serial_rx_buffer_tail = tail;
    2824:	90 93 06 02 	sts	0x0206, r25	; 0x800206 <serial_rx_buffer_tail>

    return data;
    2828:	08 95       	ret
// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
  if (serial_rx_buffer_head == tail) {
    return SERIAL_NO_DATA;
    282a:	8f ef       	ldi	r24, 0xFF	; 255
    if (tail == RX_RING_BUFFER) { tail = 0; }
    serial_rx_buffer_tail = tail;

    return data;
  }
}
    282c:	08 95       	ret

0000282e <__vector_25>:


ISR(SERIAL_RX)
{
    282e:	1f 92       	push	r1
    2830:	0f 92       	push	r0
    2832:	0f b6       	in	r0, 0x3f	; 63
    2834:	0f 92       	push	r0
    2836:	11 24       	eor	r1, r1
    2838:	0b b6       	in	r0, 0x3b	; 59
    283a:	0f 92       	push	r0
    283c:	2f 93       	push	r18
    283e:	3f 93       	push	r19
    2840:	4f 93       	push	r20
    2842:	5f 93       	push	r21
    2844:	6f 93       	push	r22
    2846:	7f 93       	push	r23
    2848:	8f 93       	push	r24
    284a:	9f 93       	push	r25
    284c:	af 93       	push	r26
    284e:	bf 93       	push	r27
    2850:	ef 93       	push	r30
    2852:	ff 93       	push	r31
  uint8_t data = UDR0;
    2854:	e0 91 c6 00 	lds	r30, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
  uint8_t next_head;

  // Pick off realtime command characters directly from the serial stream. These characters are
  // not passed into the main buffer, but these set system state flag bits for realtime execution.
  switch (data) {
    2858:	e1 32       	cpi	r30, 0x21	; 33
    285a:	a1 f0       	breq	.+40     	; 0x2884 <__vector_25+0x56>
    285c:	18 f4       	brcc	.+6      	; 0x2864 <__vector_25+0x36>
    285e:	e8 31       	cpi	r30, 0x18	; 24
    2860:	31 f0       	breq	.+12     	; 0x286e <__vector_25+0x40>
    2862:	14 c0       	rjmp	.+40     	; 0x288c <__vector_25+0x5e>
    2864:	ef 33       	cpi	r30, 0x3F	; 63
    2866:	31 f0       	breq	.+12     	; 0x2874 <__vector_25+0x46>
    2868:	ee 37       	cpi	r30, 0x7E	; 126
    286a:	41 f0       	breq	.+16     	; 0x287c <__vector_25+0x4e>
    286c:	0f c0       	rjmp	.+30     	; 0x288c <__vector_25+0x5e>
    case CMD_RESET:         mc_reset(); break; // Call motion control reset routine.
    286e:	0e 94 cb 06 	call	0xd96	; 0xd96 <mc_reset>
    2872:	81 c0       	rjmp	.+258    	; 0x2976 <__vector_25+0x148>
    case CMD_STATUS_REPORT: system_set_exec_state_flag(EXEC_STATUS_REPORT); break; // Set as true
    2874:	81 e0       	ldi	r24, 0x01	; 1
    2876:	0e 94 f5 3a 	call	0x75ea	; 0x75ea <system_set_exec_state_flag>
    287a:	7d c0       	rjmp	.+250    	; 0x2976 <__vector_25+0x148>
    case CMD_CYCLE_START:   system_set_exec_state_flag(EXEC_CYCLE_START); break; // Set as true
    287c:	82 e0       	ldi	r24, 0x02	; 2
    287e:	0e 94 f5 3a 	call	0x75ea	; 0x75ea <system_set_exec_state_flag>
    2882:	79 c0       	rjmp	.+242    	; 0x2976 <__vector_25+0x148>
    case CMD_FEED_HOLD:     system_set_exec_state_flag(EXEC_FEED_HOLD); break; // Set as true
    2884:	88 e0       	ldi	r24, 0x08	; 8
    2886:	0e 94 f5 3a 	call	0x75ea	; 0x75ea <system_set_exec_state_flag>
    288a:	75 c0       	rjmp	.+234    	; 0x2976 <__vector_25+0x148>
    default :
      if (data > 0x7F) { // Real-time control characters are extended ACSII only.
    288c:	ee 23       	and	r30, r30
    288e:	0c f0       	brlt	.+2      	; 0x2892 <__vector_25+0x64>
    2890:	64 c0       	rjmp	.+200    	; 0x295a <__vector_25+0x12c>
        switch(data) {
    2892:	8e 2f       	mov	r24, r30
    2894:	90 e0       	ldi	r25, 0x00	; 0
    2896:	fc 01       	movw	r30, r24
    2898:	e4 58       	subi	r30, 0x84	; 132
    289a:	f1 09       	sbc	r31, r1
    289c:	ee 31       	cpi	r30, 0x1E	; 30
    289e:	f1 05       	cpc	r31, r1
    28a0:	08 f0       	brcs	.+2      	; 0x28a4 <__vector_25+0x76>
    28a2:	69 c0       	rjmp	.+210    	; 0x2976 <__vector_25+0x148>
    28a4:	88 27       	eor	r24, r24
    28a6:	eb 5f       	subi	r30, 0xFB	; 251
    28a8:	fe 4f       	sbci	r31, 0xFE	; 254
    28aa:	8f 4f       	sbci	r24, 0xFF	; 255
    28ac:	0c 94 12 42 	jmp	0x8424	; 0x8424 <__tablejump2__>
          case CMD_SAFETY_DOOR:   system_set_exec_state_flag(EXEC_SAFETY_DOOR); break; // Set as true
    28b0:	80 e2       	ldi	r24, 0x20	; 32
    28b2:	0e 94 f5 3a 	call	0x75ea	; 0x75ea <system_set_exec_state_flag>
    28b6:	5f c0       	rjmp	.+190    	; 0x2976 <__vector_25+0x148>
          case CMD_JOG_CANCEL:   
            if (sys.state & STATE_JOG) { // Block all other states from invoking motion cancel.
    28b8:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
    28bc:	85 ff       	sbrs	r24, 5
    28be:	5b c0       	rjmp	.+182    	; 0x2976 <__vector_25+0x148>
              system_set_exec_state_flag(EXEC_MOTION_CANCEL); 
    28c0:	80 e4       	ldi	r24, 0x40	; 64
    28c2:	0e 94 f5 3a 	call	0x75ea	; 0x75ea <system_set_exec_state_flag>
    28c6:	57 c0       	rjmp	.+174    	; 0x2976 <__vector_25+0x148>
            }
            break; 
          #ifdef DEBUG
            case CMD_DEBUG_REPORT: {uint8_t sreg = SREG; cli(); bit_true(sys_rt_exec_debug,EXEC_DEBUG_REPORT); SREG = sreg;} break;
    28c8:	9f b7       	in	r25, 0x3f	; 63
    28ca:	f8 94       	cli
    28cc:	80 91 44 0c 	lds	r24, 0x0C44	; 0x800c44 <sys_rt_exec_debug>
    28d0:	81 60       	ori	r24, 0x01	; 1
    28d2:	80 93 44 0c 	sts	0x0C44, r24	; 0x800c44 <sys_rt_exec_debug>
    28d6:	9f bf       	out	0x3f, r25	; 63
    28d8:	4e c0       	rjmp	.+156    	; 0x2976 <__vector_25+0x148>
          #endif
          case CMD_FEED_OVR_RESET: system_set_exec_motion_override_flag(EXEC_FEED_OVR_RESET); break;
    28da:	81 e0       	ldi	r24, 0x01	; 1
    28dc:	0e 94 69 3d 	call	0x7ad2	; 0x7ad2 <system_set_exec_motion_override_flag>
    28e0:	4a c0       	rjmp	.+148    	; 0x2976 <__vector_25+0x148>
          case CMD_FEED_OVR_COARSE_PLUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_COARSE_PLUS); break;
    28e2:	82 e0       	ldi	r24, 0x02	; 2
    28e4:	0e 94 69 3d 	call	0x7ad2	; 0x7ad2 <system_set_exec_motion_override_flag>
    28e8:	46 c0       	rjmp	.+140    	; 0x2976 <__vector_25+0x148>
          case CMD_FEED_OVR_COARSE_MINUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_COARSE_MINUS); break;
    28ea:	84 e0       	ldi	r24, 0x04	; 4
    28ec:	0e 94 69 3d 	call	0x7ad2	; 0x7ad2 <system_set_exec_motion_override_flag>
    28f0:	42 c0       	rjmp	.+132    	; 0x2976 <__vector_25+0x148>
          case CMD_FEED_OVR_FINE_PLUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_FINE_PLUS); break;
    28f2:	88 e0       	ldi	r24, 0x08	; 8
    28f4:	0e 94 69 3d 	call	0x7ad2	; 0x7ad2 <system_set_exec_motion_override_flag>
    28f8:	3e c0       	rjmp	.+124    	; 0x2976 <__vector_25+0x148>
          case CMD_FEED_OVR_FINE_MINUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_FINE_MINUS); break;
    28fa:	80 e1       	ldi	r24, 0x10	; 16
    28fc:	0e 94 69 3d 	call	0x7ad2	; 0x7ad2 <system_set_exec_motion_override_flag>
    2900:	3a c0       	rjmp	.+116    	; 0x2976 <__vector_25+0x148>
          case CMD_RAPID_OVR_RESET: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_RESET); break;
    2902:	80 e2       	ldi	r24, 0x20	; 32
    2904:	0e 94 69 3d 	call	0x7ad2	; 0x7ad2 <system_set_exec_motion_override_flag>
    2908:	36 c0       	rjmp	.+108    	; 0x2976 <__vector_25+0x148>
          case CMD_RAPID_OVR_MEDIUM: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_MEDIUM); break;
    290a:	80 e4       	ldi	r24, 0x40	; 64
    290c:	0e 94 69 3d 	call	0x7ad2	; 0x7ad2 <system_set_exec_motion_override_flag>
    2910:	32 c0       	rjmp	.+100    	; 0x2976 <__vector_25+0x148>
          case CMD_RAPID_OVR_LOW: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_LOW); break;
    2912:	80 e8       	ldi	r24, 0x80	; 128
    2914:	0e 94 69 3d 	call	0x7ad2	; 0x7ad2 <system_set_exec_motion_override_flag>
    2918:	2e c0       	rjmp	.+92     	; 0x2976 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_RESET: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_RESET); break;
    291a:	81 e0       	ldi	r24, 0x01	; 1
    291c:	0e 94 72 3d 	call	0x7ae4	; 0x7ae4 <system_set_exec_accessory_override_flag>
    2920:	2a c0       	rjmp	.+84     	; 0x2976 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_COARSE_PLUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_COARSE_PLUS); break;
    2922:	82 e0       	ldi	r24, 0x02	; 2
    2924:	0e 94 72 3d 	call	0x7ae4	; 0x7ae4 <system_set_exec_accessory_override_flag>
    2928:	26 c0       	rjmp	.+76     	; 0x2976 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_COARSE_MINUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_COARSE_MINUS); break;
    292a:	84 e0       	ldi	r24, 0x04	; 4
    292c:	0e 94 72 3d 	call	0x7ae4	; 0x7ae4 <system_set_exec_accessory_override_flag>
    2930:	22 c0       	rjmp	.+68     	; 0x2976 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_FINE_PLUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_FINE_PLUS); break;
    2932:	88 e0       	ldi	r24, 0x08	; 8
    2934:	0e 94 72 3d 	call	0x7ae4	; 0x7ae4 <system_set_exec_accessory_override_flag>
    2938:	1e c0       	rjmp	.+60     	; 0x2976 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_FINE_MINUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_FINE_MINUS); break;
    293a:	80 e1       	ldi	r24, 0x10	; 16
    293c:	0e 94 72 3d 	call	0x7ae4	; 0x7ae4 <system_set_exec_accessory_override_flag>
    2940:	1a c0       	rjmp	.+52     	; 0x2976 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_STOP: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP); break;
    2942:	80 e2       	ldi	r24, 0x20	; 32
    2944:	0e 94 72 3d 	call	0x7ae4	; 0x7ae4 <system_set_exec_accessory_override_flag>
    2948:	16 c0       	rjmp	.+44     	; 0x2976 <__vector_25+0x148>
          case CMD_COOLANT_FLOOD_OVR_TOGGLE: system_set_exec_accessory_override_flag(EXEC_COOLANT_FLOOD_OVR_TOGGLE); break;
    294a:	80 e4       	ldi	r24, 0x40	; 64
    294c:	0e 94 72 3d 	call	0x7ae4	; 0x7ae4 <system_set_exec_accessory_override_flag>
    2950:	12 c0       	rjmp	.+36     	; 0x2976 <__vector_25+0x148>
          case CMD_COOLANT_MIST_OVR_TOGGLE: system_set_exec_accessory_override_flag(EXEC_COOLANT_MIST_OVR_TOGGLE); break;
    2952:	80 e8       	ldi	r24, 0x80	; 128
    2954:	0e 94 72 3d 	call	0x7ae4	; 0x7ae4 <system_set_exec_accessory_override_flag>
    2958:	0e c0       	rjmp	.+28     	; 0x2976 <__vector_25+0x148>
        }
        // Throw away any unfound extended-ASCII character by not passing it to the serial buffer.
      } else { // Write character to buffer
        next_head = serial_rx_buffer_head + 1;
    295a:	a0 91 07 02 	lds	r26, 0x0207	; 0x800207 <serial_rx_buffer_head>
    295e:	81 e0       	ldi	r24, 0x01	; 1
    2960:	8a 0f       	add	r24, r26
        if (next_head == RX_RING_BUFFER) { next_head = 0; }

        // Write data to buffer unless it is full.
        if (next_head != serial_rx_buffer_tail) {
    2962:	90 91 06 02 	lds	r25, 0x0206	; 0x800206 <serial_rx_buffer_tail>
    2966:	89 17       	cp	r24, r25
    2968:	31 f0       	breq	.+12     	; 0x2976 <__vector_25+0x148>
          serial_rx_buffer[serial_rx_buffer_head] = data;
    296a:	b0 e0       	ldi	r27, 0x00	; 0
    296c:	a0 54       	subi	r26, 0x40	; 64
    296e:	b2 4f       	sbci	r27, 0xF2	; 242
    2970:	ec 93       	st	X, r30
          serial_rx_buffer_head = next_head;
    2972:	80 93 07 02 	sts	0x0207, r24	; 0x800207 <serial_rx_buffer_head>
        }
      }
  }
}
    2976:	ff 91       	pop	r31
    2978:	ef 91       	pop	r30
    297a:	bf 91       	pop	r27
    297c:	af 91       	pop	r26
    297e:	9f 91       	pop	r25
    2980:	8f 91       	pop	r24
    2982:	7f 91       	pop	r23
    2984:	6f 91       	pop	r22
    2986:	5f 91       	pop	r21
    2988:	4f 91       	pop	r20
    298a:	3f 91       	pop	r19
    298c:	2f 91       	pop	r18
    298e:	0f 90       	pop	r0
    2990:	0b be       	out	0x3b, r0	; 59
    2992:	0f 90       	pop	r0
    2994:	0f be       	out	0x3f, r0	; 63
    2996:	0f 90       	pop	r0
    2998:	1f 90       	pop	r1
    299a:	18 95       	reti

0000299c <serial_reset_read_buffer>:


void serial_reset_read_buffer()
{
  serial_rx_buffer_tail = serial_rx_buffer_head;
    299c:	80 91 07 02 	lds	r24, 0x0207	; 0x800207 <serial_rx_buffer_head>
    29a0:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <serial_rx_buffer_tail>
    29a4:	08 95       	ret

000029a6 <protocol_auto_cycle_start>:
// when one of these conditions exist respectively: There are no more blocks sent (i.e. streaming
// is finished, single commands), a command that needs to wait for the motions in the buffer to
// execute calls a buffer sync, or the planner buffer is full and ready to go.
void protocol_auto_cycle_start()
{
  if (plan_get_current_block() != NULL) { // Check if there are any blocks in the buffer.
    29a6:	0e 94 ed 28 	call	0x51da	; 0x51da <plan_get_current_block>
    29aa:	89 2b       	or	r24, r25
    29ac:	19 f0       	breq	.+6      	; 0x29b4 <protocol_auto_cycle_start+0xe>
    system_set_exec_state_flag(EXEC_CYCLE_START); // If so, execute them!
    29ae:	82 e0       	ldi	r24, 0x02	; 2
    29b0:	0c 94 f5 3a 	jmp	0x75ea	; 0x75ea <system_set_exec_state_flag>
    29b4:	08 95       	ret

000029b6 <protocol_exec_rt_system>:

// Executes run-time commands, when required. This function primarily operates as Grbl's state
// machine and controls the various real-time features Grbl has to offer.
// NOTE: Do not alter this unless you know exactly what you are doing!
void protocol_exec_rt_system()
{
    29b6:	cf 93       	push	r28
    29b8:	df 93       	push	r29
  uint8_t rt_exec; // Temp variable to avoid calling volatile multiple times.
  rt_exec = sys_rt_exec_alarm; // Copy volatile sys_rt_exec_alarm.
    29ba:	c0 91 43 0c 	lds	r28, 0x0C43	; 0x800c43 <sys_rt_exec_alarm>
  if (rt_exec) { // Enter only if any bit flag is true
    29be:	cc 23       	and	r28, r28
    29c0:	a9 f0       	breq	.+42     	; 0x29ec <protocol_exec_rt_system+0x36>
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
    29c2:	81 e0       	ldi	r24, 0x01	; 1
    29c4:	80 93 16 0c 	sts	0x0C16, r24	; 0x800c16 <sys>
    report_alarm_message(rt_exec);
    29c8:	8c 2f       	mov	r24, r28
    29ca:	0e 94 d6 34 	call	0x69ac	; 0x69ac <report_alarm_message>
    // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
    if ((rt_exec == EXEC_ALARM_HARD_LIMIT) || (rt_exec == EXEC_ALARM_SOFT_LIMIT)) {
    29ce:	c1 50       	subi	r28, 0x01	; 1
    29d0:	c2 30       	cpi	r28, 0x02	; 2
    29d2:	50 f4       	brcc	.+20     	; 0x29e8 <protocol_exec_rt_system+0x32>
      report_feedback_message(MESSAGE_CRITICAL_EVENT);
    29d4:	81 e0       	ldi	r24, 0x01	; 1
    29d6:	0e 94 fa 34 	call	0x69f4	; 0x69f4 <report_feedback_message>
      system_clear_exec_state_flag(EXEC_RESET); // Disable any existing reset
    29da:	80 e1       	ldi	r24, 0x10	; 16
    29dc:	0e 94 53 3d 	call	0x7aa6	; 0x7aa6 <system_clear_exec_state_flag>
        // Block everything, except reset and status reports, until user issues reset or power
        // cycles. Hard limits typically occur while unattended or not paying attention. Gives
        // the user and a GUI time to do what is needed before resetting, like killing the
        // incoming stream. The same could be said about soft limits. While the position is not
        // lost, continued streaming could cause a serious crash if by chance it gets executed.
      } while (bit_isfalse(sys_rt_exec_state,EXEC_RESET));
    29e0:	80 91 29 0c 	lds	r24, 0x0C29	; 0x800c29 <sys_rt_exec_state>
    29e4:	84 ff       	sbrs	r24, 4
    29e6:	fc cf       	rjmp	.-8      	; 0x29e0 <protocol_exec_rt_system+0x2a>
    }
    system_clear_exec_alarm(); // Clear alarm
    29e8:	0e 94 63 3d 	call	0x7ac6	; 0x7ac6 <system_clear_exec_alarm>
  }

  rt_exec = sys_rt_exec_state; // Copy volatile sys_rt_exec_state.
    29ec:	c0 91 29 0c 	lds	r28, 0x0C29	; 0x800c29 <sys_rt_exec_state>
  if (rt_exec) {
    29f0:	cc 23       	and	r28, r28
    29f2:	09 f4       	brne	.+2      	; 0x29f6 <protocol_exec_rt_system+0x40>
    29f4:	f4 c0       	rjmp	.+488    	; 0x2bde <protocol_exec_rt_system+0x228>

    // Execute system abort.
    if (rt_exec & EXEC_RESET) {
    29f6:	c4 ff       	sbrs	r28, 4
    29f8:	04 c0       	rjmp	.+8      	; 0x2a02 <protocol_exec_rt_system+0x4c>
      sys.abort = true;  // Only place this is set true.
    29fa:	81 e0       	ldi	r24, 0x01	; 1
    29fc:	80 93 17 0c 	sts	0x0C17, r24	; 0x800c17 <sys+0x1>
      return; // Nothing else to do but exit.
    2a00:	c8 c1       	rjmp	.+912    	; 0x2d92 <protocol_exec_rt_system+0x3dc>
    }

    // Execute and serial print status
    if (rt_exec & EXEC_STATUS_REPORT) {
    2a02:	c0 ff       	sbrs	r28, 0
    2a04:	05 c0       	rjmp	.+10     	; 0x2a10 <protocol_exec_rt_system+0x5a>
      report_realtime_status();
    2a06:	0e 94 b7 37 	call	0x6f6e	; 0x6f6e <report_realtime_status>
      system_clear_exec_state_flag(EXEC_STATUS_REPORT);
    2a0a:	81 e0       	ldi	r24, 0x01	; 1
    2a0c:	0e 94 53 3d 	call	0x7aa6	; 0x7aa6 <system_clear_exec_state_flag>
    }

    // NOTE: Once hold is initiated, the system immediately enters a suspend state to block all
    // main program processes until either reset or resumed. This ensures a hold completes safely.
    if (rt_exec & (EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR | EXEC_SLEEP)) {
    2a10:	8c 2f       	mov	r24, r28
    2a12:	88 7e       	andi	r24, 0xE8	; 232
    2a14:	09 f4       	brne	.+2      	; 0x2a18 <protocol_exec_rt_system+0x62>
    2a16:	63 c0       	rjmp	.+198    	; 0x2ade <protocol_exec_rt_system+0x128>

      // State check for allowable states for hold methods.
      if (!(sys.state & (STATE_ALARM | STATE_CHECK_MODE))) {
    2a18:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
    2a1c:	98 2f       	mov	r25, r24
    2a1e:	93 70       	andi	r25, 0x03	; 3
    2a20:	09 f0       	breq	.+2      	; 0x2a24 <protocol_exec_rt_system+0x6e>
    2a22:	4c c0       	rjmp	.+152    	; 0x2abc <protocol_exec_rt_system+0x106>
      
        // If in CYCLE or JOG states, immediately initiate a motion HOLD.
        if (sys.state & (STATE_CYCLE | STATE_JOG)) {
    2a24:	88 72       	andi	r24, 0x28	; 40
    2a26:	91 f0       	breq	.+36     	; 0x2a4c <protocol_exec_rt_system+0x96>
          if (!(sys.suspend & (SUSPEND_MOTION_CANCEL | SUSPEND_JOG_CANCEL))) { // Block, if already holding.
    2a28:	80 91 18 0c 	lds	r24, 0x0C18	; 0x800c18 <sys+0x2>
    2a2c:	80 7c       	andi	r24, 0xC0	; 192
    2a2e:	71 f4       	brne	.+28     	; 0x2a4c <protocol_exec_rt_system+0x96>
            st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
    2a30:	7b d6       	rcall	.+3318   	; 0x3728 <st_update_plan_block_parameters>
            sys.step_control = STEP_CONTROL_EXECUTE_HOLD; // Initiate suspend state with active flag.
    2a32:	e6 e1       	ldi	r30, 0x16	; 22
    2a34:	fc e0       	ldi	r31, 0x0C	; 12
    2a36:	82 e0       	ldi	r24, 0x02	; 2
    2a38:	84 83       	std	Z+4, r24	; 0x04
            if (sys.state == STATE_JOG) { // Jog cancelled upon any hold event, except for sleeping.
    2a3a:	80 81       	ld	r24, Z
    2a3c:	80 32       	cpi	r24, 0x20	; 32
    2a3e:	31 f4       	brne	.+12     	; 0x2a4c <protocol_exec_rt_system+0x96>
              if (!(rt_exec & EXEC_SLEEP)) { sys.suspend |= SUSPEND_JOG_CANCEL; } 
    2a40:	cc 23       	and	r28, r28
    2a42:	bc f0       	brlt	.+46     	; 0x2a72 <protocol_exec_rt_system+0xbc>
    2a44:	92 81       	ldd	r25, Z+2	; 0x02
    2a46:	90 68       	ori	r25, 0x80	; 128
    2a48:	92 83       	std	Z+2, r25	; 0x02
    2a4a:	13 c0       	rjmp	.+38     	; 0x2a72 <protocol_exec_rt_system+0xbc>
            }
          }
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend state and hold is complete.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_HOLD_COMPLETE; }
    2a4c:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
    2a50:	81 11       	cpse	r24, r1
    2a52:	06 c0       	rjmp	.+12     	; 0x2a60 <protocol_exec_rt_system+0xaa>
    2a54:	91 e0       	ldi	r25, 0x01	; 1
    2a56:	90 93 18 0c 	sts	0x0C18, r25	; 0x800c18 <sys+0x2>

        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
    2a5a:	c6 fd       	sbrc	r28, 6
    2a5c:	05 c0       	rjmp	.+10     	; 0x2a68 <protocol_exec_rt_system+0xb2>
    2a5e:	96 c1       	rjmp	.+812    	; 0x2d8c <protocol_exec_rt_system+0x3d6>
    2a60:	c6 ff       	sbrs	r28, 6
    2a62:	07 c0       	rjmp	.+14     	; 0x2a72 <protocol_exec_rt_system+0xbc>
          // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiated beforehand
          // to hold the CYCLE. Motion cancel is valid for a single planner block motion only, while jog cancel
          // will handle and clear multiple planner block motions.
          if (!(sys.state & STATE_JOG)) { sys.suspend |= SUSPEND_MOTION_CANCEL; } // NOTE: State is STATE_CYCLE.
    2a64:	85 fd       	sbrc	r24, 5
    2a66:	05 c0       	rjmp	.+10     	; 0x2a72 <protocol_exec_rt_system+0xbc>
    2a68:	e6 e1       	ldi	r30, 0x16	; 22
    2a6a:	fc e0       	ldi	r31, 0x0C	; 12
    2a6c:	92 81       	ldd	r25, Z+2	; 0x02
    2a6e:	90 64       	ori	r25, 0x40	; 64
    2a70:	92 83       	std	Z+2, r25	; 0x02
        }

        // Execute a feed hold with deceleration, if required. Then, suspend system.
        if (rt_exec & EXEC_FEED_HOLD) {
    2a72:	c3 ff       	sbrs	r28, 3
    2a74:	05 c0       	rjmp	.+10     	; 0x2a80 <protocol_exec_rt_system+0xca>
          // Block SAFETY_DOOR, JOG, and SLEEP states from changing to HOLD state.
          if (!(sys.state & (STATE_SAFETY_DOOR | STATE_JOG | STATE_SLEEP))) { sys.state = STATE_HOLD; }
    2a76:	80 7e       	andi	r24, 0xE0	; 224
    2a78:	19 f4       	brne	.+6      	; 0x2a80 <protocol_exec_rt_system+0xca>
    2a7a:	80 e1       	ldi	r24, 0x10	; 16
    2a7c:	80 93 16 0c 	sts	0x0C16, r24	; 0x800c16 <sys>
        }

        // Execute a safety door stop with a feed hold and disable spindle/coolant.
        // NOTE: Safety door differs from feed holds by stopping everything no matter state, disables powered
        // devices (spindle/coolant), and blocks resuming until switch is re-engaged.
        if (rt_exec & EXEC_SAFETY_DOOR) {
    2a80:	c5 ff       	sbrs	r28, 5
    2a82:	1c c0       	rjmp	.+56     	; 0x2abc <protocol_exec_rt_system+0x106>
          report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR);
    2a84:	86 e0       	ldi	r24, 0x06	; 6
    2a86:	0e 94 fa 34 	call	0x69f4	; 0x69f4 <report_feedback_message>
          // If jogging, block safety door methods until jog cancel is complete. Just flag that it happened.
          if (!(sys.suspend & SUSPEND_JOG_CANCEL)) {
    2a8a:	80 91 18 0c 	lds	r24, 0x0C18	; 0x800c18 <sys+0x2>
    2a8e:	88 23       	and	r24, r24
    2a90:	84 f0       	brlt	.+32     	; 0x2ab2 <protocol_exec_rt_system+0xfc>
            // Check if the safety re-opened during a restore parking motion only. Ignore if
            // already retracting, parked or in sleep state.
            if (sys.state == STATE_SAFETY_DOOR) {
    2a92:	90 91 16 0c 	lds	r25, 0x0C16	; 0x800c16 <sys>
    2a96:	90 34       	cpi	r25, 0x40	; 64
    2a98:	39 f4       	brne	.+14     	; 0x2aa8 <protocol_exec_rt_system+0xf2>
              if (sys.suspend & SUSPEND_INITIATE_RESTORE) { // Actively restoring
    2a9a:	83 ff       	sbrs	r24, 3
    2a9c:	07 c0       	rjmp	.+14     	; 0x2aac <protocol_exec_rt_system+0xf6>
                    sys.step_control = (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION);
                    sys.suspend &= ~(SUSPEND_HOLD_COMPLETE);
                  } // else NO_MOTION is active.
                #endif
                sys.suspend &= ~(SUSPEND_RETRACT_COMPLETE | SUSPEND_INITIATE_RESTORE | SUSPEND_RESTORE_COMPLETE);
                sys.suspend |= SUSPEND_RESTART_RETRACT;
    2a9e:	83 7e       	andi	r24, 0xE3	; 227
    2aa0:	82 60       	ori	r24, 0x02	; 2
    2aa2:	80 93 18 0c 	sts	0x0C18, r24	; 0x800c18 <sys+0x2>
    2aa6:	02 c0       	rjmp	.+4      	; 0x2aac <protocol_exec_rt_system+0xf6>
              }
            }
            if (sys.state != STATE_SLEEP) { sys.state = STATE_SAFETY_DOOR; }
    2aa8:	90 38       	cpi	r25, 0x80	; 128
    2aaa:	19 f0       	breq	.+6      	; 0x2ab2 <protocol_exec_rt_system+0xfc>
    2aac:	80 e4       	ldi	r24, 0x40	; 64
    2aae:	80 93 16 0c 	sts	0x0C16, r24	; 0x800c16 <sys>
          }
          // NOTE: This flag doesn't change when the door closes, unlike sys.state. Ensures any parking motions
          // are executed if the door switch closes and the state returns to HOLD.
          sys.suspend |= SUSPEND_SAFETY_DOOR_AJAR;
    2ab2:	e6 e1       	ldi	r30, 0x16	; 22
    2ab4:	fc e0       	ldi	r31, 0x0C	; 12
    2ab6:	82 81       	ldd	r24, Z+2	; 0x02
    2ab8:	80 62       	ori	r24, 0x20	; 32
    2aba:	82 83       	std	Z+2, r24	; 0x02
        }
        
      }

      if (rt_exec & EXEC_SLEEP) {
    2abc:	cc 23       	and	r28, r28
    2abe:	64 f4       	brge	.+24     	; 0x2ad8 <protocol_exec_rt_system+0x122>
        if (sys.state == STATE_ALARM) { sys.suspend |= (SUSPEND_RETRACT_COMPLETE|SUSPEND_HOLD_COMPLETE); }
    2ac0:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
    2ac4:	81 30       	cpi	r24, 0x01	; 1
    2ac6:	29 f4       	brne	.+10     	; 0x2ad2 <protocol_exec_rt_system+0x11c>
    2ac8:	e6 e1       	ldi	r30, 0x16	; 22
    2aca:	fc e0       	ldi	r31, 0x0C	; 12
    2acc:	82 81       	ldd	r24, Z+2	; 0x02
    2ace:	85 60       	ori	r24, 0x05	; 5
    2ad0:	82 83       	std	Z+2, r24	; 0x02
        sys.state = STATE_SLEEP; 
    2ad2:	80 e8       	ldi	r24, 0x80	; 128
    2ad4:	80 93 16 0c 	sts	0x0C16, r24	; 0x800c16 <sys>
      }

      system_clear_exec_state_flag((EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR | EXEC_SLEEP));
    2ad8:	88 ee       	ldi	r24, 0xE8	; 232
    2ada:	0e 94 53 3d 	call	0x7aa6	; 0x7aa6 <system_clear_exec_state_flag>
    }

    // Execute a cycle start by starting the stepper interrupt to begin executing the blocks in queue.
    if (rt_exec & EXEC_CYCLE_START) {
    2ade:	c1 ff       	sbrs	r28, 1
    2ae0:	41 c0       	rjmp	.+130    	; 0x2b64 <protocol_exec_rt_system+0x1ae>
      // Block if called at same time as the hold commands: feed hold, motion cancel, and safety door.
      // Ensures auto-cycle-start doesn't resume a hold without an explicit user-input.
      if (!(rt_exec & (EXEC_FEED_HOLD | EXEC_MOTION_CANCEL | EXEC_SAFETY_DOOR))) {
    2ae2:	8c 2f       	mov	r24, r28
    2ae4:	88 76       	andi	r24, 0x68	; 104
    2ae6:	d9 f5       	brne	.+118    	; 0x2b5e <protocol_exec_rt_system+0x1a8>
        // Resume door state when parking motion has retracted and door has been closed.
        if ((sys.state == STATE_SAFETY_DOOR) && !(sys.suspend & SUSPEND_SAFETY_DOOR_AJAR)) {
    2ae8:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
    2aec:	80 34       	cpi	r24, 0x40	; 64
    2aee:	79 f4       	brne	.+30     	; 0x2b0e <protocol_exec_rt_system+0x158>
    2af0:	80 91 18 0c 	lds	r24, 0x0C18	; 0x800c18 <sys+0x2>
    2af4:	85 fd       	sbrc	r24, 5
    2af6:	33 c0       	rjmp	.+102    	; 0x2b5e <protocol_exec_rt_system+0x1a8>
          if (sys.suspend & SUSPEND_RESTORE_COMPLETE) {
    2af8:	84 ff       	sbrs	r24, 4
    2afa:	03 c0       	rjmp	.+6      	; 0x2b02 <protocol_exec_rt_system+0x14c>
            sys.state = STATE_IDLE; // Set to IDLE to immediately resume the cycle.
    2afc:	10 92 16 0c 	sts	0x0C16, r1	; 0x800c16 <sys>
    2b00:	18 c0       	rjmp	.+48     	; 0x2b32 <protocol_exec_rt_system+0x17c>
          } else if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
    2b02:	82 ff       	sbrs	r24, 2
    2b04:	2c c0       	rjmp	.+88     	; 0x2b5e <protocol_exec_rt_system+0x1a8>
            // Flag to re-energize powered components and restore original position, if disabled by SAFETY_DOOR.
            // NOTE: For a safety door to resume, the switch must be closed, as indicated by HOLD state, and
            // the retraction execution is complete, which implies the initial feed hold is not active. To
            // restore normal operation, the restore procedures must be initiated by the following flag. Once,
            // they are complete, it will call CYCLE_START automatically to resume and exit the suspend.
            sys.suspend |= SUSPEND_INITIATE_RESTORE;
    2b06:	88 60       	ori	r24, 0x08	; 8
    2b08:	80 93 18 0c 	sts	0x0C18, r24	; 0x800c18 <sys+0x2>
    2b0c:	28 c0       	rjmp	.+80     	; 0x2b5e <protocol_exec_rt_system+0x1a8>
          }
        }
        // Cycle start only when IDLE or when a hold is complete and ready to resume.
        if ((sys.state == STATE_IDLE) || ((sys.state & STATE_HOLD) && (sys.suspend & SUSPEND_HOLD_COMPLETE))) {
    2b0e:	88 23       	and	r24, r24
    2b10:	81 f0       	breq	.+32     	; 0x2b32 <protocol_exec_rt_system+0x17c>
    2b12:	84 ff       	sbrs	r24, 4
    2b14:	24 c0       	rjmp	.+72     	; 0x2b5e <protocol_exec_rt_system+0x1a8>
    2b16:	90 91 18 0c 	lds	r25, 0x0C18	; 0x800c18 <sys+0x2>
    2b1a:	90 ff       	sbrs	r25, 0
    2b1c:	20 c0       	rjmp	.+64     	; 0x2b5e <protocol_exec_rt_system+0x1a8>
          if (sys.state == STATE_HOLD && sys.spindle_stop_ovr) {
    2b1e:	80 31       	cpi	r24, 0x10	; 16
    2b20:	41 f4       	brne	.+16     	; 0x2b32 <protocol_exec_rt_system+0x17c>
    2b22:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0xa>
    2b26:	88 23       	and	r24, r24
    2b28:	21 f0       	breq	.+8      	; 0x2b32 <protocol_exec_rt_system+0x17c>
            sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE_CYCLE; // Set to restore in suspend routine and cycle start after.
    2b2a:	88 60       	ori	r24, 0x08	; 8
    2b2c:	80 93 20 0c 	sts	0x0C20, r24	; 0x800c20 <sys+0xa>
    2b30:	16 c0       	rjmp	.+44     	; 0x2b5e <protocol_exec_rt_system+0x1a8>
          } else {
            // Start cycle only if queued motions exist in planner buffer and the motion is not canceled.
            sys.step_control = STEP_CONTROL_NORMAL_OP; // Restore step control to normal operation
    2b32:	10 92 1a 0c 	sts	0x0C1A, r1	; 0x800c1a <sys+0x4>
            if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
    2b36:	0e 94 ed 28 	call	0x51da	; 0x51da <plan_get_current_block>
    2b3a:	89 2b       	or	r24, r25
    2b3c:	61 f0       	breq	.+24     	; 0x2b56 <protocol_exec_rt_system+0x1a0>
    2b3e:	80 91 18 0c 	lds	r24, 0x0C18	; 0x800c18 <sys+0x2>
    2b42:	86 fd       	sbrc	r24, 6
    2b44:	08 c0       	rjmp	.+16     	; 0x2b56 <protocol_exec_rt_system+0x1a0>
              sys.suspend = SUSPEND_DISABLE; // Break suspend state.
    2b46:	e6 e1       	ldi	r30, 0x16	; 22
    2b48:	fc e0       	ldi	r31, 0x0C	; 12
    2b4a:	12 82       	std	Z+2, r1	; 0x02
              sys.state = STATE_CYCLE;
    2b4c:	88 e0       	ldi	r24, 0x08	; 8
              st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
    2b4e:	80 83       	st	Z, r24
              st_wake_up();
    2b50:	0b d6       	rcall	.+3094   	; 0x3768 <st_prep_buffer>
    2b52:	fd d2       	rcall	.+1530   	; 0x314e <st_wake_up>
    2b54:	04 c0       	rjmp	.+8      	; 0x2b5e <protocol_exec_rt_system+0x1a8>
            } else { // Otherwise, do nothing. Set and resume IDLE state.
              sys.suspend = SUSPEND_DISABLE; // Break suspend state.
    2b56:	e6 e1       	ldi	r30, 0x16	; 22
    2b58:	fc e0       	ldi	r31, 0x0C	; 12
    2b5a:	12 82       	std	Z+2, r1	; 0x02
              sys.state = STATE_IDLE;
    2b5c:	10 82       	st	Z, r1
            }
          }
        }
      }
      system_clear_exec_state_flag(EXEC_CYCLE_START);
    2b5e:	82 e0       	ldi	r24, 0x02	; 2
    2b60:	0e 94 53 3d 	call	0x7aa6	; 0x7aa6 <system_clear_exec_state_flag>
    }

    if (rt_exec & EXEC_CYCLE_STOP) {
    2b64:	c2 ff       	sbrs	r28, 2
    2b66:	3b c0       	rjmp	.+118    	; 0x2bde <protocol_exec_rt_system+0x228>
      // Reinitializes the cycle plan and stepper system after a feed hold for a resume. Called by
      // realtime command execution in the main program, ensuring that the planner re-plans safely.
      // NOTE: Bresenham algorithm variables are still maintained through both the planner and stepper
      // cycle reinitializations. The stepper path should continue exactly as if nothing has happened.
      // NOTE: EXEC_CYCLE_STOP is set by the stepper subsystem when a cycle or feed hold completes.
      if ((sys.state & (STATE_HOLD|STATE_SAFETY_DOOR|STATE_SLEEP)) && !(sys.soft_limit) && !(sys.suspend & SUSPEND_JOG_CANCEL)) {
    2b68:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
    2b6c:	80 7d       	andi	r24, 0xD0	; 208
    2b6e:	b9 f0       	breq	.+46     	; 0x2b9e <protocol_exec_rt_system+0x1e8>
    2b70:	80 91 19 0c 	lds	r24, 0x0C19	; 0x800c19 <sys+0x3>
    2b74:	81 11       	cpse	r24, r1
    2b76:	13 c0       	rjmp	.+38     	; 0x2b9e <protocol_exec_rt_system+0x1e8>
    2b78:	80 91 18 0c 	lds	r24, 0x0C18	; 0x800c18 <sys+0x2>
    2b7c:	88 23       	and	r24, r24
    2b7e:	9c f0       	brlt	.+38     	; 0x2ba6 <protocol_exec_rt_system+0x1f0>
        // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until user
        // has issued a resume command or reset.
        plan_cycle_reinitialize();
    2b80:	0e 94 8d 2d 	call	0x5b1a	; 0x5b1a <plan_cycle_reinitialize>
        if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { sys.suspend |= SUSPEND_HOLD_COMPLETE; }
    2b84:	80 91 1a 0c 	lds	r24, 0x0C1A	; 0x800c1a <sys+0x4>
    2b88:	81 ff       	sbrs	r24, 1
    2b8a:	05 c0       	rjmp	.+10     	; 0x2b96 <protocol_exec_rt_system+0x1e0>
    2b8c:	e6 e1       	ldi	r30, 0x16	; 22
    2b8e:	fc e0       	ldi	r31, 0x0C	; 12
    2b90:	92 81       	ldd	r25, Z+2	; 0x02
    2b92:	91 60       	ori	r25, 0x01	; 1
    2b94:	92 83       	std	Z+2, r25	; 0x02
        bit_false(sys.step_control,(STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION));
    2b96:	89 7f       	andi	r24, 0xF9	; 249
    2b98:	80 93 1a 0c 	sts	0x0C1A, r24	; 0x800c1a <sys+0x4>
    2b9c:	1d c0       	rjmp	.+58     	; 0x2bd8 <protocol_exec_rt_system+0x222>
      } else {
        // Motion complete. Includes CYCLE/JOG/HOMING states and jog cancel/motion cancel/soft limit events.
        // NOTE: Motion and jog cancel both immediately return to idle after the hold completes.
        if (sys.suspend & SUSPEND_JOG_CANCEL) {   // For jog cancel, flush buffers and sync positions.
    2b9e:	80 91 18 0c 	lds	r24, 0x0C18	; 0x800c18 <sys+0x2>
    2ba2:	88 23       	and	r24, r24
    2ba4:	4c f4       	brge	.+18     	; 0x2bb8 <protocol_exec_rt_system+0x202>
          sys.step_control = STEP_CONTROL_NORMAL_OP;
    2ba6:	10 92 1a 0c 	sts	0x0C1A, r1	; 0x800c1a <sys+0x4>
          plan_reset();
    2baa:	0e 94 c7 28 	call	0x518e	; 0x518e <plan_reset>
          st_reset();
    2bae:	69 d5       	rcall	.+2770   	; 0x3682 <st_reset>
          gc_sync_position();
    2bb0:	0e 94 01 07 	call	0xe02	; 0xe02 <gc_sync_position>
          plan_sync_position();
    2bb4:	0e 94 6f 2d 	call	0x5ade	; 0x5ade <plan_sync_position>
        }
        if (sys.suspend & SUSPEND_SAFETY_DOOR_AJAR) { // Only occurs when safety door opens during jog.
    2bb8:	80 91 18 0c 	lds	r24, 0x0C18	; 0x800c18 <sys+0x2>
    2bbc:	85 ff       	sbrs	r24, 5
    2bbe:	08 c0       	rjmp	.+16     	; 0x2bd0 <protocol_exec_rt_system+0x21a>
          sys.suspend &= ~(SUSPEND_JOG_CANCEL);
          sys.suspend |= SUSPEND_HOLD_COMPLETE;
    2bc0:	e6 e1       	ldi	r30, 0x16	; 22
    2bc2:	fc e0       	ldi	r31, 0x0C	; 12
    2bc4:	8f 77       	andi	r24, 0x7F	; 127
    2bc6:	81 60       	ori	r24, 0x01	; 1
    2bc8:	82 83       	std	Z+2, r24	; 0x02
          sys.state = STATE_SAFETY_DOOR;
    2bca:	80 e4       	ldi	r24, 0x40	; 64
    2bcc:	80 83       	st	Z, r24
    2bce:	04 c0       	rjmp	.+8      	; 0x2bd8 <protocol_exec_rt_system+0x222>
        } else {
          sys.suspend = SUSPEND_DISABLE;
    2bd0:	e6 e1       	ldi	r30, 0x16	; 22
    2bd2:	fc e0       	ldi	r31, 0x0C	; 12
    2bd4:	12 82       	std	Z+2, r1	; 0x02
          sys.state = STATE_IDLE;
    2bd6:	10 82       	st	Z, r1
        }
      }
      system_clear_exec_state_flag(EXEC_CYCLE_STOP);
    2bd8:	84 e0       	ldi	r24, 0x04	; 4
    2bda:	0e 94 53 3d 	call	0x7aa6	; 0x7aa6 <system_clear_exec_state_flag>
    }
  }

  // Execute overrides.
  rt_exec = sys_rt_exec_motion_override; // Copy volatile sys_rt_exec_motion_override
    2bde:	c0 91 15 0c 	lds	r28, 0x0C15	; 0x800c15 <sys_rt_exec_motion_override>
  if (rt_exec) {
    2be2:	cc 23       	and	r28, r28
    2be4:	81 f1       	breq	.+96     	; 0x2c46 <protocol_exec_rt_system+0x290>
    system_clear_exec_motion_overrides(); // Clear all motion override flags.
    2be6:	0e 94 7b 3d 	call	0x7af6	; 0x7af6 <system_clear_exec_motion_overrides>

    uint8_t new_f_override =  sys.f_override;
    2bea:	20 91 1d 0c 	lds	r18, 0x0C1D	; 0x800c1d <sys+0x7>
    if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
    2bee:	c0 ff       	sbrs	r28, 0
    2bf0:	02 c0       	rjmp	.+4      	; 0x2bf6 <protocol_exec_rt_system+0x240>
    2bf2:	84 e6       	ldi	r24, 0x64	; 100
    2bf4:	01 c0       	rjmp	.+2      	; 0x2bf8 <protocol_exec_rt_system+0x242>
  // Execute overrides.
  rt_exec = sys_rt_exec_motion_override; // Copy volatile sys_rt_exec_motion_override
  if (rt_exec) {
    system_clear_exec_motion_overrides(); // Clear all motion override flags.

    uint8_t new_f_override =  sys.f_override;
    2bf6:	82 2f       	mov	r24, r18
    if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
    if (rt_exec & EXEC_FEED_OVR_COARSE_PLUS) { new_f_override += FEED_OVERRIDE_COARSE_INCREMENT; }
    2bf8:	c1 fd       	sbrc	r28, 1
    2bfa:	86 5f       	subi	r24, 0xF6	; 246
    if (rt_exec & EXEC_FEED_OVR_COARSE_MINUS) { new_f_override -= FEED_OVERRIDE_COARSE_INCREMENT; }
    2bfc:	c2 fd       	sbrc	r28, 2
    2bfe:	8a 50       	subi	r24, 0x0A	; 10
    if (rt_exec & EXEC_FEED_OVR_FINE_PLUS) { new_f_override += FEED_OVERRIDE_FINE_INCREMENT; }
    2c00:	c3 fd       	sbrc	r28, 3
    2c02:	8f 5f       	subi	r24, 0xFF	; 255
    if (rt_exec & EXEC_FEED_OVR_FINE_MINUS) { new_f_override -= FEED_OVERRIDE_FINE_INCREMENT; }
    2c04:	c4 fd       	sbrc	r28, 4
    2c06:	81 50       	subi	r24, 0x01	; 1
    new_f_override = min(new_f_override,MAX_FEED_RATE_OVERRIDE);
    2c08:	89 3c       	cpi	r24, 0xC9	; 201
    2c0a:	08 f0       	brcs	.+2      	; 0x2c0e <protocol_exec_rt_system+0x258>
    2c0c:	88 ec       	ldi	r24, 0xC8	; 200
    new_f_override = max(new_f_override,MIN_FEED_RATE_OVERRIDE);
    2c0e:	8a 30       	cpi	r24, 0x0A	; 10
    2c10:	08 f4       	brcc	.+2      	; 0x2c14 <protocol_exec_rt_system+0x25e>
    2c12:	8a e0       	ldi	r24, 0x0A	; 10

    uint8_t new_r_override = sys.r_override;
    2c14:	30 91 1e 0c 	lds	r19, 0x0C1E	; 0x800c1e <sys+0x8>
    if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
    2c18:	c5 ff       	sbrs	r28, 5
    2c1a:	02 c0       	rjmp	.+4      	; 0x2c20 <protocol_exec_rt_system+0x26a>
    2c1c:	94 e6       	ldi	r25, 0x64	; 100
    2c1e:	01 c0       	rjmp	.+2      	; 0x2c22 <protocol_exec_rt_system+0x26c>
    if (rt_exec & EXEC_FEED_OVR_FINE_PLUS) { new_f_override += FEED_OVERRIDE_FINE_INCREMENT; }
    if (rt_exec & EXEC_FEED_OVR_FINE_MINUS) { new_f_override -= FEED_OVERRIDE_FINE_INCREMENT; }
    new_f_override = min(new_f_override,MAX_FEED_RATE_OVERRIDE);
    new_f_override = max(new_f_override,MIN_FEED_RATE_OVERRIDE);

    uint8_t new_r_override = sys.r_override;
    2c20:	93 2f       	mov	r25, r19
    if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
    if (rt_exec & EXEC_RAPID_OVR_MEDIUM) { new_r_override = RAPID_OVERRIDE_MEDIUM; }
    2c22:	c6 fd       	sbrc	r28, 6
    2c24:	92 e3       	ldi	r25, 0x32	; 50
    if (rt_exec & EXEC_RAPID_OVR_LOW) { new_r_override = RAPID_OVERRIDE_LOW; }
    2c26:	cc 23       	and	r28, r28
    2c28:	0c f4       	brge	.+2      	; 0x2c2c <protocol_exec_rt_system+0x276>
    2c2a:	99 e1       	ldi	r25, 0x19	; 25

    if ((new_f_override != sys.f_override) || (new_r_override != sys.r_override)) {
    2c2c:	28 13       	cpse	r18, r24
    2c2e:	02 c0       	rjmp	.+4      	; 0x2c34 <protocol_exec_rt_system+0x27e>
    2c30:	93 17       	cp	r25, r19
    2c32:	49 f0       	breq	.+18     	; 0x2c46 <protocol_exec_rt_system+0x290>
      sys.f_override = new_f_override;
    2c34:	e6 e1       	ldi	r30, 0x16	; 22
    2c36:	fc e0       	ldi	r31, 0x0C	; 12
    2c38:	87 83       	std	Z+7, r24	; 0x07
      sys.r_override = new_r_override;
    2c3a:	90 87       	std	Z+8, r25	; 0x08
      sys.report_ovr_counter = 0; // Set to report change immediately
    2c3c:	13 86       	std	Z+11, r1	; 0x0b
      plan_update_velocity_profile_parameters();
    2c3e:	0e 94 9b 29 	call	0x5336	; 0x5336 <plan_update_velocity_profile_parameters>
      plan_cycle_reinitialize();
    2c42:	0e 94 8d 2d 	call	0x5b1a	; 0x5b1a <plan_cycle_reinitialize>
    }
  }

  rt_exec = sys_rt_exec_accessory_override;
    2c46:	c0 91 28 0c 	lds	r28, 0x0C28	; 0x800c28 <sys_rt_exec_accessory_override>
  if (rt_exec) {
    2c4a:	cc 23       	and	r28, r28
    2c4c:	09 f4       	brne	.+2      	; 0x2c50 <protocol_exec_rt_system+0x29a>
    2c4e:	60 c0       	rjmp	.+192    	; 0x2d10 <protocol_exec_rt_system+0x35a>
    system_clear_exec_accessory_overrides(); // Clear all accessory override flags.
    2c50:	0e 94 81 3d 	call	0x7b02	; 0x7b02 <system_clear_exec_accessory_overrides>

    // NOTE: Unlike motion overrides, spindle overrides do not require a planner reinitialization.
    uint8_t last_s_override =  sys.spindle_speed_ovr;
    2c54:	90 91 1f 0c 	lds	r25, 0x0C1F	; 0x800c1f <sys+0x9>
    if (rt_exec & EXEC_SPINDLE_OVR_RESET) { last_s_override = DEFAULT_SPINDLE_SPEED_OVERRIDE; }
    2c58:	c0 ff       	sbrs	r28, 0
    2c5a:	02 c0       	rjmp	.+4      	; 0x2c60 <protocol_exec_rt_system+0x2aa>
    2c5c:	84 e6       	ldi	r24, 0x64	; 100
    2c5e:	01 c0       	rjmp	.+2      	; 0x2c62 <protocol_exec_rt_system+0x2ac>
  rt_exec = sys_rt_exec_accessory_override;
  if (rt_exec) {
    system_clear_exec_accessory_overrides(); // Clear all accessory override flags.

    // NOTE: Unlike motion overrides, spindle overrides do not require a planner reinitialization.
    uint8_t last_s_override =  sys.spindle_speed_ovr;
    2c60:	89 2f       	mov	r24, r25
    if (rt_exec & EXEC_SPINDLE_OVR_RESET) { last_s_override = DEFAULT_SPINDLE_SPEED_OVERRIDE; }
    if (rt_exec & EXEC_SPINDLE_OVR_COARSE_PLUS) { last_s_override += SPINDLE_OVERRIDE_COARSE_INCREMENT; }
    2c62:	c1 fd       	sbrc	r28, 1
    2c64:	86 5f       	subi	r24, 0xF6	; 246
    if (rt_exec & EXEC_SPINDLE_OVR_COARSE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_COARSE_INCREMENT; }
    2c66:	c2 fd       	sbrc	r28, 2
    2c68:	8a 50       	subi	r24, 0x0A	; 10
    if (rt_exec & EXEC_SPINDLE_OVR_FINE_PLUS) { last_s_override += SPINDLE_OVERRIDE_FINE_INCREMENT; }
    2c6a:	c3 fd       	sbrc	r28, 3
    2c6c:	8f 5f       	subi	r24, 0xFF	; 255
    if (rt_exec & EXEC_SPINDLE_OVR_FINE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_FINE_INCREMENT; }
    2c6e:	c4 fd       	sbrc	r28, 4
    2c70:	81 50       	subi	r24, 0x01	; 1
    last_s_override = min(last_s_override,MAX_SPINDLE_SPEED_OVERRIDE);
    2c72:	89 3c       	cpi	r24, 0xC9	; 201
    2c74:	08 f0       	brcs	.+2      	; 0x2c78 <protocol_exec_rt_system+0x2c2>
    2c76:	88 ec       	ldi	r24, 0xC8	; 200
    last_s_override = max(last_s_override,MIN_SPINDLE_SPEED_OVERRIDE);
    2c78:	8a 30       	cpi	r24, 0x0A	; 10
    2c7a:	08 f4       	brcc	.+2      	; 0x2c7e <protocol_exec_rt_system+0x2c8>
    2c7c:	8a e0       	ldi	r24, 0x0A	; 10

    if (last_s_override != sys.spindle_speed_ovr) {
    2c7e:	98 17       	cp	r25, r24
    2c80:	b1 f0       	breq	.+44     	; 0x2cae <protocol_exec_rt_system+0x2f8>
      sys.spindle_speed_ovr = last_s_override;
    2c82:	e6 e1       	ldi	r30, 0x16	; 22
    2c84:	fc e0       	ldi	r31, 0x0C	; 12
    2c86:	81 87       	std	Z+9, r24	; 0x09
      // NOTE: Spindle speed overrides during HOLD state are taken care of by suspend function.
      if (sys.state == STATE_IDLE) { spindle_set_state(gc_state.modal.spindle, gc_state.spindle_speed); }
    2c88:	80 81       	ld	r24, Z
    2c8a:	81 11       	cpse	r24, r1
    2c8c:	09 c0       	rjmp	.+18     	; 0x2ca0 <protocol_exec_rt_system+0x2ea>
    2c8e:	e6 e4       	ldi	r30, 0x46	; 70
    2c90:	fc e0       	ldi	r31, 0x0C	; 12
    2c92:	43 85       	ldd	r20, Z+11	; 0x0b
    2c94:	54 85       	ldd	r21, Z+12	; 0x0c
    2c96:	65 85       	ldd	r22, Z+13	; 0x0d
    2c98:	76 85       	ldd	r23, Z+14	; 0x0e
    2c9a:	81 85       	ldd	r24, Z+9	; 0x09
    2c9c:	ca dc       	rcall	.-1644   	; 0x2632 <spindle_set_state>
    2c9e:	05 c0       	rjmp	.+10     	; 0x2caa <protocol_exec_rt_system+0x2f4>
			else { bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM); }
    2ca0:	e6 e1       	ldi	r30, 0x16	; 22
    2ca2:	fc e0       	ldi	r31, 0x0C	; 12
    2ca4:	84 81       	ldd	r24, Z+4	; 0x04
    2ca6:	88 60       	ori	r24, 0x08	; 8
    2ca8:	84 83       	std	Z+4, r24	; 0x04
      sys.report_ovr_counter = 0; // Set to report change immediately
    2caa:	10 92 21 0c 	sts	0x0C21, r1	; 0x800c21 <sys+0xb>
    }

    if (rt_exec & EXEC_SPINDLE_OVR_STOP) {
    2cae:	c5 ff       	sbrs	r28, 5
    2cb0:	12 c0       	rjmp	.+36     	; 0x2cd6 <protocol_exec_rt_system+0x320>
      // Spindle stop override allowed only while in HOLD state.
      // NOTE: Report counters are set in spindle_set_state() when spindle stop is executed.
      if (sys.state == STATE_HOLD) {
    2cb2:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
    2cb6:	80 31       	cpi	r24, 0x10	; 16
    2cb8:	71 f4       	brne	.+28     	; 0x2cd6 <protocol_exec_rt_system+0x320>
        if (!(sys.spindle_stop_ovr)) { sys.spindle_stop_ovr = SPINDLE_STOP_OVR_INITIATE; }
    2cba:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0xa>
    2cbe:	81 11       	cpse	r24, r1
    2cc0:	04 c0       	rjmp	.+8      	; 0x2cca <protocol_exec_rt_system+0x314>
    2cc2:	82 e0       	ldi	r24, 0x02	; 2
    2cc4:	80 93 20 0c 	sts	0x0C20, r24	; 0x800c20 <sys+0xa>
    2cc8:	5c c0       	rjmp	.+184    	; 0x2d82 <protocol_exec_rt_system+0x3cc>
        else if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_ENABLED) { sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE; }
    2cca:	80 ff       	sbrs	r24, 0
    2ccc:	5a c0       	rjmp	.+180    	; 0x2d82 <protocol_exec_rt_system+0x3cc>
    2cce:	84 60       	ori	r24, 0x04	; 4
    2cd0:	80 93 20 0c 	sts	0x0C20, r24	; 0x800c20 <sys+0xa>
    2cd4:	56 c0       	rjmp	.+172    	; 0x2d82 <protocol_exec_rt_system+0x3cc>
    }

    // NOTE: Since coolant state always performs a planner sync whenever it changes, the current
    // run state can be determined by checking the parser state.
    // NOTE: Coolant overrides only operate during IDLE, CYCLE, HOLD, and JOG states. Ignored otherwise.																										
    if (rt_exec & (EXEC_COOLANT_FLOOD_OVR_TOGGLE | EXEC_COOLANT_MIST_OVR_TOGGLE)) {
    2cd6:	8c 2f       	mov	r24, r28
    2cd8:	80 7c       	andi	r24, 0xC0	; 192
    2cda:	d1 f0       	breq	.+52     	; 0x2d10 <protocol_exec_rt_system+0x35a>
      if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_JOG))) {
    2cdc:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
    2ce0:	88 23       	and	r24, r24
    2ce2:	11 f0       	breq	.+4      	; 0x2ce8 <protocol_exec_rt_system+0x332>
    2ce4:	88 73       	andi	r24, 0x38	; 56
    2ce6:	a1 f0       	breq	.+40     	; 0x2d10 <protocol_exec_rt_system+0x35a>
        uint8_t coolant_state = gc_state.modal.coolant;
    2ce8:	d0 91 4e 0c 	lds	r29, 0x0C4E	; 0x800c4e <gc_state+0x8>
        if (rt_exec & EXEC_COOLANT_MIST_OVR_TOGGLE) {
    2cec:	cc 23       	and	r28, r28
    2cee:	2c f4       	brge	.+10     	; 0x2cfa <protocol_exec_rt_system+0x344>
          if (coolant_state & COOLANT_MIST_ENABLE) { bit_false(coolant_state,COOLANT_MIST_ENABLE); }
    2cf0:	dd 23       	and	r29, r29
    2cf2:	14 f4       	brge	.+4      	; 0x2cf8 <protocol_exec_rt_system+0x342>
    2cf4:	df 77       	andi	r29, 0x7F	; 127
    2cf6:	01 c0       	rjmp	.+2      	; 0x2cfa <protocol_exec_rt_system+0x344>
          else { coolant_state |= COOLANT_MIST_ENABLE; }
    2cf8:	d0 68       	ori	r29, 0x80	; 128
        }
        if (rt_exec & EXEC_COOLANT_FLOOD_OVR_TOGGLE) {
    2cfa:	c6 ff       	sbrs	r28, 6
    2cfc:	05 c0       	rjmp	.+10     	; 0x2d08 <protocol_exec_rt_system+0x352>
          if (coolant_state & COOLANT_FLOOD_ENABLE) { bit_false(coolant_state,COOLANT_FLOOD_ENABLE); }
    2cfe:	d6 ff       	sbrs	r29, 6
    2d00:	02 c0       	rjmp	.+4      	; 0x2d06 <protocol_exec_rt_system+0x350>
    2d02:	df 7b       	andi	r29, 0xBF	; 191
          else { coolant_state |= COOLANT_FLOOD_ENABLE; }
    2d04:	01 c0       	rjmp	.+2      	; 0x2d08 <protocol_exec_rt_system+0x352>
        }
        coolant_set_state(coolant_state); // Report counter set in coolant_set_state().
    2d06:	d0 64       	ori	r29, 0x40	; 64
    2d08:	8d 2f       	mov	r24, r29
    2d0a:	f3 dc       	rcall	.-1562   	; 0x26f2 <coolant_set_state>
        gc_state.modal.coolant = coolant_state;
    2d0c:	d0 93 4e 0c 	sts	0x0C4E, r29	; 0x800c4e <gc_state+0x8>
      }
    }
  }
  #ifdef LATHE		
  //processing spindle pulse and spindle synchronization pulse
   rt_exec = sys_sync_state;
    2d10:	80 91 10 0c 	lds	r24, 0x0C10	; 0x800c10 <sys_sync_state>
   if (bit_istrue(rt_exec,EXEC_SPINDLE_SYNC)){
    2d14:	81 ff       	sbrs	r24, 1
    2d16:	19 c0       	rjmp	.+50     	; 0x2d4a <protocol_exec_rt_system+0x394>
	   sys_synchronization_pulse_count++;
    2d18:	40 91 11 0c 	lds	r20, 0x0C11	; 0x800c11 <sys_synchronization_pulse_count>
    2d1c:	50 91 12 0c 	lds	r21, 0x0C12	; 0x800c12 <sys_synchronization_pulse_count+0x1>
    2d20:	60 91 13 0c 	lds	r22, 0x0C13	; 0x800c13 <sys_synchronization_pulse_count+0x2>
    2d24:	70 91 14 0c 	lds	r23, 0x0C14	; 0x800c14 <sys_synchronization_pulse_count+0x3>
    2d28:	4f 5f       	subi	r20, 0xFF	; 255
    2d2a:	5f 4f       	sbci	r21, 0xFF	; 255
    2d2c:	6f 4f       	sbci	r22, 0xFF	; 255
    2d2e:	7f 4f       	sbci	r23, 0xFF	; 255
    2d30:	40 93 11 0c 	sts	0x0C11, r20	; 0x800c11 <sys_synchronization_pulse_count>
    2d34:	50 93 12 0c 	sts	0x0C12, r21	; 0x800c12 <sys_synchronization_pulse_count+0x1>
    2d38:	60 93 13 0c 	sts	0x0C13, r22	; 0x800c13 <sys_synchronization_pulse_count+0x2>
    2d3c:	70 93 14 0c 	sts	0x0C14, r23	; 0x800c14 <sys_synchronization_pulse_count+0x3>
	   bit_false(sys_sync_state,EXEC_SPINDLE_SYNC);
    2d40:	90 91 10 0c 	lds	r25, 0x0C10	; 0x800c10 <sys_sync_state>
    2d44:	9d 7f       	andi	r25, 0xFD	; 253
    2d46:	90 93 10 0c 	sts	0x0C10, r25	; 0x800c10 <sys_sync_state>
	   //report_synchronization_state();
   }
   if (bit_istrue(rt_exec,EXEC_SPINDLE_INDEX)){
    2d4a:	80 ff       	sbrs	r24, 0
    2d4c:	0c c0       	rjmp	.+24     	; 0x2d66 <protocol_exec_rt_system+0x3b0>
	   sys_index_pulse_count++;
    2d4e:	80 91 45 0c 	lds	r24, 0x0C45	; 0x800c45 <sys_index_pulse_count>
    2d52:	8f 5f       	subi	r24, 0xFF	; 255
    2d54:	80 93 45 0c 	sts	0x0C45, r24	; 0x800c45 <sys_index_pulse_count>
	   bit_false(sys_sync_state,EXEC_SPINDLE_INDEX);
    2d58:	80 91 10 0c 	lds	r24, 0x0C10	; 0x800c10 <sys_sync_state>
    2d5c:	8e 7f       	andi	r24, 0xFE	; 254
    2d5e:	80 93 10 0c 	sts	0x0C10, r24	; 0x800c10 <sys_sync_state>
	   report_synchronization_state();					//report on every index pulse
    2d62:	0e 94 e3 34 	call	0x69c6	; 0x69c6 <report_synchronization_state>
   }   
  #endif
  
  #ifdef DEBUG
    if (sys_rt_exec_debug) {
    2d66:	80 91 44 0c 	lds	r24, 0x0C44	; 0x800c44 <sys_rt_exec_debug>
    2d6a:	88 23       	and	r24, r24
    2d6c:	21 f0       	breq	.+8      	; 0x2d76 <protocol_exec_rt_system+0x3c0>
      report_realtime_debug();
    2d6e:	0e 94 b9 39 	call	0x7372	; 0x7372 <report_realtime_debug>
      sys_rt_exec_debug = 0;
    2d72:	10 92 44 0c 	sts	0x0C44, r1	; 0x800c44 <sys_rt_exec_debug>
    }
  #endif

  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_SAFETY_DOOR | STATE_HOMING | STATE_SLEEP| STATE_JOG)) {
    2d76:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
    2d7a:	8c 7f       	andi	r24, 0xFC	; 252
    st_prep_buffer();
    2d7c:	51 f0       	breq	.+20     	; 0x2d92 <protocol_exec_rt_system+0x3dc>
    2d7e:	f4 d4       	rcall	.+2536   	; 0x3768 <st_prep_buffer>
    2d80:	08 c0       	rjmp	.+16     	; 0x2d92 <protocol_exec_rt_system+0x3dc>
    }

    // NOTE: Since coolant state always performs a planner sync whenever it changes, the current
    // run state can be determined by checking the parser state.
    // NOTE: Coolant overrides only operate during IDLE, CYCLE, HOLD, and JOG states. Ignored otherwise.																										
    if (rt_exec & (EXEC_COOLANT_FLOOD_OVR_TOGGLE | EXEC_COOLANT_MIST_OVR_TOGGLE)) {
    2d82:	8c 2f       	mov	r24, r28
    2d84:	80 7c       	andi	r24, 0xC0	; 192
    2d86:	09 f0       	breq	.+2      	; 0x2d8a <protocol_exec_rt_system+0x3d4>
    2d88:	af cf       	rjmp	.-162    	; 0x2ce8 <protocol_exec_rt_system+0x332>
    2d8a:	c2 cf       	rjmp	.-124    	; 0x2d10 <protocol_exec_rt_system+0x35a>
          // will handle and clear multiple planner block motions.
          if (!(sys.state & STATE_JOG)) { sys.suspend |= SUSPEND_MOTION_CANCEL; } // NOTE: State is STATE_CYCLE.
        }

        // Execute a feed hold with deceleration, if required. Then, suspend system.
        if (rt_exec & EXEC_FEED_HOLD) {
    2d8c:	c3 fd       	sbrc	r28, 3
    2d8e:	75 ce       	rjmp	.-790    	; 0x2a7a <protocol_exec_rt_system+0xc4>
    2d90:	77 ce       	rjmp	.-786    	; 0x2a80 <protocol_exec_rt_system+0xca>
  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_SAFETY_DOOR | STATE_HOMING | STATE_SLEEP| STATE_JOG)) {
    st_prep_buffer();
  }

}
    2d92:	df 91       	pop	r29
    2d94:	cf 91       	pop	r28
    2d96:	08 95       	ret

00002d98 <protocol_execute_realtime>:
// also provides a controlled way to execute certain tasks without having two or more instances of
// the same task, such as the planner recalculating the buffer upon a feedhold or overrides.
// NOTE: The sys_rt_exec_state variable flags are set by any process, step or serial interrupts, pinouts,
// limit switches, or the main program.
void protocol_execute_realtime()
{
    2d98:	7f 92       	push	r7
    2d9a:	8f 92       	push	r8
    2d9c:	9f 92       	push	r9
    2d9e:	af 92       	push	r10
    2da0:	bf 92       	push	r11
    2da2:	cf 92       	push	r12
    2da4:	df 92       	push	r13
    2da6:	ef 92       	push	r14
    2da8:	ff 92       	push	r15
    2daa:	0f 93       	push	r16
    2dac:	1f 93       	push	r17
    2dae:	cf 93       	push	r28
    2db0:	df 93       	push	r29
  protocol_exec_rt_system();
    2db2:	01 de       	rcall	.-1022   	; 0x29b6 <protocol_exec_rt_system>
  if (sys.suspend) { protocol_exec_rt_suspend(); }
    2db4:	80 91 18 0c 	lds	r24, 0x0C18	; 0x800c18 <sys+0x2>
    2db8:	88 23       	and	r24, r24
    2dba:	09 f4       	brne	.+2      	; 0x2dbe <protocol_execute_realtime+0x26>
    2dbc:	f4 c0       	rjmp	.+488    	; 0x2fa6 <protocol_execute_realtime+0x20e>
    memset(pl_data,0,sizeof(plan_line_data_t));
    pl_data->condition = (PL_COND_FLAG_SYSTEM_MOTION|PL_COND_FLAG_NO_FEED_OVERRIDE);
    pl_data->line_number = PARKING_MOTION_LINE_NUMBER;
  #endif

  plan_block_t *block = plan_get_current_block();
    2dbe:	0e 94 ed 28 	call	0x51da	; 0x51da <plan_get_current_block>
    2dc2:	ec 01       	movw	r28, r24
  uint8_t restore_condition;
  float restore_spindle_speed;
  if (block == NULL) {
    2dc4:	89 2b       	or	r24, r25
    2dc6:	51 f4       	brne	.+20     	; 0x2ddc <protocol_execute_realtime+0x44>
    restore_condition = (gc_state.modal.spindle | gc_state.modal.coolant);
    2dc8:	e6 e4       	ldi	r30, 0x46	; 70
    2dca:	fc e0       	ldi	r31, 0x0C	; 12
    2dcc:	d1 84       	ldd	r13, Z+9	; 0x09
    2dce:	80 85       	ldd	r24, Z+8	; 0x08
    2dd0:	d8 2a       	or	r13, r24
    restore_spindle_speed = gc_state.spindle_speed;
    2dd2:	83 84       	ldd	r8, Z+11	; 0x0b
    2dd4:	94 84       	ldd	r9, Z+12	; 0x0c
    2dd6:	a5 84       	ldd	r10, Z+13	; 0x0d
    2dd8:	b6 84       	ldd	r11, Z+14	; 0x0e
    2dda:	0a c0       	rjmp	.+20     	; 0x2df0 <protocol_execute_realtime+0x58>
  } else {
    restore_condition = (block->condition & PL_COND_SPINDLE_MASK) | coolant_get_state();
    2ddc:	89 89       	ldd	r24, Y+17	; 0x11
    2dde:	18 2f       	mov	r17, r24
    2de0:	10 73       	andi	r17, 0x30	; 48
    2de2:	68 dc       	rcall	.-1840   	; 0x26b4 <coolant_get_state>
    2de4:	d8 2e       	mov	r13, r24
    2de6:	d1 2a       	or	r13, r17
    restore_spindle_speed = block->spindle_speed;
    2de8:	8a a8       	ldd	r8, Y+50	; 0x32
    2dea:	9b a8       	ldd	r9, Y+51	; 0x33
    2dec:	ac a8       	ldd	r10, Y+52	; 0x34
    2dee:	bd a8       	ldd	r11, Y+53	; 0x35
  }
  #ifdef DISABLE_LASER_DURING_HOLD
    if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) { 
    2df0:	80 91 05 0f 	lds	r24, 0x0F05	; 0x800f05 <settings+0x45>
    2df4:	81 ff       	sbrs	r24, 1
    2df6:	03 c0       	rjmp	.+6      	; 0x2dfe <protocol_execute_realtime+0x66>
      system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP);
    2df8:	80 e2       	ldi	r24, 0x20	; 32
    2dfa:	0e 94 72 3d 	call	0x7ae4	; 0x7ae4 <system_set_exec_accessory_override_flag>
    }
  #endif

  while (sys.suspend) {
    2dfe:	90 91 18 0c 	lds	r25, 0x0C18	; 0x800c18 <sys+0x2>
    2e02:	99 23       	and	r25, r25
    2e04:	09 f4       	brne	.+2      	; 0x2e08 <protocol_execute_realtime+0x70>
    2e06:	cf c0       	rjmp	.+414    	; 0x2fa6 <protocol_execute_realtime+0x20e>

    if (sys.abort) { return; }
    2e08:	80 91 17 0c 	lds	r24, 0x0C17	; 0x800c17 <sys+0x1>
    2e0c:	81 11       	cpse	r24, r1
    2e0e:	cb c0       	rjmp	.+406    	; 0x2fa6 <protocol_execute_realtime+0x20e>
    // Block until initial hold is complete and the machine has stopped motion.
    if (sys.suspend & SUSPEND_HOLD_COMPLETE) {

      // Parking manager. Handles de/re-energizing, switch state checks, and parking motions for 
      // the safety door and sleep states.
      if (sys.state & (STATE_SAFETY_DOOR | STATE_SLEEP)) {
    2e10:	c6 e1       	ldi	r28, 0x16	; 22
    2e12:	dc e0       	ldi	r29, 0x0C	; 12
          }
        } else {
          // Handles spindle state during hold. NOTE: Spindle speed overrides may be altered during hold state.
          // NOTE: STEP_CONTROL_UPDATE_SPINDLE_PWM is automatically reset upon resume in step generator.
          if (bit_istrue(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
            spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    2e14:	8d 2d       	mov	r24, r13
    2e16:	80 73       	andi	r24, 0x30	; 48
    2e18:	c8 2e       	mov	r12, r24
            } else {
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
            }
          // Handles restoring of spindle state
          } else if (sys.spindle_stop_ovr & (SPINDLE_STOP_OVR_RESTORE | SPINDLE_STOP_OVR_RESTORE_CYCLE)) {
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    2e1a:	06 e4       	ldi	r16, 0x46	; 70
    2e1c:	1c e0       	ldi	r17, 0x0C	; 12
              report_feedback_message(MESSAGE_SPINDLE_RESTORE);
              if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    2e1e:	0f 2e       	mov	r0, r31
    2e20:	f5 e0       	ldi	r31, 0x05	; 5
    2e22:	ef 2e       	mov	r14, r31
    2e24:	ff e0       	ldi	r31, 0x0F	; 15
    2e26:	ff 2e       	mov	r15, r31
    2e28:	f0 2d       	mov	r31, r0
        if (sys.spindle_stop_ovr) {
          // Handles beginning of spindle stop
          if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_INITIATE) {
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
              spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_ENABLED; // Set stop override state to enabled, if de-energized.
    2e2a:	77 24       	eor	r7, r7
    2e2c:	73 94       	inc	r7
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
                // NOTE: Laser mode will honor this delay. An exhaust system is often controlled by this pin.
                coolant_set_state((restore_condition & (PL_COND_FLAG_COOLANT_FLOOD | PL_COND_FLAG_COOLANT_MIST)));
    2e2e:	ed 2d       	mov	r30, r13
    2e30:	e0 7c       	andi	r30, 0xC0	; 192
    2e32:	de 2e       	mov	r13, r30
    2e34:	03 c0       	rjmp	.+6      	; 0x2e3c <protocol_execute_realtime+0xa4>
    }
  #endif

  while (sys.suspend) {

    if (sys.abort) { return; }
    2e36:	29 81       	ldd	r18, Y+1	; 0x01
    2e38:	21 11       	cpse	r18, r1
    2e3a:	b5 c0       	rjmp	.+362    	; 0x2fa6 <protocol_execute_realtime+0x20e>

    // Block until initial hold is complete and the machine has stopped motion.
    if (sys.suspend & SUSPEND_HOLD_COMPLETE) {
    2e3c:	90 ff       	sbrs	r25, 0
    2e3e:	a7 c0       	rjmp	.+334    	; 0x2f8e <protocol_execute_realtime+0x1f6>

      // Parking manager. Handles de/re-energizing, switch state checks, and parking motions for 
      // the safety door and sleep states.
      if (sys.state & (STATE_SAFETY_DOOR | STATE_SLEEP)) {
    2e40:	28 81       	ld	r18, Y
    2e42:	32 2f       	mov	r19, r18
    2e44:	30 7c       	andi	r19, 0xC0	; 192
    2e46:	09 f4       	brne	.+2      	; 0x2e4a <protocol_execute_realtime+0xb2>
    2e48:	69 c0       	rjmp	.+210    	; 0x2f1c <protocol_execute_realtime+0x184>
      
        // Handles retraction motions and de-energizing.
        if (bit_isfalse(sys.suspend,SUSPEND_RETRACT_COMPLETE)) {
    2e4a:	92 fd       	sbrc	r25, 2
    2e4c:	0d c0       	rjmp	.+26     	; 0x2e68 <protocol_execute_realtime+0xd0>

          // Ensure any prior spindle stop override is disabled at start of safety door routine.
          sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED;
    2e4e:	1a 86       	std	Y+10, r1	; 0x0a

          #ifndef PARKING_ENABLE

            spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
    2e50:	40 e0       	ldi	r20, 0x00	; 0
    2e52:	50 e0       	ldi	r21, 0x00	; 0
    2e54:	ba 01       	movw	r22, r20
    2e56:	80 e0       	ldi	r24, 0x00	; 0
            coolant_set_state(COOLANT_DISABLE);     // De-energize
    2e58:	ec db       	rcall	.-2088   	; 0x2632 <spindle_set_state>
    2e5a:	80 e0       	ldi	r24, 0x00	; 0
    2e5c:	4a dc       	rcall	.-1900   	; 0x26f2 <coolant_set_state>
            }

          #endif

          sys.suspend &= ~(SUSPEND_RESTART_RETRACT);
          sys.suspend |= SUSPEND_RETRACT_COMPLETE;
    2e5e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e60:	8d 7f       	andi	r24, 0xFD	; 253
    2e62:	84 60       	ori	r24, 0x04	; 4
    2e64:	8a 83       	std	Y+2, r24	; 0x02
    2e66:	93 c0       	rjmp	.+294    	; 0x2f8e <protocol_execute_realtime+0x1f6>

        } else {

          
          if (sys.state == STATE_SLEEP) {
    2e68:	20 38       	cpi	r18, 0x80	; 128
    2e6a:	b1 f4       	brne	.+44     	; 0x2e98 <protocol_execute_realtime+0x100>
            report_feedback_message(MESSAGE_SLEEP_MODE);
    2e6c:	8b e0       	ldi	r24, 0x0B	; 11
    2e6e:	0e 94 fa 34 	call	0x69f4	; 0x69f4 <report_feedback_message>
            // Spindle and coolant should already be stopped, but do it again just to be sure.
            spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
    2e72:	40 e0       	ldi	r20, 0x00	; 0
    2e74:	50 e0       	ldi	r21, 0x00	; 0
    2e76:	ba 01       	movw	r22, r20
            coolant_set_state(COOLANT_DISABLE); // De-energize
    2e78:	80 e0       	ldi	r24, 0x00	; 0
    2e7a:	db db       	rcall	.-2122   	; 0x2632 <spindle_set_state>
    2e7c:	80 e0       	ldi	r24, 0x00	; 0
            st_go_idle(); // Disable steppers
    2e7e:	39 dc       	rcall	.-1934   	; 0x26f2 <coolant_set_state>
            while (!(sys.abort)) { protocol_exec_rt_system(); } // Do nothing until reset.
    2e80:	7e d1       	rcall	.+764    	; 0x317e <st_go_idle>
    2e82:	80 91 17 0c 	lds	r24, 0x0C17	; 0x800c17 <sys+0x1>
    2e86:	81 11       	cpse	r24, r1
    2e88:	8e c0       	rjmp	.+284    	; 0x2fa6 <protocol_execute_realtime+0x20e>
    2e8a:	c6 e1       	ldi	r28, 0x16	; 22
    2e8c:	dc e0       	ldi	r29, 0x0C	; 12
    2e8e:	93 dd       	rcall	.-1242   	; 0x29b6 <protocol_exec_rt_system>
    2e90:	89 81       	ldd	r24, Y+1	; 0x01
    2e92:	88 23       	and	r24, r24
    2e94:	e1 f3       	breq	.-8      	; 0x2e8e <protocol_execute_realtime+0xf6>
    2e96:	87 c0       	rjmp	.+270    	; 0x2fa6 <protocol_execute_realtime+0x20e>
            return; // Abort received. Return to re-initialize.
          }    
          
          // Allows resuming from parking/safety door. Actively checks if safety door is closed and ready to resume.
          if (sys.state == STATE_SAFETY_DOOR) {
    2e98:	20 34       	cpi	r18, 0x40	; 64
    2e9a:	39 f4       	brne	.+14     	; 0x2eaa <protocol_execute_realtime+0x112>
            if (!(system_check_safety_door_ajar())) {
    2e9c:	0e 94 32 3a 	call	0x7464	; 0x7464 <system_check_safety_door_ajar>
    2ea0:	81 11       	cpse	r24, r1
    2ea2:	03 c0       	rjmp	.+6      	; 0x2eaa <protocol_execute_realtime+0x112>
              sys.suspend &= ~(SUSPEND_SAFETY_DOOR_AJAR); // Reset door ajar flag to denote ready to resume.
    2ea4:	8a 81       	ldd	r24, Y+2	; 0x02
    2ea6:	8f 7d       	andi	r24, 0xDF	; 223
    2ea8:	8a 83       	std	Y+2, r24	; 0x02
            }
          }

          // Handles parking restore and safety door resume.
          if (sys.suspend & SUSPEND_INITIATE_RESTORE) {
    2eaa:	8a 81       	ldd	r24, Y+2	; 0x02
    2eac:	83 ff       	sbrs	r24, 3
    2eae:	6f c0       	rjmp	.+222    	; 0x2f8e <protocol_execute_realtime+0x1f6>
                }
              }
            #endif

            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    2eb0:	f8 01       	movw	r30, r16
    2eb2:	91 85       	ldd	r25, Z+9	; 0x09
    2eb4:	99 23       	and	r25, r25
    2eb6:	c9 f0       	breq	.+50     	; 0x2eea <protocol_execute_realtime+0x152>
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    2eb8:	81 fd       	sbrc	r24, 1
    2eba:	6e c0       	rjmp	.+220    	; 0x2f98 <protocol_execute_realtime+0x200>
                if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    2ebc:	f7 01       	movw	r30, r14
    2ebe:	80 81       	ld	r24, Z
    2ec0:	81 ff       	sbrs	r24, 1
    2ec2:	08 c0       	rjmp	.+16     	; 0x2ed4 <protocol_execute_realtime+0x13c>
                  // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                  bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    2ec4:	8c 81       	ldd	r24, Y+4	; 0x04
    2ec6:	88 60       	ori	r24, 0x08	; 8
    2ec8:	8c 83       	std	Y+4, r24	; 0x04
                  spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
                  delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
                }
              }
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
    2eca:	f8 01       	movw	r30, r16
    2ecc:	80 85       	ldd	r24, Z+8	; 0x08
    2ece:	81 11       	cpse	r24, r1
    2ed0:	13 c0       	rjmp	.+38     	; 0x2ef8 <protocol_execute_realtime+0x160>
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
                if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
                  // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                  bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
                } else {
                  spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    2ed2:	67 c0       	rjmp	.+206    	; 0x2fa2 <protocol_execute_realtime+0x20a>
    2ed4:	b5 01       	movw	r22, r10
    2ed6:	a4 01       	movw	r20, r8
    2ed8:	8c 2d       	mov	r24, r12
    2eda:	ab db       	rcall	.-2218   	; 0x2632 <spindle_set_state>
                  delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
    2edc:	47 2d       	mov	r20, r7
    2ede:	60 e0       	ldi	r22, 0x00	; 0
    2ee0:	70 e0       	ldi	r23, 0x00	; 0
    2ee2:	80 e8       	ldi	r24, 0x80	; 128
    2ee4:	90 e4       	ldi	r25, 0x40	; 64
    2ee6:	0e 94 5b 2e 	call	0x5cb6	; 0x5cb6 <delay_sec>
                }
              }
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
    2eea:	f8 01       	movw	r30, r16
    2eec:	80 85       	ldd	r24, Z+8	; 0x08
    2eee:	88 23       	and	r24, r24
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    2ef0:	61 f0       	breq	.+24     	; 0x2f0a <protocol_execute_realtime+0x172>
    2ef2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ef4:	81 fd       	sbrc	r24, 1
                // NOTE: Laser mode will honor this delay. An exhaust system is often controlled by this pin.
                coolant_set_state((restore_condition & (PL_COND_FLAG_COOLANT_FLOOD | PL_COND_FLAG_COOLANT_MIST)));
    2ef6:	4b c0       	rjmp	.+150    	; 0x2f8e <protocol_execute_realtime+0x1f6>
    2ef8:	8d 2d       	mov	r24, r13
    2efa:	fb db       	rcall	.-2058   	; 0x26f2 <coolant_set_state>
                delay_sec(SAFETY_DOOR_COOLANT_DELAY, DELAY_MODE_SYS_SUSPEND);
    2efc:	47 2d       	mov	r20, r7
    2efe:	60 e0       	ldi	r22, 0x00	; 0
    2f00:	70 e0       	ldi	r23, 0x00	; 0
    2f02:	80 e8       	ldi	r24, 0x80	; 128
    2f04:	9f e3       	ldi	r25, 0x3F	; 63
    2f06:	0e 94 5b 2e 	call	0x5cb6	; 0x5cb6 <delay_sec>
                  mc_parking_motion(restore_target, pl_data);
                }
              }
            #endif

            if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    2f0a:	8a 81       	ldd	r24, Y+2	; 0x02
    2f0c:	81 fd       	sbrc	r24, 1
    2f0e:	3f c0       	rjmp	.+126    	; 0x2f8e <protocol_execute_realtime+0x1f6>
              sys.suspend |= SUSPEND_RESTORE_COMPLETE;
    2f10:	80 61       	ori	r24, 0x10	; 16
    2f12:	8a 83       	std	Y+2, r24	; 0x02
              system_set_exec_state_flag(EXEC_CYCLE_START); // Set to resume program.
    2f14:	82 e0       	ldi	r24, 0x02	; 2
    2f16:	0e 94 f5 3a 	call	0x75ea	; 0x75ea <system_set_exec_state_flag>
    2f1a:	39 c0       	rjmp	.+114    	; 0x2f8e <protocol_execute_realtime+0x1f6>

      } else {

        // Feed hold manager. Controls spindle stop override states.
        // NOTE: Hold ensured as completed by condition check at the beginning of suspend routine.
        if (sys.spindle_stop_ovr) {
    2f1c:	9a 85       	ldd	r25, Y+10	; 0x0a
    2f1e:	99 23       	and	r25, r25
    2f20:	61 f1       	breq	.+88     	; 0x2f7a <protocol_execute_realtime+0x1e2>
          // Handles beginning of spindle stop
          if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_INITIATE) {
    2f22:	91 ff       	sbrs	r25, 1
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    2f24:	0d c0       	rjmp	.+26     	; 0x2f40 <protocol_execute_realtime+0x1a8>
    2f26:	f8 01       	movw	r30, r16
    2f28:	81 85       	ldd	r24, Z+9	; 0x09
    2f2a:	88 23       	and	r24, r24
              spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
    2f2c:	39 f0       	breq	.+14     	; 0x2f3c <protocol_execute_realtime+0x1a4>
    2f2e:	40 e0       	ldi	r20, 0x00	; 0
    2f30:	50 e0       	ldi	r21, 0x00	; 0
    2f32:	ba 01       	movw	r22, r20
    2f34:	80 e0       	ldi	r24, 0x00	; 0
    2f36:	7d db       	rcall	.-2310   	; 0x2632 <spindle_set_state>
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_ENABLED; // Set stop override state to enabled, if de-energized.
    2f38:	7a 86       	std	Y+10, r7	; 0x0a
    2f3a:	29 c0       	rjmp	.+82     	; 0x2f8e <protocol_execute_realtime+0x1f6>
            } else {
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
    2f3c:	1a 86       	std	Y+10, r1	; 0x0a
    2f3e:	27 c0       	rjmp	.+78     	; 0x2f8e <protocol_execute_realtime+0x1f6>
            }
          // Handles restoring of spindle state
          } else if (sys.spindle_stop_ovr & (SPINDLE_STOP_OVR_RESTORE | SPINDLE_STOP_OVR_RESTORE_CYCLE)) {
    2f40:	9c 70       	andi	r25, 0x0C	; 12
    2f42:	29 f1       	breq	.+74     	; 0x2f8e <protocol_execute_realtime+0x1f6>
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    2f44:	f8 01       	movw	r30, r16
    2f46:	81 85       	ldd	r24, Z+9	; 0x09
    2f48:	88 23       	and	r24, r24
    2f4a:	79 f0       	breq	.+30     	; 0x2f6a <protocol_execute_realtime+0x1d2>
              report_feedback_message(MESSAGE_SPINDLE_RESTORE);
    2f4c:	8a e0       	ldi	r24, 0x0A	; 10
    2f4e:	0e 94 fa 34 	call	0x69f4	; 0x69f4 <report_feedback_message>
              if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    2f52:	f7 01       	movw	r30, r14
    2f54:	80 81       	ld	r24, Z
    2f56:	81 ff       	sbrs	r24, 1
                // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    2f58:	04 c0       	rjmp	.+8      	; 0x2f62 <protocol_execute_realtime+0x1ca>
    2f5a:	8c 81       	ldd	r24, Y+4	; 0x04
    2f5c:	88 60       	ori	r24, 0x08	; 8
    2f5e:	8c 83       	std	Y+4, r24	; 0x04
              } else {
                spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    2f60:	04 c0       	rjmp	.+8      	; 0x2f6a <protocol_execute_realtime+0x1d2>
    2f62:	b5 01       	movw	r22, r10
    2f64:	a4 01       	movw	r20, r8
    2f66:	8c 2d       	mov	r24, r12
    2f68:	64 db       	rcall	.-2360   	; 0x2632 <spindle_set_state>
              }
            }
            if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_RESTORE_CYCLE) {
    2f6a:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f6c:	83 ff       	sbrs	r24, 3
              system_set_exec_state_flag(EXEC_CYCLE_START);  // Set to resume program.
    2f6e:	03 c0       	rjmp	.+6      	; 0x2f76 <protocol_execute_realtime+0x1de>
    2f70:	82 e0       	ldi	r24, 0x02	; 2
    2f72:	0e 94 f5 3a 	call	0x75ea	; 0x75ea <system_set_exec_state_flag>
            sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
          }
        } else {
          // Handles spindle state during hold. NOTE: Spindle speed overrides may be altered during hold state.
          // NOTE: STEP_CONTROL_UPDATE_SPINDLE_PWM is automatically reset upon resume in step generator.
          if (bit_istrue(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
    2f76:	1a 86       	std	Y+10, r1	; 0x0a
    2f78:	0a c0       	rjmp	.+20     	; 0x2f8e <protocol_execute_realtime+0x1f6>
    2f7a:	8c 81       	ldd	r24, Y+4	; 0x04
            spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    2f7c:	83 ff       	sbrs	r24, 3
    2f7e:	07 c0       	rjmp	.+14     	; 0x2f8e <protocol_execute_realtime+0x1f6>
    2f80:	b5 01       	movw	r22, r10
    2f82:	a4 01       	movw	r20, r8
    2f84:	8c 2d       	mov	r24, r12
            bit_false(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    2f86:	55 db       	rcall	.-2390   	; 0x2632 <spindle_set_state>
    2f88:	8c 81       	ldd	r24, Y+4	; 0x04
    2f8a:	87 7f       	andi	r24, 0xF7	; 247
      // Sleep is valid for both hold and door states, if the spindle or coolant are on or
      // set to be re-enabled.
      sleep_check();
    #endif

    protocol_exec_rt_system();
    2f8c:	8c 83       	std	Y+4, r24	; 0x04
    2f8e:	13 dd       	rcall	.-1498   	; 0x29b6 <protocol_exec_rt_system>
    if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) { 
      system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP);
    }
  #endif

  while (sys.suspend) {
    2f90:	9a 81       	ldd	r25, Y+2	; 0x02
    2f92:	91 11       	cpse	r25, r1
    2f94:	50 cf       	rjmp	.-352    	; 0x2e36 <protocol_execute_realtime+0x9e>
    2f96:	07 c0       	rjmp	.+14     	; 0x2fa6 <protocol_execute_realtime+0x20e>
                  spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
                  delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
                }
              }
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
    2f98:	f8 01       	movw	r30, r16
    2f9a:	80 85       	ldd	r24, Z+8	; 0x08
    2f9c:	81 11       	cpse	r24, r1
    2f9e:	f7 cf       	rjmp	.-18     	; 0x2f8e <protocol_execute_realtime+0x1f6>
    2fa0:	b4 cf       	rjmp	.-152    	; 0x2f0a <protocol_execute_realtime+0x172>
                  mc_parking_motion(restore_target, pl_data);
                }
              }
            #endif

            if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    2fa2:	8a 81       	ldd	r24, Y+2	; 0x02
    2fa4:	b5 cf       	rjmp	.-150    	; 0x2f10 <protocol_execute_realtime+0x178>
// limit switches, or the main program.
void protocol_execute_realtime()
{
  protocol_exec_rt_system();
  if (sys.suspend) { protocol_exec_rt_suspend(); }
}
    2fa6:	df 91       	pop	r29
    2fa8:	cf 91       	pop	r28
    2faa:	1f 91       	pop	r17
    2fac:	0f 91       	pop	r16
    2fae:	ff 90       	pop	r15
    2fb0:	ef 90       	pop	r14
    2fb2:	df 90       	pop	r13
    2fb4:	cf 90       	pop	r12
    2fb6:	bf 90       	pop	r11
    2fb8:	af 90       	pop	r10
    2fba:	9f 90       	pop	r9
    2fbc:	8f 90       	pop	r8
    2fbe:	7f 90       	pop	r7
    2fc0:	08 95       	ret

00002fc2 <protocol_main_loop>:

/*
  GRBL PRIMARY LOOP:
*/
void protocol_main_loop()
{
    2fc2:	df 92       	push	r13
    2fc4:	ef 92       	push	r14
    2fc6:	ff 92       	push	r15
    2fc8:	0f 93       	push	r16
    2fca:	1f 93       	push	r17
    2fcc:	cf 93       	push	r28
    2fce:	df 93       	push	r29
  // Perform some machine checks to make sure everything is good to go.
  #ifdef CHECK_LIMITS_AT_INIT
    if (bit_istrue(settings.flags, BITFLAG_HARD_LIMIT_ENABLE)) {
    2fd0:	80 91 05 0f 	lds	r24, 0x0F05	; 0x800f05 <settings+0x45>
    2fd4:	83 ff       	sbrs	r24, 3
    2fd6:	0a c0       	rjmp	.+20     	; 0x2fec <protocol_main_loop+0x2a>
      if (limits_get_state()) {
    2fd8:	0e 94 cd 2f 	call	0x5f9a	; 0x5f9a <limits_get_state>
    2fdc:	88 23       	and	r24, r24
    2fde:	31 f0       	breq	.+12     	; 0x2fec <protocol_main_loop+0x2a>
        sys.state = STATE_ALARM; // Ensure alarm state is active.
    2fe0:	81 e0       	ldi	r24, 0x01	; 1
    2fe2:	80 93 16 0c 	sts	0x0C16, r24	; 0x800c16 <sys>
        report_feedback_message(MESSAGE_CHECK_LIMITS);
    2fe6:	87 e0       	ldi	r24, 0x07	; 7
    2fe8:	0e 94 fa 34 	call	0x69f4	; 0x69f4 <report_feedback_message>
    }
  #endif
  // Check for and report alarm state after a reset, error, or an initial power up.
  // NOTE: Sleep mode disables the stepper drivers and position can't be guaranteed.
  // Re-initialize the sleep state as an ALARM mode to ensure user homes or acknowledges.
  if (sys.state & (STATE_ALARM | STATE_SLEEP)) {
    2fec:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
    2ff0:	81 78       	andi	r24, 0x81	; 129
    2ff2:	71 f0       	breq	.+28     	; 0x3010 <protocol_main_loop+0x4e>
    report_feedback_message(MESSAGE_ALARM_LOCK);
    2ff4:	82 e0       	ldi	r24, 0x02	; 2
    2ff6:	0e 94 fa 34 	call	0x69f4	; 0x69f4 <report_feedback_message>
    sys.state = STATE_ALARM; // Ensure alarm state is set.
    2ffa:	81 e0       	ldi	r24, 0x01	; 1
    2ffc:	80 93 16 0c 	sts	0x0C16, r24	; 0x800c16 <sys>
          } else if (c == '(') {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            line_flags |= LINE_FLAG_COMMENT_PARENTHESES;
    3000:	f1 2c       	mov	r15, r1
    3002:	e1 2c       	mov	r14, r1
    // this indicates that g-code streaming has either filled the planner buffer or has
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();

    protocol_execute_realtime();  // Runtime command check point.
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    3004:	c6 e1       	ldi	r28, 0x16	; 22
    3006:	dc e0       	ldi	r29, 0x0C	; 12

        // Direct and execute one line of formatted input, and report status of execution.
        if (line_flags & LINE_FLAG_OVERFLOW) {
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
        } else if (line[0] == 0) {
    3008:	08 e0       	ldi	r16, 0x08	; 8
    300a:	12 e0       	ldi	r17, 0x02	; 2
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    300c:	d1 2c       	mov	r13, r1
    300e:	7b c0       	rjmp	.+246    	; 0x3106 <protocol_main_loop+0x144>
  if (sys.state & (STATE_ALARM | STATE_SLEEP)) {
    report_feedback_message(MESSAGE_ALARM_LOCK);
    sys.state = STATE_ALARM; // Ensure alarm state is set.
  } else {
    // Check if the safety door is open.
    sys.state = STATE_IDLE;
    3010:	10 92 16 0c 	sts	0x0C16, r1	; 0x800c16 <sys>
    if (system_check_safety_door_ajar()) {
    3014:	0e 94 32 3a 	call	0x7464	; 0x7464 <system_check_safety_door_ajar>
    3018:	88 23       	and	r24, r24
    301a:	31 f0       	breq	.+12     	; 0x3028 <protocol_main_loop+0x66>
      bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
    301c:	80 91 29 0c 	lds	r24, 0x0C29	; 0x800c29 <sys_rt_exec_state>
    3020:	80 62       	ori	r24, 0x20	; 32
    3022:	80 93 29 0c 	sts	0x0C29, r24	; 0x800c29 <sys_rt_exec_state>
      protocol_execute_realtime(); // Enter safety door mode. Should return as IDLE state.
    3026:	b8 de       	rcall	.-656    	; 0x2d98 <protocol_execute_realtime>
    }
    // All systems go!
    system_execute_startup(line); // Execute startup script.
    3028:	88 e0       	ldi	r24, 0x08	; 8
    302a:	92 e0       	ldi	r25, 0x02	; 2
    302c:	0e 94 35 3a 	call	0x746a	; 0x746a <system_execute_startup>
    3030:	e7 cf       	rjmp	.-50     	; 0x3000 <protocol_main_loop+0x3e>
  for (;;) {

    // Process one line of incoming serial data, as the data becomes available. Performs an
    // initial filtering by removing spaces and comments and capitalizing all letters.
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
    3032:	8a 30       	cpi	r24, 0x0A	; 10
    3034:	11 f0       	breq	.+4      	; 0x303a <protocol_main_loop+0x78>
    3036:	8d 30       	cpi	r24, 0x0D	; 13

        protocol_execute_realtime(); // Runtime command check point.
    3038:	b1 f5       	brne	.+108    	; 0x30a6 <protocol_main_loop+0xe4>
    303a:	ae de       	rcall	.-676    	; 0x2d98 <protocol_execute_realtime>
        if (sys.abort) { return; } // Bail to calling function upon system abort
    303c:	89 81       	ldd	r24, Y+1	; 0x01
    303e:	81 11       	cpse	r24, r1
    3040:	6b c0       	rjmp	.+214    	; 0x3118 <protocol_main_loop+0x156>

        line[char_counter] = 0; // Set string termination character.
    3042:	ef 2d       	mov	r30, r15
    3044:	f0 e0       	ldi	r31, 0x00	; 0
    3046:	e8 5f       	subi	r30, 0xF8	; 248
    3048:	fd 4f       	sbci	r31, 0xFD	; 253
    304a:	10 82       	st	Z, r1
        #ifdef REPORT_ECHO_LINE_RECEIVED
          report_echo_line_received(line);
        #endif

        // Direct and execute one line of formatted input, and report status of execution.
        if (line_flags & LINE_FLAG_OVERFLOW) {
    304c:	e0 fe       	sbrs	r14, 0
    304e:	06 c0       	rjmp	.+12     	; 0x305c <protocol_main_loop+0x9a>
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
    3050:	8b e0       	ldi	r24, 0x0B	; 11
    3052:	0e 94 c6 34 	call	0x698c	; 0x698c <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    3056:	fd 2c       	mov	r15, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    3058:	e1 2c       	mov	r14, r1
    305a:	55 c0       	rjmp	.+170    	; 0x3106 <protocol_main_loop+0x144>

        // Direct and execute one line of formatted input, and report status of execution.
        if (line_flags & LINE_FLAG_OVERFLOW) {
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
        } else if (line[0] == 0) {
    305c:	f8 01       	movw	r30, r16
    305e:	80 81       	ld	r24, Z
    3060:	81 11       	cpse	r24, r1
    3062:	06 c0       	rjmp	.+12     	; 0x3070 <protocol_main_loop+0xae>
          // Empty or comment line. For syncing purposes.
          report_status_message(STATUS_OK);
    3064:	8d 2d       	mov	r24, r13
    3066:	0e 94 c6 34 	call	0x698c	; 0x698c <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    306a:	fd 2c       	mov	r15, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    306c:	e1 2c       	mov	r14, r1
    306e:	4b c0       	rjmp	.+150    	; 0x3106 <protocol_main_loop+0x144>
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
        } else if (line[0] == 0) {
          // Empty or comment line. For syncing purposes.
          report_status_message(STATUS_OK);
        } else if (line[0] == '$') {
    3070:	84 32       	cpi	r24, 0x24	; 36
    3072:	41 f4       	brne	.+16     	; 0x3084 <protocol_main_loop+0xc2>
          // Grbl '$' system command
          report_status_message(system_execute_line(line));
    3074:	c8 01       	movw	r24, r16
    3076:	0e 94 fe 3a 	call	0x75fc	; 0x75fc <system_execute_line>
    307a:	0e 94 c6 34 	call	0x698c	; 0x698c <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    307e:	fd 2c       	mov	r15, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    3080:	e1 2c       	mov	r14, r1
    3082:	41 c0       	rjmp	.+130    	; 0x3106 <protocol_main_loop+0x144>
          // Empty or comment line. For syncing purposes.
          report_status_message(STATUS_OK);
        } else if (line[0] == '$') {
          // Grbl '$' system command
          report_status_message(system_execute_line(line));
        } else if (sys.state & (STATE_ALARM | STATE_JOG)) {
    3084:	88 81       	ld	r24, Y
    3086:	81 72       	andi	r24, 0x21	; 33
    3088:	31 f0       	breq	.+12     	; 0x3096 <protocol_main_loop+0xd4>
          // Everything else is gcode. Block if in alarm or jog mode.
          report_status_message(STATUS_SYSTEM_GC_LOCK);
    308a:	89 e0       	ldi	r24, 0x09	; 9
    308c:	0e 94 c6 34 	call	0x698c	; 0x698c <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    3090:	fd 2c       	mov	r15, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    3092:	e1 2c       	mov	r14, r1
    3094:	38 c0       	rjmp	.+112    	; 0x3106 <protocol_main_loop+0x144>
        } else if (sys.state & (STATE_ALARM | STATE_JOG)) {
          // Everything else is gcode. Block if in alarm or jog mode.
          report_status_message(STATUS_SYSTEM_GC_LOCK);
        } else {
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
    3096:	c8 01       	movw	r24, r16
    3098:	0e 94 08 07 	call	0xe10	; 0xe10 <gc_execute_line>
    309c:	0e 94 c6 34 	call	0x698c	; 0x698c <report_status_message>
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    30a0:	fd 2c       	mov	r15, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    30a2:	e1 2c       	mov	r14, r1
    30a4:	30 c0       	rjmp	.+96     	; 0x3106 <protocol_main_loop+0x144>
        char_counter = 0;

      } else {

        if (line_flags) {
    30a6:	ee 20       	and	r14, r14
    30a8:	31 f0       	breq	.+12     	; 0x30b6 <protocol_main_loop+0xf4>
          // Throw away all (except EOL) comment characters and overflow characters.
          if (c == ')') {
    30aa:	89 32       	cpi	r24, 0x29	; 41
    30ac:	61 f5       	brne	.+88     	; 0x3106 <protocol_main_loop+0x144>
            // End of '()' comment. Resume line allowed.
            if (line_flags & LINE_FLAG_COMMENT_PARENTHESES) { line_flags &= ~(LINE_FLAG_COMMENT_PARENTHESES); }
    30ae:	fe 2d       	mov	r31, r14
    30b0:	fd 7f       	andi	r31, 0xFD	; 253
    30b2:	ef 2e       	mov	r14, r31
    30b4:	28 c0       	rjmp	.+80     	; 0x3106 <protocol_main_loop+0x144>
          }
        } else {
          if (c <= ' ') {
    30b6:	81 32       	cpi	r24, 0x21	; 33
    30b8:	30 f1       	brcs	.+76     	; 0x3106 <protocol_main_loop+0x144>
            // Throw away whitepace and control characters
          } else if (c == '/') {
    30ba:	8f 32       	cpi	r24, 0x2F	; 47
    30bc:	21 f1       	breq	.+72     	; 0x3106 <protocol_main_loop+0x144>
            // Block delete NOT SUPPORTED. Ignore character.
            // NOTE: If supported, would simply need to check the system if block delete is enabled.
          } else if (c == '(') {
    30be:	88 32       	cpi	r24, 0x28	; 40
    30c0:	c1 f0       	breq	.+48     	; 0x30f2 <protocol_main_loop+0x130>
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            line_flags |= LINE_FLAG_COMMENT_PARENTHESES;
          } else if (c == ';') {
    30c2:	8b 33       	cpi	r24, 0x3B	; 59
    30c4:	d1 f0       	breq	.+52     	; 0x30fa <protocol_main_loop+0x138>
            // Program start-end percent sign NOT SUPPORTED.
            // NOTE: This maybe installed to tell Grbl when a program is running vs manual input,
            // where, during a program, the system auto-cycle start will continue to execute
            // everything until the next '%' sign. This will help fix resuming issues with certain
            // functions that empty the planner buffer to execute its task on-time.
          } else if (char_counter >= (LINE_BUFFER_SIZE-1)) {
    30c6:	9f ef       	ldi	r25, 0xFF	; 255
    30c8:	f9 16       	cp	r15, r25
    30ca:	d9 f0       	breq	.+54     	; 0x3102 <protocol_main_loop+0x140>
            // Detect line buffer overflow and set flag.
            line_flags |= LINE_FLAG_OVERFLOW;
          } else if (c >= 'a' && c <= 'z') { // Upcase lowercase
    30cc:	9f e9       	ldi	r25, 0x9F	; 159
    30ce:	98 0f       	add	r25, r24
    30d0:	9a 31       	cpi	r25, 0x1A	; 26
    30d2:	40 f4       	brcc	.+16     	; 0x30e4 <protocol_main_loop+0x122>
            line[char_counter++] = c-'a'+'A';
    30d4:	ef 2d       	mov	r30, r15
    30d6:	f0 e0       	ldi	r31, 0x00	; 0
    30d8:	e8 5f       	subi	r30, 0xF8	; 248
    30da:	fd 4f       	sbci	r31, 0xFD	; 253
    30dc:	80 52       	subi	r24, 0x20	; 32
    30de:	80 83       	st	Z, r24
    30e0:	f3 94       	inc	r15
    30e2:	11 c0       	rjmp	.+34     	; 0x3106 <protocol_main_loop+0x144>
          } else {
            line[char_counter++] = c;
    30e4:	ef 2d       	mov	r30, r15
    30e6:	f0 e0       	ldi	r31, 0x00	; 0
    30e8:	e8 5f       	subi	r30, 0xF8	; 248
    30ea:	fd 4f       	sbci	r31, 0xFD	; 253
    30ec:	80 83       	st	Z, r24
    30ee:	f3 94       	inc	r15
    30f0:	0a c0       	rjmp	.+20     	; 0x3106 <protocol_main_loop+0x144>
          } else if (c == '(') {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            line_flags |= LINE_FLAG_COMMENT_PARENTHESES;
    30f2:	68 94       	set
    30f4:	ee 24       	eor	r14, r14
    30f6:	e1 f8       	bld	r14, 1
    30f8:	06 c0       	rjmp	.+12     	; 0x3106 <protocol_main_loop+0x144>
          } else if (c == ';') {
            // NOTE: ';' comment to EOL is a LinuxCNC definition. Not NIST.
            line_flags |= LINE_FLAG_COMMENT_SEMICOLON;
    30fa:	68 94       	set
    30fc:	ee 24       	eor	r14, r14
    30fe:	e2 f8       	bld	r14, 2
    3100:	02 c0       	rjmp	.+4      	; 0x3106 <protocol_main_loop+0x144>
            // where, during a program, the system auto-cycle start will continue to execute
            // everything until the next '%' sign. This will help fix resuming issues with certain
            // functions that empty the planner buffer to execute its task on-time.
          } else if (char_counter >= (LINE_BUFFER_SIZE-1)) {
            // Detect line buffer overflow and set flag.
            line_flags |= LINE_FLAG_OVERFLOW;
    3102:	ee 24       	eor	r14, r14
  uint8_t c;
  for (;;) {

    // Process one line of incoming serial data, as the data becomes available. Performs an
    // initial filtering by removing spaces and comments and capitalizing all letters.
    while((c = serial_read()) != SERIAL_NO_DATA) {
    3104:	e3 94       	inc	r14
    3106:	82 db       	rcall	.-2300   	; 0x280c <serial_read>
    3108:	8f 3f       	cpi	r24, 0xFF	; 255
    }

    // If there are no more characters in the serial read buffer to be processed and executed,
    // this indicates that g-code streaming has either filled the planner buffer or has
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();
    310a:	09 f0       	breq	.+2      	; 0x310e <protocol_main_loop+0x14c>
    310c:	92 cf       	rjmp	.-220    	; 0x3032 <protocol_main_loop+0x70>

    protocol_execute_realtime();  // Runtime command check point.
    310e:	4b dc       	rcall	.-1898   	; 0x29a6 <protocol_auto_cycle_start>
    3110:	43 de       	rcall	.-890    	; 0x2d98 <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    3112:	89 81       	ldd	r24, Y+1	; 0x01
    3114:	88 23       	and	r24, r24
    3116:	b9 f3       	breq	.-18     	; 0x3106 <protocol_main_loop+0x144>
      sleep_check();    
    #endif
  }

  return; /* Never reached */
}
    3118:	df 91       	pop	r29
    311a:	cf 91       	pop	r28
    311c:	1f 91       	pop	r17
    311e:	0f 91       	pop	r16
    3120:	ff 90       	pop	r15
    3122:	ef 90       	pop	r14
    3124:	df 90       	pop	r13
    3126:	08 95       	ret

00003128 <protocol_buffer_synchronize>:


// Block until all buffered steps are executed or in a cycle state. Works with feed hold
// during a synchronize call, if it should happen. Also, waits for clean cycle end.
void protocol_buffer_synchronize()
{
    3128:	cf 93       	push	r28
    312a:	df 93       	push	r29
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
    312c:	3c dc       	rcall	.-1928   	; 0x29a6 <protocol_auto_cycle_start>
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    if (sys.abort) { return; } // Check for system abort
    312e:	c6 e1       	ldi	r28, 0x16	; 22
void protocol_buffer_synchronize()
{
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    3130:	dc e0       	ldi	r29, 0x0C	; 12
    3132:	32 de       	rcall	.-924    	; 0x2d98 <protocol_execute_realtime>
    if (sys.abort) { return; } // Check for system abort
    3134:	89 81       	ldd	r24, Y+1	; 0x01
    3136:	81 11       	cpse	r24, r1
    3138:	07 c0       	rjmp	.+14     	; 0x3148 <protocol_buffer_synchronize+0x20>
  } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
    313a:	0e 94 ed 28 	call	0x51da	; 0x51da <plan_get_current_block>
    313e:	89 2b       	or	r24, r25
    3140:	c1 f7       	brne	.-16     	; 0x3132 <protocol_buffer_synchronize+0xa>
    3142:	88 81       	ld	r24, Y
    3144:	88 30       	cpi	r24, 0x08	; 8
    3146:	a9 f3       	breq	.-22     	; 0x3132 <protocol_buffer_synchronize+0xa>
}
    3148:	df 91       	pop	r29
    314a:	cf 91       	pop	r28
    314c:	08 95       	ret

0000314e <st_wake_up>:
    // Initialize stepper output bits to ensure first ISR call does not step.
    for (idx = 0; idx < N_AXIS; idx++) {
      st.step_outbits[idx] = step_port_invert_mask[idx];
    }
  #else
    if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    314e:	80 91 05 0f 	lds	r24, 0x0F05	; 0x800f05 <settings+0x45>
    3152:	82 ff       	sbrs	r24, 2
    3154:	02 c0       	rjmp	.+4      	; 0x315a <st_wake_up+0xc>
    3156:	2f 9a       	sbi	0x05, 7	; 5
    3158:	01 c0       	rjmp	.+2      	; 0x315c <st_wake_up+0xe>
    else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    315a:	2f 98       	cbi	0x05, 7	; 5
    // Initialize stepper output bits to ensure first ISR call does not step.
    st.step_outbits = step_port_invert_mask;
    315c:	e3 e4       	ldi	r30, 0x43	; 67
    315e:	f3 e0       	ldi	r31, 0x03	; 3
    3160:	80 91 3f 03 	lds	r24, 0x033F	; 0x80033f <step_port_invert_mask>
    3164:	86 87       	std	Z+14, r24	; 0x0e
    st.step_pulse_time = -(((settings.pulse_microseconds+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND) >> 3);
    // Set delay between direction pin write and step command.
    OCR0A = -(((settings.pulse_microseconds)*TICKS_PER_MICROSECOND) >> 3);
  #else // Normal operation
    // Set step pulse time. Ad hoc computation from oscilloscope. Uses two's complement.
    st.step_pulse_time = -(((settings.pulse_microseconds-2)*TICKS_PER_MICROSECOND) >> 3);
    3166:	80 91 f0 0e 	lds	r24, 0x0EF0	; 0x800ef0 <settings+0x30>
    316a:	88 0f       	add	r24, r24
    316c:	84 50       	subi	r24, 0x04	; 4
    316e:	81 95       	neg	r24
    3170:	85 87       	std	Z+13, r24	; 0x0d
  #endif

  // Enable Stepper Driver Interrupt
  TIMSK1 |= (1<<OCIE1A);
    3172:	ef e6       	ldi	r30, 0x6F	; 111
    3174:	f0 e0       	ldi	r31, 0x00	; 0
    3176:	80 81       	ld	r24, Z
    3178:	82 60       	ori	r24, 0x02	; 2
    317a:	80 83       	st	Z, r24
    317c:	08 95       	ret

0000317e <st_go_idle>:

// Stepper shutdown
void st_go_idle()
{
  // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.
  TIMSK1 &= ~(1<<OCIE1A); // Disable Timer1 interrupt
    317e:	ef e6       	ldi	r30, 0x6F	; 111
    3180:	f0 e0       	ldi	r31, 0x00	; 0
    3182:	80 81       	ld	r24, Z
    3184:	8d 7f       	andi	r24, 0xFD	; 253
    3186:	80 83       	st	Z, r24
  TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Reset clock to no prescaling.
    3188:	e1 e8       	ldi	r30, 0x81	; 129
    318a:	f0 e0       	ldi	r31, 0x00	; 0
    318c:	80 81       	ld	r24, Z
    318e:	88 7f       	andi	r24, 0xF8	; 248
    3190:	81 60       	ori	r24, 0x01	; 1
    3192:	80 83       	st	Z, r24
  busy = false;
    3194:	10 92 3d 03 	sts	0x033D, r1	; 0x80033d <busy>

  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
  if (((settings.stepper_idle_lock_time != 0xff) || sys_rt_exec_alarm || sys.state == STATE_SLEEP) && sys.state != STATE_HOMING) {
    3198:	80 91 f3 0e 	lds	r24, 0x0EF3	; 0x800ef3 <settings+0x33>
    319c:	8f 3f       	cpi	r24, 0xFF	; 255
    319e:	49 f4       	brne	.+18     	; 0x31b2 <st_go_idle+0x34>
    31a0:	90 91 43 0c 	lds	r25, 0x0C43	; 0x800c43 <sys_rt_exec_alarm>
    31a4:	91 11       	cpse	r25, r1
    31a6:	05 c0       	rjmp	.+10     	; 0x31b2 <st_go_idle+0x34>
    31a8:	90 91 16 0c 	lds	r25, 0x0C16	; 0x800c16 <sys>
    31ac:	90 38       	cpi	r25, 0x80	; 128
    31ae:	81 f4       	brne	.+32     	; 0x31d0 <st_go_idle+0x52>
    31b0:	04 c0       	rjmp	.+8      	; 0x31ba <st_go_idle+0x3c>
    31b2:	90 91 16 0c 	lds	r25, 0x0C16	; 0x800c16 <sys>
    31b6:	94 30       	cpi	r25, 0x04	; 4
    31b8:	59 f0       	breq	.+22     	; 0x31d0 <st_go_idle+0x52>
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    31ba:	90 e0       	ldi	r25, 0x00	; 0
    31bc:	0e 94 98 2e 	call	0x5d30	; 0x5d30 <delay_ms>
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    31c0:	80 91 05 0f 	lds	r24, 0x0F05	; 0x800f05 <settings+0x45>
    31c4:	82 fd       	sbrc	r24, 2
    31c6:	02 c0       	rjmp	.+4      	; 0x31cc <st_go_idle+0x4e>
      STEPPER_DISABLE_PORT(0) &= ~(1 << STEPPER_DISABLE_BIT(0));
      STEPPER_DISABLE_PORT(1) &= ~(1 << STEPPER_DISABLE_BIT(1));
      STEPPER_DISABLE_PORT(2) &= ~(1 << STEPPER_DISABLE_BIT(2));
    }
  #else
    if (pin_state) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    31c8:	2f 9a       	sbi	0x05, 7	; 5
    31ca:	08 95       	ret
    else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    31cc:	2f 98       	cbi	0x05, 7	; 5
  #endif // Ramps Board
}
    31ce:	08 95       	ret
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    31d0:	80 91 05 0f 	lds	r24, 0x0F05	; 0x800f05 <settings+0x45>
    31d4:	82 ff       	sbrs	r24, 2
    31d6:	fa cf       	rjmp	.-12     	; 0x31cc <st_go_idle+0x4e>
    31d8:	f7 cf       	rjmp	.-18     	; 0x31c8 <st_go_idle+0x4a>

000031da <__vector_17>:
*/
// TODO: Replace direct updating of the int32 position counters in the ISR somehow. Perhaps use smaller
// int8 variables and update position counters only when a segment completes. This can get complicated
// with probing and homing cycles that require true real-time positions.
ISR(TIMER1_COMPA_vect)
{
    31da:	1f 92       	push	r1
    31dc:	0f 92       	push	r0
    31de:	0f b6       	in	r0, 0x3f	; 63
    31e0:	0f 92       	push	r0
    31e2:	11 24       	eor	r1, r1
    31e4:	0b b6       	in	r0, 0x3b	; 59
    31e6:	0f 92       	push	r0
    31e8:	2f 93       	push	r18
    31ea:	3f 93       	push	r19
    31ec:	4f 93       	push	r20
    31ee:	5f 93       	push	r21
    31f0:	6f 93       	push	r22
    31f2:	7f 93       	push	r23
    31f4:	8f 93       	push	r24
    31f6:	9f 93       	push	r25
    31f8:	af 93       	push	r26
    31fa:	bf 93       	push	r27
    31fc:	cf 93       	push	r28
    31fe:	df 93       	push	r29
    3200:	ef 93       	push	r30
    3202:	ff 93       	push	r31
  #ifdef DEFAULTS_RAMPS_BOARD
    int i;
  #endif // Ramps Board

  if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
    3204:	80 91 3d 03 	lds	r24, 0x033D	; 0x80033d <busy>
    3208:	81 11       	cpse	r24, r1
    320a:	d0 c1       	rjmp	.+928    	; 0x35ac <__vector_17+0x3d2>
  #ifdef DEFAULTS_RAMPS_BOARD
    DIRECTION_PORT(0) = (DIRECTION_PORT(0) & ~(1 << DIRECTION_BIT(0))) | st.dir_outbits[0];
    DIRECTION_PORT(1) = (DIRECTION_PORT(1) & ~(1 << DIRECTION_BIT(1))) | st.dir_outbits[1];
    DIRECTION_PORT(2) = (DIRECTION_PORT(2) & ~(1 << DIRECTION_BIT(2))) | st.dir_outbits[2];
  #else
    DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK);
    320c:	88 b1       	in	r24, 0x08	; 8
    320e:	e3 e4       	ldi	r30, 0x43	; 67
    3210:	f3 e0       	ldi	r31, 0x03	; 3
    3212:	97 85       	ldd	r25, Z+15	; 0x0f
    3214:	90 7e       	andi	r25, 0xE0	; 224
    3216:	8f 71       	andi	r24, 0x1F	; 31
    3218:	89 2b       	or	r24, r25
    321a:	88 b9       	out	0x08, r24	; 8
    #endif
  #else  
    #ifdef STEP_PULSE_DELAY
      st.step_bits = (STEP_PORT & ~STEP_MASK) | st.step_outbits; // Store out_bits to prevent overwriting.
    #else  // Normal operation
      STEP_PORT = (STEP_PORT & ~STEP_MASK) | st.step_outbits;
    321c:	82 b1       	in	r24, 0x02	; 2
    321e:	83 7e       	andi	r24, 0xE3	; 227
    3220:	96 85       	ldd	r25, Z+14	; 0x0e
    3222:	89 2b       	or	r24, r25
    3224:	82 b9       	out	0x02, r24	; 2
    #endif
  #endif // Ramps Board

  // Enable step pulse reset timer so that The Stepper Port Reset Interrupt can reset the signal after
  // exactly settings.pulse_microseconds microseconds, independent of the main Timer1 prescaler.
  TCNT0 = st.step_pulse_time; // Reload Timer0 counter
    3226:	85 85       	ldd	r24, Z+13	; 0x0d
    3228:	86 bd       	out	0x26, r24	; 38
  TCCR0B = (1<<CS01); // Begin Timer0. Full speed, 1/8 prescaler
    322a:	82 e0       	ldi	r24, 0x02	; 2
    322c:	85 bd       	out	0x25, r24	; 37

  busy = true;
    322e:	81 e0       	ldi	r24, 0x01	; 1
    3230:	80 93 3d 03 	sts	0x033D, r24	; 0x80033d <busy>
  sei(); // Re-enable interrupts to allow Stepper Port Reset Interrupt to fire on-time.
    3234:	78 94       	sei
         // NOTE: The remaining code in this ISR will finish before returning to main program.

  // If there is no step segment, attempt to pop one from the stepper buffer
  if (st.exec_segment == NULL) {
    3236:	81 a1       	ldd	r24, Z+33	; 0x21
    3238:	92 a1       	ldd	r25, Z+34	; 0x22
    323a:	89 2b       	or	r24, r25
    323c:	09 f0       	breq	.+2      	; 0x3240 <__vector_17+0x66>
    323e:	a9 c0       	rjmp	.+338    	; 0x3392 <__vector_17+0x1b8>
    // Anything in the buffer? If so, load and initialize next step segment.
    if (segment_buffer_head != segment_buffer_tail) {
    3240:	80 91 42 03 	lds	r24, 0x0342	; 0x800342 <segment_buffer_tail>
    3244:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <segment_buffer_head>
    3248:	98 17       	cp	r25, r24
    324a:	09 f4       	brne	.+2      	; 0x324e <__vector_17+0x74>
    324c:	93 c0       	rjmp	.+294    	; 0x3374 <__vector_17+0x19a>
      // Initialize new step segment and load number of steps to execute
      st.exec_segment = &segment_buffer[segment_buffer_tail];
    324e:	e0 91 42 03 	lds	r30, 0x0342	; 0x800342 <segment_buffer_tail>
    3252:	f0 e0       	ldi	r31, 0x00	; 0
    3254:	a3 e4       	ldi	r26, 0x43	; 67
    3256:	b3 e0       	ldi	r27, 0x03	; 3
    3258:	ee 0f       	add	r30, r30
    325a:	ff 1f       	adc	r31, r31
    325c:	ee 0f       	add	r30, r30
    325e:	ff 1f       	adc	r31, r31
    3260:	ee 0f       	add	r30, r30
    3262:	ff 1f       	adc	r31, r31
    3264:	ea 59       	subi	r30, 0x9A	; 154
    3266:	fc 4f       	sbci	r31, 0xFC	; 252
    3268:	92 96       	adiw	r26, 0x22	; 34
    326a:	fc 93       	st	X, r31
    326c:	ee 93       	st	-X, r30
    326e:	91 97       	sbiw	r26, 0x21	; 33
        // With AMASS is disabled, set timer prescaler for segments with slow step frequencies (< 250Hz).
        TCCR1B = (TCCR1B & ~(0x07<<CS10)) | (st.exec_segment->prescaler<<CS10);
      #endif

      // Initialize step segment timing per step and load number of steps to execute.
      OCR1A = st.exec_segment->cycles_per_tick;
    3270:	82 81       	ldd	r24, Z+2	; 0x02
    3272:	93 81       	ldd	r25, Z+3	; 0x03
    3274:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    3278:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
      st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
    327c:	80 81       	ld	r24, Z
    327e:	91 81       	ldd	r25, Z+1	; 0x01
    3280:	5d 96       	adiw	r26, 0x1d	; 29
    3282:	9c 93       	st	X, r25
    3284:	8e 93       	st	-X, r24
    3286:	5c 97       	sbiw	r26, 0x1c	; 28
      // If the new segment starts a new planner block, initialize stepper variables and counters.
      // NOTE: When the segment data index changes, this indicates a new planner block.
      if ( st.exec_block_index != st.exec_segment->st_block_index ) {
    3288:	84 81       	ldd	r24, Z+4	; 0x04
    328a:	5e 96       	adiw	r26, 0x1e	; 30
    328c:	9c 91       	ld	r25, X
    328e:	5e 97       	sbiw	r26, 0x1e	; 30
    3290:	98 17       	cp	r25, r24
    3292:	49 f1       	breq	.+82     	; 0x32e6 <__vector_17+0x10c>
        st.exec_block_index = st.exec_segment->st_block_index;
    3294:	ed 01       	movw	r28, r26
    3296:	8e 8f       	std	Y+30, r24	; 0x1e
        st.exec_block = &st_block_buffer[st.exec_block_index];
    3298:	90 e0       	ldi	r25, 0x00	; 0
    329a:	88 0f       	add	r24, r24
    329c:	99 1f       	adc	r25, r25
    329e:	dc 01       	movw	r26, r24
    32a0:	aa 0f       	add	r26, r26
    32a2:	bb 1f       	adc	r27, r27
    32a4:	aa 0f       	add	r26, r26
    32a6:	bb 1f       	adc	r27, r27
    32a8:	aa 0f       	add	r26, r26
    32aa:	bb 1f       	adc	r27, r27
    32ac:	8a 0f       	add	r24, r26
    32ae:	9b 1f       	adc	r25, r27
    32b0:	dc 01       	movw	r26, r24
    32b2:	aa 54       	subi	r26, 0x4A	; 74
    32b4:	bc 4f       	sbci	r27, 0xFC	; 252
    32b6:	b8 a3       	std	Y+32, r27	; 0x20
    32b8:	af 8f       	std	Y+31, r26	; 0x1f

        // Initialize Bresenham line and distance counters
        st.counter_x = st.counter_y = st.counter_z = (st.exec_block->step_event_count >> 1);
    32ba:	1c 96       	adiw	r26, 0x0c	; 12
    32bc:	8d 91       	ld	r24, X+
    32be:	9d 91       	ld	r25, X+
    32c0:	0d 90       	ld	r0, X+
    32c2:	bc 91       	ld	r27, X
    32c4:	a0 2d       	mov	r26, r0
    32c6:	b6 95       	lsr	r27
    32c8:	a7 95       	ror	r26
    32ca:	97 95       	ror	r25
    32cc:	87 95       	ror	r24
    32ce:	88 87       	std	Y+8, r24	; 0x08
    32d0:	99 87       	std	Y+9, r25	; 0x09
    32d2:	aa 87       	std	Y+10, r26	; 0x0a
    32d4:	bb 87       	std	Y+11, r27	; 0x0b
    32d6:	8c 83       	std	Y+4, r24	; 0x04
    32d8:	9d 83       	std	Y+5, r25	; 0x05
    32da:	ae 83       	std	Y+6, r26	; 0x06
    32dc:	bf 83       	std	Y+7, r27	; 0x07
    32de:	88 83       	st	Y, r24
    32e0:	99 83       	std	Y+1, r25	; 0x01
    32e2:	aa 83       	std	Y+2, r26	; 0x02
    32e4:	bb 83       	std	Y+3, r27	; 0x03
      }
      #ifdef DEFAULTS_RAMPS_BOARD
        for (i = 0; i < N_AXIS; i++)
          st.dir_outbits[i] = st.exec_block->direction_bits[i] ^ dir_port_invert_mask[i];
      #else
        st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask;
    32e6:	a3 e4       	ldi	r26, 0x43	; 67
    32e8:	b3 e0       	ldi	r27, 0x03	; 3
    32ea:	5f 96       	adiw	r26, 0x1f	; 31
    32ec:	cd 91       	ld	r28, X+
    32ee:	dc 91       	ld	r29, X
    32f0:	90 97       	sbiw	r26, 0x20	; 32
    32f2:	98 89       	ldd	r25, Y+16	; 0x10
    32f4:	80 91 3e 03 	lds	r24, 0x033E	; 0x80033e <dir_port_invert_mask>
    32f8:	89 27       	eor	r24, r25
    32fa:	1f 96       	adiw	r26, 0x0f	; 15
    32fc:	8c 93       	st	X, r24
    32fe:	1f 97       	sbiw	r26, 0x0f	; 15
      #endif // Ramps Board

      #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
        // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
        st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.exec_segment->amass_level;
    3300:	48 81       	ld	r20, Y
    3302:	59 81       	ldd	r21, Y+1	; 0x01
    3304:	6a 81       	ldd	r22, Y+2	; 0x02
    3306:	7b 81       	ldd	r23, Y+3	; 0x03
    3308:	05 80       	ldd	r0, Z+5	; 0x05
    330a:	04 c0       	rjmp	.+8      	; 0x3314 <__vector_17+0x13a>
    330c:	76 95       	lsr	r23
    330e:	67 95       	ror	r22
    3310:	57 95       	ror	r21
    3312:	47 95       	ror	r20
    3314:	0a 94       	dec	r0
    3316:	d2 f7       	brpl	.-12     	; 0x330c <__vector_17+0x132>
    3318:	50 96       	adiw	r26, 0x10	; 16
    331a:	4d 93       	st	X+, r20
    331c:	5d 93       	st	X+, r21
    331e:	6d 93       	st	X+, r22
    3320:	7c 93       	st	X, r23
    3322:	53 97       	sbiw	r26, 0x13	; 19
        st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.exec_segment->amass_level;
    3324:	4c 81       	ldd	r20, Y+4	; 0x04
    3326:	5d 81       	ldd	r21, Y+5	; 0x05
    3328:	6e 81       	ldd	r22, Y+6	; 0x06
    332a:	7f 81       	ldd	r23, Y+7	; 0x07
    332c:	05 80       	ldd	r0, Z+5	; 0x05
    332e:	04 c0       	rjmp	.+8      	; 0x3338 <__vector_17+0x15e>
    3330:	76 95       	lsr	r23
    3332:	67 95       	ror	r22
    3334:	57 95       	ror	r21
    3336:	47 95       	ror	r20
    3338:	0a 94       	dec	r0
    333a:	d2 f7       	brpl	.-12     	; 0x3330 <__vector_17+0x156>
    333c:	54 96       	adiw	r26, 0x14	; 20
    333e:	4d 93       	st	X+, r20
    3340:	5d 93       	st	X+, r21
    3342:	6d 93       	st	X+, r22
    3344:	7c 93       	st	X, r23
    3346:	57 97       	sbiw	r26, 0x17	; 23
        st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
    3348:	48 85       	ldd	r20, Y+8	; 0x08
    334a:	59 85       	ldd	r21, Y+9	; 0x09
    334c:	6a 85       	ldd	r22, Y+10	; 0x0a
    334e:	7b 85       	ldd	r23, Y+11	; 0x0b
    3350:	05 80       	ldd	r0, Z+5	; 0x05
    3352:	04 c0       	rjmp	.+8      	; 0x335c <__vector_17+0x182>
    3354:	76 95       	lsr	r23
    3356:	67 95       	ror	r22
    3358:	57 95       	ror	r21
    335a:	47 95       	ror	r20
    335c:	0a 94       	dec	r0
    335e:	d2 f7       	brpl	.-12     	; 0x3354 <__vector_17+0x17a>
    3360:	58 96       	adiw	r26, 0x18	; 24
    3362:	4d 93       	st	X+, r20
    3364:	5d 93       	st	X+, r21
    3366:	6d 93       	st	X+, r22
    3368:	7c 93       	st	X, r23
    336a:	5b 97       	sbiw	r26, 0x1b	; 27
      #endif

      // Set real-time spindle output as segment is loaded, just prior to the first step.
      spindle_set_speed(st.exec_segment->spindle_pwm);
    336c:	86 81       	ldd	r24, Z+6	; 0x06
    336e:	97 81       	ldd	r25, Z+7	; 0x07
    3370:	ad d8       	rcall	.-3750   	; 0x24cc <spindle_set_speed>
    3372:	0f c0       	rjmp	.+30     	; 0x3392 <__vector_17+0x1b8>

    } else {
      // Segment buffer empty. Shutdown.
      st_go_idle();
    3374:	04 df       	rcall	.-504    	; 0x317e <st_go_idle>
      // Ensure pwm is set properly upon completion of rate-controlled motion.
      if (st.exec_block->is_pwm_rate_adjusted) { spindle_set_speed(SPINDLE_PWM_OFF_VALUE); }
    3376:	e0 91 62 03 	lds	r30, 0x0362	; 0x800362 <st+0x1f>
    337a:	f0 91 63 03 	lds	r31, 0x0363	; 0x800363 <st+0x20>
    337e:	81 89       	ldd	r24, Z+17	; 0x11
    3380:	88 23       	and	r24, r24
    3382:	19 f0       	breq	.+6      	; 0x338a <__vector_17+0x1b0>
    3384:	80 e0       	ldi	r24, 0x00	; 0
    3386:	90 e0       	ldi	r25, 0x00	; 0
    3388:	a1 d8       	rcall	.-3774   	; 0x24cc <spindle_set_speed>
      system_set_exec_state_flag(EXEC_CYCLE_STOP); // Flag main program for cycle end
    338a:	84 e0       	ldi	r24, 0x04	; 4
    338c:	0e 94 f5 3a 	call	0x75ea	; 0x75ea <system_set_exec_state_flag>
      return; // Nothing to do but exit.
    3390:	0d c1       	rjmp	.+538    	; 0x35ac <__vector_17+0x3d2>
    }
  }


  // Check probing state.
  if (sys_probe_state == PROBE_ACTIVE) { probe_state_monitor(); }
    3392:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <sys_probe_state>
    3396:	81 30       	cpi	r24, 0x01	; 1
    3398:	11 f4       	brne	.+4      	; 0x339e <__vector_17+0x1c4>
    339a:	0e 94 69 34 	call	0x68d2	; 0x68d2 <probe_state_monitor>
  // Reset step out bits.
  #ifdef DEFAULTS_RAMPS_BOARD
    for (i = 0; i < N_AXIS; i++)
      st.step_outbits[i] = 0;
  #else
    st.step_outbits = 0;
    339e:	e3 e4       	ldi	r30, 0x43	; 67
    33a0:	f3 e0       	ldi	r31, 0x03	; 3
    33a2:	16 86       	std	Z+14, r1	; 0x0e
  #endif // Ramps Board

  // Execute step displacement profile by Bresenham line algorithm
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_x += st.steps[X_AXIS];
    33a4:	40 81       	ld	r20, Z
    33a6:	51 81       	ldd	r21, Z+1	; 0x01
    33a8:	62 81       	ldd	r22, Z+2	; 0x02
    33aa:	73 81       	ldd	r23, Z+3	; 0x03
    33ac:	80 89       	ldd	r24, Z+16	; 0x10
    33ae:	91 89       	ldd	r25, Z+17	; 0x11
    33b0:	a2 89       	ldd	r26, Z+18	; 0x12
    33b2:	b3 89       	ldd	r27, Z+19	; 0x13
    33b4:	84 0f       	add	r24, r20
    33b6:	95 1f       	adc	r25, r21
    33b8:	a6 1f       	adc	r26, r22
    33ba:	b7 1f       	adc	r27, r23
    33bc:	80 83       	st	Z, r24
    33be:	91 83       	std	Z+1, r25	; 0x01
    33c0:	a2 83       	std	Z+2, r26	; 0x02
    33c2:	b3 83       	std	Z+3, r27	; 0x03
      st.counter_x -= st.exec_block->step_event_count;
      if (st.exec_block->direction_bits[X_AXIS] & (1<<DIRECTION_BIT(X_AXIS))) { sys_position[X_AXIS]--; }
      else { sys_position[X_AXIS]++; }
    }
  #else
    if (st.counter_x > st.exec_block->step_event_count) {
    33c4:	07 8c       	ldd	r0, Z+31	; 0x1f
    33c6:	f0 a1       	ldd	r31, Z+32	; 0x20
    33c8:	e0 2d       	mov	r30, r0
    33ca:	44 85       	ldd	r20, Z+12	; 0x0c
    33cc:	55 85       	ldd	r21, Z+13	; 0x0d
    33ce:	66 85       	ldd	r22, Z+14	; 0x0e
    33d0:	77 85       	ldd	r23, Z+15	; 0x0f
    33d2:	48 17       	cp	r20, r24
    33d4:	59 07       	cpc	r21, r25
    33d6:	6a 07       	cpc	r22, r26
    33d8:	7b 07       	cpc	r23, r27
    33da:	70 f5       	brcc	.+92     	; 0x3438 <__vector_17+0x25e>
      st.step_outbits |= (1<<X_STEP_BIT);
    33dc:	c3 e4       	ldi	r28, 0x43	; 67
    33de:	d3 e0       	ldi	r29, 0x03	; 3
    33e0:	24 e0       	ldi	r18, 0x04	; 4
    33e2:	2e 87       	std	Y+14, r18	; 0x0e
      st.counter_x -= st.exec_block->step_event_count;
    33e4:	44 85       	ldd	r20, Z+12	; 0x0c
    33e6:	55 85       	ldd	r21, Z+13	; 0x0d
    33e8:	66 85       	ldd	r22, Z+14	; 0x0e
    33ea:	77 85       	ldd	r23, Z+15	; 0x0f
    33ec:	84 1b       	sub	r24, r20
    33ee:	95 0b       	sbc	r25, r21
    33f0:	a6 0b       	sbc	r26, r22
    33f2:	b7 0b       	sbc	r27, r23
    33f4:	88 83       	st	Y, r24
    33f6:	99 83       	std	Y+1, r25	; 0x01
    33f8:	aa 83       	std	Y+2, r26	; 0x02
    33fa:	bb 83       	std	Y+3, r27	; 0x03
      if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys_position[X_AXIS]--; }
    33fc:	80 89       	ldd	r24, Z+16	; 0x10
    33fe:	88 23       	and	r24, r24
    3400:	74 f4       	brge	.+28     	; 0x341e <__vector_17+0x244>
    3402:	c7 e3       	ldi	r28, 0x37	; 55
    3404:	dc e0       	ldi	r29, 0x0C	; 12
    3406:	88 81       	ld	r24, Y
    3408:	99 81       	ldd	r25, Y+1	; 0x01
    340a:	aa 81       	ldd	r26, Y+2	; 0x02
    340c:	bb 81       	ldd	r27, Y+3	; 0x03
    340e:	01 97       	sbiw	r24, 0x01	; 1
    3410:	a1 09       	sbc	r26, r1
    3412:	b1 09       	sbc	r27, r1
    3414:	88 83       	st	Y, r24
    3416:	99 83       	std	Y+1, r25	; 0x01
    3418:	aa 83       	std	Y+2, r26	; 0x02
    341a:	bb 83       	std	Y+3, r27	; 0x03
    341c:	0d c0       	rjmp	.+26     	; 0x3438 <__vector_17+0x25e>
      else { sys_position[X_AXIS]++; }
    341e:	c7 e3       	ldi	r28, 0x37	; 55
    3420:	dc e0       	ldi	r29, 0x0C	; 12
    3422:	88 81       	ld	r24, Y
    3424:	99 81       	ldd	r25, Y+1	; 0x01
    3426:	aa 81       	ldd	r26, Y+2	; 0x02
    3428:	bb 81       	ldd	r27, Y+3	; 0x03
    342a:	01 96       	adiw	r24, 0x01	; 1
    342c:	a1 1d       	adc	r26, r1
    342e:	b1 1d       	adc	r27, r1
    3430:	88 83       	st	Y, r24
    3432:	99 83       	std	Y+1, r25	; 0x01
    3434:	aa 83       	std	Y+2, r26	; 0x02
    3436:	bb 83       	std	Y+3, r27	; 0x03
    }
  #endif // Ramps Board

  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_y += st.steps[Y_AXIS];
    3438:	c3 e4       	ldi	r28, 0x43	; 67
    343a:	d3 e0       	ldi	r29, 0x03	; 3
    343c:	4c 81       	ldd	r20, Y+4	; 0x04
    343e:	5d 81       	ldd	r21, Y+5	; 0x05
    3440:	6e 81       	ldd	r22, Y+6	; 0x06
    3442:	7f 81       	ldd	r23, Y+7	; 0x07
    3444:	8c 89       	ldd	r24, Y+20	; 0x14
    3446:	9d 89       	ldd	r25, Y+21	; 0x15
    3448:	ae 89       	ldd	r26, Y+22	; 0x16
    344a:	bf 89       	ldd	r27, Y+23	; 0x17
    344c:	84 0f       	add	r24, r20
    344e:	95 1f       	adc	r25, r21
    3450:	a6 1f       	adc	r26, r22
    3452:	b7 1f       	adc	r27, r23
    3454:	8c 83       	std	Y+4, r24	; 0x04
    3456:	9d 83       	std	Y+5, r25	; 0x05
    3458:	ae 83       	std	Y+6, r26	; 0x06
    345a:	bf 83       	std	Y+7, r27	; 0x07
      st.counter_y -= st.exec_block->step_event_count;
      if (st.exec_block->direction_bits[Y_AXIS] & (1<<DIRECTION_BIT(Y_AXIS))) { sys_position[Y_AXIS]--; }
      else { sys_position[Y_AXIS]++; }
    }
  #else
    if (st.counter_y > st.exec_block->step_event_count) {
    345c:	44 85       	ldd	r20, Z+12	; 0x0c
    345e:	55 85       	ldd	r21, Z+13	; 0x0d
    3460:	66 85       	ldd	r22, Z+14	; 0x0e
    3462:	77 85       	ldd	r23, Z+15	; 0x0f
    3464:	48 17       	cp	r20, r24
    3466:	59 07       	cpc	r21, r25
    3468:	6a 07       	cpc	r22, r26
    346a:	7b 07       	cpc	r23, r27
    346c:	68 f5       	brcc	.+90     	; 0x34c8 <__vector_17+0x2ee>
      st.step_outbits |= (1<<Y_STEP_BIT);
    346e:	2e 85       	ldd	r18, Y+14	; 0x0e
    3470:	28 60       	ori	r18, 0x08	; 8
    3472:	2e 87       	std	Y+14, r18	; 0x0e
      st.counter_y -= st.exec_block->step_event_count;
    3474:	44 85       	ldd	r20, Z+12	; 0x0c
    3476:	55 85       	ldd	r21, Z+13	; 0x0d
    3478:	66 85       	ldd	r22, Z+14	; 0x0e
    347a:	77 85       	ldd	r23, Z+15	; 0x0f
    347c:	84 1b       	sub	r24, r20
    347e:	95 0b       	sbc	r25, r21
    3480:	a6 0b       	sbc	r26, r22
    3482:	b7 0b       	sbc	r27, r23
    3484:	8c 83       	std	Y+4, r24	; 0x04
    3486:	9d 83       	std	Y+5, r25	; 0x05
    3488:	ae 83       	std	Y+6, r26	; 0x06
    348a:	bf 83       	std	Y+7, r27	; 0x07
      if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys_position[Y_AXIS]--; }
    348c:	80 89       	ldd	r24, Z+16	; 0x10
    348e:	86 ff       	sbrs	r24, 6
    3490:	0e c0       	rjmp	.+28     	; 0x34ae <__vector_17+0x2d4>
    3492:	c7 e3       	ldi	r28, 0x37	; 55
    3494:	dc e0       	ldi	r29, 0x0C	; 12
    3496:	8c 81       	ldd	r24, Y+4	; 0x04
    3498:	9d 81       	ldd	r25, Y+5	; 0x05
    349a:	ae 81       	ldd	r26, Y+6	; 0x06
    349c:	bf 81       	ldd	r27, Y+7	; 0x07
    349e:	01 97       	sbiw	r24, 0x01	; 1
    34a0:	a1 09       	sbc	r26, r1
    34a2:	b1 09       	sbc	r27, r1
    34a4:	8c 83       	std	Y+4, r24	; 0x04
    34a6:	9d 83       	std	Y+5, r25	; 0x05
    34a8:	ae 83       	std	Y+6, r26	; 0x06
    34aa:	bf 83       	std	Y+7, r27	; 0x07
    34ac:	0d c0       	rjmp	.+26     	; 0x34c8 <__vector_17+0x2ee>
      else { sys_position[Y_AXIS]++; }
    34ae:	c7 e3       	ldi	r28, 0x37	; 55
    34b0:	dc e0       	ldi	r29, 0x0C	; 12
    34b2:	8c 81       	ldd	r24, Y+4	; 0x04
    34b4:	9d 81       	ldd	r25, Y+5	; 0x05
    34b6:	ae 81       	ldd	r26, Y+6	; 0x06
    34b8:	bf 81       	ldd	r27, Y+7	; 0x07
    34ba:	01 96       	adiw	r24, 0x01	; 1
    34bc:	a1 1d       	adc	r26, r1
    34be:	b1 1d       	adc	r27, r1
    34c0:	8c 83       	std	Y+4, r24	; 0x04
    34c2:	9d 83       	std	Y+5, r25	; 0x05
    34c4:	ae 83       	std	Y+6, r26	; 0x06
    34c6:	bf 83       	std	Y+7, r27	; 0x07
    }
  #endif // Ramps Board
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_z += st.steps[Z_AXIS];
    34c8:	c3 e4       	ldi	r28, 0x43	; 67
    34ca:	d3 e0       	ldi	r29, 0x03	; 3
    34cc:	48 85       	ldd	r20, Y+8	; 0x08
    34ce:	59 85       	ldd	r21, Y+9	; 0x09
    34d0:	6a 85       	ldd	r22, Y+10	; 0x0a
    34d2:	7b 85       	ldd	r23, Y+11	; 0x0b
    34d4:	88 8d       	ldd	r24, Y+24	; 0x18
    34d6:	99 8d       	ldd	r25, Y+25	; 0x19
    34d8:	aa 8d       	ldd	r26, Y+26	; 0x1a
    34da:	bb 8d       	ldd	r27, Y+27	; 0x1b
    34dc:	84 0f       	add	r24, r20
    34de:	95 1f       	adc	r25, r21
    34e0:	a6 1f       	adc	r26, r22
    34e2:	b7 1f       	adc	r27, r23
    34e4:	88 87       	std	Y+8, r24	; 0x08
    34e6:	99 87       	std	Y+9, r25	; 0x09
    34e8:	aa 87       	std	Y+10, r26	; 0x0a
    34ea:	bb 87       	std	Y+11, r27	; 0x0b
      st.counter_z -= st.exec_block->step_event_count;
      if (st.exec_block->direction_bits[Z_AXIS] & (1<<DIRECTION_BIT(Z_AXIS))) { sys_position[Z_AXIS]--; }
      else { sys_position[Z_AXIS]++; }
    }
  #else
    if (st.counter_z > st.exec_block->step_event_count) {
    34ec:	44 85       	ldd	r20, Z+12	; 0x0c
    34ee:	55 85       	ldd	r21, Z+13	; 0x0d
    34f0:	66 85       	ldd	r22, Z+14	; 0x0e
    34f2:	77 85       	ldd	r23, Z+15	; 0x0f
    34f4:	48 17       	cp	r20, r24
    34f6:	59 07       	cpc	r21, r25
    34f8:	6a 07       	cpc	r22, r26
    34fa:	7b 07       	cpc	r23, r27
    34fc:	68 f5       	brcc	.+90     	; 0x3558 <__vector_17+0x37e>
      st.step_outbits |= (1<<Z_STEP_BIT);
    34fe:	2e 85       	ldd	r18, Y+14	; 0x0e
    3500:	20 61       	ori	r18, 0x10	; 16
    3502:	2e 87       	std	Y+14, r18	; 0x0e
      st.counter_z -= st.exec_block->step_event_count;
    3504:	44 85       	ldd	r20, Z+12	; 0x0c
    3506:	55 85       	ldd	r21, Z+13	; 0x0d
    3508:	66 85       	ldd	r22, Z+14	; 0x0e
    350a:	77 85       	ldd	r23, Z+15	; 0x0f
    350c:	84 1b       	sub	r24, r20
    350e:	95 0b       	sbc	r25, r21
    3510:	a6 0b       	sbc	r26, r22
    3512:	b7 0b       	sbc	r27, r23
    3514:	88 87       	std	Y+8, r24	; 0x08
    3516:	99 87       	std	Y+9, r25	; 0x09
    3518:	aa 87       	std	Y+10, r26	; 0x0a
    351a:	bb 87       	std	Y+11, r27	; 0x0b
      if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys_position[Z_AXIS]--; }
    351c:	80 89       	ldd	r24, Z+16	; 0x10
    351e:	85 ff       	sbrs	r24, 5
    3520:	0e c0       	rjmp	.+28     	; 0x353e <__vector_17+0x364>
    3522:	e7 e3       	ldi	r30, 0x37	; 55
    3524:	fc e0       	ldi	r31, 0x0C	; 12
    3526:	80 85       	ldd	r24, Z+8	; 0x08
    3528:	91 85       	ldd	r25, Z+9	; 0x09
    352a:	a2 85       	ldd	r26, Z+10	; 0x0a
    352c:	b3 85       	ldd	r27, Z+11	; 0x0b
    352e:	01 97       	sbiw	r24, 0x01	; 1
    3530:	a1 09       	sbc	r26, r1
    3532:	b1 09       	sbc	r27, r1
    3534:	80 87       	std	Z+8, r24	; 0x08
    3536:	91 87       	std	Z+9, r25	; 0x09
    3538:	a2 87       	std	Z+10, r26	; 0x0a
    353a:	b3 87       	std	Z+11, r27	; 0x0b
    353c:	0d c0       	rjmp	.+26     	; 0x3558 <__vector_17+0x37e>
      else { sys_position[Z_AXIS]++; }
    353e:	e7 e3       	ldi	r30, 0x37	; 55
    3540:	fc e0       	ldi	r31, 0x0C	; 12
    3542:	80 85       	ldd	r24, Z+8	; 0x08
    3544:	91 85       	ldd	r25, Z+9	; 0x09
    3546:	a2 85       	ldd	r26, Z+10	; 0x0a
    3548:	b3 85       	ldd	r27, Z+11	; 0x0b
    354a:	01 96       	adiw	r24, 0x01	; 1
    354c:	a1 1d       	adc	r26, r1
    354e:	b1 1d       	adc	r27, r1
    3550:	80 87       	std	Z+8, r24	; 0x08
    3552:	91 87       	std	Z+9, r25	; 0x09
    3554:	a2 87       	std	Z+10, r26	; 0x0a
    3556:	b3 87       	std	Z+11, r27	; 0x0b
  // During a homing cycle, lock out and prevent desired axes from moving.
  #ifdef DEFAULTS_RAMPS_BOARD
    for (i = 0; i < N_AXIS; i++)
    if (sys.state == STATE_HOMING) { st.step_outbits[i] &= sys.homing_axis_lock[i]; }
  #else
    if (sys.state == STATE_HOMING) { st.step_outbits &= sys.homing_axis_lock; }
    3558:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
    355c:	84 30       	cpi	r24, 0x04	; 4
    355e:	39 f4       	brne	.+14     	; 0x356e <__vector_17+0x394>
    3560:	e3 e4       	ldi	r30, 0x43	; 67
    3562:	f3 e0       	ldi	r31, 0x03	; 3
    3564:	96 85       	ldd	r25, Z+14	; 0x0e
    3566:	80 91 1c 0c 	lds	r24, 0x0C1C	; 0x800c1c <sys+0x6>
    356a:	89 23       	and	r24, r25
    356c:	86 87       	std	Z+14, r24	; 0x0e
  #endif // Ramps Board
  st.step_count--; // Decrement step events count
    356e:	e3 e4       	ldi	r30, 0x43	; 67
    3570:	f3 e0       	ldi	r31, 0x03	; 3
    3572:	84 8d       	ldd	r24, Z+28	; 0x1c
    3574:	95 8d       	ldd	r25, Z+29	; 0x1d
    3576:	01 97       	sbiw	r24, 0x01	; 1
    3578:	95 8f       	std	Z+29, r25	; 0x1d
    357a:	84 8f       	std	Z+28, r24	; 0x1c
  if (st.step_count == 0) {
    357c:	89 2b       	or	r24, r25
    357e:	69 f4       	brne	.+26     	; 0x359a <__vector_17+0x3c0>
    // Segment is complete. Discard current segment and advance segment indexing.
    st.exec_segment = NULL;
    3580:	10 92 65 03 	sts	0x0365, r1	; 0x800365 <st+0x22>
    3584:	10 92 64 03 	sts	0x0364, r1	; 0x800364 <st+0x21>
    if ( ++segment_buffer_tail == SEGMENT_BUFFER_SIZE) { segment_buffer_tail = 0; }
    3588:	80 91 42 03 	lds	r24, 0x0342	; 0x800342 <segment_buffer_tail>
    358c:	8f 5f       	subi	r24, 0xFF	; 255
    358e:	80 93 42 03 	sts	0x0342, r24	; 0x800342 <segment_buffer_tail>
    3592:	8a 30       	cpi	r24, 0x0A	; 10
    3594:	11 f4       	brne	.+4      	; 0x359a <__vector_17+0x3c0>
    3596:	10 92 42 03 	sts	0x0342, r1	; 0x800342 <segment_buffer_tail>
  }
  #ifdef DEFAULTS_RAMPS_BOARD
    for (i = 0; i < N_AXIS; i++)
      st.step_outbits[i] ^= step_port_invert_mask[i];  // Apply step port invert mask
  #else
    st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask
    359a:	e3 e4       	ldi	r30, 0x43	; 67
    359c:	f3 e0       	ldi	r31, 0x03	; 3
    359e:	96 85       	ldd	r25, Z+14	; 0x0e
    35a0:	80 91 3f 03 	lds	r24, 0x033F	; 0x80033f <step_port_invert_mask>
    35a4:	89 27       	eor	r24, r25
    35a6:	86 87       	std	Z+14, r24	; 0x0e
  #endif // Ramps Board
  busy = false;
    35a8:	10 92 3d 03 	sts	0x033D, r1	; 0x80033d <busy>
}
    35ac:	ff 91       	pop	r31
    35ae:	ef 91       	pop	r30
    35b0:	df 91       	pop	r29
    35b2:	cf 91       	pop	r28
    35b4:	bf 91       	pop	r27
    35b6:	af 91       	pop	r26
    35b8:	9f 91       	pop	r25
    35ba:	8f 91       	pop	r24
    35bc:	7f 91       	pop	r23
    35be:	6f 91       	pop	r22
    35c0:	5f 91       	pop	r21
    35c2:	4f 91       	pop	r20
    35c4:	3f 91       	pop	r19
    35c6:	2f 91       	pop	r18
    35c8:	0f 90       	pop	r0
    35ca:	0b be       	out	0x3b, r0	; 59
    35cc:	0f 90       	pop	r0
    35ce:	0f be       	out	0x3f, r0	; 63
    35d0:	0f 90       	pop	r0
    35d2:	1f 90       	pop	r1
    35d4:	18 95       	reti

000035d6 <__vector_23>:
*/
// This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute
// a step. This ISR resets the motor port after a short period (settings.pulse_microseconds)
// completing one step cycle.
ISR(TIMER0_OVF_vect)
{
    35d6:	1f 92       	push	r1
    35d8:	0f 92       	push	r0
    35da:	0f b6       	in	r0, 0x3f	; 63
    35dc:	0f 92       	push	r0
    35de:	11 24       	eor	r1, r1
    35e0:	8f 93       	push	r24
    35e2:	9f 93       	push	r25
  #ifdef DEFAULTS_RAMPS_BOARD
    STEP_PORT(0) = (STEP_PORT(0) & ~(1 << STEP_BIT(0))) | step_port_invert_mask[0];
    STEP_PORT(1) = (STEP_PORT(1) & ~(1 << STEP_BIT(1))) | step_port_invert_mask[1];
    STEP_PORT(2) = (STEP_PORT(2) & ~(1 << STEP_BIT(2))) | step_port_invert_mask[2];
  #else
    STEP_PORT = (STEP_PORT & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK);
    35e4:	82 b1       	in	r24, 0x02	; 2
    35e6:	90 91 3f 03 	lds	r25, 0x033F	; 0x80033f <step_port_invert_mask>
    35ea:	9c 71       	andi	r25, 0x1C	; 28
    35ec:	83 7e       	andi	r24, 0xE3	; 227
    35ee:	89 2b       	or	r24, r25
    35f0:	82 b9       	out	0x02, r24	; 2
  #endif // Ramps Board
  TCCR0B = 0; // Disable Timer0 to prevent re-entering this interrupt when it's not needed.
    35f2:	15 bc       	out	0x25, r1	; 37
}
    35f4:	9f 91       	pop	r25
    35f6:	8f 91       	pop	r24
    35f8:	0f 90       	pop	r0
    35fa:	0f be       	out	0x3f, r0	; 63
    35fc:	0f 90       	pop	r0
    35fe:	1f 90       	pop	r1
    3600:	18 95       	reti

00003602 <st_generate_step_dir_invert_masks>:
#endif


// Generates the step and direction port invert masks used in the Stepper Interrupt Driver.
void st_generate_step_dir_invert_masks()
{
    3602:	ef 92       	push	r14
    3604:	ff 92       	push	r15
    3606:	0f 93       	push	r16
    3608:	1f 93       	push	r17
    360a:	cf 93       	push	r28
    360c:	df 93       	push	r29

      if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask[idx] = get_direction_pin_mask(idx); }
      else { dir_port_invert_mask[idx] = 0; }
    }
  #else
    step_port_invert_mask = 0;
    360e:	10 92 3f 03 	sts	0x033F, r1	; 0x80033f <step_port_invert_mask>
    dir_port_invert_mask = 0;
    3612:	10 92 3e 03 	sts	0x033E, r1	; 0x80033e <dir_port_invert_mask>
    3616:	c0 e0       	ldi	r28, 0x00	; 0
    3618:	d0 e0       	ldi	r29, 0x00	; 0
    for (idx=0; idx<N_AXIS; idx++) {
      if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    361a:	00 ec       	ldi	r16, 0xC0	; 192
    361c:	1e e0       	ldi	r17, 0x0E	; 14
    361e:	ec 2e       	mov	r14, r28
    3620:	fc 2e       	mov	r15, r28
    3622:	f8 01       	movw	r30, r16
    3624:	81 a9       	ldd	r24, Z+49	; 0x31
    3626:	90 e0       	ldi	r25, 0x00	; 0
    3628:	0c 2e       	mov	r0, r28
    362a:	02 c0       	rjmp	.+4      	; 0x3630 <st_generate_step_dir_invert_masks+0x2e>
    362c:	95 95       	asr	r25
    362e:	87 95       	ror	r24
    3630:	0a 94       	dec	r0
    3632:	e2 f7       	brpl	.-8      	; 0x362c <st_generate_step_dir_invert_masks+0x2a>
    3634:	80 ff       	sbrs	r24, 0
    3636:	08 c0       	rjmp	.+16     	; 0x3648 <st_generate_step_dir_invert_masks+0x46>
    3638:	8c 2f       	mov	r24, r28
    363a:	0e 94 39 27 	call	0x4e72	; 0x4e72 <get_step_pin_mask>
    363e:	90 91 3f 03 	lds	r25, 0x033F	; 0x80033f <step_port_invert_mask>
    3642:	89 2b       	or	r24, r25
    3644:	80 93 3f 03 	sts	0x033F, r24	; 0x80033f <step_port_invert_mask>
      if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    3648:	f8 01       	movw	r30, r16
    364a:	82 a9       	ldd	r24, Z+50	; 0x32
    364c:	90 e0       	ldi	r25, 0x00	; 0
    364e:	02 c0       	rjmp	.+4      	; 0x3654 <st_generate_step_dir_invert_masks+0x52>
    3650:	95 95       	asr	r25
    3652:	87 95       	ror	r24
    3654:	fa 94       	dec	r15
    3656:	e2 f7       	brpl	.-8      	; 0x3650 <st_generate_step_dir_invert_masks+0x4e>
    3658:	80 ff       	sbrs	r24, 0
    365a:	08 c0       	rjmp	.+16     	; 0x366c <st_generate_step_dir_invert_masks+0x6a>
    365c:	8e 2d       	mov	r24, r14
    365e:	0e 94 43 27 	call	0x4e86	; 0x4e86 <get_direction_pin_mask>
    3662:	90 91 3e 03 	lds	r25, 0x033E	; 0x80033e <dir_port_invert_mask>
    3666:	89 2b       	or	r24, r25
    3668:	80 93 3e 03 	sts	0x033E, r24	; 0x80033e <dir_port_invert_mask>
    366c:	21 96       	adiw	r28, 0x01	; 1
      else { dir_port_invert_mask[idx] = 0; }
    }
  #else
    step_port_invert_mask = 0;
    dir_port_invert_mask = 0;
    for (idx=0; idx<N_AXIS; idx++) {
    366e:	c3 30       	cpi	r28, 0x03	; 3
    3670:	d1 05       	cpc	r29, r1
    3672:	a9 f6       	brne	.-86     	; 0x361e <st_generate_step_dir_invert_masks+0x1c>
      if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
      if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    }
  #endif // Ramps Board
}
    3674:	df 91       	pop	r29
    3676:	cf 91       	pop	r28
    3678:	1f 91       	pop	r17
    367a:	0f 91       	pop	r16
    367c:	ff 90       	pop	r15
    367e:	ef 90       	pop	r14
    3680:	08 95       	ret

00003682 <st_reset>:


// Reset and clear stepper subsystem variables
void st_reset()
{
    3682:	cf 93       	push	r28
    3684:	df 93       	push	r29
  #ifdef DEFAULTS_RAMPS_BOARD
    uint8_t idx;
  #endif // Ramps Board

  // Initialize stepper driver idle state.
  st_go_idle();
    3686:	7b dd       	rcall	.-1290   	; 0x317e <st_go_idle>

  // Initialize stepper algorithm variables.
  memset(&prep, 0, sizeof(st_prep_t));
    3688:	81 e3       	ldi	r24, 0x31	; 49
    368a:	e8 e0       	ldi	r30, 0x08	; 8
    368c:	f3 e0       	ldi	r31, 0x03	; 3
    368e:	df 01       	movw	r26, r30
    3690:	1d 92       	st	X+, r1
    3692:	8a 95       	dec	r24
    3694:	e9 f7       	brne	.-6      	; 0x3690 <st_reset+0xe>
  memset(&st, 0, sizeof(stepper_t));
    3696:	c3 e4       	ldi	r28, 0x43	; 67
    3698:	d3 e0       	ldi	r29, 0x03	; 3
    369a:	83 e2       	ldi	r24, 0x23	; 35
    369c:	fe 01       	movw	r30, r28
    369e:	11 92       	st	Z+, r1
    36a0:	8a 95       	dec	r24
    36a2:	e9 f7       	brne	.-6      	; 0x369e <st_reset+0x1c>
  st.exec_segment = NULL;
  pl_block = NULL;  // Planner block pointer used by segment buffer
    36a4:	10 92 3c 03 	sts	0x033C, r1	; 0x80033c <pl_block+0x1>
    36a8:	10 92 3b 03 	sts	0x033B, r1	; 0x80033b <pl_block>
  segment_buffer_tail = 0;
    36ac:	10 92 42 03 	sts	0x0342, r1	; 0x800342 <segment_buffer_tail>
  segment_buffer_head = 0; // empty = tail
    36b0:	10 92 41 03 	sts	0x0341, r1	; 0x800341 <segment_buffer_head>
  segment_next_head = 1;
    36b4:	81 e0       	ldi	r24, 0x01	; 1
    36b6:	80 93 40 03 	sts	0x0340, r24	; 0x800340 <segment_next_head>
  busy = false;
    36ba:	10 92 3d 03 	sts	0x033D, r1	; 0x80033d <busy>

  st_generate_step_dir_invert_masks();
    36be:	a1 df       	rcall	.-190    	; 0x3602 <st_generate_step_dir_invert_masks>
    DIRECTION_PORT(1) = (DIRECTION_PORT(1) & ~(1 << DIRECTION_BIT(1))) | dir_port_invert_mask[1];
  
    STEP_PORT(2) = (STEP_PORT(2) & ~(1 << STEP_BIT(2))) | step_port_invert_mask[2];
    DIRECTION_PORT(2) = (DIRECTION_PORT(2) & ~(1 << DIRECTION_BIT(2))) | dir_port_invert_mask[2];
  #else
    st.dir_outbits = dir_port_invert_mask; // Initialize direction bits to default.
    36c0:	80 91 3e 03 	lds	r24, 0x033E	; 0x80033e <dir_port_invert_mask>
    36c4:	8f 87       	std	Y+15, r24	; 0x0f

    // Initialize step and direction port pins.
    STEP_PORT = (STEP_PORT & ~STEP_MASK) | step_port_invert_mask;
    36c6:	82 b1       	in	r24, 0x02	; 2
    36c8:	83 7e       	andi	r24, 0xE3	; 227
    36ca:	90 91 3f 03 	lds	r25, 0x033F	; 0x80033f <step_port_invert_mask>
    36ce:	89 2b       	or	r24, r25
    36d0:	82 b9       	out	0x02, r24	; 2
    DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | dir_port_invert_mask;
    36d2:	88 b1       	in	r24, 0x08	; 8
    36d4:	8f 71       	andi	r24, 0x1F	; 31
    36d6:	90 91 3e 03 	lds	r25, 0x033E	; 0x80033e <dir_port_invert_mask>
    36da:	89 2b       	or	r24, r25
    36dc:	88 b9       	out	0x08, r24	; 8
  #endif // Ramps Board
}
    36de:	df 91       	pop	r29
    36e0:	cf 91       	pop	r28
    36e2:	08 95       	ret

000036e4 <stepper_init>:
  
    DIRECTION_DDR(0) |= 1<<DIRECTION_BIT(0);
    DIRECTION_DDR(1) |= 1<<DIRECTION_BIT(1);
    DIRECTION_DDR(2) |= 1<<DIRECTION_BIT(2);
  #else
    STEP_DDR |= STEP_MASK;
    36e4:	81 b1       	in	r24, 0x01	; 1
    36e6:	8c 61       	ori	r24, 0x1C	; 28
    36e8:	81 b9       	out	0x01, r24	; 1
    STEPPERS_DISABLE_DDR |= 1<<STEPPERS_DISABLE_BIT;
    36ea:	27 9a       	sbi	0x04, 7	; 4
    DIRECTION_DDR |= DIRECTION_MASK;
    36ec:	87 b1       	in	r24, 0x07	; 7
    36ee:	80 6e       	ori	r24, 0xE0	; 224
    36f0:	87 b9       	out	0x07, r24	; 7
  #endif // Ramps Board

  // Configure Timer 1: Stepper Driver Interrupt
  TCCR1B &= ~(1<<WGM13); // waveform generation = 0100 = CTC
    36f2:	e1 e8       	ldi	r30, 0x81	; 129
    36f4:	f0 e0       	ldi	r31, 0x00	; 0
    36f6:	80 81       	ld	r24, Z
    36f8:	8f 7e       	andi	r24, 0xEF	; 239
    36fa:	80 83       	st	Z, r24
  TCCR1B |=  (1<<WGM12);
    36fc:	80 81       	ld	r24, Z
    36fe:	88 60       	ori	r24, 0x08	; 8
    3700:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<WGM11) | (1<<WGM10));
    3702:	e0 e8       	ldi	r30, 0x80	; 128
    3704:	f0 e0       	ldi	r31, 0x00	; 0
    3706:	80 81       	ld	r24, Z
    3708:	8c 7f       	andi	r24, 0xFC	; 252
    370a:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<COM1A1) | (1<<COM1A0) | (1<<COM1B1) | (1<<COM1B0)); // Disconnect OC1 output
    370c:	80 81       	ld	r24, Z
    370e:	8f 70       	andi	r24, 0x0F	; 15
    3710:	80 83       	st	Z, r24
  // TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Set in st_go_idle().
  // TIMSK1 &= ~(1<<OCIE1A);  // Set in st_go_idle().

  // Configure Timer 0: Stepper Port Reset Interrupt
  TIMSK0 &= ~((1<<OCIE0B) | (1<<OCIE0A) | (1<<TOIE0)); // Disconnect OC0 outputs and OVF interrupt.
    3712:	ee e6       	ldi	r30, 0x6E	; 110
    3714:	f0 e0       	ldi	r31, 0x00	; 0
    3716:	80 81       	ld	r24, Z
    3718:	88 7f       	andi	r24, 0xF8	; 248
    371a:	80 83       	st	Z, r24
  TCCR0A = 0; // Normal operation
    371c:	14 bc       	out	0x24, r1	; 36
  TCCR0B = 0; // Disable Timer0 until needed
    371e:	15 bc       	out	0x25, r1	; 37
  TIMSK0 |= (1<<TOIE0); // Enable Timer0 overflow interrupt
    3720:	80 81       	ld	r24, Z
    3722:	81 60       	ori	r24, 0x01	; 1
    3724:	80 83       	st	Z, r24
    3726:	08 95       	ret

00003728 <st_update_plan_block_parameters>:
}


// Called by planner_recalculate() when the executing block is updated by the new plan.
void st_update_plan_block_parameters()
{
    3728:	cf 93       	push	r28
    372a:	df 93       	push	r29
  if (pl_block != NULL) { // Ignore if at start of a new block.
    372c:	c0 91 3b 03 	lds	r28, 0x033B	; 0x80033b <pl_block>
    3730:	d0 91 3c 03 	lds	r29, 0x033C	; 0x80033c <pl_block+0x1>
    3734:	20 97       	sbiw	r28, 0x00	; 0
    3736:	a9 f0       	breq	.+42     	; 0x3762 <st_update_plan_block_parameters+0x3a>
    prep.recalculate_flag |= PREP_FLAG_RECALCULATE;
    3738:	e8 e0       	ldi	r30, 0x08	; 8
    373a:	f3 e0       	ldi	r31, 0x03	; 3
    373c:	81 81       	ldd	r24, Z+1	; 0x01
    373e:	81 60       	ori	r24, 0x01	; 1
    3740:	81 83       	std	Z+1, r24	; 0x01
    pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
    3742:	67 89       	ldd	r22, Z+23	; 0x17
    3744:	70 8d       	ldd	r23, Z+24	; 0x18
    3746:	81 8d       	ldd	r24, Z+25	; 0x19
    3748:	92 8d       	ldd	r25, Z+26	; 0x1a
    374a:	9b 01       	movw	r18, r22
    374c:	ac 01       	movw	r20, r24
    374e:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    3752:	6e 8b       	std	Y+22, r22	; 0x16
    3754:	7f 8b       	std	Y+23, r23	; 0x17
    3756:	88 8f       	std	Y+24, r24	; 0x18
    3758:	99 8f       	std	Y+25, r25	; 0x19
    pl_block = NULL; // Flag st_prep_segment() to load and check active velocity profile.
    375a:	10 92 3c 03 	sts	0x033C, r1	; 0x80033c <pl_block+0x1>
    375e:	10 92 3b 03 	sts	0x033B, r1	; 0x80033b <pl_block>
  }
}
    3762:	df 91       	pop	r29
    3764:	cf 91       	pop	r28
    3766:	08 95       	ret

00003768 <st_prep_buffer>:
   longer than the time it takes the stepper algorithm to empty it before refilling it.
   Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer()
{
    3768:	2f 92       	push	r2
    376a:	3f 92       	push	r3
    376c:	4f 92       	push	r4
    376e:	5f 92       	push	r5
    3770:	6f 92       	push	r6
    3772:	7f 92       	push	r7
    3774:	8f 92       	push	r8
    3776:	9f 92       	push	r9
    3778:	af 92       	push	r10
    377a:	bf 92       	push	r11
    377c:	cf 92       	push	r12
    377e:	df 92       	push	r13
    3780:	ef 92       	push	r14
    3782:	ff 92       	push	r15
    3784:	0f 93       	push	r16
    3786:	1f 93       	push	r17
    3788:	cf 93       	push	r28
    378a:	df 93       	push	r29
    378c:	cd b7       	in	r28, 0x3d	; 61
    378e:	de b7       	in	r29, 0x3e	; 62
    3790:	ec 97       	sbiw	r28, 0x3c	; 60
    3792:	0f b6       	in	r0, 0x3f	; 63
    3794:	f8 94       	cli
    3796:	de bf       	out	0x3e, r29	; 62
    3798:	0f be       	out	0x3f, r0	; 63
    379a:	cd bf       	out	0x3d, r28	; 61
  // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }
    379c:	80 91 1a 0c 	lds	r24, 0x0C1A	; 0x800c1a <sys+0x4>
    37a0:	80 ff       	sbrs	r24, 0
    37a2:	02 c0       	rjmp	.+4      	; 0x37a8 <st_prep_buffer+0x40>
    37a4:	0c 94 e4 23 	jmp	0x47c8	; 0x47c8 <st_prep_buffer+0x1060>
      if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) { pl_block = plan_get_system_motion_block(); }
      else { pl_block = plan_get_current_block(); }
      if (pl_block == NULL) { return; } // No planner blocks. Exit.

      // Check if we need to only recompute the velocity profile or load a new block.
      if (prep.recalculate_flag & PREP_FLAG_RECALCULATE) {
    37a8:	0f 2e       	mov	r0, r31
    37aa:	f8 e0       	ldi	r31, 0x08	; 8
    37ac:	6f 2e       	mov	r6, r31
    37ae:	f3 e0       	ldi	r31, 0x03	; 3
    37b0:	7f 2e       	mov	r7, r31
    37b2:	f0 2d       	mov	r31, r0
          mm_var = mm_remaining - prep.maximum_speed*time_var;
          if (mm_var < prep.decelerate_after) { // End of cruise.
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
    37b4:	22 e0       	ldi	r18, 0x02	; 2
    37b6:	2a af       	std	Y+58, r18	; 0x3a
    37b8:	29 af       	std	Y+57, r18	; 0x39
    37ba:	cd c7       	rjmp	.+3994   	; 0x4756 <st_prep_buffer+0xfee>
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }

  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.

    // Determine if we need to load a new planner block or if the block needs to be recomputed.
    if (pl_block == NULL) {
    37bc:	80 91 3b 03 	lds	r24, 0x033B	; 0x80033b <pl_block>
    37c0:	90 91 3c 03 	lds	r25, 0x033C	; 0x80033c <pl_block+0x1>
    37c4:	89 2b       	or	r24, r25
    37c6:	09 f0       	breq	.+2      	; 0x37ca <st_prep_buffer+0x62>
    37c8:	11 c3       	rjmp	.+1570   	; 0x3dec <st_prep_buffer+0x684>

      // Query planner for a queued block
      if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) { pl_block = plan_get_system_motion_block(); }
    37ca:	80 91 1a 0c 	lds	r24, 0x0C1A	; 0x800c1a <sys+0x4>
    37ce:	82 ff       	sbrs	r24, 2
    37d0:	07 c0       	rjmp	.+14     	; 0x37e0 <st_prep_buffer+0x78>
    37d2:	0e 94 e4 28 	call	0x51c8	; 0x51c8 <plan_get_system_motion_block>
    37d6:	90 93 3c 03 	sts	0x033C, r25	; 0x80033c <pl_block+0x1>
    37da:	80 93 3b 03 	sts	0x033B, r24	; 0x80033b <pl_block>
    37de:	06 c0       	rjmp	.+12     	; 0x37ec <st_prep_buffer+0x84>
      else { pl_block = plan_get_current_block(); }
    37e0:	0e 94 ed 28 	call	0x51da	; 0x51da <plan_get_current_block>
    37e4:	90 93 3c 03 	sts	0x033C, r25	; 0x80033c <pl_block+0x1>
    37e8:	80 93 3b 03 	sts	0x033B, r24	; 0x80033b <pl_block>
      if (pl_block == NULL) { return; } // No planner blocks. Exit.
    37ec:	e0 90 3b 03 	lds	r14, 0x033B	; 0x80033b <pl_block>
    37f0:	f0 90 3c 03 	lds	r15, 0x033C	; 0x80033c <pl_block+0x1>
    37f4:	e1 14       	cp	r14, r1
    37f6:	f1 04       	cpc	r15, r1
    37f8:	09 f4       	brne	.+2      	; 0x37fc <st_prep_buffer+0x94>
    37fa:	e6 c7       	rjmp	.+4044   	; 0x47c8 <st_prep_buffer+0x1060>

      // Check if we need to only recompute the velocity profile or load a new block.
      if (prep.recalculate_flag & PREP_FLAG_RECALCULATE) {
    37fc:	d3 01       	movw	r26, r6
    37fe:	11 96       	adiw	r26, 0x01	; 1
    3800:	1c 91       	ld	r17, X
    3802:	11 97       	sbiw	r26, 0x01	; 1
    3804:	81 2f       	mov	r24, r17
    3806:	81 70       	andi	r24, 0x01	; 1
    3808:	10 ff       	sbrs	r17, 0
    380a:	03 c0       	rjmp	.+6      	; 0x3812 <st_prep_buffer+0xaa>

        #ifdef PARKING_ENABLE
          if (prep.recalculate_flag & PREP_FLAG_PARKING) { prep.recalculate_flag &= ~(PREP_FLAG_RECALCULATE); }
          else { prep.recalculate_flag = false; }
        #else
          prep.recalculate_flag = false;
    380c:	11 96       	adiw	r26, 0x01	; 1
    380e:	1c 92       	st	X, r1
    3810:	eb c0       	rjmp	.+470    	; 0x39e8 <st_prep_buffer+0x280>


// Increments the step segment buffer block data ring buffer.
static uint8_t st_next_block_index(uint8_t block_index)
{
  block_index++;
    3812:	f3 01       	movw	r30, r6
    3814:	90 81       	ld	r25, Z
    3816:	9f 5f       	subi	r25, 0xFF	; 255
  if ( block_index == (SEGMENT_BUFFER_SIZE-1) ) { return(0); }
    3818:	99 30       	cpi	r25, 0x09	; 9
    381a:	09 f0       	breq	.+2      	; 0x381e <st_prep_buffer+0xb6>
  return(block_index);
    381c:	89 2f       	mov	r24, r25
        #endif

      } else {

        // Load the Bresenham stepping data for the block.
        prep.st_block_index = st_next_block_index(prep.st_block_index);
    381e:	d3 01       	movw	r26, r6
    3820:	8c 93       	st	X, r24

        // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
        // when the segment buffer completes the planner block, it may be discarded when the
        // segment buffer finishes the prepped block, but the stepper ISR is still executing it.
        st_prep_block = &st_block_buffer[prep.st_block_index];
    3822:	90 e0       	ldi	r25, 0x00	; 0
    3824:	fc 01       	movw	r30, r24
    3826:	ee 0f       	add	r30, r30
    3828:	ff 1f       	adc	r31, r31
    382a:	9f 01       	movw	r18, r30
    382c:	22 0f       	add	r18, r18
    382e:	33 1f       	adc	r19, r19
    3830:	22 0f       	add	r18, r18
    3832:	33 1f       	adc	r19, r19
    3834:	22 0f       	add	r18, r18
    3836:	33 1f       	adc	r19, r19
    3838:	e2 0f       	add	r30, r18
    383a:	f3 1f       	adc	r31, r19
    383c:	ea 54       	subi	r30, 0x4A	; 74
    383e:	fc 4f       	sbci	r31, 0xFC	; 252
    3840:	f0 93 3a 03 	sts	0x033A, r31	; 0x80033a <st_prep_block+0x1>
    3844:	e0 93 39 03 	sts	0x0339, r30	; 0x800339 <st_prep_block>
        #ifdef DEFAULTS_RAMPS_BOARD
          for (idx=0; idx<N_AXIS; idx++) {
            st_prep_block->direction_bits[idx] = pl_block->direction_bits[idx];
          }
        #else
          st_prep_block->direction_bits = pl_block->direction_bits;
    3848:	d7 01       	movw	r26, r14
    384a:	50 96       	adiw	r26, 0x10	; 16
    384c:	2c 91       	ld	r18, X
    384e:	50 97       	sbiw	r26, 0x10	; 16
    3850:	20 8b       	std	Z+16, r18	; 0x10
    3852:	97 01       	movw	r18, r14
    3854:	24 5f       	subi	r18, 0xF4	; 244
    3856:	3f 4f       	sbci	r19, 0xFF	; 255
    3858:	fa 82       	std	Y+2, r15	; 0x02
    385a:	e9 82       	std	Y+1, r14	; 0x01
          st_prep_block->step_event_count = (pl_block->step_event_count << 1);
        #else
          // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS
          // level, such that we never divide beyond the original data anywhere in the algorithm.
          // If the original data is divided, we can lose a step from integer roundoff.
          for (idx=0; idx<N_AXIS; idx++) { st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_AMASS_LEVEL; }
    385c:	4d 91       	ld	r20, X+
    385e:	5d 91       	ld	r21, X+
    3860:	6d 91       	ld	r22, X+
    3862:	7d 91       	ld	r23, X+
    3864:	44 0f       	add	r20, r20
    3866:	55 1f       	adc	r21, r21
    3868:	66 1f       	adc	r22, r22
    386a:	77 1f       	adc	r23, r23
    386c:	44 0f       	add	r20, r20
    386e:	55 1f       	adc	r21, r21
    3870:	66 1f       	adc	r22, r22
    3872:	77 1f       	adc	r23, r23
    3874:	44 0f       	add	r20, r20
    3876:	55 1f       	adc	r21, r21
    3878:	66 1f       	adc	r22, r22
    387a:	77 1f       	adc	r23, r23
    387c:	41 93       	st	Z+, r20
    387e:	51 93       	st	Z+, r21
    3880:	61 93       	st	Z+, r22
    3882:	71 93       	st	Z+, r23
    3884:	a2 17       	cp	r26, r18
    3886:	b3 07       	cpc	r27, r19
    3888:	49 f7       	brne	.-46     	; 0x385c <st_prep_buffer+0xf4>
    388a:	e9 80       	ldd	r14, Y+1	; 0x01
    388c:	fa 80       	ldd	r15, Y+2	; 0x02
          st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
    388e:	88 0f       	add	r24, r24
    3890:	99 1f       	adc	r25, r25
    3892:	fc 01       	movw	r30, r24
    3894:	ee 0f       	add	r30, r30
    3896:	ff 1f       	adc	r31, r31
    3898:	ee 0f       	add	r30, r30
    389a:	ff 1f       	adc	r31, r31
    389c:	ee 0f       	add	r30, r30
    389e:	ff 1f       	adc	r31, r31
    38a0:	8e 0f       	add	r24, r30
    38a2:	9f 1f       	adc	r25, r31
    38a4:	9c 01       	movw	r18, r24
    38a6:	2a 54       	subi	r18, 0x4A	; 74
    38a8:	3c 4f       	sbci	r19, 0xFC	; 252
    38aa:	f7 01       	movw	r30, r14
    38ac:	84 85       	ldd	r24, Z+12	; 0x0c
    38ae:	95 85       	ldd	r25, Z+13	; 0x0d
    38b0:	a6 85       	ldd	r26, Z+14	; 0x0e
    38b2:	b7 85       	ldd	r27, Z+15	; 0x0f
    38b4:	88 0f       	add	r24, r24
    38b6:	99 1f       	adc	r25, r25
    38b8:	aa 1f       	adc	r26, r26
    38ba:	bb 1f       	adc	r27, r27
    38bc:	88 0f       	add	r24, r24
    38be:	99 1f       	adc	r25, r25
    38c0:	aa 1f       	adc	r26, r26
    38c2:	bb 1f       	adc	r27, r27
    38c4:	88 0f       	add	r24, r24
    38c6:	99 1f       	adc	r25, r25
    38c8:	aa 1f       	adc	r26, r26
    38ca:	bb 1f       	adc	r27, r27
    38cc:	f9 01       	movw	r30, r18
    38ce:	84 87       	std	Z+12, r24	; 0x0c
    38d0:	95 87       	std	Z+13, r25	; 0x0d
    38d2:	a6 87       	std	Z+14, r26	; 0x0e
    38d4:	b7 87       	std	Z+15, r27	; 0x0f
        #endif

        // Initialize segment buffer data for generating the segments.
        prep.steps_remaining = (float)pl_block->step_event_count;
    38d6:	d7 01       	movw	r26, r14
    38d8:	1c 96       	adiw	r26, 0x0c	; 12
    38da:	6d 91       	ld	r22, X+
    38dc:	7d 91       	ld	r23, X+
    38de:	8d 91       	ld	r24, X+
    38e0:	9c 91       	ld	r25, X
    38e2:	1f 97       	sbiw	r26, 0x0f	; 15
    38e4:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__floatunsisf>
    38e8:	f3 01       	movw	r30, r6
    38ea:	66 83       	std	Z+6, r22	; 0x06
    38ec:	77 83       	std	Z+7, r23	; 0x07
    38ee:	80 87       	std	Z+8, r24	; 0x08
    38f0:	91 87       	std	Z+9, r25	; 0x09
        prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
    38f2:	d7 01       	movw	r26, r14
    38f4:	92 96       	adiw	r26, 0x22	; 34
    38f6:	2d 91       	ld	r18, X+
    38f8:	3d 91       	ld	r19, X+
    38fa:	4d 91       	ld	r20, X+
    38fc:	5c 91       	ld	r21, X
    38fe:	95 97       	sbiw	r26, 0x25	; 37
    3900:	0e 94 cc 3e 	call	0x7d98	; 0x7d98 <__divsf3>
    3904:	9b 01       	movw	r18, r22
    3906:	ac 01       	movw	r20, r24
    3908:	f3 01       	movw	r30, r6
    390a:	62 87       	std	Z+10, r22	; 0x0a
    390c:	73 87       	std	Z+11, r23	; 0x0b
    390e:	84 87       	std	Z+12, r24	; 0x0c
    3910:	95 87       	std	Z+13, r25	; 0x0d
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
    3912:	60 e0       	ldi	r22, 0x00	; 0
    3914:	70 e0       	ldi	r23, 0x00	; 0
    3916:	80 ea       	ldi	r24, 0xA0	; 160
    3918:	9f e3       	ldi	r25, 0x3F	; 63
    391a:	0e 94 cc 3e 	call	0x7d98	; 0x7d98 <__divsf3>
    391e:	d3 01       	movw	r26, r6
    3920:	1e 96       	adiw	r26, 0x0e	; 14
    3922:	6d 93       	st	X+, r22
    3924:	7d 93       	st	X+, r23
    3926:	8d 93       	st	X+, r24
    3928:	9c 93       	st	X, r25
    392a:	51 97       	sbiw	r26, 0x11	; 17
        prep.dt_remainder = 0.0; // Reset for new segment block
    392c:	f3 01       	movw	r30, r6
    392e:	12 82       	std	Z+2, r1	; 0x02
    3930:	13 82       	std	Z+3, r1	; 0x03
    3932:	14 82       	std	Z+4, r1	; 0x04
    3934:	15 82       	std	Z+5, r1	; 0x05

        if ((sys.step_control & STEP_CONTROL_EXECUTE_HOLD) || (prep.recalculate_flag & PREP_FLAG_DECEL_OVERRIDE)) {
    3936:	80 91 1a 0c 	lds	r24, 0x0C1A	; 0x800c1a <sys+0x4>
    393a:	81 fd       	sbrc	r24, 1
    393c:	02 c0       	rjmp	.+4      	; 0x3942 <st_prep_buffer+0x1da>
    393e:	13 ff       	sbrs	r17, 3
    3940:	1b c0       	rjmp	.+54     	; 0x3978 <st_prep_buffer+0x210>
          // New block loaded mid-hold. Override planner block entry speed to enforce deceleration.
          prep.current_speed = prep.exit_speed;
    3942:	d3 01       	movw	r26, r6
    3944:	5f 96       	adiw	r26, 0x1f	; 31
    3946:	6d 91       	ld	r22, X+
    3948:	7d 91       	ld	r23, X+
    394a:	8d 91       	ld	r24, X+
    394c:	9c 91       	ld	r25, X
    394e:	92 97       	sbiw	r26, 0x22	; 34
    3950:	f3 01       	movw	r30, r6
    3952:	67 8b       	std	Z+23, r22	; 0x17
    3954:	70 8f       	std	Z+24, r23	; 0x18
    3956:	81 8f       	std	Z+25, r24	; 0x19
    3958:	92 8f       	std	Z+26, r25	; 0x1a
          pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed;
    395a:	9b 01       	movw	r18, r22
    395c:	ac 01       	movw	r20, r24
    395e:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    3962:	d7 01       	movw	r26, r14
    3964:	56 96       	adiw	r26, 0x16	; 22
    3966:	6d 93       	st	X+, r22
    3968:	7d 93       	st	X+, r23
    396a:	8d 93       	st	X+, r24
    396c:	9c 93       	st	X, r25
    396e:	59 97       	sbiw	r26, 0x19	; 25
          prep.recalculate_flag &= ~(PREP_FLAG_DECEL_OVERRIDE);
    3970:	17 7f       	andi	r17, 0xF7	; 247
    3972:	f3 01       	movw	r30, r6
    3974:	11 83       	std	Z+1, r17	; 0x01
    3976:	0e c0       	rjmp	.+28     	; 0x3994 <st_prep_buffer+0x22c>
        } else {
          prep.current_speed = sqrt(pl_block->entry_speed_sqr);
    3978:	d7 01       	movw	r26, r14
    397a:	56 96       	adiw	r26, 0x16	; 22
    397c:	6d 91       	ld	r22, X+
    397e:	7d 91       	ld	r23, X+
    3980:	8d 91       	ld	r24, X+
    3982:	9c 91       	ld	r25, X
    3984:	59 97       	sbiw	r26, 0x19	; 25
    3986:	0e 94 90 41 	call	0x8320	; 0x8320 <sqrt>
    398a:	f3 01       	movw	r30, r6
    398c:	67 8b       	std	Z+23, r22	; 0x17
    398e:	70 8f       	std	Z+24, r23	; 0x18
    3990:	81 8f       	std	Z+25, r24	; 0x19
    3992:	92 8f       	std	Z+26, r25	; 0x1a
        }
        
        // Setup laser mode variables. PWM rate adjusted motions will always complete a motion with the
        // spindle off. 
        st_prep_block->is_pwm_rate_adjusted = false;
    3994:	20 91 39 03 	lds	r18, 0x0339	; 0x800339 <st_prep_block>
    3998:	30 91 3a 03 	lds	r19, 0x033A	; 0x80033a <st_prep_block+0x1>
    399c:	3a 83       	std	Y+2, r19	; 0x02
    399e:	29 83       	std	Y+1, r18	; 0x01
    39a0:	d9 01       	movw	r26, r18
    39a2:	51 96       	adiw	r26, 0x11	; 17
    39a4:	1c 92       	st	X, r1
        if (settings.flags & BITFLAG_LASER_MODE) {
    39a6:	e5 e0       	ldi	r30, 0x05	; 5
    39a8:	ff e0       	ldi	r31, 0x0F	; 15
    39aa:	80 81       	ld	r24, Z
    39ac:	81 ff       	sbrs	r24, 1
    39ae:	1c c0       	rjmp	.+56     	; 0x39e8 <st_prep_buffer+0x280>
          if (pl_block->condition & PL_COND_FLAG_SPINDLE_CCW) { 
    39b0:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    39b4:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    39b8:	81 89       	ldd	r24, Z+17	; 0x11
    39ba:	85 ff       	sbrs	r24, 5
    39bc:	15 c0       	rjmp	.+42     	; 0x39e8 <st_prep_buffer+0x280>
            // Pre-compute inverse programmed rate to speed up PWM updating per step segment.
            prep.inv_rate = 1.0/pl_block->programmed_rate;
    39be:	26 a5       	ldd	r18, Z+46	; 0x2e
    39c0:	37 a5       	ldd	r19, Z+47	; 0x2f
    39c2:	40 a9       	ldd	r20, Z+48	; 0x30
    39c4:	51 a9       	ldd	r21, Z+49	; 0x31
    39c6:	60 e0       	ldi	r22, 0x00	; 0
    39c8:	70 e0       	ldi	r23, 0x00	; 0
    39ca:	80 e8       	ldi	r24, 0x80	; 128
    39cc:	9f e3       	ldi	r25, 0x3F	; 63
    39ce:	0e 94 cc 3e 	call	0x7d98	; 0x7d98 <__divsf3>
    39d2:	d3 01       	movw	r26, r6
    39d4:	9b 96       	adiw	r26, 0x2b	; 43
    39d6:	6d 93       	st	X+, r22
    39d8:	7d 93       	st	X+, r23
    39da:	8d 93       	st	X+, r24
    39dc:	9c 93       	st	X, r25
    39de:	9e 97       	sbiw	r26, 0x2e	; 46
            st_prep_block->is_pwm_rate_adjusted = true; 
    39e0:	21 e0       	ldi	r18, 0x01	; 1
    39e2:	e9 81       	ldd	r30, Y+1	; 0x01
    39e4:	fa 81       	ldd	r31, Y+2	; 0x02
    39e6:	21 8b       	std	Z+17, r18	; 0x11
			 Compute the velocity profile of a new planner block based on its entry and exit
			 speeds, or recompute the profile of a partially-completed planner block if the
			 planner has updated it. For a commanded forced-deceleration, such as from a feed
			 hold, override the planner velocities and decelerate to the target exit speed.
			*/
			prep.mm_complete = 0.0; // Default velocity profile complete at 0.0mm from end of block.
    39e8:	d3 01       	movw	r26, r6
    39ea:	53 96       	adiw	r26, 0x13	; 19
    39ec:	1d 92       	st	X+, r1
    39ee:	1d 92       	st	X+, r1
    39f0:	1d 92       	st	X+, r1
    39f2:	1c 92       	st	X, r1
    39f4:	56 97       	sbiw	r26, 0x16	; 22
			float inv_2_accel = 0.5/pl_block->acceleration;
    39f6:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    39fa:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    39fe:	fe 83       	std	Y+6, r31	; 0x06
    3a00:	ed 83       	std	Y+5, r30	; 0x05
    3a02:	86 8c       	ldd	r8, Z+30	; 0x1e
    3a04:	97 8c       	ldd	r9, Z+31	; 0x1f
    3a06:	a0 a0       	ldd	r10, Z+32	; 0x20
    3a08:	b1 a0       	ldd	r11, Z+33	; 0x21
    3a0a:	a5 01       	movw	r20, r10
    3a0c:	94 01       	movw	r18, r8
    3a0e:	60 e0       	ldi	r22, 0x00	; 0
    3a10:	70 e0       	ldi	r23, 0x00	; 0
    3a12:	80 e0       	ldi	r24, 0x00	; 0
    3a14:	9f e3       	ldi	r25, 0x3F	; 63
    3a16:	0e 94 cc 3e 	call	0x7d98	; 0x7d98 <__divsf3>
    3a1a:	69 83       	std	Y+1, r22	; 0x01
    3a1c:	7a 83       	std	Y+2, r23	; 0x02
    3a1e:	8b 83       	std	Y+3, r24	; 0x03
    3a20:	9c 83       	std	Y+4, r25	; 0x04
			if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { // [Forced Deceleration to Zero Velocity]
    3a22:	80 91 1a 0c 	lds	r24, 0x0C1A	; 0x800c1a <sys+0x4>
    3a26:	81 ff       	sbrs	r24, 1
    3a28:	54 c0       	rjmp	.+168    	; 0x3ad2 <st_prep_buffer+0x36a>
				// Compute velocity profile parameters for a feed hold in-progress. This profile overrides
				// the planner block profile, enforcing a deceleration to zero speed.
				prep.ramp_type = RAMP_DECEL;
    3a2a:	e2 e0       	ldi	r30, 0x02	; 2
    3a2c:	d3 01       	movw	r26, r6
    3a2e:	52 96       	adiw	r26, 0x12	; 18
    3a30:	ec 93       	st	X, r30
				// Compute decelerate distance relative to end of block.
				float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
    3a32:	ad 81       	ldd	r26, Y+5	; 0x05
    3a34:	be 81       	ldd	r27, Y+6	; 0x06
    3a36:	92 96       	adiw	r26, 0x22	; 34
    3a38:	2d 90       	ld	r2, X+
    3a3a:	3d 90       	ld	r3, X+
    3a3c:	4d 90       	ld	r4, X+
    3a3e:	5c 90       	ld	r5, X
    3a40:	95 97       	sbiw	r26, 0x25	; 37
    3a42:	56 96       	adiw	r26, 0x16	; 22
    3a44:	cd 90       	ld	r12, X+
    3a46:	dd 90       	ld	r13, X+
    3a48:	ed 90       	ld	r14, X+
    3a4a:	fc 90       	ld	r15, X
    3a4c:	59 97       	sbiw	r26, 0x19	; 25
    3a4e:	a7 01       	movw	r20, r14
    3a50:	96 01       	movw	r18, r12
    3a52:	69 81       	ldd	r22, Y+1	; 0x01
    3a54:	7a 81       	ldd	r23, Y+2	; 0x02
    3a56:	8b 81       	ldd	r24, Y+3	; 0x03
    3a58:	9c 81       	ldd	r25, Y+4	; 0x04
    3a5a:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    3a5e:	9b 01       	movw	r18, r22
    3a60:	ac 01       	movw	r20, r24
    3a62:	c2 01       	movw	r24, r4
    3a64:	b1 01       	movw	r22, r2
    3a66:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    3a6a:	69 83       	std	Y+1, r22	; 0x01
    3a6c:	7a 83       	std	Y+2, r23	; 0x02
    3a6e:	8b 83       	std	Y+3, r24	; 0x03
    3a70:	9c 83       	std	Y+4, r25	; 0x04
				if (decel_dist < 0.0) {
    3a72:	20 e0       	ldi	r18, 0x00	; 0
    3a74:	30 e0       	ldi	r19, 0x00	; 0
    3a76:	a9 01       	movw	r20, r18
    3a78:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    3a7c:	88 23       	and	r24, r24
    3a7e:	c4 f4       	brge	.+48     	; 0x3ab0 <st_prep_buffer+0x348>
					// Deceleration through entire planner block. End of feed hold is not in this block.
					prep.exit_speed = sqrt(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);
    3a80:	a5 01       	movw	r20, r10
    3a82:	94 01       	movw	r18, r8
    3a84:	c5 01       	movw	r24, r10
    3a86:	b4 01       	movw	r22, r8
    3a88:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    3a8c:	a2 01       	movw	r20, r4
    3a8e:	91 01       	movw	r18, r2
    3a90:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    3a94:	9b 01       	movw	r18, r22
    3a96:	ac 01       	movw	r20, r24
    3a98:	c7 01       	movw	r24, r14
    3a9a:	b6 01       	movw	r22, r12
    3a9c:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    3aa0:	0e 94 90 41 	call	0x8320	; 0x8320 <sqrt>
    3aa4:	f3 01       	movw	r30, r6
    3aa6:	67 8f       	std	Z+31, r22	; 0x1f
    3aa8:	70 a3       	std	Z+32, r23	; 0x20
    3aaa:	81 a3       	std	Z+33, r24	; 0x21
    3aac:	92 a3       	std	Z+34, r25	; 0x22
    3aae:	99 c1       	rjmp	.+818    	; 0x3de2 <st_prep_buffer+0x67a>
				} else {
					prep.mm_complete = decel_dist; // End of feed hold.
    3ab0:	29 81       	ldd	r18, Y+1	; 0x01
    3ab2:	3a 81       	ldd	r19, Y+2	; 0x02
    3ab4:	4b 81       	ldd	r20, Y+3	; 0x03
    3ab6:	5c 81       	ldd	r21, Y+4	; 0x04
    3ab8:	d3 01       	movw	r26, r6
    3aba:	53 96       	adiw	r26, 0x13	; 19
    3abc:	2d 93       	st	X+, r18
    3abe:	3d 93       	st	X+, r19
    3ac0:	4d 93       	st	X+, r20
    3ac2:	5c 93       	st	X, r21
    3ac4:	56 97       	sbiw	r26, 0x16	; 22
					prep.exit_speed = 0.0;
    3ac6:	f3 01       	movw	r30, r6
    3ac8:	17 8e       	std	Z+31, r1	; 0x1f
    3aca:	10 a2       	std	Z+32, r1	; 0x20
    3acc:	11 a2       	std	Z+33, r1	; 0x21
    3ace:	12 a2       	std	Z+34, r1	; 0x22
    3ad0:	88 c1       	rjmp	.+784    	; 0x3de2 <st_prep_buffer+0x67a>
				}
			} else { // [Normal Operation]
				// Compute or recompute velocity profile parameters of the prepped planner block.
				prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
    3ad2:	d3 01       	movw	r26, r6
    3ad4:	52 96       	adiw	r26, 0x12	; 18
    3ad6:	1c 92       	st	X, r1
    3ad8:	52 97       	sbiw	r26, 0x12	; 18
				prep.accelerate_until = pl_block->millimeters;
    3ada:	ed 81       	ldd	r30, Y+5	; 0x05
    3adc:	fe 81       	ldd	r31, Y+6	; 0x06
    3ade:	42 a1       	ldd	r20, Z+34	; 0x22
    3ae0:	53 a1       	ldd	r21, Z+35	; 0x23
    3ae2:	64 a1       	ldd	r22, Z+36	; 0x24
    3ae4:	75 a1       	ldd	r23, Z+37	; 0x25
    3ae6:	93 96       	adiw	r26, 0x23	; 35
    3ae8:	4d 93       	st	X+, r20
    3aea:	5d 93       	st	X+, r21
    3aec:	6d 93       	st	X+, r22
    3aee:	7c 93       	st	X, r23
    3af0:	96 97       	sbiw	r26, 0x26	; 38

				float exit_speed_sqr;
				float nominal_speed;
        if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
    3af2:	82 ff       	sbrs	r24, 2
    3af4:	0a c0       	rjmp	.+20     	; 0x3b0a <st_prep_buffer+0x3a2>
          prep.exit_speed = exit_speed_sqr = 0.0; // Enforce stop at end of system motion.
    3af6:	f3 01       	movw	r30, r6
    3af8:	17 8e       	std	Z+31, r1	; 0x1f
    3afa:	10 a2       	std	Z+32, r1	; 0x20
    3afc:	11 a2       	std	Z+33, r1	; 0x21
    3afe:	12 a2       	std	Z+34, r1	; 0x22
    3b00:	19 86       	std	Y+9, r1	; 0x09
    3b02:	1a 86       	std	Y+10, r1	; 0x0a
    3b04:	1b 86       	std	Y+11, r1	; 0x0b
    3b06:	1c 86       	std	Y+12, r1	; 0x0c
    3b08:	0f c0       	rjmp	.+30     	; 0x3b28 <st_prep_buffer+0x3c0>
        } else {
          exit_speed_sqr = plan_get_exec_block_exit_speed_sqr();
    3b0a:	0e 94 fd 28 	call	0x51fa	; 0x51fa <plan_get_exec_block_exit_speed_sqr>
    3b0e:	69 87       	std	Y+9, r22	; 0x09
    3b10:	7a 87       	std	Y+10, r23	; 0x0a
    3b12:	8b 87       	std	Y+11, r24	; 0x0b
    3b14:	9c 87       	std	Y+12, r25	; 0x0c
          prep.exit_speed = sqrt(exit_speed_sqr);
    3b16:	0e 94 90 41 	call	0x8320	; 0x8320 <sqrt>
    3b1a:	d3 01       	movw	r26, r6
    3b1c:	5f 96       	adiw	r26, 0x1f	; 31
    3b1e:	6d 93       	st	X+, r22
    3b20:	7d 93       	st	X+, r23
    3b22:	8d 93       	st	X+, r24
    3b24:	9c 93       	st	X, r25
    3b26:	92 97       	sbiw	r26, 0x22	; 34
        }

        nominal_speed = plan_compute_profile_nominal_speed(pl_block);
    3b28:	80 91 3b 03 	lds	r24, 0x033B	; 0x80033b <pl_block>
    3b2c:	90 91 3c 03 	lds	r25, 0x033C	; 0x80033c <pl_block+0x1>
    3b30:	0e 94 1e 29 	call	0x523c	; 0x523c <plan_compute_profile_nominal_speed>
    3b34:	4b 01       	movw	r8, r22
    3b36:	5c 01       	movw	r10, r24
				float nominal_speed_sqr = nominal_speed*nominal_speed;
    3b38:	9b 01       	movw	r18, r22
    3b3a:	ac 01       	movw	r20, r24
    3b3c:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    3b40:	6d 83       	std	Y+5, r22	; 0x05
    3b42:	7e 83       	std	Y+6, r23	; 0x06
    3b44:	8f 83       	std	Y+7, r24	; 0x07
    3b46:	98 87       	std	Y+8, r25	; 0x08
				float intersect_distance =
								0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
    3b48:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    3b4c:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    3b50:	fe 87       	std	Y+14, r31	; 0x0e
    3b52:	ed 87       	std	Y+13, r30	; 0x0d
    3b54:	c2 a0       	ldd	r12, Z+34	; 0x22
    3b56:	d3 a0       	ldd	r13, Z+35	; 0x23
    3b58:	e4 a0       	ldd	r14, Z+36	; 0x24
    3b5a:	f5 a0       	ldd	r15, Z+37	; 0x25
    3b5c:	26 88       	ldd	r2, Z+22	; 0x16
    3b5e:	37 88       	ldd	r3, Z+23	; 0x17
    3b60:	40 8c       	ldd	r4, Z+24	; 0x18
    3b62:	51 8c       	ldd	r5, Z+25	; 0x19

        if (pl_block->entry_speed_sqr > nominal_speed_sqr) { // Only occurs during override reductions.
    3b64:	a2 01       	movw	r20, r4
    3b66:	91 01       	movw	r18, r2
    3b68:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    3b6c:	88 23       	and	r24, r24
    3b6e:	0c f0       	brlt	.+2      	; 0x3b72 <st_prep_buffer+0x40a>
    3b70:	71 c0       	rjmp	.+226    	; 0x3c54 <st_prep_buffer+0x4ec>
          prep.accelerate_until = pl_block->millimeters - inv_2_accel*(pl_block->entry_speed_sqr-nominal_speed_sqr);
    3b72:	2d 81       	ldd	r18, Y+5	; 0x05
    3b74:	3e 81       	ldd	r19, Y+6	; 0x06
    3b76:	4f 81       	ldd	r20, Y+7	; 0x07
    3b78:	58 85       	ldd	r21, Y+8	; 0x08
    3b7a:	c2 01       	movw	r24, r4
    3b7c:	b1 01       	movw	r22, r2
    3b7e:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    3b82:	29 81       	ldd	r18, Y+1	; 0x01
    3b84:	3a 81       	ldd	r19, Y+2	; 0x02
    3b86:	4b 81       	ldd	r20, Y+3	; 0x03
    3b88:	5c 81       	ldd	r21, Y+4	; 0x04
    3b8a:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    3b8e:	9b 01       	movw	r18, r22
    3b90:	ac 01       	movw	r20, r24
    3b92:	c7 01       	movw	r24, r14
    3b94:	b6 01       	movw	r22, r12
    3b96:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    3b9a:	d3 01       	movw	r26, r6
    3b9c:	93 96       	adiw	r26, 0x23	; 35
    3b9e:	6d 93       	st	X+, r22
    3ba0:	7d 93       	st	X+, r23
    3ba2:	8d 93       	st	X+, r24
    3ba4:	9c 93       	st	X, r25
    3ba6:	96 97       	sbiw	r26, 0x26	; 38
          if (prep.accelerate_until <= 0.0) { // Deceleration-only.
    3ba8:	20 e0       	ldi	r18, 0x00	; 0
    3baa:	30 e0       	ldi	r19, 0x00	; 0
    3bac:	a9 01       	movw	r20, r18
    3bae:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    3bb2:	18 16       	cp	r1, r24
    3bb4:	84 f1       	brlt	.+96     	; 0x3c16 <st_prep_buffer+0x4ae>
            prep.ramp_type = RAMP_DECEL;
    3bb6:	22 e0       	ldi	r18, 0x02	; 2
    3bb8:	f3 01       	movw	r30, r6
    3bba:	22 8b       	std	Z+18, r18	; 0x12
            // prep.decelerate_after = pl_block->millimeters;
            // prep.maximum_speed = prep.current_speed;

            // Compute override block exit speed since it doesn't match the planner exit speed.
            prep.exit_speed = sqrt(pl_block->entry_speed_sqr - 2*pl_block->acceleration*pl_block->millimeters);
    3bbc:	ad 85       	ldd	r26, Y+13	; 0x0d
    3bbe:	be 85       	ldd	r27, Y+14	; 0x0e
    3bc0:	5e 96       	adiw	r26, 0x1e	; 30
    3bc2:	cd 90       	ld	r12, X+
    3bc4:	dd 90       	ld	r13, X+
    3bc6:	ed 90       	ld	r14, X+
    3bc8:	fc 90       	ld	r15, X
    3bca:	91 97       	sbiw	r26, 0x21	; 33
    3bcc:	a7 01       	movw	r20, r14
    3bce:	96 01       	movw	r18, r12
    3bd0:	c7 01       	movw	r24, r14
    3bd2:	b6 01       	movw	r22, r12
    3bd4:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    3bd8:	ed 85       	ldd	r30, Y+13	; 0x0d
    3bda:	fe 85       	ldd	r31, Y+14	; 0x0e
    3bdc:	22 a1       	ldd	r18, Z+34	; 0x22
    3bde:	33 a1       	ldd	r19, Z+35	; 0x23
    3be0:	44 a1       	ldd	r20, Z+36	; 0x24
    3be2:	55 a1       	ldd	r21, Z+37	; 0x25
    3be4:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    3be8:	9b 01       	movw	r18, r22
    3bea:	ac 01       	movw	r20, r24
    3bec:	ad 85       	ldd	r26, Y+13	; 0x0d
    3bee:	be 85       	ldd	r27, Y+14	; 0x0e
    3bf0:	56 96       	adiw	r26, 0x16	; 22
    3bf2:	6d 91       	ld	r22, X+
    3bf4:	7d 91       	ld	r23, X+
    3bf6:	8d 91       	ld	r24, X+
    3bf8:	9c 91       	ld	r25, X
    3bfa:	59 97       	sbiw	r26, 0x19	; 25
    3bfc:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    3c00:	0e 94 90 41 	call	0x8320	; 0x8320 <sqrt>
    3c04:	f3 01       	movw	r30, r6
    3c06:	67 8f       	std	Z+31, r22	; 0x1f
    3c08:	70 a3       	std	Z+32, r23	; 0x20
    3c0a:	81 a3       	std	Z+33, r24	; 0x21
    3c0c:	92 a3       	std	Z+34, r25	; 0x22
            prep.recalculate_flag |= PREP_FLAG_DECEL_OVERRIDE; // Flag to load next block as deceleration override.
    3c0e:	81 81       	ldd	r24, Z+1	; 0x01
    3c10:	88 60       	ori	r24, 0x08	; 8
    3c12:	81 83       	std	Z+1, r24	; 0x01
    3c14:	e6 c0       	rjmp	.+460    	; 0x3de2 <st_prep_buffer+0x67a>
            // Can be tricky since entry speed will be current speed, as in feed holds.
            // Also, look into near-zero speed handling issues with this.

          } else {
            // Decelerate to cruise or cruise-decelerate types. Guaranteed to intersect updated plan.
            prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
    3c16:	29 85       	ldd	r18, Y+9	; 0x09
    3c18:	3a 85       	ldd	r19, Y+10	; 0x0a
    3c1a:	4b 85       	ldd	r20, Y+11	; 0x0b
    3c1c:	5c 85       	ldd	r21, Y+12	; 0x0c
    3c1e:	6d 81       	ldd	r22, Y+5	; 0x05
    3c20:	7e 81       	ldd	r23, Y+6	; 0x06
    3c22:	8f 81       	ldd	r24, Y+7	; 0x07
    3c24:	98 85       	ldd	r25, Y+8	; 0x08
    3c26:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    3c2a:	29 81       	ldd	r18, Y+1	; 0x01
    3c2c:	3a 81       	ldd	r19, Y+2	; 0x02
    3c2e:	4b 81       	ldd	r20, Y+3	; 0x03
    3c30:	5c 81       	ldd	r21, Y+4	; 0x04
    3c32:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    3c36:	d3 01       	movw	r26, r6
    3c38:	97 96       	adiw	r26, 0x27	; 39
    3c3a:	6d 93       	st	X+, r22
    3c3c:	7d 93       	st	X+, r23
    3c3e:	8d 93       	st	X+, r24
    3c40:	9c 93       	st	X, r25
    3c42:	9a 97       	sbiw	r26, 0x2a	; 42
            prep.maximum_speed = nominal_speed;
    3c44:	f3 01       	movw	r30, r6
    3c46:	83 8e       	std	Z+27, r8	; 0x1b
    3c48:	94 8e       	std	Z+28, r9	; 0x1c
    3c4a:	a5 8e       	std	Z+29, r10	; 0x1d
    3c4c:	b6 8e       	std	Z+30, r11	; 0x1e
            prep.ramp_type = RAMP_DECEL_OVERRIDE;
    3c4e:	23 e0       	ldi	r18, 0x03	; 3
    3c50:	22 8b       	std	Z+18, r18	; 0x12
    3c52:	c7 c0       	rjmp	.+398    	; 0x3de2 <st_prep_buffer+0x67a>
          prep.exit_speed = sqrt(exit_speed_sqr);
        }

        nominal_speed = plan_compute_profile_nominal_speed(pl_block);
				float nominal_speed_sqr = nominal_speed*nominal_speed;
				float intersect_distance =
    3c54:	29 85       	ldd	r18, Y+9	; 0x09
    3c56:	3a 85       	ldd	r19, Y+10	; 0x0a
    3c58:	4b 85       	ldd	r20, Y+11	; 0x0b
    3c5a:	5c 85       	ldd	r21, Y+12	; 0x0c
    3c5c:	c2 01       	movw	r24, r4
    3c5e:	b1 01       	movw	r22, r2
    3c60:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    3c64:	29 81       	ldd	r18, Y+1	; 0x01
    3c66:	3a 81       	ldd	r19, Y+2	; 0x02
    3c68:	4b 81       	ldd	r20, Y+3	; 0x03
    3c6a:	5c 81       	ldd	r21, Y+4	; 0x04
    3c6c:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    3c70:	a7 01       	movw	r20, r14
    3c72:	96 01       	movw	r18, r12
    3c74:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    3c78:	20 e0       	ldi	r18, 0x00	; 0
    3c7a:	30 e0       	ldi	r19, 0x00	; 0
    3c7c:	40 e0       	ldi	r20, 0x00	; 0
    3c7e:	5f e3       	ldi	r21, 0x3F	; 63
    3c80:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    3c84:	1b 01       	movw	r2, r22
    3c86:	2c 01       	movw	r4, r24
            // Decelerate to cruise or cruise-decelerate types. Guaranteed to intersect updated plan.
            prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
            prep.maximum_speed = nominal_speed;
            prep.ramp_type = RAMP_DECEL_OVERRIDE;
          }
				} else if (intersect_distance > 0.0) {
    3c88:	20 e0       	ldi	r18, 0x00	; 0
    3c8a:	30 e0       	ldi	r19, 0x00	; 0
    3c8c:	a9 01       	movw	r20, r18
    3c8e:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    3c92:	18 16       	cp	r1, r24
    3c94:	0c f0       	brlt	.+2      	; 0x3c98 <st_prep_buffer+0x530>
    3c96:	93 c0       	rjmp	.+294    	; 0x3dbe <st_prep_buffer+0x656>
					if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
    3c98:	a2 01       	movw	r20, r4
    3c9a:	91 01       	movw	r18, r2
    3c9c:	c7 01       	movw	r24, r14
    3c9e:	b6 01       	movw	r22, r12
    3ca0:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    3ca4:	18 16       	cp	r1, r24
    3ca6:	0c f0       	brlt	.+2      	; 0x3caa <st_prep_buffer+0x542>
    3ca8:	85 c0       	rjmp	.+266    	; 0x3db4 <st_prep_buffer+0x64c>
						// NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
						prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
    3caa:	29 85       	ldd	r18, Y+9	; 0x09
    3cac:	3a 85       	ldd	r19, Y+10	; 0x0a
    3cae:	4b 85       	ldd	r20, Y+11	; 0x0b
    3cb0:	5c 85       	ldd	r21, Y+12	; 0x0c
    3cb2:	6d 81       	ldd	r22, Y+5	; 0x05
    3cb4:	7e 81       	ldd	r23, Y+6	; 0x06
    3cb6:	8f 81       	ldd	r24, Y+7	; 0x07
    3cb8:	98 85       	ldd	r25, Y+8	; 0x08
    3cba:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    3cbe:	29 81       	ldd	r18, Y+1	; 0x01
    3cc0:	3a 81       	ldd	r19, Y+2	; 0x02
    3cc2:	4b 81       	ldd	r20, Y+3	; 0x03
    3cc4:	5c 81       	ldd	r21, Y+4	; 0x04
    3cc6:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    3cca:	9b 01       	movw	r18, r22
    3ccc:	ac 01       	movw	r20, r24
    3cce:	d3 01       	movw	r26, r6
    3cd0:	97 96       	adiw	r26, 0x27	; 39
    3cd2:	6d 93       	st	X+, r22
    3cd4:	7d 93       	st	X+, r23
    3cd6:	8d 93       	st	X+, r24
    3cd8:	9c 93       	st	X, r25
    3cda:	9a 97       	sbiw	r26, 0x2a	; 42
						if (prep.decelerate_after < intersect_distance) { // Trapezoid type
    3cdc:	c2 01       	movw	r24, r4
    3cde:	b1 01       	movw	r22, r2
    3ce0:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    3ce4:	18 16       	cp	r1, r24
    3ce6:	d4 f5       	brge	.+116    	; 0x3d5c <st_prep_buffer+0x5f4>
							prep.maximum_speed = nominal_speed;
    3ce8:	f3 01       	movw	r30, r6
    3cea:	83 8e       	std	Z+27, r8	; 0x1b
    3cec:	94 8e       	std	Z+28, r9	; 0x1c
    3cee:	a5 8e       	std	Z+29, r10	; 0x1d
    3cf0:	b6 8e       	std	Z+30, r11	; 0x1e
							if (pl_block->entry_speed_sqr == nominal_speed_sqr) {
    3cf2:	ad 85       	ldd	r26, Y+13	; 0x0d
    3cf4:	be 85       	ldd	r27, Y+14	; 0x0e
    3cf6:	56 96       	adiw	r26, 0x16	; 22
    3cf8:	2d 90       	ld	r2, X+
    3cfa:	3d 90       	ld	r3, X+
    3cfc:	4d 90       	ld	r4, X+
    3cfe:	5c 90       	ld	r5, X
    3d00:	59 97       	sbiw	r26, 0x19	; 25
    3d02:	a2 01       	movw	r20, r4
    3d04:	91 01       	movw	r18, r2
    3d06:	6d 81       	ldd	r22, Y+5	; 0x05
    3d08:	7e 81       	ldd	r23, Y+6	; 0x06
    3d0a:	8f 81       	ldd	r24, Y+7	; 0x07
    3d0c:	98 85       	ldd	r25, Y+8	; 0x08
    3d0e:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    3d12:	81 11       	cpse	r24, r1
    3d14:	04 c0       	rjmp	.+8      	; 0x3d1e <st_prep_buffer+0x5b6>
								// Cruise-deceleration or cruise-only type.
								prep.ramp_type = RAMP_CRUISE;
    3d16:	21 e0       	ldi	r18, 0x01	; 1
    3d18:	f3 01       	movw	r30, r6
    3d1a:	22 8b       	std	Z+18, r18	; 0x12
    3d1c:	62 c0       	rjmp	.+196    	; 0x3de2 <st_prep_buffer+0x67a>
							} else {
								// Full-trapezoid or acceleration-cruise types
								prep.accelerate_until -= inv_2_accel*(nominal_speed_sqr-pl_block->entry_speed_sqr);
    3d1e:	a2 01       	movw	r20, r4
    3d20:	91 01       	movw	r18, r2
    3d22:	6d 81       	ldd	r22, Y+5	; 0x05
    3d24:	7e 81       	ldd	r23, Y+6	; 0x06
    3d26:	8f 81       	ldd	r24, Y+7	; 0x07
    3d28:	98 85       	ldd	r25, Y+8	; 0x08
    3d2a:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    3d2e:	29 81       	ldd	r18, Y+1	; 0x01
    3d30:	3a 81       	ldd	r19, Y+2	; 0x02
    3d32:	4b 81       	ldd	r20, Y+3	; 0x03
    3d34:	5c 81       	ldd	r21, Y+4	; 0x04
    3d36:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    3d3a:	9b 01       	movw	r18, r22
    3d3c:	ac 01       	movw	r20, r24
    3d3e:	d3 01       	movw	r26, r6
    3d40:	93 96       	adiw	r26, 0x23	; 35
    3d42:	6d 91       	ld	r22, X+
    3d44:	7d 91       	ld	r23, X+
    3d46:	8d 91       	ld	r24, X+
    3d48:	9c 91       	ld	r25, X
    3d4a:	96 97       	sbiw	r26, 0x26	; 38
    3d4c:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    3d50:	f3 01       	movw	r30, r6
    3d52:	63 a3       	std	Z+35, r22	; 0x23
    3d54:	74 a3       	std	Z+36, r23	; 0x24
    3d56:	85 a3       	std	Z+37, r24	; 0x25
    3d58:	96 a3       	std	Z+38, r25	; 0x26
    3d5a:	43 c0       	rjmp	.+134    	; 0x3de2 <st_prep_buffer+0x67a>
							}
						} else { // Triangle type
							prep.accelerate_until = intersect_distance;
    3d5c:	d3 01       	movw	r26, r6
    3d5e:	93 96       	adiw	r26, 0x23	; 35
    3d60:	2d 92       	st	X+, r2
    3d62:	3d 92       	st	X+, r3
    3d64:	4d 92       	st	X+, r4
    3d66:	5c 92       	st	X, r5
    3d68:	96 97       	sbiw	r26, 0x26	; 38
							prep.decelerate_after = intersect_distance;
    3d6a:	f3 01       	movw	r30, r6
    3d6c:	27 a2       	std	Z+39, r2	; 0x27
    3d6e:	30 a6       	std	Z+40, r3	; 0x28
    3d70:	41 a6       	std	Z+41, r4	; 0x29
    3d72:	52 a6       	std	Z+42, r5	; 0x2a
							prep.maximum_speed = sqrt(2.0*pl_block->acceleration*intersect_distance+exit_speed_sqr);
    3d74:	ad 85       	ldd	r26, Y+13	; 0x0d
    3d76:	be 85       	ldd	r27, Y+14	; 0x0e
    3d78:	5e 96       	adiw	r26, 0x1e	; 30
    3d7a:	cd 90       	ld	r12, X+
    3d7c:	dd 90       	ld	r13, X+
    3d7e:	ed 90       	ld	r14, X+
    3d80:	fc 90       	ld	r15, X
    3d82:	91 97       	sbiw	r26, 0x21	; 33
    3d84:	a7 01       	movw	r20, r14
    3d86:	96 01       	movw	r18, r12
    3d88:	c7 01       	movw	r24, r14
    3d8a:	b6 01       	movw	r22, r12
    3d8c:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    3d90:	a2 01       	movw	r20, r4
    3d92:	91 01       	movw	r18, r2
    3d94:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    3d98:	29 85       	ldd	r18, Y+9	; 0x09
    3d9a:	3a 85       	ldd	r19, Y+10	; 0x0a
    3d9c:	4b 85       	ldd	r20, Y+11	; 0x0b
    3d9e:	5c 85       	ldd	r21, Y+12	; 0x0c
    3da0:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    3da4:	0e 94 90 41 	call	0x8320	; 0x8320 <sqrt>
    3da8:	f3 01       	movw	r30, r6
    3daa:	63 8f       	std	Z+27, r22	; 0x1b
    3dac:	74 8f       	std	Z+28, r23	; 0x1c
    3dae:	85 8f       	std	Z+29, r24	; 0x1d
    3db0:	96 8f       	std	Z+30, r25	; 0x1e
    3db2:	17 c0       	rjmp	.+46     	; 0x3de2 <st_prep_buffer+0x67a>
						}
					} else { // Deceleration-only type
            prep.ramp_type = RAMP_DECEL;
    3db4:	e2 e0       	ldi	r30, 0x02	; 2
    3db6:	d3 01       	movw	r26, r6
    3db8:	52 96       	adiw	r26, 0x12	; 18
    3dba:	ec 93       	st	X, r30
    3dbc:	12 c0       	rjmp	.+36     	; 0x3de2 <st_prep_buffer+0x67a>
            // prep.decelerate_after = pl_block->millimeters;
            // prep.maximum_speed = prep.current_speed;
					}
				} else { // Acceleration-only type
					prep.accelerate_until = 0.0;
    3dbe:	d3 01       	movw	r26, r6
    3dc0:	93 96       	adiw	r26, 0x23	; 35
    3dc2:	1d 92       	st	X+, r1
    3dc4:	1d 92       	st	X+, r1
    3dc6:	1d 92       	st	X+, r1
    3dc8:	1c 92       	st	X, r1
    3dca:	96 97       	sbiw	r26, 0x26	; 38
					// prep.decelerate_after = 0.0;
					prep.maximum_speed = prep.exit_speed;
    3dcc:	5f 96       	adiw	r26, 0x1f	; 31
    3dce:	8d 91       	ld	r24, X+
    3dd0:	9d 91       	ld	r25, X+
    3dd2:	0d 90       	ld	r0, X+
    3dd4:	bc 91       	ld	r27, X
    3dd6:	a0 2d       	mov	r26, r0
    3dd8:	f3 01       	movw	r30, r6
    3dda:	83 8f       	std	Z+27, r24	; 0x1b
    3ddc:	94 8f       	std	Z+28, r25	; 0x1c
    3dde:	a5 8f       	std	Z+29, r26	; 0x1d
    3de0:	b6 8f       	std	Z+30, r27	; 0x1e
				}
			}
      
      bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM); // Force update whenever updating block.
    3de2:	80 91 1a 0c 	lds	r24, 0x0C1A	; 0x800c1a <sys+0x4>
    3de6:	88 60       	ori	r24, 0x08	; 8
    3de8:	80 93 1a 0c 	sts	0x0C1A, r24	; 0x800c1a <sys+0x4>
    }
    
    // Initialize new segment
    segment_t *prep_segment = &segment_buffer[segment_buffer_head];
    3dec:	e0 91 41 03 	lds	r30, 0x0341	; 0x800341 <segment_buffer_head>
    3df0:	2e 2f       	mov	r18, r30
    3df2:	30 e0       	ldi	r19, 0x00	; 0
    3df4:	3b ab       	std	Y+51, r19	; 0x33
    3df6:	2a ab       	std	Y+50, r18	; 0x32

    // Set new segment to point to the current segment data block.
    prep_segment->st_block_index = prep.st_block_index;
    3df8:	f9 01       	movw	r30, r18
    3dfa:	ee 0f       	add	r30, r30
    3dfc:	ff 1f       	adc	r31, r31
    3dfe:	ee 0f       	add	r30, r30
    3e00:	ff 1f       	adc	r31, r31
    3e02:	ee 0f       	add	r30, r30
    3e04:	ff 1f       	adc	r31, r31
    3e06:	ea 59       	subi	r30, 0x9A	; 154
    3e08:	fc 4f       	sbci	r31, 0xFC	; 252
    3e0a:	d3 01       	movw	r26, r6
    3e0c:	8c 91       	ld	r24, X
    3e0e:	84 83       	std	Z+4, r24	; 0x04
    float dt_max = DT_SEGMENT; // Maximum segment time
    float dt = 0.0; // Initialize segment time
    float time_var = dt_max; // Time worker variable
    float mm_var; // mm-Distance worker variable
    float speed_var; // Speed worker variable
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    3e10:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    3e14:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    3e18:	fb 8f       	std	Y+27, r31	; 0x1b
    3e1a:	ea 8f       	std	Y+26, r30	; 0x1a
    3e1c:	f2 a1       	ldd	r31, Z+34	; 0x22
    3e1e:	fa a7       	std	Y+42, r31	; 0x2a
    3e20:	aa 8d       	ldd	r26, Y+26	; 0x1a
    3e22:	bb 8d       	ldd	r27, Y+27	; 0x1b
    3e24:	93 96       	adiw	r26, 0x23	; 35
    3e26:	bc 91       	ld	r27, X
    3e28:	bb a7       	std	Y+43, r27	; 0x2b
    3e2a:	ea 8d       	ldd	r30, Y+26	; 0x1a
    3e2c:	fb 8d       	ldd	r31, Y+27	; 0x1b
    3e2e:	f4 a1       	ldd	r31, Z+36	; 0x24
    3e30:	fc a7       	std	Y+44, r31	; 0x2c
    3e32:	aa 8d       	ldd	r26, Y+26	; 0x1a
    3e34:	bb 8d       	ldd	r27, Y+27	; 0x1b
    3e36:	95 96       	adiw	r26, 0x25	; 37
    3e38:	bc 91       	ld	r27, X
    3e3a:	bd a7       	std	Y+45, r27	; 0x2d
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    3e3c:	f3 01       	movw	r30, r6
    3e3e:	26 85       	ldd	r18, Z+14	; 0x0e
    3e40:	37 85       	ldd	r19, Z+15	; 0x0f
    3e42:	40 89       	ldd	r20, Z+16	; 0x10
    3e44:	51 89       	ldd	r21, Z+17	; 0x11
    3e46:	6a a5       	ldd	r22, Y+42	; 0x2a
    3e48:	7b a5       	ldd	r23, Y+43	; 0x2b
    3e4a:	8c a5       	ldd	r24, Y+44	; 0x2c
    3e4c:	9b 2f       	mov	r25, r27
    3e4e:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    3e52:	6a a3       	std	Y+34, r22	; 0x22
    3e54:	7b a3       	std	Y+35, r23	; 0x23
    3e56:	8c a3       	std	Y+36, r24	; 0x24
    3e58:	9d a3       	std	Y+37, r25	; 0x25
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }
    3e5a:	20 e0       	ldi	r18, 0x00	; 0
    3e5c:	30 e0       	ldi	r19, 0x00	; 0
    3e5e:	a9 01       	movw	r20, r18
    3e60:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    3e64:	88 23       	and	r24, r24
    3e66:	24 f4       	brge	.+8      	; 0x3e70 <st_prep_buffer+0x708>
    3e68:	1a a2       	std	Y+34, r1	; 0x22
    3e6a:	1b a2       	std	Y+35, r1	; 0x23
    3e6c:	1c a2       	std	Y+36, r1	; 0x24
    3e6e:	1d a2       	std	Y+37, r1	; 0x25

    do {
      switch (prep.ramp_type) {
        case RAMP_DECEL_OVERRIDE:
          speed_var = pl_block->acceleration*time_var;
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
    3e70:	d3 01       	movw	r26, r6
    3e72:	5b 96       	adiw	r26, 0x1b	; 27
    3e74:	bc 91       	ld	r27, X
    3e76:	be 8b       	std	Y+22, r27	; 0x16
    3e78:	f3 01       	movw	r30, r6
    3e7a:	f4 8d       	ldd	r31, Z+28	; 0x1c
    3e7c:	ff 8b       	std	Y+23, r31	; 0x17
    3e7e:	d3 01       	movw	r26, r6
    3e80:	5d 96       	adiw	r26, 0x1d	; 29
    3e82:	bc 91       	ld	r27, X
    3e84:	b8 8f       	std	Y+24, r27	; 0x18
    3e86:	f3 01       	movw	r30, r6
    3e88:	f6 8d       	ldd	r31, Z+30	; 0x1e
    3e8a:	f9 8f       	std	Y+25, r31	; 0x19
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
    3e8c:	d3 01       	movw	r26, r6
    3e8e:	93 96       	adiw	r26, 0x23	; 35
    3e90:	bc 91       	ld	r27, X
    3e92:	be 8f       	std	Y+30, r27	; 0x1e
    3e94:	f3 01       	movw	r30, r6
    3e96:	f4 a1       	ldd	r31, Z+36	; 0x24
    3e98:	ff 8f       	std	Y+31, r31	; 0x1f
    3e9a:	d3 01       	movw	r26, r6
    3e9c:	95 96       	adiw	r26, 0x25	; 37
    3e9e:	bc 91       	ld	r27, X
    3ea0:	b8 a3       	std	Y+32, r27	; 0x20
    3ea2:	f3 01       	movw	r30, r6
    3ea4:	f6 a1       	ldd	r31, Z+38	; 0x26
    3ea6:	f9 a3       	std	Y+33, r31	; 0x21
    3ea8:	d3 01       	movw	r26, r6
    3eaa:	57 96       	adiw	r26, 0x17	; 23
    3eac:	bc 91       	ld	r27, X
    3eae:	b9 83       	std	Y+1, r27	; 0x01
    3eb0:	f3 01       	movw	r30, r6
    3eb2:	f0 8d       	ldd	r31, Z+24	; 0x18
    3eb4:	fd 83       	std	Y+5, r31	; 0x05
    3eb6:	d3 01       	movw	r26, r6
    3eb8:	59 96       	adiw	r26, 0x19	; 25
    3eba:	bc 91       	ld	r27, X
    3ebc:	b9 87       	std	Y+9, r27	; 0x09
    3ebe:	f3 01       	movw	r30, r6
    3ec0:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3ec2:	f9 8b       	std	Y+17, r31	; 0x11
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    3ec4:	d3 01       	movw	r26, r6
    3ec6:	97 96       	adiw	r26, 0x27	; 39
    3ec8:	bc 91       	ld	r27, X
    3eca:	be a3       	std	Y+38, r27	; 0x26
    3ecc:	f3 01       	movw	r30, r6
    3ece:	f0 a5       	ldd	r31, Z+40	; 0x28
    3ed0:	ff a3       	std	Y+39, r31	; 0x27
    3ed2:	d3 01       	movw	r26, r6
    3ed4:	99 96       	adiw	r26, 0x29	; 41
    3ed6:	bc 91       	ld	r27, X
    3ed8:	b8 a7       	std	Y+40, r27	; 0x28
    3eda:	f3 01       	movw	r30, r6
    3edc:	f2 a5       	ldd	r31, Z+42	; 0x2a
    3ede:	f9 a7       	std	Y+41, r31	; 0x29
    3ee0:	d3 01       	movw	r26, r6
    3ee2:	52 96       	adiw	r26, 0x12	; 18
    3ee4:	bc 91       	ld	r27, X
    3ee6:	bd 8f       	std	Y+29, r27	; 0x1d
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
    3ee8:	f3 01       	movw	r30, r6
    3eea:	f3 89       	ldd	r31, Z+19	; 0x13
    3eec:	fa 8b       	std	Y+18, r31	; 0x12
    3eee:	d3 01       	movw	r26, r6
    3ef0:	54 96       	adiw	r26, 0x14	; 20
    3ef2:	bc 91       	ld	r27, X
    3ef4:	bb 8b       	std	Y+19, r27	; 0x13
    3ef6:	f3 01       	movw	r30, r6
    3ef8:	f5 89       	ldd	r31, Z+21	; 0x15
    3efa:	fc 8b       	std	Y+20, r31	; 0x14
    3efc:	d3 01       	movw	r26, r6
    3efe:	56 96       	adiw	r26, 0x16	; 22
    3f00:	bc 91       	ld	r27, X
    3f02:	bd 8b       	std	Y+21, r27	; 0x15
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    3f04:	f3 01       	movw	r30, r6
    3f06:	f7 8d       	ldd	r31, Z+31	; 0x1f
    3f08:	fe a7       	std	Y+46, r31	; 0x2e
    3f0a:	d3 01       	movw	r26, r6
    3f0c:	90 96       	adiw	r26, 0x20	; 32
    3f0e:	bc 91       	ld	r27, X
    3f10:	bf a7       	std	Y+47, r27	; 0x2f
    3f12:	f3 01       	movw	r30, r6
    3f14:	f1 a1       	ldd	r31, Z+33	; 0x21
    3f16:	f8 ab       	std	Y+48, r31	; 0x30
    3f18:	d3 01       	movw	r26, r6
    3f1a:	92 96       	adiw	r26, 0x22	; 34
    3f1c:	bc 91       	ld	r27, X
    3f1e:	b9 ab       	std	Y+49, r27	; 0x31
    3f20:	2e a1       	ldd	r18, Y+38	; 0x26
    3f22:	3f a1       	ldd	r19, Y+39	; 0x27
    3f24:	48 a5       	ldd	r20, Y+40	; 0x28
    3f26:	59 a5       	ldd	r21, Y+41	; 0x29
    3f28:	6e 8d       	ldd	r22, Y+30	; 0x1e
    3f2a:	7f 8d       	ldd	r23, Y+31	; 0x1f
    3f2c:	88 a1       	ldd	r24, Y+32	; 0x20
    3f2e:	99 a1       	ldd	r25, Y+33	; 0x21
    3f30:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    3f34:	81 11       	cpse	r24, r1
    3f36:	02 c0       	rjmp	.+4      	; 0x3f3c <st_prep_buffer+0x7d4>
    3f38:	8a ad       	ldd	r24, Y+58	; 0x3a
    3f3a:	01 c0       	rjmp	.+2      	; 0x3f3e <st_prep_buffer+0x7d6>
    3f3c:	81 e0       	ldi	r24, 0x01	; 1
    3f3e:	5a a4       	ldd	r5, Y+42	; 0x2a
    3f40:	1b a5       	ldd	r17, Y+43	; 0x2b
    3f42:	0c a5       	ldd	r16, Y+44	; 0x2c
    3f44:	ed a5       	ldd	r30, Y+45	; 0x2d
    3f46:	ec 8f       	std	Y+28, r30	; 0x1c
    3f48:	0f 2e       	mov	r0, r31
    3f4a:	fe e3       	ldi	r31, 0x3E	; 62
    3f4c:	4f 2e       	mov	r4, r31
    3f4e:	f0 2d       	mov	r31, r0
    3f50:	0f 2e       	mov	r0, r31
    3f52:	f3 ec       	ldi	r31, 0xC3	; 195
    3f54:	3f 2e       	mov	r3, r31
    3f56:	f0 2d       	mov	r31, r0
    3f58:	0f 2e       	mov	r0, r31
    3f5a:	fe e2       	ldi	r31, 0x2E	; 46
    3f5c:	2f 2e       	mov	r2, r31
    3f5e:	f0 2d       	mov	r31, r0
    3f60:	0f 2e       	mov	r0, r31
    3f62:	f9 e3       	ldi	r31, 0x39	; 57
    3f64:	ff 2e       	mov	r15, r31
    3f66:	f0 2d       	mov	r31, r0
    3f68:	81 2c       	mov	r8, r1
    3f6a:	91 2c       	mov	r9, r1
    3f6c:	54 01       	movw	r10, r8
    3f6e:	0f 2e       	mov	r0, r31
    3f70:	fe e3       	ldi	r31, 0x3E	; 62
    3f72:	cf 2e       	mov	r12, r31
    3f74:	f0 2d       	mov	r31, r0
    3f76:	0f 2e       	mov	r0, r31
    3f78:	f3 ec       	ldi	r31, 0xC3	; 195
    3f7a:	df 2e       	mov	r13, r31
    3f7c:	f0 2d       	mov	r31, r0
    3f7e:	0f 2e       	mov	r0, r31
    3f80:	fe e2       	ldi	r31, 0x2E	; 46
    3f82:	ef 2e       	mov	r14, r31
    3f84:	f0 2d       	mov	r31, r0
    3f86:	f9 e3       	ldi	r31, 0x39	; 57
    3f88:	fd 87       	std	Y+13, r31	; 0x0d
    3f8a:	8d ab       	std	Y+53, r24	; 0x35
    3f8c:	2d 8d       	ldd	r18, Y+29	; 0x1d
    3f8e:	2c af       	std	Y+60, r18	; 0x3c
    3f90:	7f aa       	std	Y+55, r7	; 0x37
    3f92:	6e aa       	std	Y+54, r6	; 0x36
    3f94:	7c 2c       	mov	r7, r12
    3f96:	81 2f       	mov	r24, r17
    3f98:	1e 2d       	mov	r17, r14
    3f9a:	e5 2c       	mov	r14, r5
    3f9c:	5d 2c       	mov	r5, r13
    3f9e:	c0 2e       	mov	r12, r16
    3fa0:	09 e3       	ldi	r16, 0x39	; 57
    3fa2:	fb ae       	std	Y+59, r15	; 0x3b
    3fa4:	fe 2e       	mov	r15, r30
    3fa6:	d8 2e       	mov	r13, r24
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }

    do {
      switch (prep.ramp_type) {
    3fa8:	3c ad       	ldd	r19, Y+60	; 0x3c
    3faa:	31 30       	cpi	r19, 0x01	; 1
    3fac:	09 f4       	brne	.+2      	; 0x3fb0 <st_prep_buffer+0x848>
    3fae:	0f c1       	rjmp	.+542    	; 0x41ce <st_prep_buffer+0xa66>
    3fb0:	08 f4       	brcc	.+2      	; 0x3fb4 <st_prep_buffer+0x84c>
    3fb2:	8f c0       	rjmp	.+286    	; 0x40d2 <st_prep_buffer+0x96a>
    3fb4:	33 30       	cpi	r19, 0x03	; 3
    3fb6:	09 f0       	breq	.+2      	; 0x3fba <st_prep_buffer+0x852>
    3fb8:	48 c1       	rjmp	.+656    	; 0x424a <st_prep_buffer+0xae2>
        case RAMP_DECEL_OVERRIDE:
          speed_var = pl_block->acceleration*time_var;
    3fba:	aa 8d       	ldd	r26, Y+26	; 0x1a
    3fbc:	bb 8d       	ldd	r27, Y+27	; 0x1b
    3fbe:	5e 96       	adiw	r26, 0x1e	; 30
    3fc0:	2d 91       	ld	r18, X+
    3fc2:	3d 91       	ld	r19, X+
    3fc4:	4d 91       	ld	r20, X+
    3fc6:	5c 91       	ld	r21, X
    3fc8:	91 97       	sbiw	r26, 0x21	; 33
    3fca:	64 2d       	mov	r22, r4
    3fcc:	73 2d       	mov	r23, r3
    3fce:	82 2d       	mov	r24, r2
    3fd0:	9b ad       	ldd	r25, Y+59	; 0x3b
    3fd2:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    3fd6:	6d 87       	std	Y+13, r22	; 0x0d
    3fd8:	7e 87       	std	Y+14, r23	; 0x0e
    3fda:	8f 87       	std	Y+15, r24	; 0x0f
    3fdc:	98 8b       	std	Y+16, r25	; 0x10
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
    3fde:	2e 89       	ldd	r18, Y+22	; 0x16
    3fe0:	3f 89       	ldd	r19, Y+23	; 0x17
    3fe2:	48 8d       	ldd	r20, Y+24	; 0x18
    3fe4:	59 8d       	ldd	r21, Y+25	; 0x19
    3fe6:	69 81       	ldd	r22, Y+1	; 0x01
    3fe8:	7d 81       	ldd	r23, Y+5	; 0x05
    3fea:	89 85       	ldd	r24, Y+9	; 0x09
    3fec:	99 89       	ldd	r25, Y+17	; 0x11
    3fee:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    3ff2:	9b 01       	movw	r18, r22
    3ff4:	ac 01       	movw	r20, r24
    3ff6:	6d 85       	ldd	r22, Y+13	; 0x0d
    3ff8:	7e 85       	ldd	r23, Y+14	; 0x0e
    3ffa:	8f 85       	ldd	r24, Y+15	; 0x0f
    3ffc:	98 89       	ldd	r25, Y+16	; 0x10
    3ffe:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    4002:	88 23       	and	r24, r24
    4004:	9c f1       	brlt	.+102    	; 0x406c <st_prep_buffer+0x904>
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    4006:	2e 8d       	ldd	r18, Y+30	; 0x1e
    4008:	3f 8d       	ldd	r19, Y+31	; 0x1f
    400a:	48 a1       	ldd	r20, Y+32	; 0x20
    400c:	59 a1       	ldd	r21, Y+33	; 0x21
    400e:	6a a5       	ldd	r22, Y+42	; 0x2a
    4010:	7b a5       	ldd	r23, Y+43	; 0x2b
    4012:	8c a5       	ldd	r24, Y+44	; 0x2c
    4014:	9d a5       	ldd	r25, Y+45	; 0x2d
    4016:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    401a:	9b 01       	movw	r18, r22
    401c:	ac 01       	movw	r20, r24
    401e:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    4022:	6b 01       	movw	r12, r22
    4024:	7c 01       	movw	r14, r24
    4026:	29 81       	ldd	r18, Y+1	; 0x01
    4028:	3d 81       	ldd	r19, Y+5	; 0x05
    402a:	49 85       	ldd	r20, Y+9	; 0x09
    402c:	59 89       	ldd	r21, Y+17	; 0x11
    402e:	6e 89       	ldd	r22, Y+22	; 0x16
    4030:	7f 89       	ldd	r23, Y+23	; 0x17
    4032:	88 8d       	ldd	r24, Y+24	; 0x18
    4034:	99 8d       	ldd	r25, Y+25	; 0x19
    4036:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    403a:	9b 01       	movw	r18, r22
    403c:	ac 01       	movw	r20, r24
    403e:	c7 01       	movw	r24, r14
    4040:	b6 01       	movw	r22, r12
    4042:	0e 94 cc 3e 	call	0x7d98	; 0x7d98 <__divsf3>
    4046:	46 2e       	mov	r4, r22
    4048:	37 2e       	mov	r3, r23
    404a:	28 2e       	mov	r2, r24
    404c:	9b af       	std	Y+59, r25	; 0x3b
            prep.ramp_type = RAMP_CRUISE;
            prep.current_speed = prep.maximum_speed;
    404e:	be 89       	ldd	r27, Y+22	; 0x16
    4050:	b9 83       	std	Y+1, r27	; 0x01
    4052:	ef 89       	ldd	r30, Y+23	; 0x17
    4054:	ed 83       	std	Y+5, r30	; 0x05
    4056:	f8 8d       	ldd	r31, Y+24	; 0x18
    4058:	f9 87       	std	Y+9, r31	; 0x09
    405a:	29 8d       	ldd	r18, Y+25	; 0x19
    405c:	29 8b       	std	Y+17, r18	; 0x11
      switch (prep.ramp_type) {
        case RAMP_DECEL_OVERRIDE:
          speed_var = pl_block->acceleration*time_var;
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
    405e:	ee 8c       	ldd	r14, Y+30	; 0x1e
    4060:	df 8c       	ldd	r13, Y+31	; 0x1f
    4062:	c8 a0       	ldd	r12, Y+32	; 0x20
    4064:	f9 a0       	ldd	r15, Y+33	; 0x21
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            prep.ramp_type = RAMP_CRUISE;
    4066:	38 ad       	ldd	r19, Y+56	; 0x38
    4068:	3c af       	std	Y+60, r19	; 0x3c
    406a:	80 c1       	rjmp	.+768    	; 0x436c <st_prep_buffer+0xc04>
            prep.current_speed = prep.maximum_speed;
          } else { // Mid-deceleration override ramp.
            mm_remaining -= time_var*(prep.current_speed - 0.5*speed_var);
    406c:	20 e0       	ldi	r18, 0x00	; 0
    406e:	30 e0       	ldi	r19, 0x00	; 0
    4070:	40 e0       	ldi	r20, 0x00	; 0
    4072:	5f e3       	ldi	r21, 0x3F	; 63
    4074:	6d 85       	ldd	r22, Y+13	; 0x0d
    4076:	7e 85       	ldd	r23, Y+14	; 0x0e
    4078:	8f 85       	ldd	r24, Y+15	; 0x0f
    407a:	98 89       	ldd	r25, Y+16	; 0x10
    407c:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    4080:	9b 01       	movw	r18, r22
    4082:	ac 01       	movw	r20, r24
    4084:	69 81       	ldd	r22, Y+1	; 0x01
    4086:	7d 81       	ldd	r23, Y+5	; 0x05
    4088:	89 85       	ldd	r24, Y+9	; 0x09
    408a:	99 89       	ldd	r25, Y+17	; 0x11
    408c:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    4090:	24 2d       	mov	r18, r4
    4092:	33 2d       	mov	r19, r3
    4094:	42 2d       	mov	r20, r2
    4096:	5b ad       	ldd	r21, Y+59	; 0x3b
    4098:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    409c:	9b 01       	movw	r18, r22
    409e:	ac 01       	movw	r20, r24
    40a0:	6e 2d       	mov	r22, r14
    40a2:	7d 2d       	mov	r23, r13
    40a4:	8c 2d       	mov	r24, r12
    40a6:	9f 2d       	mov	r25, r15
    40a8:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    40ac:	e6 2e       	mov	r14, r22
    40ae:	d7 2e       	mov	r13, r23
    40b0:	c8 2e       	mov	r12, r24
    40b2:	f9 2e       	mov	r15, r25
            prep.current_speed -= speed_var;
    40b4:	2d 85       	ldd	r18, Y+13	; 0x0d
    40b6:	3e 85       	ldd	r19, Y+14	; 0x0e
    40b8:	4f 85       	ldd	r20, Y+15	; 0x0f
    40ba:	58 89       	ldd	r21, Y+16	; 0x10
    40bc:	69 81       	ldd	r22, Y+1	; 0x01
    40be:	7d 81       	ldd	r23, Y+5	; 0x05
    40c0:	89 85       	ldd	r24, Y+9	; 0x09
    40c2:	99 89       	ldd	r25, Y+17	; 0x11
    40c4:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    40c8:	69 83       	std	Y+1, r22	; 0x01
    40ca:	7d 83       	std	Y+5, r23	; 0x05
    40cc:	89 87       	std	Y+9, r24	; 0x09
    40ce:	99 8b       	std	Y+17, r25	; 0x11
    40d0:	4d c1       	rjmp	.+666    	; 0x436c <st_prep_buffer+0xc04>
          }
          break;
        case RAMP_ACCEL:
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
    40d2:	aa 8d       	ldd	r26, Y+26	; 0x1a
    40d4:	bb 8d       	ldd	r27, Y+27	; 0x1b
    40d6:	5e 96       	adiw	r26, 0x1e	; 30
    40d8:	2d 91       	ld	r18, X+
    40da:	3d 91       	ld	r19, X+
    40dc:	4d 91       	ld	r20, X+
    40de:	5c 91       	ld	r21, X
    40e0:	91 97       	sbiw	r26, 0x21	; 33
    40e2:	64 2d       	mov	r22, r4
    40e4:	73 2d       	mov	r23, r3
    40e6:	82 2d       	mov	r24, r2
    40e8:	9b ad       	ldd	r25, Y+59	; 0x3b
    40ea:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    40ee:	6d 87       	std	Y+13, r22	; 0x0d
    40f0:	7e 87       	std	Y+14, r23	; 0x0e
    40f2:	8f 87       	std	Y+15, r24	; 0x0f
    40f4:	98 8b       	std	Y+16, r25	; 0x10
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
    40f6:	20 e0       	ldi	r18, 0x00	; 0
    40f8:	30 e0       	ldi	r19, 0x00	; 0
    40fa:	40 e0       	ldi	r20, 0x00	; 0
    40fc:	5f e3       	ldi	r21, 0x3F	; 63
    40fe:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    4102:	29 81       	ldd	r18, Y+1	; 0x01
    4104:	3d 81       	ldd	r19, Y+5	; 0x05
    4106:	49 85       	ldd	r20, Y+9	; 0x09
    4108:	59 89       	ldd	r21, Y+17	; 0x11
    410a:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    410e:	24 2d       	mov	r18, r4
    4110:	33 2d       	mov	r19, r3
    4112:	42 2d       	mov	r20, r2
    4114:	5b ad       	ldd	r21, Y+59	; 0x3b
    4116:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    411a:	9b 01       	movw	r18, r22
    411c:	ac 01       	movw	r20, r24
    411e:	6e 2d       	mov	r22, r14
    4120:	7d 2d       	mov	r23, r13
    4122:	8c 2d       	mov	r24, r12
    4124:	9f 2d       	mov	r25, r15
    4126:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    412a:	e6 2e       	mov	r14, r22
    412c:	d7 2e       	mov	r13, r23
    412e:	c8 2e       	mov	r12, r24
    4130:	f9 2e       	mov	r15, r25
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    4132:	26 2f       	mov	r18, r22
    4134:	37 2f       	mov	r19, r23
    4136:	48 2f       	mov	r20, r24
    4138:	59 2f       	mov	r21, r25
    413a:	6e 8d       	ldd	r22, Y+30	; 0x1e
    413c:	7f 8d       	ldd	r23, Y+31	; 0x1f
    413e:	88 a1       	ldd	r24, Y+32	; 0x20
    4140:	99 a1       	ldd	r25, Y+33	; 0x21
    4142:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    4146:	18 16       	cp	r1, r24
    4148:	9c f5       	brge	.+102    	; 0x41b0 <st_prep_buffer+0xa48>
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    414a:	2e 8d       	ldd	r18, Y+30	; 0x1e
    414c:	3f 8d       	ldd	r19, Y+31	; 0x1f
    414e:	48 a1       	ldd	r20, Y+32	; 0x20
    4150:	59 a1       	ldd	r21, Y+33	; 0x21
    4152:	6a a5       	ldd	r22, Y+42	; 0x2a
    4154:	7b a5       	ldd	r23, Y+43	; 0x2b
    4156:	8c a5       	ldd	r24, Y+44	; 0x2c
    4158:	9d a5       	ldd	r25, Y+45	; 0x2d
    415a:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    415e:	9b 01       	movw	r18, r22
    4160:	ac 01       	movw	r20, r24
    4162:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    4166:	6b 01       	movw	r12, r22
    4168:	7c 01       	movw	r14, r24
    416a:	29 81       	ldd	r18, Y+1	; 0x01
    416c:	3d 81       	ldd	r19, Y+5	; 0x05
    416e:	49 85       	ldd	r20, Y+9	; 0x09
    4170:	59 89       	ldd	r21, Y+17	; 0x11
    4172:	6e 89       	ldd	r22, Y+22	; 0x16
    4174:	7f 89       	ldd	r23, Y+23	; 0x17
    4176:	88 8d       	ldd	r24, Y+24	; 0x18
    4178:	99 8d       	ldd	r25, Y+25	; 0x19
    417a:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    417e:	9b 01       	movw	r18, r22
    4180:	ac 01       	movw	r20, r24
    4182:	c7 01       	movw	r24, r14
    4184:	b6 01       	movw	r22, r12
    4186:	0e 94 cc 3e 	call	0x7d98	; 0x7d98 <__divsf3>
    418a:	46 2e       	mov	r4, r22
    418c:	37 2e       	mov	r3, r23
    418e:	28 2e       	mov	r2, r24
    4190:	9b af       	std	Y+59, r25	; 0x3b
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
    4192:	be 89       	ldd	r27, Y+22	; 0x16
    4194:	b9 83       	std	Y+1, r27	; 0x01
    4196:	ef 89       	ldd	r30, Y+23	; 0x17
    4198:	ed 83       	std	Y+5, r30	; 0x05
    419a:	f8 8d       	ldd	r31, Y+24	; 0x18
    419c:	f9 87       	std	Y+9, r31	; 0x09
    419e:	29 8d       	ldd	r18, Y+25	; 0x19
    41a0:	29 8b       	std	Y+17, r18	; 0x11
    41a2:	3d a9       	ldd	r19, Y+53	; 0x35
    41a4:	3c af       	std	Y+60, r19	; 0x3c
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
    41a6:	ee 8c       	ldd	r14, Y+30	; 0x1e
    41a8:	df 8c       	ldd	r13, Y+31	; 0x1f
    41aa:	c8 a0       	ldd	r12, Y+32	; 0x20
    41ac:	f9 a0       	ldd	r15, Y+33	; 0x21
    41ae:	de c0       	rjmp	.+444    	; 0x436c <st_prep_buffer+0xc04>
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
          } else { // Acceleration only.
            prep.current_speed += speed_var;
    41b0:	2d 85       	ldd	r18, Y+13	; 0x0d
    41b2:	3e 85       	ldd	r19, Y+14	; 0x0e
    41b4:	4f 85       	ldd	r20, Y+15	; 0x0f
    41b6:	58 89       	ldd	r21, Y+16	; 0x10
    41b8:	69 81       	ldd	r22, Y+1	; 0x01
    41ba:	7d 81       	ldd	r23, Y+5	; 0x05
    41bc:	89 85       	ldd	r24, Y+9	; 0x09
    41be:	99 89       	ldd	r25, Y+17	; 0x11
    41c0:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    41c4:	69 83       	std	Y+1, r22	; 0x01
    41c6:	7d 83       	std	Y+5, r23	; 0x05
    41c8:	89 87       	std	Y+9, r24	; 0x09
    41ca:	99 8b       	std	Y+17, r25	; 0x11
    41cc:	cf c0       	rjmp	.+414    	; 0x436c <st_prep_buffer+0xc04>
          break;
        case RAMP_CRUISE:
          // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
          // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To
          //   prevent this, simply enforce a minimum speed threshold in the planner.
          mm_var = mm_remaining - prep.maximum_speed*time_var;
    41ce:	2e 89       	ldd	r18, Y+22	; 0x16
    41d0:	3f 89       	ldd	r19, Y+23	; 0x17
    41d2:	48 8d       	ldd	r20, Y+24	; 0x18
    41d4:	59 8d       	ldd	r21, Y+25	; 0x19
    41d6:	64 2d       	mov	r22, r4
    41d8:	73 2d       	mov	r23, r3
    41da:	82 2d       	mov	r24, r2
    41dc:	9b ad       	ldd	r25, Y+59	; 0x3b
    41de:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    41e2:	9b 01       	movw	r18, r22
    41e4:	ac 01       	movw	r20, r24
    41e6:	6e 2d       	mov	r22, r14
    41e8:	7d 2d       	mov	r23, r13
    41ea:	8c 2d       	mov	r24, r12
    41ec:	9f 2d       	mov	r25, r15
    41ee:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    41f2:	6d 87       	std	Y+13, r22	; 0x0d
    41f4:	7c 8f       	std	Y+28, r23	; 0x1c
    41f6:	8d 8f       	std	Y+29, r24	; 0x1d
    41f8:	69 2e       	mov	r6, r25
          if (mm_var < prep.decelerate_after) { // End of cruise.
    41fa:	26 2f       	mov	r18, r22
    41fc:	37 2f       	mov	r19, r23
    41fe:	48 2f       	mov	r20, r24
    4200:	59 2f       	mov	r21, r25
    4202:	6e a1       	ldd	r22, Y+38	; 0x26
    4204:	7f a1       	ldd	r23, Y+39	; 0x27
    4206:	88 a5       	ldd	r24, Y+40	; 0x28
    4208:	99 a5       	ldd	r25, Y+41	; 0x29
    420a:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    420e:	18 16       	cp	r1, r24
    4210:	0c f0       	brlt	.+2      	; 0x4214 <st_prep_buffer+0xaac>
    4212:	a8 c0       	rjmp	.+336    	; 0x4364 <st_prep_buffer+0xbfc>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
    4214:	2e a1       	ldd	r18, Y+38	; 0x26
    4216:	3f a1       	ldd	r19, Y+39	; 0x27
    4218:	48 a5       	ldd	r20, Y+40	; 0x28
    421a:	59 a5       	ldd	r21, Y+41	; 0x29
    421c:	6e 2d       	mov	r22, r14
    421e:	7d 2d       	mov	r23, r13
    4220:	8c 2d       	mov	r24, r12
    4222:	9f 2d       	mov	r25, r15
    4224:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    4228:	2e 89       	ldd	r18, Y+22	; 0x16
    422a:	3f 89       	ldd	r19, Y+23	; 0x17
    422c:	48 8d       	ldd	r20, Y+24	; 0x18
    422e:	59 8d       	ldd	r21, Y+25	; 0x19
    4230:	0e 94 cc 3e 	call	0x7d98	; 0x7d98 <__divsf3>
    4234:	46 2e       	mov	r4, r22
    4236:	37 2e       	mov	r3, r23
    4238:	28 2e       	mov	r2, r24
    423a:	9b af       	std	Y+59, r25	; 0x3b
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
    423c:	ee a0       	ldd	r14, Y+38	; 0x26
    423e:	df a0       	ldd	r13, Y+39	; 0x27
    4240:	c8 a4       	ldd	r12, Y+40	; 0x28
    4242:	f9 a4       	ldd	r15, Y+41	; 0x29
            prep.ramp_type = RAMP_DECEL;
    4244:	49 ad       	ldd	r20, Y+57	; 0x39
    4246:	4c af       	std	Y+60, r20	; 0x3c
    4248:	91 c0       	rjmp	.+290    	; 0x436c <st_prep_buffer+0xc04>
            mm_remaining = mm_var;
          }
          break;
        default: // case RAMP_DECEL:
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
    424a:	aa 8d       	ldd	r26, Y+26	; 0x1a
    424c:	bb 8d       	ldd	r27, Y+27	; 0x1b
    424e:	5e 96       	adiw	r26, 0x1e	; 30
    4250:	2d 91       	ld	r18, X+
    4252:	3d 91       	ld	r19, X+
    4254:	4d 91       	ld	r20, X+
    4256:	5c 91       	ld	r21, X
    4258:	91 97       	sbiw	r26, 0x21	; 33
    425a:	64 2d       	mov	r22, r4
    425c:	73 2d       	mov	r23, r3
    425e:	82 2d       	mov	r24, r2
    4260:	9b ad       	ldd	r25, Y+59	; 0x3b
    4262:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    4266:	6d 87       	std	Y+13, r22	; 0x0d
    4268:	7e 87       	std	Y+14, r23	; 0x0e
    426a:	8f 87       	std	Y+15, r24	; 0x0f
    426c:	98 8b       	std	Y+16, r25	; 0x10
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
    426e:	9b 01       	movw	r18, r22
    4270:	ac 01       	movw	r20, r24
    4272:	69 81       	ldd	r22, Y+1	; 0x01
    4274:	7d 81       	ldd	r23, Y+5	; 0x05
    4276:	89 85       	ldd	r24, Y+9	; 0x09
    4278:	99 89       	ldd	r25, Y+17	; 0x11
    427a:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    427e:	18 16       	cp	r1, r24
    4280:	0c f0       	brlt	.+2      	; 0x4284 <st_prep_buffer+0xb1c>
    4282:	3f c0       	rjmp	.+126    	; 0x4302 <st_prep_buffer+0xb9a>
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
    4284:	20 e0       	ldi	r18, 0x00	; 0
    4286:	30 e0       	ldi	r19, 0x00	; 0
    4288:	40 e0       	ldi	r20, 0x00	; 0
    428a:	5f e3       	ldi	r21, 0x3F	; 63
    428c:	6d 85       	ldd	r22, Y+13	; 0x0d
    428e:	7e 85       	ldd	r23, Y+14	; 0x0e
    4290:	8f 85       	ldd	r24, Y+15	; 0x0f
    4292:	98 89       	ldd	r25, Y+16	; 0x10
    4294:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    4298:	9b 01       	movw	r18, r22
    429a:	ac 01       	movw	r20, r24
    429c:	69 81       	ldd	r22, Y+1	; 0x01
    429e:	7d 81       	ldd	r23, Y+5	; 0x05
    42a0:	89 85       	ldd	r24, Y+9	; 0x09
    42a2:	99 89       	ldd	r25, Y+17	; 0x11
    42a4:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    42a8:	24 2d       	mov	r18, r4
    42aa:	33 2d       	mov	r19, r3
    42ac:	42 2d       	mov	r20, r2
    42ae:	5b ad       	ldd	r21, Y+59	; 0x3b
    42b0:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    42b4:	9b 01       	movw	r18, r22
    42b6:	ac 01       	movw	r20, r24
    42b8:	6e 2d       	mov	r22, r14
    42ba:	7d 2d       	mov	r23, r13
    42bc:	8c 2d       	mov	r24, r12
    42be:	9f 2d       	mov	r25, r15
    42c0:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    42c4:	6c 8f       	std	Y+28, r22	; 0x1c
    42c6:	7d 8f       	std	Y+29, r23	; 0x1d
    42c8:	8c ab       	std	Y+52, r24	; 0x34
    42ca:	69 2e       	mov	r6, r25
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
    42cc:	2a 89       	ldd	r18, Y+18	; 0x12
    42ce:	3b 89       	ldd	r19, Y+19	; 0x13
    42d0:	4c 89       	ldd	r20, Y+20	; 0x14
    42d2:	5d 89       	ldd	r21, Y+21	; 0x15
    42d4:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    42d8:	18 16       	cp	r1, r24
    42da:	9c f4       	brge	.+38     	; 0x4302 <st_prep_buffer+0xb9a>
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
    42dc:	2d 85       	ldd	r18, Y+13	; 0x0d
    42de:	3e 85       	ldd	r19, Y+14	; 0x0e
    42e0:	4f 85       	ldd	r20, Y+15	; 0x0f
    42e2:	58 89       	ldd	r21, Y+16	; 0x10
    42e4:	69 81       	ldd	r22, Y+1	; 0x01
    42e6:	7d 81       	ldd	r23, Y+5	; 0x05
    42e8:	89 85       	ldd	r24, Y+9	; 0x09
    42ea:	99 89       	ldd	r25, Y+17	; 0x11
    42ec:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    42f0:	69 83       	std	Y+1, r22	; 0x01
    42f2:	7d 83       	std	Y+5, r23	; 0x05
    42f4:	89 87       	std	Y+9, r24	; 0x09
    42f6:	99 8b       	std	Y+17, r25	; 0x11
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
              mm_remaining = mm_var;
    42f8:	ec 8c       	ldd	r14, Y+28	; 0x1c
    42fa:	dd 8c       	ldd	r13, Y+29	; 0x1d
    42fc:	cc a8       	ldd	r12, Y+52	; 0x34
    42fe:	f6 2c       	mov	r15, r6
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
    4300:	35 c0       	rjmp	.+106    	; 0x436c <st_prep_buffer+0xc04>
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    4302:	2a 89       	ldd	r18, Y+18	; 0x12
    4304:	3b 89       	ldd	r19, Y+19	; 0x13
    4306:	4c 89       	ldd	r20, Y+20	; 0x14
    4308:	5d 89       	ldd	r21, Y+21	; 0x15
    430a:	6e 2d       	mov	r22, r14
    430c:	7d 2d       	mov	r23, r13
    430e:	8c 2d       	mov	r24, r12
    4310:	9f 2d       	mov	r25, r15
    4312:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    4316:	9b 01       	movw	r18, r22
    4318:	ac 01       	movw	r20, r24
    431a:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    431e:	6b 01       	movw	r12, r22
    4320:	7c 01       	movw	r14, r24
    4322:	2e a5       	ldd	r18, Y+46	; 0x2e
    4324:	3f a5       	ldd	r19, Y+47	; 0x2f
    4326:	48 a9       	ldd	r20, Y+48	; 0x30
    4328:	59 a9       	ldd	r21, Y+49	; 0x31
    432a:	69 81       	ldd	r22, Y+1	; 0x01
    432c:	7d 81       	ldd	r23, Y+5	; 0x05
    432e:	89 85       	ldd	r24, Y+9	; 0x09
    4330:	99 89       	ldd	r25, Y+17	; 0x11
    4332:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    4336:	9b 01       	movw	r18, r22
    4338:	ac 01       	movw	r20, r24
    433a:	c7 01       	movw	r24, r14
    433c:	b6 01       	movw	r22, r12
    433e:	0e 94 cc 3e 	call	0x7d98	; 0x7d98 <__divsf3>
    4342:	46 2e       	mov	r4, r22
    4344:	37 2e       	mov	r3, r23
    4346:	28 2e       	mov	r2, r24
    4348:	9b af       	std	Y+59, r25	; 0x3b
          mm_remaining = prep.mm_complete;
          prep.current_speed = prep.exit_speed;
    434a:	be a5       	ldd	r27, Y+46	; 0x2e
    434c:	b9 83       	std	Y+1, r27	; 0x01
    434e:	ef a5       	ldd	r30, Y+47	; 0x2f
    4350:	ed 83       	std	Y+5, r30	; 0x05
    4352:	f8 a9       	ldd	r31, Y+48	; 0x30
    4354:	f9 87       	std	Y+9, r31	; 0x09
    4356:	29 a9       	ldd	r18, Y+49	; 0x31
    4358:	29 8b       	std	Y+17, r18	; 0x11
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete;
    435a:	ea 88       	ldd	r14, Y+18	; 0x12
    435c:	db 88       	ldd	r13, Y+19	; 0x13
    435e:	cc 88       	ldd	r12, Y+20	; 0x14
    4360:	fd 88       	ldd	r15, Y+21	; 0x15
    4362:	04 c0       	rjmp	.+8      	; 0x436c <st_prep_buffer+0xc04>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
          } else { // Cruising only.
            mm_remaining = mm_var;
    4364:	ed 84       	ldd	r14, Y+13	; 0x0d
    4366:	dc 8c       	ldd	r13, Y+28	; 0x1c
    4368:	cd 8c       	ldd	r12, Y+29	; 0x1d
    436a:	f6 2c       	mov	r15, r6
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete;
          prep.current_speed = prep.exit_speed;
      }
      dt += time_var; // Add computed ramp time to total segment time.
    436c:	24 2d       	mov	r18, r4
    436e:	33 2d       	mov	r19, r3
    4370:	42 2d       	mov	r20, r2
    4372:	5b ad       	ldd	r21, Y+59	; 0x3b
    4374:	c5 01       	movw	r24, r10
    4376:	b4 01       	movw	r22, r8
    4378:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    437c:	4b 01       	movw	r8, r22
    437e:	5c 01       	movw	r10, r24
      if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
    4380:	9b 01       	movw	r18, r22
    4382:	ac 01       	movw	r20, r24
    4384:	67 2d       	mov	r22, r7
    4386:	75 2d       	mov	r23, r5
    4388:	81 2f       	mov	r24, r17
    438a:	90 2f       	mov	r25, r16
    438c:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    4390:	18 16       	cp	r1, r24
    4392:	6c f4       	brge	.+26     	; 0x43ae <st_prep_buffer+0xc46>
    4394:	a5 01       	movw	r20, r10
    4396:	94 01       	movw	r18, r8
    4398:	67 2d       	mov	r22, r7
    439a:	75 2d       	mov	r23, r5
    439c:	81 2f       	mov	r24, r17
    439e:	90 2f       	mov	r25, r16
    43a0:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    43a4:	46 2e       	mov	r4, r22
    43a6:	37 2e       	mov	r3, r23
    43a8:	28 2e       	mov	r2, r24
    43aa:	9b af       	std	Y+59, r25	; 0x3b
    43ac:	36 c0       	rjmp	.+108    	; 0x441a <st_prep_buffer+0xcb2>
      else {
        if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
    43ae:	2a a1       	ldd	r18, Y+34	; 0x22
    43b0:	3b a1       	ldd	r19, Y+35	; 0x23
    43b2:	4c a1       	ldd	r20, Y+36	; 0x24
    43b4:	5d a1       	ldd	r21, Y+37	; 0x25
    43b6:	6e 2d       	mov	r22, r14
    43b8:	7d 2d       	mov	r23, r13
    43ba:	8c 2d       	mov	r24, r12
    43bc:	9f 2d       	mov	r25, r15
    43be:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    43c2:	18 16       	cp	r1, r24
    43c4:	a4 f0       	brlt	.+40     	; 0x43ee <st_prep_buffer+0xc86>
    43c6:	3c ad       	ldd	r19, Y+60	; 0x3c
    43c8:	6e a8       	ldd	r6, Y+54	; 0x36
    43ca:	7f a8       	ldd	r7, Y+55	; 0x37
    43cc:	5e 2c       	mov	r5, r14
    43ce:	1d 2d       	mov	r17, r13
    43d0:	0c 2d       	mov	r16, r12
    43d2:	fc 8e       	std	Y+28, r15	; 0x1c
    43d4:	d3 01       	movw	r26, r6
    43d6:	52 96       	adiw	r26, 0x12	; 18
    43d8:	3c 93       	st	X, r19
    43da:	89 81       	ldd	r24, Y+1	; 0x01
    43dc:	9d 81       	ldd	r25, Y+5	; 0x05
    43de:	a9 85       	ldd	r26, Y+9	; 0x09
    43e0:	b9 89       	ldd	r27, Y+17	; 0x11
    43e2:	f3 01       	movw	r30, r6
    43e4:	87 8b       	std	Z+23, r24	; 0x17
    43e6:	90 8f       	std	Z+24, r25	; 0x18
    43e8:	a1 8f       	std	Z+25, r26	; 0x19
    43ea:	b2 8f       	std	Z+26, r27	; 0x1a
    43ec:	37 c0       	rjmp	.+110    	; 0x445c <st_prep_buffer+0xcf4>
          // Increase segment time to ensure at least one step in segment. Override and loop
          // through distance calculations until minimum_mm or mm_complete.
          dt_max += DT_SEGMENT;
    43ee:	2e e3       	ldi	r18, 0x3E	; 62
    43f0:	33 ec       	ldi	r19, 0xC3	; 195
    43f2:	4e e2       	ldi	r20, 0x2E	; 46
    43f4:	59 e3       	ldi	r21, 0x39	; 57
    43f6:	67 2d       	mov	r22, r7
    43f8:	75 2d       	mov	r23, r5
    43fa:	81 2f       	mov	r24, r17
    43fc:	90 2f       	mov	r25, r16
    43fe:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    4402:	76 2e       	mov	r7, r22
    4404:	57 2e       	mov	r5, r23
    4406:	18 2f       	mov	r17, r24
    4408:	09 2f       	mov	r16, r25
          time_var = dt_max - dt;
    440a:	a5 01       	movw	r20, r10
    440c:	94 01       	movw	r18, r8
    440e:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    4412:	46 2e       	mov	r4, r22
    4414:	37 2e       	mov	r3, r23
    4416:	28 2e       	mov	r2, r24
    4418:	9b af       	std	Y+59, r25	; 0x3b
        } else {
          break; // **Complete** Exit loop. Segment execution time maxed.
        }
      }
    } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
    441a:	2a 89       	ldd	r18, Y+18	; 0x12
    441c:	3b 89       	ldd	r19, Y+19	; 0x13
    441e:	4c 89       	ldd	r20, Y+20	; 0x14
    4420:	5d 89       	ldd	r21, Y+21	; 0x15
    4422:	6e 2d       	mov	r22, r14
    4424:	7d 2d       	mov	r23, r13
    4426:	8c 2d       	mov	r24, r12
    4428:	9f 2d       	mov	r25, r15
    442a:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    442e:	18 16       	cp	r1, r24
    4430:	0c f4       	brge	.+2      	; 0x4434 <st_prep_buffer+0xccc>
    4432:	ba cd       	rjmp	.-1164   	; 0x3fa8 <st_prep_buffer+0x840>
    4434:	fc ad       	ldd	r31, Y+60	; 0x3c
    4436:	fd 8f       	std	Y+29, r31	; 0x1d
    4438:	6e a8       	ldd	r6, Y+54	; 0x36
    443a:	7f a8       	ldd	r7, Y+55	; 0x37
    443c:	5e 2c       	mov	r5, r14
    443e:	1d 2d       	mov	r17, r13
    4440:	0c 2d       	mov	r16, r12
    4442:	fc 8e       	std	Y+28, r15	; 0x1c
    4444:	d3 01       	movw	r26, r6
    4446:	52 96       	adiw	r26, 0x12	; 18
    4448:	fc 93       	st	X, r31
    444a:	89 81       	ldd	r24, Y+1	; 0x01
    444c:	9d 81       	ldd	r25, Y+5	; 0x05
    444e:	a9 85       	ldd	r26, Y+9	; 0x09
    4450:	b9 89       	ldd	r27, Y+17	; 0x11
    4452:	f3 01       	movw	r30, r6
    4454:	87 8b       	std	Z+23, r24	; 0x17
    4456:	90 8f       	std	Z+24, r25	; 0x18
    4458:	a1 8f       	std	Z+25, r26	; 0x19
    445a:	b2 8f       	std	Z+26, r27	; 0x1a

    /* -----------------------------------------------------------------------------------
      Compute spindle speed PWM output for step segment
    */
    
    if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
    445c:	e0 91 39 03 	lds	r30, 0x0339	; 0x800339 <st_prep_block>
    4460:	f0 91 3a 03 	lds	r31, 0x033A	; 0x80033a <st_prep_block+0x1>
    4464:	81 89       	ldd	r24, Z+17	; 0x11
    4466:	81 11       	cpse	r24, r1
    4468:	99 c1       	rjmp	.+818    	; 0x479c <st_prep_buffer+0x1034>
    446a:	80 91 1a 0c 	lds	r24, 0x0C1A	; 0x800c1a <sys+0x4>
    446e:	83 fd       	sbrc	r24, 3
    4470:	a5 c1       	rjmp	.+842    	; 0x47bc <st_prep_buffer+0x1054>
    4472:	18 c0       	rjmp	.+48     	; 0x44a4 <st_prep_buffer+0xd3c>
        float rpm = pl_block->spindle_speed;
        // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.        
        if (st_prep_block->is_pwm_rate_adjusted) { rpm *= (prep.current_speed * prep.inv_rate); }
        // If current_speed is zero, then may need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE)
        // but this would be instantaneous only and during a motion. May not matter at all.
        prep.current_spindle_pwm = spindle_compute_pwm_value(rpm);
    4474:	0e 94 78 12 	call	0x24f0	; 0x24f0 <spindle_compute_pwm_value>
    4478:	d3 01       	movw	r26, r6
    447a:	d0 96       	adiw	r26, 0x30	; 48
    447c:	9c 93       	st	X, r25
    447e:	8e 93       	st	-X, r24
    4480:	9f 97       	sbiw	r26, 0x2f	; 47
    4482:	0b c0       	rjmp	.+22     	; 0x449a <st_prep_buffer+0xd32>
      } else { 
        sys.spindle_speed = 0.0;
    4484:	10 92 24 0c 	sts	0x0C24, r1	; 0x800c24 <sys+0xe>
    4488:	10 92 25 0c 	sts	0x0C25, r1	; 0x800c25 <sys+0xf>
    448c:	10 92 26 0c 	sts	0x0C26, r1	; 0x800c26 <sys+0x10>
    4490:	10 92 27 0c 	sts	0x0C27, r1	; 0x800c27 <sys+0x11>
        prep.current_spindle_pwm = SPINDLE_PWM_OFF_VALUE;
    4494:	f3 01       	movw	r30, r6
    4496:	10 aa       	std	Z+48, r1	; 0x30
    4498:	17 a6       	std	Z+47, r1	; 0x2f
      }
      bit_false(sys.step_control,STEP_CONTROL_UPDATE_SPINDLE_PWM);
    449a:	80 91 1a 0c 	lds	r24, 0x0C1A	; 0x800c1a <sys+0x4>
    449e:	87 7f       	andi	r24, 0xF7	; 247
    44a0:	80 93 1a 0c 	sts	0x0C1A, r24	; 0x800c1a <sys+0x4>
    }
    prep_segment->spindle_pwm = prep.current_spindle_pwm; // Reload segment PWM value
    44a4:	8a a9       	ldd	r24, Y+50	; 0x32
    44a6:	9b a9       	ldd	r25, Y+51	; 0x33
    44a8:	88 0f       	add	r24, r24
    44aa:	99 1f       	adc	r25, r25
    44ac:	88 0f       	add	r24, r24
    44ae:	99 1f       	adc	r25, r25
    44b0:	88 0f       	add	r24, r24
    44b2:	99 1f       	adc	r25, r25
    44b4:	9c 01       	movw	r18, r24
    44b6:	2a 59       	subi	r18, 0x9A	; 154
    44b8:	3c 4f       	sbci	r19, 0xFC	; 252
    44ba:	19 01       	movw	r2, r18
    44bc:	d3 01       	movw	r26, r6
    44be:	9f 96       	adiw	r26, 0x2f	; 47
    44c0:	8d 91       	ld	r24, X+
    44c2:	9c 91       	ld	r25, X
    44c4:	d0 97       	sbiw	r26, 0x30	; 48
    44c6:	f9 01       	movw	r30, r18
    44c8:	97 83       	std	Z+7, r25	; 0x07
    44ca:	86 83       	std	Z+6, r24	; 0x06
       However, since floats have only 7.2 significant digits, long moves with extremely
       high step counts can exceed the precision of floats, which can lead to lost steps.
       Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
       supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    */
    float step_dist_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
    44cc:	1a 96       	adiw	r26, 0x0a	; 10
    44ce:	2d 91       	ld	r18, X+
    44d0:	3d 91       	ld	r19, X+
    44d2:	4d 91       	ld	r20, X+
    44d4:	5c 91       	ld	r21, X
    44d6:	1d 97       	sbiw	r26, 0x0d	; 13
    44d8:	65 2d       	mov	r22, r5
    44da:	71 2f       	mov	r23, r17
    44dc:	80 2f       	mov	r24, r16
    44de:	9c 8d       	ldd	r25, Y+28	; 0x1c
    44e0:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    44e4:	69 83       	std	Y+1, r22	; 0x01
    44e6:	7a 83       	std	Y+2, r23	; 0x02
    44e8:	8b 83       	std	Y+3, r24	; 0x03
    44ea:	9c 83       	std	Y+4, r25	; 0x04
    float n_steps_remaining = ceil(step_dist_remaining); // Round-up current steps remaining
    44ec:	0e 94 b2 3e 	call	0x7d64	; 0x7d64 <ceil>
    44f0:	6d 83       	std	Y+5, r22	; 0x05
    44f2:	7e 83       	std	Y+6, r23	; 0x06
    44f4:	8f 83       	std	Y+7, r24	; 0x07
    44f6:	98 87       	std	Y+8, r25	; 0x08
    float last_n_steps_remaining = ceil(prep.steps_remaining); // Round-up last steps remaining
    44f8:	d3 01       	movw	r26, r6
    44fa:	16 96       	adiw	r26, 0x06	; 6
    44fc:	6d 91       	ld	r22, X+
    44fe:	7d 91       	ld	r23, X+
    4500:	8d 91       	ld	r24, X+
    4502:	9c 91       	ld	r25, X
    4504:	19 97       	sbiw	r26, 0x09	; 9
    4506:	0e 94 b2 3e 	call	0x7d64	; 0x7d64 <ceil>
    450a:	69 87       	std	Y+9, r22	; 0x09
    450c:	7a 87       	std	Y+10, r23	; 0x0a
    450e:	8b 87       	std	Y+11, r24	; 0x0b
    4510:	9c 87       	std	Y+12, r25	; 0x0c
    prep_segment->n_step = last_n_steps_remaining-n_steps_remaining; // Compute number of steps to execute.
    4512:	2d 81       	ldd	r18, Y+5	; 0x05
    4514:	3e 81       	ldd	r19, Y+6	; 0x06
    4516:	4f 81       	ldd	r20, Y+7	; 0x07
    4518:	58 85       	ldd	r21, Y+8	; 0x08
    451a:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    451e:	0e 94 39 3f 	call	0x7e72	; 0x7e72 <__fixunssfsi>
    4522:	6b 01       	movw	r12, r22
    4524:	7c 01       	movw	r14, r24
    4526:	f1 01       	movw	r30, r2
    4528:	71 83       	std	Z+1, r23	; 0x01
    452a:	60 83       	st	Z, r22

    // Bail if we are at the end of a feed hold and don't have a step to execute.
    if (prep_segment->n_step == 0) {
    452c:	67 2b       	or	r22, r23
    452e:	41 f4       	brne	.+16     	; 0x4540 <st_prep_buffer+0xdd8>
      if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) {
    4530:	80 91 1a 0c 	lds	r24, 0x0C1A	; 0x800c1a <sys+0x4>
    4534:	81 ff       	sbrs	r24, 1
    4536:	04 c0       	rjmp	.+8      	; 0x4540 <st_prep_buffer+0xdd8>
        // Less than one step to decelerate to zero speed, but already very close. AMASS
        // requires full steps to execute. So, just bail.
        bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    4538:	81 60       	ori	r24, 0x01	; 1
    453a:	80 93 1a 0c 	sts	0x0C1A, r24	; 0x800c1a <sys+0x4>
        #ifdef PARKING_ENABLE
          if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
        #endif
        return; // Segment not generated, but current step data still retained.
    453e:	44 c1       	rjmp	.+648    	; 0x47c8 <st_prep_buffer+0x1060>
    // apply it with the partial step distance to the current segment, so that it minutely
    // adjusts the whole segment rate to keep step output exact. These rate adjustments are
    // typically very small and do not adversely effect performance, but ensures that Grbl
    // outputs the exact acceleration and velocity profiles as computed by the planner.
    dt += prep.dt_remainder; // Apply previous segment partial step execute time
    float inv_rate = dt/(last_n_steps_remaining - step_dist_remaining); // Compute adjusted step rate inverse
    4540:	d3 01       	movw	r26, r6
    4542:	12 96       	adiw	r26, 0x02	; 2
    4544:	2d 91       	ld	r18, X+
    4546:	3d 91       	ld	r19, X+
    4548:	4d 91       	ld	r20, X+
    454a:	5c 91       	ld	r21, X
    454c:	15 97       	sbiw	r26, 0x05	; 5
    454e:	c5 01       	movw	r24, r10
    4550:	b4 01       	movw	r22, r8
    4552:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    4556:	4b 01       	movw	r8, r22
    4558:	5c 01       	movw	r10, r24
    455a:	29 81       	ldd	r18, Y+1	; 0x01
    455c:	3a 81       	ldd	r19, Y+2	; 0x02
    455e:	4b 81       	ldd	r20, Y+3	; 0x03
    4560:	5c 81       	ldd	r21, Y+4	; 0x04
    4562:	69 85       	ldd	r22, Y+9	; 0x09
    4564:	7a 85       	ldd	r23, Y+10	; 0x0a
    4566:	8b 85       	ldd	r24, Y+11	; 0x0b
    4568:	9c 85       	ldd	r25, Y+12	; 0x0c
    456a:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    456e:	9b 01       	movw	r18, r22
    4570:	ac 01       	movw	r20, r24
    4572:	c5 01       	movw	r24, r10
    4574:	b4 01       	movw	r22, r8
    4576:	0e 94 cc 3e 	call	0x7d98	; 0x7d98 <__divsf3>
    457a:	4b 01       	movw	r8, r22
    457c:	5c 01       	movw	r10, r24

    // Compute CPU cycles per step for the prepped segment.
    uint32_t cycles = ceil( (TICKS_PER_MICROSECOND*1000000*60)*inv_rate ); // (cycles/step)
    457e:	20 ec       	ldi	r18, 0xC0	; 192
    4580:	31 ee       	ldi	r19, 0xE1	; 225
    4582:	44 e6       	ldi	r20, 0x64	; 100
    4584:	5e e4       	ldi	r21, 0x4E	; 78
    4586:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    458a:	0e 94 b2 3e 	call	0x7d64	; 0x7d64 <ceil>
    458e:	0e 94 39 3f 	call	0x7e72	; 0x7e72 <__fixunssfsi>

    #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
      // Compute step timing and multi-axis smoothing level.
      // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
      if (cycles < AMASS_LEVEL1) { prep_segment->amass_level = 0; }
    4592:	60 3d       	cpi	r22, 0xD0	; 208
    4594:	b7 e0       	ldi	r27, 0x07	; 7
    4596:	7b 07       	cpc	r23, r27
    4598:	81 05       	cpc	r24, r1
    459a:	91 05       	cpc	r25, r1
    459c:	60 f4       	brcc	.+24     	; 0x45b6 <st_prep_buffer+0xe4e>
    459e:	ea a9       	ldd	r30, Y+50	; 0x32
    45a0:	fb a9       	ldd	r31, Y+51	; 0x33
    45a2:	ee 0f       	add	r30, r30
    45a4:	ff 1f       	adc	r31, r31
    45a6:	ee 0f       	add	r30, r30
    45a8:	ff 1f       	adc	r31, r31
    45aa:	ee 0f       	add	r30, r30
    45ac:	ff 1f       	adc	r31, r31
    45ae:	ea 59       	subi	r30, 0x9A	; 154
    45b0:	fc 4f       	sbci	r31, 0xFC	; 252
    45b2:	15 82       	std	Z+5, r1	; 0x05
    45b4:	4d c0       	rjmp	.+154    	; 0x4650 <st_prep_buffer+0xee8>
      else {
        if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }
    45b6:	60 3a       	cpi	r22, 0xA0	; 160
    45b8:	ef e0       	ldi	r30, 0x0F	; 15
    45ba:	7e 07       	cpc	r23, r30
    45bc:	81 05       	cpc	r24, r1
    45be:	91 05       	cpc	r25, r1
    45c0:	68 f4       	brcc	.+26     	; 0x45dc <st_prep_buffer+0xe74>
    45c2:	ea a9       	ldd	r30, Y+50	; 0x32
    45c4:	fb a9       	ldd	r31, Y+51	; 0x33
    45c6:	ee 0f       	add	r30, r30
    45c8:	ff 1f       	adc	r31, r31
    45ca:	ee 0f       	add	r30, r30
    45cc:	ff 1f       	adc	r31, r31
    45ce:	ee 0f       	add	r30, r30
    45d0:	ff 1f       	adc	r31, r31
    45d2:	ea 59       	subi	r30, 0x9A	; 154
    45d4:	fc 4f       	sbci	r31, 0xFC	; 252
    45d6:	21 e0       	ldi	r18, 0x01	; 1
    45d8:	25 83       	std	Z+5, r18	; 0x05
    45da:	1f c0       	rjmp	.+62     	; 0x461a <st_prep_buffer+0xeb2>
        else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }
    45dc:	60 34       	cpi	r22, 0x40	; 64
    45de:	3f e1       	ldi	r19, 0x1F	; 31
    45e0:	73 07       	cpc	r23, r19
    45e2:	81 05       	cpc	r24, r1
    45e4:	91 05       	cpc	r25, r1
    45e6:	68 f4       	brcc	.+26     	; 0x4602 <st_prep_buffer+0xe9a>
    45e8:	ea a9       	ldd	r30, Y+50	; 0x32
    45ea:	fb a9       	ldd	r31, Y+51	; 0x33
    45ec:	ee 0f       	add	r30, r30
    45ee:	ff 1f       	adc	r31, r31
    45f0:	ee 0f       	add	r30, r30
    45f2:	ff 1f       	adc	r31, r31
    45f4:	ee 0f       	add	r30, r30
    45f6:	ff 1f       	adc	r31, r31
    45f8:	ea 59       	subi	r30, 0x9A	; 154
    45fa:	fc 4f       	sbci	r31, 0xFC	; 252
    45fc:	42 e0       	ldi	r20, 0x02	; 2
    45fe:	45 83       	std	Z+5, r20	; 0x05
    4600:	0c c0       	rjmp	.+24     	; 0x461a <st_prep_buffer+0xeb2>
        else { prep_segment->amass_level = 3; }
    4602:	ea a9       	ldd	r30, Y+50	; 0x32
    4604:	fb a9       	ldd	r31, Y+51	; 0x33
    4606:	ee 0f       	add	r30, r30
    4608:	ff 1f       	adc	r31, r31
    460a:	ee 0f       	add	r30, r30
    460c:	ff 1f       	adc	r31, r31
    460e:	ee 0f       	add	r30, r30
    4610:	ff 1f       	adc	r31, r31
    4612:	ea 59       	subi	r30, 0x9A	; 154
    4614:	fc 4f       	sbci	r31, 0xFC	; 252
    4616:	53 e0       	ldi	r21, 0x03	; 3
    4618:	55 83       	std	Z+5, r21	; 0x05
        cycles >>= prep_segment->amass_level;
    461a:	ea a9       	ldd	r30, Y+50	; 0x32
    461c:	fb a9       	ldd	r31, Y+51	; 0x33
    461e:	ee 0f       	add	r30, r30
    4620:	ff 1f       	adc	r31, r31
    4622:	ee 0f       	add	r30, r30
    4624:	ff 1f       	adc	r31, r31
    4626:	ee 0f       	add	r30, r30
    4628:	ff 1f       	adc	r31, r31
    462a:	ea 59       	subi	r30, 0x9A	; 154
    462c:	fc 4f       	sbci	r31, 0xFC	; 252
    462e:	25 81       	ldd	r18, Z+5	; 0x05
    4630:	02 2e       	mov	r0, r18
    4632:	04 c0       	rjmp	.+8      	; 0x463c <st_prep_buffer+0xed4>
    4634:	96 95       	lsr	r25
    4636:	87 95       	ror	r24
    4638:	77 95       	ror	r23
    463a:	67 95       	ror	r22
    463c:	0a 94       	dec	r0
    463e:	d2 f7       	brpl	.-12     	; 0x4634 <st_prep_buffer+0xecc>
        prep_segment->n_step <<= prep_segment->amass_level;
    4640:	d6 01       	movw	r26, r12
    4642:	02 c0       	rjmp	.+4      	; 0x4648 <st_prep_buffer+0xee0>
    4644:	aa 0f       	add	r26, r26
    4646:	bb 1f       	adc	r27, r27
    4648:	2a 95       	dec	r18
    464a:	e2 f7       	brpl	.-8      	; 0x4644 <st_prep_buffer+0xedc>
    464c:	b1 83       	std	Z+1, r27	; 0x01
    464e:	a0 83       	st	Z, r26
      }
      if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)
    4650:	61 15       	cp	r22, r1
    4652:	71 05       	cpc	r23, r1
    4654:	b1 e0       	ldi	r27, 0x01	; 1
    4656:	8b 07       	cpc	r24, r27
    4658:	91 05       	cpc	r25, r1
    465a:	68 f4       	brcc	.+26     	; 0x4676 <st_prep_buffer+0xf0e>
    465c:	ea a9       	ldd	r30, Y+50	; 0x32
    465e:	fb a9       	ldd	r31, Y+51	; 0x33
    4660:	ee 0f       	add	r30, r30
    4662:	ff 1f       	adc	r31, r31
    4664:	ee 0f       	add	r30, r30
    4666:	ff 1f       	adc	r31, r31
    4668:	ee 0f       	add	r30, r30
    466a:	ff 1f       	adc	r31, r31
    466c:	ea 59       	subi	r30, 0x9A	; 154
    466e:	fc 4f       	sbci	r31, 0xFC	; 252
    4670:	73 83       	std	Z+3, r23	; 0x03
    4672:	62 83       	std	Z+2, r22	; 0x02
    4674:	0e c0       	rjmp	.+28     	; 0x4692 <st_prep_buffer+0xf2a>
      else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
    4676:	ea a9       	ldd	r30, Y+50	; 0x32
    4678:	fb a9       	ldd	r31, Y+51	; 0x33
    467a:	ee 0f       	add	r30, r30
    467c:	ff 1f       	adc	r31, r31
    467e:	ee 0f       	add	r30, r30
    4680:	ff 1f       	adc	r31, r31
    4682:	ee 0f       	add	r30, r30
    4684:	ff 1f       	adc	r31, r31
    4686:	ea 59       	subi	r30, 0x9A	; 154
    4688:	fc 4f       	sbci	r31, 0xFC	; 252
    468a:	2f ef       	ldi	r18, 0xFF	; 255
    468c:	3f ef       	ldi	r19, 0xFF	; 255
    468e:	33 83       	std	Z+3, r19	; 0x03
    4690:	22 83       	std	Z+2, r18	; 0x02
        }
      }
    #endif

    // Segment complete! Increment segment buffer indices, so stepper ISR can immediately execute it.
    segment_buffer_head = segment_next_head;
    4692:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <segment_next_head>
    4696:	80 93 41 03 	sts	0x0341, r24	; 0x800341 <segment_buffer_head>
    if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
    469a:	8f 5f       	subi	r24, 0xFF	; 255
    469c:	8a 30       	cpi	r24, 0x0A	; 10
    469e:	19 f0       	breq	.+6      	; 0x46a6 <st_prep_buffer+0xf3e>
    46a0:	80 93 40 03 	sts	0x0340, r24	; 0x800340 <segment_next_head>
    46a4:	02 c0       	rjmp	.+4      	; 0x46aa <st_prep_buffer+0xf42>
    46a6:	10 92 40 03 	sts	0x0340, r1	; 0x800340 <segment_next_head>

    // Update the appropriate planner and segment data.
    pl_block->millimeters = mm_remaining;
    46aa:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    46ae:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    46b2:	85 2d       	mov	r24, r5
    46b4:	91 2f       	mov	r25, r17
    46b6:	a0 2f       	mov	r26, r16
    46b8:	bc 8d       	ldd	r27, Y+28	; 0x1c
    46ba:	82 a3       	std	Z+34, r24	; 0x22
    46bc:	93 a3       	std	Z+35, r25	; 0x23
    46be:	a4 a3       	std	Z+36, r26	; 0x24
    46c0:	b5 a3       	std	Z+37, r27	; 0x25
    prep.steps_remaining = n_steps_remaining;
    46c2:	8d 81       	ldd	r24, Y+5	; 0x05
    46c4:	9e 81       	ldd	r25, Y+6	; 0x06
    46c6:	af 81       	ldd	r26, Y+7	; 0x07
    46c8:	b8 85       	ldd	r27, Y+8	; 0x08
    46ca:	f3 01       	movw	r30, r6
    46cc:	86 83       	std	Z+6, r24	; 0x06
    46ce:	97 83       	std	Z+7, r25	; 0x07
    46d0:	a0 87       	std	Z+8, r26	; 0x08
    46d2:	b1 87       	std	Z+9, r27	; 0x09
    prep.dt_remainder = (n_steps_remaining - step_dist_remaining)*inv_rate;
    46d4:	29 81       	ldd	r18, Y+1	; 0x01
    46d6:	3a 81       	ldd	r19, Y+2	; 0x02
    46d8:	4b 81       	ldd	r20, Y+3	; 0x03
    46da:	5c 81       	ldd	r21, Y+4	; 0x04
    46dc:	bc 01       	movw	r22, r24
    46de:	cd 01       	movw	r24, r26
    46e0:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    46e4:	a5 01       	movw	r20, r10
    46e6:	94 01       	movw	r18, r8
    46e8:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    46ec:	d3 01       	movw	r26, r6
    46ee:	12 96       	adiw	r26, 0x02	; 2
    46f0:	6d 93       	st	X+, r22
    46f2:	7d 93       	st	X+, r23
    46f4:	8d 93       	st	X+, r24
    46f6:	9c 93       	st	X, r25
    46f8:	15 97       	sbiw	r26, 0x05	; 5

    // Check for exit conditions and flag to load next planner block.
    if (mm_remaining == prep.mm_complete) {
    46fa:	53 96       	adiw	r26, 0x13	; 19
    46fc:	2d 91       	ld	r18, X+
    46fe:	3d 91       	ld	r19, X+
    4700:	4d 91       	ld	r20, X+
    4702:	5c 91       	ld	r21, X
    4704:	56 97       	sbiw	r26, 0x16	; 22
    4706:	65 2d       	mov	r22, r5
    4708:	71 2f       	mov	r23, r17
    470a:	80 2f       	mov	r24, r16
    470c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    470e:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    4712:	81 11       	cpse	r24, r1
    4714:	22 c0       	rjmp	.+68     	; 0x475a <st_prep_buffer+0xff2>
    4716:	45 2c       	mov	r4, r5
    4718:	2c 8c       	ldd	r2, Y+28	; 0x1c
      // End of planner block or forced-termination. No more distance to be executed.
      if (mm_remaining > 0.0) { // At end of forced-termination.
    471a:	20 e0       	ldi	r18, 0x00	; 0
    471c:	30 e0       	ldi	r19, 0x00	; 0
    471e:	a9 01       	movw	r20, r18
    4720:	64 2d       	mov	r22, r4
    4722:	71 2f       	mov	r23, r17
    4724:	80 2f       	mov	r24, r16
    4726:	92 2d       	mov	r25, r2
    4728:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    472c:	18 16       	cp	r1, r24
    472e:	34 f4       	brge	.+12     	; 0x473c <st_prep_buffer+0xfd4>
        // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
        // the segment queue, where realtime protocol will set new state upon receiving the
        // cycle stop flag from the ISR. Prep_segment is blocked until then.
        bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    4730:	e6 e1       	ldi	r30, 0x16	; 22
    4732:	fc e0       	ldi	r31, 0x0C	; 12
    4734:	84 81       	ldd	r24, Z+4	; 0x04
    4736:	81 60       	ori	r24, 0x01	; 1
    4738:	84 83       	std	Z+4, r24	; 0x04
        #ifdef PARKING_ENABLE
          if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
        #endif
        return; // Bail!
    473a:	46 c0       	rjmp	.+140    	; 0x47c8 <st_prep_buffer+0x1060>
      } else { // End of planner block
        // The planner block is complete. All steps are set to be executed in the segment buffer.
        if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
    473c:	80 91 1a 0c 	lds	r24, 0x0C1A	; 0x800c1a <sys+0x4>
    4740:	82 ff       	sbrs	r24, 2
    4742:	04 c0       	rjmp	.+8      	; 0x474c <st_prep_buffer+0xfe4>
          bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    4744:	81 60       	ori	r24, 0x01	; 1
    4746:	80 93 1a 0c 	sts	0x0C1A, r24	; 0x800c1a <sys+0x4>
          return;
    474a:	3e c0       	rjmp	.+124    	; 0x47c8 <st_prep_buffer+0x1060>
        }
        pl_block = NULL; // Set pointer to indicate check and load next planner block.
    474c:	10 92 3c 03 	sts	0x033C, r1	; 0x80033c <pl_block+0x1>
    4750:	10 92 3b 03 	sts	0x033B, r1	; 0x80033b <pl_block>
        plan_discard_current_block();
    4754:	25 d5       	rcall	.+2634   	; 0x51a0 <plan_discard_current_block>
          speed_var = pl_block->acceleration*time_var;
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            prep.ramp_type = RAMP_CRUISE;
    4756:	b1 e0       	ldi	r27, 0x01	; 1
    4758:	b8 af       	std	Y+56, r27	; 0x38
void st_prep_buffer()
{
  // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }

  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
    475a:	90 91 42 03 	lds	r25, 0x0342	; 0x800342 <segment_buffer_tail>
    475e:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <segment_next_head>
    4762:	98 13       	cpse	r25, r24
    4764:	2b c8       	rjmp	.-4010   	; 0x37bc <st_prep_buffer+0x54>
    4766:	30 c0       	rjmp	.+96     	; 0x47c8 <st_prep_buffer+0x1060>
      Compute spindle speed PWM output for step segment
    */
    
    if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
      if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
        float rpm = pl_block->spindle_speed;
    4768:	ea 8d       	ldd	r30, Y+26	; 0x1a
    476a:	fb 8d       	ldd	r31, Y+27	; 0x1b
    476c:	c2 a8       	ldd	r12, Z+50	; 0x32
    476e:	d3 a8       	ldd	r13, Z+51	; 0x33
    4770:	e4 a8       	ldd	r14, Z+52	; 0x34
    4772:	f5 a8       	ldd	r15, Z+53	; 0x35
        // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.        
        if (st_prep_block->is_pwm_rate_adjusted) { rpm *= (prep.current_speed * prep.inv_rate); }
    4774:	d3 01       	movw	r26, r6
    4776:	9b 96       	adiw	r26, 0x2b	; 43
    4778:	2d 91       	ld	r18, X+
    477a:	3d 91       	ld	r19, X+
    477c:	4d 91       	ld	r20, X+
    477e:	5c 91       	ld	r21, X
    4780:	9e 97       	sbiw	r26, 0x2e	; 46
    4782:	57 96       	adiw	r26, 0x17	; 23
    4784:	6d 91       	ld	r22, X+
    4786:	7d 91       	ld	r23, X+
    4788:	8d 91       	ld	r24, X+
    478a:	9c 91       	ld	r25, X
    478c:	5a 97       	sbiw	r26, 0x1a	; 26
    478e:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    4792:	a7 01       	movw	r20, r14
    4794:	96 01       	movw	r18, r12
    4796:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    479a:	6c ce       	rjmp	.-808    	; 0x4474 <st_prep_buffer+0xd0c>
    /* -----------------------------------------------------------------------------------
      Compute spindle speed PWM output for step segment
    */
    
    if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
      if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
    479c:	ea 8d       	ldd	r30, Y+26	; 0x1a
    479e:	fb 8d       	ldd	r31, Y+27	; 0x1b
    47a0:	81 89       	ldd	r24, Z+17	; 0x11
    47a2:	80 73       	andi	r24, 0x30	; 48
    47a4:	09 f4       	brne	.+2      	; 0x47a8 <st_prep_buffer+0x1040>
    47a6:	6e ce       	rjmp	.-804    	; 0x4484 <st_prep_buffer+0xd1c>
    47a8:	df cf       	rjmp	.-66     	; 0x4768 <st_prep_buffer+0x1000>
        float rpm = pl_block->spindle_speed;
    47aa:	aa 8d       	ldd	r26, Y+26	; 0x1a
    47ac:	bb 8d       	ldd	r27, Y+27	; 0x1b
    47ae:	d2 96       	adiw	r26, 0x32	; 50
    47b0:	6d 91       	ld	r22, X+
    47b2:	7d 91       	ld	r23, X+
    47b4:	8d 91       	ld	r24, X+
    47b6:	9c 91       	ld	r25, X
    47b8:	d5 97       	sbiw	r26, 0x35	; 53
    47ba:	5c ce       	rjmp	.-840    	; 0x4474 <st_prep_buffer+0xd0c>
    /* -----------------------------------------------------------------------------------
      Compute spindle speed PWM output for step segment
    */
    
    if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
      if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
    47bc:	ea 8d       	ldd	r30, Y+26	; 0x1a
    47be:	fb 8d       	ldd	r31, Y+27	; 0x1b
    47c0:	81 89       	ldd	r24, Z+17	; 0x11
    47c2:	80 73       	andi	r24, 0x30	; 48
    47c4:	91 f7       	brne	.-28     	; 0x47aa <st_prep_buffer+0x1042>
    47c6:	5e ce       	rjmp	.-836    	; 0x4484 <st_prep_buffer+0xd1c>
        plan_discard_current_block();
      }
    }

  }
}
    47c8:	ec 96       	adiw	r28, 0x3c	; 60
    47ca:	0f b6       	in	r0, 0x3f	; 63
    47cc:	f8 94       	cli
    47ce:	de bf       	out	0x3e, r29	; 62
    47d0:	0f be       	out	0x3f, r0	; 63
    47d2:	cd bf       	out	0x3d, r28	; 61
    47d4:	df 91       	pop	r29
    47d6:	cf 91       	pop	r28
    47d8:	1f 91       	pop	r17
    47da:	0f 91       	pop	r16
    47dc:	ff 90       	pop	r15
    47de:	ef 90       	pop	r14
    47e0:	df 90       	pop	r13
    47e2:	cf 90       	pop	r12
    47e4:	bf 90       	pop	r11
    47e6:	af 90       	pop	r10
    47e8:	9f 90       	pop	r9
    47ea:	8f 90       	pop	r8
    47ec:	7f 90       	pop	r7
    47ee:	6f 90       	pop	r6
    47f0:	5f 90       	pop	r5
    47f2:	4f 90       	pop	r4
    47f4:	3f 90       	pop	r3
    47f6:	2f 90       	pop	r2
    47f8:	08 95       	ret

000047fa <st_get_realtime_rate>:
// however is not exactly the current speed, but the speed computed in the last step segment
// in the segment buffer. It will always be behind by up to the number of segment blocks (-1)
// divided by the ACCELERATION TICKS PER SECOND in seconds.
float st_get_realtime_rate()
{
  if (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)){
    47fa:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
    47fe:	8c 77       	andi	r24, 0x7C	; 124
    4800:	49 f0       	breq	.+18     	; 0x4814 <st_get_realtime_rate+0x1a>
    return prep.current_speed;
    4802:	60 91 1f 03 	lds	r22, 0x031F	; 0x80031f <prep+0x17>
    4806:	70 91 20 03 	lds	r23, 0x0320	; 0x800320 <prep+0x18>
    480a:	80 91 21 03 	lds	r24, 0x0321	; 0x800321 <prep+0x19>
    480e:	90 91 22 03 	lds	r25, 0x0322	; 0x800322 <prep+0x1a>
    4812:	08 95       	ret
  }
  return 0.0f;
    4814:	60 e0       	ldi	r22, 0x00	; 0
    4816:	70 e0       	ldi	r23, 0x00	; 0
    4818:	cb 01       	movw	r24, r22
}
    481a:	08 95       	ret

0000481c <eeprom_get_char>:
 *  \param  addr  EEPROM address to read from.
 *  \return  The byte read from the EEPROM address.
 */
unsigned char eeprom_get_char( unsigned int addr )
{
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    481c:	f9 99       	sbic	0x1f, 1	; 31
    481e:	fe cf       	rjmp	.-4      	; 0x481c <eeprom_get_char>
	EEAR = addr; // Set EEPROM address register.
    4820:	92 bd       	out	0x22, r25	; 34
    4822:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    4824:	81 e0       	ldi	r24, 0x01	; 1
    4826:	8f bb       	out	0x1f, r24	; 31
	return EEDR; // Return the byte read from EEPROM.
    4828:	80 b5       	in	r24, 0x20	; 32
}
    482a:	08 95       	ret

0000482c <eeprom_put_char>:
void eeprom_put_char( unsigned int addr, unsigned char new_value )
{
	char old_value; // Old EEPROM value.
	char diff_mask; // Difference mask, i.e. old value XOR new value.

	cli(); // Ensure atomic operation for the write operation.
    482c:	f8 94       	cli
	
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    482e:	f9 99       	sbic	0x1f, 1	; 31
    4830:	fe cf       	rjmp	.-4      	; 0x482e <eeprom_put_char+0x2>
	#ifndef EEPROM_IGNORE_SELFPROG
	do {} while( SPMCSR & (1<<SELFPRGEN) ); // Wait for completion of SPM.
	#endif
	
	EEAR = addr; // Set EEPROM address register.
    4832:	92 bd       	out	0x22, r25	; 34
    4834:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    4836:	81 e0       	ldi	r24, 0x01	; 1
    4838:	8f bb       	out	0x1f, r24	; 31
	old_value = EEDR; // Get old EEPROM value.
    483a:	80 b5       	in	r24, 0x20	; 32
	diff_mask = old_value ^ new_value; // Get bit differences.
    483c:	86 27       	eor	r24, r22
	
	// Check if any bits are changed to '1' in the new value.
	if( diff_mask & new_value ) {
    483e:	96 2f       	mov	r25, r22
    4840:	98 23       	and	r25, r24
    4842:	59 f0       	breq	.+22     	; 0x485a <eeprom_put_char+0x2e>
		// Now we know that _some_ bits need to be erased to '1'.
		
		// Check if any bits in the new value are '0'.
		if( new_value != 0xff ) {
    4844:	6f 3f       	cpi	r22, 0xFF	; 255
    4846:	29 f0       	breq	.+10     	; 0x4852 <eeprom_put_char+0x26>
			// Now we know that some bits need to be programmed to '0' also.
			
			EEDR = new_value; // Set EEPROM data register.
    4848:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    484a:	84 e0       	ldi	r24, 0x04	; 4
    484c:	8f bb       	out	0x1f, r24	; 31
			       (0<<EEPM1) | (0<<EEPM0); // ...and Erase+Write mode.
			EECR |= (1<<EEPE);  // Start Erase+Write operation.
    484e:	f9 9a       	sbi	0x1f, 1	; 31
    4850:	0a c0       	rjmp	.+20     	; 0x4866 <eeprom_put_char+0x3a>
		} else {
			// Now we know that all bits should be erased.

			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    4852:	84 e1       	ldi	r24, 0x14	; 20
    4854:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM0);  // ...and Erase-only mode.
			EECR |= (1<<EEPE);  // Start Erase-only operation.
    4856:	f9 9a       	sbi	0x1f, 1	; 31
    4858:	06 c0       	rjmp	.+12     	; 0x4866 <eeprom_put_char+0x3a>
		}
	} else {
		// Now we know that _no_ bits need to be erased to '1'.
		
		// Check if any bits are changed from '1' in the old value.
		if( diff_mask ) {
    485a:	88 23       	and	r24, r24
    485c:	21 f0       	breq	.+8      	; 0x4866 <eeprom_put_char+0x3a>
			// Now we know that _some_ bits need to the programmed to '0'.
			
			EEDR = new_value;   // Set EEPROM data register.
    485e:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    4860:	84 e2       	ldi	r24, 0x24	; 36
    4862:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM1);  // ...and Write-only mode.
			EECR |= (1<<EEPE);  // Start Write-only operation.
    4864:	f9 9a       	sbi	0x1f, 1	; 31
		}
	}
	
	sei(); // Restore interrupt flag state.
    4866:	78 94       	sei
    4868:	08 95       	ret

0000486a <memcpy_to_eeprom_with_checksum>:
}

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
    486a:	8f 92       	push	r8
    486c:	9f 92       	push	r9
    486e:	af 92       	push	r10
    4870:	bf 92       	push	r11
    4872:	cf 92       	push	r12
    4874:	df 92       	push	r13
    4876:	ef 92       	push	r14
    4878:	ff 92       	push	r15
    487a:	0f 93       	push	r16
    487c:	1f 93       	push	r17
    487e:	cf 93       	push	r28
    4880:	df 93       	push	r29
    4882:	7c 01       	movw	r14, r24
    4884:	8b 01       	movw	r16, r22
    4886:	6a 01       	movw	r12, r20
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    4888:	41 15       	cp	r20, r1
    488a:	51 05       	cpc	r21, r1
    488c:	01 f1       	breq	.+64     	; 0x48ce <memcpy_to_eeprom_with_checksum+0x64>
    488e:	5a 01       	movw	r10, r20
    4890:	c0 e0       	ldi	r28, 0x00	; 0
    checksum = (checksum << 1) || (checksum >> 7);
    4892:	d1 e0       	ldi	r29, 0x01	; 1
    4894:	01 c0       	rjmp	.+2      	; 0x4898 <memcpy_to_eeprom_with_checksum+0x2e>
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
    4896:	c4 01       	movw	r24, r8


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    4898:	c1 11       	cpse	r28, r1
    489a:	08 c0       	rjmp	.+16     	; 0x48ac <memcpy_to_eeprom_with_checksum+0x42>
    489c:	6c 2f       	mov	r22, r28
    489e:	cc 0f       	add	r28, r28
    48a0:	77 0b       	sbc	r23, r23
    48a2:	c7 2f       	mov	r28, r23
    48a4:	cc 1f       	adc	r28, r28
    48a6:	cc 27       	eor	r28, r28
    48a8:	cc 1f       	adc	r28, r28
    48aa:	01 c0       	rjmp	.+2      	; 0x48ae <memcpy_to_eeprom_with_checksum+0x44>
    48ac:	cd 2f       	mov	r28, r29
    checksum += *source;
    48ae:	f8 01       	movw	r30, r16
    48b0:	61 91       	ld	r22, Z+
    48b2:	8f 01       	movw	r16, r30
    48b4:	c6 0f       	add	r28, r22
    eeprom_put_char(destination++, *(source++)); 
    48b6:	4c 01       	movw	r8, r24
    48b8:	ff ef       	ldi	r31, 0xFF	; 255
    48ba:	8f 1a       	sub	r8, r31
    48bc:	9f 0a       	sbc	r9, r31
    48be:	b6 df       	rcall	.-148    	; 0x482c <eeprom_put_char>
// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    48c0:	21 e0       	ldi	r18, 0x01	; 1
    48c2:	a2 1a       	sub	r10, r18
    48c4:	b1 08       	sbc	r11, r1
    48c6:	39 f7       	brne	.-50     	; 0x4896 <memcpy_to_eeprom_with_checksum+0x2c>
    48c8:	ec 0c       	add	r14, r12
    48ca:	fd 1c       	adc	r15, r13
    48cc:	01 c0       	rjmp	.+2      	; 0x48d0 <memcpy_to_eeprom_with_checksum+0x66>

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
    48ce:	c0 e0       	ldi	r28, 0x00	; 0
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
  }
  eeprom_put_char(destination, checksum);
    48d0:	6c 2f       	mov	r22, r28
    48d2:	c7 01       	movw	r24, r14
    48d4:	ab df       	rcall	.-170    	; 0x482c <eeprom_put_char>
}
    48d6:	df 91       	pop	r29
    48d8:	cf 91       	pop	r28
    48da:	1f 91       	pop	r17
    48dc:	0f 91       	pop	r16
    48de:	ff 90       	pop	r15
    48e0:	ef 90       	pop	r14
    48e2:	df 90       	pop	r13
    48e4:	cf 90       	pop	r12
    48e6:	bf 90       	pop	r11
    48e8:	af 90       	pop	r10
    48ea:	9f 90       	pop	r9
    48ec:	8f 90       	pop	r8
    48ee:	08 95       	ret

000048f0 <memcpy_from_eeprom_with_checksum>:

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
    48f0:	8f 92       	push	r8
    48f2:	9f 92       	push	r9
    48f4:	af 92       	push	r10
    48f6:	bf 92       	push	r11
    48f8:	cf 92       	push	r12
    48fa:	df 92       	push	r13
    48fc:	ef 92       	push	r14
    48fe:	ff 92       	push	r15
    4900:	0f 93       	push	r16
    4902:	1f 93       	push	r17
    4904:	cf 93       	push	r28
    4906:	df 93       	push	r29
    4908:	7b 01       	movw	r14, r22
    490a:	6a 01       	movw	r12, r20
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    490c:	41 15       	cp	r20, r1
    490e:	51 05       	cpc	r21, r1
    4910:	09 f1       	breq	.+66     	; 0x4954 <memcpy_from_eeprom_with_checksum+0x64>
    4912:	c8 2f       	mov	r28, r24
    4914:	d9 2f       	mov	r29, r25
    4916:	5a 01       	movw	r10, r20
    4918:	cb 01       	movw	r24, r22
    491a:	91 2c       	mov	r9, r1
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    491c:	88 24       	eor	r8, r8
    491e:	83 94       	inc	r8
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    data = eeprom_get_char(source++);
    4920:	8c 01       	movw	r16, r24
    4922:	0f 5f       	subi	r16, 0xFF	; 255
    4924:	1f 4f       	sbci	r17, 0xFF	; 255
    4926:	7a df       	rcall	.-268    	; 0x481c <eeprom_get_char>
    checksum = (checksum << 1) || (checksum >> 7);
    4928:	91 10       	cpse	r9, r1
    492a:	08 c0       	rjmp	.+16     	; 0x493c <memcpy_from_eeprom_with_checksum+0x4c>
    492c:	29 2d       	mov	r18, r9
    492e:	99 0c       	add	r9, r9
    4930:	33 0b       	sbc	r19, r19
    4932:	23 2f       	mov	r18, r19
    4934:	22 1f       	adc	r18, r18
    4936:	22 27       	eor	r18, r18
    4938:	22 1f       	adc	r18, r18
    493a:	01 c0       	rjmp	.+2      	; 0x493e <memcpy_from_eeprom_with_checksum+0x4e>
    493c:	28 2d       	mov	r18, r8
    checksum += data;    
    493e:	98 2e       	mov	r9, r24
    4940:	92 0e       	add	r9, r18
    *(destination++) = data; 
    4942:	89 93       	st	Y+, r24
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    4944:	81 e0       	ldi	r24, 0x01	; 1
    4946:	a8 1a       	sub	r10, r24
    4948:	b1 08       	sbc	r11, r1
    data = eeprom_get_char(source++);
    494a:	c8 01       	movw	r24, r16
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    494c:	49 f7       	brne	.-46     	; 0x4920 <memcpy_from_eeprom_with_checksum+0x30>
    494e:	ec 0c       	add	r14, r12
    4950:	fd 1c       	adc	r15, r13
    4952:	01 c0       	rjmp	.+2      	; 0x4956 <memcpy_from_eeprom_with_checksum+0x66>
  }
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
    4954:	91 2c       	mov	r9, r1
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += data;    
    *(destination++) = data; 
  }
  return(checksum == eeprom_get_char(source));
    4956:	c7 01       	movw	r24, r14
    4958:	61 df       	rcall	.-318    	; 0x481c <eeprom_get_char>
    495a:	21 e0       	ldi	r18, 0x01	; 1
    495c:	30 e0       	ldi	r19, 0x00	; 0
    495e:	89 15       	cp	r24, r9
    4960:	11 f0       	breq	.+4      	; 0x4966 <memcpy_from_eeprom_with_checksum+0x76>
    4962:	20 e0       	ldi	r18, 0x00	; 0
    4964:	30 e0       	ldi	r19, 0x00	; 0
}
    4966:	c9 01       	movw	r24, r18
    4968:	df 91       	pop	r29
    496a:	cf 91       	pop	r28
    496c:	1f 91       	pop	r17
    496e:	0f 91       	pop	r16
    4970:	ff 90       	pop	r15
    4972:	ef 90       	pop	r14
    4974:	df 90       	pop	r13
    4976:	cf 90       	pop	r12
    4978:	bf 90       	pop	r11
    497a:	af 90       	pop	r10
    497c:	9f 90       	pop	r9
    497e:	8f 90       	pop	r8
    4980:	08 95       	ret

00004982 <settings_store_startup_line>:
    .max_travel[Z_AXIS] = (-DEFAULT_Z_MAX_TRAVEL)};


// Method to store startup lines into EEPROM
void settings_store_startup_line(uint8_t n, char *line)
{
    4982:	1f 93       	push	r17
    4984:	cf 93       	push	r28
    4986:	df 93       	push	r29
    4988:	18 2f       	mov	r17, r24
    498a:	eb 01       	movw	r28, r22
  #ifdef FORCE_BUFFER_SYNC_DURING_EEPROM_WRITE
    protocol_buffer_synchronize(); // A startup line may contain a motion and be executing. 
    498c:	0e 94 94 18 	call	0x3128	; 0x3128 <protocol_buffer_synchronize>
  #endif
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
  memcpy_to_eeprom_with_checksum(addr,(char*)line, LINE_BUFFER_SIZE);
    4990:	21 e0       	ldi	r18, 0x01	; 1
    4992:	31 e0       	ldi	r19, 0x01	; 1
    4994:	12 9f       	mul	r17, r18
    4996:	c0 01       	movw	r24, r0
    4998:	13 9f       	mul	r17, r19
    499a:	90 0d       	add	r25, r0
    499c:	11 24       	eor	r1, r1
    499e:	40 e0       	ldi	r20, 0x00	; 0
    49a0:	51 e0       	ldi	r21, 0x01	; 1
    49a2:	be 01       	movw	r22, r28
    49a4:	9d 5f       	subi	r25, 0xFD	; 253
    49a6:	61 df       	rcall	.-318    	; 0x486a <memcpy_to_eeprom_with_checksum>
}
    49a8:	df 91       	pop	r29
    49aa:	cf 91       	pop	r28
    49ac:	1f 91       	pop	r17
    49ae:	08 95       	ret

000049b0 <settings_store_build_info>:
// Method to store build info into EEPROM
// NOTE: This function can only be called in IDLE state.
void settings_store_build_info(char *line)
{
  // Build info can only be stored when state is IDLE.
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_BUILD_INFO,(char*)line, LINE_BUFFER_SIZE);
    49b0:	40 e0       	ldi	r20, 0x00	; 0
    49b2:	51 e0       	ldi	r21, 0x01	; 1
    49b4:	bc 01       	movw	r22, r24
    49b6:	8e ea       	ldi	r24, 0xAE	; 174
    49b8:	93 e0       	ldi	r25, 0x03	; 3
    49ba:	57 cf       	rjmp	.-338    	; 0x486a <memcpy_to_eeprom_with_checksum>
    49bc:	08 95       	ret

000049be <settings_write_coord_data>:
}


// Method to store coord data parameters into EEPROM
void settings_write_coord_data(uint8_t coord_select, float *coord_data)
{
    49be:	0f 93       	push	r16
    49c0:	1f 93       	push	r17
    49c2:	cf 93       	push	r28
    49c4:	c8 2f       	mov	r28, r24
    49c6:	8b 01       	movw	r16, r22
  #ifdef FORCE_BUFFER_SYNC_DURING_EEPROM_WRITE
    protocol_buffer_synchronize();
    49c8:	0e 94 94 18 	call	0x3128	; 0x3128 <protocol_buffer_synchronize>
  #endif
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
  memcpy_to_eeprom_with_checksum(addr,(char*)coord_data, sizeof(float)*N_AXIS);
    49cc:	2d e0       	ldi	r18, 0x0D	; 13
    49ce:	c2 9f       	mul	r28, r18
    49d0:	c0 01       	movw	r24, r0
    49d2:	11 24       	eor	r1, r1
    49d4:	4c e0       	ldi	r20, 0x0C	; 12
    49d6:	50 e0       	ldi	r21, 0x00	; 0
    49d8:	b8 01       	movw	r22, r16
    49da:	9e 5f       	subi	r25, 0xFE	; 254
    49dc:	46 df       	rcall	.-372    	; 0x486a <memcpy_to_eeprom_with_checksum>
}
    49de:	cf 91       	pop	r28
    49e0:	1f 91       	pop	r17
    49e2:	0f 91       	pop	r16
    49e4:	08 95       	ret

000049e6 <write_global_settings>:

// Method to store Grbl global settings struct and version number into EEPROM
// NOTE: This function can only be called in IDLE state.
void write_global_settings()
{
  eeprom_put_char(0, SETTINGS_VERSION);
    49e6:	6a e0       	ldi	r22, 0x0A	; 10
    49e8:	80 e0       	ldi	r24, 0x00	; 0
    49ea:	90 e0       	ldi	r25, 0x00	; 0
    49ec:	1f df       	rcall	.-450    	; 0x482c <eeprom_put_char>
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_GLOBAL, (char*)&settings, sizeof(settings_t));
    49ee:	45 e5       	ldi	r20, 0x55	; 85
    49f0:	50 e0       	ldi	r21, 0x00	; 0
    49f2:	60 ec       	ldi	r22, 0xC0	; 192
    49f4:	7e e0       	ldi	r23, 0x0E	; 14
    49f6:	81 e0       	ldi	r24, 0x01	; 1
    49f8:	90 e0       	ldi	r25, 0x00	; 0
    49fa:	37 cf       	rjmp	.-402    	; 0x486a <memcpy_to_eeprom_with_checksum>
    49fc:	08 95       	ret

000049fe <settings_restore>:
}


// Method to restore EEPROM-saved Grbl global settings back to defaults.
void settings_restore(uint8_t restore_flag) {
    49fe:	0f 93       	push	r16
    4a00:	1f 93       	push	r17
    4a02:	cf 93       	push	r28
    4a04:	df 93       	push	r29
    4a06:	cd b7       	in	r28, 0x3d	; 61
    4a08:	de b7       	in	r29, 0x3e	; 62
    4a0a:	2c 97       	sbiw	r28, 0x0c	; 12
    4a0c:	0f b6       	in	r0, 0x3f	; 63
    4a0e:	f8 94       	cli
    4a10:	de bf       	out	0x3e, r29	; 62
    4a12:	0f be       	out	0x3f, r0	; 63
    4a14:	cd bf       	out	0x3d, r28	; 61
    4a16:	08 2f       	mov	r16, r24
  if (restore_flag & SETTINGS_RESTORE_DEFAULTS) {
    4a18:	80 ff       	sbrs	r24, 0
    4a1a:	0a c0       	rjmp	.+20     	; 0x4a30 <settings_restore+0x32>
    settings = defaults;
    4a1c:	85 e5       	ldi	r24, 0x55	; 85
    4a1e:	ea ee       	ldi	r30, 0xEA	; 234
    4a20:	f2 e0       	ldi	r31, 0x02	; 2
    4a22:	a0 ec       	ldi	r26, 0xC0	; 192
    4a24:	be e0       	ldi	r27, 0x0E	; 14
    4a26:	05 90       	lpm	r0, Z+
    4a28:	0d 92       	st	X+, r0
    4a2a:	8a 95       	dec	r24
    4a2c:	e1 f7       	brne	.-8      	; 0x4a26 <settings_restore+0x28>
    write_global_settings();
    4a2e:	db df       	rcall	.-74     	; 0x49e6 <write_global_settings>
  }

  if (restore_flag & SETTINGS_RESTORE_PARAMETERS) {
    4a30:	01 ff       	sbrs	r16, 1
    4a32:	10 c0       	rjmp	.+32     	; 0x4a54 <settings_restore+0x56>
    uint8_t idx;
    float coord_data[N_AXIS];
    memset(&coord_data, 0, sizeof(coord_data));
    4a34:	fe 01       	movw	r30, r28
    4a36:	31 96       	adiw	r30, 0x01	; 1
    4a38:	8c e0       	ldi	r24, 0x0C	; 12
    4a3a:	df 01       	movw	r26, r30
    4a3c:	1d 92       	st	X+, r1
    4a3e:	8a 95       	dec	r24
    4a40:	e9 f7       	brne	.-6      	; 0x4a3c <settings_restore+0x3e>
    for (idx=0; idx <= SETTING_INDEX_NCOORD; idx++) { settings_write_coord_data(idx, coord_data); }
    4a42:	10 e0       	ldi	r17, 0x00	; 0
    4a44:	be 01       	movw	r22, r28
    4a46:	6f 5f       	subi	r22, 0xFF	; 255
    4a48:	7f 4f       	sbci	r23, 0xFF	; 255
    4a4a:	81 2f       	mov	r24, r17
    4a4c:	b8 df       	rcall	.-144    	; 0x49be <settings_write_coord_data>
    4a4e:	1f 5f       	subi	r17, 0xFF	; 255
    4a50:	18 30       	cpi	r17, 0x08	; 8
    4a52:	c1 f7       	brne	.-16     	; 0x4a44 <settings_restore+0x46>
  }

  if (restore_flag & SETTINGS_RESTORE_STARTUP_LINES) {
    4a54:	02 ff       	sbrs	r16, 2
    4a56:	10 c0       	rjmp	.+32     	; 0x4a78 <settings_restore+0x7a>
    #if N_STARTUP_LINE > 0
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK, 0);
    4a58:	60 e0       	ldi	r22, 0x00	; 0
    4a5a:	80 e0       	ldi	r24, 0x00	; 0
    4a5c:	93 e0       	ldi	r25, 0x03	; 3
    4a5e:	e6 de       	rcall	.-564    	; 0x482c <eeprom_put_char>
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+1, 0); // Checksum
    4a60:	60 e0       	ldi	r22, 0x00	; 0
    4a62:	81 e0       	ldi	r24, 0x01	; 1
    4a64:	93 e0       	ldi	r25, 0x03	; 3
    4a66:	e2 de       	rcall	.-572    	; 0x482c <eeprom_put_char>
    #endif
    #if N_STARTUP_LINE > 1
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+1), 0);
    4a68:	60 e0       	ldi	r22, 0x00	; 0
    4a6a:	81 e0       	ldi	r24, 0x01	; 1
    4a6c:	94 e0       	ldi	r25, 0x04	; 4
    4a6e:	de de       	rcall	.-580    	; 0x482c <eeprom_put_char>
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+2), 0); // Checksum
    4a70:	60 e0       	ldi	r22, 0x00	; 0
    4a72:	82 e0       	ldi	r24, 0x02	; 2
    4a74:	94 e0       	ldi	r25, 0x04	; 4
    4a76:	da de       	rcall	.-588    	; 0x482c <eeprom_put_char>
    #endif
  }

  if (restore_flag & SETTINGS_RESTORE_BUILD_INFO) {
    4a78:	03 ff       	sbrs	r16, 3
    4a7a:	08 c0       	rjmp	.+16     	; 0x4a8c <settings_restore+0x8e>
    eeprom_put_char(EEPROM_ADDR_BUILD_INFO , 0);
    4a7c:	60 e0       	ldi	r22, 0x00	; 0
    4a7e:	8e ea       	ldi	r24, 0xAE	; 174
    4a80:	93 e0       	ldi	r25, 0x03	; 3
    4a82:	d4 de       	rcall	.-600    	; 0x482c <eeprom_put_char>
    eeprom_put_char(EEPROM_ADDR_BUILD_INFO+1 , 0); // Checksum
    4a84:	60 e0       	ldi	r22, 0x00	; 0
    4a86:	8f ea       	ldi	r24, 0xAF	; 175
    4a88:	93 e0       	ldi	r25, 0x03	; 3
    4a8a:	d0 de       	rcall	.-608    	; 0x482c <eeprom_put_char>
    4a8c:	2c 96       	adiw	r28, 0x0c	; 12
  }
}
    4a8e:	0f b6       	in	r0, 0x3f	; 63
    4a90:	f8 94       	cli
    4a92:	de bf       	out	0x3e, r29	; 62
    4a94:	0f be       	out	0x3f, r0	; 63
    4a96:	cd bf       	out	0x3d, r28	; 61
    4a98:	df 91       	pop	r29
    4a9a:	cf 91       	pop	r28
    4a9c:	1f 91       	pop	r17
    4a9e:	0f 91       	pop	r16
    4aa0:	08 95       	ret

00004aa2 <settings_read_startup_line>:
    4aa2:	1f 93       	push	r17


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_startup_line(uint8_t n, char *line)
{
    4aa4:	cf 93       	push	r28
    4aa6:	df 93       	push	r29
    4aa8:	18 2f       	mov	r17, r24
    4aaa:	eb 01       	movw	r28, r22
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
  if (!(memcpy_from_eeprom_with_checksum((char*)line, addr, LINE_BUFFER_SIZE))) {
    4aac:	81 e0       	ldi	r24, 0x01	; 1
    4aae:	91 e0       	ldi	r25, 0x01	; 1
    4ab0:	18 9f       	mul	r17, r24
    4ab2:	b0 01       	movw	r22, r0
    4ab4:	19 9f       	mul	r17, r25
    4ab6:	70 0d       	add	r23, r0
    4ab8:	11 24       	eor	r1, r1
    4aba:	7d 5f       	subi	r23, 0xFD	; 253
    4abc:	40 e0       	ldi	r20, 0x00	; 0
    4abe:	51 e0       	ldi	r21, 0x01	; 1
    4ac0:	ce 01       	movw	r24, r28
    4ac2:	16 df       	rcall	.-468    	; 0x48f0 <memcpy_from_eeprom_with_checksum>
    4ac4:	89 2b       	or	r24, r25
    4ac6:	31 f4       	brne	.+12     	; 0x4ad4 <settings_read_startup_line+0x32>
    // Reset line with default value
    line[0] = 0; // Empty line
    4ac8:	18 82       	st	Y, r1
    settings_store_startup_line(n, line);
    4aca:	be 01       	movw	r22, r28
    4acc:	81 2f       	mov	r24, r17
    4ace:	59 df       	rcall	.-334    	; 0x4982 <settings_store_startup_line>
    return(false);
    4ad0:	80 e0       	ldi	r24, 0x00	; 0
    4ad2:	01 c0       	rjmp	.+2      	; 0x4ad6 <settings_read_startup_line+0x34>
  }
  return(true);
    4ad4:	81 e0       	ldi	r24, 0x01	; 1
}
    4ad6:	df 91       	pop	r29
    4ad8:	cf 91       	pop	r28
    4ada:	1f 91       	pop	r17
    4adc:	08 95       	ret

00004ade <settings_read_build_info>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_build_info(char *line)
{
    4ade:	cf 93       	push	r28
    4ae0:	df 93       	push	r29
    4ae2:	ec 01       	movw	r28, r24
  if (!(memcpy_from_eeprom_with_checksum((char*)line, EEPROM_ADDR_BUILD_INFO, LINE_BUFFER_SIZE))) {
    4ae4:	40 e0       	ldi	r20, 0x00	; 0
    4ae6:	51 e0       	ldi	r21, 0x01	; 1
    4ae8:	6e ea       	ldi	r22, 0xAE	; 174
    4aea:	73 e0       	ldi	r23, 0x03	; 3
    4aec:	01 df       	rcall	.-510    	; 0x48f0 <memcpy_from_eeprom_with_checksum>
    4aee:	89 2b       	or	r24, r25
    4af0:	29 f4       	brne	.+10     	; 0x4afc <settings_read_build_info+0x1e>
    // Reset line with default value
    line[0] = 0; // Empty line
    4af2:	18 82       	st	Y, r1
    settings_store_build_info(line);
    4af4:	ce 01       	movw	r24, r28
    4af6:	5c df       	rcall	.-328    	; 0x49b0 <settings_store_build_info>
    return(false);
    4af8:	80 e0       	ldi	r24, 0x00	; 0
    4afa:	01 c0       	rjmp	.+2      	; 0x4afe <settings_read_build_info+0x20>
  }
  return(true);
    4afc:	81 e0       	ldi	r24, 0x01	; 1
}
    4afe:	df 91       	pop	r29
    4b00:	cf 91       	pop	r28
    4b02:	08 95       	ret

00004b04 <settings_read_coord_data>:


// Read selected coordinate data from EEPROM. Updates pointed coord_data value.
uint8_t settings_read_coord_data(uint8_t coord_select, float *coord_data)
{
    4b04:	1f 93       	push	r17
    4b06:	cf 93       	push	r28
    4b08:	df 93       	push	r29
    4b0a:	18 2f       	mov	r17, r24
    4b0c:	eb 01       	movw	r28, r22
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
  if (!(memcpy_from_eeprom_with_checksum((char*)coord_data, addr, sizeof(float)*N_AXIS))) {
    4b0e:	8d e0       	ldi	r24, 0x0D	; 13
    4b10:	18 9f       	mul	r17, r24
    4b12:	b0 01       	movw	r22, r0
    4b14:	11 24       	eor	r1, r1
    4b16:	7e 5f       	subi	r23, 0xFE	; 254
    4b18:	4c e0       	ldi	r20, 0x0C	; 12
    4b1a:	50 e0       	ldi	r21, 0x00	; 0
    4b1c:	ce 01       	movw	r24, r28
    4b1e:	e8 de       	rcall	.-560    	; 0x48f0 <memcpy_from_eeprom_with_checksum>
    4b20:	89 2b       	or	r24, r25
    4b22:	51 f4       	brne	.+20     	; 0x4b38 <settings_read_coord_data+0x34>
    // Reset with default zero vector
    clear_vector_float(coord_data);
    4b24:	8c e0       	ldi	r24, 0x0C	; 12
    4b26:	fe 01       	movw	r30, r28
    4b28:	11 92       	st	Z+, r1
    4b2a:	8a 95       	dec	r24
    4b2c:	e9 f7       	brne	.-6      	; 0x4b28 <settings_read_coord_data+0x24>
    settings_write_coord_data(coord_select,coord_data);
    4b2e:	be 01       	movw	r22, r28
    4b30:	81 2f       	mov	r24, r17
    4b32:	45 df       	rcall	.-374    	; 0x49be <settings_write_coord_data>
    return(false);
    4b34:	80 e0       	ldi	r24, 0x00	; 0
    4b36:	01 c0       	rjmp	.+2      	; 0x4b3a <settings_read_coord_data+0x36>
  }
  return(true);
    4b38:	81 e0       	ldi	r24, 0x01	; 1
}
    4b3a:	df 91       	pop	r29
    4b3c:	cf 91       	pop	r28
    4b3e:	1f 91       	pop	r17
    4b40:	08 95       	ret

00004b42 <read_global_settings>:


// Reads Grbl global settings struct from EEPROM.
uint8_t read_global_settings() {
  // Check version-byte of eeprom
  uint8_t version = eeprom_get_char(0);
    4b42:	80 e0       	ldi	r24, 0x00	; 0
    4b44:	90 e0       	ldi	r25, 0x00	; 0
    4b46:	6a de       	rcall	.-812    	; 0x481c <eeprom_get_char>
  if (version == SETTINGS_VERSION) {
    4b48:	8a 30       	cpi	r24, 0x0A	; 10
    4b4a:	61 f4       	brne	.+24     	; 0x4b64 <read_global_settings+0x22>
    // Read settings-record and check checksum
    if (!(memcpy_from_eeprom_with_checksum((char*)&settings, EEPROM_ADDR_GLOBAL, sizeof(settings_t)))) {
    4b4c:	45 e5       	ldi	r20, 0x55	; 85
    4b4e:	50 e0       	ldi	r21, 0x00	; 0
    4b50:	61 e0       	ldi	r22, 0x01	; 1
    4b52:	70 e0       	ldi	r23, 0x00	; 0
    4b54:	80 ec       	ldi	r24, 0xC0	; 192
    4b56:	9e e0       	ldi	r25, 0x0E	; 14
    4b58:	cb de       	rcall	.-618    	; 0x48f0 <memcpy_from_eeprom_with_checksum>
      return(false);
    4b5a:	21 e0       	ldi	r18, 0x01	; 1
    4b5c:	89 2b       	or	r24, r25
    4b5e:	19 f4       	brne	.+6      	; 0x4b66 <read_global_settings+0x24>
    4b60:	20 e0       	ldi	r18, 0x00	; 0
    4b62:	01 c0       	rjmp	.+2      	; 0x4b66 <read_global_settings+0x24>
    }
  } else {
    return(false);
    4b64:	20 e0       	ldi	r18, 0x00	; 0
  }
  return(true);
}
    4b66:	82 2f       	mov	r24, r18
    4b68:	08 95       	ret

00004b6a <settings_store_global_setting>:


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
    4b6a:	cf 92       	push	r12
    4b6c:	df 92       	push	r13
    4b6e:	ef 92       	push	r14
    4b70:	ff 92       	push	r15
    4b72:	cf 93       	push	r28
    4b74:	df 93       	push	r29
    4b76:	c8 2f       	mov	r28, r24
    4b78:	6a 01       	movw	r12, r20
    4b7a:	7b 01       	movw	r14, r22
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); }
    4b7c:	20 e0       	ldi	r18, 0x00	; 0
    4b7e:	30 e0       	ldi	r19, 0x00	; 0
    4b80:	a9 01       	movw	r20, r18
    4b82:	c7 01       	movw	r24, r14
    4b84:	b6 01       	movw	r22, r12
    4b86:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    4b8a:	88 23       	and	r24, r24
    4b8c:	0c f4       	brge	.+2      	; 0x4b90 <settings_store_global_setting+0x26>
    4b8e:	07 c1       	rjmp	.+526    	; 0x4d9e <settings_store_global_setting+0x234>
  if (parameter >= AXIS_SETTINGS_START_VAL) {
    4b90:	c4 36       	cpi	r28, 0x64	; 100
    4b92:	a0 f0       	brcs	.+40     	; 0x4bbc <settings_store_global_setting+0x52>
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    4b94:	ec e9       	ldi	r30, 0x9C	; 156
    4b96:	ec 0f       	add	r30, r28
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    4b98:	e3 30       	cpi	r30, 0x03	; 3
    4b9a:	20 f0       	brcs	.+8      	; 0x4ba4 <settings_store_global_setting+0x3a>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4b9c:	ea 30       	cpi	r30, 0x0A	; 10
    4b9e:	08 f0       	brcs	.+2      	; 0x4ba2 <settings_store_global_setting+0x38>
    4ba0:	0c c1       	rjmp	.+536    	; 0x4dba <settings_store_global_setting+0x250>
    4ba2:	ff c0       	rjmp	.+510    	; 0x4da2 <settings_store_global_setting+0x238>
        switch (set_idx) {
          case 0:
            #ifdef MAX_STEP_RATE_HZ
              if (value*settings.max_rate[parameter] > (MAX_STEP_RATE_HZ*60.0)) { return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            #endif
            settings.steps_per_mm[parameter] = value;
    4ba4:	f0 e0       	ldi	r31, 0x00	; 0
    4ba6:	ee 0f       	add	r30, r30
    4ba8:	ff 1f       	adc	r31, r31
    4baa:	ee 0f       	add	r30, r30
    4bac:	ff 1f       	adc	r31, r31
    4bae:	e0 54       	subi	r30, 0x40	; 64
    4bb0:	f1 4f       	sbci	r31, 0xF1	; 241
    4bb2:	c0 82       	st	Z, r12
    4bb4:	d1 82       	std	Z+1, r13	; 0x01
    4bb6:	e2 82       	std	Z+2, r14	; 0x02
    4bb8:	f3 82       	std	Z+3, r15	; 0x03
            break;
    4bba:	ee c0       	rjmp	.+476    	; 0x4d98 <settings_store_global_setting+0x22e>
        parameter -= AXIS_SETTINGS_INCREMENT;
      }
    }
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    4bbc:	c7 01       	movw	r24, r14
    4bbe:	b6 01       	movw	r22, r12
    4bc0:	0e 94 d1 41 	call	0x83a2	; 0x83a2 <trunc>
    4bc4:	0e 94 39 3f 	call	0x7e72	; 0x7e72 <__fixunssfsi>
    switch(parameter) {
    4bc8:	8c 2f       	mov	r24, r28
    4bca:	90 e0       	ldi	r25, 0x00	; 0
    4bcc:	81 32       	cpi	r24, 0x21	; 33
    4bce:	91 05       	cpc	r25, r1
    4bd0:	08 f0       	brcs	.+2      	; 0x4bd4 <settings_store_global_setting+0x6a>
    4bd2:	e9 c0       	rjmp	.+466    	; 0x4da6 <settings_store_global_setting+0x23c>
    4bd4:	fc 01       	movw	r30, r24
    4bd6:	88 27       	eor	r24, r24
    4bd8:	ed 5d       	subi	r30, 0xDD	; 221
    4bda:	fe 4f       	sbci	r31, 0xFE	; 254
    4bdc:	8f 4f       	sbci	r24, 0xFF	; 255
    4bde:	0c 94 12 42 	jmp	0x8424	; 0x8424 <__tablejump2__>
      case 0:
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    4be2:	63 30       	cpi	r22, 0x03	; 3
    4be4:	08 f4       	brcc	.+2      	; 0x4be8 <settings_store_global_setting+0x7e>
    4be6:	e1 c0       	rjmp	.+450    	; 0x4daa <settings_store_global_setting+0x240>
        settings.pulse_microseconds = int_value; break;
    4be8:	60 93 f0 0e 	sts	0x0EF0, r22	; 0x800ef0 <settings+0x30>
    4bec:	d5 c0       	rjmp	.+426    	; 0x4d98 <settings_store_global_setting+0x22e>
      case 1: settings.stepper_idle_lock_time = int_value; break;
    4bee:	60 93 f3 0e 	sts	0x0EF3, r22	; 0x800ef3 <settings+0x33>
    4bf2:	d2 c0       	rjmp	.+420    	; 0x4d98 <settings_store_global_setting+0x22e>
      case 2:
        settings.step_invert_mask = int_value;
    4bf4:	60 93 f1 0e 	sts	0x0EF1, r22	; 0x800ef1 <settings+0x31>
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    4bf8:	0e 94 01 1b 	call	0x3602	; 0x3602 <st_generate_step_dir_invert_masks>
        break;
    4bfc:	cd c0       	rjmp	.+410    	; 0x4d98 <settings_store_global_setting+0x22e>
      case 3:
        settings.dir_invert_mask = int_value;
    4bfe:	60 93 f2 0e 	sts	0x0EF2, r22	; 0x800ef2 <settings+0x32>
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    4c02:	0e 94 01 1b 	call	0x3602	; 0x3602 <st_generate_step_dir_invert_masks>
        break;
    4c06:	c8 c0       	rjmp	.+400    	; 0x4d98 <settings_store_global_setting+0x22e>
      case 4: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }
    4c08:	66 23       	and	r22, r22
    4c0a:	31 f0       	breq	.+12     	; 0x4c18 <settings_store_global_setting+0xae>
    4c0c:	e5 e0       	ldi	r30, 0x05	; 5
    4c0e:	ff e0       	ldi	r31, 0x0F	; 15
    4c10:	80 81       	ld	r24, Z
    4c12:	84 60       	ori	r24, 0x04	; 4
    4c14:	80 83       	st	Z, r24
    4c16:	c0 c0       	rjmp	.+384    	; 0x4d98 <settings_store_global_setting+0x22e>
        else { settings.flags &= ~BITFLAG_INVERT_ST_ENABLE; }
    4c18:	e5 e0       	ldi	r30, 0x05	; 5
    4c1a:	ff e0       	ldi	r31, 0x0F	; 15
    4c1c:	80 81       	ld	r24, Z
    4c1e:	8b 7f       	andi	r24, 0xFB	; 251
    4c20:	80 83       	st	Z, r24
    4c22:	ba c0       	rjmp	.+372    	; 0x4d98 <settings_store_global_setting+0x22e>
        break;
      case 5: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
    4c24:	66 23       	and	r22, r22
    4c26:	31 f0       	breq	.+12     	; 0x4c34 <settings_store_global_setting+0xca>
    4c28:	e5 e0       	ldi	r30, 0x05	; 5
    4c2a:	ff e0       	ldi	r31, 0x0F	; 15
    4c2c:	80 81       	ld	r24, Z
    4c2e:	80 64       	ori	r24, 0x40	; 64
    4c30:	80 83       	st	Z, r24
    4c32:	b2 c0       	rjmp	.+356    	; 0x4d98 <settings_store_global_setting+0x22e>
        else { settings.flags &= ~BITFLAG_INVERT_LIMIT_PINS; }
    4c34:	e5 e0       	ldi	r30, 0x05	; 5
    4c36:	ff e0       	ldi	r31, 0x0F	; 15
    4c38:	80 81       	ld	r24, Z
    4c3a:	8f 7b       	andi	r24, 0xBF	; 191
    4c3c:	80 83       	st	Z, r24
    4c3e:	ac c0       	rjmp	.+344    	; 0x4d98 <settings_store_global_setting+0x22e>
        break;
      case 6: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_PROBE_PIN; }
    4c40:	66 23       	and	r22, r22
    4c42:	31 f0       	breq	.+12     	; 0x4c50 <settings_store_global_setting+0xe6>
    4c44:	e5 e0       	ldi	r30, 0x05	; 5
    4c46:	ff e0       	ldi	r31, 0x0F	; 15
    4c48:	80 81       	ld	r24, Z
    4c4a:	80 68       	ori	r24, 0x80	; 128
    4c4c:	80 83       	st	Z, r24
    4c4e:	05 c0       	rjmp	.+10     	; 0x4c5a <settings_store_global_setting+0xf0>
        else { settings.flags &= ~BITFLAG_INVERT_PROBE_PIN; }
    4c50:	e5 e0       	ldi	r30, 0x05	; 5
    4c52:	ff e0       	ldi	r31, 0x0F	; 15
    4c54:	80 81       	ld	r24, Z
    4c56:	8f 77       	andi	r24, 0x7F	; 127
    4c58:	80 83       	st	Z, r24
        probe_configure_invert_mask(false);
    4c5a:	80 e0       	ldi	r24, 0x00	; 0
    4c5c:	0e 94 44 34 	call	0x6888	; 0x6888 <probe_configure_invert_mask>
        break;
    4c60:	9b c0       	rjmp	.+310    	; 0x4d98 <settings_store_global_setting+0x22e>
      case 10: settings.status_report_mask = int_value; break;
    4c62:	60 93 f4 0e 	sts	0x0EF4, r22	; 0x800ef4 <settings+0x34>
    4c66:	98 c0       	rjmp	.+304    	; 0x4d98 <settings_store_global_setting+0x22e>
      case 11: settings.junction_deviation = value; break;
    4c68:	c0 92 f5 0e 	sts	0x0EF5, r12	; 0x800ef5 <settings+0x35>
    4c6c:	d0 92 f6 0e 	sts	0x0EF6, r13	; 0x800ef6 <settings+0x36>
    4c70:	e0 92 f7 0e 	sts	0x0EF7, r14	; 0x800ef7 <settings+0x37>
    4c74:	f0 92 f8 0e 	sts	0x0EF8, r15	; 0x800ef8 <settings+0x38>
    4c78:	8f c0       	rjmp	.+286    	; 0x4d98 <settings_store_global_setting+0x22e>
      case 12: settings.arc_tolerance = value; break;
    4c7a:	c0 92 f9 0e 	sts	0x0EF9, r12	; 0x800ef9 <settings+0x39>
    4c7e:	d0 92 fa 0e 	sts	0x0EFA, r13	; 0x800efa <settings+0x3a>
    4c82:	e0 92 fb 0e 	sts	0x0EFB, r14	; 0x800efb <settings+0x3b>
    4c86:	f0 92 fc 0e 	sts	0x0EFC, r15	; 0x800efc <settings+0x3c>
    4c8a:	86 c0       	rjmp	.+268    	; 0x4d98 <settings_store_global_setting+0x22e>
      case 13:
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
    4c8c:	66 23       	and	r22, r22
    4c8e:	31 f0       	breq	.+12     	; 0x4c9c <settings_store_global_setting+0x132>
    4c90:	e5 e0       	ldi	r30, 0x05	; 5
    4c92:	ff e0       	ldi	r31, 0x0F	; 15
    4c94:	80 81       	ld	r24, Z
    4c96:	81 60       	ori	r24, 0x01	; 1
    4c98:	80 83       	st	Z, r24
    4c9a:	05 c0       	rjmp	.+10     	; 0x4ca6 <settings_store_global_setting+0x13c>
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
    4c9c:	e5 e0       	ldi	r30, 0x05	; 5
    4c9e:	ff e0       	ldi	r31, 0x0F	; 15
    4ca0:	80 81       	ld	r24, Z
    4ca2:	8e 7f       	andi	r24, 0xFE	; 254
    4ca4:	80 83       	st	Z, r24
        system_flag_wco_change(); // Make sure WCO is immediately updated.
    4ca6:	0e 94 57 3a 	call	0x74ae	; 0x74ae <system_flag_wco_change>
        break;
    4caa:	76 c0       	rjmp	.+236    	; 0x4d98 <settings_store_global_setting+0x22e>
      case 20:
        if (int_value) {
    4cac:	66 23       	and	r22, r22
    4cae:	41 f0       	breq	.+16     	; 0x4cc0 <settings_store_global_setting+0x156>
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    4cb0:	80 91 05 0f 	lds	r24, 0x0F05	; 0x800f05 <settings+0x45>
    4cb4:	84 ff       	sbrs	r24, 4
    4cb6:	7b c0       	rjmp	.+246    	; 0x4dae <settings_store_global_setting+0x244>
          settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE;
    4cb8:	80 62       	ori	r24, 0x20	; 32
    4cba:	80 93 05 0f 	sts	0x0F05, r24	; 0x800f05 <settings+0x45>
    4cbe:	6c c0       	rjmp	.+216    	; 0x4d98 <settings_store_global_setting+0x22e>
        } else { settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; }
    4cc0:	e5 e0       	ldi	r30, 0x05	; 5
    4cc2:	ff e0       	ldi	r31, 0x0F	; 15
    4cc4:	80 81       	ld	r24, Z
    4cc6:	8f 7d       	andi	r24, 0xDF	; 223
    4cc8:	80 83       	st	Z, r24
    4cca:	66 c0       	rjmp	.+204    	; 0x4d98 <settings_store_global_setting+0x22e>
        break;
      case 21:
        if (int_value) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
    4ccc:	66 23       	and	r22, r22
    4cce:	31 f0       	breq	.+12     	; 0x4cdc <settings_store_global_setting+0x172>
    4cd0:	e5 e0       	ldi	r30, 0x05	; 5
    4cd2:	ff e0       	ldi	r31, 0x0F	; 15
    4cd4:	80 81       	ld	r24, Z
    4cd6:	88 60       	ori	r24, 0x08	; 8
    4cd8:	80 83       	st	Z, r24
    4cda:	05 c0       	rjmp	.+10     	; 0x4ce6 <settings_store_global_setting+0x17c>
        else { settings.flags &= ~BITFLAG_HARD_LIMIT_ENABLE; }
    4cdc:	e5 e0       	ldi	r30, 0x05	; 5
    4cde:	ff e0       	ldi	r31, 0x0F	; 15
    4ce0:	80 81       	ld	r24, Z
    4ce2:	87 7f       	andi	r24, 0xF7	; 247
    4ce4:	80 83       	st	Z, r24
        limits_init(); // Re-init to immediately change. NOTE: Nice to have but could be problematic later.
    4ce6:	0e 94 ac 2f 	call	0x5f58	; 0x5f58 <limits_init>
        break;
    4cea:	56 c0       	rjmp	.+172    	; 0x4d98 <settings_store_global_setting+0x22e>
      case 22:
        if (int_value) { settings.flags |= BITFLAG_HOMING_ENABLE; }
    4cec:	66 23       	and	r22, r22
    4cee:	31 f0       	breq	.+12     	; 0x4cfc <settings_store_global_setting+0x192>
    4cf0:	e5 e0       	ldi	r30, 0x05	; 5
    4cf2:	ff e0       	ldi	r31, 0x0F	; 15
    4cf4:	80 81       	ld	r24, Z
    4cf6:	80 61       	ori	r24, 0x10	; 16
    4cf8:	80 83       	st	Z, r24
    4cfa:	4e c0       	rjmp	.+156    	; 0x4d98 <settings_store_global_setting+0x22e>
        else {
          settings.flags &= ~BITFLAG_HOMING_ENABLE;
          settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; // Force disable soft-limits.
    4cfc:	e5 e0       	ldi	r30, 0x05	; 5
    4cfe:	ff e0       	ldi	r31, 0x0F	; 15
    4d00:	80 81       	ld	r24, Z
    4d02:	8f 7c       	andi	r24, 0xCF	; 207
    4d04:	80 83       	st	Z, r24
    4d06:	48 c0       	rjmp	.+144    	; 0x4d98 <settings_store_global_setting+0x22e>
        }
        break;
      case 23: settings.homing_dir_mask = int_value; break;
    4d08:	60 93 06 0f 	sts	0x0F06, r22	; 0x800f06 <settings+0x46>
    4d0c:	45 c0       	rjmp	.+138    	; 0x4d98 <settings_store_global_setting+0x22e>
      case 24: settings.homing_feed_rate = value; break;
    4d0e:	c0 92 07 0f 	sts	0x0F07, r12	; 0x800f07 <settings+0x47>
    4d12:	d0 92 08 0f 	sts	0x0F08, r13	; 0x800f08 <settings+0x48>
    4d16:	e0 92 09 0f 	sts	0x0F09, r14	; 0x800f09 <settings+0x49>
    4d1a:	f0 92 0a 0f 	sts	0x0F0A, r15	; 0x800f0a <settings+0x4a>
    4d1e:	3c c0       	rjmp	.+120    	; 0x4d98 <settings_store_global_setting+0x22e>
      case 25: settings.homing_seek_rate = value; break;
    4d20:	c0 92 0b 0f 	sts	0x0F0B, r12	; 0x800f0b <settings+0x4b>
    4d24:	d0 92 0c 0f 	sts	0x0F0C, r13	; 0x800f0c <settings+0x4c>
    4d28:	e0 92 0d 0f 	sts	0x0F0D, r14	; 0x800f0d <settings+0x4d>
    4d2c:	f0 92 0e 0f 	sts	0x0F0E, r15	; 0x800f0e <settings+0x4e>
    4d30:	33 c0       	rjmp	.+102    	; 0x4d98 <settings_store_global_setting+0x22e>
      case 26: settings.homing_debounce_delay = int_value; break;
    4d32:	86 2f       	mov	r24, r22
    4d34:	90 e0       	ldi	r25, 0x00	; 0
    4d36:	90 93 10 0f 	sts	0x0F10, r25	; 0x800f10 <settings+0x50>
    4d3a:	80 93 0f 0f 	sts	0x0F0F, r24	; 0x800f0f <settings+0x4f>
    4d3e:	2c c0       	rjmp	.+88     	; 0x4d98 <settings_store_global_setting+0x22e>
      case 27: settings.homing_pulloff = value; break;
    4d40:	c0 92 11 0f 	sts	0x0F11, r12	; 0x800f11 <settings+0x51>
    4d44:	d0 92 12 0f 	sts	0x0F12, r13	; 0x800f12 <settings+0x52>
    4d48:	e0 92 13 0f 	sts	0x0F13, r14	; 0x800f13 <settings+0x53>
    4d4c:	f0 92 14 0f 	sts	0x0F14, r15	; 0x800f14 <settings+0x54>
    4d50:	23 c0       	rjmp	.+70     	; 0x4d98 <settings_store_global_setting+0x22e>
      case 30: settings.rpm_max = value; spindle_init(); break; // Re-initialize spindle rpm calibration
    4d52:	c0 92 fd 0e 	sts	0x0EFD, r12	; 0x800efd <settings+0x3d>
    4d56:	d0 92 fe 0e 	sts	0x0EFE, r13	; 0x800efe <settings+0x3e>
    4d5a:	e0 92 ff 0e 	sts	0x0EFF, r14	; 0x800eff <settings+0x3f>
    4d5e:	f0 92 00 0f 	sts	0x0F00, r15	; 0x800f00 <settings+0x40>
    4d62:	0e 94 2d 12 	call	0x245a	; 0x245a <spindle_init>
    4d66:	18 c0       	rjmp	.+48     	; 0x4d98 <settings_store_global_setting+0x22e>
      case 31: settings.rpm_min = value; spindle_init(); break; // Re-initialize spindle rpm calibration
    4d68:	c0 92 01 0f 	sts	0x0F01, r12	; 0x800f01 <settings+0x41>
    4d6c:	d0 92 02 0f 	sts	0x0F02, r13	; 0x800f02 <settings+0x42>
    4d70:	e0 92 03 0f 	sts	0x0F03, r14	; 0x800f03 <settings+0x43>
    4d74:	f0 92 04 0f 	sts	0x0F04, r15	; 0x800f04 <settings+0x44>
    4d78:	0e 94 2d 12 	call	0x245a	; 0x245a <spindle_init>
    4d7c:	0d c0       	rjmp	.+26     	; 0x4d98 <settings_store_global_setting+0x22e>
      case 32:
        if (int_value) { settings.flags |= BITFLAG_LASER_MODE; }
    4d7e:	66 23       	and	r22, r22
    4d80:	31 f0       	breq	.+12     	; 0x4d8e <settings_store_global_setting+0x224>
    4d82:	e5 e0       	ldi	r30, 0x05	; 5
    4d84:	ff e0       	ldi	r31, 0x0F	; 15
    4d86:	80 81       	ld	r24, Z
    4d88:	82 60       	ori	r24, 0x02	; 2
    4d8a:	80 83       	st	Z, r24
    4d8c:	05 c0       	rjmp	.+10     	; 0x4d98 <settings_store_global_setting+0x22e>
        else { settings.flags &= ~BITFLAG_LASER_MODE; }
    4d8e:	e5 e0       	ldi	r30, 0x05	; 5
    4d90:	ff e0       	ldi	r31, 0x0F	; 15
    4d92:	80 81       	ld	r24, Z
    4d94:	8d 7f       	andi	r24, 0xFD	; 253
    4d96:	80 83       	st	Z, r24
        break;
      default:
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
    4d98:	26 de       	rcall	.-948    	; 0x49e6 <write_global_settings>
  return(STATUS_OK);
    4d9a:	80 e0       	ldi	r24, 0x00	; 0
    4d9c:	58 c0       	rjmp	.+176    	; 0x4e4e <settings_store_global_setting+0x2e4>
}


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); }
    4d9e:	84 e0       	ldi	r24, 0x04	; 4
    4da0:	56 c0       	rjmp	.+172    	; 0x4e4e <settings_store_global_setting+0x2e4>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4da2:	83 e0       	ldi	r24, 0x03	; 3
    4da4:	54 c0       	rjmp	.+168    	; 0x4e4e <settings_store_global_setting+0x2e4>
      case 32:
        if (int_value) { settings.flags |= BITFLAG_LASER_MODE; }
        else { settings.flags &= ~BITFLAG_LASER_MODE; }
        break;
      default:
        return(STATUS_INVALID_STATEMENT);
    4da6:	83 e0       	ldi	r24, 0x03	; 3
    4da8:	52 c0       	rjmp	.+164    	; 0x4e4e <settings_store_global_setting+0x2e4>
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    switch(parameter) {
      case 0:
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    4daa:	86 e0       	ldi	r24, 0x06	; 6
    4dac:	50 c0       	rjmp	.+160    	; 0x4e4e <settings_store_global_setting+0x2e4>
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
        system_flag_wco_change(); // Make sure WCO is immediately updated.
        break;
      case 20:
        if (int_value) {
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    4dae:	8a e0       	ldi	r24, 0x0A	; 10
    4db0:	4e c0       	rjmp	.+156    	; 0x4e4e <settings_store_global_setting+0x2e4>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4db2:	83 e0       	ldi	r24, 0x03	; 3
    4db4:	4c c0       	rjmp	.+152    	; 0x4e4e <settings_store_global_setting+0x2e4>
    4db6:	83 e0       	ldi	r24, 0x03	; 3
    4db8:	4a c0       	rjmp	.+148    	; 0x4e4e <settings_store_global_setting+0x2e4>
        parameter -= AXIS_SETTINGS_INCREMENT;
    4dba:	e2 e9       	ldi	r30, 0x92	; 146
    4dbc:	ec 0f       	add	r30, r28
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    4dbe:	e3 30       	cpi	r30, 0x03	; 3
    4dc0:	70 f0       	brcs	.+28     	; 0x4dde <settings_store_global_setting+0x274>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4dc2:	ea 30       	cpi	r30, 0x0A	; 10
    4dc4:	b0 f3       	brcs	.-20     	; 0x4db2 <settings_store_global_setting+0x248>
        parameter -= AXIS_SETTINGS_INCREMENT;
    4dc6:	88 e8       	ldi	r24, 0x88	; 136
    4dc8:	8c 0f       	add	r24, r28
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    4dca:	83 30       	cpi	r24, 0x03	; 3
    4dcc:	a0 f0       	brcs	.+40     	; 0x4df6 <settings_store_global_setting+0x28c>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4dce:	8a 30       	cpi	r24, 0x0A	; 10
    4dd0:	90 f3       	brcs	.-28     	; 0x4db6 <settings_store_global_setting+0x24c>
        parameter -= AXIS_SETTINGS_INCREMENT;
    4dd2:	8e e7       	ldi	r24, 0x7E	; 126
    4dd4:	8c 0f       	add	r24, r28
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    4dd6:	83 30       	cpi	r24, 0x03	; 3
    4dd8:	48 f1       	brcs	.+82     	; 0x4e2c <settings_store_global_setting+0x2c2>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4dda:	83 e0       	ldi	r24, 0x03	; 3
    4ddc:	38 c0       	rjmp	.+112    	; 0x4e4e <settings_store_global_setting+0x2e4>
            break;
          case 1:
            #ifdef MAX_STEP_RATE_HZ
              if (value*settings.steps_per_mm[parameter] > (MAX_STEP_RATE_HZ*60.0)) {  return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            #endif
            settings.max_rate[parameter] = value;
    4dde:	f0 e0       	ldi	r31, 0x00	; 0
    4de0:	ee 0f       	add	r30, r30
    4de2:	ff 1f       	adc	r31, r31
    4de4:	ee 0f       	add	r30, r30
    4de6:	ff 1f       	adc	r31, r31
    4de8:	e4 53       	subi	r30, 0x34	; 52
    4dea:	f1 4f       	sbci	r31, 0xF1	; 241
    4dec:	c0 82       	st	Z, r12
    4dee:	d1 82       	std	Z+1, r13	; 0x01
    4df0:	e2 82       	std	Z+2, r14	; 0x02
    4df2:	f3 82       	std	Z+3, r15	; 0x03
            break;
    4df4:	d1 cf       	rjmp	.-94     	; 0x4d98 <settings_store_global_setting+0x22e>
          case 2: settings.acceleration[parameter] = value*60*60; break; // Convert to mm/min^2 for grbl internal use.
    4df6:	c8 2f       	mov	r28, r24
    4df8:	d0 e0       	ldi	r29, 0x00	; 0
    4dfa:	cc 0f       	add	r28, r28
    4dfc:	dd 1f       	adc	r29, r29
    4dfe:	cc 0f       	add	r28, r28
    4e00:	dd 1f       	adc	r29, r29
    4e02:	c8 52       	subi	r28, 0x28	; 40
    4e04:	d1 4f       	sbci	r29, 0xF1	; 241
    4e06:	20 e0       	ldi	r18, 0x00	; 0
    4e08:	30 e0       	ldi	r19, 0x00	; 0
    4e0a:	40 e7       	ldi	r20, 0x70	; 112
    4e0c:	52 e4       	ldi	r21, 0x42	; 66
    4e0e:	c7 01       	movw	r24, r14
    4e10:	b6 01       	movw	r22, r12
    4e12:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    4e16:	20 e0       	ldi	r18, 0x00	; 0
    4e18:	30 e0       	ldi	r19, 0x00	; 0
    4e1a:	40 e7       	ldi	r20, 0x70	; 112
    4e1c:	52 e4       	ldi	r21, 0x42	; 66
    4e1e:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    4e22:	68 83       	st	Y, r22
    4e24:	79 83       	std	Y+1, r23	; 0x01
    4e26:	8a 83       	std	Y+2, r24	; 0x02
    4e28:	9b 83       	std	Y+3, r25	; 0x03
    4e2a:	b6 cf       	rjmp	.-148    	; 0x4d98 <settings_store_global_setting+0x22e>
          case 3: settings.max_travel[parameter] = -value; break;  // Store as negative for grbl internal use.
    4e2c:	e8 2f       	mov	r30, r24
    4e2e:	f0 e0       	ldi	r31, 0x00	; 0
    4e30:	ee 0f       	add	r30, r30
    4e32:	ff 1f       	adc	r31, r31
    4e34:	ee 0f       	add	r30, r30
    4e36:	ff 1f       	adc	r31, r31
    4e38:	ec 51       	subi	r30, 0x1C	; 28
    4e3a:	f1 4f       	sbci	r31, 0xF1	; 241
    4e3c:	f7 fa       	bst	r15, 7
    4e3e:	f0 94       	com	r15
    4e40:	f7 f8       	bld	r15, 7
    4e42:	f0 94       	com	r15
    4e44:	c0 82       	st	Z, r12
    4e46:	d1 82       	std	Z+1, r13	; 0x01
    4e48:	e2 82       	std	Z+2, r14	; 0x02
    4e4a:	f3 82       	std	Z+3, r15	; 0x03
    4e4c:	a5 cf       	rjmp	.-182    	; 0x4d98 <settings_store_global_setting+0x22e>
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
  return(STATUS_OK);
}
    4e4e:	df 91       	pop	r29
    4e50:	cf 91       	pop	r28
    4e52:	ff 90       	pop	r15
    4e54:	ef 90       	pop	r14
    4e56:	df 90       	pop	r13
    4e58:	cf 90       	pop	r12
    4e5a:	08 95       	ret

00004e5c <settings_init>:


// Initialize the config subsystem
void settings_init() {
  if(!read_global_settings()) {
    4e5c:	72 de       	rcall	.-796    	; 0x4b42 <read_global_settings>
    4e5e:	81 11       	cpse	r24, r1
    4e60:	07 c0       	rjmp	.+14     	; 0x4e70 <settings_init+0x14>
    report_status_message(STATUS_SETTING_READ_FAIL);
    4e62:	87 e0       	ldi	r24, 0x07	; 7
    4e64:	0e 94 c6 34 	call	0x698c	; 0x698c <report_status_message>
    settings_restore(SETTINGS_RESTORE_ALL); // Force restore all EEPROM data.
    4e68:	8f ef       	ldi	r24, 0xFF	; 255
    4e6a:	c9 dd       	rcall	.-1134   	; 0x49fe <settings_restore>
    report_grbl_settings();
    4e6c:	0c 94 42 35 	jmp	0x6a84	; 0x6a84 <report_grbl_settings>
    4e70:	08 95       	ret

00004e72 <get_step_pin_mask>:
  #ifdef DEFAULTS_RAMPS_BOARD
    if ( axis_idx == X_AXIS ) { return((1<<STEP_BIT(X_AXIS))); }
    if ( axis_idx == Y_AXIS ) { return((1<<STEP_BIT(Y_AXIS))); }
    return((1<<STEP_BIT(Z_AXIS)));
  #else
    if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    4e72:	88 23       	and	r24, r24
    4e74:	21 f0       	breq	.+8      	; 0x4e7e <get_step_pin_mask+0xc>
    if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    4e76:	81 30       	cpi	r24, 0x01	; 1
    4e78:	21 f0       	breq	.+8      	; 0x4e82 <get_step_pin_mask+0x10>
    return((1<<Z_STEP_BIT));
    4e7a:	80 e1       	ldi	r24, 0x10	; 16
    4e7c:	08 95       	ret
  #ifdef DEFAULTS_RAMPS_BOARD
    if ( axis_idx == X_AXIS ) { return((1<<STEP_BIT(X_AXIS))); }
    if ( axis_idx == Y_AXIS ) { return((1<<STEP_BIT(Y_AXIS))); }
    return((1<<STEP_BIT(Z_AXIS)));
  #else
    if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    4e7e:	84 e0       	ldi	r24, 0x04	; 4
    4e80:	08 95       	ret
    if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    4e82:	88 e0       	ldi	r24, 0x08	; 8
    return((1<<Z_STEP_BIT));
  #endif // DEFAULTS_RAMPS_BOARD
}
    4e84:	08 95       	ret

00004e86 <get_direction_pin_mask>:
  #ifdef DEFAULTS_RAMPS_BOARD
    if ( axis_idx == X_AXIS ) { return((1<<DIRECTION_BIT(X_AXIS))); }
    if ( axis_idx == Y_AXIS ) { return((1<<DIRECTION_BIT(Y_AXIS))); }
    return((1<<DIRECTION_BIT(Z_AXIS)));
  #else
    if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    4e86:	88 23       	and	r24, r24
    4e88:	21 f0       	breq	.+8      	; 0x4e92 <get_direction_pin_mask+0xc>
    if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    4e8a:	81 30       	cpi	r24, 0x01	; 1
    4e8c:	21 f0       	breq	.+8      	; 0x4e96 <get_direction_pin_mask+0x10>
    return((1<<Z_DIRECTION_BIT));
    4e8e:	80 e2       	ldi	r24, 0x20	; 32
    4e90:	08 95       	ret
  #ifdef DEFAULTS_RAMPS_BOARD
    if ( axis_idx == X_AXIS ) { return((1<<DIRECTION_BIT(X_AXIS))); }
    if ( axis_idx == Y_AXIS ) { return((1<<DIRECTION_BIT(Y_AXIS))); }
    return((1<<DIRECTION_BIT(Z_AXIS)));
  #else
    if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    4e92:	80 e8       	ldi	r24, 0x80	; 128
    4e94:	08 95       	ret
    if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    4e96:	80 e4       	ldi	r24, 0x40	; 64
    return((1<<Z_DIRECTION_BIT));
  #endif // DEFAULTS_RAMPS_BOARD
}
    4e98:	08 95       	ret

00004e9a <get_limit_pin_mask>:
     return((1<<MAX_LIMIT_BIT(Z_AXIS)));
  }
#else
  uint8_t get_limit_pin_mask(uint8_t axis_idx)
  {
    if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    4e9a:	88 23       	and	r24, r24
    4e9c:	21 f0       	breq	.+8      	; 0x4ea6 <get_limit_pin_mask+0xc>
    if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    4e9e:	81 30       	cpi	r24, 0x01	; 1
    4ea0:	21 f0       	breq	.+8      	; 0x4eaa <get_limit_pin_mask+0x10>
    return((1<<Z_LIMIT_BIT));
    4ea2:	80 e4       	ldi	r24, 0x40	; 64
    4ea4:	08 95       	ret
     return((1<<MAX_LIMIT_BIT(Z_AXIS)));
  }
#else
  uint8_t get_limit_pin_mask(uint8_t axis_idx)
  {
    if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    4ea6:	80 e1       	ldi	r24, 0x10	; 16
    4ea8:	08 95       	ret
    if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    4eaa:	80 e2       	ldi	r24, 0x20	; 32
    return((1<<Z_LIMIT_BIT));
  }
    4eac:	08 95       	ret

00004eae <planner_recalculate>:
// NOTE: Deprecated. Not used unless classic status reports are enabled in config.h
uint8_t plan_get_block_buffer_count()
{
  if (block_buffer_head >= block_buffer_tail) { return(block_buffer_head-block_buffer_tail); }
  return(BLOCK_BUFFER_SIZE - (block_buffer_tail-block_buffer_head));
}
    4eae:	2f 92       	push	r2
    4eb0:	3f 92       	push	r3
    4eb2:	4f 92       	push	r4
    4eb4:	5f 92       	push	r5
    4eb6:	6f 92       	push	r6
    4eb8:	7f 92       	push	r7
    4eba:	8f 92       	push	r8
    4ebc:	9f 92       	push	r9
    4ebe:	af 92       	push	r10
    4ec0:	bf 92       	push	r11
    4ec2:	cf 92       	push	r12
    4ec4:	df 92       	push	r13
    4ec6:	ef 92       	push	r14
    4ec8:	ff 92       	push	r15
    4eca:	0f 93       	push	r16
    4ecc:	1f 93       	push	r17
    4ece:	cf 93       	push	r28
    4ed0:	df 93       	push	r29
    4ed2:	c0 91 76 04 	lds	r28, 0x0476	; 0x800476 <block_buffer_head>
    4ed6:	c1 11       	cpse	r28, r1
    4ed8:	01 c0       	rjmp	.+2      	; 0x4edc <planner_recalculate+0x2e>
    4eda:	c4 e2       	ldi	r28, 0x24	; 36
    4edc:	c1 50       	subi	r28, 0x01	; 1
    4ede:	d0 91 74 04 	lds	r29, 0x0474	; 0x800474 <block_buffer_planned>
    4ee2:	dc 17       	cp	r29, r28
    4ee4:	09 f4       	brne	.+2      	; 0x4ee8 <planner_recalculate+0x3a>
    4ee6:	36 c1       	rjmp	.+620    	; 0x5154 <planner_recalculate+0x2a6>
    4ee8:	0c 2f       	mov	r16, r28
    4eea:	10 e0       	ldi	r17, 0x00	; 0
    4eec:	26 e3       	ldi	r18, 0x36	; 54
    4eee:	c2 9f       	mul	r28, r18
    4ef0:	c0 01       	movw	r24, r0
    4ef2:	11 24       	eor	r1, r1
    4ef4:	fc 01       	movw	r30, r24
    4ef6:	e8 58       	subi	r30, 0x88	; 136
    4ef8:	fb 4f       	sbci	r31, 0xFB	; 251
    4efa:	6f 01       	movw	r12, r30
    4efc:	e2 8c       	ldd	r14, Z+26	; 0x1a
    4efe:	f3 8c       	ldd	r15, Z+27	; 0x1b
    4f00:	94 8c       	ldd	r9, Z+28	; 0x1c
    4f02:	85 8c       	ldd	r8, Z+29	; 0x1d
    4f04:	66 8d       	ldd	r22, Z+30	; 0x1e
    4f06:	77 8d       	ldd	r23, Z+31	; 0x1f
    4f08:	80 a1       	ldd	r24, Z+32	; 0x20
    4f0a:	91 a1       	ldd	r25, Z+33	; 0x21
    4f0c:	9b 01       	movw	r18, r22
    4f0e:	ac 01       	movw	r20, r24
    4f10:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    4f14:	f6 01       	movw	r30, r12
    4f16:	22 a1       	ldd	r18, Z+34	; 0x22
    4f18:	33 a1       	ldd	r19, Z+35	; 0x23
    4f1a:	44 a1       	ldd	r20, Z+36	; 0x24
    4f1c:	55 a1       	ldd	r21, Z+37	; 0x25
    4f1e:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    4f22:	a6 2e       	mov	r10, r22
    4f24:	b7 2e       	mov	r11, r23
    4f26:	c8 2e       	mov	r12, r24
    4f28:	d9 2e       	mov	r13, r25
    4f2a:	26 2f       	mov	r18, r22
    4f2c:	37 2f       	mov	r19, r23
    4f2e:	48 2f       	mov	r20, r24
    4f30:	59 2f       	mov	r21, r25
    4f32:	6e 2d       	mov	r22, r14
    4f34:	7f 2d       	mov	r23, r15
    4f36:	89 2d       	mov	r24, r9
    4f38:	98 2d       	mov	r25, r8
    4f3a:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    4f3e:	88 23       	and	r24, r24
    4f40:	24 f0       	brlt	.+8      	; 0x4f4a <planner_recalculate+0x9c>
    4f42:	ea 2c       	mov	r14, r10
    4f44:	fb 2c       	mov	r15, r11
    4f46:	9c 2c       	mov	r9, r12
    4f48:	8d 2c       	mov	r8, r13
    4f4a:	86 e3       	ldi	r24, 0x36	; 54
    4f4c:	80 9f       	mul	r24, r16
    4f4e:	f0 01       	movw	r30, r0
    4f50:	81 9f       	mul	r24, r17
    4f52:	f0 0d       	add	r31, r0
    4f54:	11 24       	eor	r1, r1
    4f56:	e8 58       	subi	r30, 0x88	; 136
    4f58:	fb 4f       	sbci	r31, 0xFB	; 251
    4f5a:	8e 2d       	mov	r24, r14
    4f5c:	9f 2d       	mov	r25, r15
    4f5e:	a9 2d       	mov	r26, r9
    4f60:	b8 2d       	mov	r27, r8
    4f62:	86 8b       	std	Z+22, r24	; 0x16
    4f64:	97 8b       	std	Z+23, r25	; 0x17
    4f66:	a0 8f       	std	Z+24, r26	; 0x18
    4f68:	b1 8f       	std	Z+25, r27	; 0x19
    4f6a:	c1 11       	cpse	r28, r1
    4f6c:	01 c0       	rjmp	.+2      	; 0x4f70 <planner_recalculate+0xc2>
    4f6e:	c4 e2       	ldi	r28, 0x24	; 36
    4f70:	c1 50       	subi	r28, 0x01	; 1
    4f72:	dc 13       	cpse	r29, r28
    4f74:	07 c0       	rjmp	.+14     	; 0x4f84 <planner_recalculate+0xd6>
    4f76:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    4f7a:	d8 13       	cpse	r29, r24
    4f7c:	7c c0       	rjmp	.+248    	; 0x5076 <planner_recalculate+0x1c8>
    4f7e:	0e 94 94 1b 	call	0x3728	; 0x3728 <st_update_plan_block_parameters>
    4f82:	79 c0       	rjmp	.+242    	; 0x5076 <planner_recalculate+0x1c8>
    4f84:	26 e3       	ldi	r18, 0x36	; 54
    4f86:	20 9f       	mul	r18, r16
    4f88:	c0 01       	movw	r24, r0
    4f8a:	21 9f       	mul	r18, r17
    4f8c:	90 0d       	add	r25, r0
    4f8e:	11 24       	eor	r1, r1
    4f90:	9c 01       	movw	r18, r24
    4f92:	28 58       	subi	r18, 0x88	; 136
    4f94:	3b 4f       	sbci	r19, 0xFB	; 251
    4f96:	69 01       	movw	r12, r18
    4f98:	d6 e3       	ldi	r29, 0x36	; 54
    4f9a:	ec 2e       	mov	r14, r28
    4f9c:	f1 2c       	mov	r15, r1
    4f9e:	de 9d       	mul	r29, r14
    4fa0:	80 01       	movw	r16, r0
    4fa2:	df 9d       	mul	r29, r15
    4fa4:	10 0d       	add	r17, r0
    4fa6:	11 24       	eor	r1, r1
    4fa8:	08 58       	subi	r16, 0x88	; 136
    4faa:	1b 4f       	sbci	r17, 0xFB	; 251
    4fac:	c1 11       	cpse	r28, r1
    4fae:	01 c0       	rjmp	.+2      	; 0x4fb2 <planner_recalculate+0x104>
    4fb0:	c4 e2       	ldi	r28, 0x24	; 36
    4fb2:	c1 50       	subi	r28, 0x01	; 1
    4fb4:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    4fb8:	8c 13       	cpse	r24, r28
    4fba:	02 c0       	rjmp	.+4      	; 0x4fc0 <planner_recalculate+0x112>
    4fbc:	0e 94 94 1b 	call	0x3728	; 0x3728 <st_update_plan_block_parameters>
    4fc0:	de 9d       	mul	r29, r14
    4fc2:	f0 01       	movw	r30, r0
    4fc4:	df 9d       	mul	r29, r15
    4fc6:	f0 0d       	add	r31, r0
    4fc8:	11 24       	eor	r1, r1
    4fca:	e8 58       	subi	r30, 0x88	; 136
    4fcc:	fb 4f       	sbci	r31, 0xFB	; 251
    4fce:	42 8c       	ldd	r4, Z+26	; 0x1a
    4fd0:	53 8c       	ldd	r5, Z+27	; 0x1b
    4fd2:	64 8c       	ldd	r6, Z+28	; 0x1c
    4fd4:	75 8c       	ldd	r7, Z+29	; 0x1d
    4fd6:	a3 01       	movw	r20, r6
    4fd8:	92 01       	movw	r18, r4
    4fda:	66 89       	ldd	r22, Z+22	; 0x16
    4fdc:	77 89       	ldd	r23, Z+23	; 0x17
    4fde:	80 8d       	ldd	r24, Z+24	; 0x18
    4fe0:	91 8d       	ldd	r25, Z+25	; 0x19
    4fe2:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    4fe6:	88 23       	and	r24, r24
    4fe8:	09 f4       	brne	.+2      	; 0x4fec <planner_recalculate+0x13e>
    4fea:	40 c0       	rjmp	.+128    	; 0x506c <planner_recalculate+0x1be>
    4fec:	de 9d       	mul	r29, r14
    4fee:	c0 01       	movw	r24, r0
    4ff0:	df 9d       	mul	r29, r15
    4ff2:	90 0d       	add	r25, r0
    4ff4:	11 24       	eor	r1, r1
    4ff6:	fc 01       	movw	r30, r24
    4ff8:	e8 58       	subi	r30, 0x88	; 136
    4ffa:	fb 4f       	sbci	r31, 0xFB	; 251
    4ffc:	5f 01       	movw	r10, r30
    4ffe:	66 8d       	ldd	r22, Z+30	; 0x1e
    5000:	77 8d       	ldd	r23, Z+31	; 0x1f
    5002:	80 a1       	ldd	r24, Z+32	; 0x20
    5004:	91 a1       	ldd	r25, Z+33	; 0x21
    5006:	9b 01       	movw	r18, r22
    5008:	ac 01       	movw	r20, r24
    500a:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    500e:	f5 01       	movw	r30, r10
    5010:	22 a1       	ldd	r18, Z+34	; 0x22
    5012:	33 a1       	ldd	r19, Z+35	; 0x23
    5014:	44 a1       	ldd	r20, Z+36	; 0x24
    5016:	55 a1       	ldd	r21, Z+37	; 0x25
    5018:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    501c:	f6 01       	movw	r30, r12
    501e:	26 89       	ldd	r18, Z+22	; 0x16
    5020:	37 89       	ldd	r19, Z+23	; 0x17
    5022:	40 8d       	ldd	r20, Z+24	; 0x18
    5024:	51 8d       	ldd	r21, Z+25	; 0x19
    5026:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    502a:	4b 01       	movw	r8, r22
    502c:	5c 01       	movw	r10, r24
    502e:	9b 01       	movw	r18, r22
    5030:	ac 01       	movw	r20, r24
    5032:	c3 01       	movw	r24, r6
    5034:	b2 01       	movw	r22, r4
    5036:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    503a:	18 16       	cp	r1, r24
    503c:	64 f4       	brge	.+24     	; 0x5056 <planner_recalculate+0x1a8>
    503e:	de 9d       	mul	r29, r14
    5040:	f0 01       	movw	r30, r0
    5042:	df 9d       	mul	r29, r15
    5044:	f0 0d       	add	r31, r0
    5046:	11 24       	eor	r1, r1
    5048:	e8 58       	subi	r30, 0x88	; 136
    504a:	fb 4f       	sbci	r31, 0xFB	; 251
    504c:	86 8a       	std	Z+22, r8	; 0x16
    504e:	97 8a       	std	Z+23, r9	; 0x17
    5050:	a0 8e       	std	Z+24, r10	; 0x18
    5052:	b1 8e       	std	Z+25, r11	; 0x19
    5054:	0b c0       	rjmp	.+22     	; 0x506c <planner_recalculate+0x1be>
    5056:	de 9d       	mul	r29, r14
    5058:	f0 01       	movw	r30, r0
    505a:	df 9d       	mul	r29, r15
    505c:	f0 0d       	add	r31, r0
    505e:	11 24       	eor	r1, r1
    5060:	e8 58       	subi	r30, 0x88	; 136
    5062:	fb 4f       	sbci	r31, 0xFB	; 251
    5064:	46 8a       	std	Z+22, r4	; 0x16
    5066:	57 8a       	std	Z+23, r5	; 0x17
    5068:	60 8e       	std	Z+24, r6	; 0x18
    506a:	71 8e       	std	Z+25, r7	; 0x19
    506c:	68 01       	movw	r12, r16
    506e:	80 91 74 04 	lds	r24, 0x0474	; 0x800474 <block_buffer_planned>
    5072:	8c 13       	cpse	r24, r28
    5074:	92 cf       	rjmp	.-220    	; 0x4f9a <planner_recalculate+0xec>
    5076:	20 90 74 04 	lds	r2, 0x0474	; 0x800474 <block_buffer_planned>
    507a:	f6 e3       	ldi	r31, 0x36	; 54
    507c:	2f 9e       	mul	r2, r31
    507e:	c0 01       	movw	r24, r0
    5080:	11 24       	eor	r1, r1
    5082:	9c 01       	movw	r18, r24
    5084:	28 58       	subi	r18, 0x88	; 136
    5086:	3b 4f       	sbci	r19, 0xFB	; 251
    5088:	79 01       	movw	r14, r18
    508a:	c1 e0       	ldi	r28, 0x01	; 1
    508c:	c2 0d       	add	r28, r2
    508e:	c4 32       	cpi	r28, 0x24	; 36
    5090:	09 f4       	brne	.+2      	; 0x5094 <planner_recalculate+0x1e6>
    5092:	c0 e0       	ldi	r28, 0x00	; 0
    5094:	30 90 76 04 	lds	r3, 0x0476	; 0x800476 <block_buffer_head>
    5098:	d6 e3       	ldi	r29, 0x36	; 54
    509a:	58 c0       	rjmp	.+176    	; 0x514c <planner_recalculate+0x29e>
    509c:	cc 2e       	mov	r12, r28
    509e:	d1 2c       	mov	r13, r1
    50a0:	dc 9d       	mul	r29, r12
    50a2:	80 01       	movw	r16, r0
    50a4:	dd 9d       	mul	r29, r13
    50a6:	10 0d       	add	r17, r0
    50a8:	11 24       	eor	r1, r1
    50aa:	08 58       	subi	r16, 0x88	; 136
    50ac:	1b 4f       	sbci	r17, 0xFB	; 251
    50ae:	f7 01       	movw	r30, r14
    50b0:	46 88       	ldd	r4, Z+22	; 0x16
    50b2:	57 88       	ldd	r5, Z+23	; 0x17
    50b4:	60 8c       	ldd	r6, Z+24	; 0x18
    50b6:	71 8c       	ldd	r7, Z+25	; 0x19
    50b8:	f8 01       	movw	r30, r16
    50ba:	86 88       	ldd	r8, Z+22	; 0x16
    50bc:	97 88       	ldd	r9, Z+23	; 0x17
    50be:	a0 8c       	ldd	r10, Z+24	; 0x18
    50c0:	b1 8c       	ldd	r11, Z+25	; 0x19
    50c2:	a5 01       	movw	r20, r10
    50c4:	94 01       	movw	r18, r8
    50c6:	c3 01       	movw	r24, r6
    50c8:	b2 01       	movw	r22, r4
    50ca:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    50ce:	88 23       	and	r24, r24
    50d0:	24 f5       	brge	.+72     	; 0x511a <planner_recalculate+0x26c>
    50d2:	f7 01       	movw	r30, r14
    50d4:	66 8d       	ldd	r22, Z+30	; 0x1e
    50d6:	77 8d       	ldd	r23, Z+31	; 0x1f
    50d8:	80 a1       	ldd	r24, Z+32	; 0x20
    50da:	91 a1       	ldd	r25, Z+33	; 0x21
    50dc:	9b 01       	movw	r18, r22
    50de:	ac 01       	movw	r20, r24
    50e0:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    50e4:	f7 01       	movw	r30, r14
    50e6:	22 a1       	ldd	r18, Z+34	; 0x22
    50e8:	33 a1       	ldd	r19, Z+35	; 0x23
    50ea:	44 a1       	ldd	r20, Z+36	; 0x24
    50ec:	55 a1       	ldd	r21, Z+37	; 0x25
    50ee:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    50f2:	a3 01       	movw	r20, r6
    50f4:	92 01       	movw	r18, r4
    50f6:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    50fa:	2b 01       	movw	r4, r22
    50fc:	3c 01       	movw	r6, r24
    50fe:	9b 01       	movw	r18, r22
    5100:	ac 01       	movw	r20, r24
    5102:	c5 01       	movw	r24, r10
    5104:	b4 01       	movw	r22, r8
    5106:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    510a:	18 16       	cp	r1, r24
    510c:	34 f4       	brge	.+12     	; 0x511a <planner_recalculate+0x26c>
    510e:	f8 01       	movw	r30, r16
    5110:	46 8a       	std	Z+22, r4	; 0x16
    5112:	57 8a       	std	Z+23, r5	; 0x17
    5114:	60 8e       	std	Z+24, r6	; 0x18
    5116:	71 8e       	std	Z+25, r7	; 0x19
    5118:	2c 2e       	mov	r2, r28
    511a:	dc 9d       	mul	r29, r12
    511c:	f0 01       	movw	r30, r0
    511e:	dd 9d       	mul	r29, r13
    5120:	f0 0d       	add	r31, r0
    5122:	11 24       	eor	r1, r1
    5124:	e8 58       	subi	r30, 0x88	; 136
    5126:	fb 4f       	sbci	r31, 0xFB	; 251
    5128:	22 8d       	ldd	r18, Z+26	; 0x1a
    512a:	33 8d       	ldd	r19, Z+27	; 0x1b
    512c:	44 8d       	ldd	r20, Z+28	; 0x1c
    512e:	55 8d       	ldd	r21, Z+29	; 0x1d
    5130:	66 89       	ldd	r22, Z+22	; 0x16
    5132:	77 89       	ldd	r23, Z+23	; 0x17
    5134:	80 8d       	ldd	r24, Z+24	; 0x18
    5136:	91 8d       	ldd	r25, Z+25	; 0x19
    5138:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    513c:	81 11       	cpse	r24, r1
    513e:	01 c0       	rjmp	.+2      	; 0x5142 <planner_recalculate+0x294>
    5140:	2c 2e       	mov	r2, r28
    5142:	cf 5f       	subi	r28, 0xFF	; 255
    5144:	c4 32       	cpi	r28, 0x24	; 36
    5146:	09 f4       	brne	.+2      	; 0x514a <planner_recalculate+0x29c>
    5148:	c0 e0       	ldi	r28, 0x00	; 0
    514a:	78 01       	movw	r14, r16
    514c:	c3 11       	cpse	r28, r3
    514e:	a6 cf       	rjmp	.-180    	; 0x509c <planner_recalculate+0x1ee>
    5150:	20 92 74 04 	sts	0x0474, r2	; 0x800474 <block_buffer_planned>
    5154:	df 91       	pop	r29
    5156:	cf 91       	pop	r28
    5158:	1f 91       	pop	r17
    515a:	0f 91       	pop	r16
    515c:	ff 90       	pop	r15
    515e:	ef 90       	pop	r14
    5160:	df 90       	pop	r13
    5162:	cf 90       	pop	r12
    5164:	bf 90       	pop	r11
    5166:	af 90       	pop	r10
    5168:	9f 90       	pop	r9
    516a:	8f 90       	pop	r8
    516c:	7f 90       	pop	r7
    516e:	6f 90       	pop	r6
    5170:	5f 90       	pop	r5
    5172:	4f 90       	pop	r4
    5174:	3f 90       	pop	r3
    5176:	2f 90       	pop	r2
    5178:	08 95       	ret

0000517a <plan_reset_buffer>:
    517a:	10 92 77 04 	sts	0x0477, r1	; 0x800477 <block_buffer_tail>
    517e:	10 92 76 04 	sts	0x0476, r1	; 0x800476 <block_buffer_head>
    5182:	81 e0       	ldi	r24, 0x01	; 1
    5184:	80 93 75 04 	sts	0x0475, r24	; 0x800475 <next_buffer_head>
    5188:	10 92 74 04 	sts	0x0474, r1	; 0x800474 <block_buffer_planned>
    518c:	08 95       	ret

0000518e <plan_reset>:
    518e:	8c e1       	ldi	r24, 0x1C	; 28
    5190:	e8 e5       	ldi	r30, 0x58	; 88
    5192:	f4 e0       	ldi	r31, 0x04	; 4
    5194:	df 01       	movw	r26, r30
    5196:	1d 92       	st	X+, r1
    5198:	8a 95       	dec	r24
    519a:	e9 f7       	brne	.-6      	; 0x5196 <plan_reset+0x8>
    519c:	ee cf       	rjmp	.-36     	; 0x517a <plan_reset_buffer>
    519e:	08 95       	ret

000051a0 <plan_discard_current_block>:
    51a0:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    51a4:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <block_buffer_head>
    51a8:	98 17       	cp	r25, r24
    51aa:	69 f0       	breq	.+26     	; 0x51c6 <plan_discard_current_block+0x26>
    51ac:	91 e0       	ldi	r25, 0x01	; 1
    51ae:	98 0f       	add	r25, r24
    51b0:	94 32       	cpi	r25, 0x24	; 36
    51b2:	09 f4       	brne	.+2      	; 0x51b6 <plan_discard_current_block+0x16>
    51b4:	90 e0       	ldi	r25, 0x00	; 0
    51b6:	20 91 74 04 	lds	r18, 0x0474	; 0x800474 <block_buffer_planned>
    51ba:	82 13       	cpse	r24, r18
    51bc:	02 c0       	rjmp	.+4      	; 0x51c2 <plan_discard_current_block+0x22>
    51be:	90 93 74 04 	sts	0x0474, r25	; 0x800474 <block_buffer_planned>
    51c2:	90 93 77 04 	sts	0x0477, r25	; 0x800477 <block_buffer_tail>
    51c6:	08 95       	ret

000051c8 <plan_get_system_motion_block>:
    51c8:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <block_buffer_head>
    51cc:	26 e3       	ldi	r18, 0x36	; 54
    51ce:	82 9f       	mul	r24, r18
    51d0:	c0 01       	movw	r24, r0
    51d2:	11 24       	eor	r1, r1
    51d4:	88 58       	subi	r24, 0x88	; 136
    51d6:	9b 4f       	sbci	r25, 0xFB	; 251
    51d8:	08 95       	ret

000051da <plan_get_current_block>:
    51da:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    51de:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <block_buffer_head>
    51e2:	98 17       	cp	r25, r24
    51e4:	39 f0       	breq	.+14     	; 0x51f4 <plan_get_current_block+0x1a>
    51e6:	26 e3       	ldi	r18, 0x36	; 54
    51e8:	82 9f       	mul	r24, r18
    51ea:	c0 01       	movw	r24, r0
    51ec:	11 24       	eor	r1, r1
    51ee:	88 58       	subi	r24, 0x88	; 136
    51f0:	9b 4f       	sbci	r25, 0xFB	; 251
    51f2:	08 95       	ret
    51f4:	80 e0       	ldi	r24, 0x00	; 0
    51f6:	90 e0       	ldi	r25, 0x00	; 0
    51f8:	08 95       	ret

000051fa <plan_get_exec_block_exit_speed_sqr>:
    51fa:	e0 91 77 04 	lds	r30, 0x0477	; 0x800477 <block_buffer_tail>
    51fe:	ef 5f       	subi	r30, 0xFF	; 255
    5200:	e4 32       	cpi	r30, 0x24	; 36
    5202:	09 f4       	brne	.+2      	; 0x5206 <plan_get_exec_block_exit_speed_sqr+0xc>
    5204:	e0 e0       	ldi	r30, 0x00	; 0
    5206:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <block_buffer_head>
    520a:	8e 17       	cp	r24, r30
    520c:	59 f0       	breq	.+22     	; 0x5224 <plan_get_exec_block_exit_speed_sqr+0x2a>
    520e:	86 e3       	ldi	r24, 0x36	; 54
    5210:	e8 9f       	mul	r30, r24
    5212:	f0 01       	movw	r30, r0
    5214:	11 24       	eor	r1, r1
    5216:	e8 58       	subi	r30, 0x88	; 136
    5218:	fb 4f       	sbci	r31, 0xFB	; 251
    521a:	66 89       	ldd	r22, Z+22	; 0x16
    521c:	77 89       	ldd	r23, Z+23	; 0x17
    521e:	80 8d       	ldd	r24, Z+24	; 0x18
    5220:	91 8d       	ldd	r25, Z+25	; 0x19
    5222:	08 95       	ret
    5224:	60 e0       	ldi	r22, 0x00	; 0
    5226:	70 e0       	ldi	r23, 0x00	; 0
    5228:	cb 01       	movw	r24, r22
    522a:	08 95       	ret

0000522c <plan_check_full_buffer>:
    522c:	81 e0       	ldi	r24, 0x01	; 1
    522e:	20 91 77 04 	lds	r18, 0x0477	; 0x800477 <block_buffer_tail>
    5232:	90 91 75 04 	lds	r25, 0x0475	; 0x800475 <next_buffer_head>
    5236:	29 13       	cpse	r18, r25
    5238:	80 e0       	ldi	r24, 0x00	; 0
    523a:	08 95       	ret

0000523c <plan_compute_profile_nominal_speed>:
    523c:	af 92       	push	r10
    523e:	bf 92       	push	r11
    5240:	cf 92       	push	r12
    5242:	df 92       	push	r13
    5244:	ef 92       	push	r14
    5246:	ff 92       	push	r15
    5248:	0f 93       	push	r16
    524a:	1f 93       	push	r17
    524c:	cf 93       	push	r28
    524e:	df 93       	push	r29
    5250:	ec 01       	movw	r28, r24
    5252:	1e a5       	ldd	r17, Y+46	; 0x2e
    5254:	af a4       	ldd	r10, Y+47	; 0x2f
    5256:	e8 a8       	ldd	r14, Y+48	; 0x30
    5258:	09 a9       	ldd	r16, Y+49	; 0x31
    525a:	89 89       	ldd	r24, Y+17	; 0x11
    525c:	80 ff       	sbrs	r24, 0
    525e:	1a c0       	rjmp	.+52     	; 0x5294 <plan_compute_profile_nominal_speed+0x58>
    5260:	60 91 1e 0c 	lds	r22, 0x0C1E	; 0x800c1e <sys+0x8>
    5264:	70 e0       	ldi	r23, 0x00	; 0
    5266:	80 e0       	ldi	r24, 0x00	; 0
    5268:	90 e0       	ldi	r25, 0x00	; 0
    526a:	0e 94 67 3f 	call	0x7ece	; 0x7ece <__floatsisf>
    526e:	2a e0       	ldi	r18, 0x0A	; 10
    5270:	37 ed       	ldi	r19, 0xD7	; 215
    5272:	43 e2       	ldi	r20, 0x23	; 35
    5274:	5c e3       	ldi	r21, 0x3C	; 60
    5276:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    527a:	9b 01       	movw	r18, r22
    527c:	ac 01       	movw	r20, r24
    527e:	61 2f       	mov	r22, r17
    5280:	7a 2d       	mov	r23, r10
    5282:	8e 2d       	mov	r24, r14
    5284:	90 2f       	mov	r25, r16
    5286:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    528a:	16 2f       	mov	r17, r22
    528c:	a7 2e       	mov	r10, r23
    528e:	e8 2e       	mov	r14, r24
    5290:	09 2f       	mov	r16, r25
    5292:	2f c0       	rjmp	.+94     	; 0x52f2 <plan_compute_profile_nominal_speed+0xb6>
    5294:	82 fd       	sbrc	r24, 2
    5296:	19 c0       	rjmp	.+50     	; 0x52ca <plan_compute_profile_nominal_speed+0x8e>
    5298:	60 91 1d 0c 	lds	r22, 0x0C1D	; 0x800c1d <sys+0x7>
    529c:	70 e0       	ldi	r23, 0x00	; 0
    529e:	80 e0       	ldi	r24, 0x00	; 0
    52a0:	90 e0       	ldi	r25, 0x00	; 0
    52a2:	0e 94 67 3f 	call	0x7ece	; 0x7ece <__floatsisf>
    52a6:	2a e0       	ldi	r18, 0x0A	; 10
    52a8:	37 ed       	ldi	r19, 0xD7	; 215
    52aa:	43 e2       	ldi	r20, 0x23	; 35
    52ac:	5c e3       	ldi	r21, 0x3C	; 60
    52ae:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    52b2:	9b 01       	movw	r18, r22
    52b4:	ac 01       	movw	r20, r24
    52b6:	61 2f       	mov	r22, r17
    52b8:	7a 2d       	mov	r23, r10
    52ba:	8e 2d       	mov	r24, r14
    52bc:	90 2f       	mov	r25, r16
    52be:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    52c2:	16 2f       	mov	r17, r22
    52c4:	a7 2e       	mov	r10, r23
    52c6:	e8 2e       	mov	r14, r24
    52c8:	09 2f       	mov	r16, r25
    52ca:	ba a4       	ldd	r11, Y+42	; 0x2a
    52cc:	cb a4       	ldd	r12, Y+43	; 0x2b
    52ce:	dc a4       	ldd	r13, Y+44	; 0x2c
    52d0:	fd a4       	ldd	r15, Y+45	; 0x2d
    52d2:	2b 2d       	mov	r18, r11
    52d4:	3c 2d       	mov	r19, r12
    52d6:	4d 2d       	mov	r20, r13
    52d8:	5f 2d       	mov	r21, r15
    52da:	61 2f       	mov	r22, r17
    52dc:	7a 2d       	mov	r23, r10
    52de:	8e 2d       	mov	r24, r14
    52e0:	90 2f       	mov	r25, r16
    52e2:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    52e6:	18 16       	cp	r1, r24
    52e8:	24 f4       	brge	.+8      	; 0x52f2 <plan_compute_profile_nominal_speed+0xb6>
    52ea:	1b 2d       	mov	r17, r11
    52ec:	ac 2c       	mov	r10, r12
    52ee:	ed 2c       	mov	r14, r13
    52f0:	0f 2d       	mov	r16, r15
    52f2:	20 e0       	ldi	r18, 0x00	; 0
    52f4:	30 e0       	ldi	r19, 0x00	; 0
    52f6:	40 e8       	ldi	r20, 0x80	; 128
    52f8:	5f e3       	ldi	r21, 0x3F	; 63
    52fa:	61 2f       	mov	r22, r17
    52fc:	7a 2d       	mov	r23, r10
    52fe:	8e 2d       	mov	r24, r14
    5300:	90 2f       	mov	r25, r16
    5302:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    5306:	18 16       	cp	r1, r24
    5308:	1c f4       	brge	.+6      	; 0x5310 <plan_compute_profile_nominal_speed+0xd4>
    530a:	da 2d       	mov	r29, r10
    530c:	ce 2d       	mov	r28, r14
    530e:	04 c0       	rjmp	.+8      	; 0x5318 <plan_compute_profile_nominal_speed+0xdc>
    5310:	10 e0       	ldi	r17, 0x00	; 0
    5312:	d0 e0       	ldi	r29, 0x00	; 0
    5314:	c0 e8       	ldi	r28, 0x80	; 128
    5316:	0f e3       	ldi	r16, 0x3F	; 63
    5318:	61 2f       	mov	r22, r17
    531a:	7d 2f       	mov	r23, r29
    531c:	8c 2f       	mov	r24, r28
    531e:	90 2f       	mov	r25, r16
    5320:	df 91       	pop	r29
    5322:	cf 91       	pop	r28
    5324:	1f 91       	pop	r17
    5326:	0f 91       	pop	r16
    5328:	ff 90       	pop	r15
    532a:	ef 90       	pop	r14
    532c:	df 90       	pop	r13
    532e:	cf 90       	pop	r12
    5330:	bf 90       	pop	r11
    5332:	af 90       	pop	r10
    5334:	08 95       	ret

00005336 <plan_update_velocity_profile_parameters>:
    5336:	5f 92       	push	r5
    5338:	6f 92       	push	r6
    533a:	7f 92       	push	r7
    533c:	8f 92       	push	r8
    533e:	9f 92       	push	r9
    5340:	af 92       	push	r10
    5342:	bf 92       	push	r11
    5344:	cf 92       	push	r12
    5346:	df 92       	push	r13
    5348:	ef 92       	push	r14
    534a:	ff 92       	push	r15
    534c:	0f 93       	push	r16
    534e:	1f 93       	push	r17
    5350:	cf 93       	push	r28
    5352:	df 93       	push	r29
    5354:	10 91 77 04 	lds	r17, 0x0477	; 0x800477 <block_buffer_tail>
    5358:	50 90 76 04 	lds	r5, 0x0476	; 0x800476 <block_buffer_head>
    535c:	0f 2e       	mov	r0, r31
    535e:	f9 e9       	ldi	r31, 0x99	; 153
    5360:	9f 2e       	mov	r9, r31
    5362:	f0 2d       	mov	r31, r0
    5364:	0f 2e       	mov	r0, r31
    5366:	f6 e7       	ldi	r31, 0x76	; 118
    5368:	8f 2e       	mov	r8, r31
    536a:	f0 2d       	mov	r31, r0
    536c:	0f 2e       	mov	r0, r31
    536e:	f6 e9       	ldi	r31, 0x96	; 150
    5370:	7f 2e       	mov	r7, r31
    5372:	f0 2d       	mov	r31, r0
    5374:	0f 2e       	mov	r0, r31
    5376:	fe e7       	ldi	r31, 0x7E	; 126
    5378:	6f 2e       	mov	r6, r31
    537a:	f0 2d       	mov	r31, r0
    537c:	0f 2e       	mov	r0, r31
    537e:	f6 e3       	ldi	r31, 0x36	; 54
    5380:	cf 2e       	mov	r12, r31
    5382:	f0 2d       	mov	r31, r0
    5384:	73 c0       	rjmp	.+230    	; 0x546c <plan_update_velocity_profile_parameters+0x136>
    5386:	c1 2f       	mov	r28, r17
    5388:	d0 e0       	ldi	r29, 0x00	; 0
    538a:	cc 9e       	mul	r12, r28
    538c:	c0 01       	movw	r24, r0
    538e:	cd 9e       	mul	r12, r29
    5390:	90 0d       	add	r25, r0
    5392:	11 24       	eor	r1, r1
    5394:	88 58       	subi	r24, 0x88	; 136
    5396:	9b 4f       	sbci	r25, 0xFB	; 251
    5398:	51 df       	rcall	.-350    	; 0x523c <plan_compute_profile_nominal_speed>
    539a:	06 2f       	mov	r16, r22
    539c:	f7 2e       	mov	r15, r23
    539e:	e8 2e       	mov	r14, r24
    53a0:	d9 2e       	mov	r13, r25
    53a2:	26 2f       	mov	r18, r22
    53a4:	37 2f       	mov	r19, r23
    53a6:	48 2f       	mov	r20, r24
    53a8:	59 2f       	mov	r21, r25
    53aa:	69 2d       	mov	r22, r9
    53ac:	78 2d       	mov	r23, r8
    53ae:	87 2d       	mov	r24, r7
    53b0:	96 2d       	mov	r25, r6
    53b2:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    53b6:	88 23       	and	r24, r24
    53b8:	cc f4       	brge	.+50     	; 0x53ec <plan_update_velocity_profile_parameters+0xb6>
    53ba:	cc 9e       	mul	r12, r28
    53bc:	c0 01       	movw	r24, r0
    53be:	cd 9e       	mul	r12, r29
    53c0:	90 0d       	add	r25, r0
    53c2:	11 24       	eor	r1, r1
    53c4:	9c 01       	movw	r18, r24
    53c6:	28 58       	subi	r18, 0x88	; 136
    53c8:	3b 4f       	sbci	r19, 0xFB	; 251
    53ca:	59 01       	movw	r10, r18
    53cc:	29 2d       	mov	r18, r9
    53ce:	38 2d       	mov	r19, r8
    53d0:	47 2d       	mov	r20, r7
    53d2:	56 2d       	mov	r21, r6
    53d4:	69 2d       	mov	r22, r9
    53d6:	78 2d       	mov	r23, r8
    53d8:	87 2d       	mov	r24, r7
    53da:	96 2d       	mov	r25, r6
    53dc:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    53e0:	f5 01       	movw	r30, r10
    53e2:	62 8f       	std	Z+26, r22	; 0x1a
    53e4:	73 8f       	std	Z+27, r23	; 0x1b
    53e6:	84 8f       	std	Z+28, r24	; 0x1c
    53e8:	95 8f       	std	Z+29, r25	; 0x1d
    53ea:	18 c0       	rjmp	.+48     	; 0x541c <plan_update_velocity_profile_parameters+0xe6>
    53ec:	cc 9e       	mul	r12, r28
    53ee:	c0 01       	movw	r24, r0
    53f0:	cd 9e       	mul	r12, r29
    53f2:	90 0d       	add	r25, r0
    53f4:	11 24       	eor	r1, r1
    53f6:	9c 01       	movw	r18, r24
    53f8:	28 58       	subi	r18, 0x88	; 136
    53fa:	3b 4f       	sbci	r19, 0xFB	; 251
    53fc:	59 01       	movw	r10, r18
    53fe:	20 2f       	mov	r18, r16
    5400:	3f 2d       	mov	r19, r15
    5402:	4e 2d       	mov	r20, r14
    5404:	5d 2d       	mov	r21, r13
    5406:	60 2f       	mov	r22, r16
    5408:	7f 2d       	mov	r23, r15
    540a:	8e 2d       	mov	r24, r14
    540c:	9d 2d       	mov	r25, r13
    540e:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    5412:	f5 01       	movw	r30, r10
    5414:	62 8f       	std	Z+26, r22	; 0x1a
    5416:	73 8f       	std	Z+27, r23	; 0x1b
    5418:	84 8f       	std	Z+28, r24	; 0x1c
    541a:	95 8f       	std	Z+29, r25	; 0x1d
    541c:	cc 9e       	mul	r12, r28
    541e:	f0 01       	movw	r30, r0
    5420:	cd 9e       	mul	r12, r29
    5422:	f0 0d       	add	r31, r0
    5424:	11 24       	eor	r1, r1
    5426:	e8 58       	subi	r30, 0x88	; 136
    5428:	fb 4f       	sbci	r31, 0xFB	; 251
    542a:	86 a0       	ldd	r8, Z+38	; 0x26
    542c:	97 a0       	ldd	r9, Z+39	; 0x27
    542e:	a0 a4       	ldd	r10, Z+40	; 0x28
    5430:	b1 a4       	ldd	r11, Z+41	; 0x29
    5432:	a5 01       	movw	r20, r10
    5434:	94 01       	movw	r18, r8
    5436:	62 8d       	ldd	r22, Z+26	; 0x1a
    5438:	73 8d       	ldd	r23, Z+27	; 0x1b
    543a:	84 8d       	ldd	r24, Z+28	; 0x1c
    543c:	95 8d       	ldd	r25, Z+29	; 0x1d
    543e:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    5442:	18 16       	cp	r1, r24
    5444:	5c f4       	brge	.+22     	; 0x545c <plan_update_velocity_profile_parameters+0x126>
    5446:	cc 9e       	mul	r12, r28
    5448:	f0 01       	movw	r30, r0
    544a:	cd 9e       	mul	r12, r29
    544c:	f0 0d       	add	r31, r0
    544e:	11 24       	eor	r1, r1
    5450:	e8 58       	subi	r30, 0x88	; 136
    5452:	fb 4f       	sbci	r31, 0xFB	; 251
    5454:	82 8e       	std	Z+26, r8	; 0x1a
    5456:	93 8e       	std	Z+27, r9	; 0x1b
    5458:	a4 8e       	std	Z+28, r10	; 0x1c
    545a:	b5 8e       	std	Z+29, r11	; 0x1d
    545c:	1f 5f       	subi	r17, 0xFF	; 255
    545e:	14 32       	cpi	r17, 0x24	; 36
    5460:	09 f4       	brne	.+2      	; 0x5464 <plan_update_velocity_profile_parameters+0x12e>
    5462:	10 e0       	ldi	r17, 0x00	; 0
    5464:	90 2e       	mov	r9, r16
    5466:	8f 2c       	mov	r8, r15
    5468:	7e 2c       	mov	r7, r14
    546a:	6d 2c       	mov	r6, r13
    546c:	15 11       	cpse	r17, r5
    546e:	8b cf       	rjmp	.-234    	; 0x5386 <plan_update_velocity_profile_parameters+0x50>
    5470:	89 2d       	mov	r24, r9
    5472:	98 2d       	mov	r25, r8
    5474:	a7 2d       	mov	r26, r7
    5476:	b6 2d       	mov	r27, r6
    5478:	80 93 70 04 	sts	0x0470, r24	; 0x800470 <pl+0x18>
    547c:	90 93 71 04 	sts	0x0471, r25	; 0x800471 <pl+0x19>
    5480:	a0 93 72 04 	sts	0x0472, r26	; 0x800472 <pl+0x1a>
    5484:	b0 93 73 04 	sts	0x0473, r27	; 0x800473 <pl+0x1b>
    5488:	df 91       	pop	r29
    548a:	cf 91       	pop	r28
    548c:	1f 91       	pop	r17
    548e:	0f 91       	pop	r16
    5490:	ff 90       	pop	r15
    5492:	ef 90       	pop	r14
    5494:	df 90       	pop	r13
    5496:	cf 90       	pop	r12
    5498:	bf 90       	pop	r11
    549a:	af 90       	pop	r10
    549c:	9f 90       	pop	r9
    549e:	8f 90       	pop	r8
    54a0:	7f 90       	pop	r7
    54a2:	6f 90       	pop	r6
    54a4:	5f 90       	pop	r5
    54a6:	08 95       	ret

000054a8 <plan_buffer_line>:
    54a8:	2f 92       	push	r2
    54aa:	3f 92       	push	r3
    54ac:	4f 92       	push	r4
    54ae:	5f 92       	push	r5
    54b0:	6f 92       	push	r6
    54b2:	7f 92       	push	r7
    54b4:	8f 92       	push	r8
    54b6:	9f 92       	push	r9
    54b8:	af 92       	push	r10
    54ba:	bf 92       	push	r11
    54bc:	cf 92       	push	r12
    54be:	df 92       	push	r13
    54c0:	ef 92       	push	r14
    54c2:	ff 92       	push	r15
    54c4:	0f 93       	push	r16
    54c6:	1f 93       	push	r17
    54c8:	cf 93       	push	r28
    54ca:	df 93       	push	r29
    54cc:	cd b7       	in	r28, 0x3d	; 61
    54ce:	de b7       	in	r29, 0x3e	; 62
    54d0:	c6 54       	subi	r28, 0x46	; 70
    54d2:	d1 09       	sbc	r29, r1
    54d4:	0f b6       	in	r0, 0x3f	; 63
    54d6:	f8 94       	cli
    54d8:	de bf       	out	0x3e, r29	; 62
    54da:	0f be       	out	0x3f, r0	; 63
    54dc:	cd bf       	out	0x3d, r28	; 61
    54de:	23 96       	adiw	r28, 0x03	; 3
    54e0:	7f af       	std	Y+63, r23	; 0x3f
    54e2:	6e af       	std	Y+62, r22	; 0x3e
    54e4:	23 97       	sbiw	r28, 0x03	; 3
    54e6:	20 90 76 04 	lds	r2, 0x0476	; 0x800476 <block_buffer_head>
    54ea:	a2 2c       	mov	r10, r2
    54ec:	b1 2c       	mov	r11, r1
    54ee:	26 e3       	ldi	r18, 0x36	; 54
    54f0:	2a 9d       	mul	r18, r10
    54f2:	a0 01       	movw	r20, r0
    54f4:	2b 9d       	mul	r18, r11
    54f6:	50 0d       	add	r21, r0
    54f8:	11 24       	eor	r1, r1
    54fa:	ba 01       	movw	r22, r20
    54fc:	68 58       	subi	r22, 0x88	; 136
    54fe:	7b 4f       	sbci	r23, 0xFB	; 251
    5500:	21 96       	adiw	r28, 0x01	; 1
    5502:	7f af       	std	Y+63, r23	; 0x3f
    5504:	6e af       	std	Y+62, r22	; 0x3e
    5506:	21 97       	sbiw	r28, 0x01	; 1
    5508:	fb 01       	movw	r30, r22
    550a:	11 92       	st	Z+, r1
    550c:	2a 95       	dec	r18
    550e:	e9 f7       	brne	.-6      	; 0x550a <plan_buffer_line+0x62>
    5510:	23 96       	adiw	r28, 0x03	; 3
    5512:	ee ad       	ldd	r30, Y+62	; 0x3e
    5514:	ff ad       	ldd	r31, Y+63	; 0x3f
    5516:	23 97       	sbiw	r28, 0x03	; 3
    5518:	24 85       	ldd	r18, Z+12	; 0x0c
    551a:	fb 01       	movw	r30, r22
    551c:	21 8b       	std	Z+17, r18	; 0x11
    551e:	23 96       	adiw	r28, 0x03	; 3
    5520:	ee ad       	ldd	r30, Y+62	; 0x3e
    5522:	ff ad       	ldd	r31, Y+63	; 0x3f
    5524:	23 97       	sbiw	r28, 0x03	; 3
    5526:	44 81       	ldd	r20, Z+4	; 0x04
    5528:	55 81       	ldd	r21, Z+5	; 0x05
    552a:	66 81       	ldd	r22, Z+6	; 0x06
    552c:	77 81       	ldd	r23, Z+7	; 0x07
    552e:	21 96       	adiw	r28, 0x01	; 1
    5530:	ee ad       	ldd	r30, Y+62	; 0x3e
    5532:	ff ad       	ldd	r31, Y+63	; 0x3f
    5534:	21 97       	sbiw	r28, 0x01	; 1
    5536:	42 ab       	std	Z+50, r20	; 0x32
    5538:	53 ab       	std	Z+51, r21	; 0x33
    553a:	64 ab       	std	Z+52, r22	; 0x34
    553c:	75 ab       	std	Z+53, r23	; 0x35
    553e:	23 96       	adiw	r28, 0x03	; 3
    5540:	ee ad       	ldd	r30, Y+62	; 0x3e
    5542:	ff ad       	ldd	r31, Y+63	; 0x3f
    5544:	23 97       	sbiw	r28, 0x03	; 3
    5546:	40 85       	ldd	r20, Z+8	; 0x08
    5548:	51 85       	ldd	r21, Z+9	; 0x09
    554a:	62 85       	ldd	r22, Z+10	; 0x0a
    554c:	73 85       	ldd	r23, Z+11	; 0x0b
    554e:	21 96       	adiw	r28, 0x01	; 1
    5550:	ee ad       	ldd	r30, Y+62	; 0x3e
    5552:	ff ad       	ldd	r31, Y+63	; 0x3f
    5554:	21 97       	sbiw	r28, 0x01	; 1
    5556:	42 8b       	std	Z+18, r20	; 0x12
    5558:	53 8b       	std	Z+19, r21	; 0x13
    555a:	64 8b       	std	Z+20, r22	; 0x14
    555c:	75 8b       	std	Z+21, r23	; 0x15
    555e:	21 ff       	sbrs	r18, 1
    5560:	0a c0       	rjmp	.+20     	; 0x5576 <plan_buffer_line+0xce>
    5562:	2c e0       	ldi	r18, 0x0C	; 12
    5564:	e7 e3       	ldi	r30, 0x37	; 55
    5566:	fc e0       	ldi	r31, 0x0C	; 12
    5568:	de 01       	movw	r26, r28
    556a:	1d 96       	adiw	r26, 0x0d	; 13
    556c:	01 90       	ld	r0, Z+
    556e:	0d 92       	st	X+, r0
    5570:	2a 95       	dec	r18
    5572:	e1 f7       	brne	.-8      	; 0x556c <plan_buffer_line+0xc4>
    5574:	65 c2       	rjmp	.+1226   	; 0x5a40 <plan_buffer_line+0x598>
    5576:	2c e0       	ldi	r18, 0x0C	; 12
    5578:	e8 e5       	ldi	r30, 0x58	; 88
    557a:	f4 e0       	ldi	r31, 0x04	; 4
    557c:	de 01       	movw	r26, r28
    557e:	1d 96       	adiw	r26, 0x0d	; 13
    5580:	01 90       	ld	r0, Z+
    5582:	0d 92       	st	X+, r0
    5584:	2a 95       	dec	r18
    5586:	e1 f7       	brne	.-8      	; 0x5580 <plan_buffer_line+0xd8>
    5588:	5b c2       	rjmp	.+1206   	; 0x5a40 <plan_buffer_line+0x598>
    558a:	e9 ad       	ldd	r30, Y+57	; 0x39
    558c:	fa ad       	ldd	r31, Y+58	; 0x3a
    558e:	61 91       	ld	r22, Z+
    5590:	71 91       	ld	r23, Z+
    5592:	81 91       	ld	r24, Z+
    5594:	91 91       	ld	r25, Z+
    5596:	fa af       	std	Y+58, r31	; 0x3a
    5598:	e9 af       	std	Y+57, r30	; 0x39
    559a:	eb ad       	ldd	r30, Y+59	; 0x3b
    559c:	fc ad       	ldd	r31, Y+60	; 0x3c
    559e:	21 91       	ld	r18, Z+
    55a0:	31 91       	ld	r19, Z+
    55a2:	41 91       	ld	r20, Z+
    55a4:	51 91       	ld	r21, Z+
    55a6:	fc af       	std	Y+60, r31	; 0x3c
    55a8:	eb af       	std	Y+59, r30	; 0x3b
    55aa:	2d ab       	std	Y+53, r18	; 0x35
    55ac:	3e ab       	std	Y+54, r19	; 0x36
    55ae:	4f ab       	std	Y+55, r20	; 0x37
    55b0:	58 af       	std	Y+56, r21	; 0x38
    55b2:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    55b6:	0e 94 d3 40 	call	0x81a6	; 0x81a6 <lround>
    55ba:	f4 01       	movw	r30, r8
    55bc:	61 93       	st	Z+, r22
    55be:	71 93       	st	Z+, r23
    55c0:	81 93       	st	Z+, r24
    55c2:	91 93       	st	Z+, r25
    55c4:	4f 01       	movw	r8, r30
    55c6:	f6 01       	movw	r30, r12
    55c8:	01 91       	ld	r16, Z+
    55ca:	11 91       	ld	r17, Z+
    55cc:	21 91       	ld	r18, Z+
    55ce:	31 91       	ld	r19, Z+
    55d0:	6f 01       	movw	r12, r30
    55d2:	60 1b       	sub	r22, r16
    55d4:	71 0b       	sbc	r23, r17
    55d6:	82 0b       	sbc	r24, r18
    55d8:	93 0b       	sbc	r25, r19
    55da:	8b 01       	movw	r16, r22
    55dc:	9c 01       	movw	r18, r24
    55de:	3a f4       	brpl	.+14     	; 0x55ee <plan_buffer_line+0x146>
    55e0:	00 27       	eor	r16, r16
    55e2:	11 27       	eor	r17, r17
    55e4:	98 01       	movw	r18, r16
    55e6:	06 1b       	sub	r16, r22
    55e8:	17 0b       	sbc	r17, r23
    55ea:	28 0b       	sbc	r18, r24
    55ec:	39 0b       	sbc	r19, r25
    55ee:	f1 01       	movw	r30, r2
    55f0:	01 93       	st	Z+, r16
    55f2:	11 93       	st	Z+, r17
    55f4:	21 93       	st	Z+, r18
    55f6:	31 93       	st	Z+, r19
    55f8:	1f 01       	movw	r2, r30
    55fa:	f7 01       	movw	r30, r14
    55fc:	40 80       	ld	r4, Z
    55fe:	51 80       	ldd	r5, Z+1	; 0x01
    5600:	62 80       	ldd	r6, Z+2	; 0x02
    5602:	73 80       	ldd	r7, Z+3	; 0x03
    5604:	40 16       	cp	r4, r16
    5606:	51 06       	cpc	r5, r17
    5608:	62 06       	cpc	r6, r18
    560a:	73 06       	cpc	r7, r19
    560c:	10 f4       	brcc	.+4      	; 0x5612 <plan_buffer_line+0x16a>
    560e:	28 01       	movw	r4, r16
    5610:	39 01       	movw	r6, r18
    5612:	f7 01       	movw	r30, r14
    5614:	40 82       	st	Z, r4
    5616:	51 82       	std	Z+1, r5	; 0x01
    5618:	62 82       	std	Z+2, r6	; 0x02
    561a:	73 82       	std	Z+3, r7	; 0x03
    561c:	0e 94 67 3f 	call	0x7ece	; 0x7ece <__floatsisf>
    5620:	2d a9       	ldd	r18, Y+53	; 0x35
    5622:	3e a9       	ldd	r19, Y+54	; 0x36
    5624:	4f a9       	ldd	r20, Y+55	; 0x37
    5626:	58 ad       	ldd	r21, Y+56	; 0x38
    5628:	0e 94 cc 3e 	call	0x7d98	; 0x7d98 <__divsf3>
    562c:	ed ad       	ldd	r30, Y+61	; 0x3d
    562e:	fe ad       	ldd	r31, Y+62	; 0x3e
    5630:	61 93       	st	Z+, r22
    5632:	71 93       	st	Z+, r23
    5634:	81 93       	st	Z+, r24
    5636:	91 93       	st	Z+, r25
    5638:	fe af       	std	Y+62, r31	; 0x3e
    563a:	ed af       	std	Y+61, r30	; 0x3d
    563c:	20 e0       	ldi	r18, 0x00	; 0
    563e:	30 e0       	ldi	r19, 0x00	; 0
    5640:	a9 01       	movw	r20, r18
    5642:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    5646:	88 23       	and	r24, r24
    5648:	4c f4       	brge	.+18     	; 0x565c <plan_buffer_line+0x1b4>
    564a:	89 a9       	ldd	r24, Y+49	; 0x31
    564c:	1c dc       	rcall	.-1992   	; 0x4e86 <get_direction_pin_mask>
    564e:	27 96       	adiw	r28, 0x07	; 7
    5650:	ee ad       	ldd	r30, Y+62	; 0x3e
    5652:	ff ad       	ldd	r31, Y+63	; 0x3f
    5654:	27 97       	sbiw	r28, 0x07	; 7
    5656:	90 81       	ld	r25, Z
    5658:	89 2b       	or	r24, r25
    565a:	80 83       	st	Z, r24
    565c:	f9 a9       	ldd	r31, Y+49	; 0x31
    565e:	ff 5f       	subi	r31, 0xFF	; 255
    5660:	f9 ab       	std	Y+49, r31	; 0x31
    5662:	f3 30       	cpi	r31, 0x03	; 3
    5664:	09 f0       	breq	.+2      	; 0x5668 <plan_buffer_line+0x1c0>
    5666:	91 cf       	rjmp	.-222    	; 0x558a <plan_buffer_line+0xe2>
    5668:	86 e3       	ldi	r24, 0x36	; 54
    566a:	8a 9d       	mul	r24, r10
    566c:	f0 01       	movw	r30, r0
    566e:	8b 9d       	mul	r24, r11
    5670:	f0 0d       	add	r31, r0
    5672:	11 24       	eor	r1, r1
    5674:	e8 58       	subi	r30, 0x88	; 136
    5676:	fb 4f       	sbci	r31, 0xFB	; 251
    5678:	84 85       	ldd	r24, Z+12	; 0x0c
    567a:	95 85       	ldd	r25, Z+13	; 0x0d
    567c:	a6 85       	ldd	r26, Z+14	; 0x0e
    567e:	b7 85       	ldd	r27, Z+15	; 0x0f
    5680:	89 2b       	or	r24, r25
    5682:	8a 2b       	or	r24, r26
    5684:	8b 2b       	or	r24, r27
    5686:	09 f4       	brne	.+2      	; 0x568a <plan_buffer_line+0x1e2>
    5688:	d7 c1       	rjmp	.+942    	; 0x5a38 <plan_buffer_line+0x590>
    568a:	ce 01       	movw	r24, r28
    568c:	49 96       	adiw	r24, 0x19	; 25
    568e:	8e d3       	rcall	.+1820   	; 0x5dac <convert_delta_vector_to_unit_vector>
    5690:	26 e3       	ldi	r18, 0x36	; 54
    5692:	2a 9d       	mul	r18, r10
    5694:	80 01       	movw	r16, r0
    5696:	2b 9d       	mul	r18, r11
    5698:	10 0d       	add	r17, r0
    569a:	11 24       	eor	r1, r1
    569c:	08 58       	subi	r16, 0x88	; 136
    569e:	1b 4f       	sbci	r17, 0xFB	; 251
    56a0:	f8 01       	movw	r30, r16
    56a2:	62 a3       	std	Z+34, r22	; 0x22
    56a4:	73 a3       	std	Z+35, r23	; 0x23
    56a6:	84 a3       	std	Z+36, r24	; 0x24
    56a8:	95 a3       	std	Z+37, r25	; 0x25
    56aa:	be 01       	movw	r22, r28
    56ac:	67 5e       	subi	r22, 0xE7	; 231
    56ae:	7f 4f       	sbci	r23, 0xFF	; 255
    56b0:	88 ed       	ldi	r24, 0xD8	; 216
    56b2:	9e e0       	ldi	r25, 0x0E	; 14
    56b4:	e2 d3       	rcall	.+1988   	; 0x5e7a <limit_value_by_axis_maximum>
    56b6:	f8 01       	movw	r30, r16
    56b8:	66 8f       	std	Z+30, r22	; 0x1e
    56ba:	77 8f       	std	Z+31, r23	; 0x1f
    56bc:	80 a3       	std	Z+32, r24	; 0x20
    56be:	91 a3       	std	Z+33, r25	; 0x21
    56c0:	be 01       	movw	r22, r28
    56c2:	67 5e       	subi	r22, 0xE7	; 231
    56c4:	7f 4f       	sbci	r23, 0xFF	; 255
    56c6:	8c ec       	ldi	r24, 0xCC	; 204
    56c8:	9e e0       	ldi	r25, 0x0E	; 14
    56ca:	d7 d3       	rcall	.+1966   	; 0x5e7a <limit_value_by_axis_maximum>
    56cc:	f8 01       	movw	r30, r16
    56ce:	62 a7       	std	Z+42, r22	; 0x2a
    56d0:	73 a7       	std	Z+43, r23	; 0x2b
    56d2:	84 a7       	std	Z+44, r24	; 0x2c
    56d4:	95 a7       	std	Z+45, r25	; 0x2d
    56d6:	11 89       	ldd	r17, Z+17	; 0x11
    56d8:	10 ff       	sbrs	r17, 0
    56da:	0d c0       	rjmp	.+26     	; 0x56f6 <plan_buffer_line+0x24e>
    56dc:	26 e3       	ldi	r18, 0x36	; 54
    56de:	2a 9d       	mul	r18, r10
    56e0:	f0 01       	movw	r30, r0
    56e2:	2b 9d       	mul	r18, r11
    56e4:	f0 0d       	add	r31, r0
    56e6:	11 24       	eor	r1, r1
    56e8:	e8 58       	subi	r30, 0x88	; 136
    56ea:	fb 4f       	sbci	r31, 0xFB	; 251
    56ec:	66 a7       	std	Z+46, r22	; 0x2e
    56ee:	77 a7       	std	Z+47, r23	; 0x2f
    56f0:	80 ab       	std	Z+48, r24	; 0x30
    56f2:	91 ab       	std	Z+49, r25	; 0x31
    56f4:	22 c0       	rjmp	.+68     	; 0x573a <plan_buffer_line+0x292>
    56f6:	23 96       	adiw	r28, 0x03	; 3
    56f8:	ee ad       	ldd	r30, Y+62	; 0x3e
    56fa:	ff ad       	ldd	r31, Y+63	; 0x3f
    56fc:	23 97       	sbiw	r28, 0x03	; 3
    56fe:	20 81       	ld	r18, Z
    5700:	31 81       	ldd	r19, Z+1	; 0x01
    5702:	42 81       	ldd	r20, Z+2	; 0x02
    5704:	53 81       	ldd	r21, Z+3	; 0x03
    5706:	86 e3       	ldi	r24, 0x36	; 54
    5708:	8a 9d       	mul	r24, r10
    570a:	f0 01       	movw	r30, r0
    570c:	8b 9d       	mul	r24, r11
    570e:	f0 0d       	add	r31, r0
    5710:	11 24       	eor	r1, r1
    5712:	e8 58       	subi	r30, 0x88	; 136
    5714:	fb 4f       	sbci	r31, 0xFB	; 251
    5716:	26 a7       	std	Z+46, r18	; 0x2e
    5718:	37 a7       	std	Z+47, r19	; 0x2f
    571a:	40 ab       	std	Z+48, r20	; 0x30
    571c:	51 ab       	std	Z+49, r21	; 0x31
    571e:	13 ff       	sbrs	r17, 3
    5720:	0c c0       	rjmp	.+24     	; 0x573a <plan_buffer_line+0x292>
    5722:	7f 01       	movw	r14, r30
    5724:	62 a1       	ldd	r22, Z+34	; 0x22
    5726:	73 a1       	ldd	r23, Z+35	; 0x23
    5728:	84 a1       	ldd	r24, Z+36	; 0x24
    572a:	95 a1       	ldd	r25, Z+37	; 0x25
    572c:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    5730:	f7 01       	movw	r30, r14
    5732:	66 a7       	std	Z+46, r22	; 0x2e
    5734:	77 a7       	std	Z+47, r23	; 0x2f
    5736:	80 ab       	std	Z+48, r24	; 0x30
    5738:	91 ab       	std	Z+49, r25	; 0x31
    573a:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <block_buffer_head>
    573e:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    5742:	98 17       	cp	r25, r24
    5744:	11 f0       	breq	.+4      	; 0x574a <plan_buffer_line+0x2a2>
    5746:	11 ff       	sbrs	r17, 1
    5748:	11 c0       	rjmp	.+34     	; 0x576c <plan_buffer_line+0x2c4>
    574a:	86 e3       	ldi	r24, 0x36	; 54
    574c:	8a 9d       	mul	r24, r10
    574e:	f0 01       	movw	r30, r0
    5750:	8b 9d       	mul	r24, r11
    5752:	f0 0d       	add	r31, r0
    5754:	11 24       	eor	r1, r1
    5756:	e8 58       	subi	r30, 0x88	; 136
    5758:	fb 4f       	sbci	r31, 0xFB	; 251
    575a:	16 8a       	std	Z+22, r1	; 0x16
    575c:	17 8a       	std	Z+23, r1	; 0x17
    575e:	10 8e       	std	Z+24, r1	; 0x18
    5760:	11 8e       	std	Z+25, r1	; 0x19
    5762:	16 a2       	std	Z+38, r1	; 0x26
    5764:	17 a2       	std	Z+39, r1	; 0x27
    5766:	10 a6       	std	Z+40, r1	; 0x28
    5768:	11 a6       	std	Z+41, r1	; 0x29
    576a:	d6 c0       	rjmp	.+428    	; 0x5918 <plan_buffer_line+0x470>
    576c:	04 e6       	ldi	r16, 0x64	; 100
    576e:	14 e0       	ldi	r17, 0x04	; 4
    5770:	1e 01       	movw	r2, r28
    5772:	f5 e2       	ldi	r31, 0x25	; 37
    5774:	2f 0e       	add	r2, r31
    5776:	31 1c       	adc	r3, r1
    5778:	41 01       	movw	r8, r2
    577a:	19 aa       	std	Y+49, r1	; 0x31
    577c:	1a aa       	std	Y+50, r1	; 0x32
    577e:	1b aa       	std	Y+51, r1	; 0x33
    5780:	1c aa       	std	Y+52, r1	; 0x34
    5782:	f8 01       	movw	r30, r16
    5784:	c1 90       	ld	r12, Z+
    5786:	d1 90       	ld	r13, Z+
    5788:	e1 90       	ld	r14, Z+
    578a:	f1 90       	ld	r15, Z+
    578c:	8f 01       	movw	r16, r30
    578e:	25 96       	adiw	r28, 0x05	; 5
    5790:	ee ad       	ldd	r30, Y+62	; 0x3e
    5792:	ff ad       	ldd	r31, Y+63	; 0x3f
    5794:	25 97       	sbiw	r28, 0x05	; 5
    5796:	41 90       	ld	r4, Z+
    5798:	51 90       	ld	r5, Z+
    579a:	61 90       	ld	r6, Z+
    579c:	71 90       	ld	r7, Z+
    579e:	25 96       	adiw	r28, 0x05	; 5
    57a0:	ff af       	std	Y+63, r31	; 0x3f
    57a2:	ee af       	std	Y+62, r30	; 0x3e
    57a4:	25 97       	sbiw	r28, 0x05	; 5
    57a6:	a3 01       	movw	r20, r6
    57a8:	92 01       	movw	r18, r4
    57aa:	c7 01       	movw	r24, r14
    57ac:	b6 01       	movw	r22, r12
    57ae:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    57b2:	9b 01       	movw	r18, r22
    57b4:	ac 01       	movw	r20, r24
    57b6:	69 a9       	ldd	r22, Y+49	; 0x31
    57b8:	7a a9       	ldd	r23, Y+50	; 0x32
    57ba:	8b a9       	ldd	r24, Y+51	; 0x33
    57bc:	9c a9       	ldd	r25, Y+52	; 0x34
    57be:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    57c2:	69 ab       	std	Y+49, r22	; 0x31
    57c4:	7a ab       	std	Y+50, r23	; 0x32
    57c6:	8b ab       	std	Y+51, r24	; 0x33
    57c8:	9c ab       	std	Y+52, r25	; 0x34
    57ca:	a7 01       	movw	r20, r14
    57cc:	96 01       	movw	r18, r12
    57ce:	c3 01       	movw	r24, r6
    57d0:	b2 01       	movw	r22, r4
    57d2:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    57d6:	f1 01       	movw	r30, r2
    57d8:	61 93       	st	Z+, r22
    57da:	71 93       	st	Z+, r23
    57dc:	81 93       	st	Z+, r24
    57de:	91 93       	st	Z+, r25
    57e0:	1f 01       	movw	r2, r30
    57e2:	25 96       	adiw	r28, 0x05	; 5
    57e4:	2e ad       	ldd	r18, Y+62	; 0x3e
    57e6:	3f ad       	ldd	r19, Y+63	; 0x3f
    57e8:	25 97       	sbiw	r28, 0x05	; 5
    57ea:	28 15       	cp	r18, r8
    57ec:	39 05       	cpc	r19, r9
    57ee:	49 f6       	brne	.-110    	; 0x5782 <plan_buffer_line+0x2da>
    57f0:	2f ee       	ldi	r18, 0xEF	; 239
    57f2:	3f ef       	ldi	r19, 0xFF	; 255
    57f4:	4f e7       	ldi	r20, 0x7F	; 127
    57f6:	5f e3       	ldi	r21, 0x3F	; 63
    57f8:	69 a9       	ldd	r22, Y+49	; 0x31
    57fa:	7a a9       	ldd	r23, Y+50	; 0x32
    57fc:	8b a9       	ldd	r24, Y+51	; 0x33
    57fe:	9c a9       	ldd	r25, Y+52	; 0x34
    5800:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    5804:	18 16       	cp	r1, r24
    5806:	6c f4       	brge	.+26     	; 0x5822 <plan_buffer_line+0x37a>
    5808:	86 e3       	ldi	r24, 0x36	; 54
    580a:	8a 9d       	mul	r24, r10
    580c:	f0 01       	movw	r30, r0
    580e:	8b 9d       	mul	r24, r11
    5810:	f0 0d       	add	r31, r0
    5812:	11 24       	eor	r1, r1
    5814:	e8 58       	subi	r30, 0x88	; 136
    5816:	fb 4f       	sbci	r31, 0xFB	; 251
    5818:	16 a2       	std	Z+38, r1	; 0x26
    581a:	17 a2       	std	Z+39, r1	; 0x27
    581c:	10 a6       	std	Z+40, r1	; 0x28
    581e:	11 a6       	std	Z+41, r1	; 0x29
    5820:	7b c0       	rjmp	.+246    	; 0x5918 <plan_buffer_line+0x470>
    5822:	2f ee       	ldi	r18, 0xEF	; 239
    5824:	3f ef       	ldi	r19, 0xFF	; 255
    5826:	4f e7       	ldi	r20, 0x7F	; 127
    5828:	5f eb       	ldi	r21, 0xBF	; 191
    582a:	69 a9       	ldd	r22, Y+49	; 0x31
    582c:	7a a9       	ldd	r23, Y+50	; 0x32
    582e:	8b a9       	ldd	r24, Y+51	; 0x33
    5830:	9c a9       	ldd	r25, Y+52	; 0x34
    5832:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    5836:	88 23       	and	r24, r24
    5838:	8c f4       	brge	.+34     	; 0x585c <plan_buffer_line+0x3b4>
    583a:	86 e3       	ldi	r24, 0x36	; 54
    583c:	8a 9d       	mul	r24, r10
    583e:	f0 01       	movw	r30, r0
    5840:	8b 9d       	mul	r24, r11
    5842:	f0 0d       	add	r31, r0
    5844:	11 24       	eor	r1, r1
    5846:	e8 58       	subi	r30, 0x88	; 136
    5848:	fb 4f       	sbci	r31, 0xFB	; 251
    584a:	89 e9       	ldi	r24, 0x99	; 153
    584c:	96 e7       	ldi	r25, 0x76	; 118
    584e:	a6 e9       	ldi	r26, 0x96	; 150
    5850:	be e7       	ldi	r27, 0x7E	; 126
    5852:	86 a3       	std	Z+38, r24	; 0x26
    5854:	97 a3       	std	Z+39, r25	; 0x27
    5856:	a0 a7       	std	Z+40, r26	; 0x28
    5858:	b1 a7       	std	Z+41, r27	; 0x29
    585a:	5e c0       	rjmp	.+188    	; 0x5918 <plan_buffer_line+0x470>
    585c:	ce 01       	movw	r24, r28
    585e:	85 96       	adiw	r24, 0x25	; 37
    5860:	a5 d2       	rcall	.+1354   	; 0x5dac <convert_delta_vector_to_unit_vector>
    5862:	be 01       	movw	r22, r28
    5864:	6b 5d       	subi	r22, 0xDB	; 219
    5866:	7f 4f       	sbci	r23, 0xFF	; 255
    5868:	88 ed       	ldi	r24, 0xD8	; 216
    586a:	9e e0       	ldi	r25, 0x0E	; 14
    586c:	06 d3       	rcall	.+1548   	; 0x5e7a <limit_value_by_axis_maximum>
    586e:	6b 01       	movw	r12, r22
    5870:	7c 01       	movw	r14, r24
    5872:	29 a9       	ldd	r18, Y+49	; 0x31
    5874:	3a a9       	ldd	r19, Y+50	; 0x32
    5876:	4b a9       	ldd	r20, Y+51	; 0x33
    5878:	5c a9       	ldd	r21, Y+52	; 0x34
    587a:	60 e0       	ldi	r22, 0x00	; 0
    587c:	70 e0       	ldi	r23, 0x00	; 0
    587e:	80 e8       	ldi	r24, 0x80	; 128
    5880:	9f e3       	ldi	r25, 0x3F	; 63
    5882:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    5886:	20 e0       	ldi	r18, 0x00	; 0
    5888:	30 e0       	ldi	r19, 0x00	; 0
    588a:	40 e0       	ldi	r20, 0x00	; 0
    588c:	5f e3       	ldi	r21, 0x3F	; 63
    588e:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    5892:	0e 94 90 41 	call	0x8320	; 0x8320 <sqrt>
    5896:	2b 01       	movw	r4, r22
    5898:	3c 01       	movw	r6, r24
    589a:	20 91 f5 0e 	lds	r18, 0x0EF5	; 0x800ef5 <settings+0x35>
    589e:	30 91 f6 0e 	lds	r19, 0x0EF6	; 0x800ef6 <settings+0x36>
    58a2:	40 91 f7 0e 	lds	r20, 0x0EF7	; 0x800ef7 <settings+0x37>
    58a6:	50 91 f8 0e 	lds	r21, 0x0EF8	; 0x800ef8 <settings+0x38>
    58aa:	c7 01       	movw	r24, r14
    58ac:	b6 01       	movw	r22, r12
    58ae:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    58b2:	a3 01       	movw	r20, r6
    58b4:	92 01       	movw	r18, r4
    58b6:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    58ba:	6b 01       	movw	r12, r22
    58bc:	7c 01       	movw	r14, r24
    58be:	a3 01       	movw	r20, r6
    58c0:	92 01       	movw	r18, r4
    58c2:	60 e0       	ldi	r22, 0x00	; 0
    58c4:	70 e0       	ldi	r23, 0x00	; 0
    58c6:	80 e8       	ldi	r24, 0x80	; 128
    58c8:	9f e3       	ldi	r25, 0x3F	; 63
    58ca:	0e 94 eb 3d 	call	0x7bd6	; 0x7bd6 <__subsf3>
    58ce:	9b 01       	movw	r18, r22
    58d0:	ac 01       	movw	r20, r24
    58d2:	c7 01       	movw	r24, r14
    58d4:	b6 01       	movw	r22, r12
    58d6:	0e 94 cc 3e 	call	0x7d98	; 0x7d98 <__divsf3>
    58da:	e6 2e       	mov	r14, r22
    58dc:	f7 2e       	mov	r15, r23
    58de:	08 2f       	mov	r16, r24
    58e0:	19 2f       	mov	r17, r25
    58e2:	20 e0       	ldi	r18, 0x00	; 0
    58e4:	30 e0       	ldi	r19, 0x00	; 0
    58e6:	a9 01       	movw	r20, r18
    58e8:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    58ec:	88 23       	and	r24, r24
    58ee:	24 f4       	brge	.+8      	; 0x58f8 <plan_buffer_line+0x450>
    58f0:	e1 2c       	mov	r14, r1
    58f2:	f1 2c       	mov	r15, r1
    58f4:	00 e0       	ldi	r16, 0x00	; 0
    58f6:	10 e0       	ldi	r17, 0x00	; 0
    58f8:	86 e3       	ldi	r24, 0x36	; 54
    58fa:	8a 9d       	mul	r24, r10
    58fc:	f0 01       	movw	r30, r0
    58fe:	8b 9d       	mul	r24, r11
    5900:	f0 0d       	add	r31, r0
    5902:	11 24       	eor	r1, r1
    5904:	e8 58       	subi	r30, 0x88	; 136
    5906:	fb 4f       	sbci	r31, 0xFB	; 251
    5908:	4e 2d       	mov	r20, r14
    590a:	5f 2d       	mov	r21, r15
    590c:	60 2f       	mov	r22, r16
    590e:	71 2f       	mov	r23, r17
    5910:	46 a3       	std	Z+38, r20	; 0x26
    5912:	57 a3       	std	Z+39, r21	; 0x27
    5914:	60 a7       	std	Z+40, r22	; 0x28
    5916:	71 a7       	std	Z+41, r23	; 0x29
    5918:	86 e3       	ldi	r24, 0x36	; 54
    591a:	8a 9d       	mul	r24, r10
    591c:	f0 01       	movw	r30, r0
    591e:	8b 9d       	mul	r24, r11
    5920:	f0 0d       	add	r31, r0
    5922:	11 24       	eor	r1, r1
    5924:	e8 58       	subi	r30, 0x88	; 136
    5926:	fb 4f       	sbci	r31, 0xFB	; 251
    5928:	81 89       	ldd	r24, Z+17	; 0x11
    592a:	81 fd       	sbrc	r24, 1
    592c:	87 c0       	rjmp	.+270    	; 0x5a3c <plan_buffer_line+0x594>
    592e:	21 96       	adiw	r28, 0x01	; 1
    5930:	8e ad       	ldd	r24, Y+62	; 0x3e
    5932:	9f ad       	ldd	r25, Y+63	; 0x3f
    5934:	21 97       	sbiw	r28, 0x01	; 1
    5936:	82 dc       	rcall	.-1788   	; 0x523c <plan_compute_profile_nominal_speed>
    5938:	6b 01       	movw	r12, r22
    593a:	7c 01       	movw	r14, r24
    593c:	40 90 70 04 	lds	r4, 0x0470	; 0x800470 <pl+0x18>
    5940:	50 90 71 04 	lds	r5, 0x0471	; 0x800471 <pl+0x19>
    5944:	60 90 72 04 	lds	r6, 0x0472	; 0x800472 <pl+0x1a>
    5948:	70 90 73 04 	lds	r7, 0x0473	; 0x800473 <pl+0x1b>
    594c:	a3 01       	movw	r20, r6
    594e:	92 01       	movw	r18, r4
    5950:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    5954:	18 16       	cp	r1, r24
    5956:	a4 f4       	brge	.+40     	; 0x5980 <plan_buffer_line+0x4d8>
    5958:	86 e3       	ldi	r24, 0x36	; 54
    595a:	8a 9d       	mul	r24, r10
    595c:	80 01       	movw	r16, r0
    595e:	8b 9d       	mul	r24, r11
    5960:	10 0d       	add	r17, r0
    5962:	11 24       	eor	r1, r1
    5964:	08 58       	subi	r16, 0x88	; 136
    5966:	1b 4f       	sbci	r17, 0xFB	; 251
    5968:	a3 01       	movw	r20, r6
    596a:	92 01       	movw	r18, r4
    596c:	c3 01       	movw	r24, r6
    596e:	b2 01       	movw	r22, r4
    5970:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    5974:	f8 01       	movw	r30, r16
    5976:	62 8f       	std	Z+26, r22	; 0x1a
    5978:	73 8f       	std	Z+27, r23	; 0x1b
    597a:	84 8f       	std	Z+28, r24	; 0x1c
    597c:	95 8f       	std	Z+29, r25	; 0x1d
    597e:	13 c0       	rjmp	.+38     	; 0x59a6 <plan_buffer_line+0x4fe>
    5980:	86 e3       	ldi	r24, 0x36	; 54
    5982:	8a 9d       	mul	r24, r10
    5984:	80 01       	movw	r16, r0
    5986:	8b 9d       	mul	r24, r11
    5988:	10 0d       	add	r17, r0
    598a:	11 24       	eor	r1, r1
    598c:	08 58       	subi	r16, 0x88	; 136
    598e:	1b 4f       	sbci	r17, 0xFB	; 251
    5990:	a7 01       	movw	r20, r14
    5992:	96 01       	movw	r18, r12
    5994:	c7 01       	movw	r24, r14
    5996:	b6 01       	movw	r22, r12
    5998:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    599c:	f8 01       	movw	r30, r16
    599e:	62 8f       	std	Z+26, r22	; 0x1a
    59a0:	73 8f       	std	Z+27, r23	; 0x1b
    59a2:	84 8f       	std	Z+28, r24	; 0x1c
    59a4:	95 8f       	std	Z+29, r25	; 0x1d
    59a6:	86 e3       	ldi	r24, 0x36	; 54
    59a8:	8a 9d       	mul	r24, r10
    59aa:	f0 01       	movw	r30, r0
    59ac:	8b 9d       	mul	r24, r11
    59ae:	f0 0d       	add	r31, r0
    59b0:	11 24       	eor	r1, r1
    59b2:	e8 58       	subi	r30, 0x88	; 136
    59b4:	fb 4f       	sbci	r31, 0xFB	; 251
    59b6:	46 a0       	ldd	r4, Z+38	; 0x26
    59b8:	57 a0       	ldd	r5, Z+39	; 0x27
    59ba:	60 a4       	ldd	r6, Z+40	; 0x28
    59bc:	71 a4       	ldd	r7, Z+41	; 0x29
    59be:	a3 01       	movw	r20, r6
    59c0:	92 01       	movw	r18, r4
    59c2:	62 8d       	ldd	r22, Z+26	; 0x1a
    59c4:	73 8d       	ldd	r23, Z+27	; 0x1b
    59c6:	84 8d       	ldd	r24, Z+28	; 0x1c
    59c8:	95 8d       	ldd	r25, Z+29	; 0x1d
    59ca:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    59ce:	18 16       	cp	r1, r24
    59d0:	64 f4       	brge	.+24     	; 0x59ea <plan_buffer_line+0x542>
    59d2:	86 e3       	ldi	r24, 0x36	; 54
    59d4:	8a 9d       	mul	r24, r10
    59d6:	f0 01       	movw	r30, r0
    59d8:	8b 9d       	mul	r24, r11
    59da:	f0 0d       	add	r31, r0
    59dc:	11 24       	eor	r1, r1
    59de:	e8 58       	subi	r30, 0x88	; 136
    59e0:	fb 4f       	sbci	r31, 0xFB	; 251
    59e2:	42 8e       	std	Z+26, r4	; 0x1a
    59e4:	53 8e       	std	Z+27, r5	; 0x1b
    59e6:	64 8e       	std	Z+28, r6	; 0x1c
    59e8:	75 8e       	std	Z+29, r7	; 0x1d
    59ea:	c0 92 70 04 	sts	0x0470, r12	; 0x800470 <pl+0x18>
    59ee:	d0 92 71 04 	sts	0x0471, r13	; 0x800471 <pl+0x19>
    59f2:	e0 92 72 04 	sts	0x0472, r14	; 0x800472 <pl+0x1a>
    59f6:	f0 92 73 04 	sts	0x0473, r15	; 0x800473 <pl+0x1b>
    59fa:	8c e0       	ldi	r24, 0x0C	; 12
    59fc:	fe 01       	movw	r30, r28
    59fe:	79 96       	adiw	r30, 0x19	; 25
    5a00:	a4 e6       	ldi	r26, 0x64	; 100
    5a02:	b4 e0       	ldi	r27, 0x04	; 4
    5a04:	01 90       	ld	r0, Z+
    5a06:	0d 92       	st	X+, r0
    5a08:	8a 95       	dec	r24
    5a0a:	e1 f7       	brne	.-8      	; 0x5a04 <plan_buffer_line+0x55c>
    5a0c:	8c e0       	ldi	r24, 0x0C	; 12
    5a0e:	fe 01       	movw	r30, r28
    5a10:	31 96       	adiw	r30, 0x01	; 1
    5a12:	a8 e5       	ldi	r26, 0x58	; 88
    5a14:	b4 e0       	ldi	r27, 0x04	; 4
    5a16:	01 90       	ld	r0, Z+
    5a18:	0d 92       	st	X+, r0
    5a1a:	8a 95       	dec	r24
    5a1c:	e1 f7       	brne	.-8      	; 0x5a16 <plan_buffer_line+0x56e>
    5a1e:	80 91 75 04 	lds	r24, 0x0475	; 0x800475 <next_buffer_head>
    5a22:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <block_buffer_head>
    5a26:	8f 5f       	subi	r24, 0xFF	; 255
    5a28:	84 32       	cpi	r24, 0x24	; 36
    5a2a:	09 f4       	brne	.+2      	; 0x5a2e <plan_buffer_line+0x586>
    5a2c:	80 e0       	ldi	r24, 0x00	; 0
    5a2e:	80 93 75 04 	sts	0x0475, r24	; 0x800475 <next_buffer_head>
    5a32:	3d da       	rcall	.-2950   	; 0x4eae <planner_recalculate>
    5a34:	81 e0       	ldi	r24, 0x01	; 1
    5a36:	39 c0       	rjmp	.+114    	; 0x5aaa <plan_buffer_line+0x602>
    5a38:	80 e0       	ldi	r24, 0x00	; 0
    5a3a:	37 c0       	rjmp	.+110    	; 0x5aaa <plan_buffer_line+0x602>
    5a3c:	81 e0       	ldi	r24, 0x01	; 1
    5a3e:	35 c0       	rjmp	.+106    	; 0x5aaa <plan_buffer_line+0x602>
    5a40:	89 af       	std	Y+57, r24	; 0x39
    5a42:	9a af       	std	Y+58, r25	; 0x3a
    5a44:	20 ec       	ldi	r18, 0xC0	; 192
    5a46:	3e e0       	ldi	r19, 0x0E	; 14
    5a48:	3c af       	std	Y+60, r19	; 0x3c
    5a4a:	2b af       	std	Y+59, r18	; 0x3b
    5a4c:	ae 01       	movw	r20, r28
    5a4e:	4f 5f       	subi	r20, 0xFF	; 255
    5a50:	5f 4f       	sbci	r21, 0xFF	; 255
    5a52:	4a 01       	movw	r8, r20
    5a54:	6e 01       	movw	r12, r28
    5a56:	5d e0       	ldi	r21, 0x0D	; 13
    5a58:	c5 0e       	add	r12, r21
    5a5a:	d1 1c       	adc	r13, r1
    5a5c:	66 e3       	ldi	r22, 0x36	; 54
    5a5e:	26 9e       	mul	r2, r22
    5a60:	c0 01       	movw	r24, r0
    5a62:	11 24       	eor	r1, r1
    5a64:	fc 01       	movw	r30, r24
    5a66:	e8 58       	subi	r30, 0x88	; 136
    5a68:	fb 4f       	sbci	r31, 0xFB	; 251
    5a6a:	1f 01       	movw	r2, r30
    5a6c:	9e 01       	movw	r18, r28
    5a6e:	27 5e       	subi	r18, 0xE7	; 231
    5a70:	3f 4f       	sbci	r19, 0xFF	; 255
    5a72:	25 96       	adiw	r28, 0x05	; 5
    5a74:	3f af       	std	Y+63, r19	; 0x3f
    5a76:	2e af       	std	Y+62, r18	; 0x3e
    5a78:	25 97       	sbiw	r28, 0x05	; 5
    5a7a:	3e af       	std	Y+62, r19	; 0x3e
    5a7c:	2d af       	std	Y+61, r18	; 0x3d
    5a7e:	10 e0       	ldi	r17, 0x00	; 0
    5a80:	26 e3       	ldi	r18, 0x36	; 54
    5a82:	2a 9d       	mul	r18, r10
    5a84:	c0 01       	movw	r24, r0
    5a86:	2b 9d       	mul	r18, r11
    5a88:	90 0d       	add	r25, r0
    5a8a:	11 24       	eor	r1, r1
    5a8c:	88 58       	subi	r24, 0x88	; 136
    5a8e:	9b 4f       	sbci	r25, 0xFB	; 251
    5a90:	7c 01       	movw	r14, r24
    5a92:	3c e0       	ldi	r19, 0x0C	; 12
    5a94:	e3 0e       	add	r14, r19
    5a96:	f1 1c       	adc	r15, r1
    5a98:	ac 01       	movw	r20, r24
    5a9a:	40 5f       	subi	r20, 0xF0	; 240
    5a9c:	5f 4f       	sbci	r21, 0xFF	; 255
    5a9e:	27 96       	adiw	r28, 0x07	; 7
    5aa0:	5f af       	std	Y+63, r21	; 0x3f
    5aa2:	4e af       	std	Y+62, r20	; 0x3e
    5aa4:	27 97       	sbiw	r28, 0x07	; 7
    5aa6:	19 ab       	std	Y+49, r17	; 0x31
    5aa8:	70 cd       	rjmp	.-1312   	; 0x558a <plan_buffer_line+0xe2>
    5aaa:	ca 5b       	subi	r28, 0xBA	; 186
    5aac:	df 4f       	sbci	r29, 0xFF	; 255
    5aae:	0f b6       	in	r0, 0x3f	; 63
    5ab0:	f8 94       	cli
    5ab2:	de bf       	out	0x3e, r29	; 62
    5ab4:	0f be       	out	0x3f, r0	; 63
    5ab6:	cd bf       	out	0x3d, r28	; 61
    5ab8:	df 91       	pop	r29
    5aba:	cf 91       	pop	r28
    5abc:	1f 91       	pop	r17
    5abe:	0f 91       	pop	r16
    5ac0:	ff 90       	pop	r15
    5ac2:	ef 90       	pop	r14
    5ac4:	df 90       	pop	r13
    5ac6:	cf 90       	pop	r12
    5ac8:	bf 90       	pop	r11
    5aca:	af 90       	pop	r10
    5acc:	9f 90       	pop	r9
    5ace:	8f 90       	pop	r8
    5ad0:	7f 90       	pop	r7
    5ad2:	6f 90       	pop	r6
    5ad4:	5f 90       	pop	r5
    5ad6:	4f 90       	pop	r4
    5ad8:	3f 90       	pop	r3
    5ada:	2f 90       	pop	r2
    5adc:	08 95       	ret

00005ade <plan_sync_position>:
    5ade:	e7 e3       	ldi	r30, 0x37	; 55
    5ae0:	fc e0       	ldi	r31, 0x0C	; 12
    5ae2:	a8 e5       	ldi	r26, 0x58	; 88
    5ae4:	b4 e0       	ldi	r27, 0x04	; 4
    5ae6:	83 e4       	ldi	r24, 0x43	; 67
    5ae8:	9c e0       	ldi	r25, 0x0C	; 12
    5aea:	41 91       	ld	r20, Z+
    5aec:	51 91       	ld	r21, Z+
    5aee:	61 91       	ld	r22, Z+
    5af0:	71 91       	ld	r23, Z+
    5af2:	4d 93       	st	X+, r20
    5af4:	5d 93       	st	X+, r21
    5af6:	6d 93       	st	X+, r22
    5af8:	7d 93       	st	X+, r23
    5afa:	e8 17       	cp	r30, r24
    5afc:	f9 07       	cpc	r31, r25
    5afe:	a9 f7       	brne	.-22     	; 0x5aea <plan_sync_position+0xc>
    5b00:	08 95       	ret

00005b02 <plan_get_block_buffer_available>:
    5b02:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <block_buffer_head>
    5b06:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    5b0a:	98 17       	cp	r25, r24
    5b0c:	18 f0       	brcs	.+6      	; 0x5b14 <plan_get_block_buffer_available+0x12>
    5b0e:	8d 5d       	subi	r24, 0xDD	; 221
    5b10:	89 1b       	sub	r24, r25
    5b12:	08 95       	ret
    5b14:	81 50       	subi	r24, 0x01	; 1
    5b16:	89 1b       	sub	r24, r25
    5b18:	08 95       	ret

00005b1a <plan_cycle_reinitialize>:
// Re-initialize buffer plan with a partially completed block, assumed to exist at the buffer tail.
// Called after a steppers have come to a complete stop for a feed hold and the cycle is stopped.
void plan_cycle_reinitialize()
{
  // Re-plan from a complete stop. Reset planner entry speeds and buffer planned pointer.
  st_update_plan_block_parameters();
    5b1a:	0e 94 94 1b 	call	0x3728	; 0x3728 <st_update_plan_block_parameters>
  block_buffer_planned = block_buffer_tail;
    5b1e:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    5b22:	80 93 74 04 	sts	0x0474, r24	; 0x800474 <block_buffer_planned>
  planner_recalculate();
    5b26:	c3 c9       	rjmp	.-3194   	; 0x4eae <planner_recalculate>
    5b28:	08 95       	ret

00005b2a <read_float>:
// Delays variable defined microseconds. Compiler compatibility fix for _delay_us(),
// which only accepts constants in future compiler releases. Written to perform more
// efficiently with larger delays, as the counter adds parasitic time in each iteration.
void delay_us(uint32_t us)
{
  while (us) {
    5b2a:	4f 92       	push	r4
    5b2c:	5f 92       	push	r5
    5b2e:	6f 92       	push	r6
    5b30:	7f 92       	push	r7
    5b32:	8f 92       	push	r8
    5b34:	9f 92       	push	r9
    5b36:	af 92       	push	r10
    5b38:	bf 92       	push	r11
    5b3a:	cf 92       	push	r12
    5b3c:	df 92       	push	r13
    5b3e:	ef 92       	push	r14
    5b40:	ff 92       	push	r15
    5b42:	0f 93       	push	r16
    5b44:	1f 93       	push	r17
    5b46:	cf 93       	push	r28
    5b48:	df 93       	push	r29
    5b4a:	dc 01       	movw	r26, r24
    5b4c:	fb 01       	movw	r30, r22
    5b4e:	c0 81       	ld	r28, Z
    5b50:	d0 e0       	ldi	r29, 0x00	; 0
    5b52:	fc 01       	movw	r30, r24
    5b54:	ec 0f       	add	r30, r28
    5b56:	fd 1f       	adc	r31, r29
    5b58:	90 81       	ld	r25, Z
    5b5a:	9d 32       	cpi	r25, 0x2D	; 45
    5b5c:	29 f4       	brne	.+10     	; 0x5b68 <read_float+0x3e>
    5b5e:	ef 01       	movw	r28, r30
    5b60:	22 96       	adiw	r28, 0x02	; 2
    5b62:	91 81       	ldd	r25, Z+1	; 0x01
    5b64:	01 e0       	ldi	r16, 0x01	; 1
    5b66:	0b c0       	rjmp	.+22     	; 0x5b7e <read_float+0x54>
    5b68:	9b 32       	cpi	r25, 0x2B	; 43
    5b6a:	29 f0       	breq	.+10     	; 0x5b76 <read_float+0x4c>
    5b6c:	21 96       	adiw	r28, 0x01	; 1
    5b6e:	ca 0f       	add	r28, r26
    5b70:	db 1f       	adc	r29, r27
    5b72:	00 e0       	ldi	r16, 0x00	; 0
    5b74:	04 c0       	rjmp	.+8      	; 0x5b7e <read_float+0x54>
    5b76:	ef 01       	movw	r28, r30
    5b78:	22 96       	adiw	r28, 0x02	; 2
    5b7a:	91 81       	ldd	r25, Z+1	; 0x01
    5b7c:	00 e0       	ldi	r16, 0x00	; 0
    5b7e:	80 e0       	ldi	r24, 0x00	; 0
    5b80:	20 e0       	ldi	r18, 0x00	; 0
    5b82:	10 e0       	ldi	r17, 0x00	; 0
    5b84:	41 2c       	mov	r4, r1
    5b86:	51 2c       	mov	r5, r1
    5b88:	32 01       	movw	r6, r4
    5b8a:	31 e0       	ldi	r19, 0x01	; 1
    5b8c:	fe 01       	movw	r30, r28
    5b8e:	90 53       	subi	r25, 0x30	; 48
    5b90:	9a 30       	cpi	r25, 0x0A	; 10
    5b92:	10 f5       	brcc	.+68     	; 0x5bd8 <read_float+0xae>
    5b94:	2f 5f       	subi	r18, 0xFF	; 255
    5b96:	29 30       	cpi	r18, 0x09	; 9
    5b98:	d8 f4       	brcc	.+54     	; 0x5bd0 <read_float+0xa6>
    5b9a:	81 11       	cpse	r24, r1
    5b9c:	11 50       	subi	r17, 0x01	; 1
    5b9e:	53 01       	movw	r10, r6
    5ba0:	42 01       	movw	r8, r4
    5ba2:	88 0c       	add	r8, r8
    5ba4:	99 1c       	adc	r9, r9
    5ba6:	aa 1c       	adc	r10, r10
    5ba8:	bb 1c       	adc	r11, r11
    5baa:	88 0c       	add	r8, r8
    5bac:	99 1c       	adc	r9, r9
    5bae:	aa 1c       	adc	r10, r10
    5bb0:	bb 1c       	adc	r11, r11
    5bb2:	84 0c       	add	r8, r4
    5bb4:	95 1c       	adc	r9, r5
    5bb6:	a6 1c       	adc	r10, r6
    5bb8:	b7 1c       	adc	r11, r7
    5bba:	88 0c       	add	r8, r8
    5bbc:	99 1c       	adc	r9, r9
    5bbe:	aa 1c       	adc	r10, r10
    5bc0:	bb 1c       	adc	r11, r11
    5bc2:	24 01       	movw	r4, r8
    5bc4:	35 01       	movw	r6, r10
    5bc6:	49 0e       	add	r4, r25
    5bc8:	51 1c       	adc	r5, r1
    5bca:	61 1c       	adc	r6, r1
    5bcc:	71 1c       	adc	r7, r1
    5bce:	09 c0       	rjmp	.+18     	; 0x5be2 <read_float+0xb8>
    5bd0:	81 11       	cpse	r24, r1
    5bd2:	07 c0       	rjmp	.+14     	; 0x5be2 <read_float+0xb8>
    5bd4:	1f 5f       	subi	r17, 0xFF	; 255
    5bd6:	05 c0       	rjmp	.+10     	; 0x5be2 <read_float+0xb8>
    5bd8:	9e 3f       	cpi	r25, 0xFE	; 254
    5bda:	31 f4       	brne	.+12     	; 0x5be8 <read_float+0xbe>
    5bdc:	81 11       	cpse	r24, r1
    5bde:	04 c0       	rjmp	.+8      	; 0x5be8 <read_float+0xbe>
    5be0:	83 2f       	mov	r24, r19
    5be2:	90 81       	ld	r25, Z
    5be4:	21 96       	adiw	r28, 0x01	; 1
    5be6:	d2 cf       	rjmp	.-92     	; 0x5b8c <read_float+0x62>
    5be8:	22 23       	and	r18, r18
    5bea:	09 f4       	brne	.+2      	; 0x5bee <read_float+0xc4>
    5bec:	52 c0       	rjmp	.+164    	; 0x5c92 <read_float+0x168>
    5bee:	6a 01       	movw	r12, r20
    5bf0:	7b 01       	movw	r14, r22
    5bf2:	5d 01       	movw	r10, r26
    5bf4:	c3 01       	movw	r24, r6
    5bf6:	b2 01       	movw	r22, r4
    5bf8:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__floatunsisf>
    5bfc:	2b 01       	movw	r4, r22
    5bfe:	3c 01       	movw	r6, r24
    5c00:	20 e0       	ldi	r18, 0x00	; 0
    5c02:	30 e0       	ldi	r19, 0x00	; 0
    5c04:	a9 01       	movw	r20, r18
    5c06:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    5c0a:	88 23       	and	r24, r24
    5c0c:	51 f1       	breq	.+84     	; 0x5c62 <read_float+0x138>
    5c0e:	1f 3f       	cpi	r17, 0xFF	; 255
    5c10:	6c f4       	brge	.+26     	; 0x5c2c <read_float+0x102>
    5c12:	2a e0       	ldi	r18, 0x0A	; 10
    5c14:	37 ed       	ldi	r19, 0xD7	; 215
    5c16:	43 e2       	ldi	r20, 0x23	; 35
    5c18:	5c e3       	ldi	r21, 0x3C	; 60
    5c1a:	c3 01       	movw	r24, r6
    5c1c:	b2 01       	movw	r22, r4
    5c1e:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    5c22:	2b 01       	movw	r4, r22
    5c24:	3c 01       	movw	r6, r24
    5c26:	1e 5f       	subi	r17, 0xFE	; 254
    5c28:	1f 3f       	cpi	r17, 0xFF	; 255
    5c2a:	9c f3       	brlt	.-26     	; 0x5c12 <read_float+0xe8>
    5c2c:	11 23       	and	r17, r17
    5c2e:	5c f4       	brge	.+22     	; 0x5c46 <read_float+0x11c>
    5c30:	2d ec       	ldi	r18, 0xCD	; 205
    5c32:	3c ec       	ldi	r19, 0xCC	; 204
    5c34:	4c ec       	ldi	r20, 0xCC	; 204
    5c36:	5d e3       	ldi	r21, 0x3D	; 61
    5c38:	c3 01       	movw	r24, r6
    5c3a:	b2 01       	movw	r22, r4
    5c3c:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    5c40:	2b 01       	movw	r4, r22
    5c42:	3c 01       	movw	r6, r24
    5c44:	0e c0       	rjmp	.+28     	; 0x5c62 <read_float+0x138>
    5c46:	11 16       	cp	r1, r17
    5c48:	64 f4       	brge	.+24     	; 0x5c62 <read_float+0x138>
    5c4a:	20 e0       	ldi	r18, 0x00	; 0
    5c4c:	30 e0       	ldi	r19, 0x00	; 0
    5c4e:	40 e2       	ldi	r20, 0x20	; 32
    5c50:	51 e4       	ldi	r21, 0x41	; 65
    5c52:	c3 01       	movw	r24, r6
    5c54:	b2 01       	movw	r22, r4
    5c56:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    5c5a:	2b 01       	movw	r4, r22
    5c5c:	3c 01       	movw	r6, r24
    5c5e:	11 50       	subi	r17, 0x01	; 1
    5c60:	a1 f7       	brne	.-24     	; 0x5c4a <read_float+0x120>
    5c62:	00 23       	and	r16, r16
    5c64:	51 f0       	breq	.+20     	; 0x5c7a <read_float+0x150>
    5c66:	77 fa       	bst	r7, 7
    5c68:	70 94       	com	r7
    5c6a:	77 f8       	bld	r7, 7
    5c6c:	70 94       	com	r7
    5c6e:	f6 01       	movw	r30, r12
    5c70:	40 82       	st	Z, r4
    5c72:	51 82       	std	Z+1, r5	; 0x01
    5c74:	62 82       	std	Z+2, r6	; 0x02
    5c76:	73 82       	std	Z+3, r7	; 0x03
    5c78:	05 c0       	rjmp	.+10     	; 0x5c84 <read_float+0x15a>
    5c7a:	f6 01       	movw	r30, r12
    5c7c:	40 82       	st	Z, r4
    5c7e:	51 82       	std	Z+1, r5	; 0x01
    5c80:	62 82       	std	Z+2, r6	; 0x02
    5c82:	73 82       	std	Z+3, r7	; 0x03
    5c84:	ca 19       	sub	r28, r10
    5c86:	db 09       	sbc	r29, r11
    5c88:	c1 50       	subi	r28, 0x01	; 1
    5c8a:	f7 01       	movw	r30, r14
    5c8c:	c0 83       	st	Z, r28
    5c8e:	81 e0       	ldi	r24, 0x01	; 1
    5c90:	01 c0       	rjmp	.+2      	; 0x5c94 <read_float+0x16a>
    5c92:	80 e0       	ldi	r24, 0x00	; 0
    5c94:	df 91       	pop	r29
    5c96:	cf 91       	pop	r28
    5c98:	1f 91       	pop	r17
    5c9a:	0f 91       	pop	r16
    5c9c:	ff 90       	pop	r15
    5c9e:	ef 90       	pop	r14
    5ca0:	df 90       	pop	r13
    5ca2:	cf 90       	pop	r12
    5ca4:	bf 90       	pop	r11
    5ca6:	af 90       	pop	r10
    5ca8:	9f 90       	pop	r9
    5caa:	8f 90       	pop	r8
    5cac:	7f 90       	pop	r7
    5cae:	6f 90       	pop	r6
    5cb0:	5f 90       	pop	r5
    5cb2:	4f 90       	pop	r4
    5cb4:	08 95       	ret

00005cb6 <delay_sec>:
    5cb6:	ff 92       	push	r15
    5cb8:	0f 93       	push	r16
    5cba:	1f 93       	push	r17
    5cbc:	cf 93       	push	r28
    5cbe:	df 93       	push	r29
    5cc0:	f4 2e       	mov	r15, r20
    5cc2:	20 e0       	ldi	r18, 0x00	; 0
    5cc4:	30 e0       	ldi	r19, 0x00	; 0
    5cc6:	40 ea       	ldi	r20, 0xA0	; 160
    5cc8:	51 e4       	ldi	r21, 0x41	; 65
    5cca:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    5cce:	0e 94 b2 3e 	call	0x7d64	; 0x7d64 <ceil>
    5cd2:	0e 94 39 3f 	call	0x7e72	; 0x7e72 <__fixunssfsi>
    5cd6:	61 15       	cp	r22, r1
    5cd8:	71 05       	cpc	r23, r1
    5cda:	21 f1       	breq	.+72     	; 0x5d24 <delay_sec+0x6e>
    5cdc:	20 91 17 0c 	lds	r18, 0x0C17	; 0x800c17 <sys+0x1>
    5ce0:	21 11       	cpse	r18, r1
    5ce2:	20 c0       	rjmp	.+64     	; 0x5d24 <delay_sec+0x6e>
    5ce4:	eb 01       	movw	r28, r22
    5ce6:	06 e1       	ldi	r16, 0x16	; 22
    5ce8:	1c e0       	ldi	r17, 0x0C	; 12
    5cea:	05 c0       	rjmp	.+10     	; 0x5cf6 <delay_sec+0x40>
    5cec:	21 97       	sbiw	r28, 0x01	; 1
    5cee:	f8 01       	movw	r30, r16
    5cf0:	81 81       	ldd	r24, Z+1	; 0x01
    5cf2:	81 11       	cpse	r24, r1
    5cf4:	17 c0       	rjmp	.+46     	; 0x5d24 <delay_sec+0x6e>
    5cf6:	f1 10       	cpse	r15, r1
    5cf8:	03 c0       	rjmp	.+6      	; 0x5d00 <delay_sec+0x4a>
    5cfa:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <protocol_execute_realtime>
    5cfe:	06 c0       	rjmp	.+12     	; 0x5d0c <delay_sec+0x56>
    5d00:	0e 94 db 14 	call	0x29b6	; 0x29b6 <protocol_exec_rt_system>
    5d04:	f8 01       	movw	r30, r16
    5d06:	82 81       	ldd	r24, Z+2	; 0x02
    5d08:	81 fd       	sbrc	r24, 1
    5d0a:	0c c0       	rjmp	.+24     	; 0x5d24 <delay_sec+0x6e>
    5d0c:	ff ef       	ldi	r31, 0xFF	; 255
    5d0e:	20 e7       	ldi	r18, 0x70	; 112
    5d10:	82 e0       	ldi	r24, 0x02	; 2
    5d12:	f1 50       	subi	r31, 0x01	; 1
    5d14:	20 40       	sbci	r18, 0x00	; 0
    5d16:	80 40       	sbci	r24, 0x00	; 0
    5d18:	e1 f7       	brne	.-8      	; 0x5d12 <delay_sec+0x5c>
    5d1a:	00 c0       	rjmp	.+0      	; 0x5d1c <delay_sec+0x66>
    5d1c:	00 00       	nop
    5d1e:	c1 30       	cpi	r28, 0x01	; 1
    5d20:	d1 05       	cpc	r29, r1
    5d22:	21 f7       	brne	.-56     	; 0x5cec <delay_sec+0x36>
    5d24:	df 91       	pop	r29
    5d26:	cf 91       	pop	r28
    5d28:	1f 91       	pop	r17
    5d2a:	0f 91       	pop	r16
    5d2c:	ff 90       	pop	r15
    5d2e:	08 95       	ret

00005d30 <delay_ms>:
    5d30:	00 97       	sbiw	r24, 0x00	; 0
    5d32:	41 f0       	breq	.+16     	; 0x5d44 <delay_ms+0x14>
    5d34:	ef e9       	ldi	r30, 0x9F	; 159
    5d36:	ff e0       	ldi	r31, 0x0F	; 15
    5d38:	31 97       	sbiw	r30, 0x01	; 1
    5d3a:	f1 f7       	brne	.-4      	; 0x5d38 <delay_ms+0x8>
    5d3c:	00 c0       	rjmp	.+0      	; 0x5d3e <delay_ms+0xe>
    5d3e:	00 00       	nop
    5d40:	01 97       	sbiw	r24, 0x01	; 1
    5d42:	c1 f7       	brne	.-16     	; 0x5d34 <delay_ms+0x4>
    5d44:	08 95       	ret

00005d46 <hypot_f>:
  }
}


// Simple hypotenuse computation function.
float hypot_f(float x, float y) { return(sqrt(x*x + y*y)); }
    5d46:	4f 92       	push	r4
    5d48:	5f 92       	push	r5
    5d4a:	6f 92       	push	r6
    5d4c:	7f 92       	push	r7
    5d4e:	8f 92       	push	r8
    5d50:	9f 92       	push	r9
    5d52:	af 92       	push	r10
    5d54:	bf 92       	push	r11
    5d56:	cf 92       	push	r12
    5d58:	df 92       	push	r13
    5d5a:	ef 92       	push	r14
    5d5c:	ff 92       	push	r15
    5d5e:	4b 01       	movw	r8, r22
    5d60:	5c 01       	movw	r10, r24
    5d62:	69 01       	movw	r12, r18
    5d64:	7a 01       	movw	r14, r20
    5d66:	a5 01       	movw	r20, r10
    5d68:	94 01       	movw	r18, r8
    5d6a:	c5 01       	movw	r24, r10
    5d6c:	b4 01       	movw	r22, r8
    5d6e:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    5d72:	4b 01       	movw	r8, r22
    5d74:	5c 01       	movw	r10, r24
    5d76:	a7 01       	movw	r20, r14
    5d78:	96 01       	movw	r18, r12
    5d7a:	c7 01       	movw	r24, r14
    5d7c:	b6 01       	movw	r22, r12
    5d7e:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    5d82:	9b 01       	movw	r18, r22
    5d84:	ac 01       	movw	r20, r24
    5d86:	c5 01       	movw	r24, r10
    5d88:	b4 01       	movw	r22, r8
    5d8a:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    5d8e:	0e 94 90 41 	call	0x8320	; 0x8320 <sqrt>
    5d92:	ff 90       	pop	r15
    5d94:	ef 90       	pop	r14
    5d96:	df 90       	pop	r13
    5d98:	cf 90       	pop	r12
    5d9a:	bf 90       	pop	r11
    5d9c:	af 90       	pop	r10
    5d9e:	9f 90       	pop	r9
    5da0:	8f 90       	pop	r8
    5da2:	7f 90       	pop	r7
    5da4:	6f 90       	pop	r6
    5da6:	5f 90       	pop	r5
    5da8:	4f 90       	pop	r4
    5daa:	08 95       	ret

00005dac <convert_delta_vector_to_unit_vector>:


float convert_delta_vector_to_unit_vector(float *vector)
{
    5dac:	4f 92       	push	r4
    5dae:	5f 92       	push	r5
    5db0:	6f 92       	push	r6
    5db2:	7f 92       	push	r7
    5db4:	af 92       	push	r10
    5db6:	bf 92       	push	r11
    5db8:	cf 92       	push	r12
    5dba:	df 92       	push	r13
    5dbc:	ef 92       	push	r14
    5dbe:	ff 92       	push	r15
    5dc0:	0f 93       	push	r16
    5dc2:	1f 93       	push	r17
    5dc4:	cf 93       	push	r28
    5dc6:	df 93       	push	r29
    5dc8:	ec 01       	movw	r28, r24
    5dca:	5c 01       	movw	r10, r24
    5dcc:	8c e0       	ldi	r24, 0x0C	; 12
    5dce:	a8 0e       	add	r10, r24
    5dd0:	b1 1c       	adc	r11, r1
    5dd2:	8e 01       	movw	r16, r28
  uint8_t idx;
  float magnitude = 0.0;
    5dd4:	41 2c       	mov	r4, r1
    5dd6:	51 2c       	mov	r5, r1
    5dd8:	32 01       	movw	r6, r4
  for (idx=0; idx<N_AXIS; idx++) {
    if (vector[idx] != 0.0) {
    5dda:	f8 01       	movw	r30, r16
    5ddc:	c1 90       	ld	r12, Z+
    5dde:	d1 90       	ld	r13, Z+
    5de0:	e1 90       	ld	r14, Z+
    5de2:	f1 90       	ld	r15, Z+
    5de4:	8f 01       	movw	r16, r30
    5de6:	20 e0       	ldi	r18, 0x00	; 0
    5de8:	30 e0       	ldi	r19, 0x00	; 0
    5dea:	a9 01       	movw	r20, r18
    5dec:	c7 01       	movw	r24, r14
    5dee:	b6 01       	movw	r22, r12
    5df0:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    5df4:	88 23       	and	r24, r24
    5df6:	71 f0       	breq	.+28     	; 0x5e14 <convert_delta_vector_to_unit_vector+0x68>
      magnitude += vector[idx]*vector[idx];
    5df8:	a7 01       	movw	r20, r14
    5dfa:	96 01       	movw	r18, r12
    5dfc:	c7 01       	movw	r24, r14
    5dfe:	b6 01       	movw	r22, r12
    5e00:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    5e04:	9b 01       	movw	r18, r22
    5e06:	ac 01       	movw	r20, r24
    5e08:	c3 01       	movw	r24, r6
    5e0a:	b2 01       	movw	r22, r4
    5e0c:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    5e10:	2b 01       	movw	r4, r22
    5e12:	3c 01       	movw	r6, r24

float convert_delta_vector_to_unit_vector(float *vector)
{
  uint8_t idx;
  float magnitude = 0.0;
  for (idx=0; idx<N_AXIS; idx++) {
    5e14:	0a 15       	cp	r16, r10
    5e16:	1b 05       	cpc	r17, r11
    5e18:	01 f7       	brne	.-64     	; 0x5dda <convert_delta_vector_to_unit_vector+0x2e>
    if (vector[idx] != 0.0) {
      magnitude += vector[idx]*vector[idx];
    }
  }
  magnitude = sqrt(magnitude);
    5e1a:	c3 01       	movw	r24, r6
    5e1c:	b2 01       	movw	r22, r4
    5e1e:	0e 94 90 41 	call	0x8320	; 0x8320 <sqrt>
    5e22:	2b 01       	movw	r4, r22
    5e24:	3c 01       	movw	r6, r24
  float inv_magnitude = 1.0/magnitude;
    5e26:	9b 01       	movw	r18, r22
    5e28:	ac 01       	movw	r20, r24
    5e2a:	60 e0       	ldi	r22, 0x00	; 0
    5e2c:	70 e0       	ldi	r23, 0x00	; 0
    5e2e:	80 e8       	ldi	r24, 0x80	; 128
    5e30:	9f e3       	ldi	r25, 0x3F	; 63
    5e32:	0e 94 cc 3e 	call	0x7d98	; 0x7d98 <__divsf3>
    5e36:	6b 01       	movw	r12, r22
    5e38:	7c 01       	movw	r14, r24
  for (idx=0; idx<N_AXIS; idx++) { vector[idx] *= inv_magnitude; }
    5e3a:	a7 01       	movw	r20, r14
    5e3c:	96 01       	movw	r18, r12
    5e3e:	68 81       	ld	r22, Y
    5e40:	79 81       	ldd	r23, Y+1	; 0x01
    5e42:	8a 81       	ldd	r24, Y+2	; 0x02
    5e44:	9b 81       	ldd	r25, Y+3	; 0x03
    5e46:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    5e4a:	69 93       	st	Y+, r22
    5e4c:	79 93       	st	Y+, r23
    5e4e:	89 93       	st	Y+, r24
    5e50:	99 93       	st	Y+, r25
    5e52:	ca 15       	cp	r28, r10
    5e54:	db 05       	cpc	r29, r11
    5e56:	89 f7       	brne	.-30     	; 0x5e3a <convert_delta_vector_to_unit_vector+0x8e>
  return(magnitude);
}
    5e58:	c3 01       	movw	r24, r6
    5e5a:	b2 01       	movw	r22, r4
    5e5c:	df 91       	pop	r29
    5e5e:	cf 91       	pop	r28
    5e60:	1f 91       	pop	r17
    5e62:	0f 91       	pop	r16
    5e64:	ff 90       	pop	r15
    5e66:	ef 90       	pop	r14
    5e68:	df 90       	pop	r13
    5e6a:	cf 90       	pop	r12
    5e6c:	bf 90       	pop	r11
    5e6e:	af 90       	pop	r10
    5e70:	7f 90       	pop	r7
    5e72:	6f 90       	pop	r6
    5e74:	5f 90       	pop	r5
    5e76:	4f 90       	pop	r4
    5e78:	08 95       	ret

00005e7a <limit_value_by_axis_maximum>:


float limit_value_by_axis_maximum(float *max_value, float *unit_vec)
{
    5e7a:	6f 92       	push	r6
    5e7c:	7f 92       	push	r7
    5e7e:	8f 92       	push	r8
    5e80:	9f 92       	push	r9
    5e82:	af 92       	push	r10
    5e84:	bf 92       	push	r11
    5e86:	cf 92       	push	r12
    5e88:	df 92       	push	r13
    5e8a:	ef 92       	push	r14
    5e8c:	ff 92       	push	r15
    5e8e:	0f 93       	push	r16
    5e90:	1f 93       	push	r17
    5e92:	cf 93       	push	r28
    5e94:	df 93       	push	r29
    5e96:	eb 01       	movw	r28, r22
    5e98:	8c 01       	movw	r16, r24
    5e9a:	7b 01       	movw	r14, r22
    5e9c:	8c e0       	ldi	r24, 0x0C	; 12
    5e9e:	e8 0e       	add	r14, r24
    5ea0:	f1 1c       	adc	r15, r1
  uint8_t idx;
  float limit_value = SOME_LARGE_VALUE;
    5ea2:	0f 2e       	mov	r0, r31
    5ea4:	f9 e9       	ldi	r31, 0x99	; 153
    5ea6:	7f 2e       	mov	r7, r31
    5ea8:	f0 2d       	mov	r31, r0
    5eaa:	0f 2e       	mov	r0, r31
    5eac:	f6 e7       	ldi	r31, 0x76	; 118
    5eae:	cf 2e       	mov	r12, r31
    5eb0:	f0 2d       	mov	r31, r0
    5eb2:	0f 2e       	mov	r0, r31
    5eb4:	f6 e9       	ldi	r31, 0x96	; 150
    5eb6:	df 2e       	mov	r13, r31
    5eb8:	f0 2d       	mov	r31, r0
    5eba:	0f 2e       	mov	r0, r31
    5ebc:	fe e7       	ldi	r31, 0x7E	; 126
    5ebe:	6f 2e       	mov	r6, r31
    5ec0:	f0 2d       	mov	r31, r0
  for (idx=0; idx<N_AXIS; idx++) {
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
    5ec2:	89 90       	ld	r8, Y+
    5ec4:	99 90       	ld	r9, Y+
    5ec6:	a9 90       	ld	r10, Y+
    5ec8:	b9 90       	ld	r11, Y+
    5eca:	20 e0       	ldi	r18, 0x00	; 0
    5ecc:	30 e0       	ldi	r19, 0x00	; 0
    5ece:	a9 01       	movw	r20, r18
    5ed0:	c5 01       	movw	r24, r10
    5ed2:	b4 01       	movw	r22, r8
    5ed4:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    5ed8:	88 23       	and	r24, r24
    5eda:	d9 f0       	breq	.+54     	; 0x5f12 <limit_value_by_axis_maximum+0x98>
      limit_value = min(limit_value,fabs(max_value[idx]/unit_vec[idx]));
    5edc:	a5 01       	movw	r20, r10
    5ede:	94 01       	movw	r18, r8
    5ee0:	f8 01       	movw	r30, r16
    5ee2:	60 81       	ld	r22, Z
    5ee4:	71 81       	ldd	r23, Z+1	; 0x01
    5ee6:	82 81       	ldd	r24, Z+2	; 0x02
    5ee8:	93 81       	ldd	r25, Z+3	; 0x03
    5eea:	0e 94 cc 3e 	call	0x7d98	; 0x7d98 <__divsf3>
    5eee:	4b 01       	movw	r8, r22
    5ef0:	5c 01       	movw	r10, r24
    5ef2:	e8 94       	clt
    5ef4:	b7 f8       	bld	r11, 7
    5ef6:	27 2d       	mov	r18, r7
    5ef8:	3c 2d       	mov	r19, r12
    5efa:	4d 2d       	mov	r20, r13
    5efc:	56 2d       	mov	r21, r6
    5efe:	c5 01       	movw	r24, r10
    5f00:	b4 01       	movw	r22, r8
    5f02:	0e 94 c8 40 	call	0x8190	; 0x8190 <__gesf2>
    5f06:	18 16       	cp	r1, r24
    5f08:	24 f0       	brlt	.+8      	; 0x5f12 <limit_value_by_axis_maximum+0x98>
    5f0a:	78 2c       	mov	r7, r8
    5f0c:	c9 2c       	mov	r12, r9
    5f0e:	da 2c       	mov	r13, r10
    5f10:	6b 2c       	mov	r6, r11
    5f12:	0c 5f       	subi	r16, 0xFC	; 252
    5f14:	1f 4f       	sbci	r17, 0xFF	; 255

float limit_value_by_axis_maximum(float *max_value, float *unit_vec)
{
  uint8_t idx;
  float limit_value = SOME_LARGE_VALUE;
  for (idx=0; idx<N_AXIS; idx++) {
    5f16:	ce 15       	cp	r28, r14
    5f18:	df 05       	cpc	r29, r15
    5f1a:	99 f6       	brne	.-90     	; 0x5ec2 <limit_value_by_axis_maximum+0x48>
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
      limit_value = min(limit_value,fabs(max_value[idx]/unit_vec[idx]));
    }
  }
  return(limit_value);
}
    5f1c:	67 2d       	mov	r22, r7
    5f1e:	7c 2d       	mov	r23, r12
    5f20:	8d 2d       	mov	r24, r13
    5f22:	96 2d       	mov	r25, r6
    5f24:	df 91       	pop	r29
    5f26:	cf 91       	pop	r28
    5f28:	1f 91       	pop	r17
    5f2a:	0f 91       	pop	r16
    5f2c:	ff 90       	pop	r15
    5f2e:	ef 90       	pop	r14
    5f30:	df 90       	pop	r13
    5f32:	cf 90       	pop	r12
    5f34:	bf 90       	pop	r11
    5f36:	af 90       	pop	r10
    5f38:	9f 90       	pop	r9
    5f3a:	8f 90       	pop	r8
    5f3c:	7f 90       	pop	r7
    5f3e:	6f 90       	pop	r6
    5f40:	08 95       	ret

00005f42 <limits_disable>:
    #ifndef DISABLE_HW_LIMITS
     LIMIT_PCMSK &= ~LIMIT_MASK;  // Disable specific pins of the Pin Change Interrupt
     PCICR &= ~(1 << LIMIT_INT);  // Disable Pin Change Interrupt
    #endif
  #else
    LIMIT_PCMSK &= ~LIMIT_MASK;  // Disable specific pins of the Pin Change Interrupt
    5f42:	eb e6       	ldi	r30, 0x6B	; 107
    5f44:	f0 e0       	ldi	r31, 0x00	; 0
    5f46:	80 81       	ld	r24, Z
    5f48:	8f 78       	andi	r24, 0x8F	; 143
    5f4a:	80 83       	st	Z, r24
    PCICR &= ~(1 << LIMIT_INT);  // Disable Pin Change Interrupt
    5f4c:	e8 e6       	ldi	r30, 0x68	; 104
    5f4e:	f0 e0       	ldi	r31, 0x00	; 0
    5f50:	80 81       	ld	r24, Z
    5f52:	8e 7f       	andi	r24, 0xFE	; 254
    5f54:	80 83       	st	Z, r24
    5f56:	08 95       	ret

00005f58 <limits_init>:
        WDTCSR |= (1<<WDCE) | (1<<WDE);
        WDTCSR = (1<<WDP0); // Set time-out at ~32msec.
      #endif
    #endif // DISABLE_HW_LIMITS
  #else
    LIMIT_DDR &= ~(LIMIT_MASK); // Set as input pins
    5f58:	84 b1       	in	r24, 0x04	; 4
    5f5a:	8f 78       	andi	r24, 0x8F	; 143
    5f5c:	84 b9       	out	0x04, r24	; 4

    #ifdef DISABLE_LIMIT_PIN_PULL_UP
      LIMIT_PORT &= ~(LIMIT_MASK); // Normal low operation. Requires external pull-down.
    #else
      LIMIT_PORT |= (LIMIT_MASK);  // Enable internal pull-up resistors. Normal high operation.
    5f5e:	85 b1       	in	r24, 0x05	; 5
    5f60:	80 67       	ori	r24, 0x70	; 112
    5f62:	85 b9       	out	0x05, r24	; 5
    #endif

    if (bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE)) {
    5f64:	80 91 05 0f 	lds	r24, 0x0F05	; 0x800f05 <settings+0x45>
    5f68:	83 ff       	sbrs	r24, 3
    5f6a:	0b c0       	rjmp	.+22     	; 0x5f82 <limits_init+0x2a>
      LIMIT_PCMSK |= LIMIT_MASK; // Enable specific pins of the Pin Change Interrupt
    5f6c:	eb e6       	ldi	r30, 0x6B	; 107
    5f6e:	f0 e0       	ldi	r31, 0x00	; 0
    5f70:	80 81       	ld	r24, Z
    5f72:	80 67       	ori	r24, 0x70	; 112
    5f74:	80 83       	st	Z, r24
      PCICR |= (1 << LIMIT_INT); // Enable Pin Change Interrupt
    5f76:	e8 e6       	ldi	r30, 0x68	; 104
    5f78:	f0 e0       	ldi	r31, 0x00	; 0
    5f7a:	80 81       	ld	r24, Z
    5f7c:	81 60       	ori	r24, 0x01	; 1
    5f7e:	80 83       	st	Z, r24
    5f80:	01 c0       	rjmp	.+2      	; 0x5f84 <limits_init+0x2c>
    } else {
      limits_disable();
    5f82:	df df       	rcall	.-66     	; 0x5f42 <limits_disable>
    }
  
    #ifdef ENABLE_SOFTWARE_DEBOUNCE
      MCUSR &= ~(1<<WDRF);
    5f84:	84 b7       	in	r24, 0x34	; 52
    5f86:	87 7f       	andi	r24, 0xF7	; 247
    5f88:	84 bf       	out	0x34, r24	; 52
      WDTCSR |= (1<<WDCE) | (1<<WDE);
    5f8a:	e0 e6       	ldi	r30, 0x60	; 96
    5f8c:	f0 e0       	ldi	r31, 0x00	; 0
    5f8e:	80 81       	ld	r24, Z
    5f90:	88 61       	ori	r24, 0x18	; 24
    5f92:	80 83       	st	Z, r24
      WDTCSR = (1<<WDP0); // Set time-out at ~32msec.
    5f94:	81 e0       	ldi	r24, 0x01	; 1
    5f96:	80 83       	st	Z, r24
    5f98:	08 95       	ret

00005f9a <limits_get_state>:

// Returns limit state as a bit-wise uint8 variable. Each bit indicates an axis limit, where 
// triggered is 1 and not triggered is 0. Invert mask is applied. Axes are defined by their
// number in bit position, i.e. Z_AXIS is (1<<2) or bit 2, and Y_AXIS is (1<<1) or bit 1.
uint8_t limits_get_state()
{
    5f9a:	ef 92       	push	r14
    5f9c:	ff 92       	push	r15
    5f9e:	0f 93       	push	r16
    5fa0:	1f 93       	push	r17
    5fa2:	cf 93       	push	r28
    5fa4:	df 93       	push	r29
      if (pin)
        limit_state |= (1 << idx);
    } 
    //return(limit_state);
  #else
    uint8_t pin = (LIMIT_PIN & LIMIT_MASK);
    5fa6:	c3 b1       	in	r28, 0x03	; 3
    5fa8:	c0 77       	andi	r28, 0x70	; 112
    #ifdef INVERT_LIMIT_PIN_MASK
      pin ^= INVERT_LIMIT_PIN_MASK;
    #endif
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
    5faa:	80 91 05 0f 	lds	r24, 0x0F05	; 0x800f05 <settings+0x45>
    5fae:	86 fd       	sbrc	r24, 6
    5fb0:	2b c0       	rjmp	.+86     	; 0x6008 <limits_get_state+0x6e>
    5fb2:	80 e7       	ldi	r24, 0x70	; 112
    5fb4:	c8 27       	eor	r28, r24
    5fb6:	28 c0       	rjmp	.+80     	; 0x6008 <limits_get_state+0x6e>
    if (pin) {  
    5fb8:	00 e0       	ldi	r16, 0x00	; 0
    5fba:	10 e0       	ldi	r17, 0x00	; 0
    5fbc:	d0 e0       	ldi	r29, 0x00	; 0
      uint8_t idx;
      for (idx=0; idx<N_AXIS; idx++) {
        if (pin & get_limit_pin_mask(idx)) { limit_state |= (1 << idx); }
    5fbe:	ee 24       	eor	r14, r14
    5fc0:	e3 94       	inc	r14
    5fc2:	f1 2c       	mov	r15, r1
    5fc4:	80 2f       	mov	r24, r16
    5fc6:	0e 94 4d 27 	call	0x4e9a	; 0x4e9a <get_limit_pin_mask>
    5fca:	8c 23       	and	r24, r28
    5fcc:	41 f0       	breq	.+16     	; 0x5fde <limits_get_state+0x44>
    5fce:	c7 01       	movw	r24, r14
    5fd0:	00 2e       	mov	r0, r16
    5fd2:	02 c0       	rjmp	.+4      	; 0x5fd8 <limits_get_state+0x3e>
    5fd4:	88 0f       	add	r24, r24
    5fd6:	99 1f       	adc	r25, r25
    5fd8:	0a 94       	dec	r0
    5fda:	e2 f7       	brpl	.-8      	; 0x5fd4 <limits_get_state+0x3a>
    5fdc:	d8 2b       	or	r29, r24
    5fde:	0f 5f       	subi	r16, 0xFF	; 255
    5fe0:	1f 4f       	sbci	r17, 0xFF	; 255
      pin ^= INVERT_LIMIT_PIN_MASK;
    #endif
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
    if (pin) {  
      uint8_t idx;
      for (idx=0; idx<N_AXIS; idx++) {
    5fe2:	03 30       	cpi	r16, 0x03	; 3
    5fe4:	11 05       	cpc	r17, r1
    5fe6:	71 f7       	brne	.-36     	; 0x5fc4 <limits_get_state+0x2a>
    }
    //return(limit_state);
  #endif //DEFAULTS_RAMPS_BOARD
//Ignore Hardware Limit triggers on the Y-Axis (Spindle Index Pulse) when LATHE is defined and not Homing, signal index pulse received when not homing
  #ifdef LATHE
	if (sys.state!=STATE_HOMING) {						//when not homing
    5fe8:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
    5fec:	84 30       	cpi	r24, 0x04	; 4
    5fee:	81 f0       	breq	.+32     	; 0x6010 <limits_get_state+0x76>
	  limit_state &= ~(1<<Y_AXIS);						//Clear state to avoid limit triggered alarm
    5ff0:	dd 7f       	andi	r29, 0xFD	; 253
      if (pin & get_limit_pin_mask(Y_AXIS))				//If the limit input is set
    5ff2:	81 e0       	ldi	r24, 0x01	; 1
    5ff4:	0e 94 4d 27 	call	0x4e9a	; 0x4e9a <get_limit_pin_mask>
    5ff8:	8c 23       	and	r24, r28
    5ffa:	51 f0       	breq	.+20     	; 0x6010 <limits_get_state+0x76>
	    bit_true(sys_sync_state, EXEC_SPINDLE_INDEX);	//Signal the receive of a spindle index pulse
    5ffc:	80 91 10 0c 	lds	r24, 0x0C10	; 0x800c10 <sys_sync_state>
    6000:	81 60       	ori	r24, 0x01	; 1
    6002:	80 93 10 0c 	sts	0x0C10, r24	; 0x800c10 <sys_sync_state>
	}
  #endif
  return(limit_state);
    6006:	04 c0       	rjmp	.+8      	; 0x6010 <limits_get_state+0x76>
    uint8_t pin = (LIMIT_PIN & LIMIT_MASK);
    #ifdef INVERT_LIMIT_PIN_MASK
      pin ^= INVERT_LIMIT_PIN_MASK;
    #endif
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
    if (pin) {  
    6008:	c1 11       	cpse	r28, r1
    600a:	d6 cf       	rjmp	.-84     	; 0x5fb8 <limits_get_state+0x1e>
// Returns limit state as a bit-wise uint8 variable. Each bit indicates an axis limit, where 
// triggered is 1 and not triggered is 0. Invert mask is applied. Axes are defined by their
// number in bit position, i.e. Z_AXIS is (1<<2) or bit 2, and Y_AXIS is (1<<1) or bit 1.
uint8_t limits_get_state()
{
  uint8_t limit_state = 0;
    600c:	d0 e0       	ldi	r29, 0x00	; 0
    600e:	ec cf       	rjmp	.-40     	; 0x5fe8 <limits_get_state+0x4e>
      if (pin & get_limit_pin_mask(Y_AXIS))				//If the limit input is set
	    bit_true(sys_sync_state, EXEC_SPINDLE_INDEX);	//Signal the receive of a spindle index pulse
	}
  #endif
  return(limit_state);
}
    6010:	8d 2f       	mov	r24, r29
    6012:	df 91       	pop	r29
    6014:	cf 91       	pop	r28
    6016:	1f 91       	pop	r17
    6018:	0f 91       	pop	r16
    601a:	ff 90       	pop	r15
    601c:	ef 90       	pop	r14
    601e:	08 95       	ret

00006020 <__vector_9>:
        }
      }
    }  
  #else // OPTIONAL: Software debounce limit pin routine.
    // Upon limit pin change, enable watchdog timer to create a short delay. 
    ISR(LIMIT_INT_vect) { if (!(WDTCSR & (1<<WDIE))) { WDTCSR |= (1<<WDIE); } }
    6020:	1f 92       	push	r1
    6022:	0f 92       	push	r0
    6024:	0f b6       	in	r0, 0x3f	; 63
    6026:	0f 92       	push	r0
    6028:	11 24       	eor	r1, r1
    602a:	0b b6       	in	r0, 0x3b	; 59
    602c:	0f 92       	push	r0
    602e:	8f 93       	push	r24
    6030:	ef 93       	push	r30
    6032:	ff 93       	push	r31
    6034:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    6038:	86 fd       	sbrc	r24, 6
    603a:	05 c0       	rjmp	.+10     	; 0x6046 <__vector_9+0x26>
    603c:	e0 e6       	ldi	r30, 0x60	; 96
    603e:	f0 e0       	ldi	r31, 0x00	; 0
    6040:	80 81       	ld	r24, Z
    6042:	80 64       	ori	r24, 0x40	; 64
    6044:	80 83       	st	Z, r24
    6046:	ff 91       	pop	r31
    6048:	ef 91       	pop	r30
    604a:	8f 91       	pop	r24
    604c:	0f 90       	pop	r0
    604e:	0b be       	out	0x3b, r0	; 59
    6050:	0f 90       	pop	r0
    6052:	0f be       	out	0x3f, r0	; 63
    6054:	0f 90       	pop	r0
    6056:	1f 90       	pop	r1
    6058:	18 95       	reti

0000605a <__vector_12>:
    ISR(WDT_vect) // Watchdog timer ISR
    {
    605a:	1f 92       	push	r1
    605c:	0f 92       	push	r0
    605e:	0f b6       	in	r0, 0x3f	; 63
    6060:	0f 92       	push	r0
    6062:	11 24       	eor	r1, r1
    6064:	0b b6       	in	r0, 0x3b	; 59
    6066:	0f 92       	push	r0
    6068:	2f 93       	push	r18
    606a:	3f 93       	push	r19
    606c:	4f 93       	push	r20
    606e:	5f 93       	push	r21
    6070:	6f 93       	push	r22
    6072:	7f 93       	push	r23
    6074:	8f 93       	push	r24
    6076:	9f 93       	push	r25
    6078:	af 93       	push	r26
    607a:	bf 93       	push	r27
    607c:	ef 93       	push	r30
    607e:	ff 93       	push	r31
      WDTCSR &= ~(1<<WDIE); // Disable watchdog timer. 
    6080:	e0 e6       	ldi	r30, 0x60	; 96
    6082:	f0 e0       	ldi	r31, 0x00	; 0
    6084:	80 81       	ld	r24, Z
    6086:	8f 7b       	andi	r24, 0xBF	; 191
    6088:	80 83       	st	Z, r24
      if (sys.state != STATE_ALARM) {  // Ignore if already in alarm state. 
    608a:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
    608e:	81 30       	cpi	r24, 0x01	; 1
    6090:	61 f0       	breq	.+24     	; 0x60aa <__vector_12+0x50>
        if (!(sys_rt_exec_alarm)) {
    6092:	80 91 43 0c 	lds	r24, 0x0C43	; 0x800c43 <sys_rt_exec_alarm>
    6096:	81 11       	cpse	r24, r1
    6098:	08 c0       	rjmp	.+16     	; 0x60aa <__vector_12+0x50>
          // Check limit pin state. 
          if (limits_get_state()) {
    609a:	7f df       	rcall	.-258    	; 0x5f9a <limits_get_state>
    609c:	88 23       	and	r24, r24
    609e:	29 f0       	breq	.+10     	; 0x60aa <__vector_12+0x50>
            mc_reset(); // Initiate system kill.
    60a0:	0e 94 cb 06 	call	0xd96	; 0xd96 <mc_reset>
            system_set_exec_alarm(EXEC_ALARM_HARD_LIMIT); // Indicate hard limit critical event
    60a4:	81 e0       	ldi	r24, 0x01	; 1
    60a6:	0e 94 5d 3d 	call	0x7aba	; 0x7aba <system_set_exec_alarm>
          }
        }  
      }
    }
    60aa:	ff 91       	pop	r31
    60ac:	ef 91       	pop	r30
    60ae:	bf 91       	pop	r27
    60b0:	af 91       	pop	r26
    60b2:	9f 91       	pop	r25
    60b4:	8f 91       	pop	r24
    60b6:	7f 91       	pop	r23
    60b8:	6f 91       	pop	r22
    60ba:	5f 91       	pop	r21
    60bc:	4f 91       	pop	r20
    60be:	3f 91       	pop	r19
    60c0:	2f 91       	pop	r18
    60c2:	0f 90       	pop	r0
    60c4:	0b be       	out	0x3b, r0	; 59
    60c6:	0f 90       	pop	r0
    60c8:	0f be       	out	0x3f, r0	; 63
    60ca:	0f 90       	pop	r0
    60cc:	1f 90       	pop	r1
    60ce:	18 95       	reti

000060d0 <limits_go_home>:
// mask, which prevents the stepper algorithm from executing step pulses. Homing motions typically
// circumvent the processes for executing motions in normal operation.
// NOTE: Only the abort realtime command can interrupt this process.
// TODO: Move limit pin-specific calls to a general function for portability.
void limits_go_home(uint8_t cycle_mask)
{
    60d0:	2f 92       	push	r2
    60d2:	3f 92       	push	r3
    60d4:	4f 92       	push	r4
    60d6:	5f 92       	push	r5
    60d8:	6f 92       	push	r6
    60da:	7f 92       	push	r7
    60dc:	8f 92       	push	r8
    60de:	9f 92       	push	r9
    60e0:	af 92       	push	r10
    60e2:	bf 92       	push	r11
    60e4:	cf 92       	push	r12
    60e6:	df 92       	push	r13
    60e8:	ef 92       	push	r14
    60ea:	ff 92       	push	r15
    60ec:	0f 93       	push	r16
    60ee:	1f 93       	push	r17
    60f0:	cf 93       	push	r28
    60f2:	df 93       	push	r29
    60f4:	cd b7       	in	r28, 0x3d	; 61
    60f6:	de b7       	in	r29, 0x3e	; 62
    60f8:	a9 97       	sbiw	r28, 0x29	; 41
    60fa:	0f b6       	in	r0, 0x3f	; 63
    60fc:	f8 94       	cli
    60fe:	de bf       	out	0x3e, r29	; 62
    6100:	0f be       	out	0x3f, r0	; 63
    6102:	cd bf       	out	0x3d, r28	; 61
  if (sys.abort) { return; } // Block if system reset has been issued.
    6104:	90 91 17 0c 	lds	r25, 0x0C17	; 0x800c17 <sys+0x1>
    6108:	91 11       	cpse	r25, r1
    610a:	e1 c1       	rjmp	.+962    	; 0x64ce <limits_go_home+0x3fe>
    610c:	8f a3       	std	Y+39, r24	; 0x27

  // Initialize plan data struct for homing motion. Spindle and coolant are disabled.
  plan_line_data_t plan_data;
  plan_line_data_t *pl_data = &plan_data;
  memset(pl_data,0,sizeof(plan_line_data_t));
    610e:	fe 01       	movw	r30, r28
    6110:	31 96       	adiw	r30, 0x01	; 1
    6112:	8d e0       	ldi	r24, 0x0D	; 13
    6114:	df 01       	movw	r26, r30
    6116:	1d 92       	st	X+, r1
    6118:	8a 95       	dec	r24
    611a:	e9 f7       	brne	.-6      	; 0x6116 <limits_go_home+0x46>
  pl_data->condition = (PL_COND_FLAG_SYSTEM_MOTION|PL_COND_FLAG_NO_FEED_OVERRIDE);
    611c:	86 e0       	ldi	r24, 0x06	; 6
    611e:	8d 87       	std	Y+13, r24	; 0x0d
    6120:	e0 ec       	ldi	r30, 0xC0	; 192
    6122:	fe e0       	ldi	r31, 0x0E	; 14
    6124:	fc a3       	std	Y+36, r31	; 0x24
    6126:	eb a3       	std	Y+35, r30	; 0x23
    6128:	7f 01       	movw	r14, r30
    612a:	9e 01       	movw	r18, r28
    612c:	22 5f       	subi	r18, 0xF2	; 242
    612e:	3f 4f       	sbci	r19, 0xFF	; 255
    6130:	59 01       	movw	r10, r18
    6132:	00 e0       	ldi	r16, 0x00	; 0
    6134:	10 e0       	ldi	r17, 0x00	; 0

  // Initialize variables used for homing computations.
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  uint8_t step_pin[N_AXIS];
  float target[N_AXIS];
  float max_travel = 0.0;
    6136:	41 2c       	mov	r4, r1
    6138:	51 2c       	mov	r5, r1
    613a:	32 01       	movw	r6, r4
    step_pin[idx] = get_step_pin_mask(idx);
    #ifdef COREXY
      if ((idx==A_MOTOR)||(idx==B_MOTOR)) { step_pin[idx] = (get_step_pin_mask(X_AXIS)|get_step_pin_mask(Y_AXIS)); }
    #endif

    if (bit_istrue(cycle_mask,bit(idx))) {
    613c:	3f a1       	ldd	r19, Y+39	; 0x27
    613e:	c3 2e       	mov	r12, r19
    6140:	d1 2c       	mov	r13, r1
  float target[N_AXIS];
  float max_travel = 0.0;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    // Initialize step pin masks
    step_pin[idx] = get_step_pin_mask(idx);
    6142:	80 2f       	mov	r24, r16
    6144:	0e 94 39 27 	call	0x4e72	; 0x4e72 <get_step_pin_mask>
    6148:	d5 01       	movw	r26, r10
    614a:	8d 93       	st	X+, r24
    614c:	5d 01       	movw	r10, r26
    #ifdef COREXY
      if ((idx==A_MOTOR)||(idx==B_MOTOR)) { step_pin[idx] = (get_step_pin_mask(X_AXIS)|get_step_pin_mask(Y_AXIS)); }
    #endif

    if (bit_istrue(cycle_mask,bit(idx))) {
    614e:	de 8e       	std	Y+30, r13	; 0x1e
    6150:	cd 8e       	std	Y+29, r12	; 0x1d
    6152:	c6 01       	movw	r24, r12
    6154:	00 2e       	mov	r0, r16
    6156:	02 c0       	rjmp	.+4      	; 0x615c <limits_go_home+0x8c>
    6158:	95 95       	asr	r25
    615a:	87 95       	ror	r24
    615c:	0a 94       	dec	r0
    615e:	e2 f7       	brpl	.-8      	; 0x6158 <limits_go_home+0x88>
    6160:	80 ff       	sbrs	r24, 0
    6162:	19 c0       	rjmp	.+50     	; 0x6196 <limits_go_home+0xc6>
      // Set target based on max_travel setting. Ensure homing switches engaged with search scalar.
      // NOTE: settings.max_travel[] is stored as a negative value.
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    6164:	20 e0       	ldi	r18, 0x00	; 0
    6166:	30 e0       	ldi	r19, 0x00	; 0
    6168:	40 ec       	ldi	r20, 0xC0	; 192
    616a:	5f eb       	ldi	r21, 0xBF	; 191
    616c:	f7 01       	movw	r30, r14
    616e:	64 a1       	ldd	r22, Z+36	; 0x24
    6170:	75 a1       	ldd	r23, Z+37	; 0x25
    6172:	86 a1       	ldd	r24, Z+38	; 0x26
    6174:	97 a1       	ldd	r25, Z+39	; 0x27
    6176:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    617a:	86 2e       	mov	r8, r22
    617c:	97 2e       	mov	r9, r23
    617e:	28 2e       	mov	r2, r24
    6180:	39 2e       	mov	r3, r25
    6182:	a3 01       	movw	r20, r6
    6184:	92 01       	movw	r18, r4
    6186:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    618a:	88 23       	and	r24, r24
    618c:	24 f0       	brlt	.+8      	; 0x6196 <limits_go_home+0xc6>
    618e:	48 2c       	mov	r4, r8
    6190:	59 2c       	mov	r5, r9
    6192:	62 2c       	mov	r6, r2
    6194:	73 2c       	mov	r7, r3
    6196:	0f 5f       	subi	r16, 0xFF	; 255
    6198:	1f 4f       	sbci	r17, 0xFF	; 255
    619a:	f4 e0       	ldi	r31, 0x04	; 4
    619c:	ef 0e       	add	r14, r31
    619e:	f1 1c       	adc	r15, r1
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  uint8_t step_pin[N_AXIS];
  float target[N_AXIS];
  float max_travel = 0.0;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    61a0:	03 30       	cpi	r16, 0x03	; 3
    61a2:	11 05       	cpc	r17, r1
    61a4:	71 f6       	brne	.-100    	; 0x6142 <limits_go_home+0x72>
    61a6:	2d 8c       	ldd	r2, Y+29	; 0x1d
    61a8:	3e 8c       	ldd	r3, Y+30	; 0x1e
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    }
  }
  // Set search mode with approach at seek rate to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
  float homing_rate = settings.homing_seek_rate;
    61aa:	80 91 0b 0f 	lds	r24, 0x0F0B	; 0x800f0b <settings+0x4b>
    61ae:	90 91 0c 0f 	lds	r25, 0x0F0C	; 0x800f0c <settings+0x4c>
    61b2:	a0 91 0d 0f 	lds	r26, 0x0F0D	; 0x800f0d <settings+0x4d>
    61b6:	b0 91 0e 0f 	lds	r27, 0x0F0E	; 0x800f0e <settings+0x4e>
    61ba:	8f 8f       	std	Y+31, r24	; 0x1f
    61bc:	98 a3       	std	Y+32, r25	; 0x20
    61be:	a9 a3       	std	Y+33, r26	; 0x21
    61c0:	ba a3       	std	Y+34, r27	; 0x22
    61c2:	94 e0       	ldi	r25, 0x04	; 4
    61c4:	9d 8f       	std	Y+29, r25	; 0x1d
      // NOTE: settings.max_travel[] is stored as a negative value.
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    }
  }
  // Set search mode with approach at seek rate to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
    61c6:	01 e0       	ldi	r16, 0x01	; 1
          axislock |= step_pin[idx];
        }

      }
      homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
      sys.homing_axis_lock = axislock;
    61c8:	0f 2e       	mov	r0, r31
    61ca:	f6 e1       	ldi	r31, 0x16	; 22
    61cc:	cf 2e       	mov	r12, r31
    61ce:	fc e0       	ldi	r31, 0x0C	; 12
    61d0:	df 2e       	mov	r13, r31
    61d2:	f0 2d       	mov	r31, r0
    } while (n_cycle-- > 0);
  #else
    uint8_t limit_state, axislock, n_active_axis;
    do {

      system_convert_array_steps_to_mpos(target,sys_position);
    61d4:	67 e3       	ldi	r22, 0x37	; 55
    61d6:	7c e0       	ldi	r23, 0x0C	; 12
    61d8:	ce 01       	movw	r24, r28
    61da:	41 96       	adiw	r24, 0x11	; 17
    61dc:	0e 94 76 3a 	call	0x74ec	; 0x74ec <system_convert_array_steps_to_mpos>
          #else
            sys_position[idx] = 0;
          #endif
          // Set target direction based on cycle mask and homing cycle approach state.
          // NOTE: This happens to compile smaller than any other implementation tried.
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
    61e0:	a6 e0       	ldi	r26, 0x06	; 6
    61e2:	bf e0       	ldi	r27, 0x0F	; 15
    61e4:	ec 90       	ld	r14, X
    61e6:	f1 2c       	mov	r15, r1
    61e8:	ae 01       	movw	r20, r28
    61ea:	4f 5e       	subi	r20, 0xEF	; 239
    61ec:	5f 4f       	sbci	r21, 0xFF	; 255
    61ee:	e7 e3       	ldi	r30, 0x37	; 55
    61f0:	fc e0       	ldi	r31, 0x0C	; 12
    61f2:	fe a3       	std	Y+38, r31	; 0x26
    61f4:	ed a3       	std	Y+37, r30	; 0x25
    61f6:	de 01       	movw	r26, r28
    61f8:	1e 96       	adiw	r26, 0x0e	; 14
    61fa:	80 e0       	ldi	r24, 0x00	; 0
    61fc:	90 e0       	ldi	r25, 0x00	; 0

      system_convert_array_steps_to_mpos(target,sys_position);

      // Initialize and declare variables needed for homing routine.
      axislock = 0;
      n_active_axis = 0;
    61fe:	60 e0       	ldi	r22, 0x00	; 0
    do {

      system_convert_array_steps_to_mpos(target,sys_position);

      // Initialize and declare variables needed for homing routine.
      axislock = 0;
    6200:	10 e0       	ldi	r17, 0x00	; 0
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
            if (approach) { target[idx] = -max_travel; }
            else { target[idx] = max_travel; }
          } else {
            if (approach) { target[idx] = max_travel; }
            else { target[idx] = -max_travel; }
    6202:	53 01       	movw	r10, r6
    6204:	42 01       	movw	r8, r4
    6206:	b7 fa       	bst	r11, 7
    6208:	b0 94       	com	r11
    620a:	b7 f8       	bld	r11, 7
    620c:	b0 94       	com	r11
    620e:	b9 a7       	std	Y+41, r27	; 0x29
    6210:	a8 a7       	std	Y+40, r26	; 0x28
      // Initialize and declare variables needed for homing routine.
      axislock = 0;
      n_active_axis = 0;
      for (idx=0; idx<N_AXIS; idx++) {
        // Set target location for active axes and setup computation for homing rate.
        if (bit_istrue(cycle_mask,bit(idx))) {
    6212:	91 01       	movw	r18, r2
    6214:	08 2e       	mov	r0, r24
    6216:	02 c0       	rjmp	.+4      	; 0x621c <limits_go_home+0x14c>
    6218:	35 95       	asr	r19
    621a:	27 95       	ror	r18
    621c:	0a 94       	dec	r0
    621e:	e2 f7       	brpl	.-8      	; 0x6218 <limits_go_home+0x148>
    6220:	20 ff       	sbrs	r18, 0
    6222:	31 c0       	rjmp	.+98     	; 0x6286 <limits_go_home+0x1b6>
          n_active_axis++;
    6224:	6f 5f       	subi	r22, 0xFF	; 255
              sys_position[A_MOTOR] = sys_position[B_MOTOR] = axis_position;
            } else {
              sys_position[Z_AXIS] = 0;
            }
          #else
            sys_position[idx] = 0;
    6226:	10 82       	st	Z, r1
    6228:	11 82       	std	Z+1, r1	; 0x01
    622a:	12 82       	std	Z+2, r1	; 0x02
    622c:	13 82       	std	Z+3, r1	; 0x03
          #endif
          // Set target direction based on cycle mask and homing cycle approach state.
          // NOTE: This happens to compile smaller than any other implementation tried.
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
    622e:	97 01       	movw	r18, r14
    6230:	08 2e       	mov	r0, r24
    6232:	02 c0       	rjmp	.+4      	; 0x6238 <limits_go_home+0x168>
    6234:	35 95       	asr	r19
    6236:	27 95       	ror	r18
    6238:	0a 94       	dec	r0
    623a:	e2 f7       	brpl	.-8      	; 0x6234 <limits_go_home+0x164>
    623c:	20 ff       	sbrs	r18, 0
    623e:	10 c0       	rjmp	.+32     	; 0x6260 <limits_go_home+0x190>
            if (approach) { target[idx] = -max_travel; }
    6240:	00 23       	and	r16, r16
    6242:	39 f0       	breq	.+14     	; 0x6252 <limits_go_home+0x182>
    6244:	da 01       	movw	r26, r20
    6246:	8d 92       	st	X+, r8
    6248:	9d 92       	st	X+, r9
    624a:	ad 92       	st	X+, r10
    624c:	bc 92       	st	X, r11
    624e:	13 97       	sbiw	r26, 0x03	; 3
    6250:	16 c0       	rjmp	.+44     	; 0x627e <limits_go_home+0x1ae>
            else { target[idx] = max_travel; }
    6252:	da 01       	movw	r26, r20
    6254:	4d 92       	st	X+, r4
    6256:	5d 92       	st	X+, r5
    6258:	6d 92       	st	X+, r6
    625a:	7c 92       	st	X, r7
    625c:	13 97       	sbiw	r26, 0x03	; 3
    625e:	0f c0       	rjmp	.+30     	; 0x627e <limits_go_home+0x1ae>
          } else {
            if (approach) { target[idx] = max_travel; }
    6260:	00 23       	and	r16, r16
    6262:	39 f0       	breq	.+14     	; 0x6272 <limits_go_home+0x1a2>
    6264:	da 01       	movw	r26, r20
    6266:	4d 92       	st	X+, r4
    6268:	5d 92       	st	X+, r5
    626a:	6d 92       	st	X+, r6
    626c:	7c 92       	st	X, r7
    626e:	13 97       	sbiw	r26, 0x03	; 3
    6270:	06 c0       	rjmp	.+12     	; 0x627e <limits_go_home+0x1ae>
            else { target[idx] = -max_travel; }
    6272:	da 01       	movw	r26, r20
    6274:	8d 92       	st	X+, r8
    6276:	9d 92       	st	X+, r9
    6278:	ad 92       	st	X+, r10
    627a:	bc 92       	st	X, r11
    627c:	13 97       	sbiw	r26, 0x03	; 3
          }
          // Apply axislock to the step port pins active in this cycle.
          axislock |= step_pin[idx];
    627e:	a8 a5       	ldd	r26, Y+40	; 0x28
    6280:	b9 a5       	ldd	r27, Y+41	; 0x29
    6282:	2c 91       	ld	r18, X
    6284:	12 2b       	or	r17, r18
    6286:	01 96       	adiw	r24, 0x01	; 1
    6288:	28 a5       	ldd	r18, Y+40	; 0x28
    628a:	39 a5       	ldd	r19, Y+41	; 0x29
    628c:	2f 5f       	subi	r18, 0xFF	; 255
    628e:	3f 4f       	sbci	r19, 0xFF	; 255
    6290:	39 a7       	std	Y+41, r19	; 0x29
    6292:	28 a7       	std	Y+40, r18	; 0x28
    6294:	4c 5f       	subi	r20, 0xFC	; 252
    6296:	5f 4f       	sbci	r21, 0xFF	; 255
    6298:	34 96       	adiw	r30, 0x04	; 4
      system_convert_array_steps_to_mpos(target,sys_position);

      // Initialize and declare variables needed for homing routine.
      axislock = 0;
      n_active_axis = 0;
      for (idx=0; idx<N_AXIS; idx++) {
    629a:	83 30       	cpi	r24, 0x03	; 3
    629c:	91 05       	cpc	r25, r1
    629e:	09 f0       	breq	.+2      	; 0x62a2 <limits_go_home+0x1d2>
    62a0:	b8 cf       	rjmp	.-144    	; 0x6212 <limits_go_home+0x142>
          // Apply axislock to the step port pins active in this cycle.
          axislock |= step_pin[idx];
        }

      }
      homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
    62a2:	46 2e       	mov	r4, r22
    62a4:	51 2c       	mov	r5, r1
    62a6:	61 2c       	mov	r6, r1
    62a8:	71 2c       	mov	r7, r1
    62aa:	c3 01       	movw	r24, r6
    62ac:	b2 01       	movw	r22, r4
    62ae:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__floatunsisf>
    62b2:	0e 94 90 41 	call	0x8320	; 0x8320 <sqrt>
    62b6:	9b 01       	movw	r18, r22
    62b8:	ac 01       	movw	r20, r24
      sys.homing_axis_lock = axislock;
    62ba:	d6 01       	movw	r26, r12
    62bc:	16 96       	adiw	r26, 0x06	; 6
    62be:	1c 93       	st	X, r17

      // Perform homing cycle. Planner buffer should be empty, as required to initiate the homing cycle.
      pl_data->feed_rate = homing_rate; // Set current homing rate.
    62c0:	6f 8d       	ldd	r22, Y+31	; 0x1f
    62c2:	78 a1       	ldd	r23, Y+32	; 0x20
    62c4:	89 a1       	ldd	r24, Y+33	; 0x21
    62c6:	9a a1       	ldd	r25, Y+34	; 0x22
    62c8:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    62cc:	69 83       	std	Y+1, r22	; 0x01
    62ce:	7a 83       	std	Y+2, r23	; 0x02
    62d0:	8b 83       	std	Y+3, r24	; 0x03
    62d2:	9c 83       	std	Y+4, r25	; 0x04
      plan_buffer_line(target, pl_data); // Bypass mc_line(). Directly plan homing motion.
    62d4:	be 01       	movw	r22, r28
    62d6:	6f 5f       	subi	r22, 0xFF	; 255
    62d8:	7f 4f       	sbci	r23, 0xFF	; 255
    62da:	ce 01       	movw	r24, r28
    62dc:	41 96       	adiw	r24, 0x11	; 17
    62de:	e4 d8       	rcall	.-3640   	; 0x54a8 <plan_buffer_line>

      sys.step_control = STEP_CONTROL_EXECUTE_SYS_MOTION; // Set to execute homing motion and clear existing flags.
    62e0:	24 e0       	ldi	r18, 0x04	; 4
    62e2:	f6 01       	movw	r30, r12
    62e4:	24 83       	std	Z+4, r18	; 0x04
      st_prep_buffer(); // Prep and fill segment buffer from newly planned block.
    62e6:	0e 94 b4 1b 	call	0x3768	; 0x3768 <st_prep_buffer>
      st_wake_up(); // Initiate motion
    62ea:	0e 94 a7 18 	call	0x314e	; 0x314e <st_wake_up>
      do {
        if (approach) {
    62ee:	00 23       	and	r16, r16
    62f0:	f1 f0       	breq	.+60     	; 0x632e <limits_go_home+0x25e>
          // Check limit state. Lock out cycle axes when they change.
          limit_state = limits_get_state();
    62f2:	53 de       	rcall	.-858    	; 0x5f9a <limits_get_state>
    62f4:	fe 01       	movw	r30, r28
    62f6:	3e 96       	adiw	r30, 0x0e	; 14
    62f8:	20 e0       	ldi	r18, 0x00	; 0
    62fa:	30 e0       	ldi	r19, 0x00	; 0
          for (idx=0; idx<N_AXIS; idx++) {
            if (axislock & step_pin[idx]) {
              if (limit_state & (1 << idx)) {
    62fc:	68 2f       	mov	r22, r24
    62fe:	70 e0       	ldi	r23, 0x00	; 0
      do {
        if (approach) {
          // Check limit state. Lock out cycle axes when they change.
          limit_state = limits_get_state();
          for (idx=0; idx<N_AXIS; idx++) {
            if (axislock & step_pin[idx]) {
    6300:	81 91       	ld	r24, Z+
    6302:	98 2f       	mov	r25, r24
    6304:	91 23       	and	r25, r17
    6306:	59 f0       	breq	.+22     	; 0x631e <limits_go_home+0x24e>
              if (limit_state & (1 << idx)) {
    6308:	ab 01       	movw	r20, r22
    630a:	02 2e       	mov	r0, r18
    630c:	02 c0       	rjmp	.+4      	; 0x6312 <limits_go_home+0x242>
    630e:	55 95       	asr	r21
    6310:	47 95       	ror	r20
    6312:	0a 94       	dec	r0
    6314:	e2 f7       	brpl	.-8      	; 0x630e <limits_go_home+0x23e>
    6316:	40 ff       	sbrs	r20, 0
    6318:	02 c0       	rjmp	.+4      	; 0x631e <limits_go_home+0x24e>
                #ifdef COREXY
                  if (idx==Z_AXIS) { axislock &= ~(step_pin[Z_AXIS]); }
                  else { axislock &= ~(step_pin[A_MOTOR]|step_pin[B_MOTOR]); }
                #else
                  axislock &= ~(step_pin[idx]);
    631a:	80 95       	com	r24
    631c:	18 23       	and	r17, r24
    631e:	2f 5f       	subi	r18, 0xFF	; 255
    6320:	3f 4f       	sbci	r19, 0xFF	; 255
      st_wake_up(); // Initiate motion
      do {
        if (approach) {
          // Check limit state. Lock out cycle axes when they change.
          limit_state = limits_get_state();
          for (idx=0; idx<N_AXIS; idx++) {
    6322:	23 30       	cpi	r18, 0x03	; 3
    6324:	31 05       	cpc	r19, r1
    6326:	61 f7       	brne	.-40     	; 0x6300 <limits_go_home+0x230>
                  axislock &= ~(step_pin[idx]);
                #endif
              }
            }
          }
          sys.homing_axis_lock = axislock;
    6328:	d6 01       	movw	r26, r12
    632a:	16 96       	adiw	r26, 0x06	; 6
    632c:	1c 93       	st	X, r17
        }

        st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
    632e:	0e 94 b4 1b 	call	0x3768	; 0x3768 <st_prep_buffer>

        // Exit routines: No time to run protocol_execute_realtime() in this loop.
        if (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET | EXEC_CYCLE_STOP)) {
    6332:	80 91 29 0c 	lds	r24, 0x0C29	; 0x800c29 <sys_rt_exec_state>
    6336:	84 73       	andi	r24, 0x34	; 52
    6338:	31 f1       	breq	.+76     	; 0x6386 <limits_go_home+0x2b6>
          uint8_t rt_exec = sys_rt_exec_state;
    633a:	10 91 29 0c 	lds	r17, 0x0C29	; 0x800c29 <sys_rt_exec_state>
          // Homing failure condition: Reset issued during cycle.
          if (rt_exec & EXEC_RESET) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_RESET); }
    633e:	14 ff       	sbrs	r17, 4
    6340:	03 c0       	rjmp	.+6      	; 0x6348 <limits_go_home+0x278>
    6342:	86 e0       	ldi	r24, 0x06	; 6
    6344:	0e 94 5d 3d 	call	0x7aba	; 0x7aba <system_set_exec_alarm>
          // Homing failure condition: Safety door was opened.
          if (rt_exec & EXEC_SAFETY_DOOR) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_DOOR); }
    6348:	15 ff       	sbrs	r17, 5
    634a:	03 c0       	rjmp	.+6      	; 0x6352 <limits_go_home+0x282>
    634c:	87 e0       	ldi	r24, 0x07	; 7
    634e:	0e 94 5d 3d 	call	0x7aba	; 0x7aba <system_set_exec_alarm>
          // Homing failure condition: Limit switch still engaged after pull-off motion
          if (!approach && (limits_get_state() & cycle_mask)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_PULLOFF); }
    6352:	01 11       	cpse	r16, r1
    6354:	b9 c0       	rjmp	.+370    	; 0x64c8 <limits_go_home+0x3f8>
    6356:	21 de       	rcall	.-958    	; 0x5f9a <limits_get_state>
    6358:	bf a1       	ldd	r27, Y+39	; 0x27
    635a:	8b 23       	and	r24, r27
    635c:	39 f0       	breq	.+14     	; 0x636c <limits_go_home+0x29c>
    635e:	88 e0       	ldi	r24, 0x08	; 8
    6360:	0e 94 5d 3d 	call	0x7aba	; 0x7aba <system_set_exec_alarm>
    6364:	03 c0       	rjmp	.+6      	; 0x636c <limits_go_home+0x29c>
          // Homing failure condition: Limit switch not found during approach.
          if (approach && (rt_exec & EXEC_CYCLE_STOP)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_APPROACH); }
    6366:	89 e0       	ldi	r24, 0x09	; 9
    6368:	0e 94 5d 3d 	call	0x7aba	; 0x7aba <system_set_exec_alarm>
          if (sys_rt_exec_alarm) {
    636c:	80 91 43 0c 	lds	r24, 0x0C43	; 0x800c43 <sys_rt_exec_alarm>
    6370:	88 23       	and	r24, r24
    6372:	29 f0       	breq	.+10     	; 0x637e <limits_go_home+0x2ae>
            mc_reset(); // Stop motors, if they are running.
    6374:	0e 94 cb 06 	call	0xd96	; 0xd96 <mc_reset>
            protocol_execute_realtime();
    6378:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <protocol_execute_realtime>
            return;
    637c:	a8 c0       	rjmp	.+336    	; 0x64ce <limits_go_home+0x3fe>
          } else {
            // Pull-off motion complete. Disable CYCLE_STOP from executing.
            system_clear_exec_state_flag(EXEC_CYCLE_STOP);
    637e:	84 e0       	ldi	r24, 0x04	; 4
    6380:	0e 94 53 3d 	call	0x7aa6	; 0x7aa6 <system_clear_exec_state_flag>
            break;
    6384:	04 c0       	rjmp	.+8      	; 0x638e <limits_go_home+0x2be>
          }
        }

      } while (STEP_MASK & axislock);
    6386:	81 2f       	mov	r24, r17
    6388:	8c 71       	andi	r24, 0x1C	; 28
    638a:	09 f0       	breq	.+2      	; 0x638e <limits_go_home+0x2be>
    638c:	b0 cf       	rjmp	.-160    	; 0x62ee <limits_go_home+0x21e>
      st_reset(); // Immediately force kill steppers and reset step segment buffer.
    638e:	0e 94 41 1b 	call	0x3682	; 0x3682 <st_reset>
      delay_ms(settings.homing_debounce_delay); // Delay to allow transient dynamics to dissipate.
    6392:	ef e0       	ldi	r30, 0x0F	; 15
    6394:	ff e0       	ldi	r31, 0x0F	; 15
    6396:	80 81       	ld	r24, Z
    6398:	91 81       	ldd	r25, Z+1	; 0x01
    639a:	ca dc       	rcall	.-1644   	; 0x5d30 <delay_ms>

      // Reverse direction and reset homing rate for locate cycle(s).
      approach = !approach;
    639c:	f1 e0       	ldi	r31, 0x01	; 1
    639e:	0f 27       	eor	r16, r31

      // After first cycle, homing enters locating phase. Shorten search to pull-off distance.
      if (approach) {
    63a0:	d1 f0       	breq	.+52     	; 0x63d6 <limits_go_home+0x306>
        max_travel = settings.homing_pulloff*HOMING_AXIS_LOCATE_SCALAR;
    63a2:	20 e0       	ldi	r18, 0x00	; 0
    63a4:	30 e0       	ldi	r19, 0x00	; 0
    63a6:	40 ea       	ldi	r20, 0xA0	; 160
    63a8:	50 e4       	ldi	r21, 0x40	; 64
    63aa:	a1 e1       	ldi	r26, 0x11	; 17
    63ac:	bf e0       	ldi	r27, 0x0F	; 15
    63ae:	6d 91       	ld	r22, X+
    63b0:	7d 91       	ld	r23, X+
    63b2:	8d 91       	ld	r24, X+
    63b4:	9c 91       	ld	r25, X
    63b6:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    63ba:	2b 01       	movw	r4, r22
    63bc:	3c 01       	movw	r6, r24
        homing_rate = settings.homing_feed_rate;
    63be:	a7 e0       	ldi	r26, 0x07	; 7
    63c0:	bf e0       	ldi	r27, 0x0F	; 15
    63c2:	8d 91       	ld	r24, X+
    63c4:	9d 91       	ld	r25, X+
    63c6:	0d 90       	ld	r0, X+
    63c8:	bc 91       	ld	r27, X
    63ca:	a0 2d       	mov	r26, r0
    63cc:	8f 8f       	std	Y+31, r24	; 0x1f
    63ce:	98 a3       	std	Y+32, r25	; 0x20
    63d0:	a9 a3       	std	Y+33, r26	; 0x21
    63d2:	ba a3       	std	Y+34, r27	; 0x22
    63d4:	11 c0       	rjmp	.+34     	; 0x63f8 <limits_go_home+0x328>
      } else {
        max_travel = settings.homing_pulloff;
    63d6:	e1 e1       	ldi	r30, 0x11	; 17
    63d8:	ff e0       	ldi	r31, 0x0F	; 15
    63da:	40 80       	ld	r4, Z
    63dc:	51 80       	ldd	r5, Z+1	; 0x01
    63de:	62 80       	ldd	r6, Z+2	; 0x02
    63e0:	73 80       	ldd	r7, Z+3	; 0x03
        homing_rate = settings.homing_seek_rate;
    63e2:	ab e0       	ldi	r26, 0x0B	; 11
    63e4:	bf e0       	ldi	r27, 0x0F	; 15
    63e6:	8d 91       	ld	r24, X+
    63e8:	9d 91       	ld	r25, X+
    63ea:	0d 90       	ld	r0, X+
    63ec:	bc 91       	ld	r27, X
    63ee:	a0 2d       	mov	r26, r0
    63f0:	8f 8f       	std	Y+31, r24	; 0x1f
    63f2:	98 a3       	std	Y+32, r25	; 0x20
    63f4:	a9 a3       	std	Y+33, r26	; 0x21
    63f6:	ba a3       	std	Y+34, r27	; 0x22
    63f8:	bd 8d       	ldd	r27, Y+29	; 0x1d
    63fa:	b1 50       	subi	r27, 0x01	; 1
    63fc:	bd 8f       	std	Y+29, r27	; 0x1d
      }
    } while (n_cycle-- > 0);
    63fe:	b1 11       	cpse	r27, r1
    6400:	e9 ce       	rjmp	.-558    	; 0x61d4 <limits_go_home+0x104>
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
      #ifdef HOMING_FORCE_SET_ORIGIN
        set_axis_position = 0;
      #else
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    6402:	e0 90 06 0f 	lds	r14, 0x0F06	; 0x800f06 <settings+0x46>
    6406:	f1 2c       	mov	r15, r1
          set_axis_position = lround((settings.max_travel[idx]+settings.homing_pulloff)*settings.steps_per_mm[idx]);
    6408:	80 90 11 0f 	lds	r8, 0x0F11	; 0x800f11 <settings+0x51>
    640c:	90 90 12 0f 	lds	r9, 0x0F12	; 0x800f12 <settings+0x52>
    6410:	a0 90 13 0f 	lds	r10, 0x0F13	; 0x800f13 <settings+0x53>
    6414:	b0 90 14 0f 	lds	r11, 0x0F14	; 0x800f14 <settings+0x54>
        } else {
          set_axis_position = lround(-settings.homing_pulloff*settings.steps_per_mm[idx]);
    6418:	24 01       	movw	r4, r8
    641a:	35 01       	movw	r6, r10
    641c:	77 fa       	bst	r7, 7
    641e:	70 94       	com	r7
    6420:	77 f8       	bld	r7, 7
    6422:	70 94       	com	r7
    6424:	00 e0       	ldi	r16, 0x00	; 0
    6426:	10 e0       	ldi	r17, 0x00	; 0
    6428:	cd a0       	ldd	r12, Y+37	; 0x25
    642a:	de a0       	ldd	r13, Y+38	; 0x26
  // triggering when hard limits are enabled or when more than one axes shares a limit pin.
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
    642c:	c1 01       	movw	r24, r2
    642e:	00 2e       	mov	r0, r16
    6430:	02 c0       	rjmp	.+4      	; 0x6436 <limits_go_home+0x366>
    6432:	95 95       	asr	r25
    6434:	87 95       	ror	r24
    6436:	0a 94       	dec	r0
    6438:	e2 f7       	brpl	.-8      	; 0x6432 <limits_go_home+0x362>
    643a:	80 ff       	sbrs	r24, 0
    643c:	34 c0       	rjmp	.+104    	; 0x64a6 <limits_go_home+0x3d6>
      #ifdef HOMING_FORCE_SET_ORIGIN
        set_axis_position = 0;
      #else
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    643e:	c7 01       	movw	r24, r14
    6440:	00 2e       	mov	r0, r16
    6442:	02 c0       	rjmp	.+4      	; 0x6448 <limits_go_home+0x378>
    6444:	95 95       	asr	r25
    6446:	87 95       	ror	r24
    6448:	0a 94       	dec	r0
    644a:	e2 f7       	brpl	.-8      	; 0x6444 <limits_go_home+0x374>
    644c:	80 ff       	sbrs	r24, 0
    644e:	15 c0       	rjmp	.+42     	; 0x647a <limits_go_home+0x3aa>
          set_axis_position = lround((settings.max_travel[idx]+settings.homing_pulloff)*settings.steps_per_mm[idx]);
    6450:	eb a1       	ldd	r30, Y+35	; 0x23
    6452:	fc a1       	ldd	r31, Y+36	; 0x24
    6454:	24 a1       	ldd	r18, Z+36	; 0x24
    6456:	35 a1       	ldd	r19, Z+37	; 0x25
    6458:	46 a1       	ldd	r20, Z+38	; 0x26
    645a:	57 a1       	ldd	r21, Z+39	; 0x27
    645c:	c5 01       	movw	r24, r10
    645e:	b4 01       	movw	r22, r8
    6460:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    6464:	ab a1       	ldd	r26, Y+35	; 0x23
    6466:	bc a1       	ldd	r27, Y+36	; 0x24
    6468:	2d 91       	ld	r18, X+
    646a:	3d 91       	ld	r19, X+
    646c:	4d 91       	ld	r20, X+
    646e:	5c 91       	ld	r21, X
    6470:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    6474:	0e 94 d3 40 	call	0x81a6	; 0x81a6 <lround>
    6478:	0c c0       	rjmp	.+24     	; 0x6492 <limits_go_home+0x3c2>
        } else {
          set_axis_position = lround(-settings.homing_pulloff*settings.steps_per_mm[idx]);
    647a:	eb a1       	ldd	r30, Y+35	; 0x23
    647c:	fc a1       	ldd	r31, Y+36	; 0x24
    647e:	20 81       	ld	r18, Z
    6480:	31 81       	ldd	r19, Z+1	; 0x01
    6482:	42 81       	ldd	r20, Z+2	; 0x02
    6484:	53 81       	ldd	r21, Z+3	; 0x03
    6486:	c3 01       	movw	r24, r6
    6488:	b2 01       	movw	r22, r4
    648a:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    648e:	0e 94 d3 40 	call	0x81a6	; 0x81a6 <lround>
          sys_position[B_MOTOR] = off_axis_position - set_axis_position;
        } else {
          sys_position[idx] = set_axis_position;
        }
      #else
        sys_position[idx] = set_axis_position;
    6492:	d6 01       	movw	r26, r12
    6494:	6c 93       	st	X, r22
    6496:	11 96       	adiw	r26, 0x01	; 1
    6498:	7c 93       	st	X, r23
    649a:	11 97       	sbiw	r26, 0x01	; 1
    649c:	12 96       	adiw	r26, 0x02	; 2
    649e:	8c 93       	st	X, r24
    64a0:	12 97       	sbiw	r26, 0x02	; 2
    64a2:	13 96       	adiw	r26, 0x03	; 3
    64a4:	9c 93       	st	X, r25
    64a6:	0f 5f       	subi	r16, 0xFF	; 255
    64a8:	1f 4f       	sbci	r17, 0xFF	; 255
    64aa:	b4 e0       	ldi	r27, 0x04	; 4
    64ac:	cb 0e       	add	r12, r27
    64ae:	d1 1c       	adc	r13, r1
    64b0:	eb a1       	ldd	r30, Y+35	; 0x23
    64b2:	fc a1       	ldd	r31, Y+36	; 0x24
    64b4:	34 96       	adiw	r30, 0x04	; 4
    64b6:	fc a3       	std	Y+36, r31	; 0x24
    64b8:	eb a3       	std	Y+35, r30	; 0x23
  // set up pull-off maneuver from axes limit switches that have been homed. This provides
  // some initial clearance off the switches and should also help prevent them from falsely
  // triggering when hard limits are enabled or when more than one axes shares a limit pin.
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    64ba:	03 30       	cpi	r16, 0x03	; 3
    64bc:	11 05       	cpc	r17, r1
    64be:	09 f0       	breq	.+2      	; 0x64c2 <limits_go_home+0x3f2>
    64c0:	b5 cf       	rjmp	.-150    	; 0x642c <limits_go_home+0x35c>
        sys_position[idx] = set_axis_position;
      #endif

    }
  }
  sys.step_control = STEP_CONTROL_NORMAL_OP; // Return step control to normal operation.
    64c2:	10 92 1a 0c 	sts	0x0C1A, r1	; 0x800c1a <sys+0x4>
    64c6:	03 c0       	rjmp	.+6      	; 0x64ce <limits_go_home+0x3fe>
          // Homing failure condition: Safety door was opened.
          if (rt_exec & EXEC_SAFETY_DOOR) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_DOOR); }
          // Homing failure condition: Limit switch still engaged after pull-off motion
          if (!approach && (limits_get_state() & cycle_mask)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_PULLOFF); }
          // Homing failure condition: Limit switch not found during approach.
          if (approach && (rt_exec & EXEC_CYCLE_STOP)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_APPROACH); }
    64c8:	12 ff       	sbrs	r17, 2
    64ca:	50 cf       	rjmp	.-352    	; 0x636c <limits_go_home+0x29c>
    64cc:	4c cf       	rjmp	.-360    	; 0x6366 <limits_go_home+0x296>
      #endif

    }
  }
  sys.step_control = STEP_CONTROL_NORMAL_OP; // Return step control to normal operation.
}
    64ce:	a9 96       	adiw	r28, 0x29	; 41
    64d0:	0f b6       	in	r0, 0x3f	; 63
    64d2:	f8 94       	cli
    64d4:	de bf       	out	0x3e, r29	; 62
    64d6:	0f be       	out	0x3f, r0	; 63
    64d8:	cd bf       	out	0x3d, r28	; 61
    64da:	df 91       	pop	r29
    64dc:	cf 91       	pop	r28
    64de:	1f 91       	pop	r17
    64e0:	0f 91       	pop	r16
    64e2:	ff 90       	pop	r15
    64e4:	ef 90       	pop	r14
    64e6:	df 90       	pop	r13
    64e8:	cf 90       	pop	r12
    64ea:	bf 90       	pop	r11
    64ec:	af 90       	pop	r10
    64ee:	9f 90       	pop	r9
    64f0:	8f 90       	pop	r8
    64f2:	7f 90       	pop	r7
    64f4:	6f 90       	pop	r6
    64f6:	5f 90       	pop	r5
    64f8:	4f 90       	pop	r4
    64fa:	3f 90       	pop	r3
    64fc:	2f 90       	pop	r2
    64fe:	08 95       	ret

00006500 <limits_soft_check>:

// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
// NOTE: Used by jogging to limit travel within soft-limit volume.
void limits_soft_check(float *target)
{
    6500:	cf 93       	push	r28
    6502:	df 93       	push	r29
  if (system_check_travel_limits(target)) {
    6504:	0e 94 90 3a 	call	0x7520	; 0x7520 <system_check_travel_limits>
    6508:	88 23       	and	r24, r24
    650a:	d1 f0       	breq	.+52     	; 0x6540 <limits_soft_check+0x40>
    sys.soft_limit = true;
    650c:	e6 e1       	ldi	r30, 0x16	; 22
    650e:	fc e0       	ldi	r31, 0x0C	; 12
    6510:	81 e0       	ldi	r24, 0x01	; 1
    6512:	83 83       	std	Z+3, r24	; 0x03
    // Force feed hold if cycle is active. All buffered blocks are guaranteed to be within
    // workspace volume so just come to a controlled stop so position is not lost. When complete
    // enter alarm mode.
    if (sys.state == STATE_CYCLE) {
    6514:	80 81       	ld	r24, Z
    6516:	88 30       	cpi	r24, 0x08	; 8
    6518:	61 f4       	brne	.+24     	; 0x6532 <limits_soft_check+0x32>
      system_set_exec_state_flag(EXEC_FEED_HOLD);
    651a:	0e 94 f5 3a 	call	0x75ea	; 0x75ea <system_set_exec_state_flag>
      do {
        protocol_execute_realtime();
        if (sys.abort) { return; }
    651e:	c6 e1       	ldi	r28, 0x16	; 22
    6520:	dc e0       	ldi	r29, 0x0C	; 12
    // workspace volume so just come to a controlled stop so position is not lost. When complete
    // enter alarm mode.
    if (sys.state == STATE_CYCLE) {
      system_set_exec_state_flag(EXEC_FEED_HOLD);
      do {
        protocol_execute_realtime();
    6522:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <protocol_execute_realtime>
        if (sys.abort) { return; }
    6526:	89 81       	ldd	r24, Y+1	; 0x01
    6528:	81 11       	cpse	r24, r1
    652a:	0a c0       	rjmp	.+20     	; 0x6540 <limits_soft_check+0x40>
      } while ( sys.state != STATE_IDLE );
    652c:	88 81       	ld	r24, Y
    652e:	81 11       	cpse	r24, r1
    6530:	f8 cf       	rjmp	.-16     	; 0x6522 <limits_soft_check+0x22>
    }
    mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
    6532:	0e 94 cb 06 	call	0xd96	; 0xd96 <mc_reset>
    system_set_exec_alarm(EXEC_ALARM_SOFT_LIMIT); // Indicate soft limit critical event
    6536:	82 e0       	ldi	r24, 0x02	; 2
    6538:	0e 94 5d 3d 	call	0x7aba	; 0x7aba <system_set_exec_alarm>
    protocol_execute_realtime(); // Execute to enter critical event loop and system abort
    653c:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <protocol_execute_realtime>
    return;
  }
}
    6540:	df 91       	pop	r29
    6542:	cf 91       	pop	r28
    6544:	08 95       	ret

00006546 <printString>:
      n /= 2;
  }

  for (; i > 0; i--)
      serial_write('0' + buf[i - 1]);
}
    6546:	cf 93       	push	r28
    6548:	df 93       	push	r29
    654a:	ec 01       	movw	r28, r24
    654c:	88 81       	ld	r24, Y
    654e:	88 23       	and	r24, r24
    6550:	31 f0       	breq	.+12     	; 0x655e <printString+0x18>
    6552:	21 96       	adiw	r28, 0x01	; 1
    6554:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6558:	89 91       	ld	r24, Y+
    655a:	81 11       	cpse	r24, r1
    655c:	fb cf       	rjmp	.-10     	; 0x6554 <printString+0xe>
    655e:	df 91       	pop	r29
    6560:	cf 91       	pop	r28
    6562:	08 95       	ret

00006564 <printPgmString>:
    6564:	cf 93       	push	r28
    6566:	df 93       	push	r29
    6568:	ec 01       	movw	r28, r24
    656a:	21 96       	adiw	r28, 0x01	; 1
    656c:	fc 01       	movw	r30, r24
    656e:	84 91       	lpm	r24, Z
    6570:	88 23       	and	r24, r24
    6572:	39 f0       	breq	.+14     	; 0x6582 <printPgmString+0x1e>
    6574:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6578:	fe 01       	movw	r30, r28
    657a:	84 91       	lpm	r24, Z
    657c:	21 96       	adiw	r28, 0x01	; 1
    657e:	81 11       	cpse	r24, r1
    6580:	f9 cf       	rjmp	.-14     	; 0x6574 <printPgmString+0x10>
    6582:	df 91       	pop	r29
    6584:	cf 91       	pop	r28
    6586:	08 95       	ret

00006588 <print_uint8_base10>:
    6588:	cf 93       	push	r28
    658a:	df 93       	push	r29
    658c:	84 36       	cpi	r24, 0x64	; 100
    658e:	90 f0       	brcs	.+36     	; 0x65b4 <print_uint8_base10+0x2c>
    6590:	9d ec       	ldi	r25, 0xCD	; 205
    6592:	89 9f       	mul	r24, r25
    6594:	91 2d       	mov	r25, r1
    6596:	11 24       	eor	r1, r1
    6598:	96 95       	lsr	r25
    659a:	96 95       	lsr	r25
    659c:	96 95       	lsr	r25
    659e:	39 2f       	mov	r19, r25
    65a0:	33 0f       	add	r19, r19
    65a2:	23 2f       	mov	r18, r19
    65a4:	22 0f       	add	r18, r18
    65a6:	22 0f       	add	r18, r18
    65a8:	23 0f       	add	r18, r19
    65aa:	82 1b       	sub	r24, r18
    65ac:	d0 e3       	ldi	r29, 0x30	; 48
    65ae:	d8 0f       	add	r29, r24
    65b0:	89 2f       	mov	r24, r25
    65b2:	01 c0       	rjmp	.+2      	; 0x65b6 <print_uint8_base10+0x2e>
    65b4:	d0 e0       	ldi	r29, 0x00	; 0
    65b6:	8a 30       	cpi	r24, 0x0A	; 10
    65b8:	f8 f0       	brcs	.+62     	; 0x65f8 <print_uint8_base10+0x70>
    65ba:	9d ec       	ldi	r25, 0xCD	; 205
    65bc:	89 9f       	mul	r24, r25
    65be:	91 2d       	mov	r25, r1
    65c0:	11 24       	eor	r1, r1
    65c2:	96 95       	lsr	r25
    65c4:	96 95       	lsr	r25
    65c6:	96 95       	lsr	r25
    65c8:	39 2f       	mov	r19, r25
    65ca:	33 0f       	add	r19, r19
    65cc:	23 2f       	mov	r18, r19
    65ce:	22 0f       	add	r18, r18
    65d0:	22 0f       	add	r18, r18
    65d2:	23 0f       	add	r18, r19
    65d4:	c8 2f       	mov	r28, r24
    65d6:	c2 1b       	sub	r28, r18
    65d8:	c0 5d       	subi	r28, 0xD0	; 208
    65da:	80 e3       	ldi	r24, 0x30	; 48
    65dc:	89 0f       	add	r24, r25
    65de:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    65e2:	cc 23       	and	r28, r28
    65e4:	19 f0       	breq	.+6      	; 0x65ec <print_uint8_base10+0x64>
    65e6:	8c 2f       	mov	r24, r28
    65e8:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    65ec:	dd 23       	and	r29, r29
    65ee:	41 f0       	breq	.+16     	; 0x6600 <print_uint8_base10+0x78>
    65f0:	8d 2f       	mov	r24, r29
    65f2:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    65f6:	04 c0       	rjmp	.+8      	; 0x6600 <print_uint8_base10+0x78>
    65f8:	80 5d       	subi	r24, 0xD0	; 208
    65fa:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    65fe:	f6 cf       	rjmp	.-20     	; 0x65ec <print_uint8_base10+0x64>
    6600:	df 91       	pop	r29
    6602:	cf 91       	pop	r28
    6604:	08 95       	ret

00006606 <print_uint32_base10>:


void print_uint32_base10(uint32_t n)
{
    6606:	8f 92       	push	r8
    6608:	9f 92       	push	r9
    660a:	af 92       	push	r10
    660c:	bf 92       	push	r11
    660e:	ef 92       	push	r14
    6610:	ff 92       	push	r15
    6612:	1f 93       	push	r17
    6614:	cf 93       	push	r28
    6616:	df 93       	push	r29
    6618:	cd b7       	in	r28, 0x3d	; 61
    661a:	de b7       	in	r29, 0x3e	; 62
    661c:	2a 97       	sbiw	r28, 0x0a	; 10
    661e:	0f b6       	in	r0, 0x3f	; 63
    6620:	f8 94       	cli
    6622:	de bf       	out	0x3e, r29	; 62
    6624:	0f be       	out	0x3f, r0	; 63
    6626:	cd bf       	out	0x3d, r28	; 61
  if (n == 0) {
    6628:	61 15       	cp	r22, r1
    662a:	71 05       	cpc	r23, r1
    662c:	81 05       	cpc	r24, r1
    662e:	91 05       	cpc	r25, r1
    6630:	21 f4       	brne	.+8      	; 0x663a <print_uint32_base10+0x34>
    serial_write('0');
    6632:	80 e3       	ldi	r24, 0x30	; 48
    6634:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6638:	2c c0       	rjmp	.+88     	; 0x6692 <print_uint32_base10+0x8c>
    663a:	20 e0       	ldi	r18, 0x00	; 0

  unsigned char buf[10];
  uint8_t i = 0;

  while (n > 0) {
    buf[i++] = n % 10;
    663c:	0f 2e       	mov	r0, r31
    663e:	fa e0       	ldi	r31, 0x0A	; 10
    6640:	8f 2e       	mov	r8, r31
    6642:	91 2c       	mov	r9, r1
    6644:	a1 2c       	mov	r10, r1
    6646:	b1 2c       	mov	r11, r1
    6648:	f0 2d       	mov	r31, r0
    664a:	11 e0       	ldi	r17, 0x01	; 1
    664c:	12 0f       	add	r17, r18
    664e:	ee 24       	eor	r14, r14
    6650:	e3 94       	inc	r14
    6652:	f1 2c       	mov	r15, r1
    6654:	ec 0e       	add	r14, r28
    6656:	fd 1e       	adc	r15, r29
    6658:	e2 0e       	add	r14, r18
    665a:	f1 1c       	adc	r15, r1
    665c:	a5 01       	movw	r20, r10
    665e:	94 01       	movw	r18, r8
    6660:	0e 94 f0 41 	call	0x83e0	; 0x83e0 <__udivmodsi4>
    6664:	f7 01       	movw	r30, r14
    6666:	60 83       	st	Z, r22
    n /= 10;
    6668:	62 2f       	mov	r22, r18
    666a:	73 2f       	mov	r23, r19
    666c:	84 2f       	mov	r24, r20
    666e:	95 2f       	mov	r25, r21

  unsigned char buf[10];
  uint8_t i = 0;

  while (n > 0) {
    buf[i++] = n % 10;
    6670:	21 2f       	mov	r18, r17
  }

  unsigned char buf[10];
  uint8_t i = 0;

  while (n > 0) {
    6672:	61 15       	cp	r22, r1
    6674:	71 05       	cpc	r23, r1
    6676:	81 05       	cpc	r24, r1
    6678:	91 05       	cpc	r25, r1
    667a:	39 f7       	brne	.-50     	; 0x664a <print_uint32_base10+0x44>
    buf[i++] = n % 10;
    n /= 10;
  }

  for (; i > 0; i--)
    667c:	11 23       	and	r17, r17
    667e:	49 f0       	breq	.+18     	; 0x6692 <print_uint32_base10+0x8c>
    serial_write('0' + buf[i-1]);
    6680:	fe 01       	movw	r30, r28
    6682:	e1 0f       	add	r30, r17
    6684:	f1 1d       	adc	r31, r1
    6686:	80 81       	ld	r24, Z
    6688:	80 5d       	subi	r24, 0xD0	; 208
    668a:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
  while (n > 0) {
    buf[i++] = n % 10;
    n /= 10;
  }

  for (; i > 0; i--)
    668e:	11 50       	subi	r17, 0x01	; 1
    6690:	b9 f7       	brne	.-18     	; 0x6680 <print_uint32_base10+0x7a>
    serial_write('0' + buf[i-1]);
}
    6692:	2a 96       	adiw	r28, 0x0a	; 10
    6694:	0f b6       	in	r0, 0x3f	; 63
    6696:	f8 94       	cli
    6698:	de bf       	out	0x3e, r29	; 62
    669a:	0f be       	out	0x3f, r0	; 63
    669c:	cd bf       	out	0x3d, r28	; 61
    669e:	df 91       	pop	r29
    66a0:	cf 91       	pop	r28
    66a2:	1f 91       	pop	r17
    66a4:	ff 90       	pop	r15
    66a6:	ef 90       	pop	r14
    66a8:	bf 90       	pop	r11
    66aa:	af 90       	pop	r10
    66ac:	9f 90       	pop	r9
    66ae:	8f 90       	pop	r8
    66b0:	08 95       	ret

000066b2 <printInteger>:


void printInteger(long n)
{
    66b2:	cf 92       	push	r12
    66b4:	df 92       	push	r13
    66b6:	ef 92       	push	r14
    66b8:	ff 92       	push	r15
    66ba:	6b 01       	movw	r12, r22
    66bc:	7c 01       	movw	r14, r24
  if (n < 0) {
    66be:	99 23       	and	r25, r25
    66c0:	64 f4       	brge	.+24     	; 0x66da <printInteger+0x28>
    serial_write('-');
    66c2:	8d e2       	ldi	r24, 0x2D	; 45
    66c4:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    print_uint32_base10(-n);
    66c8:	66 27       	eor	r22, r22
    66ca:	77 27       	eor	r23, r23
    66cc:	cb 01       	movw	r24, r22
    66ce:	6c 19       	sub	r22, r12
    66d0:	7d 09       	sbc	r23, r13
    66d2:	8e 09       	sbc	r24, r14
    66d4:	9f 09       	sbc	r25, r15
    66d6:	97 df       	rcall	.-210    	; 0x6606 <print_uint32_base10>
    66d8:	01 c0       	rjmp	.+2      	; 0x66dc <printInteger+0x2a>
  } else {
    print_uint32_base10(n);
    66da:	95 df       	rcall	.-214    	; 0x6606 <print_uint32_base10>
    66dc:	ff 90       	pop	r15
  }
}
    66de:	ef 90       	pop	r14
    66e0:	df 90       	pop	r13
    66e2:	cf 90       	pop	r12
    66e4:	08 95       	ret

000066e6 <printFloat>:
    66e6:	8f 92       	push	r8
// more digits than a float. Number of decimal places, which are tracked by a counter,
// may be set by the user. The integer is then efficiently converted to a string.
// NOTE: AVR '%' and '/' integer operations are very efficient. Bitshifting speed-up
// techniques are actually just slightly slower. Found this out the hard way.
void printFloat(float n, uint8_t decimal_places)
{
    66e8:	9f 92       	push	r9
    66ea:	af 92       	push	r10
    66ec:	bf 92       	push	r11
    66ee:	cf 92       	push	r12
    66f0:	df 92       	push	r13
    66f2:	ef 92       	push	r14
    66f4:	ff 92       	push	r15
    66f6:	0f 93       	push	r16
    66f8:	1f 93       	push	r17
    66fa:	cf 93       	push	r28
    66fc:	df 93       	push	r29
    66fe:	cd b7       	in	r28, 0x3d	; 61
    6700:	de b7       	in	r29, 0x3e	; 62
    6702:	2d 97       	sbiw	r28, 0x0d	; 13
    6704:	0f b6       	in	r0, 0x3f	; 63
    6706:	f8 94       	cli
    6708:	de bf       	out	0x3e, r29	; 62
    670a:	0f be       	out	0x3f, r0	; 63
    670c:	cd bf       	out	0x3d, r28	; 61
    670e:	6b 01       	movw	r12, r22
    6710:	7c 01       	movw	r14, r24
    6712:	04 2f       	mov	r16, r20
  if (n < 0) {
    6714:	20 e0       	ldi	r18, 0x00	; 0
    6716:	30 e0       	ldi	r19, 0x00	; 0
    6718:	a9 01       	movw	r20, r18
    671a:	0e 94 c5 3e 	call	0x7d8a	; 0x7d8a <__cmpsf2>
    671e:	88 23       	and	r24, r24
    6720:	3c f4       	brge	.+14     	; 0x6730 <printFloat+0x4a>
    serial_write('-');
    6722:	8d e2       	ldi	r24, 0x2D	; 45
    6724:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    n = -n;
    6728:	f7 fa       	bst	r15, 7
    672a:	f0 94       	com	r15
    672c:	f7 f8       	bld	r15, 7
    672e:	f0 94       	com	r15
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    6730:	02 30       	cpi	r16, 0x02	; 2
    6732:	88 f0       	brcs	.+34     	; 0x6756 <printFloat+0x70>
    6734:	10 2f       	mov	r17, r16
    n *= 100;
    6736:	20 e0       	ldi	r18, 0x00	; 0
    6738:	30 e0       	ldi	r19, 0x00	; 0
    673a:	48 ec       	ldi	r20, 0xC8	; 200
    673c:	52 e4       	ldi	r21, 0x42	; 66
    673e:	c7 01       	movw	r24, r14
    6740:	b6 01       	movw	r22, r12
    6742:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    6746:	6b 01       	movw	r12, r22
    6748:	7c 01       	movw	r14, r24
    decimals -= 2;
    674a:	12 50       	subi	r17, 0x02	; 2
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    674c:	12 30       	cpi	r17, 0x02	; 2
    674e:	98 f7       	brcc	.-26     	; 0x6736 <printFloat+0x50>
    6750:	80 2f       	mov	r24, r16
    6752:	81 70       	andi	r24, 0x01	; 1
    6754:	01 c0       	rjmp	.+2      	; 0x6758 <printFloat+0x72>
  if (n < 0) {
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
    6756:	80 2f       	mov	r24, r16
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    n *= 100;
    decimals -= 2;
  }
  if (decimals) { n *= 10; }
    6758:	88 23       	and	r24, r24
    675a:	51 f0       	breq	.+20     	; 0x6770 <printFloat+0x8a>
    675c:	20 e0       	ldi	r18, 0x00	; 0
    675e:	30 e0       	ldi	r19, 0x00	; 0
    6760:	40 e2       	ldi	r20, 0x20	; 32
    6762:	51 e4       	ldi	r21, 0x41	; 65
    6764:	c7 01       	movw	r24, r14
    6766:	b6 01       	movw	r22, r12
    6768:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    676c:	6b 01       	movw	r12, r22
    676e:	7c 01       	movw	r14, r24
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.

  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
  uint32_t a = (long)n;
    6770:	20 e0       	ldi	r18, 0x00	; 0
    6772:	30 e0       	ldi	r19, 0x00	; 0
    6774:	40 e0       	ldi	r20, 0x00	; 0
    6776:	5f e3       	ldi	r21, 0x3F	; 63
    6778:	c7 01       	movw	r24, r14
    677a:	b6 01       	movw	r22, r12
    677c:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <__addsf3>
    6780:	0e 94 34 3f 	call	0x7e68	; 0x7e68 <__fixsfsi>
  while(a > 0) {
    6784:	61 15       	cp	r22, r1
    6786:	71 05       	cpc	r23, r1
    6788:	81 05       	cpc	r24, r1
    678a:	91 05       	cpc	r25, r1
    678c:	19 f1       	breq	.+70     	; 0x67d4 <printFloat+0xee>
    678e:	20 e0       	ldi	r18, 0x00	; 0
    buf[i++] = (a % 10) + '0'; // Get digit
    6790:	0f 2e       	mov	r0, r31
    6792:	fa e0       	ldi	r31, 0x0A	; 10
    6794:	8f 2e       	mov	r8, r31
    6796:	91 2c       	mov	r9, r1
    6798:	a1 2c       	mov	r10, r1
    679a:	b1 2c       	mov	r11, r1
    679c:	f0 2d       	mov	r31, r0
    679e:	11 e0       	ldi	r17, 0x01	; 1
    67a0:	12 0f       	add	r17, r18
    67a2:	ee 24       	eor	r14, r14
    67a4:	e3 94       	inc	r14
    67a6:	f1 2c       	mov	r15, r1
    67a8:	ec 0e       	add	r14, r28
    67aa:	fd 1e       	adc	r15, r29
    67ac:	e2 0e       	add	r14, r18
    67ae:	f1 1c       	adc	r15, r1
    67b0:	a5 01       	movw	r20, r10
    67b2:	94 01       	movw	r18, r8
    67b4:	0e 94 f0 41 	call	0x83e0	; 0x83e0 <__udivmodsi4>
    67b8:	60 5d       	subi	r22, 0xD0	; 208
    67ba:	f7 01       	movw	r30, r14
    67bc:	60 83       	st	Z, r22
    a /= 10;
    67be:	62 2f       	mov	r22, r18
    67c0:	73 2f       	mov	r23, r19
    67c2:	84 2f       	mov	r24, r20
    67c4:	95 2f       	mov	r25, r21
  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
  uint32_t a = (long)n;
  while(a > 0) {
    buf[i++] = (a % 10) + '0'; // Get digit
    67c6:	21 2f       	mov	r18, r17

  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
  uint32_t a = (long)n;
  while(a > 0) {
    67c8:	61 15       	cp	r22, r1
    67ca:	71 05       	cpc	r23, r1
    67cc:	81 05       	cpc	r24, r1
    67ce:	91 05       	cpc	r25, r1
    67d0:	31 f7       	brne	.-52     	; 0x679e <printFloat+0xb8>
    67d2:	01 c0       	rjmp	.+2      	; 0x67d6 <printFloat+0xf0>
  if (decimals) { n *= 10; }
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.

  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
    67d4:	10 e0       	ldi	r17, 0x00	; 0
  uint32_t a = (long)n;
  while(a > 0) {
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) {
    67d6:	10 17       	cp	r17, r16
    67d8:	60 f4       	brcc	.+24     	; 0x67f2 <printFloat+0x10c>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
    67da:	80 e3       	ldi	r24, 0x30	; 48
    67dc:	e1 e0       	ldi	r30, 0x01	; 1
    67de:	f0 e0       	ldi	r31, 0x00	; 0
    67e0:	ec 0f       	add	r30, r28
    67e2:	fd 1f       	adc	r31, r29
    67e4:	e1 0f       	add	r30, r17
    67e6:	f1 1d       	adc	r31, r1
    67e8:	80 83       	st	Z, r24
    67ea:	1f 5f       	subi	r17, 0xFF	; 255
  uint32_t a = (long)n;
  while(a > 0) {
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) {
    67ec:	01 13       	cpse	r16, r17
    67ee:	f6 cf       	rjmp	.-20     	; 0x67dc <printFloat+0xf6>
    67f0:	02 c0       	rjmp	.+4      	; 0x67f6 <printFloat+0x110>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
  }
  if (i == decimal_places) { // Fill in leading zero, if needed.
    67f2:	01 13       	cpse	r16, r17
    67f4:	07 c0       	rjmp	.+14     	; 0x6804 <printFloat+0x11e>
    buf[i++] = '0';
    67f6:	11 e0       	ldi	r17, 0x01	; 1
    67f8:	10 0f       	add	r17, r16
    67fa:	80 e3       	ldi	r24, 0x30	; 48
    67fc:	fe 01       	movw	r30, r28
    67fe:	e0 0f       	add	r30, r16
    6800:	f1 1d       	adc	r31, r1
    6802:	81 83       	std	Z+1, r24	; 0x01
  }

  // Print the generated string.
  for (; i > 0; i--) {
    6804:	11 23       	and	r17, r17
    6806:	69 f0       	breq	.+26     	; 0x6822 <printFloat+0x13c>
    if (i == decimal_places) { serial_write('.'); } // Insert decimal point in right place.
    6808:	01 13       	cpse	r16, r17
    680a:	03 c0       	rjmp	.+6      	; 0x6812 <printFloat+0x12c>
    680c:	8e e2       	ldi	r24, 0x2E	; 46
    680e:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    serial_write(buf[i-1]);
    6812:	fe 01       	movw	r30, r28
    6814:	e1 0f       	add	r30, r17
    6816:	f1 1d       	adc	r31, r1
    6818:	80 81       	ld	r24, Z
    681a:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
  if (i == decimal_places) { // Fill in leading zero, if needed.
    buf[i++] = '0';
  }

  // Print the generated string.
  for (; i > 0; i--) {
    681e:	11 50       	subi	r17, 0x01	; 1
    6820:	99 f7       	brne	.-26     	; 0x6808 <printFloat+0x122>
    if (i == decimal_places) { serial_write('.'); } // Insert decimal point in right place.
    serial_write(buf[i-1]);
  }
}
    6822:	2d 96       	adiw	r28, 0x0d	; 13
    6824:	0f b6       	in	r0, 0x3f	; 63
    6826:	f8 94       	cli
    6828:	de bf       	out	0x3e, r29	; 62
    682a:	0f be       	out	0x3f, r0	; 63
    682c:	cd bf       	out	0x3d, r28	; 61
    682e:	df 91       	pop	r29
    6830:	cf 91       	pop	r28
    6832:	1f 91       	pop	r17
    6834:	0f 91       	pop	r16
    6836:	ff 90       	pop	r15
    6838:	ef 90       	pop	r14
    683a:	df 90       	pop	r13
    683c:	cf 90       	pop	r12
    683e:	bf 90       	pop	r11
    6840:	af 90       	pop	r10
    6842:	9f 90       	pop	r9
    6844:	8f 90       	pop	r8
    6846:	08 95       	ret

00006848 <printFloat_CoordValue>:
// Floating value printing handlers for special variables types used in Grbl and are defined
// in the config.h.
//  - CoordValue: Handles all position or coordinate values in inches or mm reporting.
//  - RateValue: Handles feed rate and current velocity in inches or mm reporting.
void printFloat_CoordValue(float n) {
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
    6848:	20 91 05 0f 	lds	r18, 0x0F05	; 0x800f05 <settings+0x45>
    684c:	20 ff       	sbrs	r18, 0
    684e:	09 c0       	rjmp	.+18     	; 0x6862 <printFloat_CoordValue+0x1a>
    printFloat(n*INCH_PER_MM,N_DECIMAL_COORDVALUE_INCH);
    6850:	2b e8       	ldi	r18, 0x8B	; 139
    6852:	32 e4       	ldi	r19, 0x42	; 66
    6854:	41 e2       	ldi	r20, 0x21	; 33
    6856:	5d e3       	ldi	r21, 0x3D	; 61
    6858:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    685c:	44 e0       	ldi	r20, 0x04	; 4
    685e:	43 cf       	rjmp	.-378    	; 0x66e6 <printFloat>
    6860:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_COORDVALUE_MM);
    6862:	43 e0       	ldi	r20, 0x03	; 3
    6864:	40 cf       	rjmp	.-384    	; 0x66e6 <printFloat>
    6866:	08 95       	ret

00006868 <printFloat_RateValue>:
  }
}

void printFloat_RateValue(float n) {
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
    6868:	20 91 05 0f 	lds	r18, 0x0F05	; 0x800f05 <settings+0x45>
    686c:	20 ff       	sbrs	r18, 0
    686e:	09 c0       	rjmp	.+18     	; 0x6882 <printFloat_RateValue+0x1a>
    printFloat(n*INCH_PER_MM,N_DECIMAL_RATEVALUE_INCH);
    6870:	2b e8       	ldi	r18, 0x8B	; 139
    6872:	32 e4       	ldi	r19, 0x42	; 66
    6874:	41 e2       	ldi	r20, 0x21	; 33
    6876:	5d e3       	ldi	r21, 0x3D	; 61
    6878:	0e 94 03 41 	call	0x8206	; 0x8206 <__mulsf3>
    687c:	41 e0       	ldi	r20, 0x01	; 1
    687e:	33 cf       	rjmp	.-410    	; 0x66e6 <printFloat>
    6880:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_RATEVALUE_MM);
    6882:	40 e0       	ldi	r20, 0x00	; 0
    6884:	30 cf       	rjmp	.-416    	; 0x66e6 <printFloat>
    6886:	08 95       	ret

00006888 <probe_configure_invert_mask>:
// Called by probe_init() and the mc_probe() routines. Sets up the probe pin invert mask to
// appropriately set the pin logic according to setting for normal-high/normal-low operation
// and the probing cycle modes for toward-workpiece/away-from-workpiece.
void probe_configure_invert_mask(uint8_t is_probe_away)
{
  probe_invert_mask = 0; // Initialize as zero.
    6888:	10 92 15 0f 	sts	0x0F15, r1	; 0x800f15 <probe_invert_mask>
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_PROBE_PIN)) { probe_invert_mask ^= PROBE_MASK; }
    688c:	90 91 05 0f 	lds	r25, 0x0F05	; 0x800f05 <settings+0x45>
    6890:	99 23       	and	r25, r25
    6892:	1c f0       	brlt	.+6      	; 0x689a <probe_configure_invert_mask+0x12>
    6894:	90 e8       	ldi	r25, 0x80	; 128
    6896:	90 93 15 0f 	sts	0x0F15, r25	; 0x800f15 <probe_invert_mask>
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
    689a:	88 23       	and	r24, r24
    689c:	29 f0       	breq	.+10     	; 0x68a8 <probe_configure_invert_mask+0x20>
    689e:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <probe_invert_mask>
    68a2:	80 58       	subi	r24, 0x80	; 128
    68a4:	80 93 15 0f 	sts	0x0F15, r24	; 0x800f15 <probe_invert_mask>
    68a8:	08 95       	ret

000068aa <probe_init>:


// Probe pin initialization routine.
void probe_init()
{
  PROBE_DDR &= ~(PROBE_MASK); // Configure as input pins
    68aa:	e7 e0       	ldi	r30, 0x07	; 7
    68ac:	f1 e0       	ldi	r31, 0x01	; 1
    68ae:	80 81       	ld	r24, Z
    68b0:	8f 77       	andi	r24, 0x7F	; 127
    68b2:	80 83       	st	Z, r24
  #ifdef DISABLE_PROBE_PIN_PULL_UP
    PROBE_PORT &= ~(PROBE_MASK); // Normal low operation. Requires external pull-down.
  #else
    PROBE_PORT |= PROBE_MASK;    // Enable internal pull-up resistors. Normal high operation.
    68b4:	e8 e0       	ldi	r30, 0x08	; 8
    68b6:	f1 e0       	ldi	r31, 0x01	; 1
    68b8:	80 81       	ld	r24, Z
    68ba:	80 68       	ori	r24, 0x80	; 128
    68bc:	80 83       	st	Z, r24
  #endif
  probe_configure_invert_mask(false); // Initialize invert mask.
    68be:	80 e0       	ldi	r24, 0x00	; 0
    68c0:	e3 cf       	rjmp	.-58     	; 0x6888 <probe_configure_invert_mask>
    68c2:	08 95       	ret

000068c4 <probe_get_state>:
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
}


// Returns the probe pin state. Triggered = true. Called by gcode parser and probe state monitor.
uint8_t probe_get_state() { return((PROBE_PIN & PROBE_MASK) ^ probe_invert_mask); }
    68c4:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
    68c8:	80 78       	andi	r24, 0x80	; 128
    68ca:	90 91 15 0f 	lds	r25, 0x0F15	; 0x800f15 <probe_invert_mask>
    68ce:	89 27       	eor	r24, r25
    68d0:	08 95       	ret

000068d2 <probe_state_monitor>:
// Monitors probe pin state and records the system position when detected. Called by the
// stepper ISR per ISR tick.
// NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
void probe_state_monitor()
{
  if (probe_get_state()) {
    68d2:	f8 df       	rcall	.-16     	; 0x68c4 <probe_get_state>
    68d4:	88 23       	and	r24, r24
    68d6:	81 f0       	breq	.+32     	; 0x68f8 <probe_state_monitor+0x26>
    sys_probe_state = PROBE_OFF;
    68d8:	10 92 2a 0c 	sts	0x0C2A, r1	; 0x800c2a <sys_probe_state>
    memcpy(sys_probe_position, sys_position, sizeof(sys_position));
    68dc:	8c e0       	ldi	r24, 0x0C	; 12
    68de:	e7 e3       	ldi	r30, 0x37	; 55
    68e0:	fc e0       	ldi	r31, 0x0C	; 12
    68e2:	ab e2       	ldi	r26, 0x2B	; 43
    68e4:	bc e0       	ldi	r27, 0x0C	; 12
    68e6:	01 90       	ld	r0, Z+
    68e8:	0d 92       	st	X+, r0
    68ea:	8a 95       	dec	r24
    68ec:	e1 f7       	brne	.-8      	; 0x68e6 <probe_state_monitor+0x14>
    bit_true(sys_rt_exec_state, EXEC_MOTION_CANCEL);
    68ee:	80 91 29 0c 	lds	r24, 0x0C29	; 0x800c29 <sys_rt_exec_state>
    68f2:	80 64       	ori	r24, 0x40	; 64
    68f4:	80 93 29 0c 	sts	0x0C29, r24	; 0x800c29 <sys_rt_exec_state>
    68f8:	08 95       	ret

000068fa <report_util_line_feed>:
// and has been sent into protocol_execute_line() routine to be executed by Grbl.
void report_echo_line_received(char *line)
{
  printPgmString(PSTR("[echo: ")); printString(line);
  report_util_feedback_line_feed();
}
    68fa:	86 e1       	ldi	r24, 0x16	; 22
    68fc:	95 e0       	ldi	r25, 0x05	; 5
    68fe:	32 ce       	rjmp	.-924    	; 0x6564 <printPgmString>
    6900:	08 95       	ret

00006902 <report_util_feedback_line_feed>:
    6902:	8d e5       	ldi	r24, 0x5D	; 93
    6904:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6908:	f8 cf       	rjmp	.-16     	; 0x68fa <report_util_line_feed>
    690a:	08 95       	ret

0000690c <report_util_axis_values>:
    690c:	0f 93       	push	r16
    690e:	1f 93       	push	r17
    6910:	cf 93       	push	r28
    6912:	8c 01       	movw	r16, r24
    6914:	c0 e0       	ldi	r28, 0x00	; 0
    6916:	f8 01       	movw	r30, r16
    6918:	61 91       	ld	r22, Z+
    691a:	71 91       	ld	r23, Z+
    691c:	81 91       	ld	r24, Z+
    691e:	91 91       	ld	r25, Z+
    6920:	8f 01       	movw	r16, r30
    6922:	92 df       	rcall	.-220    	; 0x6848 <printFloat_CoordValue>
    6924:	c2 30       	cpi	r28, 0x02	; 2
    6926:	18 f4       	brcc	.+6      	; 0x692e <report_util_axis_values+0x22>
    6928:	8c e2       	ldi	r24, 0x2C	; 44
    692a:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    692e:	cf 5f       	subi	r28, 0xFF	; 255
    6930:	c3 30       	cpi	r28, 0x03	; 3
    6932:	89 f7       	brne	.-30     	; 0x6916 <report_util_axis_values+0xa>
    6934:	cf 91       	pop	r28
    6936:	1f 91       	pop	r17
    6938:	0f 91       	pop	r16
    693a:	08 95       	ret

0000693c <report_util_setting_prefix>:
    693c:	cf 93       	push	r28
    693e:	c8 2f       	mov	r28, r24
    6940:	84 e2       	ldi	r24, 0x24	; 36
    6942:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6946:	8c 2f       	mov	r24, r28
    6948:	1f de       	rcall	.-962    	; 0x6588 <print_uint8_base10>
    694a:	8d e3       	ldi	r24, 0x3D	; 61
    694c:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6950:	cf 91       	pop	r28
    6952:	08 95       	ret

00006954 <report_util_uint8_setting>:
    6954:	cf 93       	push	r28
    6956:	c6 2f       	mov	r28, r22
    6958:	f1 df       	rcall	.-30     	; 0x693c <report_util_setting_prefix>
    695a:	8c 2f       	mov	r24, r28
    695c:	15 de       	rcall	.-982    	; 0x6588 <print_uint8_base10>
    695e:	cd df       	rcall	.-102    	; 0x68fa <report_util_line_feed>
    6960:	cf 91       	pop	r28
    6962:	08 95       	ret

00006964 <report_util_float_setting>:
    6964:	cf 92       	push	r12
    6966:	df 92       	push	r13
    6968:	ef 92       	push	r14
    696a:	ff 92       	push	r15
    696c:	cf 93       	push	r28
    696e:	6a 01       	movw	r12, r20
    6970:	7b 01       	movw	r14, r22
    6972:	c2 2f       	mov	r28, r18
    6974:	e3 df       	rcall	.-58     	; 0x693c <report_util_setting_prefix>
    6976:	4c 2f       	mov	r20, r28
    6978:	c7 01       	movw	r24, r14
    697a:	b6 01       	movw	r22, r12
    697c:	b4 de       	rcall	.-664    	; 0x66e6 <printFloat>
    697e:	bd df       	rcall	.-134    	; 0x68fa <report_util_line_feed>
    6980:	cf 91       	pop	r28
    6982:	ff 90       	pop	r15
    6984:	ef 90       	pop	r14
    6986:	df 90       	pop	r13
    6988:	cf 90       	pop	r12
    698a:	08 95       	ret

0000698c <report_status_message>:
    698c:	cf 93       	push	r28
    698e:	c8 2f       	mov	r28, r24
    6990:	81 11       	cpse	r24, r1
    6992:	04 c0       	rjmp	.+8      	; 0x699c <report_status_message+0x10>
    6994:	80 e2       	ldi	r24, 0x20	; 32
    6996:	95 e0       	ldi	r25, 0x05	; 5
    6998:	e5 dd       	rcall	.-1078   	; 0x6564 <printPgmString>
    699a:	06 c0       	rjmp	.+12     	; 0x69a8 <report_status_message+0x1c>
    699c:	89 e1       	ldi	r24, 0x19	; 25
    699e:	95 e0       	ldi	r25, 0x05	; 5
    69a0:	e1 dd       	rcall	.-1086   	; 0x6564 <printPgmString>
    69a2:	8c 2f       	mov	r24, r28
    69a4:	f1 dd       	rcall	.-1054   	; 0x6588 <print_uint8_base10>
    69a6:	a9 df       	rcall	.-174    	; 0x68fa <report_util_line_feed>
    69a8:	cf 91       	pop	r28
    69aa:	08 95       	ret

000069ac <report_alarm_message>:
    69ac:	cf 93       	push	r28
    69ae:	c8 2f       	mov	r28, r24
    69b0:	8f e0       	ldi	r24, 0x0F	; 15
    69b2:	95 e0       	ldi	r25, 0x05	; 5
    69b4:	d7 dd       	rcall	.-1106   	; 0x6564 <printPgmString>
    69b6:	8c 2f       	mov	r24, r28
    69b8:	e7 dd       	rcall	.-1074   	; 0x6588 <print_uint8_base10>
    69ba:	9f df       	rcall	.-194    	; 0x68fa <report_util_line_feed>
    69bc:	84 ef       	ldi	r24, 0xF4	; 244
    69be:	91 e0       	ldi	r25, 0x01	; 1
    69c0:	b7 d9       	rcall	.-3218   	; 0x5d30 <delay_ms>
    69c2:	cf 91       	pop	r28
    69c4:	08 95       	ret

000069c6 <report_synchronization_state>:
    69c6:	8a e0       	ldi	r24, 0x0A	; 10
    69c8:	95 e0       	ldi	r25, 0x05	; 5
    69ca:	cc dd       	rcall	.-1128   	; 0x6564 <printPgmString>
    69cc:	60 91 45 0c 	lds	r22, 0x0C45	; 0x800c45 <sys_index_pulse_count>
    69d0:	70 e0       	ldi	r23, 0x00	; 0
    69d2:	80 e0       	ldi	r24, 0x00	; 0
    69d4:	90 e0       	ldi	r25, 0x00	; 0
    69d6:	17 de       	rcall	.-978    	; 0x6606 <print_uint32_base10>
    69d8:	84 e0       	ldi	r24, 0x04	; 4
    69da:	95 e0       	ldi	r25, 0x05	; 5
    69dc:	c3 dd       	rcall	.-1146   	; 0x6564 <printPgmString>
    69de:	60 91 11 0c 	lds	r22, 0x0C11	; 0x800c11 <sys_synchronization_pulse_count>
    69e2:	70 91 12 0c 	lds	r23, 0x0C12	; 0x800c12 <sys_synchronization_pulse_count+0x1>
    69e6:	80 91 13 0c 	lds	r24, 0x0C13	; 0x800c13 <sys_synchronization_pulse_count+0x2>
    69ea:	90 91 14 0c 	lds	r25, 0x0C14	; 0x800c14 <sys_synchronization_pulse_count+0x3>
    69ee:	0b de       	rcall	.-1002   	; 0x6606 <print_uint32_base10>
    69f0:	84 cf       	rjmp	.-248    	; 0x68fa <report_util_line_feed>
    69f2:	08 95       	ret

000069f4 <report_feedback_message>:
    69f4:	cf 93       	push	r28
    69f6:	c8 2f       	mov	r28, r24
    69f8:	8e ef       	ldi	r24, 0xFE	; 254
    69fa:	94 e0       	ldi	r25, 0x04	; 4
    69fc:	b3 dd       	rcall	.-1178   	; 0x6564 <printPgmString>
    69fe:	8c 2f       	mov	r24, r28
    6a00:	90 e0       	ldi	r25, 0x00	; 0
    6a02:	fc 01       	movw	r30, r24
    6a04:	31 97       	sbiw	r30, 0x01	; 1
    6a06:	eb 30       	cpi	r30, 0x0B	; 11
    6a08:	f1 05       	cpc	r31, r1
    6a0a:	88 f5       	brcc	.+98     	; 0x6a6e <report_feedback_message+0x7a>
    6a0c:	88 27       	eor	r24, r24
    6a0e:	ec 5b       	subi	r30, 0xBC	; 188
    6a10:	fe 4f       	sbci	r31, 0xFE	; 254
    6a12:	8f 4f       	sbci	r24, 0xFF	; 255
    6a14:	0c 94 12 42 	jmp	0x8424	; 0x8424 <__tablejump2__>
    6a18:	8c ee       	ldi	r24, 0xEC	; 236
    6a1a:	94 e0       	ldi	r25, 0x04	; 4
    6a1c:	a3 dd       	rcall	.-1210   	; 0x6564 <printPgmString>
    6a1e:	27 c0       	rjmp	.+78     	; 0x6a6e <report_feedback_message+0x7a>
    6a20:	88 ed       	ldi	r24, 0xD8	; 216
    6a22:	94 e0       	ldi	r25, 0x04	; 4
    6a24:	9f dd       	rcall	.-1218   	; 0x6564 <printPgmString>
    6a26:	23 c0       	rjmp	.+70     	; 0x6a6e <report_feedback_message+0x7a>
    6a28:	86 ec       	ldi	r24, 0xC6	; 198
    6a2a:	94 e0       	ldi	r25, 0x04	; 4
    6a2c:	9b dd       	rcall	.-1226   	; 0x6564 <printPgmString>
    6a2e:	1f c0       	rjmp	.+62     	; 0x6a6e <report_feedback_message+0x7a>
    6a30:	8e eb       	ldi	r24, 0xBE	; 190
    6a32:	94 e0       	ldi	r25, 0x04	; 4
    6a34:	97 dd       	rcall	.-1234   	; 0x6564 <printPgmString>
    6a36:	1b c0       	rjmp	.+54     	; 0x6a6e <report_feedback_message+0x7a>
    6a38:	85 eb       	ldi	r24, 0xB5	; 181
    6a3a:	94 e0       	ldi	r25, 0x04	; 4
    6a3c:	93 dd       	rcall	.-1242   	; 0x6564 <printPgmString>
    6a3e:	17 c0       	rjmp	.+46     	; 0x6a6e <report_feedback_message+0x7a>
    6a40:	8a ea       	ldi	r24, 0xAA	; 170
    6a42:	94 e0       	ldi	r25, 0x04	; 4
    6a44:	8f dd       	rcall	.-1250   	; 0x6564 <printPgmString>
    6a46:	13 c0       	rjmp	.+38     	; 0x6a6e <report_feedback_message+0x7a>
    6a48:	8d e9       	ldi	r24, 0x9D	; 157
    6a4a:	94 e0       	ldi	r25, 0x04	; 4
    6a4c:	8b dd       	rcall	.-1258   	; 0x6564 <printPgmString>
    6a4e:	0f c0       	rjmp	.+30     	; 0x6a6e <report_feedback_message+0x7a>
    6a50:	85 e9       	ldi	r24, 0x95	; 149
    6a52:	94 e0       	ldi	r25, 0x04	; 4
    6a54:	87 dd       	rcall	.-1266   	; 0x6564 <printPgmString>
    6a56:	0b c0       	rjmp	.+22     	; 0x6a6e <report_feedback_message+0x7a>
    6a58:	82 e8       	ldi	r24, 0x82	; 130
    6a5a:	94 e0       	ldi	r25, 0x04	; 4
    6a5c:	83 dd       	rcall	.-1274   	; 0x6564 <printPgmString>
    6a5e:	07 c0       	rjmp	.+14     	; 0x6a6e <report_feedback_message+0x7a>
    6a60:	80 e7       	ldi	r24, 0x70	; 112
    6a62:	94 e0       	ldi	r25, 0x04	; 4
    6a64:	7f dd       	rcall	.-1282   	; 0x6564 <printPgmString>
    6a66:	03 c0       	rjmp	.+6      	; 0x6a6e <report_feedback_message+0x7a>
    6a68:	87 e6       	ldi	r24, 0x67	; 103
    6a6a:	94 e0       	ldi	r25, 0x04	; 4
    6a6c:	7b dd       	rcall	.-1290   	; 0x6564 <printPgmString>
    6a6e:	49 df       	rcall	.-366    	; 0x6902 <report_util_feedback_line_feed>
    6a70:	cf 91       	pop	r28
    6a72:	08 95       	ret

00006a74 <report_init_message>:
    6a74:	8a e4       	ldi	r24, 0x4A	; 74
    6a76:	94 e0       	ldi	r25, 0x04	; 4
    6a78:	75 cd       	rjmp	.-1302   	; 0x6564 <printPgmString>
    6a7a:	08 95       	ret

00006a7c <report_grbl_help>:
    6a7c:	80 e0       	ldi	r24, 0x00	; 0
    6a7e:	94 e0       	ldi	r25, 0x04	; 4
    6a80:	71 cd       	rjmp	.-1310   	; 0x6564 <printPgmString>
    6a82:	08 95       	ret

00006a84 <report_grbl_settings>:
    6a84:	ef 92       	push	r14
    6a86:	ff 92       	push	r15
    6a88:	0f 93       	push	r16
    6a8a:	1f 93       	push	r17
    6a8c:	cf 93       	push	r28
    6a8e:	df 93       	push	r29
    6a90:	00 ec       	ldi	r16, 0xC0	; 192
    6a92:	1e e0       	ldi	r17, 0x0E	; 14
    6a94:	f8 01       	movw	r30, r16
    6a96:	60 a9       	ldd	r22, Z+48	; 0x30
    6a98:	70 e0       	ldi	r23, 0x00	; 0
    6a9a:	80 e0       	ldi	r24, 0x00	; 0
    6a9c:	5b df       	rcall	.-330    	; 0x6954 <report_util_uint8_setting>
    6a9e:	f8 01       	movw	r30, r16
    6aa0:	63 a9       	ldd	r22, Z+51	; 0x33
    6aa2:	70 e0       	ldi	r23, 0x00	; 0
    6aa4:	81 e0       	ldi	r24, 0x01	; 1
    6aa6:	56 df       	rcall	.-340    	; 0x6954 <report_util_uint8_setting>
    6aa8:	f8 01       	movw	r30, r16
    6aaa:	61 a9       	ldd	r22, Z+49	; 0x31
    6aac:	70 e0       	ldi	r23, 0x00	; 0
    6aae:	82 e0       	ldi	r24, 0x02	; 2
    6ab0:	51 df       	rcall	.-350    	; 0x6954 <report_util_uint8_setting>
    6ab2:	f8 01       	movw	r30, r16
    6ab4:	62 a9       	ldd	r22, Z+50	; 0x32
    6ab6:	70 e0       	ldi	r23, 0x00	; 0
    6ab8:	83 e0       	ldi	r24, 0x03	; 3
    6aba:	4c df       	rcall	.-360    	; 0x6954 <report_util_uint8_setting>
    6abc:	c5 e0       	ldi	r28, 0x05	; 5
    6abe:	df e0       	ldi	r29, 0x0F	; 15
    6ac0:	68 81       	ld	r22, Y
    6ac2:	62 fb       	bst	r22, 2
    6ac4:	66 27       	eor	r22, r22
    6ac6:	60 f9       	bld	r22, 0
    6ac8:	70 e0       	ldi	r23, 0x00	; 0
    6aca:	84 e0       	ldi	r24, 0x04	; 4
    6acc:	43 df       	rcall	.-378    	; 0x6954 <report_util_uint8_setting>
    6ace:	68 81       	ld	r22, Y
    6ad0:	66 fb       	bst	r22, 6
    6ad2:	66 27       	eor	r22, r22
    6ad4:	60 f9       	bld	r22, 0
    6ad6:	70 e0       	ldi	r23, 0x00	; 0
    6ad8:	85 e0       	ldi	r24, 0x05	; 5
    6ada:	3c df       	rcall	.-392    	; 0x6954 <report_util_uint8_setting>
    6adc:	88 81       	ld	r24, Y
    6ade:	08 2e       	mov	r0, r24
    6ae0:	00 0c       	add	r0, r0
    6ae2:	99 0b       	sbc	r25, r25
    6ae4:	69 2f       	mov	r22, r25
    6ae6:	66 1f       	adc	r22, r22
    6ae8:	66 27       	eor	r22, r22
    6aea:	66 1f       	adc	r22, r22
    6aec:	70 e0       	ldi	r23, 0x00	; 0
    6aee:	86 e0       	ldi	r24, 0x06	; 6
    6af0:	31 df       	rcall	.-414    	; 0x6954 <report_util_uint8_setting>
    6af2:	f8 01       	movw	r30, r16
    6af4:	64 a9       	ldd	r22, Z+52	; 0x34
    6af6:	70 e0       	ldi	r23, 0x00	; 0
    6af8:	8a e0       	ldi	r24, 0x0A	; 10
    6afa:	2c df       	rcall	.-424    	; 0x6954 <report_util_uint8_setting>
    6afc:	f8 01       	movw	r30, r16
    6afe:	45 a9       	ldd	r20, Z+53	; 0x35
    6b00:	56 a9       	ldd	r21, Z+54	; 0x36
    6b02:	67 a9       	ldd	r22, Z+55	; 0x37
    6b04:	70 ad       	ldd	r23, Z+56	; 0x38
    6b06:	23 e0       	ldi	r18, 0x03	; 3
    6b08:	8b e0       	ldi	r24, 0x0B	; 11
    6b0a:	2c df       	rcall	.-424    	; 0x6964 <report_util_float_setting>
    6b0c:	f8 01       	movw	r30, r16
    6b0e:	41 ad       	ldd	r20, Z+57	; 0x39
    6b10:	52 ad       	ldd	r21, Z+58	; 0x3a
    6b12:	63 ad       	ldd	r22, Z+59	; 0x3b
    6b14:	74 ad       	ldd	r23, Z+60	; 0x3c
    6b16:	23 e0       	ldi	r18, 0x03	; 3
    6b18:	8c e0       	ldi	r24, 0x0C	; 12
    6b1a:	24 df       	rcall	.-440    	; 0x6964 <report_util_float_setting>
    6b1c:	68 81       	ld	r22, Y
    6b1e:	61 70       	andi	r22, 0x01	; 1
    6b20:	70 e0       	ldi	r23, 0x00	; 0
    6b22:	8d e0       	ldi	r24, 0x0D	; 13
    6b24:	17 df       	rcall	.-466    	; 0x6954 <report_util_uint8_setting>
    6b26:	68 81       	ld	r22, Y
    6b28:	65 fb       	bst	r22, 5
    6b2a:	66 27       	eor	r22, r22
    6b2c:	60 f9       	bld	r22, 0
    6b2e:	70 e0       	ldi	r23, 0x00	; 0
    6b30:	84 e1       	ldi	r24, 0x14	; 20
    6b32:	10 df       	rcall	.-480    	; 0x6954 <report_util_uint8_setting>
    6b34:	68 81       	ld	r22, Y
    6b36:	63 fb       	bst	r22, 3
    6b38:	66 27       	eor	r22, r22
    6b3a:	60 f9       	bld	r22, 0
    6b3c:	70 e0       	ldi	r23, 0x00	; 0
    6b3e:	85 e1       	ldi	r24, 0x15	; 21
    6b40:	09 df       	rcall	.-494    	; 0x6954 <report_util_uint8_setting>
    6b42:	68 81       	ld	r22, Y
    6b44:	62 95       	swap	r22
    6b46:	61 70       	andi	r22, 0x01	; 1
    6b48:	70 e0       	ldi	r23, 0x00	; 0
    6b4a:	86 e1       	ldi	r24, 0x16	; 22
    6b4c:	03 df       	rcall	.-506    	; 0x6954 <report_util_uint8_setting>
    6b4e:	60 91 06 0f 	lds	r22, 0x0F06	; 0x800f06 <settings+0x46>
    6b52:	70 e0       	ldi	r23, 0x00	; 0
    6b54:	87 e1       	ldi	r24, 0x17	; 23
    6b56:	fe de       	rcall	.-516    	; 0x6954 <report_util_uint8_setting>
    6b58:	40 91 07 0f 	lds	r20, 0x0F07	; 0x800f07 <settings+0x47>
    6b5c:	50 91 08 0f 	lds	r21, 0x0F08	; 0x800f08 <settings+0x48>
    6b60:	60 91 09 0f 	lds	r22, 0x0F09	; 0x800f09 <settings+0x49>
    6b64:	70 91 0a 0f 	lds	r23, 0x0F0A	; 0x800f0a <settings+0x4a>
    6b68:	23 e0       	ldi	r18, 0x03	; 3
    6b6a:	88 e1       	ldi	r24, 0x18	; 24
    6b6c:	fb de       	rcall	.-522    	; 0x6964 <report_util_float_setting>
    6b6e:	40 91 0b 0f 	lds	r20, 0x0F0B	; 0x800f0b <settings+0x4b>
    6b72:	50 91 0c 0f 	lds	r21, 0x0F0C	; 0x800f0c <settings+0x4c>
    6b76:	60 91 0d 0f 	lds	r22, 0x0F0D	; 0x800f0d <settings+0x4d>
    6b7a:	70 91 0e 0f 	lds	r23, 0x0F0E	; 0x800f0e <settings+0x4e>
    6b7e:	23 e0       	ldi	r18, 0x03	; 3
    6b80:	89 e1       	ldi	r24, 0x19	; 25
    6b82:	f0 de       	rcall	.-544    	; 0x6964 <report_util_float_setting>
    6b84:	60 91 0f 0f 	lds	r22, 0x0F0F	; 0x800f0f <settings+0x4f>
    6b88:	70 91 10 0f 	lds	r23, 0x0F10	; 0x800f10 <settings+0x50>
    6b8c:	8a e1       	ldi	r24, 0x1A	; 26
    6b8e:	e2 de       	rcall	.-572    	; 0x6954 <report_util_uint8_setting>
    6b90:	40 91 11 0f 	lds	r20, 0x0F11	; 0x800f11 <settings+0x51>
    6b94:	50 91 12 0f 	lds	r21, 0x0F12	; 0x800f12 <settings+0x52>
    6b98:	60 91 13 0f 	lds	r22, 0x0F13	; 0x800f13 <settings+0x53>
    6b9c:	70 91 14 0f 	lds	r23, 0x0F14	; 0x800f14 <settings+0x54>
    6ba0:	23 e0       	ldi	r18, 0x03	; 3
    6ba2:	8b e1       	ldi	r24, 0x1B	; 27
    6ba4:	df de       	rcall	.-578    	; 0x6964 <report_util_float_setting>
    6ba6:	40 91 fd 0e 	lds	r20, 0x0EFD	; 0x800efd <settings+0x3d>
    6baa:	50 91 fe 0e 	lds	r21, 0x0EFE	; 0x800efe <settings+0x3e>
    6bae:	60 91 ff 0e 	lds	r22, 0x0EFF	; 0x800eff <settings+0x3f>
    6bb2:	70 91 00 0f 	lds	r23, 0x0F00	; 0x800f00 <settings+0x40>
    6bb6:	20 e0       	ldi	r18, 0x00	; 0
    6bb8:	8e e1       	ldi	r24, 0x1E	; 30
    6bba:	d4 de       	rcall	.-600    	; 0x6964 <report_util_float_setting>
    6bbc:	40 91 01 0f 	lds	r20, 0x0F01	; 0x800f01 <settings+0x41>
    6bc0:	50 91 02 0f 	lds	r21, 0x0F02	; 0x800f02 <settings+0x42>
    6bc4:	60 91 03 0f 	lds	r22, 0x0F03	; 0x800f03 <settings+0x43>
    6bc8:	70 91 04 0f 	lds	r23, 0x0F04	; 0x800f04 <settings+0x44>
    6bcc:	20 e0       	ldi	r18, 0x00	; 0
    6bce:	8f e1       	ldi	r24, 0x1F	; 31
    6bd0:	c9 de       	rcall	.-622    	; 0x6964 <report_util_float_setting>
    6bd2:	68 81       	ld	r22, Y
    6bd4:	66 95       	lsr	r22
    6bd6:	61 70       	andi	r22, 0x01	; 1
    6bd8:	70 e0       	ldi	r23, 0x00	; 0
    6bda:	80 e2       	ldi	r24, 0x20	; 32
    6bdc:	bb de       	rcall	.-650    	; 0x6954 <report_util_uint8_setting>
    6bde:	0f 2e       	mov	r0, r31
    6be0:	f4 e6       	ldi	r31, 0x64	; 100
    6be2:	ff 2e       	mov	r15, r31
    6be4:	f0 2d       	mov	r31, r0
    6be6:	d0 e0       	ldi	r29, 0x00	; 0
    6be8:	3f c0       	rjmp	.+126    	; 0x6c68 <report_grbl_settings+0x1e4>
    6bea:	d1 30       	cpi	r29, 0x01	; 1
    6bec:	79 f0       	breq	.+30     	; 0x6c0c <report_grbl_settings+0x188>
    6bee:	28 f0       	brcs	.+10     	; 0x6bfa <report_grbl_settings+0x176>
    6bf0:	d2 30       	cpi	r29, 0x02	; 2
    6bf2:	a9 f0       	breq	.+42     	; 0x6c1e <report_grbl_settings+0x19a>
    6bf4:	d3 30       	cpi	r29, 0x03	; 3
    6bf6:	21 f1       	breq	.+72     	; 0x6c40 <report_grbl_settings+0x1bc>
    6bf8:	2c c0       	rjmp	.+88     	; 0x6c52 <report_grbl_settings+0x1ce>
    6bfa:	f8 01       	movw	r30, r16
    6bfc:	40 81       	ld	r20, Z
    6bfe:	51 81       	ldd	r21, Z+1	; 0x01
    6c00:	62 81       	ldd	r22, Z+2	; 0x02
    6c02:	73 81       	ldd	r23, Z+3	; 0x03
    6c04:	23 e0       	ldi	r18, 0x03	; 3
    6c06:	8c 2f       	mov	r24, r28
    6c08:	ad de       	rcall	.-678    	; 0x6964 <report_util_float_setting>
    6c0a:	23 c0       	rjmp	.+70     	; 0x6c52 <report_grbl_settings+0x1ce>
    6c0c:	f8 01       	movw	r30, r16
    6c0e:	44 85       	ldd	r20, Z+12	; 0x0c
    6c10:	55 85       	ldd	r21, Z+13	; 0x0d
    6c12:	66 85       	ldd	r22, Z+14	; 0x0e
    6c14:	77 85       	ldd	r23, Z+15	; 0x0f
    6c16:	23 e0       	ldi	r18, 0x03	; 3
    6c18:	8c 2f       	mov	r24, r28
    6c1a:	a4 de       	rcall	.-696    	; 0x6964 <report_util_float_setting>
    6c1c:	1a c0       	rjmp	.+52     	; 0x6c52 <report_grbl_settings+0x1ce>
    6c1e:	20 e0       	ldi	r18, 0x00	; 0
    6c20:	30 e0       	ldi	r19, 0x00	; 0
    6c22:	41 e6       	ldi	r20, 0x61	; 97
    6c24:	55 e4       	ldi	r21, 0x45	; 69
    6c26:	f8 01       	movw	r30, r16
    6c28:	60 8d       	ldd	r22, Z+24	; 0x18
    6c2a:	71 8d       	ldd	r23, Z+25	; 0x19
    6c2c:	82 8d       	ldd	r24, Z+26	; 0x1a
    6c2e:	93 8d       	ldd	r25, Z+27	; 0x1b
    6c30:	0e 94 cc 3e 	call	0x7d98	; 0x7d98 <__divsf3>
    6c34:	ab 01       	movw	r20, r22
    6c36:	bc 01       	movw	r22, r24
    6c38:	23 e0       	ldi	r18, 0x03	; 3
    6c3a:	8c 2f       	mov	r24, r28
    6c3c:	93 de       	rcall	.-730    	; 0x6964 <report_util_float_setting>
    6c3e:	09 c0       	rjmp	.+18     	; 0x6c52 <report_grbl_settings+0x1ce>
    6c40:	f8 01       	movw	r30, r16
    6c42:	44 a1       	ldd	r20, Z+36	; 0x24
    6c44:	55 a1       	ldd	r21, Z+37	; 0x25
    6c46:	66 a1       	ldd	r22, Z+38	; 0x26
    6c48:	77 a1       	ldd	r23, Z+39	; 0x27
    6c4a:	70 58       	subi	r23, 0x80	; 128
    6c4c:	23 e0       	ldi	r18, 0x03	; 3
    6c4e:	8c 2f       	mov	r24, r28
    6c50:	89 de       	rcall	.-750    	; 0x6964 <report_util_float_setting>
    6c52:	0c 5f       	subi	r16, 0xFC	; 252
    6c54:	1f 4f       	sbci	r17, 0xFF	; 255
    6c56:	cf 5f       	subi	r28, 0xFF	; 255
    6c58:	ce 11       	cpse	r28, r14
    6c5a:	c7 cf       	rjmp	.-114    	; 0x6bea <report_grbl_settings+0x166>
    6c5c:	fa e0       	ldi	r31, 0x0A	; 10
    6c5e:	ff 0e       	add	r15, r31
    6c60:	df 5f       	subi	r29, 0xFF	; 255
    6c62:	8c e8       	ldi	r24, 0x8C	; 140
    6c64:	f8 16       	cp	r15, r24
    6c66:	49 f0       	breq	.+18     	; 0x6c7a <report_grbl_settings+0x1f6>
    6c68:	00 ec       	ldi	r16, 0xC0	; 192
    6c6a:	1e e0       	ldi	r17, 0x0E	; 14
    6c6c:	0f 2e       	mov	r0, r31
    6c6e:	f3 e0       	ldi	r31, 0x03	; 3
    6c70:	ef 2e       	mov	r14, r31
    6c72:	f0 2d       	mov	r31, r0
    6c74:	ef 0c       	add	r14, r15
    6c76:	cf 2d       	mov	r28, r15
    6c78:	b8 cf       	rjmp	.-144    	; 0x6bea <report_grbl_settings+0x166>
    6c7a:	df 91       	pop	r29
    6c7c:	cf 91       	pop	r28
    6c7e:	1f 91       	pop	r17
    6c80:	0f 91       	pop	r16
    6c82:	ff 90       	pop	r15
    6c84:	ef 90       	pop	r14
    6c86:	08 95       	ret

00006c88 <report_probe_parameters>:
    6c88:	cf 93       	push	r28
    6c8a:	df 93       	push	r29
    6c8c:	cd b7       	in	r28, 0x3d	; 61
    6c8e:	de b7       	in	r29, 0x3e	; 62
    6c90:	2c 97       	sbiw	r28, 0x0c	; 12
    6c92:	0f b6       	in	r0, 0x3f	; 63
    6c94:	f8 94       	cli
    6c96:	de bf       	out	0x3e, r29	; 62
    6c98:	0f be       	out	0x3f, r0	; 63
    6c9a:	cd bf       	out	0x3d, r28	; 61
    6c9c:	8a ef       	ldi	r24, 0xFA	; 250
    6c9e:	93 e0       	ldi	r25, 0x03	; 3
    6ca0:	61 dc       	rcall	.-1854   	; 0x6564 <printPgmString>
    6ca2:	6b e2       	ldi	r22, 0x2B	; 43
    6ca4:	7c e0       	ldi	r23, 0x0C	; 12
    6ca6:	ce 01       	movw	r24, r28
    6ca8:	01 96       	adiw	r24, 0x01	; 1
    6caa:	20 d4       	rcall	.+2112   	; 0x74ec <system_convert_array_steps_to_mpos>
    6cac:	ce 01       	movw	r24, r28
    6cae:	01 96       	adiw	r24, 0x01	; 1
    6cb0:	2d de       	rcall	.-934    	; 0x690c <report_util_axis_values>
    6cb2:	8a e3       	ldi	r24, 0x3A	; 58
    6cb4:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6cb8:	80 91 1b 0c 	lds	r24, 0x0C1B	; 0x800c1b <sys+0x5>
    6cbc:	65 dc       	rcall	.-1846   	; 0x6588 <print_uint8_base10>
    6cbe:	21 de       	rcall	.-958    	; 0x6902 <report_util_feedback_line_feed>
    6cc0:	2c 96       	adiw	r28, 0x0c	; 12
    6cc2:	0f b6       	in	r0, 0x3f	; 63
    6cc4:	f8 94       	cli
    6cc6:	de bf       	out	0x3e, r29	; 62
    6cc8:	0f be       	out	0x3f, r0	; 63
    6cca:	cd bf       	out	0x3d, r28	; 61
    6ccc:	df 91       	pop	r29
    6cce:	cf 91       	pop	r28
    6cd0:	08 95       	ret

00006cd2 <report_ngc_parameters>:
    6cd2:	0f 93       	push	r16
    6cd4:	1f 93       	push	r17
    6cd6:	cf 93       	push	r28
    6cd8:	df 93       	push	r29
    6cda:	cd b7       	in	r28, 0x3d	; 61
    6cdc:	de b7       	in	r29, 0x3e	; 62
    6cde:	2c 97       	sbiw	r28, 0x0c	; 12
    6ce0:	0f b6       	in	r0, 0x3f	; 63
    6ce2:	f8 94       	cli
    6ce4:	de bf       	out	0x3e, r29	; 62
    6ce6:	0f be       	out	0x3f, r0	; 63
    6ce8:	cd bf       	out	0x3d, r28	; 61
    6cea:	01 e0       	ldi	r16, 0x01	; 1
    6cec:	01 c0       	rjmp	.+2      	; 0x6cf0 <report_ngc_parameters+0x1e>
    6cee:	0f 5f       	subi	r16, 0xFF	; 255
    6cf0:	1f ef       	ldi	r17, 0xFF	; 255
    6cf2:	10 0f       	add	r17, r16
    6cf4:	be 01       	movw	r22, r28
    6cf6:	6f 5f       	subi	r22, 0xFF	; 255
    6cf8:	7f 4f       	sbci	r23, 0xFF	; 255
    6cfa:	81 2f       	mov	r24, r17
    6cfc:	0e 94 82 25 	call	0x4b04	; 0x4b04 <settings_read_coord_data>
    6d00:	81 11       	cpse	r24, r1
    6d02:	03 c0       	rjmp	.+6      	; 0x6d0a <report_ngc_parameters+0x38>
    6d04:	87 e0       	ldi	r24, 0x07	; 7
    6d06:	42 de       	rcall	.-892    	; 0x698c <report_status_message>
    6d08:	40 c0       	rjmp	.+128    	; 0x6d8a <report_ngc_parameters+0xb8>
    6d0a:	87 ef       	ldi	r24, 0xF7	; 247
    6d0c:	93 e0       	ldi	r25, 0x03	; 3
    6d0e:	2a dc       	rcall	.-1964   	; 0x6564 <printPgmString>
    6d10:	16 30       	cpi	r17, 0x06	; 6
    6d12:	19 f0       	breq	.+6      	; 0x6d1a <report_ngc_parameters+0x48>
    6d14:	17 30       	cpi	r17, 0x07	; 7
    6d16:	61 f0       	breq	.+24     	; 0x6d30 <report_ngc_parameters+0x5e>
    6d18:	16 c0       	rjmp	.+44     	; 0x6d46 <report_ngc_parameters+0x74>
    6d1a:	84 ef       	ldi	r24, 0xF4	; 244
    6d1c:	93 e0       	ldi	r25, 0x03	; 3
    6d1e:	22 dc       	rcall	.-1980   	; 0x6564 <printPgmString>
    6d20:	8a e3       	ldi	r24, 0x3A	; 58
    6d22:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6d26:	ce 01       	movw	r24, r28
    6d28:	01 96       	adiw	r24, 0x01	; 1
    6d2a:	f0 dd       	rcall	.-1056   	; 0x690c <report_util_axis_values>
    6d2c:	ea dd       	rcall	.-1068   	; 0x6902 <report_util_feedback_line_feed>
    6d2e:	df cf       	rjmp	.-66     	; 0x6cee <report_ngc_parameters+0x1c>
    6d30:	81 ef       	ldi	r24, 0xF1	; 241
    6d32:	93 e0       	ldi	r25, 0x03	; 3
    6d34:	17 dc       	rcall	.-2002   	; 0x6564 <printPgmString>
    6d36:	8a e3       	ldi	r24, 0x3A	; 58
    6d38:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6d3c:	ce 01       	movw	r24, r28
    6d3e:	01 96       	adiw	r24, 0x01	; 1
    6d40:	e5 dd       	rcall	.-1078   	; 0x690c <report_util_axis_values>
    6d42:	df dd       	rcall	.-1090   	; 0x6902 <report_util_feedback_line_feed>
    6d44:	0d c0       	rjmp	.+26     	; 0x6d60 <report_ngc_parameters+0x8e>
    6d46:	85 e3       	ldi	r24, 0x35	; 53
    6d48:	80 0f       	add	r24, r16
    6d4a:	1e dc       	rcall	.-1988   	; 0x6588 <print_uint8_base10>
    6d4c:	8a e3       	ldi	r24, 0x3A	; 58
    6d4e:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6d52:	ce 01       	movw	r24, r28
    6d54:	01 96       	adiw	r24, 0x01	; 1
    6d56:	da dd       	rcall	.-1100   	; 0x690c <report_util_axis_values>
    6d58:	d4 dd       	rcall	.-1112   	; 0x6902 <report_util_feedback_line_feed>
    6d5a:	08 30       	cpi	r16, 0x08	; 8
    6d5c:	08 f4       	brcc	.+2      	; 0x6d60 <report_ngc_parameters+0x8e>
    6d5e:	c7 cf       	rjmp	.-114    	; 0x6cee <report_ngc_parameters+0x1c>
    6d60:	8b ee       	ldi	r24, 0xEB	; 235
    6d62:	93 e0       	ldi	r25, 0x03	; 3
    6d64:	ff db       	rcall	.-2050   	; 0x6564 <printPgmString>
    6d66:	86 e7       	ldi	r24, 0x76	; 118
    6d68:	9c e0       	ldi	r25, 0x0C	; 12
    6d6a:	d0 dd       	rcall	.-1120   	; 0x690c <report_util_axis_values>
    6d6c:	ca dd       	rcall	.-1132   	; 0x6902 <report_util_feedback_line_feed>
    6d6e:	85 ee       	ldi	r24, 0xE5	; 229
    6d70:	93 e0       	ldi	r25, 0x03	; 3
    6d72:	f8 db       	rcall	.-2064   	; 0x6564 <printPgmString>
    6d74:	60 91 82 0c 	lds	r22, 0x0C82	; 0x800c82 <gc_state+0x3c>
    6d78:	70 91 83 0c 	lds	r23, 0x0C83	; 0x800c83 <gc_state+0x3d>
    6d7c:	80 91 84 0c 	lds	r24, 0x0C84	; 0x800c84 <gc_state+0x3e>
    6d80:	90 91 85 0c 	lds	r25, 0x0C85	; 0x800c85 <gc_state+0x3f>
    6d84:	61 dd       	rcall	.-1342   	; 0x6848 <printFloat_CoordValue>
    6d86:	bd dd       	rcall	.-1158   	; 0x6902 <report_util_feedback_line_feed>
    6d88:	7f df       	rcall	.-258    	; 0x6c88 <report_probe_parameters>
    6d8a:	2c 96       	adiw	r28, 0x0c	; 12
    6d8c:	0f b6       	in	r0, 0x3f	; 63
    6d8e:	f8 94       	cli
    6d90:	de bf       	out	0x3e, r29	; 62
    6d92:	0f be       	out	0x3f, r0	; 63
    6d94:	cd bf       	out	0x3d, r28	; 61
    6d96:	df 91       	pop	r29
    6d98:	cf 91       	pop	r28
    6d9a:	1f 91       	pop	r17
    6d9c:	0f 91       	pop	r16
    6d9e:	08 95       	ret

00006da0 <report_gcode_modes>:
    6da0:	cf 93       	push	r28
    6da2:	df 93       	push	r29
    6da4:	8f ed       	ldi	r24, 0xDF	; 223
    6da6:	93 e0       	ldi	r25, 0x03	; 3
    6da8:	dd db       	rcall	.-2118   	; 0x6564 <printPgmString>
    6daa:	80 91 46 0c 	lds	r24, 0x0C46	; 0x800c46 <gc_state>
    6dae:	8c 38       	cpi	r24, 0x8C	; 140
    6db0:	40 f0       	brcs	.+16     	; 0x6dc2 <report_gcode_modes+0x22>
    6db2:	8b ed       	ldi	r24, 0xDB	; 219
    6db4:	93 e0       	ldi	r25, 0x03	; 3
    6db6:	d6 db       	rcall	.-2132   	; 0x6564 <printPgmString>
    6db8:	80 91 46 0c 	lds	r24, 0x0C46	; 0x800c46 <gc_state>
    6dbc:	8a 58       	subi	r24, 0x8A	; 138
    6dbe:	e4 db       	rcall	.-2104   	; 0x6588 <print_uint8_base10>
    6dc0:	01 c0       	rjmp	.+2      	; 0x6dc4 <report_gcode_modes+0x24>
    6dc2:	e2 db       	rcall	.-2108   	; 0x6588 <print_uint8_base10>
    6dc4:	8f ec       	ldi	r24, 0xCF	; 207
    6dc6:	93 e0       	ldi	r25, 0x03	; 3
    6dc8:	cd db       	rcall	.-2150   	; 0x6564 <printPgmString>
    6dca:	c6 e4       	ldi	r28, 0x46	; 70
    6dcc:	dc e0       	ldi	r29, 0x0C	; 12
    6dce:	8e 81       	ldd	r24, Y+6	; 0x06
    6dd0:	8a 5c       	subi	r24, 0xCA	; 202
    6dd2:	da db       	rcall	.-2124   	; 0x6588 <print_uint8_base10>
    6dd4:	8f ec       	ldi	r24, 0xCF	; 207
    6dd6:	93 e0       	ldi	r25, 0x03	; 3
    6dd8:	c5 db       	rcall	.-2166   	; 0x6564 <printPgmString>
    6dda:	8c 81       	ldd	r24, Y+4	; 0x04
    6ddc:	8f 5e       	subi	r24, 0xEF	; 239
    6dde:	d4 db       	rcall	.-2136   	; 0x6588 <print_uint8_base10>
    6de0:	8f ec       	ldi	r24, 0xCF	; 207
    6de2:	93 e0       	ldi	r25, 0x03	; 3
    6de4:	bf db       	rcall	.-2178   	; 0x6564 <printPgmString>
    6de6:	9a 81       	ldd	r25, Y+2	; 0x02
    6de8:	85 e1       	ldi	r24, 0x15	; 21
    6dea:	89 1b       	sub	r24, r25
    6dec:	cd db       	rcall	.-2150   	; 0x6588 <print_uint8_base10>
    6dee:	8f ec       	ldi	r24, 0xCF	; 207
    6df0:	93 e0       	ldi	r25, 0x03	; 3
    6df2:	b8 db       	rcall	.-2192   	; 0x6564 <printPgmString>
    6df4:	8b 81       	ldd	r24, Y+3	; 0x03
    6df6:	86 5a       	subi	r24, 0xA6	; 166
    6df8:	c7 db       	rcall	.-2162   	; 0x6588 <print_uint8_base10>
    6dfa:	8f ec       	ldi	r24, 0xCF	; 207
    6dfc:	93 e0       	ldi	r25, 0x03	; 3
    6dfe:	b2 db       	rcall	.-2204   	; 0x6564 <printPgmString>
    6e00:	99 81       	ldd	r25, Y+1	; 0x01
    6e02:	8e e5       	ldi	r24, 0x5E	; 94
    6e04:	89 1b       	sub	r24, r25
    6e06:	c0 db       	rcall	.-2176   	; 0x6588 <print_uint8_base10>
    6e08:	8f 81       	ldd	r24, Y+7	; 0x07
    6e0a:	88 23       	and	r24, r24
    6e0c:	89 f0       	breq	.+34     	; 0x6e30 <report_gcode_modes+0x90>
    6e0e:	8c ec       	ldi	r24, 0xCC	; 204
    6e10:	93 e0       	ldi	r25, 0x03	; 3
    6e12:	a8 db       	rcall	.-2224   	; 0x6564 <printPgmString>
    6e14:	80 91 4d 0c 	lds	r24, 0x0C4D	; 0x800c4d <gc_state+0x7>
    6e18:	83 30       	cpi	r24, 0x03	; 3
    6e1a:	29 f0       	breq	.+10     	; 0x6e26 <report_gcode_modes+0x86>
    6e1c:	8e 31       	cpi	r24, 0x1E	; 30
    6e1e:	39 f0       	breq	.+14     	; 0x6e2e <report_gcode_modes+0x8e>
    6e20:	82 30       	cpi	r24, 0x02	; 2
    6e22:	31 f4       	brne	.+12     	; 0x6e30 <report_gcode_modes+0x90>
    6e24:	04 c0       	rjmp	.+8      	; 0x6e2e <report_gcode_modes+0x8e>
    6e26:	80 e3       	ldi	r24, 0x30	; 48
    6e28:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6e2c:	01 c0       	rjmp	.+2      	; 0x6e30 <report_gcode_modes+0x90>
    6e2e:	ac db       	rcall	.-2216   	; 0x6588 <print_uint8_base10>
    6e30:	8c ec       	ldi	r24, 0xCC	; 204
    6e32:	93 e0       	ldi	r25, 0x03	; 3
    6e34:	97 db       	rcall	.-2258   	; 0x6564 <printPgmString>
    6e36:	80 91 4f 0c 	lds	r24, 0x0C4F	; 0x800c4f <gc_state+0x9>
    6e3a:	80 31       	cpi	r24, 0x10	; 16
    6e3c:	29 f0       	breq	.+10     	; 0x6e48 <report_gcode_modes+0xa8>
    6e3e:	80 32       	cpi	r24, 0x20	; 32
    6e40:	39 f0       	breq	.+14     	; 0x6e50 <report_gcode_modes+0xb0>
    6e42:	81 11       	cpse	r24, r1
    6e44:	0c c0       	rjmp	.+24     	; 0x6e5e <report_gcode_modes+0xbe>
    6e46:	08 c0       	rjmp	.+16     	; 0x6e58 <report_gcode_modes+0xb8>
    6e48:	83 e3       	ldi	r24, 0x33	; 51
    6e4a:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6e4e:	07 c0       	rjmp	.+14     	; 0x6e5e <report_gcode_modes+0xbe>
    6e50:	84 e3       	ldi	r24, 0x34	; 52
    6e52:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6e56:	03 c0       	rjmp	.+6      	; 0x6e5e <report_gcode_modes+0xbe>
    6e58:	85 e3       	ldi	r24, 0x35	; 53
    6e5a:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6e5e:	8c ec       	ldi	r24, 0xCC	; 204
    6e60:	93 e0       	ldi	r25, 0x03	; 3
    6e62:	80 db       	rcall	.-2304   	; 0x6564 <printPgmString>
    6e64:	80 91 4e 0c 	lds	r24, 0x0C4E	; 0x800c4e <gc_state+0x8>
    6e68:	88 23       	and	r24, r24
    6e6a:	61 f0       	breq	.+24     	; 0x6e84 <report_gcode_modes+0xe4>
    6e6c:	1c f4       	brge	.+6      	; 0x6e74 <report_gcode_modes+0xd4>
    6e6e:	87 e3       	ldi	r24, 0x37	; 55
    6e70:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6e74:	80 91 4e 0c 	lds	r24, 0x0C4E	; 0x800c4e <gc_state+0x8>
    6e78:	86 ff       	sbrs	r24, 6
    6e7a:	07 c0       	rjmp	.+14     	; 0x6e8a <report_gcode_modes+0xea>
    6e7c:	88 e3       	ldi	r24, 0x38	; 56
    6e7e:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6e82:	03 c0       	rjmp	.+6      	; 0x6e8a <report_gcode_modes+0xea>
    6e84:	89 e3       	ldi	r24, 0x39	; 57
    6e86:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6e8a:	88 ed       	ldi	r24, 0xD8	; 216
    6e8c:	93 e0       	ldi	r25, 0x03	; 3
    6e8e:	6a db       	rcall	.-2348   	; 0x6564 <printPgmString>
    6e90:	c6 e4       	ldi	r28, 0x46	; 70
    6e92:	dc e0       	ldi	r29, 0x0C	; 12
    6e94:	8b 89       	ldd	r24, Y+19	; 0x13
    6e96:	78 db       	rcall	.-2320   	; 0x6588 <print_uint8_base10>
    6e98:	85 ed       	ldi	r24, 0xD5	; 213
    6e9a:	93 e0       	ldi	r25, 0x03	; 3
    6e9c:	63 db       	rcall	.-2362   	; 0x6564 <printPgmString>
    6e9e:	6f 85       	ldd	r22, Y+15	; 0x0f
    6ea0:	78 89       	ldd	r23, Y+16	; 0x10
    6ea2:	89 89       	ldd	r24, Y+17	; 0x11
    6ea4:	9a 89       	ldd	r25, Y+18	; 0x12
    6ea6:	e0 dc       	rcall	.-1600   	; 0x6868 <printFloat_RateValue>
    6ea8:	82 ed       	ldi	r24, 0xD2	; 210
    6eaa:	93 e0       	ldi	r25, 0x03	; 3
    6eac:	5b db       	rcall	.-2378   	; 0x6564 <printPgmString>
    6eae:	6b 85       	ldd	r22, Y+11	; 0x0b
    6eb0:	7c 85       	ldd	r23, Y+12	; 0x0c
    6eb2:	8d 85       	ldd	r24, Y+13	; 0x0d
    6eb4:	9e 85       	ldd	r25, Y+14	; 0x0e
    6eb6:	40 e0       	ldi	r20, 0x00	; 0
    6eb8:	16 dc       	rcall	.-2004   	; 0x66e6 <printFloat>
    6eba:	23 dd       	rcall	.-1466   	; 0x6902 <report_util_feedback_line_feed>
    6ebc:	df 91       	pop	r29
    6ebe:	cf 91       	pop	r28
    6ec0:	08 95       	ret

00006ec2 <report_startup_line>:
    6ec2:	1f 93       	push	r17
    6ec4:	cf 93       	push	r28
    6ec6:	df 93       	push	r29
    6ec8:	18 2f       	mov	r17, r24
    6eca:	eb 01       	movw	r28, r22
    6ecc:	89 ec       	ldi	r24, 0xC9	; 201
    6ece:	93 e0       	ldi	r25, 0x03	; 3
    6ed0:	49 db       	rcall	.-2414   	; 0x6564 <printPgmString>
    6ed2:	81 2f       	mov	r24, r17
    6ed4:	59 db       	rcall	.-2382   	; 0x6588 <print_uint8_base10>
    6ed6:	8d e3       	ldi	r24, 0x3D	; 61
    6ed8:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6edc:	ce 01       	movw	r24, r28
    6ede:	33 db       	rcall	.-2458   	; 0x6546 <printString>
    6ee0:	0c dd       	rcall	.-1512   	; 0x68fa <report_util_line_feed>
    6ee2:	df 91       	pop	r29
    6ee4:	cf 91       	pop	r28
    6ee6:	1f 91       	pop	r17
    6ee8:	08 95       	ret

00006eea <report_execute_startup_message>:
    6eea:	0f 93       	push	r16
    6eec:	1f 93       	push	r17
    6eee:	cf 93       	push	r28
    6ef0:	8c 01       	movw	r16, r24
    6ef2:	c6 2f       	mov	r28, r22
    6ef4:	8e e3       	ldi	r24, 0x3E	; 62
    6ef6:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6efa:	c8 01       	movw	r24, r16
    6efc:	24 db       	rcall	.-2488   	; 0x6546 <printString>
    6efe:	8a e3       	ldi	r24, 0x3A	; 58
    6f00:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6f04:	8c 2f       	mov	r24, r28
    6f06:	42 dd       	rcall	.-1404   	; 0x698c <report_status_message>
    6f08:	cf 91       	pop	r28
    6f0a:	1f 91       	pop	r17
    6f0c:	0f 91       	pop	r16
    6f0e:	08 95       	ret

00006f10 <report_build_info>:
    6f10:	cf 93       	push	r28
    6f12:	df 93       	push	r29
    6f14:	ec 01       	movw	r28, r24
    6f16:	80 eb       	ldi	r24, 0xB0	; 176
    6f18:	93 e0       	ldi	r25, 0x03	; 3
    6f1a:	24 db       	rcall	.-2488   	; 0x6564 <printPgmString>
    6f1c:	ce 01       	movw	r24, r28
    6f1e:	13 db       	rcall	.-2522   	; 0x6546 <printString>
    6f20:	f0 dc       	rcall	.-1568   	; 0x6902 <report_util_feedback_line_feed>
    6f22:	8a ea       	ldi	r24, 0xAA	; 170
    6f24:	93 e0       	ldi	r25, 0x03	; 3
    6f26:	1e db       	rcall	.-2500   	; 0x6564 <printPgmString>
    6f28:	86 e5       	ldi	r24, 0x56	; 86
    6f2a:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6f2e:	8e e4       	ldi	r24, 0x4E	; 78
    6f30:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6f34:	8d e4       	ldi	r24, 0x4D	; 77
    6f36:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6f3a:	8b e2       	ldi	r24, 0x2B	; 43
    6f3c:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6f40:	88 e4       	ldi	r24, 0x48	; 72
    6f42:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6f46:	83 e5       	ldi	r24, 0x53	; 83
    6f48:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6f4c:	8c e4       	ldi	r24, 0x4C	; 76
    6f4e:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6f52:	8c e2       	ldi	r24, 0x2C	; 44
    6f54:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6f58:	83 e2       	ldi	r24, 0x23	; 35
    6f5a:	16 db       	rcall	.-2516   	; 0x6588 <print_uint8_base10>
    6f5c:	8c e2       	ldi	r24, 0x2C	; 44
    6f5e:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    6f62:	8f ef       	ldi	r24, 0xFF	; 255
    6f64:	11 db       	rcall	.-2526   	; 0x6588 <print_uint8_base10>
    6f66:	cd dc       	rcall	.-1638   	; 0x6902 <report_util_feedback_line_feed>
    6f68:	df 91       	pop	r29
    6f6a:	cf 91       	pop	r28
    6f6c:	08 95       	ret

00006f6e <report_realtime_status>:
 // and the actual location of the CNC machine. Users may change the following function to their
 // specific needs, but the desired real-time data report must be as short as possible. This is
 // requires as it minimizes the computational overhead and allows grbl to keep running smoothly,
 // especially during g-code programs with fast, short line segments and high frequency reports (5-20Hz).
void report_realtime_status()
{
    6f6e:	4f 92       	push	r4
    6f70:	5f 92       	push	r5
    6f72:	6f 92       	push	r6
    6f74:	7f 92       	push	r7
    6f76:	8f 92       	push	r8
    6f78:	9f 92       	push	r9
    6f7a:	af 92       	push	r10
    6f7c:	bf 92       	push	r11
    6f7e:	cf 92       	push	r12
    6f80:	df 92       	push	r13
    6f82:	ef 92       	push	r14
    6f84:	ff 92       	push	r15
    6f86:	0f 93       	push	r16
    6f88:	1f 93       	push	r17
    6f8a:	cf 93       	push	r28
    6f8c:	df 93       	push	r29
    6f8e:	cd b7       	in	r28, 0x3d	; 61
    6f90:	de b7       	in	r29, 0x3e	; 62
    6f92:	a4 97       	sbiw	r28, 0x24	; 36
    6f94:	0f b6       	in	r0, 0x3f	; 63
    6f96:	f8 94       	cli
    6f98:	de bf       	out	0x3e, r29	; 62
    6f9a:	0f be       	out	0x3f, r0	; 63
    6f9c:	cd bf       	out	0x3d, r28	; 61
  uint8_t idx;
  int32_t current_position[N_AXIS]; // Copy current state of the system position variable
  memcpy(current_position,sys_position,sizeof(sys_position));
    6f9e:	8c e0       	ldi	r24, 0x0C	; 12
    6fa0:	e7 e3       	ldi	r30, 0x37	; 55
    6fa2:	fc e0       	ldi	r31, 0x0C	; 12
    6fa4:	de 01       	movw	r26, r28
    6fa6:	11 96       	adiw	r26, 0x01	; 1
    6fa8:	01 90       	ld	r0, Z+
    6faa:	0d 92       	st	X+, r0
    6fac:	8a 95       	dec	r24
    6fae:	e1 f7       	brne	.-8      	; 0x6fa8 <report_realtime_status+0x3a>
  float print_position[N_AXIS];
  system_convert_array_steps_to_mpos(print_position,current_position);
    6fb0:	be 01       	movw	r22, r28
    6fb2:	6f 5f       	subi	r22, 0xFF	; 255
    6fb4:	7f 4f       	sbci	r23, 0xFF	; 255
    6fb6:	ce 01       	movw	r24, r28
    6fb8:	0d 96       	adiw	r24, 0x0d	; 13
    6fba:	98 d2       	rcall	.+1328   	; 0x74ec <system_convert_array_steps_to_mpos>

  // Report current machine state and sub-states
  serial_write('<');
    6fbc:	8c e3       	ldi	r24, 0x3C	; 60
    6fbe:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
  switch (sys.state) {
    6fc2:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
    6fc6:	88 30       	cpi	r24, 0x08	; 8
    6fc8:	c9 f0       	breq	.+50     	; 0x6ffc <report_realtime_status+0x8e>
    6fca:	40 f4       	brcc	.+16     	; 0x6fdc <report_realtime_status+0x6e>
    6fcc:	81 30       	cpi	r24, 0x01	; 1
    6fce:	a9 f1       	breq	.+106    	; 0x703a <report_realtime_status+0xcc>
    6fd0:	88 f0       	brcs	.+34     	; 0x6ff4 <report_realtime_status+0x86>
    6fd2:	82 30       	cpi	r24, 0x02	; 2
    6fd4:	b1 f1       	breq	.+108    	; 0x7042 <report_realtime_status+0xd4>
    6fd6:	84 30       	cpi	r24, 0x04	; 4
    6fd8:	61 f1       	breq	.+88     	; 0x7032 <report_realtime_status+0xc4>
    6fda:	55 c0       	rjmp	.+170    	; 0x7086 <report_realtime_status+0x118>
    6fdc:	80 32       	cpi	r24, 0x20	; 32
    6fde:	29 f1       	breq	.+74     	; 0x702a <report_realtime_status+0xbc>
    6fe0:	18 f4       	brcc	.+6      	; 0x6fe8 <report_realtime_status+0x7a>
    6fe2:	80 31       	cpi	r24, 0x10	; 16
    6fe4:	79 f0       	breq	.+30     	; 0x7004 <report_realtime_status+0x96>
    6fe6:	4f c0       	rjmp	.+158    	; 0x7086 <report_realtime_status+0x118>
    6fe8:	80 34       	cpi	r24, 0x40	; 64
    6fea:	79 f1       	breq	.+94     	; 0x704a <report_realtime_status+0xdc>
    6fec:	80 38       	cpi	r24, 0x80	; 128
    6fee:	09 f4       	brne	.+2      	; 0x6ff2 <report_realtime_status+0x84>
    6ff0:	47 c0       	rjmp	.+142    	; 0x7080 <report_realtime_status+0x112>
    6ff2:	49 c0       	rjmp	.+146    	; 0x7086 <report_realtime_status+0x118>
    case STATE_IDLE: printPgmString(PSTR("Idle")); break;
    6ff4:	85 ea       	ldi	r24, 0xA5	; 165
    6ff6:	93 e0       	ldi	r25, 0x03	; 3
    6ff8:	b5 da       	rcall	.-2710   	; 0x6564 <printPgmString>
    6ffa:	45 c0       	rjmp	.+138    	; 0x7086 <report_realtime_status+0x118>
    case STATE_CYCLE: printPgmString(PSTR("Run")); break;
    6ffc:	81 ea       	ldi	r24, 0xA1	; 161
    6ffe:	93 e0       	ldi	r25, 0x03	; 3
    7000:	b1 da       	rcall	.-2718   	; 0x6564 <printPgmString>
    7002:	41 c0       	rjmp	.+130    	; 0x7086 <report_realtime_status+0x118>
    case STATE_HOLD:
      if (!(sys.suspend & SUSPEND_JOG_CANCEL)) {
    7004:	80 91 18 0c 	lds	r24, 0x0C18	; 0x800c18 <sys+0x2>
    7008:	88 23       	and	r24, r24
        printPgmString(PSTR("Hold:"));
    700a:	7c f0       	brlt	.+30     	; 0x702a <report_realtime_status+0xbc>
    700c:	8b e9       	ldi	r24, 0x9B	; 155
    700e:	93 e0       	ldi	r25, 0x03	; 3
    7010:	a9 da       	rcall	.-2734   	; 0x6564 <printPgmString>
        if (sys.suspend & SUSPEND_HOLD_COMPLETE) { serial_write('0'); } // Ready to resume
    7012:	80 91 18 0c 	lds	r24, 0x0C18	; 0x800c18 <sys+0x2>
    7016:	80 ff       	sbrs	r24, 0
    7018:	04 c0       	rjmp	.+8      	; 0x7022 <report_realtime_status+0xb4>
    701a:	80 e3       	ldi	r24, 0x30	; 48
    701c:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    7020:	32 c0       	rjmp	.+100    	; 0x7086 <report_realtime_status+0x118>
        else { serial_write('1'); } // Actively holding
    7022:	81 e3       	ldi	r24, 0x31	; 49
    7024:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
        break;
      } // Continues to print jog state during jog cancel.
    case STATE_JOG: printPgmString(PSTR("Jog")); break;
    7028:	2e c0       	rjmp	.+92     	; 0x7086 <report_realtime_status+0x118>
    702a:	87 e9       	ldi	r24, 0x97	; 151
    702c:	93 e0       	ldi	r25, 0x03	; 3
    702e:	9a da       	rcall	.-2764   	; 0x6564 <printPgmString>
    case STATE_HOMING: printPgmString(PSTR("Home")); break;
    7030:	2a c0       	rjmp	.+84     	; 0x7086 <report_realtime_status+0x118>
    7032:	82 e9       	ldi	r24, 0x92	; 146
    7034:	93 e0       	ldi	r25, 0x03	; 3
    7036:	96 da       	rcall	.-2772   	; 0x6564 <printPgmString>
    case STATE_ALARM: printPgmString(PSTR("Alarm")); break;
    7038:	26 c0       	rjmp	.+76     	; 0x7086 <report_realtime_status+0x118>
    703a:	8c e8       	ldi	r24, 0x8C	; 140
    703c:	93 e0       	ldi	r25, 0x03	; 3
    703e:	92 da       	rcall	.-2780   	; 0x6564 <printPgmString>
    case STATE_CHECK_MODE: printPgmString(PSTR("Check")); break;
    7040:	22 c0       	rjmp	.+68     	; 0x7086 <report_realtime_status+0x118>
    7042:	86 e8       	ldi	r24, 0x86	; 134
    7044:	93 e0       	ldi	r25, 0x03	; 3
    7046:	8e da       	rcall	.-2788   	; 0x6564 <printPgmString>
    7048:	1e c0       	rjmp	.+60     	; 0x7086 <report_realtime_status+0x118>
    case STATE_SAFETY_DOOR:
      printPgmString(PSTR("Door:"));
    704a:	80 e8       	ldi	r24, 0x80	; 128
    704c:	93 e0       	ldi	r25, 0x03	; 3
    704e:	8a da       	rcall	.-2796   	; 0x6564 <printPgmString>
    7050:	80 91 18 0c 	lds	r24, 0x0C18	; 0x800c18 <sys+0x2>
      if (sys.suspend & SUSPEND_INITIATE_RESTORE) {
    7054:	83 ff       	sbrs	r24, 3
    7056:	04 c0       	rjmp	.+8      	; 0x7060 <report_realtime_status+0xf2>
    7058:	83 e3       	ldi	r24, 0x33	; 51
        serial_write('3'); // Restoring
    705a:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    705e:	13 c0       	rjmp	.+38     	; 0x7086 <report_realtime_status+0x118>
    7060:	82 ff       	sbrs	r24, 2
      } else {
        if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
    7062:	0a c0       	rjmp	.+20     	; 0x7078 <report_realtime_status+0x10a>
    7064:	85 ff       	sbrs	r24, 5
          if (sys.suspend & SUSPEND_SAFETY_DOOR_AJAR) {
    7066:	04 c0       	rjmp	.+8      	; 0x7070 <report_realtime_status+0x102>
    7068:	81 e3       	ldi	r24, 0x31	; 49
            serial_write('1'); // Door ajar
    706a:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    706e:	0b c0       	rjmp	.+22     	; 0x7086 <report_realtime_status+0x118>
    7070:	80 e3       	ldi	r24, 0x30	; 48
          } else {
            serial_write('0');
    7072:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    7076:	07 c0       	rjmp	.+14     	; 0x7086 <report_realtime_status+0x118>
          } // Door closed and ready to resume
        } else {
          serial_write('2'); // Retracting
    7078:	82 e3       	ldi	r24, 0x32	; 50
    707a:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    707e:	03 c0       	rjmp	.+6      	; 0x7086 <report_realtime_status+0x118>
        }
      }
      break;
    case STATE_SLEEP: printPgmString(PSTR("Sleep")); break;
    7080:	8a e7       	ldi	r24, 0x7A	; 122
    7082:	93 e0       	ldi	r25, 0x03	; 3
    7084:	6f da       	rcall	.-2850   	; 0x6564 <printPgmString>
    7086:	80 91 f4 0e 	lds	r24, 0x0EF4	; 0x800ef4 <settings+0x34>
    708a:	28 2f       	mov	r18, r24
  }

  float wco[N_AXIS];
  if (bit_isfalse(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE) ||
    708c:	21 70       	andi	r18, 0x01	; 1
    708e:	e2 2e       	mov	r14, r18
    7090:	80 ff       	sbrs	r24, 0
    7092:	04 c0       	rjmp	.+8      	; 0x709c <report_realtime_status+0x12e>
    7094:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0xc>
    7098:	81 11       	cpse	r24, r1
    709a:	52 c0       	rjmp	.+164    	; 0x7140 <report_realtime_status+0x1d2>
    709c:	40 90 82 0c 	lds	r4, 0x0C82	; 0x800c82 <gc_state+0x3c>
      (sys.report_wco_counter == 0) ) {
    for (idx=0; idx< N_AXIS; idx++) {
      // Apply work coordinate offsets and tool length offset to current position.
      wco[idx] = gc_state.coord_system[idx]+gc_state.coord_offset[idx];
      if (idx == TOOL_LENGTH_OFFSET_AXIS) { wco[idx] += gc_state.tool_length_offset; }
    70a0:	50 90 83 0c 	lds	r5, 0x0C83	; 0x800c83 <gc_state+0x3d>
    70a4:	60 90 84 0c 	lds	r6, 0x0C84	; 0x800c84 <gc_state+0x3e>
    70a8:	70 90 85 0c 	lds	r7, 0x0C85	; 0x800c85 <gc_state+0x3f>
    70ac:	0f 2e       	mov	r0, r31
    70ae:	fa e6       	ldi	r31, 0x6A	; 106
    70b0:	cf 2e       	mov	r12, r31
    70b2:	fc e0       	ldi	r31, 0x0C	; 12
    70b4:	df 2e       	mov	r13, r31
    70b6:	f0 2d       	mov	r31, r0
    70b8:	8e 01       	movw	r16, r28
    70ba:	07 5e       	subi	r16, 0xE7	; 231
    70bc:	1f 4f       	sbci	r17, 0xFF	; 255
    70be:	5e 01       	movw	r10, r28
    70c0:	8d e0       	ldi	r24, 0x0D	; 13
    70c2:	a8 0e       	add	r10, r24
    70c4:	b1 1c       	adc	r11, r1
    70c6:	f1 2c       	mov	r15, r1
    70c8:	f6 01       	movw	r30, r12
  float wco[N_AXIS];
  if (bit_isfalse(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE) ||
      (sys.report_wco_counter == 0) ) {
    for (idx=0; idx< N_AXIS; idx++) {
      // Apply work coordinate offsets and tool length offset to current position.
      wco[idx] = gc_state.coord_system[idx]+gc_state.coord_offset[idx];
    70ca:	61 91       	ld	r22, Z+
    70cc:	71 91       	ld	r23, Z+
    70ce:	81 91       	ld	r24, Z+
    70d0:	91 91       	ld	r25, Z+
    70d2:	6f 01       	movw	r12, r30
    70d4:	20 85       	ldd	r18, Z+8	; 0x08
    70d6:	31 85       	ldd	r19, Z+9	; 0x09
    70d8:	42 85       	ldd	r20, Z+10	; 0x0a
    70da:	53 85       	ldd	r21, Z+11	; 0x0b
    70dc:	7d d5       	rcall	.+2810   	; 0x7bd8 <__addsf3>
    70de:	48 01       	movw	r8, r16
    70e0:	f8 01       	movw	r30, r16
    70e2:	60 83       	st	Z, r22
    70e4:	71 83       	std	Z+1, r23	; 0x01
    70e6:	82 83       	std	Z+2, r24	; 0x02
    70e8:	93 83       	std	Z+3, r25	; 0x03
      if (idx == TOOL_LENGTH_OFFSET_AXIS) { wco[idx] += gc_state.tool_length_offset; }
    70ea:	f2 e0       	ldi	r31, 0x02	; 2
    70ec:	ff 12       	cpse	r15, r31
    70ee:	0b c0       	rjmp	.+22     	; 0x7106 <report_realtime_status+0x198>
    70f0:	a3 01       	movw	r20, r6
    70f2:	92 01       	movw	r18, r4
    70f4:	71 d5       	rcall	.+2786   	; 0x7bd8 <__addsf3>
    70f6:	f8 01       	movw	r30, r16
    70f8:	60 83       	st	Z, r22
    70fa:	71 83       	std	Z+1, r23	; 0x01
    70fc:	82 83       	std	Z+2, r24	; 0x02
    70fe:	93 83       	std	Z+3, r25	; 0x03
    7100:	e1 10       	cpse	r14, r1
      if (bit_isfalse(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE)) {
    7102:	1e c0       	rjmp	.+60     	; 0x7140 <report_realtime_status+0x1d2>
    7104:	02 c0       	rjmp	.+4      	; 0x710a <report_realtime_status+0x19c>
    7106:	e1 10       	cpse	r14, r1
    7108:	10 c0       	rjmp	.+32     	; 0x712a <report_realtime_status+0x1bc>
        print_position[idx] -= wco[idx];
    710a:	f4 01       	movw	r30, r8
    710c:	20 81       	ld	r18, Z
    710e:	31 81       	ldd	r19, Z+1	; 0x01
    7110:	42 81       	ldd	r20, Z+2	; 0x02
    7112:	53 81       	ldd	r21, Z+3	; 0x03
    7114:	f5 01       	movw	r30, r10
    7116:	60 81       	ld	r22, Z
    7118:	71 81       	ldd	r23, Z+1	; 0x01
    711a:	82 81       	ldd	r24, Z+2	; 0x02
    711c:	93 81       	ldd	r25, Z+3	; 0x03
    711e:	5b d5       	rcall	.+2742   	; 0x7bd6 <__subsf3>
    7120:	f5 01       	movw	r30, r10
    7122:	60 83       	st	Z, r22
    7124:	71 83       	std	Z+1, r23	; 0x01
    7126:	82 83       	std	Z+2, r24	; 0x02
    7128:	93 83       	std	Z+3, r25	; 0x03
    712a:	f3 94       	inc	r15
  }

  float wco[N_AXIS];
  if (bit_isfalse(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE) ||
      (sys.report_wco_counter == 0) ) {
    for (idx=0; idx< N_AXIS; idx++) {
    712c:	0c 5f       	subi	r16, 0xFC	; 252
    712e:	1f 4f       	sbci	r17, 0xFF	; 255
    7130:	f4 e0       	ldi	r31, 0x04	; 4
    7132:	af 0e       	add	r10, r31
    7134:	b1 1c       	adc	r11, r1
    7136:	23 e0       	ldi	r18, 0x03	; 3
    7138:	f2 12       	cpse	r15, r18
      }
    }
  }

  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE)) {
    713a:	c6 cf       	rjmp	.-116    	; 0x70c8 <report_realtime_status+0x15a>
    713c:	ee 20       	and	r14, r14
    printPgmString(PSTR("|MPos:"));
    713e:	21 f0       	breq	.+8      	; 0x7148 <report_realtime_status+0x1da>
    7140:	83 e7       	ldi	r24, 0x73	; 115
    7142:	93 e0       	ldi	r25, 0x03	; 3
    7144:	0f da       	rcall	.-3042   	; 0x6564 <printPgmString>
  } else {
    printPgmString(PSTR("|WPos:"));
    7146:	03 c0       	rjmp	.+6      	; 0x714e <report_realtime_status+0x1e0>
    7148:	8c e6       	ldi	r24, 0x6C	; 108
    714a:	93 e0       	ldi	r25, 0x03	; 3
  }
  report_util_axis_values(print_position);
    714c:	0b da       	rcall	.-3050   	; 0x6564 <printPgmString>
    714e:	ce 01       	movw	r24, r28
    7150:	0d 96       	adiw	r24, 0x0d	; 13

  // Returns planner and serial read buffer states.
  #ifdef REPORT_FIELD_BUFFER_STATE
    if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_BUFFER_STATE)) {
    7152:	dc db       	rcall	.-2120   	; 0x690c <report_util_axis_values>
    7154:	80 91 f4 0e 	lds	r24, 0x0EF4	; 0x800ef4 <settings+0x34>
    7158:	81 ff       	sbrs	r24, 1
      printPgmString(PSTR("|Bf:"));
    715a:	0c c0       	rjmp	.+24     	; 0x7174 <report_realtime_status+0x206>
    715c:	87 e6       	ldi	r24, 0x67	; 103
    715e:	93 e0       	ldi	r25, 0x03	; 3
    7160:	01 da       	rcall	.-3070   	; 0x6564 <printPgmString>
      print_uint8_base10(plan_get_block_buffer_available());
    7162:	0e 94 81 2d 	call	0x5b02	; 0x5b02 <plan_get_block_buffer_available>
    7166:	10 da       	rcall	.-3040   	; 0x6588 <print_uint8_base10>
    7168:	8c e2       	ldi	r24, 0x2C	; 44
      serial_write(',');
    716a:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    716e:	0e 94 a5 13 	call	0x274a	; 0x274a <serial_get_rx_buffer_available>
      print_uint8_base10(serial_get_rx_buffer_available());
    7172:	0a da       	rcall	.-3052   	; 0x6588 <print_uint8_base10>
    7174:	0e 94 ed 28 	call	0x51da	; 0x51da <plan_get_current_block>
  #endif

  #ifdef REPORT_FIELD_LINE_NUMBERS
    // Report current line number
    plan_block_t * cur_block = plan_get_current_block();
    if (cur_block != NULL) {
    7178:	00 97       	sbiw	r24, 0x00	; 0
      uint32_t ln = cur_block->line_number;
    717a:	81 f0       	breq	.+32     	; 0x719c <report_realtime_status+0x22e>
    717c:	fc 01       	movw	r30, r24
    717e:	c2 88       	ldd	r12, Z+18	; 0x12
    7180:	d3 88       	ldd	r13, Z+19	; 0x13
      if (ln > 0) {
    7182:	e4 88       	ldd	r14, Z+20	; 0x14
    7184:	f5 88       	ldd	r15, Z+21	; 0x15
    7186:	c1 14       	cp	r12, r1
    7188:	d1 04       	cpc	r13, r1
    718a:	e1 04       	cpc	r14, r1
        printPgmString(PSTR("|Ln:"));
    718c:	f1 04       	cpc	r15, r1
    718e:	31 f0       	breq	.+12     	; 0x719c <report_realtime_status+0x22e>
    7190:	82 e6       	ldi	r24, 0x62	; 98
    7192:	93 e0       	ldi	r25, 0x03	; 3
        printInteger(ln);
    7194:	e7 d9       	rcall	.-3122   	; 0x6564 <printPgmString>
    7196:	c7 01       	movw	r24, r14
    7198:	b6 01       	movw	r22, r12
    }
  #endif

  // Report realtime feed speed
  #ifdef REPORT_FIELD_CURRENT_FEED_SPEED
    printPgmString(PSTR("|FS:"));
    719a:	8b da       	rcall	.-2794   	; 0x66b2 <printInteger>
    719c:	8d e5       	ldi	r24, 0x5D	; 93
    719e:	93 e0       	ldi	r25, 0x03	; 3
    printFloat_RateValue(st_get_realtime_rate());
    71a0:	e1 d9       	rcall	.-3134   	; 0x6564 <printPgmString>
    71a2:	0e 94 fd 23 	call	0x47fa	; 0x47fa <st_get_realtime_rate>
    71a6:	60 db       	rcall	.-2368   	; 0x6868 <printFloat_RateValue>
    serial_write(',');
    71a8:	8c e2       	ldi	r24, 0x2C	; 44
    71aa:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    printFloat(sys.spindle_speed,N_DECIMAL_RPMVALUE);
    71ae:	60 91 24 0c 	lds	r22, 0x0C24	; 0x800c24 <sys+0xe>
    71b2:	70 91 25 0c 	lds	r23, 0x0C25	; 0x800c25 <sys+0xf>
    71b6:	80 91 26 0c 	lds	r24, 0x0C26	; 0x800c26 <sys+0x10>
    71ba:	90 91 27 0c 	lds	r25, 0x0C27	; 0x800c27 <sys+0x11>
    71be:	40 e0       	ldi	r20, 0x00	; 0
    71c0:	92 da       	rcall	.-2780   	; 0x66e6 <printFloat>
  #endif

  #ifdef REPORT_FIELD_PIN_STATE
    uint8_t lim_pin_state = limits_get_state();
    71c2:	0e 94 cd 2f 	call	0x5f9a	; 0x5f9a <limits_get_state>
    71c6:	08 2f       	mov	r16, r24
    uint8_t ctrl_pin_state = system_control_get_state();
    71c8:	ea d0       	rcall	.+468    	; 0x739e <system_control_get_state>
    71ca:	18 2f       	mov	r17, r24
    71cc:	7b db       	rcall	.-2314   	; 0x68c4 <probe_get_state>
    uint8_t prb_pin_state = probe_get_state();
    71ce:	f8 2e       	mov	r15, r24
    71d0:	80 2f       	mov	r24, r16
    71d2:	81 2b       	or	r24, r17
    if (lim_pin_state | ctrl_pin_state | prb_pin_state) {
    71d4:	8f 29       	or	r24, r15
    71d6:	79 f1       	breq	.+94     	; 0x7236 <report_realtime_status+0x2c8>
    71d8:	88 e5       	ldi	r24, 0x58	; 88
    71da:	93 e0       	ldi	r25, 0x03	; 3
      printPgmString(PSTR("|Pn:"));
    71dc:	c3 d9       	rcall	.-3194   	; 0x6564 <printPgmString>
    71de:	ff 20       	and	r15, r15
    71e0:	19 f0       	breq	.+6      	; 0x71e8 <report_realtime_status+0x27a>
    71e2:	80 e5       	ldi	r24, 0x50	; 80
      if (prb_pin_state) { serial_write('P'); }
    71e4:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    71e8:	00 23       	and	r16, r16
    71ea:	79 f0       	breq	.+30     	; 0x720a <report_realtime_status+0x29c>
    71ec:	00 ff       	sbrs	r16, 0
      if (lim_pin_state) {
    71ee:	03 c0       	rjmp	.+6      	; 0x71f6 <report_realtime_status+0x288>
    71f0:	88 e5       	ldi	r24, 0x58	; 88
        if (bit_istrue(lim_pin_state,bit(X_AXIS))) { serial_write('X'); }
    71f2:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    71f6:	01 ff       	sbrs	r16, 1
    71f8:	03 c0       	rjmp	.+6      	; 0x7200 <report_realtime_status+0x292>
    71fa:	89 e5       	ldi	r24, 0x59	; 89
        if (bit_istrue(lim_pin_state,bit(Y_AXIS))) { serial_write('Y'); }
    71fc:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    7200:	02 ff       	sbrs	r16, 2
    7202:	03 c0       	rjmp	.+6      	; 0x720a <report_realtime_status+0x29c>
    7204:	8a e5       	ldi	r24, 0x5A	; 90
        if (bit_istrue(lim_pin_state,bit(Z_AXIS))) { serial_write('Z'); }
    7206:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    720a:	11 23       	and	r17, r17
    720c:	a1 f0       	breq	.+40     	; 0x7236 <report_realtime_status+0x2c8>
    720e:	10 ff       	sbrs	r17, 0
      }
      if (ctrl_pin_state) {
    7210:	03 c0       	rjmp	.+6      	; 0x7218 <report_realtime_status+0x2aa>
    7212:	84 e4       	ldi	r24, 0x44	; 68
        if (bit_istrue(ctrl_pin_state,CONTROL_PIN_INDEX_SAFETY_DOOR)) { serial_write('D'); }
    7214:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    7218:	11 ff       	sbrs	r17, 1
    721a:	03 c0       	rjmp	.+6      	; 0x7222 <report_realtime_status+0x2b4>
    721c:	82 e5       	ldi	r24, 0x52	; 82
        if (bit_istrue(ctrl_pin_state,CONTROL_PIN_INDEX_RESET)) { serial_write('R'); }
    721e:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    7222:	12 ff       	sbrs	r17, 2
    7224:	03 c0       	rjmp	.+6      	; 0x722c <report_realtime_status+0x2be>
    7226:	88 e4       	ldi	r24, 0x48	; 72
        if (bit_istrue(ctrl_pin_state,CONTROL_PIN_INDEX_FEED_HOLD)) { serial_write('H'); }
    7228:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    722c:	13 ff       	sbrs	r17, 3
    722e:	03 c0       	rjmp	.+6      	; 0x7236 <report_realtime_status+0x2c8>
    7230:	83 e5       	ldi	r24, 0x53	; 83
        if (bit_istrue(ctrl_pin_state,CONTROL_PIN_INDEX_CYCLE_START)) { serial_write('S'); }
    7232:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    7236:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0xc>
    723a:	88 23       	and	r24, r24
      }
    }
  #endif

  #ifdef REPORT_FIELD_WORK_COORD_OFFSET
    if (sys.report_wco_counter > 0) { sys.report_wco_counter--; }
    723c:	21 f0       	breq	.+8      	; 0x7246 <report_realtime_status+0x2d8>
    723e:	81 50       	subi	r24, 0x01	; 1
    7240:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <sys+0xc>
    7244:	18 c0       	rjmp	.+48     	; 0x7276 <report_realtime_status+0x308>
    7246:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
    else {
      if (sys.state & (STATE_HOMING | STATE_CYCLE | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)) {
    724a:	8c 77       	andi	r24, 0x7C	; 124
    724c:	21 f0       	breq	.+8      	; 0x7256 <report_realtime_status+0x2e8>
    724e:	8d e1       	ldi	r24, 0x1D	; 29
        sys.report_wco_counter = (REPORT_WCO_REFRESH_BUSY_COUNT-1); // Reset counter for slow refresh
    7250:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <sys+0xc>
    7254:	03 c0       	rjmp	.+6      	; 0x725c <report_realtime_status+0x2ee>
    7256:	89 e0       	ldi	r24, 0x09	; 9
      } else { sys.report_wco_counter = (REPORT_WCO_REFRESH_IDLE_COUNT-1); }
    7258:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <sys+0xc>
    725c:	80 91 21 0c 	lds	r24, 0x0C21	; 0x800c21 <sys+0xb>
      if (sys.report_ovr_counter == 0) { sys.report_ovr_counter = 1; } // Set override on next report.
    7260:	81 11       	cpse	r24, r1
    7262:	03 c0       	rjmp	.+6      	; 0x726a <report_realtime_status+0x2fc>
    7264:	81 e0       	ldi	r24, 0x01	; 1
    7266:	80 93 21 0c 	sts	0x0C21, r24	; 0x800c21 <sys+0xb>
    726a:	82 e5       	ldi	r24, 0x52	; 82
      printPgmString(PSTR("|WCO:"));
    726c:	93 e0       	ldi	r25, 0x03	; 3
    726e:	7a d9       	rcall	.-3340   	; 0x6564 <printPgmString>
    7270:	ce 01       	movw	r24, r28
      report_util_axis_values(wco);
    7272:	49 96       	adiw	r24, 0x19	; 25
    7274:	4b db       	rcall	.-2410   	; 0x690c <report_util_axis_values>
    7276:	80 91 21 0c 	lds	r24, 0x0C21	; 0x800c21 <sys+0xb>
    }
  #endif

  #ifdef REPORT_FIELD_OVERRIDES
    if (sys.report_ovr_counter > 0) { sys.report_ovr_counter--; }
    727a:	88 23       	and	r24, r24
    727c:	21 f0       	breq	.+8      	; 0x7286 <report_realtime_status+0x318>
    727e:	81 50       	subi	r24, 0x01	; 1
    7280:	80 93 21 0c 	sts	0x0C21, r24	; 0x800c21 <sys+0xb>
    7284:	3b c0       	rjmp	.+118    	; 0x72fc <report_realtime_status+0x38e>
    else {
      if (sys.state & (STATE_HOMING | STATE_CYCLE | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)) {
    7286:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
    728a:	8c 77       	andi	r24, 0x7C	; 124
        sys.report_ovr_counter = (REPORT_OVR_REFRESH_BUSY_COUNT-1); // Reset counter for slow refresh
    728c:	21 f0       	breq	.+8      	; 0x7296 <report_realtime_status+0x328>
    728e:	83 e1       	ldi	r24, 0x13	; 19
    7290:	80 93 21 0c 	sts	0x0C21, r24	; 0x800c21 <sys+0xb>
      } else { sys.report_ovr_counter = (REPORT_OVR_REFRESH_IDLE_COUNT-1); }
    7294:	03 c0       	rjmp	.+6      	; 0x729c <report_realtime_status+0x32e>
    7296:	89 e0       	ldi	r24, 0x09	; 9
    7298:	80 93 21 0c 	sts	0x0C21, r24	; 0x800c21 <sys+0xb>
      printPgmString(PSTR("|Ov:"));
    729c:	8d e4       	ldi	r24, 0x4D	; 77
    729e:	93 e0       	ldi	r25, 0x03	; 3
    72a0:	61 d9       	rcall	.-3390   	; 0x6564 <printPgmString>
      print_uint8_base10(sys.f_override);
    72a2:	06 e1       	ldi	r16, 0x16	; 22
    72a4:	1c e0       	ldi	r17, 0x0C	; 12
    72a6:	f8 01       	movw	r30, r16
    72a8:	87 81       	ldd	r24, Z+7	; 0x07
    72aa:	6e d9       	rcall	.-3364   	; 0x6588 <print_uint8_base10>
    72ac:	8c e2       	ldi	r24, 0x2C	; 44
      serial_write(',');
    72ae:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    72b2:	f8 01       	movw	r30, r16
      print_uint8_base10(sys.r_override);
    72b4:	80 85       	ldd	r24, Z+8	; 0x08
    72b6:	68 d9       	rcall	.-3376   	; 0x6588 <print_uint8_base10>
    72b8:	8c e2       	ldi	r24, 0x2C	; 44
    72ba:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
      serial_write(',');
    72be:	f8 01       	movw	r30, r16
    72c0:	81 85       	ldd	r24, Z+9	; 0x09
      print_uint8_base10(sys.spindle_speed_ovr);
    72c2:	62 d9       	rcall	.-3388   	; 0x6588 <print_uint8_base10>
    72c4:	0e 94 10 12 	call	0x2420	; 0x2420 <spindle_get_state>

      uint8_t sp_state = spindle_get_state();
    72c8:	08 2f       	mov	r16, r24
    72ca:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <coolant_get_state>
      uint8_t cl_state = coolant_get_state();
    72ce:	18 2f       	mov	r17, r24
    72d0:	01 11       	cpse	r16, r1
    72d2:	2e c0       	rjmp	.+92     	; 0x7330 <report_realtime_status+0x3c2>
      if (sp_state || cl_state) {
    72d4:	81 11       	cpse	r24, r1
    72d6:	32 c0       	rjmp	.+100    	; 0x733c <report_realtime_status+0x3ce>
    72d8:	11 c0       	rjmp	.+34     	; 0x72fc <report_realtime_status+0x38e>
        printPgmString(PSTR("|A:"));
        if (sp_state) { // != SPINDLE_STATE_DISABLE
          if (sp_state == SPINDLE_STATE_CW) { serial_write('S'); } // CW
    72da:	83 e5       	ldi	r24, 0x53	; 83
    72dc:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
    72e0:	03 c0       	rjmp	.+6      	; 0x72e8 <report_realtime_status+0x37a>
          else { serial_write('C'); } // CCW
    72e2:	83 e4       	ldi	r24, 0x43	; 67
    72e4:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
        }
        if (cl_state & COOLANT_STATE_FLOOD) { serial_write('F'); }
    72e8:	16 ff       	sbrs	r17, 6
    72ea:	03 c0       	rjmp	.+6      	; 0x72f2 <report_realtime_status+0x384>
    72ec:	86 e4       	ldi	r24, 0x46	; 70
    72ee:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
        if (cl_state & COOLANT_STATE_MIST) { serial_write('M'); }
    72f2:	11 23       	and	r17, r17
    72f4:	1c f4       	brge	.+6      	; 0x72fc <report_realtime_status+0x38e>
    72f6:	8d e4       	ldi	r24, 0x4D	; 77
      }  
    }
  #endif
  
  #ifdef LATHE
      printPgmString(PSTR("|Sp:"));
    72f8:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
      print_uint32_base10(sys_synchronization_pulse_count);
    72fc:	84 e4       	ldi	r24, 0x44	; 68
    72fe:	93 e0       	ldi	r25, 0x03	; 3
    7300:	31 d9       	rcall	.-3486   	; 0x6564 <printPgmString>
    7302:	60 91 11 0c 	lds	r22, 0x0C11	; 0x800c11 <sys_synchronization_pulse_count>
    7306:	70 91 12 0c 	lds	r23, 0x0C12	; 0x800c12 <sys_synchronization_pulse_count+0x1>
    730a:	80 91 13 0c 	lds	r24, 0x0C13	; 0x800c13 <sys_synchronization_pulse_count+0x2>
    730e:	90 91 14 0c 	lds	r25, 0x0C14	; 0x800c14 <sys_synchronization_pulse_count+0x3>
      printPgmString(PSTR("|Si:"));
    7312:	79 d9       	rcall	.-3342   	; 0x6606 <print_uint32_base10>
    7314:	8f e3       	ldi	r24, 0x3F	; 63
    7316:	93 e0       	ldi	r25, 0x03	; 3
      print_uint32_base10(sys_index_pulse_count);
    7318:	25 d9       	rcall	.-3510   	; 0x6564 <printPgmString>
    731a:	60 91 45 0c 	lds	r22, 0x0C45	; 0x800c45 <sys_index_pulse_count>
    731e:	70 e0       	ldi	r23, 0x00	; 0
    7320:	80 e0       	ldi	r24, 0x00	; 0
    7322:	90 e0       	ldi	r25, 0x00	; 0
    7324:	70 d9       	rcall	.-3360   	; 0x6606 <print_uint32_base10>
  #endif

  serial_write('>');
    7326:	8e e3       	ldi	r24, 0x3E	; 62
    7328:	0e 94 c2 13 	call	0x2784	; 0x2784 <serial_write>
  report_util_line_feed();
    732c:	e6 da       	rcall	.-2612   	; 0x68fa <report_util_line_feed>
    732e:	0a c0       	rjmp	.+20     	; 0x7344 <report_realtime_status+0x3d6>
}
    7330:	89 e4       	ldi	r24, 0x49	; 73
      print_uint8_base10(sys.spindle_speed_ovr);

      uint8_t sp_state = spindle_get_state();
      uint8_t cl_state = coolant_get_state();
      if (sp_state || cl_state) {
        printPgmString(PSTR("|A:"));
    7332:	93 e0       	ldi	r25, 0x03	; 3
    7334:	17 d9       	rcall	.-3538   	; 0x6564 <printPgmString>
    7336:	01 30       	cpi	r16, 0x01	; 1
    7338:	a1 f6       	brne	.-88     	; 0x72e2 <report_realtime_status+0x374>
        if (sp_state) { // != SPINDLE_STATE_DISABLE
          if (sp_state == SPINDLE_STATE_CW) { serial_write('S'); } // CW
    733a:	cf cf       	rjmp	.-98     	; 0x72da <report_realtime_status+0x36c>
    733c:	89 e4       	ldi	r24, 0x49	; 73
    733e:	93 e0       	ldi	r25, 0x03	; 3
      print_uint8_base10(sys.spindle_speed_ovr);

      uint8_t sp_state = spindle_get_state();
      uint8_t cl_state = coolant_get_state();
      if (sp_state || cl_state) {
        printPgmString(PSTR("|A:"));
    7340:	11 d9       	rcall	.-3550   	; 0x6564 <printPgmString>
    7342:	d2 cf       	rjmp	.-92     	; 0x72e8 <report_realtime_status+0x37a>
    7344:	a4 96       	adiw	r28, 0x24	; 36
    7346:	0f b6       	in	r0, 0x3f	; 63
    7348:	f8 94       	cli
      print_uint32_base10(sys_index_pulse_count);
  #endif

  serial_write('>');
  report_util_line_feed();
}
    734a:	de bf       	out	0x3e, r29	; 62
    734c:	0f be       	out	0x3f, r0	; 63
    734e:	cd bf       	out	0x3d, r28	; 61
    7350:	df 91       	pop	r29
    7352:	cf 91       	pop	r28
    7354:	1f 91       	pop	r17
    7356:	0f 91       	pop	r16
    7358:	ff 90       	pop	r15
    735a:	ef 90       	pop	r14
    735c:	df 90       	pop	r13
    735e:	cf 90       	pop	r12
    7360:	bf 90       	pop	r11
    7362:	af 90       	pop	r10
    7364:	9f 90       	pop	r9
    7366:	8f 90       	pop	r8
    7368:	7f 90       	pop	r7
    736a:	6f 90       	pop	r6
    736c:	5f 90       	pop	r5
    736e:	4f 90       	pop	r4
    7370:	08 95       	ret

00007372 <report_realtime_debug>:
    7372:	08 95       	ret

00007374 <system_init>:
#include "grbl.h"


void system_init()
{
  CONTROL_DDR &= ~(CONTROL_MASK); // Configure as input pins
    7374:	e7 e0       	ldi	r30, 0x07	; 7
    7376:	f1 e0       	ldi	r31, 0x01	; 1
    7378:	80 81       	ld	r24, Z
    737a:	80 77       	andi	r24, 0x70	; 112
    737c:	80 83       	st	Z, r24
  #ifdef DISABLE_CONTROL_PIN_PULL_UP
    CONTROL_PORT &= ~(CONTROL_MASK); // Normal low operation. Requires external pull-down.
  #else
    CONTROL_PORT |= CONTROL_MASK;   // Enable internal pull-up resistors. Normal high operation.
    737e:	e8 e0       	ldi	r30, 0x08	; 8
    7380:	f1 e0       	ldi	r31, 0x01	; 1
    7382:	80 81       	ld	r24, Z
    7384:	8f 68       	ori	r24, 0x8F	; 143
    7386:	80 83       	st	Z, r24
  #endif
  CONTROL_PCMSK |= CONTROL_MASK;  // Enable specific pins of the Pin Change Interrupt
    7388:	ed e6       	ldi	r30, 0x6D	; 109
    738a:	f0 e0       	ldi	r31, 0x00	; 0
    738c:	80 81       	ld	r24, Z
    738e:	8f 68       	ori	r24, 0x8F	; 143
    7390:	80 83       	st	Z, r24
  PCICR |= (1 << CONTROL_INT);   // Enable Pin Change Interrupt
    7392:	e8 e6       	ldi	r30, 0x68	; 104
    7394:	f0 e0       	ldi	r31, 0x00	; 0
    7396:	80 81       	ld	r24, Z
    7398:	84 60       	ori	r24, 0x04	; 4
    739a:	80 83       	st	Z, r24
    739c:	08 95       	ret

0000739e <system_control_get_state>:
// triggered is 1 and not triggered is 0. Invert mask is applied. Bitfield organization is
// defined by the CONTROL_PIN_INDEX in the header file.
uint8_t system_control_get_state()
{
  uint8_t control_state = 0;
  uint8_t pin = (CONTROL_PIN & CONTROL_MASK);
    739e:	20 91 06 01 	lds	r18, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
    73a2:	32 2f       	mov	r19, r18
    73a4:	3f 78       	andi	r19, 0x8F	; 143
  #ifdef INVERT_CONTROL_PIN_MASK
    pin ^= INVERT_CONTROL_PIN_MASK;
  #endif
  if (pin) {
    73a6:	79 f0       	breq	.+30     	; 0x73c6 <system_control_get_state+0x28>
// Returns control pin state as a uint8 bitfield. Each bit indicates the input pin state, where
// triggered is 1 and not triggered is 0. Invert mask is applied. Bitfield organization is
// defined by the CONTROL_PIN_INDEX in the header file.
uint8_t system_control_get_state()
{
  uint8_t control_state = 0;
    73a8:	23 fb       	bst	r18, 3
    73aa:	88 27       	eor	r24, r24
    73ac:	80 f9       	bld	r24, 0
    73ae:	91 e0       	ldi	r25, 0x01	; 1
    73b0:	89 27       	eor	r24, r25
  #ifdef INVERT_CONTROL_PIN_MASK
    pin ^= INVERT_CONTROL_PIN_MASK;
  #endif
  if (pin) {
    if (bit_isfalse(pin,(1<<CONTROL_SAFETY_DOOR_BIT))) { control_state |= CONTROL_PIN_INDEX_SAFETY_DOOR; }
    if (bit_isfalse(pin,(1<<CONTROL_RESET_BIT))) { control_state |= CONTROL_PIN_INDEX_RESET; }
    73b2:	20 ff       	sbrs	r18, 0
    73b4:	82 60       	ori	r24, 0x02	; 2
    if (bit_isfalse(pin,(1<<CONTROL_FEED_HOLD_BIT))) { control_state |= CONTROL_PIN_INDEX_FEED_HOLD; }
    73b6:	21 ff       	sbrs	r18, 1
    73b8:	84 60       	ori	r24, 0x04	; 4
    if (bit_isfalse(pin,(1<<CONTROL_CYCLE_START_BIT))) { control_state |= CONTROL_PIN_INDEX_CYCLE_START; }
    73ba:	22 ff       	sbrs	r18, 2
    73bc:	88 60       	ori	r24, 0x08	; 8
    if (bit_isfalse(pin,(1<<CONTROL_SPINDLE_SYNC_BIT))) { control_state |= CONTROL_PIN_INDEX_SPINDLE_SYNC; }
    73be:	33 23       	and	r19, r19
    73c0:	1c f0       	brlt	.+6      	; 0x73c8 <system_control_get_state+0x2a>
    73c2:	80 61       	ori	r24, 0x10	; 16
    73c4:	08 95       	ret
// Returns control pin state as a uint8 bitfield. Each bit indicates the input pin state, where
// triggered is 1 and not triggered is 0. Invert mask is applied. Bitfield organization is
// defined by the CONTROL_PIN_INDEX in the header file.
uint8_t system_control_get_state()
{
  uint8_t control_state = 0;
    73c6:	80 e0       	ldi	r24, 0x00	; 0
    if (bit_isfalse(pin,(1<<CONTROL_FEED_HOLD_BIT))) { control_state |= CONTROL_PIN_INDEX_FEED_HOLD; }
    if (bit_isfalse(pin,(1<<CONTROL_CYCLE_START_BIT))) { control_state |= CONTROL_PIN_INDEX_CYCLE_START; }
    if (bit_isfalse(pin,(1<<CONTROL_SPINDLE_SYNC_BIT))) { control_state |= CONTROL_PIN_INDEX_SPINDLE_SYNC; }
  }
  return(control_state);
}
    73c8:	08 95       	ret

000073ca <__vector_11>:
// Pin change interrupt for pin-out commands, i.e. cycle start, feed hold, and reset. Sets
// only the realtime command execute variable to have the main program execute these when
// its ready. This works exactly like the character-based realtime commands when picked off
// directly from the incoming serial data stream.
ISR(CONTROL_INT_vect)
{
    73ca:	1f 92       	push	r1
    73cc:	0f 92       	push	r0
    73ce:	0f b6       	in	r0, 0x3f	; 63
    73d0:	0f 92       	push	r0
    73d2:	11 24       	eor	r1, r1
    73d4:	0b b6       	in	r0, 0x3b	; 59
    73d6:	0f 92       	push	r0
    73d8:	2f 93       	push	r18
    73da:	3f 93       	push	r19
    73dc:	4f 93       	push	r20
    73de:	5f 93       	push	r21
    73e0:	6f 93       	push	r22
    73e2:	7f 93       	push	r23
    73e4:	8f 93       	push	r24
    73e6:	9f 93       	push	r25
    73e8:	af 93       	push	r26
    73ea:	bf 93       	push	r27
    73ec:	ef 93       	push	r30
    73ee:	ff 93       	push	r31
  uint8_t pin = system_control_get_state();
    73f0:	d6 df       	rcall	.-84     	; 0x739e <system_control_get_state>
  if (pin) {
    73f2:	88 23       	and	r24, r24
    73f4:	21 f1       	breq	.+72     	; 0x743e <__vector_11+0x74>
    if (bit_istrue(pin,CONTROL_PIN_INDEX_RESET)) {
    73f6:	81 ff       	sbrs	r24, 1
    73f8:	03 c0       	rjmp	.+6      	; 0x7400 <__vector_11+0x36>
      mc_reset();
    73fa:	0e 94 cb 06 	call	0xd96	; 0xd96 <mc_reset>
    73fe:	1f c0       	rjmp	.+62     	; 0x743e <__vector_11+0x74>
    } else if (bit_istrue(pin,CONTROL_PIN_INDEX_CYCLE_START)) {
    7400:	83 ff       	sbrs	r24, 3
    7402:	06 c0       	rjmp	.+12     	; 0x7410 <__vector_11+0x46>
      bit_true(sys_rt_exec_state, EXEC_CYCLE_START);
    7404:	80 91 29 0c 	lds	r24, 0x0C29	; 0x800c29 <sys_rt_exec_state>
    7408:	82 60       	ori	r24, 0x02	; 2
    740a:	80 93 29 0c 	sts	0x0C29, r24	; 0x800c29 <sys_rt_exec_state>
    740e:	17 c0       	rjmp	.+46     	; 0x743e <__vector_11+0x74>
    } else if (bit_istrue(pin,CONTROL_PIN_INDEX_FEED_HOLD)) {
    7410:	82 ff       	sbrs	r24, 2
    7412:	06 c0       	rjmp	.+12     	; 0x7420 <__vector_11+0x56>
      bit_true(sys_rt_exec_state, EXEC_FEED_HOLD); 
    7414:	80 91 29 0c 	lds	r24, 0x0C29	; 0x800c29 <sys_rt_exec_state>
    7418:	88 60       	ori	r24, 0x08	; 8
    741a:	80 93 29 0c 	sts	0x0C29, r24	; 0x800c29 <sys_rt_exec_state>
    741e:	0f c0       	rjmp	.+30     	; 0x743e <__vector_11+0x74>
    } else if (bit_istrue(pin,CONTROL_PIN_INDEX_SAFETY_DOOR)) {
    7420:	80 ff       	sbrs	r24, 0
    7422:	06 c0       	rjmp	.+12     	; 0x7430 <__vector_11+0x66>
      bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
    7424:	80 91 29 0c 	lds	r24, 0x0C29	; 0x800c29 <sys_rt_exec_state>
    7428:	80 62       	ori	r24, 0x20	; 32
    742a:	80 93 29 0c 	sts	0x0C29, r24	; 0x800c29 <sys_rt_exec_state>
    742e:	07 c0       	rjmp	.+14     	; 0x743e <__vector_11+0x74>
	} else if (bit_istrue(pin,CONTROL_PIN_INDEX_SPINDLE_SYNC)) {
    7430:	84 ff       	sbrs	r24, 4
    7432:	05 c0       	rjmp	.+10     	; 0x743e <__vector_11+0x74>
	 bit_true(sys_sync_state, EXEC_SPINDLE_SYNC);   } 
    7434:	80 91 10 0c 	lds	r24, 0x0C10	; 0x800c10 <sys_sync_state>
    7438:	82 60       	ori	r24, 0x02	; 2
    743a:	80 93 10 0c 	sts	0x0C10, r24	; 0x800c10 <sys_sync_state>
  }
}
    743e:	ff 91       	pop	r31
    7440:	ef 91       	pop	r30
    7442:	bf 91       	pop	r27
    7444:	af 91       	pop	r26
    7446:	9f 91       	pop	r25
    7448:	8f 91       	pop	r24
    744a:	7f 91       	pop	r23
    744c:	6f 91       	pop	r22
    744e:	5f 91       	pop	r21
    7450:	4f 91       	pop	r20
    7452:	3f 91       	pop	r19
    7454:	2f 91       	pop	r18
    7456:	0f 90       	pop	r0
    7458:	0b be       	out	0x3b, r0	; 59
    745a:	0f 90       	pop	r0
    745c:	0f be       	out	0x3f, r0	; 63
    745e:	0f 90       	pop	r0
    7460:	1f 90       	pop	r1
    7462:	18 95       	reti

00007464 <system_check_safety_door_ajar>:


// Returns if safety door is ajar(T) or closed(F), based on pin state.
uint8_t system_check_safety_door_ajar()
{
    return(system_control_get_state() & CONTROL_PIN_INDEX_SAFETY_DOOR);
    7464:	9c df       	rcall	.-200    	; 0x739e <system_control_get_state>
}
    7466:	81 70       	andi	r24, 0x01	; 1
    7468:	08 95       	ret

0000746a <system_execute_startup>:


// Executes user startup script, if stored.
void system_execute_startup(char *line)
{
    746a:	0f 93       	push	r16
    746c:	1f 93       	push	r17
    746e:	cf 93       	push	r28
    7470:	8c 01       	movw	r16, r24
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    7472:	c0 e0       	ldi	r28, 0x00	; 0
    if (!(settings_read_startup_line(n, line))) {
    7474:	b8 01       	movw	r22, r16
    7476:	8c 2f       	mov	r24, r28
    7478:	0e 94 51 25 	call	0x4aa2	; 0x4aa2 <settings_read_startup_line>
    747c:	81 11       	cpse	r24, r1
    747e:	06 c0       	rjmp	.+12     	; 0x748c <system_execute_startup+0x22>
      line[0] = 0;
    7480:	f8 01       	movw	r30, r16
    7482:	10 82       	st	Z, r1
      report_execute_startup_message(line,STATUS_SETTING_READ_FAIL);
    7484:	67 e0       	ldi	r22, 0x07	; 7
    7486:	c8 01       	movw	r24, r16
    7488:	30 dd       	rcall	.-1440   	; 0x6eea <report_execute_startup_message>
    748a:	0a c0       	rjmp	.+20     	; 0x74a0 <system_execute_startup+0x36>
    } else {
      if (line[0] != 0) {
    748c:	f8 01       	movw	r30, r16
    748e:	80 81       	ld	r24, Z
    7490:	88 23       	and	r24, r24
    7492:	31 f0       	breq	.+12     	; 0x74a0 <system_execute_startup+0x36>
        uint8_t status_code = gc_execute_line(line);
    7494:	c8 01       	movw	r24, r16
    7496:	0e 94 08 07 	call	0xe10	; 0xe10 <gc_execute_line>
        report_execute_startup_message(line,status_code);
    749a:	68 2f       	mov	r22, r24
    749c:	c8 01       	movw	r24, r16
    749e:	25 dd       	rcall	.-1462   	; 0x6eea <report_execute_startup_message>

// Executes user startup script, if stored.
void system_execute_startup(char *line)
{
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    74a0:	cf 5f       	subi	r28, 0xFF	; 255
    74a2:	c2 30       	cpi	r28, 0x02	; 2
    74a4:	39 f7       	brne	.-50     	; 0x7474 <system_execute_startup+0xa>
        uint8_t status_code = gc_execute_line(line);
        report_execute_startup_message(line,status_code);
      }
    }
  }
}
    74a6:	cf 91       	pop	r28
    74a8:	1f 91       	pop	r17
    74aa:	0f 91       	pop	r16
    74ac:	08 95       	ret

000074ae <system_flag_wco_change>:


void system_flag_wco_change()
{
  #ifdef FORCE_BUFFER_SYNC_DURING_WCO_CHANGE
    protocol_buffer_synchronize();
    74ae:	0e 94 94 18 	call	0x3128	; 0x3128 <protocol_buffer_synchronize>
  #endif
  sys.report_wco_counter = 0;
    74b2:	10 92 22 0c 	sts	0x0C22, r1	; 0x800c22 <sys+0xc>
    74b6:	08 95       	ret

000074b8 <system_convert_axis_steps_to_mpos>:

// Returns machine position of axis 'idx'. Must be sent a 'step' array.
// NOTE: If motor steps and machine position are not in the same coordinate frame, this function
//   serves as a central place to compute the transformation.
float system_convert_axis_steps_to_mpos(int32_t *steps, uint8_t idx)
{
    74b8:	cf 93       	push	r28
    74ba:	df 93       	push	r29
      pos = (float)system_convert_corexy_to_y_axis_steps(steps) / settings.steps_per_mm[idx];
    } else {
      pos = steps[idx]/settings.steps_per_mm[idx];
    }
  #else
    pos = steps[idx]/settings.steps_per_mm[idx];
    74bc:	c6 2f       	mov	r28, r22
    74be:	d0 e0       	ldi	r29, 0x00	; 0
    74c0:	cc 0f       	add	r28, r28
    74c2:	dd 1f       	adc	r29, r29
    74c4:	cc 0f       	add	r28, r28
    74c6:	dd 1f       	adc	r29, r29
    74c8:	8c 0f       	add	r24, r28
    74ca:	9d 1f       	adc	r25, r29
  #endif
  return(pos);
    74cc:	fc 01       	movw	r30, r24
    74ce:	60 81       	ld	r22, Z
    74d0:	71 81       	ldd	r23, Z+1	; 0x01
    74d2:	82 81       	ldd	r24, Z+2	; 0x02
    74d4:	93 81       	ldd	r25, Z+3	; 0x03
    74d6:	fb d4       	rcall	.+2550   	; 0x7ece <__floatsisf>
      pos = (float)system_convert_corexy_to_y_axis_steps(steps) / settings.steps_per_mm[idx];
    } else {
      pos = steps[idx]/settings.steps_per_mm[idx];
    }
  #else
    pos = steps[idx]/settings.steps_per_mm[idx];
    74d8:	c0 54       	subi	r28, 0x40	; 64
    74da:	d1 4f       	sbci	r29, 0xF1	; 241
  #endif
  return(pos);
    74dc:	28 81       	ld	r18, Y
    74de:	39 81       	ldd	r19, Y+1	; 0x01
    74e0:	4a 81       	ldd	r20, Y+2	; 0x02
    74e2:	5b 81       	ldd	r21, Y+3	; 0x03
    74e4:	59 d4       	rcall	.+2226   	; 0x7d98 <__divsf3>
}
    74e6:	df 91       	pop	r29
    74e8:	cf 91       	pop	r28
    74ea:	08 95       	ret

000074ec <system_convert_array_steps_to_mpos>:


void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
    74ec:	ef 92       	push	r14
    74ee:	ff 92       	push	r15
    74f0:	0f 93       	push	r16
    74f2:	1f 93       	push	r17
    74f4:	cf 93       	push	r28
    74f6:	7b 01       	movw	r14, r22
    74f8:	8c 01       	movw	r16, r24
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    74fa:	c0 e0       	ldi	r28, 0x00	; 0
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
    74fc:	6c 2f       	mov	r22, r28
    74fe:	c7 01       	movw	r24, r14
    7500:	db df       	rcall	.-74     	; 0x74b8 <system_convert_axis_steps_to_mpos>
    7502:	f8 01       	movw	r30, r16
    7504:	61 93       	st	Z+, r22
    7506:	71 93       	st	Z+, r23
    7508:	81 93       	st	Z+, r24
    750a:	91 93       	st	Z+, r25
    750c:	8f 01       	movw	r16, r30


void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    750e:	cf 5f       	subi	r28, 0xFF	; 255
    7510:	c3 30       	cpi	r28, 0x03	; 3
    7512:	a1 f7       	brne	.-24     	; 0x74fc <system_convert_array_steps_to_mpos+0x10>
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
  }
  return;
}
    7514:	cf 91       	pop	r28
    7516:	1f 91       	pop	r17
    7518:	0f 91       	pop	r16
    751a:	ff 90       	pop	r15
    751c:	ef 90       	pop	r14
    751e:	08 95       	ret

00007520 <system_check_travel_limits>:
#endif


// Checks and reports if target array exceeds machine travel limits.
uint8_t system_check_travel_limits(float *target)
{
    7520:	cf 92       	push	r12
    7522:	df 92       	push	r13
    7524:	ef 92       	push	r14
    7526:	ff 92       	push	r15
    7528:	cf 93       	push	r28
    752a:	df 93       	push	r29
    752c:	ec 01       	movw	r28, r24
      } else {
        if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { return(true); }
      }
    #else
      // NOTE: max_travel is stored as negative
      if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { return(true); }
    752e:	c8 80       	ld	r12, Y
    7530:	d9 80       	ldd	r13, Y+1	; 0x01
    7532:	ea 80       	ldd	r14, Y+2	; 0x02
    7534:	fb 80       	ldd	r15, Y+3	; 0x03
    7536:	20 e0       	ldi	r18, 0x00	; 0
    7538:	30 e0       	ldi	r19, 0x00	; 0
    753a:	a9 01       	movw	r20, r18
    753c:	c7 01       	movw	r24, r14
    753e:	b6 01       	movw	r22, r12
    7540:	27 d6       	rcall	.+3150   	; 0x8190 <__gesf2>
    7542:	18 16       	cp	r1, r24
    7544:	0c f4       	brge	.+2      	; 0x7548 <system_check_travel_limits+0x28>
    7546:	41 c0       	rjmp	.+130    	; 0x75ca <system_check_travel_limits+0xaa>
    7548:	20 91 e4 0e 	lds	r18, 0x0EE4	; 0x800ee4 <settings+0x24>
    754c:	30 91 e5 0e 	lds	r19, 0x0EE5	; 0x800ee5 <settings+0x25>
    7550:	40 91 e6 0e 	lds	r20, 0x0EE6	; 0x800ee6 <settings+0x26>
    7554:	50 91 e7 0e 	lds	r21, 0x0EE7	; 0x800ee7 <settings+0x27>
    7558:	c7 01       	movw	r24, r14
    755a:	b6 01       	movw	r22, r12
    755c:	16 d4       	rcall	.+2092   	; 0x7d8a <__cmpsf2>
    755e:	88 23       	and	r24, r24
    7560:	b4 f1       	brlt	.+108    	; 0x75ce <system_check_travel_limits+0xae>
    7562:	cc 80       	ldd	r12, Y+4	; 0x04
    7564:	dd 80       	ldd	r13, Y+5	; 0x05
    7566:	ee 80       	ldd	r14, Y+6	; 0x06
    7568:	ff 80       	ldd	r15, Y+7	; 0x07
    756a:	20 e0       	ldi	r18, 0x00	; 0
    756c:	30 e0       	ldi	r19, 0x00	; 0
    756e:	a9 01       	movw	r20, r18
    7570:	c7 01       	movw	r24, r14
    7572:	b6 01       	movw	r22, r12
    7574:	0d d6       	rcall	.+3098   	; 0x8190 <__gesf2>
    7576:	18 16       	cp	r1, r24
    7578:	64 f1       	brlt	.+88     	; 0x75d2 <system_check_travel_limits+0xb2>
    757a:	20 91 e8 0e 	lds	r18, 0x0EE8	; 0x800ee8 <settings+0x28>
    757e:	30 91 e9 0e 	lds	r19, 0x0EE9	; 0x800ee9 <settings+0x29>
    7582:	40 91 ea 0e 	lds	r20, 0x0EEA	; 0x800eea <settings+0x2a>
    7586:	50 91 eb 0e 	lds	r21, 0x0EEB	; 0x800eeb <settings+0x2b>
    758a:	c7 01       	movw	r24, r14
    758c:	b6 01       	movw	r22, r12
    758e:	fd d3       	rcall	.+2042   	; 0x7d8a <__cmpsf2>
    7590:	88 23       	and	r24, r24
    7592:	0c f1       	brlt	.+66     	; 0x75d6 <system_check_travel_limits+0xb6>
    7594:	c8 84       	ldd	r12, Y+8	; 0x08
    7596:	d9 84       	ldd	r13, Y+9	; 0x09
    7598:	ea 84       	ldd	r14, Y+10	; 0x0a
    759a:	fb 84       	ldd	r15, Y+11	; 0x0b
    759c:	20 e0       	ldi	r18, 0x00	; 0
    759e:	30 e0       	ldi	r19, 0x00	; 0
    75a0:	a9 01       	movw	r20, r18
    75a2:	c7 01       	movw	r24, r14
    75a4:	b6 01       	movw	r22, r12
    75a6:	f4 d5       	rcall	.+3048   	; 0x8190 <__gesf2>
    75a8:	18 16       	cp	r1, r24
    75aa:	bc f0       	brlt	.+46     	; 0x75da <system_check_travel_limits+0xba>
    75ac:	20 91 ec 0e 	lds	r18, 0x0EEC	; 0x800eec <settings+0x2c>
    75b0:	30 91 ed 0e 	lds	r19, 0x0EED	; 0x800eed <settings+0x2d>
    75b4:	40 91 ee 0e 	lds	r20, 0x0EEE	; 0x800eee <settings+0x2e>
    75b8:	50 91 ef 0e 	lds	r21, 0x0EEF	; 0x800eef <settings+0x2f>
    75bc:	c7 01       	movw	r24, r14
    75be:	b6 01       	movw	r22, r12
    75c0:	e4 d3       	rcall	.+1992   	; 0x7d8a <__cmpsf2>
    75c2:	88 1f       	adc	r24, r24
    75c4:	88 27       	eor	r24, r24
    75c6:	88 1f       	adc	r24, r24
    75c8:	09 c0       	rjmp	.+18     	; 0x75dc <system_check_travel_limits+0xbc>
    75ca:	81 e0       	ldi	r24, 0x01	; 1
    75cc:	07 c0       	rjmp	.+14     	; 0x75dc <system_check_travel_limits+0xbc>
    75ce:	81 e0       	ldi	r24, 0x01	; 1
    75d0:	05 c0       	rjmp	.+10     	; 0x75dc <system_check_travel_limits+0xbc>
    75d2:	81 e0       	ldi	r24, 0x01	; 1
    75d4:	03 c0       	rjmp	.+6      	; 0x75dc <system_check_travel_limits+0xbc>
    75d6:	81 e0       	ldi	r24, 0x01	; 1
    75d8:	01 c0       	rjmp	.+2      	; 0x75dc <system_check_travel_limits+0xbc>
    75da:	81 e0       	ldi	r24, 0x01	; 1
    #endif
  }
  return(false);
}
    75dc:	df 91       	pop	r29
    75de:	cf 91       	pop	r28
    75e0:	ff 90       	pop	r15
    75e2:	ef 90       	pop	r14
    75e4:	df 90       	pop	r13
    75e6:	cf 90       	pop	r12
    75e8:	08 95       	ret

000075ea <system_set_exec_state_flag>:


// Special handlers for setting and clearing Grbl's real-time execution flags.
void system_set_exec_state_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    75ea:	9f b7       	in	r25, 0x3f	; 63
  cli();
    75ec:	f8 94       	cli
  sys_rt_exec_state |= (mask);
    75ee:	20 91 29 0c 	lds	r18, 0x0C29	; 0x800c29 <sys_rt_exec_state>
    75f2:	82 2b       	or	r24, r18
    75f4:	80 93 29 0c 	sts	0x0C29, r24	; 0x800c29 <sys_rt_exec_state>
  SREG = sreg;
    75f8:	9f bf       	out	0x3f, r25	; 63
    75fa:	08 95       	ret

000075fc <system_execute_line>:
// next line during a cycle, so for switches like block delete, the switch only effects
// the lines that are processed afterward, not necessarily real-time during a cycle,
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line)
{
    75fc:	8f 92       	push	r8
    75fe:	9f 92       	push	r9
    7600:	af 92       	push	r10
    7602:	bf 92       	push	r11
    7604:	cf 92       	push	r12
    7606:	df 92       	push	r13
    7608:	ef 92       	push	r14
    760a:	ff 92       	push	r15
    760c:	0f 93       	push	r16
    760e:	1f 93       	push	r17
    7610:	cf 93       	push	r28
    7612:	df 93       	push	r29
    7614:	cd b7       	in	r28, 0x3d	; 61
    7616:	de b7       	in	r29, 0x3e	; 62
    7618:	29 97       	sbiw	r28, 0x09	; 9
    761a:	0f b6       	in	r0, 0x3f	; 63
    761c:	f8 94       	cli
    761e:	de bf       	out	0x3e, r29	; 62
    7620:	0f be       	out	0x3f, r0	; 63
    7622:	cd bf       	out	0x3d, r28	; 61
    7624:	8c 01       	movw	r16, r24
  uint8_t char_counter = 1;
    7626:	81 e0       	ldi	r24, 0x01	; 1
    7628:	89 83       	std	Y+1, r24	; 0x01
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    762a:	f8 01       	movw	r30, r16
    762c:	81 81       	ldd	r24, Z+1	; 0x01
    762e:	83 34       	cpi	r24, 0x43	; 67
    7630:	09 f1       	breq	.+66     	; 0x7674 <system_execute_line+0x78>
    7632:	30 f4       	brcc	.+12     	; 0x7640 <system_execute_line+0x44>
    7634:	88 23       	and	r24, r24
    7636:	61 f0       	breq	.+24     	; 0x7650 <system_execute_line+0x54>
    7638:	84 32       	cpi	r24, 0x24	; 36
    763a:	09 f0       	breq	.+2      	; 0x763e <system_execute_line+0x42>
    763c:	56 c0       	rjmp	.+172    	; 0x76ea <system_execute_line+0xee>
    763e:	1a c0       	rjmp	.+52     	; 0x7674 <system_execute_line+0x78>
    7640:	8a 34       	cpi	r24, 0x4A	; 74
    7642:	49 f0       	breq	.+18     	; 0x7656 <system_execute_line+0x5a>
    7644:	88 35       	cpi	r24, 0x58	; 88
    7646:	b1 f0       	breq	.+44     	; 0x7674 <system_execute_line+0x78>
    7648:	87 34       	cpi	r24, 0x47	; 71
    764a:	09 f0       	breq	.+2      	; 0x764e <system_execute_line+0x52>
    764c:	4e c0       	rjmp	.+156    	; 0x76ea <system_execute_line+0xee>
    764e:	12 c0       	rjmp	.+36     	; 0x7674 <system_execute_line+0x78>
    case 0 : report_grbl_help(); break;
    7650:	15 da       	rcall	.-3030   	; 0x6a7c <report_grbl_help>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7652:	f1 2c       	mov	r15, r1
{
  uint8_t char_counter = 1;
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    7654:	14 c2       	rjmp	.+1064   	; 0x7a7e <system_execute_line+0x482>
    case 'J' : // Jogging
      // Execute only if in IDLE or JOG states.
      if (sys.state != STATE_IDLE && sys.state != STATE_JOG) { return(STATUS_IDLE_ERROR); }
    7656:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
    765a:	8f 7d       	andi	r24, 0xDF	; 223
    765c:	09 f0       	breq	.+2      	; 0x7660 <system_execute_line+0x64>
    765e:	85 c1       	rjmp	.+778    	; 0x796a <system_execute_line+0x36e>
      if(line[2] != '=') { return(STATUS_INVALID_STATEMENT); }
    7660:	f8 01       	movw	r30, r16
    7662:	82 81       	ldd	r24, Z+2	; 0x02
    7664:	8d 33       	cpi	r24, 0x3D	; 61
    7666:	09 f0       	breq	.+2      	; 0x766a <system_execute_line+0x6e>
    7668:	84 c1       	rjmp	.+776    	; 0x7972 <system_execute_line+0x376>
      return(gc_execute_line(line)); // NOTE: $J= is ignored inside g-code parser and used to detect jog motions.
    766a:	c8 01       	movw	r24, r16
    766c:	0e 94 08 07 	call	0xe10	; 0xe10 <gc_execute_line>
    7670:	f8 2e       	mov	r15, r24
    7672:	05 c2       	rjmp	.+1034   	; 0x7a7e <system_execute_line+0x482>
      break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7674:	f8 01       	movw	r30, r16
    7676:	92 81       	ldd	r25, Z+2	; 0x02
    7678:	91 11       	cpse	r25, r1
    767a:	80 c1       	rjmp	.+768    	; 0x797c <system_execute_line+0x380>
      switch( line[1] ) {
    767c:	83 34       	cpi	r24, 0x43	; 67
    767e:	a1 f0       	breq	.+40     	; 0x76a8 <system_execute_line+0xac>
    7680:	18 f4       	brcc	.+6      	; 0x7688 <system_execute_line+0x8c>
    7682:	84 32       	cpi	r24, 0x24	; 36
    7684:	31 f0       	breq	.+12     	; 0x7692 <system_execute_line+0x96>
    7686:	7f c1       	rjmp	.+766    	; 0x7986 <system_execute_line+0x38a>
    7688:	87 34       	cpi	r24, 0x47	; 71
    768a:	59 f0       	breq	.+22     	; 0x76a2 <system_execute_line+0xa6>
    768c:	88 35       	cpi	r24, 0x58	; 88
    768e:	f9 f0       	breq	.+62     	; 0x76ce <system_execute_line+0xd2>
    7690:	7a c1       	rjmp	.+756    	; 0x7986 <system_execute_line+0x38a>
    7692:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
    7696:	88 71       	andi	r24, 0x18	; 24
    7698:	f8 2e       	mov	r15, r24
        case '$' : // Prints Grbl settings
          if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    769a:	09 f0       	breq	.+2      	; 0x769e <system_execute_line+0xa2>
          else { report_grbl_settings(); }
    769c:	76 c1       	rjmp	.+748    	; 0x798a <system_execute_line+0x38e>
          break;
    769e:	f2 d9       	rcall	.-3100   	; 0x6a84 <report_grbl_settings>
        case 'G' : // Prints gcode parser state
          // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
          report_gcode_modes();
    76a0:	ee c1       	rjmp	.+988    	; 0x7a7e <system_execute_line+0x482>
    76a2:	7e db       	rcall	.-2308   	; 0x6da0 <report_gcode_modes>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    76a4:	f1 2c       	mov	r15, r1
          else { report_grbl_settings(); }
          break;
        case 'G' : // Prints gcode parser state
          // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
          report_gcode_modes();
          break;
    76a6:	eb c1       	rjmp	.+982    	; 0x7a7e <system_execute_line+0x482>
        case 'C' : // Set check g-code mode [IDLE/CHECK]
          // Perform reset when toggling off. Check g-code mode should only work if Grbl
          // is idle and ready, regardless of alarm locks. This is mainly to keep things
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) {
    76a8:	f0 90 16 0c 	lds	r15, 0x0C16	; 0x800c16 <sys>
    76ac:	f2 e0       	ldi	r31, 0x02	; 2
    76ae:	ff 12       	cpse	r15, r31
    76b0:	06 c0       	rjmp	.+12     	; 0x76be <system_execute_line+0xc2>
            mc_reset();
    76b2:	0e 94 cb 06 	call	0xd96	; 0xd96 <mc_reset>
            report_feedback_message(MESSAGE_DISABLED);
    76b6:	85 e0       	ldi	r24, 0x05	; 5
    76b8:	9d d9       	rcall	.-3270   	; 0x69f4 <report_feedback_message>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    76ba:	f1 2c       	mov	r15, r1
    76bc:	e0 c1       	rjmp	.+960    	; 0x7a7e <system_execute_line+0x482>
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) {
            mc_reset();
            report_feedback_message(MESSAGE_DISABLED);
          } else {
            if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    76be:	f1 10       	cpse	r15, r1
    76c0:	68 c1       	rjmp	.+720    	; 0x7992 <system_execute_line+0x396>
            sys.state = STATE_CHECK_MODE;
    76c2:	82 e0       	ldi	r24, 0x02	; 2
    76c4:	80 93 16 0c 	sts	0x0C16, r24	; 0x800c16 <sys>
            report_feedback_message(MESSAGE_ENABLED);
    76c8:	84 e0       	ldi	r24, 0x04	; 4
    76ca:	94 d9       	rcall	.-3288   	; 0x69f4 <report_feedback_message>
    76cc:	d8 c1       	rjmp	.+944    	; 0x7a7e <system_execute_line+0x482>
          }
          break;
        case 'X' : // Disable alarm lock [ALARM]
          if (sys.state == STATE_ALARM) {
    76ce:	80 91 16 0c 	lds	r24, 0x0C16	; 0x800c16 <sys>
    76d2:	81 30       	cpi	r24, 0x01	; 1
    76d4:	09 f0       	breq	.+2      	; 0x76d8 <system_execute_line+0xdc>
            // Block if safety door is ajar.
            if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); }
    76d6:	61 c1       	rjmp	.+706    	; 0x799a <system_execute_line+0x39e>
    76d8:	c5 de       	rcall	.-630    	; 0x7464 <system_check_safety_door_ajar>
    76da:	f8 2e       	mov	r15, r24
    76dc:	81 11       	cpse	r24, r1
            report_feedback_message(MESSAGE_ALARM_UNLOCK);
    76de:	5f c1       	rjmp	.+702    	; 0x799e <system_execute_line+0x3a2>
    76e0:	83 e0       	ldi	r24, 0x03	; 3
    76e2:	88 d9       	rcall	.-3312   	; 0x69f4 <report_feedback_message>
            sys.state = STATE_IDLE;
    76e4:	10 92 16 0c 	sts	0x0C16, r1	; 0x800c16 <sys>
    76e8:	ca c1       	rjmp	.+916    	; 0x7a7e <system_execute_line+0x482>
          break;
      }
      break;
    default :
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    76ea:	90 91 16 0c 	lds	r25, 0x0C16	; 0x800c16 <sys>
    76ee:	92 30       	cpi	r25, 0x02	; 2
    76f0:	08 f0       	brcs	.+2      	; 0x76f4 <system_execute_line+0xf8>
    76f2:	5a c1       	rjmp	.+692    	; 0x79a8 <system_execute_line+0x3ac>
      switch( line[1] ) {
    76f4:	89 34       	cpi	r24, 0x49	; 73
    76f6:	09 f4       	brne	.+2      	; 0x76fa <system_execute_line+0xfe>
    76f8:	5e c0       	rjmp	.+188    	; 0x77b6 <system_execute_line+0x1ba>
    76fa:	28 f4       	brcc	.+10     	; 0x7706 <system_execute_line+0x10a>
    76fc:	83 32       	cpi	r24, 0x23	; 35
    76fe:	69 f0       	breq	.+26     	; 0x771a <system_execute_line+0x11e>
    7700:	88 34       	cpi	r24, 0x48	; 72
    7702:	91 f0       	breq	.+36     	; 0x7728 <system_execute_line+0x12c>
    7704:	c2 c0       	rjmp	.+388    	; 0x788a <system_execute_line+0x28e>
    7706:	82 35       	cpi	r24, 0x52	; 82
    7708:	09 f4       	brne	.+2      	; 0x770c <system_execute_line+0x110>
    770a:	77 c0       	rjmp	.+238    	; 0x77fa <system_execute_line+0x1fe>
    770c:	83 35       	cpi	r24, 0x53	; 83
    770e:	09 f4       	brne	.+2      	; 0x7712 <system_execute_line+0x116>
    7710:	42 c0       	rjmp	.+132    	; 0x7796 <system_execute_line+0x19a>
    7712:	8e 34       	cpi	r24, 0x4E	; 78
    7714:	09 f0       	breq	.+2      	; 0x7718 <system_execute_line+0x11c>
    7716:	b9 c0       	rjmp	.+370    	; 0x788a <system_execute_line+0x28e>
    7718:	9a c0       	rjmp	.+308    	; 0x784e <system_execute_line+0x252>
        case '#' : // Print Grbl NGC parameters
          if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    771a:	f8 01       	movw	r30, r16
    771c:	82 81       	ldd	r24, Z+2	; 0x02
    771e:	81 11       	cpse	r24, r1
          else { report_ngc_parameters(); }
    7720:	47 c1       	rjmp	.+654    	; 0x79b0 <system_execute_line+0x3b4>
    7722:	d7 da       	rcall	.-2642   	; 0x6cd2 <report_ngc_parameters>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7724:	f1 2c       	mov	r15, r1
        case '#' : // Print Grbl NGC parameters
          if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
          else { report_ngc_parameters(); }
          break;
        case 'H' : // Perform homing cycle [IDLE/ALARM]
          if (bit_isfalse(settings.flags,BITFLAG_HOMING_ENABLE)) {return(STATUS_SETTING_DISABLED); }
    7726:	ab c1       	rjmp	.+854    	; 0x7a7e <system_execute_line+0x482>
    7728:	80 91 05 0f 	lds	r24, 0x0F05	; 0x800f05 <settings+0x45>
    772c:	84 ff       	sbrs	r24, 4
          if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); } // Block if safety door is ajar.
    772e:	45 c1       	rjmp	.+650    	; 0x79ba <system_execute_line+0x3be>
    7730:	99 de       	rcall	.-718    	; 0x7464 <system_check_safety_door_ajar>
    7732:	e8 2e       	mov	r14, r24
    7734:	81 11       	cpse	r24, r1
    7736:	46 c1       	rjmp	.+652    	; 0x79c4 <system_execute_line+0x3c8>
          sys.state = STATE_HOMING; // Set system state variable
    7738:	84 e0       	ldi	r24, 0x04	; 4
    773a:	80 93 16 0c 	sts	0x0C16, r24	; 0x800c16 <sys>
          if (line[2] == 0) {
    773e:	f8 01       	movw	r30, r16
    7740:	82 81       	ldd	r24, Z+2	; 0x02
    7742:	81 11       	cpse	r24, r1
    7744:	03 c0       	rjmp	.+6      	; 0x774c <system_execute_line+0x150>
            mc_homing_cycle(HOMING_CYCLE_ALL);
    7746:	0e 94 39 06 	call	0xc72	; 0xc72 <mc_homing_cycle>
    774a:	16 c0       	rjmp	.+44     	; 0x7778 <system_execute_line+0x17c>
          #ifdef HOMING_SINGLE_AXIS_COMMANDS
            } else if (line[3] == 0) {
    774c:	f8 01       	movw	r30, r16
    774e:	93 81       	ldd	r25, Z+3	; 0x03
    7750:	91 11       	cpse	r25, r1
    7752:	3d c1       	rjmp	.+634    	; 0x79ce <system_execute_line+0x3d2>
              switch (line[2]) {
    7754:	89 35       	cpi	r24, 0x59	; 89
    7756:	49 f0       	breq	.+18     	; 0x776a <system_execute_line+0x16e>
    7758:	8a 35       	cpi	r24, 0x5A	; 90
    775a:	59 f0       	breq	.+22     	; 0x7772 <system_execute_line+0x176>
    775c:	88 35       	cpi	r24, 0x58	; 88
    775e:	09 f0       	breq	.+2      	; 0x7762 <system_execute_line+0x166>
    7760:	3b c1       	rjmp	.+630    	; 0x79d8 <system_execute_line+0x3dc>
                case 'X': mc_homing_cycle(HOMING_CYCLE_X); break;
    7762:	81 e0       	ldi	r24, 0x01	; 1
    7764:	0e 94 39 06 	call	0xc72	; 0xc72 <mc_homing_cycle>
    7768:	07 c0       	rjmp	.+14     	; 0x7778 <system_execute_line+0x17c>
                case 'Y': mc_homing_cycle(HOMING_CYCLE_Y); break;
    776a:	82 e0       	ldi	r24, 0x02	; 2
    776c:	0e 94 39 06 	call	0xc72	; 0xc72 <mc_homing_cycle>
    7770:	03 c0       	rjmp	.+6      	; 0x7778 <system_execute_line+0x17c>
                case 'Z': mc_homing_cycle(HOMING_CYCLE_Z); break;
    7772:	84 e0       	ldi	r24, 0x04	; 4
    7774:	0e 94 39 06 	call	0xc72	; 0xc72 <mc_homing_cycle>
                default: return(STATUS_INVALID_STATEMENT);
              }
          #endif
          } else { return(STATUS_INVALID_STATEMENT); }
          if (!sys.abort) {  // Execute startup scripts after successful homing.
    7778:	f0 90 17 0c 	lds	r15, 0x0C17	; 0x800c17 <sys+0x1>
    777c:	f1 10       	cpse	r15, r1
    777e:	31 c1       	rjmp	.+610    	; 0x79e2 <system_execute_line+0x3e6>
            sys.state = STATE_IDLE; // Set to IDLE when complete.
    7780:	10 92 16 0c 	sts	0x0C16, r1	; 0x800c16 <sys>
            st_go_idle(); // Set steppers to the settings idle state before returning.
    7784:	0e 94 bf 18 	call	0x317e	; 0x317e <st_go_idle>
            if (line[2] == 0) { system_execute_startup(line); }
    7788:	f8 01       	movw	r30, r16
    778a:	82 81       	ldd	r24, Z+2	; 0x02
    778c:	81 11       	cpse	r24, r1
    778e:	77 c1       	rjmp	.+750    	; 0x7a7e <system_execute_line+0x482>
    7790:	c8 01       	movw	r24, r16
    7792:	6b de       	rcall	.-810    	; 0x746a <system_execute_startup>
    7794:	74 c1       	rjmp	.+744    	; 0x7a7e <system_execute_line+0x482>
          }
          break;
        case 'S' : // Puts Grbl to sleep [IDLE/ALARM]
          if ((line[2] != 'L') || (line[3] != 'P') || (line[4] != 0)) { return(STATUS_INVALID_STATEMENT); }
    7796:	f8 01       	movw	r30, r16
    7798:	82 81       	ldd	r24, Z+2	; 0x02
    779a:	8c 34       	cpi	r24, 0x4C	; 76
    779c:	09 f0       	breq	.+2      	; 0x77a0 <system_execute_line+0x1a4>
    779e:	23 c1       	rjmp	.+582    	; 0x79e6 <system_execute_line+0x3ea>
    77a0:	83 81       	ldd	r24, Z+3	; 0x03
    77a2:	80 35       	cpi	r24, 0x50	; 80
    77a4:	09 f0       	breq	.+2      	; 0x77a8 <system_execute_line+0x1ac>
    77a6:	24 c1       	rjmp	.+584    	; 0x79f0 <system_execute_line+0x3f4>
    77a8:	84 81       	ldd	r24, Z+4	; 0x04
    77aa:	81 11       	cpse	r24, r1
          system_set_exec_state_flag(EXEC_SLEEP); // Set to execute sleep mode immediately
    77ac:	26 c1       	rjmp	.+588    	; 0x79fa <system_execute_line+0x3fe>
    77ae:	80 e8       	ldi	r24, 0x80	; 128
    77b0:	1c df       	rcall	.-456    	; 0x75ea <system_set_exec_state_flag>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    77b2:	f1 2c       	mov	r15, r1
          }
          break;
        case 'S' : // Puts Grbl to sleep [IDLE/ALARM]
          if ((line[2] != 'L') || (line[3] != 'P') || (line[4] != 0)) { return(STATUS_INVALID_STATEMENT); }
          system_set_exec_state_flag(EXEC_SLEEP); // Set to execute sleep mode immediately
          break;
    77b4:	64 c1       	rjmp	.+712    	; 0x7a7e <system_execute_line+0x482>
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) {
    77b6:	82 e0       	ldi	r24, 0x02	; 2
    77b8:	89 83       	std	Y+1, r24	; 0x01
    77ba:	f8 01       	movw	r30, r16
    77bc:	82 81       	ldd	r24, Z+2	; 0x02
    77be:	81 11       	cpse	r24, r1
            settings_read_build_info(line);
    77c0:	07 c0       	rjmp	.+14     	; 0x77d0 <system_execute_line+0x1d4>
    77c2:	c8 01       	movw	r24, r16
    77c4:	0e 94 6f 25 	call	0x4ade	; 0x4ade <settings_read_build_info>
            report_build_info(line);
    77c8:	c8 01       	movw	r24, r16
    77ca:	a2 db       	rcall	.-2236   	; 0x6f10 <report_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    77cc:	f1 2c       	mov	r15, r1
    77ce:	57 c1       	rjmp	.+686    	; 0x7a7e <system_execute_line+0x482>
          if ( line[++char_counter] == 0 ) {
            settings_read_build_info(line);
            report_build_info(line);
          #ifdef ENABLE_BUILD_INFO_WRITE_COMMAND
            } else { // Store startup line [IDLE/ALARM]
              if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    77d0:	8d 33       	cpi	r24, 0x3D	; 61
    77d2:	09 f0       	breq	.+2      	; 0x77d6 <system_execute_line+0x1da>
    77d4:	17 c1       	rjmp	.+558    	; 0x7a04 <system_execute_line+0x408>
    77d6:	83 e0       	ldi	r24, 0x03	; 3
              helper_var = char_counter; // Set helper variable as counter to start of user info line.
              do {
                line[char_counter-helper_var] = line[char_counter];
    77d8:	f8 01       	movw	r30, r16
    77da:	e8 0f       	add	r30, r24
    77dc:	f1 1d       	adc	r31, r1
    77de:	90 81       	ld	r25, Z
    77e0:	df 01       	movw	r26, r30
    77e2:	13 97       	sbiw	r26, 0x03	; 3
    77e4:	9c 93       	st	X, r25
              } while (line[char_counter++] != 0);
    77e6:	8f 5f       	subi	r24, 0xFF	; 255
    77e8:	90 81       	ld	r25, Z
    77ea:	91 11       	cpse	r25, r1
    77ec:	f5 cf       	rjmp	.-22     	; 0x77d8 <system_execute_line+0x1dc>
    77ee:	89 83       	std	Y+1, r24	; 0x01
              settings_store_build_info(line);
    77f0:	c8 01       	movw	r24, r16
    77f2:	0e 94 d8 24 	call	0x49b0	; 0x49b0 <settings_store_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    77f6:	f1 2c       	mov	r15, r1
    77f8:	42 c1       	rjmp	.+644    	; 0x7a7e <system_execute_line+0x482>
              settings_store_build_info(line);
          #endif
          }
          break;
        case 'R' : // Restore defaults [IDLE/ALARM]
          if ((line[2] != 'S') || (line[3] != 'T') || (line[4] != '=') || (line[6] != 0)) { return(STATUS_INVALID_STATEMENT); }
    77fa:	f8 01       	movw	r30, r16
    77fc:	82 81       	ldd	r24, Z+2	; 0x02
    77fe:	83 35       	cpi	r24, 0x53	; 83
    7800:	09 f0       	breq	.+2      	; 0x7804 <system_execute_line+0x208>
    7802:	05 c1       	rjmp	.+522    	; 0x7a0e <system_execute_line+0x412>
    7804:	83 81       	ldd	r24, Z+3	; 0x03
    7806:	84 35       	cpi	r24, 0x54	; 84
    7808:	09 f0       	breq	.+2      	; 0x780c <system_execute_line+0x210>
    780a:	06 c1       	rjmp	.+524    	; 0x7a18 <system_execute_line+0x41c>
    780c:	84 81       	ldd	r24, Z+4	; 0x04
    780e:	8d 33       	cpi	r24, 0x3D	; 61
    7810:	09 f0       	breq	.+2      	; 0x7814 <system_execute_line+0x218>
    7812:	07 c1       	rjmp	.+526    	; 0x7a22 <system_execute_line+0x426>
    7814:	86 81       	ldd	r24, Z+6	; 0x06
    7816:	81 11       	cpse	r24, r1
    7818:	09 c1       	rjmp	.+530    	; 0x7a2c <system_execute_line+0x430>
          switch (line[5]) {
    781a:	85 81       	ldd	r24, Z+5	; 0x05
    781c:	84 32       	cpi	r24, 0x24	; 36
    781e:	31 f0       	breq	.+12     	; 0x782c <system_execute_line+0x230>
    7820:	8a 32       	cpi	r24, 0x2A	; 42
    7822:	61 f0       	breq	.+24     	; 0x783c <system_execute_line+0x240>
    7824:	83 32       	cpi	r24, 0x23	; 35
    7826:	09 f0       	breq	.+2      	; 0x782a <system_execute_line+0x22e>
    7828:	06 c1       	rjmp	.+524    	; 0x7a36 <system_execute_line+0x43a>
    782a:	04 c0       	rjmp	.+8      	; 0x7834 <system_execute_line+0x238>
            #ifdef ENABLE_RESTORE_EEPROM_DEFAULT_SETTINGS
              case '$': settings_restore(SETTINGS_RESTORE_DEFAULTS); break;
    782c:	81 e0       	ldi	r24, 0x01	; 1
    782e:	0e 94 ff 24 	call	0x49fe	; 0x49fe <settings_restore>
            #endif
            #ifdef ENABLE_RESTORE_EEPROM_CLEAR_PARAMETERS
              case '#': settings_restore(SETTINGS_RESTORE_PARAMETERS); break;
    7832:	07 c0       	rjmp	.+14     	; 0x7842 <system_execute_line+0x246>
    7834:	82 e0       	ldi	r24, 0x02	; 2
    7836:	0e 94 ff 24 	call	0x49fe	; 0x49fe <settings_restore>
            #endif
            #ifdef ENABLE_RESTORE_EEPROM_WIPE_ALL
              case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
    783a:	03 c0       	rjmp	.+6      	; 0x7842 <system_execute_line+0x246>
    783c:	8f ef       	ldi	r24, 0xFF	; 255
    783e:	0e 94 ff 24 	call	0x49fe	; 0x49fe <settings_restore>
            #endif
            default: return(STATUS_INVALID_STATEMENT);
          }
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
    7842:	89 e0       	ldi	r24, 0x09	; 9
    7844:	d7 d8       	rcall	.-3666   	; 0x69f4 <report_feedback_message>
          mc_reset(); // Force reset to ensure settings are initialized correctly.
    7846:	0e 94 cb 06 	call	0xd96	; 0xd96 <mc_reset>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    784a:	f1 2c       	mov	r15, r1
            #endif
            default: return(STATUS_INVALID_STATEMENT);
          }
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
          mc_reset(); // Force reset to ensure settings are initialized correctly.
          break;
    784c:	18 c1       	rjmp	.+560    	; 0x7a7e <system_execute_line+0x482>
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
    784e:	82 e0       	ldi	r24, 0x02	; 2
    7850:	89 83       	std	Y+1, r24	; 0x01
    7852:	f8 01       	movw	r30, r16
    7854:	82 81       	ldd	r24, Z+2	; 0x02
    7856:	81 11       	cpse	r24, r1
    7858:	13 c0       	rjmp	.+38     	; 0x7880 <system_execute_line+0x284>
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
              if (!(settings_read_startup_line(helper_var, line))) {
    785a:	f1 2c       	mov	r15, r1
    785c:	b8 01       	movw	r22, r16
    785e:	8f 2d       	mov	r24, r15
    7860:	0e 94 51 25 	call	0x4aa2	; 0x4aa2 <settings_read_startup_line>
                report_status_message(STATUS_SETTING_READ_FAIL);
    7864:	81 11       	cpse	r24, r1
    7866:	03 c0       	rjmp	.+6      	; 0x786e <system_execute_line+0x272>
    7868:	87 e0       	ldi	r24, 0x07	; 7
    786a:	90 d8       	rcall	.-3808   	; 0x698c <report_status_message>
              } else {
                report_startup_line(helper_var,line);
    786c:	03 c0       	rjmp	.+6      	; 0x7874 <system_execute_line+0x278>
    786e:	b8 01       	movw	r22, r16
    7870:	8f 2d       	mov	r24, r15
    7872:	27 db       	rcall	.-2482   	; 0x6ec2 <report_startup_line>
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
          mc_reset(); // Force reset to ensure settings are initialized correctly.
          break;
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
    7874:	f3 94       	inc	r15
    7876:	f2 e0       	ldi	r31, 0x02	; 2
    7878:	ff 12       	cpse	r15, r31
    787a:	f0 cf       	rjmp	.-32     	; 0x785c <system_execute_line+0x260>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    787c:	f1 2c       	mov	r15, r1
    787e:	ff c0       	rjmp	.+510    	; 0x7a7e <system_execute_line+0x482>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    7880:	91 11       	cpse	r25, r1
    7882:	de c0       	rjmp	.+444    	; 0x7a40 <system_execute_line+0x444>
            helper_var = true;  // Set helper_var to flag storing method.
    7884:	ff 24       	eor	r15, r15
    7886:	f3 94       	inc	r15
    7888:	01 c0       	rjmp	.+2      	; 0x788c <system_execute_line+0x290>
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line)
{
  uint8_t char_counter = 1;
  uint8_t helper_var = 0; // Helper variable
    788a:	f1 2c       	mov	r15, r1
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
            helper_var = true;  // Set helper_var to flag storing method.
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    788c:	ae 01       	movw	r20, r28
    788e:	4e 5f       	subi	r20, 0xFE	; 254
    7890:	5f 4f       	sbci	r21, 0xFF	; 255
    7892:	be 01       	movw	r22, r28
    7894:	6f 5f       	subi	r22, 0xFF	; 255
    7896:	7f 4f       	sbci	r23, 0xFF	; 255
    7898:	c8 01       	movw	r24, r16
    789a:	0e 94 95 2d 	call	0x5b2a	; 0x5b2a <read_float>
    789e:	88 23       	and	r24, r24
    78a0:	09 f4       	brne	.+2      	; 0x78a4 <system_execute_line+0x2a8>
    78a2:	d2 c0       	rjmp	.+420    	; 0x7a48 <system_execute_line+0x44c>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    78a4:	89 81       	ldd	r24, Y+1	; 0x01
    78a6:	41 e0       	ldi	r20, 0x01	; 1
    78a8:	48 0f       	add	r20, r24
    78aa:	49 83       	std	Y+1, r20	; 0x01
    78ac:	f8 01       	movw	r30, r16
    78ae:	e8 0f       	add	r30, r24
    78b0:	f1 1d       	adc	r31, r1
    78b2:	80 81       	ld	r24, Z
    78b4:	8d 33       	cpi	r24, 0x3D	; 61
    78b6:	09 f0       	breq	.+2      	; 0x78ba <system_execute_line+0x2be>
    78b8:	cb c0       	rjmp	.+406    	; 0x7a50 <system_execute_line+0x454>
          if (helper_var) { // Store startup line
    78ba:	ff 20       	and	r15, r15
    78bc:	39 f1       	breq	.+78     	; 0x790c <system_execute_line+0x310>
    78be:	24 2f       	mov	r18, r20
            // Prepare sending gcode block to gcode parser by shifting all characters
            helper_var = char_counter; // Set helper variable as counter to start of gcode block
            do {
              line[char_counter-helper_var] = line[char_counter];
    78c0:	50 e0       	ldi	r21, 0x00	; 0
    78c2:	82 2f       	mov	r24, r18
    78c4:	90 e0       	ldi	r25, 0x00	; 0
    78c6:	d8 01       	movw	r26, r16
    78c8:	a8 0f       	add	r26, r24
    78ca:	b9 1f       	adc	r27, r25
    78cc:	3c 91       	ld	r19, X
    78ce:	84 1b       	sub	r24, r20
    78d0:	95 0b       	sbc	r25, r21
    78d2:	f8 01       	movw	r30, r16
    78d4:	e8 0f       	add	r30, r24
    78d6:	f9 1f       	adc	r31, r25
    78d8:	30 83       	st	Z, r19
            } while (line[char_counter++] != 0);
    78da:	2f 5f       	subi	r18, 0xFF	; 255
    78dc:	8c 91       	ld	r24, X
    78de:	81 11       	cpse	r24, r1
    78e0:	f0 cf       	rjmp	.-32     	; 0x78c2 <system_execute_line+0x2c6>
    78e2:	29 83       	std	Y+1, r18	; 0x01
            if (char_counter > EEPROM_LINE_SIZE) { return(STATUS_LINE_LENGTH_EXCEEDED); }
    78e4:	21 35       	cpi	r18, 0x51	; 81
    78e6:	08 f0       	brcs	.+2      	; 0x78ea <system_execute_line+0x2ee>
    78e8:	b8 c0       	rjmp	.+368    	; 0x7a5a <system_execute_line+0x45e>
            // Execute gcode block to ensure block is valid.
            helper_var = gc_execute_line(line); // Set helper_var to returned status code.
    78ea:	c8 01       	movw	r24, r16
    78ec:	0e 94 08 07 	call	0xe10	; 0xe10 <gc_execute_line>
            if (helper_var) { return(helper_var); }
    78f0:	f8 2e       	mov	r15, r24
            else {
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
    78f2:	81 11       	cpse	r24, r1
    78f4:	c4 c0       	rjmp	.+392    	; 0x7a7e <system_execute_line+0x482>
    78f6:	6a 81       	ldd	r22, Y+2	; 0x02
    78f8:	7b 81       	ldd	r23, Y+3	; 0x03
    78fa:	8c 81       	ldd	r24, Y+4	; 0x04
    78fc:	9d 81       	ldd	r25, Y+5	; 0x05
              settings_store_startup_line(helper_var,line);
    78fe:	51 d5       	rcall	.+2722   	; 0x83a2 <trunc>
    7900:	b8 d2       	rcall	.+1392   	; 0x7e72 <__fixunssfsi>
    7902:	86 2f       	mov	r24, r22
    7904:	b8 01       	movw	r22, r16
    7906:	0e 94 c1 24 	call	0x4982	; 0x4982 <settings_store_startup_line>
    790a:	b9 c0       	rjmp	.+370    	; 0x7a7e <system_execute_line+0x482>
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    790c:	ae 01       	movw	r20, r28
    790e:	4a 5f       	subi	r20, 0xFA	; 250
    7910:	5f 4f       	sbci	r21, 0xFF	; 255
    7912:	be 01       	movw	r22, r28
    7914:	6f 5f       	subi	r22, 0xFF	; 255
    7916:	7f 4f       	sbci	r23, 0xFF	; 255
    7918:	c8 01       	movw	r24, r16
    791a:	0e 94 95 2d 	call	0x5b2a	; 0x5b2a <read_float>
    791e:	88 23       	and	r24, r24
    7920:	09 f4       	brne	.+2      	; 0x7924 <system_execute_line+0x328>
    7922:	a0 c0       	rjmp	.+320    	; 0x7a64 <system_execute_line+0x468>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    7924:	89 81       	ldd	r24, Y+1	; 0x01
    7926:	f8 01       	movw	r30, r16
    7928:	e8 0f       	add	r30, r24
    792a:	f1 1d       	adc	r31, r1
    792c:	80 81       	ld	r24, Z
    792e:	81 11       	cpse	r24, r1
    7930:	9d c0       	rjmp	.+314    	; 0x7a6c <system_execute_line+0x470>
    7932:	ca 80       	ldd	r12, Y+2	; 0x02
    7934:	db 80       	ldd	r13, Y+3	; 0x03
    7936:	ec 80       	ldd	r14, Y+4	; 0x04
    7938:	fd 80       	ldd	r15, Y+5	; 0x05
    793a:	20 e0       	ldi	r18, 0x00	; 0
    793c:	30 e0       	ldi	r19, 0x00	; 0
    793e:	4f e7       	ldi	r20, 0x7F	; 127
    7940:	53 e4       	ldi	r21, 0x43	; 67
    7942:	c7 01       	movw	r24, r14
    7944:	b6 01       	movw	r22, r12
    7946:	24 d4       	rcall	.+2120   	; 0x8190 <__gesf2>
    7948:	18 16       	cp	r1, r24
    794a:	0c f4       	brge	.+2      	; 0x794e <system_execute_line+0x352>
            return(settings_store_global_setting((uint8_t)parameter, value));
    794c:	94 c0       	rjmp	.+296    	; 0x7a76 <system_execute_line+0x47a>
    794e:	8e 80       	ldd	r8, Y+6	; 0x06
    7950:	9f 80       	ldd	r9, Y+7	; 0x07
    7952:	a8 84       	ldd	r10, Y+8	; 0x08
    7954:	b9 84       	ldd	r11, Y+9	; 0x09
    7956:	c7 01       	movw	r24, r14
    7958:	b6 01       	movw	r22, r12
    795a:	8b d2       	rcall	.+1302   	; 0x7e72 <__fixunssfsi>
    795c:	86 2f       	mov	r24, r22
    795e:	b5 01       	movw	r22, r10
    7960:	a4 01       	movw	r20, r8
    7962:	0e 94 b5 25 	call	0x4b6a	; 0x4b6a <settings_store_global_setting>
    7966:	f8 2e       	mov	r15, r24
    7968:	8a c0       	rjmp	.+276    	; 0x7a7e <system_execute_line+0x482>
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    case 'J' : // Jogging
      // Execute only if in IDLE or JOG states.
      if (sys.state != STATE_IDLE && sys.state != STATE_JOG) { return(STATUS_IDLE_ERROR); }
    796a:	68 94       	set
    796c:	ff 24       	eor	r15, r15
    796e:	f3 f8       	bld	r15, 3
    7970:	86 c0       	rjmp	.+268    	; 0x7a7e <system_execute_line+0x482>
      if(line[2] != '=') { return(STATUS_INVALID_STATEMENT); }
    7972:	0f 2e       	mov	r0, r31
    7974:	f3 e0       	ldi	r31, 0x03	; 3
    7976:	ff 2e       	mov	r15, r31
    7978:	f0 2d       	mov	r31, r0
    797a:	81 c0       	rjmp	.+258    	; 0x7a7e <system_execute_line+0x482>
      return(gc_execute_line(line)); // NOTE: $J= is ignored inside g-code parser and used to detect jog motions.
      break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    797c:	0f 2e       	mov	r0, r31
    797e:	f3 e0       	ldi	r31, 0x03	; 3
    7980:	ff 2e       	mov	r15, r31
    7982:	f0 2d       	mov	r31, r0
    7984:	7c c0       	rjmp	.+248    	; 0x7a7e <system_execute_line+0x482>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7986:	f1 2c       	mov	r15, r1
    7988:	7a c0       	rjmp	.+244    	; 0x7a7e <system_execute_line+0x482>
      break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
      switch( line[1] ) {
        case '$' : // Prints Grbl settings
          if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    798a:	68 94       	set
    798c:	ff 24       	eor	r15, r15
    798e:	f3 f8       	bld	r15, 3
    7990:	76 c0       	rjmp	.+236    	; 0x7a7e <system_execute_line+0x482>
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) {
            mc_reset();
            report_feedback_message(MESSAGE_DISABLED);
          } else {
            if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    7992:	68 94       	set
    7994:	ff 24       	eor	r15, r15
    7996:	f3 f8       	bld	r15, 3
    7998:	72 c0       	rjmp	.+228    	; 0x7a7e <system_execute_line+0x482>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    799a:	f1 2c       	mov	r15, r1
    799c:	70 c0       	rjmp	.+224    	; 0x7a7e <system_execute_line+0x482>
          }
          break;
        case 'X' : // Disable alarm lock [ALARM]
          if (sys.state == STATE_ALARM) {
            // Block if safety door is ajar.
            if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); }
    799e:	0f 2e       	mov	r0, r31
    79a0:	fd e0       	ldi	r31, 0x0D	; 13
    79a2:	ff 2e       	mov	r15, r31
    79a4:	f0 2d       	mov	r31, r0
    79a6:	6b c0       	rjmp	.+214    	; 0x7a7e <system_execute_line+0x482>
          break;
      }
      break;
    default :
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    79a8:	68 94       	set
    79aa:	ff 24       	eor	r15, r15
    79ac:	f3 f8       	bld	r15, 3
    79ae:	67 c0       	rjmp	.+206    	; 0x7a7e <system_execute_line+0x482>
      switch( line[1] ) {
        case '#' : // Print Grbl NGC parameters
          if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    79b0:	0f 2e       	mov	r0, r31
    79b2:	f3 e0       	ldi	r31, 0x03	; 3
    79b4:	ff 2e       	mov	r15, r31
    79b6:	f0 2d       	mov	r31, r0
    79b8:	62 c0       	rjmp	.+196    	; 0x7a7e <system_execute_line+0x482>
          else { report_ngc_parameters(); }
          break;
        case 'H' : // Perform homing cycle [IDLE/ALARM]
          if (bit_isfalse(settings.flags,BITFLAG_HOMING_ENABLE)) {return(STATUS_SETTING_DISABLED); }
    79ba:	0f 2e       	mov	r0, r31
    79bc:	f5 e0       	ldi	r31, 0x05	; 5
    79be:	ff 2e       	mov	r15, r31
    79c0:	f0 2d       	mov	r31, r0
    79c2:	5d c0       	rjmp	.+186    	; 0x7a7e <system_execute_line+0x482>
          if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); } // Block if safety door is ajar.
    79c4:	0f 2e       	mov	r0, r31
    79c6:	fd e0       	ldi	r31, 0x0D	; 13
    79c8:	ff 2e       	mov	r15, r31
    79ca:	f0 2d       	mov	r31, r0
    79cc:	58 c0       	rjmp	.+176    	; 0x7a7e <system_execute_line+0x482>
                case 'Y': mc_homing_cycle(HOMING_CYCLE_Y); break;
                case 'Z': mc_homing_cycle(HOMING_CYCLE_Z); break;
                default: return(STATUS_INVALID_STATEMENT);
              }
          #endif
          } else { return(STATUS_INVALID_STATEMENT); }
    79ce:	0f 2e       	mov	r0, r31
    79d0:	f3 e0       	ldi	r31, 0x03	; 3
    79d2:	ff 2e       	mov	r15, r31
    79d4:	f0 2d       	mov	r31, r0
    79d6:	53 c0       	rjmp	.+166    	; 0x7a7e <system_execute_line+0x482>
            } else if (line[3] == 0) {
              switch (line[2]) {
                case 'X': mc_homing_cycle(HOMING_CYCLE_X); break;
                case 'Y': mc_homing_cycle(HOMING_CYCLE_Y); break;
                case 'Z': mc_homing_cycle(HOMING_CYCLE_Z); break;
                default: return(STATUS_INVALID_STATEMENT);
    79d8:	0f 2e       	mov	r0, r31
    79da:	f3 e0       	ldi	r31, 0x03	; 3
    79dc:	ff 2e       	mov	r15, r31
    79de:	f0 2d       	mov	r31, r0
    79e0:	4e c0       	rjmp	.+156    	; 0x7a7e <system_execute_line+0x482>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    79e2:	fe 2c       	mov	r15, r14
    79e4:	4c c0       	rjmp	.+152    	; 0x7a7e <system_execute_line+0x482>
            st_go_idle(); // Set steppers to the settings idle state before returning.
            if (line[2] == 0) { system_execute_startup(line); }
          }
          break;
        case 'S' : // Puts Grbl to sleep [IDLE/ALARM]
          if ((line[2] != 'L') || (line[3] != 'P') || (line[4] != 0)) { return(STATUS_INVALID_STATEMENT); }
    79e6:	0f 2e       	mov	r0, r31
    79e8:	f3 e0       	ldi	r31, 0x03	; 3
    79ea:	ff 2e       	mov	r15, r31
    79ec:	f0 2d       	mov	r31, r0
    79ee:	47 c0       	rjmp	.+142    	; 0x7a7e <system_execute_line+0x482>
    79f0:	0f 2e       	mov	r0, r31
    79f2:	f3 e0       	ldi	r31, 0x03	; 3
    79f4:	ff 2e       	mov	r15, r31
    79f6:	f0 2d       	mov	r31, r0
    79f8:	42 c0       	rjmp	.+132    	; 0x7a7e <system_execute_line+0x482>
    79fa:	0f 2e       	mov	r0, r31
    79fc:	f3 e0       	ldi	r31, 0x03	; 3
    79fe:	ff 2e       	mov	r15, r31
    7a00:	f0 2d       	mov	r31, r0
    7a02:	3d c0       	rjmp	.+122    	; 0x7a7e <system_execute_line+0x482>
          if ( line[++char_counter] == 0 ) {
            settings_read_build_info(line);
            report_build_info(line);
          #ifdef ENABLE_BUILD_INFO_WRITE_COMMAND
            } else { // Store startup line [IDLE/ALARM]
              if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    7a04:	0f 2e       	mov	r0, r31
    7a06:	f3 e0       	ldi	r31, 0x03	; 3
    7a08:	ff 2e       	mov	r15, r31
    7a0a:	f0 2d       	mov	r31, r0
    7a0c:	38 c0       	rjmp	.+112    	; 0x7a7e <system_execute_line+0x482>
              settings_store_build_info(line);
          #endif
          }
          break;
        case 'R' : // Restore defaults [IDLE/ALARM]
          if ((line[2] != 'S') || (line[3] != 'T') || (line[4] != '=') || (line[6] != 0)) { return(STATUS_INVALID_STATEMENT); }
    7a0e:	0f 2e       	mov	r0, r31
    7a10:	f3 e0       	ldi	r31, 0x03	; 3
    7a12:	ff 2e       	mov	r15, r31
    7a14:	f0 2d       	mov	r31, r0
    7a16:	33 c0       	rjmp	.+102    	; 0x7a7e <system_execute_line+0x482>
    7a18:	0f 2e       	mov	r0, r31
    7a1a:	f3 e0       	ldi	r31, 0x03	; 3
    7a1c:	ff 2e       	mov	r15, r31
    7a1e:	f0 2d       	mov	r31, r0
    7a20:	2e c0       	rjmp	.+92     	; 0x7a7e <system_execute_line+0x482>
    7a22:	0f 2e       	mov	r0, r31
    7a24:	f3 e0       	ldi	r31, 0x03	; 3
    7a26:	ff 2e       	mov	r15, r31
    7a28:	f0 2d       	mov	r31, r0
    7a2a:	29 c0       	rjmp	.+82     	; 0x7a7e <system_execute_line+0x482>
    7a2c:	0f 2e       	mov	r0, r31
    7a2e:	f3 e0       	ldi	r31, 0x03	; 3
    7a30:	ff 2e       	mov	r15, r31
    7a32:	f0 2d       	mov	r31, r0
    7a34:	24 c0       	rjmp	.+72     	; 0x7a7e <system_execute_line+0x482>
              case '#': settings_restore(SETTINGS_RESTORE_PARAMETERS); break;
            #endif
            #ifdef ENABLE_RESTORE_EEPROM_WIPE_ALL
              case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
            #endif
            default: return(STATUS_INVALID_STATEMENT);
    7a36:	0f 2e       	mov	r0, r31
    7a38:	f3 e0       	ldi	r31, 0x03	; 3
    7a3a:	ff 2e       	mov	r15, r31
    7a3c:	f0 2d       	mov	r31, r0
    7a3e:	1f c0       	rjmp	.+62     	; 0x7a7e <system_execute_line+0x482>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    7a40:	68 94       	set
    7a42:	ff 24       	eor	r15, r15
    7a44:	f3 f8       	bld	r15, 3
    7a46:	1b c0       	rjmp	.+54     	; 0x7a7e <system_execute_line+0x482>
            helper_var = true;  // Set helper_var to flag storing method.
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    7a48:	68 94       	set
    7a4a:	ff 24       	eor	r15, r15
    7a4c:	f1 f8       	bld	r15, 1
    7a4e:	17 c0       	rjmp	.+46     	; 0x7a7e <system_execute_line+0x482>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    7a50:	0f 2e       	mov	r0, r31
    7a52:	f3 e0       	ldi	r31, 0x03	; 3
    7a54:	ff 2e       	mov	r15, r31
    7a56:	f0 2d       	mov	r31, r0
    7a58:	12 c0       	rjmp	.+36     	; 0x7a7e <system_execute_line+0x482>
            // Prepare sending gcode block to gcode parser by shifting all characters
            helper_var = char_counter; // Set helper variable as counter to start of gcode block
            do {
              line[char_counter-helper_var] = line[char_counter];
            } while (line[char_counter++] != 0);
            if (char_counter > EEPROM_LINE_SIZE) { return(STATUS_LINE_LENGTH_EXCEEDED); }
    7a5a:	0f 2e       	mov	r0, r31
    7a5c:	fe e0       	ldi	r31, 0x0E	; 14
    7a5e:	ff 2e       	mov	r15, r31
    7a60:	f0 2d       	mov	r31, r0
    7a62:	0d c0       	rjmp	.+26     	; 0x7a7e <system_execute_line+0x482>
            else {
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
              settings_store_startup_line(helper_var,line);
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    7a64:	68 94       	set
    7a66:	ff 24       	eor	r15, r15
    7a68:	f1 f8       	bld	r15, 1
    7a6a:	09 c0       	rjmp	.+18     	; 0x7a7e <system_execute_line+0x482>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    7a6c:	0f 2e       	mov	r0, r31
    7a6e:	f3 e0       	ldi	r31, 0x03	; 3
    7a70:	ff 2e       	mov	r15, r31
    7a72:	f0 2d       	mov	r31, r0
    7a74:	04 c0       	rjmp	.+8      	; 0x7a7e <system_execute_line+0x482>
    7a76:	0f 2e       	mov	r0, r31
    7a78:	f3 e0       	ldi	r31, 0x03	; 3
    7a7a:	ff 2e       	mov	r15, r31
    7a7c:	f0 2d       	mov	r31, r0
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
}
    7a7e:	8f 2d       	mov	r24, r15
    7a80:	29 96       	adiw	r28, 0x09	; 9
    7a82:	0f b6       	in	r0, 0x3f	; 63
    7a84:	f8 94       	cli
    7a86:	de bf       	out	0x3e, r29	; 62
    7a88:	0f be       	out	0x3f, r0	; 63
    7a8a:	cd bf       	out	0x3d, r28	; 61
    7a8c:	df 91       	pop	r29
    7a8e:	cf 91       	pop	r28
    7a90:	1f 91       	pop	r17
    7a92:	0f 91       	pop	r16
    7a94:	ff 90       	pop	r15
    7a96:	ef 90       	pop	r14
    7a98:	df 90       	pop	r13
    7a9a:	cf 90       	pop	r12
    7a9c:	bf 90       	pop	r11
    7a9e:	af 90       	pop	r10
    7aa0:	9f 90       	pop	r9
    7aa2:	8f 90       	pop	r8
    7aa4:	08 95       	ret

00007aa6 <system_clear_exec_state_flag>:
  sys_rt_exec_state |= (mask);
  SREG = sreg;
}

void system_clear_exec_state_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    7aa6:	2f b7       	in	r18, 0x3f	; 63
  cli();
    7aa8:	f8 94       	cli
  sys_rt_exec_state &= ~(mask);
    7aaa:	90 91 29 0c 	lds	r25, 0x0C29	; 0x800c29 <sys_rt_exec_state>
    7aae:	80 95       	com	r24
    7ab0:	89 23       	and	r24, r25
    7ab2:	80 93 29 0c 	sts	0x0C29, r24	; 0x800c29 <sys_rt_exec_state>
  SREG = sreg;
    7ab6:	2f bf       	out	0x3f, r18	; 63
    7ab8:	08 95       	ret

00007aba <system_set_exec_alarm>:
}

void system_set_exec_alarm(uint8_t code) {
  uint8_t sreg = SREG;
    7aba:	9f b7       	in	r25, 0x3f	; 63
  cli();
    7abc:	f8 94       	cli
  sys_rt_exec_alarm = code;
    7abe:	80 93 43 0c 	sts	0x0C43, r24	; 0x800c43 <sys_rt_exec_alarm>
  SREG = sreg;
    7ac2:	9f bf       	out	0x3f, r25	; 63
    7ac4:	08 95       	ret

00007ac6 <system_clear_exec_alarm>:
}

void system_clear_exec_alarm() {
  uint8_t sreg = SREG;
    7ac6:	8f b7       	in	r24, 0x3f	; 63
  cli();
    7ac8:	f8 94       	cli
  sys_rt_exec_alarm = 0;
    7aca:	10 92 43 0c 	sts	0x0C43, r1	; 0x800c43 <sys_rt_exec_alarm>
  SREG = sreg;
    7ace:	8f bf       	out	0x3f, r24	; 63
    7ad0:	08 95       	ret

00007ad2 <system_set_exec_motion_override_flag>:
}

void system_set_exec_motion_override_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    7ad2:	9f b7       	in	r25, 0x3f	; 63
  cli();
    7ad4:	f8 94       	cli
  sys_rt_exec_motion_override |= (mask);
    7ad6:	20 91 15 0c 	lds	r18, 0x0C15	; 0x800c15 <sys_rt_exec_motion_override>
    7ada:	82 2b       	or	r24, r18
    7adc:	80 93 15 0c 	sts	0x0C15, r24	; 0x800c15 <sys_rt_exec_motion_override>
  SREG = sreg;
    7ae0:	9f bf       	out	0x3f, r25	; 63
    7ae2:	08 95       	ret

00007ae4 <system_set_exec_accessory_override_flag>:
}

void system_set_exec_accessory_override_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    7ae4:	9f b7       	in	r25, 0x3f	; 63
  cli();
    7ae6:	f8 94       	cli
  sys_rt_exec_accessory_override |= (mask);
    7ae8:	20 91 28 0c 	lds	r18, 0x0C28	; 0x800c28 <sys_rt_exec_accessory_override>
    7aec:	82 2b       	or	r24, r18
    7aee:	80 93 28 0c 	sts	0x0C28, r24	; 0x800c28 <sys_rt_exec_accessory_override>
  SREG = sreg;
    7af2:	9f bf       	out	0x3f, r25	; 63
    7af4:	08 95       	ret

00007af6 <system_clear_exec_motion_overrides>:
}

void system_clear_exec_motion_overrides() {
  uint8_t sreg = SREG;
    7af6:	8f b7       	in	r24, 0x3f	; 63
  cli();
    7af8:	f8 94       	cli
  sys_rt_exec_motion_override = 0;
    7afa:	10 92 15 0c 	sts	0x0C15, r1	; 0x800c15 <sys_rt_exec_motion_override>
  SREG = sreg;
    7afe:	8f bf       	out	0x3f, r24	; 63
    7b00:	08 95       	ret

00007b02 <system_clear_exec_accessory_overrides>:
}

void system_clear_exec_accessory_overrides() {
  uint8_t sreg = SREG;
    7b02:	8f b7       	in	r24, 0x3f	; 63
  cli();
    7b04:	f8 94       	cli
  sys_rt_exec_accessory_override = 0;
    7b06:	10 92 28 0c 	sts	0x0C28, r1	; 0x800c28 <sys_rt_exec_accessory_override>
  SREG = sreg;
    7b0a:	8f bf       	out	0x3f, r24	; 63
    7b0c:	08 95       	ret

00007b0e <sleep_init>:
// Initialization routine for sleep timer.
void sleep_init()
{
  // Configure Timer 3: Sleep Counter Overflow Interrupt
  // NOTE: By using an overflow interrupt, the timer is automatically reloaded upon overflow.
  TCCR3B = 0; // Normal operation. Overflow.
    7b0e:	e1 e9       	ldi	r30, 0x91	; 145
    7b10:	f0 e0       	ldi	r31, 0x00	; 0
    7b12:	10 82       	st	Z, r1
  TCCR3A = 0;
    7b14:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
  TCCR3B = (TCCR3B & ~((1<<CS32) | (1<<CS31))) | (1<<CS30); // Stop timer
    7b18:	80 81       	ld	r24, Z
    7b1a:	88 7f       	andi	r24, 0xF8	; 248
    7b1c:	81 60       	ori	r24, 0x01	; 1
    7b1e:	80 83       	st	Z, r24
  // TCCR3B |= (1<<CS32); // Enable timer with 1/256 prescaler. ~4.4min max with uint8 and 1.05sec/tick
  // TCCR3B |= (1<<CS31); // Enable timer with 1/8 prescaler. ~8.3sec max with uint8 and 32.7msec/tick
  TCCR3B |= (1<<CS31)|(1<<CS30); // Enable timer with 1/64 prescaler. ~66.8sec max with uint8 and 0.262sec/tick
    7b20:	80 81       	ld	r24, Z
    7b22:	83 60       	ori	r24, 0x03	; 3
    7b24:	80 83       	st	Z, r24
  TIMSK3 |= (1<<TOIE3); // Enable timer3 overflow interrupt
} 


// Disable sleep timer.
static void sleep_disable() {  TIMSK3 &= ~(1<<TOIE3); } // Disable timer overflow interrupt
    7b26:	e1 e7       	ldi	r30, 0x71	; 113
    7b28:	f0 e0       	ldi	r31, 0x00	; 0
    7b2a:	80 81       	ld	r24, Z
    7b2c:	8e 7f       	andi	r24, 0xFE	; 254
    7b2e:	80 83       	st	Z, r24
    7b30:	08 95       	ret

00007b32 <__vector_35>:
  sleep_disable();
}


// Increment sleep counter with each timer overflow.
ISR(TIMER3_OVF_vect) { sleep_counter++; }
    7b32:	1f 92       	push	r1
    7b34:	0f 92       	push	r0
    7b36:	0f b6       	in	r0, 0x3f	; 63
    7b38:	0f 92       	push	r0
    7b3a:	11 24       	eor	r1, r1
    7b3c:	8f 93       	push	r24
    7b3e:	80 91 16 0f 	lds	r24, 0x0F16	; 0x800f16 <sleep_counter>
    7b42:	8f 5f       	subi	r24, 0xFF	; 255
    7b44:	80 93 16 0f 	sts	0x0F16, r24	; 0x800f16 <sleep_counter>
    7b48:	8f 91       	pop	r24
    7b4a:	0f 90       	pop	r0
    7b4c:	0f be       	out	0x3f, r0	; 63
    7b4e:	0f 90       	pop	r0
    7b50:	1f 90       	pop	r1
    7b52:	18 95       	reti

00007b54 <jog_execute>:
#include "grbl.h"


// Sets up valid jog motion received from g-code parser, checks for soft-limits, and executes the jog.
uint8_t jog_execute(plan_line_data_t *pl_data, parser_block_t *gc_block)
{
    7b54:	0f 93       	push	r16
    7b56:	1f 93       	push	r17
    7b58:	cf 93       	push	r28
    7b5a:	df 93       	push	r29
    7b5c:	ec 01       	movw	r28, r24
    7b5e:	8b 01       	movw	r16, r22
  // Initialize planner data struct for jogging motions.
  // NOTE: Spindle and coolant are allowed to fully function with overrides during a jog.
  pl_data->feed_rate = gc_block->values.f;
    7b60:	fb 01       	movw	r30, r22
    7b62:	84 85       	ldd	r24, Z+12	; 0x0c
    7b64:	95 85       	ldd	r25, Z+13	; 0x0d
    7b66:	a6 85       	ldd	r26, Z+14	; 0x0e
    7b68:	b7 85       	ldd	r27, Z+15	; 0x0f
    7b6a:	88 83       	st	Y, r24
    7b6c:	99 83       	std	Y+1, r25	; 0x01
    7b6e:	aa 83       	std	Y+2, r26	; 0x02
    7b70:	bb 83       	std	Y+3, r27	; 0x03
  pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
    7b72:	8c 85       	ldd	r24, Y+12	; 0x0c
    7b74:	84 60       	ori	r24, 0x04	; 4
    7b76:	8c 87       	std	Y+12, r24	; 0x0c
  pl_data->line_number = gc_block->values.n;
    7b78:	85 8d       	ldd	r24, Z+29	; 0x1d
    7b7a:	96 8d       	ldd	r25, Z+30	; 0x1e
    7b7c:	a7 8d       	ldd	r26, Z+31	; 0x1f
    7b7e:	b0 a1       	ldd	r27, Z+32	; 0x20
    7b80:	88 87       	std	Y+8, r24	; 0x08
    7b82:	99 87       	std	Y+9, r25	; 0x09
    7b84:	aa 87       	std	Y+10, r26	; 0x0a
    7b86:	bb 87       	std	Y+11, r27	; 0x0b

  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
    7b88:	80 91 05 0f 	lds	r24, 0x0F05	; 0x800f05 <settings+0x45>
    7b8c:	85 ff       	sbrs	r24, 5
    7b8e:	05 c0       	rjmp	.+10     	; 0x7b9a <jog_execute+0x46>
    if (system_check_travel_limits(gc_block->values.xyz)) { return(STATUS_TRAVEL_EXCEEDED); }
    7b90:	cb 01       	movw	r24, r22
    7b92:	8e 96       	adiw	r24, 0x2e	; 46
    7b94:	c5 dc       	rcall	.-1654   	; 0x7520 <system_check_travel_limits>
    7b96:	81 11       	cpse	r24, r1
    7b98:	15 c0       	rjmp	.+42     	; 0x7bc4 <jog_execute+0x70>
  }

  // Valid jog command. Plan, set state, and execute.
  mc_line(gc_block->values.xyz,pl_data);
    7b9a:	be 01       	movw	r22, r28
    7b9c:	c8 01       	movw	r24, r16
    7b9e:	8e 96       	adiw	r24, 0x2e	; 46
    7ba0:	0e 94 03 03 	call	0x606	; 0x606 <mc_line>
  if (sys.state == STATE_IDLE) {
    7ba4:	c0 91 16 0c 	lds	r28, 0x0C16	; 0x800c16 <sys>
    7ba8:	c1 11       	cpse	r28, r1
    7baa:	0e c0       	rjmp	.+28     	; 0x7bc8 <jog_execute+0x74>
    if (plan_get_current_block() != NULL) { // Check if there is a block to execute.
    7bac:	0e 94 ed 28 	call	0x51da	; 0x51da <plan_get_current_block>
    7bb0:	89 2b       	or	r24, r25
    7bb2:	59 f0       	breq	.+22     	; 0x7bca <jog_execute+0x76>
      sys.state = STATE_JOG;
    7bb4:	80 e2       	ldi	r24, 0x20	; 32
    7bb6:	80 93 16 0c 	sts	0x0C16, r24	; 0x800c16 <sys>
      st_prep_buffer();
    7bba:	0e 94 b4 1b 	call	0x3768	; 0x3768 <st_prep_buffer>
      st_wake_up();  // NOTE: Manual start. No state machine required.
    7bbe:	0e 94 a7 18 	call	0x314e	; 0x314e <st_wake_up>
    7bc2:	03 c0       	rjmp	.+6      	; 0x7bca <jog_execute+0x76>
  pl_data->feed_rate = gc_block->values.f;
  pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
  pl_data->line_number = gc_block->values.n;

  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
    if (system_check_travel_limits(gc_block->values.xyz)) { return(STATUS_TRAVEL_EXCEEDED); }
    7bc4:	cf e0       	ldi	r28, 0x0F	; 15
    7bc6:	01 c0       	rjmp	.+2      	; 0x7bca <jog_execute+0x76>
      st_prep_buffer();
      st_wake_up();  // NOTE: Manual start. No state machine required.
    }
  }

  return(STATUS_OK);
    7bc8:	c0 e0       	ldi	r28, 0x00	; 0
}
    7bca:	8c 2f       	mov	r24, r28
    7bcc:	df 91       	pop	r29
    7bce:	cf 91       	pop	r28
    7bd0:	1f 91       	pop	r17
    7bd2:	0f 91       	pop	r16
    7bd4:	08 95       	ret

00007bd6 <__subsf3>:
    7bd6:	50 58       	subi	r21, 0x80	; 128

00007bd8 <__addsf3>:
    7bd8:	bb 27       	eor	r27, r27
    7bda:	aa 27       	eor	r26, r26
    7bdc:	0e d0       	rcall	.+28     	; 0x7bfa <__addsf3x>
    7bde:	76 c2       	rjmp	.+1260   	; 0x80cc <__fp_round>
    7be0:	3f d2       	rcall	.+1150   	; 0x8060 <__fp_pscA>
    7be2:	30 f0       	brcs	.+12     	; 0x7bf0 <__addsf3+0x18>
    7be4:	44 d2       	rcall	.+1160   	; 0x806e <__fp_pscB>
    7be6:	20 f0       	brcs	.+8      	; 0x7bf0 <__addsf3+0x18>
    7be8:	31 f4       	brne	.+12     	; 0x7bf6 <__addsf3+0x1e>
    7bea:	9f 3f       	cpi	r25, 0xFF	; 255
    7bec:	11 f4       	brne	.+4      	; 0x7bf2 <__addsf3+0x1a>
    7bee:	1e f4       	brtc	.+6      	; 0x7bf6 <__addsf3+0x1e>
    7bf0:	0f c2       	rjmp	.+1054   	; 0x8010 <__fp_nan>
    7bf2:	0e f4       	brtc	.+2      	; 0x7bf6 <__addsf3+0x1e>
    7bf4:	e0 95       	com	r30
    7bf6:	e7 fb       	bst	r30, 7
    7bf8:	dc c1       	rjmp	.+952    	; 0x7fb2 <__fp_inf>

00007bfa <__addsf3x>:
    7bfa:	e9 2f       	mov	r30, r25
    7bfc:	89 d2       	rcall	.+1298   	; 0x8110 <__fp_split3>
    7bfe:	80 f3       	brcs	.-32     	; 0x7be0 <__addsf3+0x8>
    7c00:	ba 17       	cp	r27, r26
    7c02:	62 07       	cpc	r22, r18
    7c04:	73 07       	cpc	r23, r19
    7c06:	84 07       	cpc	r24, r20
    7c08:	95 07       	cpc	r25, r21
    7c0a:	18 f0       	brcs	.+6      	; 0x7c12 <__addsf3x+0x18>
    7c0c:	71 f4       	brne	.+28     	; 0x7c2a <__addsf3x+0x30>
    7c0e:	9e f5       	brtc	.+102    	; 0x7c76 <__addsf3x+0x7c>
    7c10:	b8 c2       	rjmp	.+1392   	; 0x8182 <__fp_zero>
    7c12:	0e f4       	brtc	.+2      	; 0x7c16 <__addsf3x+0x1c>
    7c14:	e0 95       	com	r30
    7c16:	0b 2e       	mov	r0, r27
    7c18:	ba 2f       	mov	r27, r26
    7c1a:	a0 2d       	mov	r26, r0
    7c1c:	0b 01       	movw	r0, r22
    7c1e:	b9 01       	movw	r22, r18
    7c20:	90 01       	movw	r18, r0
    7c22:	0c 01       	movw	r0, r24
    7c24:	ca 01       	movw	r24, r20
    7c26:	a0 01       	movw	r20, r0
    7c28:	11 24       	eor	r1, r1
    7c2a:	ff 27       	eor	r31, r31
    7c2c:	59 1b       	sub	r21, r25
    7c2e:	99 f0       	breq	.+38     	; 0x7c56 <__addsf3x+0x5c>
    7c30:	59 3f       	cpi	r21, 0xF9	; 249
    7c32:	50 f4       	brcc	.+20     	; 0x7c48 <__addsf3x+0x4e>
    7c34:	50 3e       	cpi	r21, 0xE0	; 224
    7c36:	68 f1       	brcs	.+90     	; 0x7c92 <__addsf3x+0x98>
    7c38:	1a 16       	cp	r1, r26
    7c3a:	f0 40       	sbci	r31, 0x00	; 0
    7c3c:	a2 2f       	mov	r26, r18
    7c3e:	23 2f       	mov	r18, r19
    7c40:	34 2f       	mov	r19, r20
    7c42:	44 27       	eor	r20, r20
    7c44:	58 5f       	subi	r21, 0xF8	; 248
    7c46:	f3 cf       	rjmp	.-26     	; 0x7c2e <__addsf3x+0x34>
    7c48:	46 95       	lsr	r20
    7c4a:	37 95       	ror	r19
    7c4c:	27 95       	ror	r18
    7c4e:	a7 95       	ror	r26
    7c50:	f0 40       	sbci	r31, 0x00	; 0
    7c52:	53 95       	inc	r21
    7c54:	c9 f7       	brne	.-14     	; 0x7c48 <__addsf3x+0x4e>
    7c56:	7e f4       	brtc	.+30     	; 0x7c76 <__addsf3x+0x7c>
    7c58:	1f 16       	cp	r1, r31
    7c5a:	ba 0b       	sbc	r27, r26
    7c5c:	62 0b       	sbc	r22, r18
    7c5e:	73 0b       	sbc	r23, r19
    7c60:	84 0b       	sbc	r24, r20
    7c62:	ba f0       	brmi	.+46     	; 0x7c92 <__addsf3x+0x98>
    7c64:	91 50       	subi	r25, 0x01	; 1
    7c66:	a1 f0       	breq	.+40     	; 0x7c90 <__addsf3x+0x96>
    7c68:	ff 0f       	add	r31, r31
    7c6a:	bb 1f       	adc	r27, r27
    7c6c:	66 1f       	adc	r22, r22
    7c6e:	77 1f       	adc	r23, r23
    7c70:	88 1f       	adc	r24, r24
    7c72:	c2 f7       	brpl	.-16     	; 0x7c64 <__addsf3x+0x6a>
    7c74:	0e c0       	rjmp	.+28     	; 0x7c92 <__addsf3x+0x98>
    7c76:	ba 0f       	add	r27, r26
    7c78:	62 1f       	adc	r22, r18
    7c7a:	73 1f       	adc	r23, r19
    7c7c:	84 1f       	adc	r24, r20
    7c7e:	48 f4       	brcc	.+18     	; 0x7c92 <__addsf3x+0x98>
    7c80:	87 95       	ror	r24
    7c82:	77 95       	ror	r23
    7c84:	67 95       	ror	r22
    7c86:	b7 95       	ror	r27
    7c88:	f7 95       	ror	r31
    7c8a:	9e 3f       	cpi	r25, 0xFE	; 254
    7c8c:	08 f0       	brcs	.+2      	; 0x7c90 <__addsf3x+0x96>
    7c8e:	b3 cf       	rjmp	.-154    	; 0x7bf6 <__addsf3+0x1e>
    7c90:	93 95       	inc	r25
    7c92:	88 0f       	add	r24, r24
    7c94:	08 f0       	brcs	.+2      	; 0x7c98 <__addsf3x+0x9e>
    7c96:	99 27       	eor	r25, r25
    7c98:	ee 0f       	add	r30, r30
    7c9a:	97 95       	ror	r25
    7c9c:	87 95       	ror	r24
    7c9e:	08 95       	ret
    7ca0:	df d1       	rcall	.+958    	; 0x8060 <__fp_pscA>
    7ca2:	58 f0       	brcs	.+22     	; 0x7cba <__addsf3x+0xc0>
    7ca4:	80 e8       	ldi	r24, 0x80	; 128
    7ca6:	91 e0       	ldi	r25, 0x01	; 1
    7ca8:	09 f4       	brne	.+2      	; 0x7cac <__addsf3x+0xb2>
    7caa:	9e ef       	ldi	r25, 0xFE	; 254
    7cac:	e0 d1       	rcall	.+960    	; 0x806e <__fp_pscB>
    7cae:	28 f0       	brcs	.+10     	; 0x7cba <__addsf3x+0xc0>
    7cb0:	40 e8       	ldi	r20, 0x80	; 128
    7cb2:	51 e0       	ldi	r21, 0x01	; 1
    7cb4:	59 f4       	brne	.+22     	; 0x7ccc <atan2+0xe>
    7cb6:	5e ef       	ldi	r21, 0xFE	; 254
    7cb8:	09 c0       	rjmp	.+18     	; 0x7ccc <atan2+0xe>
    7cba:	aa c1       	rjmp	.+852    	; 0x8010 <__fp_nan>
    7cbc:	62 c2       	rjmp	.+1220   	; 0x8182 <__fp_zero>

00007cbe <atan2>:
    7cbe:	e9 2f       	mov	r30, r25
    7cc0:	e0 78       	andi	r30, 0x80	; 128
    7cc2:	26 d2       	rcall	.+1100   	; 0x8110 <__fp_split3>
    7cc4:	68 f3       	brcs	.-38     	; 0x7ca0 <__addsf3x+0xa6>
    7cc6:	09 2e       	mov	r0, r25
    7cc8:	05 2a       	or	r0, r21
    7cca:	c1 f3       	breq	.-16     	; 0x7cbc <__addsf3x+0xc2>
    7ccc:	26 17       	cp	r18, r22
    7cce:	37 07       	cpc	r19, r23
    7cd0:	48 07       	cpc	r20, r24
    7cd2:	59 07       	cpc	r21, r25
    7cd4:	38 f0       	brcs	.+14     	; 0x7ce4 <atan2+0x26>
    7cd6:	0e 2e       	mov	r0, r30
    7cd8:	07 f8       	bld	r0, 7
    7cda:	e0 25       	eor	r30, r0
    7cdc:	69 f0       	breq	.+26     	; 0x7cf8 <atan2+0x3a>
    7cde:	e0 25       	eor	r30, r0
    7ce0:	e0 64       	ori	r30, 0x40	; 64
    7ce2:	0a c0       	rjmp	.+20     	; 0x7cf8 <atan2+0x3a>
    7ce4:	ef 63       	ori	r30, 0x3F	; 63
    7ce6:	07 f8       	bld	r0, 7
    7ce8:	00 94       	com	r0
    7cea:	07 fa       	bst	r0, 7
    7cec:	db 01       	movw	r26, r22
    7cee:	b9 01       	movw	r22, r18
    7cf0:	9d 01       	movw	r18, r26
    7cf2:	dc 01       	movw	r26, r24
    7cf4:	ca 01       	movw	r24, r20
    7cf6:	ad 01       	movw	r20, r26
    7cf8:	ef 93       	push	r30
    7cfa:	5d d0       	rcall	.+186    	; 0x7db6 <__divsf3_pse>
    7cfc:	e7 d1       	rcall	.+974    	; 0x80cc <__fp_round>
    7cfe:	0a d0       	rcall	.+20     	; 0x7d14 <atan>
    7d00:	5f 91       	pop	r21
    7d02:	55 23       	and	r21, r21
    7d04:	31 f0       	breq	.+12     	; 0x7d12 <atan2+0x54>
    7d06:	2b ed       	ldi	r18, 0xDB	; 219
    7d08:	3f e0       	ldi	r19, 0x0F	; 15
    7d0a:	49 e4       	ldi	r20, 0x49	; 73
    7d0c:	50 fd       	sbrc	r21, 0
    7d0e:	49 ec       	ldi	r20, 0xC9	; 201
    7d10:	63 cf       	rjmp	.-314    	; 0x7bd8 <__addsf3>
    7d12:	08 95       	ret

00007d14 <atan>:
    7d14:	df 93       	push	r29
    7d16:	dd 27       	eor	r29, r29
    7d18:	b9 2f       	mov	r27, r25
    7d1a:	bf 77       	andi	r27, 0x7F	; 127
    7d1c:	40 e8       	ldi	r20, 0x80	; 128
    7d1e:	5f e3       	ldi	r21, 0x3F	; 63
    7d20:	16 16       	cp	r1, r22
    7d22:	17 06       	cpc	r1, r23
    7d24:	48 07       	cpc	r20, r24
    7d26:	5b 07       	cpc	r21, r27
    7d28:	10 f4       	brcc	.+4      	; 0x7d2e <atan+0x1a>
    7d2a:	d9 2f       	mov	r29, r25
    7d2c:	35 d2       	rcall	.+1130   	; 0x8198 <inverse>
    7d2e:	9f 93       	push	r25
    7d30:	8f 93       	push	r24
    7d32:	7f 93       	push	r23
    7d34:	6f 93       	push	r22
    7d36:	32 d3       	rcall	.+1636   	; 0x839c <square>
    7d38:	ee e9       	ldi	r30, 0x9E	; 158
    7d3a:	f2 e0       	ldi	r31, 0x02	; 2
    7d3c:	6c d1       	rcall	.+728    	; 0x8016 <__fp_powser>
    7d3e:	c6 d1       	rcall	.+908    	; 0x80cc <__fp_round>
    7d40:	2f 91       	pop	r18
    7d42:	3f 91       	pop	r19
    7d44:	4f 91       	pop	r20
    7d46:	5f 91       	pop	r21
    7d48:	6a d2       	rcall	.+1236   	; 0x821e <__mulsf3x>
    7d4a:	dd 23       	and	r29, r29
    7d4c:	49 f0       	breq	.+18     	; 0x7d60 <atan+0x4c>
    7d4e:	90 58       	subi	r25, 0x80	; 128
    7d50:	a2 ea       	ldi	r26, 0xA2	; 162
    7d52:	2a ed       	ldi	r18, 0xDA	; 218
    7d54:	3f e0       	ldi	r19, 0x0F	; 15
    7d56:	49 ec       	ldi	r20, 0xC9	; 201
    7d58:	5f e3       	ldi	r21, 0x3F	; 63
    7d5a:	d0 78       	andi	r29, 0x80	; 128
    7d5c:	5d 27       	eor	r21, r29
    7d5e:	4d df       	rcall	.-358    	; 0x7bfa <__addsf3x>
    7d60:	df 91       	pop	r29
    7d62:	b4 c1       	rjmp	.+872    	; 0x80cc <__fp_round>

00007d64 <ceil>:
    7d64:	f7 d1       	rcall	.+1006   	; 0x8154 <__fp_trunc>
    7d66:	80 f0       	brcs	.+32     	; 0x7d88 <ceil+0x24>
    7d68:	9f 37       	cpi	r25, 0x7F	; 127
    7d6a:	40 f4       	brcc	.+16     	; 0x7d7c <ceil+0x18>
    7d6c:	91 11       	cpse	r25, r1
    7d6e:	0e f4       	brtc	.+2      	; 0x7d72 <ceil+0xe>
    7d70:	09 c2       	rjmp	.+1042   	; 0x8184 <__fp_szero>
    7d72:	60 e0       	ldi	r22, 0x00	; 0
    7d74:	70 e0       	ldi	r23, 0x00	; 0
    7d76:	80 e8       	ldi	r24, 0x80	; 128
    7d78:	9f e3       	ldi	r25, 0x3F	; 63
    7d7a:	08 95       	ret
    7d7c:	26 f0       	brts	.+8      	; 0x7d86 <ceil+0x22>
    7d7e:	1b 16       	cp	r1, r27
    7d80:	61 1d       	adc	r22, r1
    7d82:	71 1d       	adc	r23, r1
    7d84:	81 1d       	adc	r24, r1
    7d86:	1b c1       	rjmp	.+566    	; 0x7fbe <__fp_mintl>
    7d88:	35 c1       	rjmp	.+618    	; 0x7ff4 <__fp_mpack>

00007d8a <__cmpsf2>:
    7d8a:	ef d0       	rcall	.+478    	; 0x7f6a <__fp_cmp>
    7d8c:	08 f4       	brcc	.+2      	; 0x7d90 <__cmpsf2+0x6>
    7d8e:	81 e0       	ldi	r24, 0x01	; 1
    7d90:	08 95       	ret

00007d92 <cos>:
    7d92:	75 d1       	rcall	.+746    	; 0x807e <__fp_rempio2>
    7d94:	e3 95       	inc	r30
    7d96:	ab c1       	rjmp	.+854    	; 0x80ee <__fp_sinus>

00007d98 <__divsf3>:
    7d98:	0c d0       	rcall	.+24     	; 0x7db2 <__divsf3x>
    7d9a:	98 c1       	rjmp	.+816    	; 0x80cc <__fp_round>
    7d9c:	68 d1       	rcall	.+720    	; 0x806e <__fp_pscB>
    7d9e:	40 f0       	brcs	.+16     	; 0x7db0 <__divsf3+0x18>
    7da0:	5f d1       	rcall	.+702    	; 0x8060 <__fp_pscA>
    7da2:	30 f0       	brcs	.+12     	; 0x7db0 <__divsf3+0x18>
    7da4:	21 f4       	brne	.+8      	; 0x7dae <__divsf3+0x16>
    7da6:	5f 3f       	cpi	r21, 0xFF	; 255
    7da8:	19 f0       	breq	.+6      	; 0x7db0 <__divsf3+0x18>
    7daa:	03 c1       	rjmp	.+518    	; 0x7fb2 <__fp_inf>
    7dac:	51 11       	cpse	r21, r1
    7dae:	ea c1       	rjmp	.+980    	; 0x8184 <__fp_szero>
    7db0:	2f c1       	rjmp	.+606    	; 0x8010 <__fp_nan>

00007db2 <__divsf3x>:
    7db2:	ae d1       	rcall	.+860    	; 0x8110 <__fp_split3>
    7db4:	98 f3       	brcs	.-26     	; 0x7d9c <__divsf3+0x4>

00007db6 <__divsf3_pse>:
    7db6:	99 23       	and	r25, r25
    7db8:	c9 f3       	breq	.-14     	; 0x7dac <__divsf3+0x14>
    7dba:	55 23       	and	r21, r21
    7dbc:	b1 f3       	breq	.-20     	; 0x7daa <__divsf3+0x12>
    7dbe:	95 1b       	sub	r25, r21
    7dc0:	55 0b       	sbc	r21, r21
    7dc2:	bb 27       	eor	r27, r27
    7dc4:	aa 27       	eor	r26, r26
    7dc6:	62 17       	cp	r22, r18
    7dc8:	73 07       	cpc	r23, r19
    7dca:	84 07       	cpc	r24, r20
    7dcc:	38 f0       	brcs	.+14     	; 0x7ddc <__divsf3_pse+0x26>
    7dce:	9f 5f       	subi	r25, 0xFF	; 255
    7dd0:	5f 4f       	sbci	r21, 0xFF	; 255
    7dd2:	22 0f       	add	r18, r18
    7dd4:	33 1f       	adc	r19, r19
    7dd6:	44 1f       	adc	r20, r20
    7dd8:	aa 1f       	adc	r26, r26
    7dda:	a9 f3       	breq	.-22     	; 0x7dc6 <__divsf3_pse+0x10>
    7ddc:	33 d0       	rcall	.+102    	; 0x7e44 <__divsf3_pse+0x8e>
    7dde:	0e 2e       	mov	r0, r30
    7de0:	3a f0       	brmi	.+14     	; 0x7df0 <__divsf3_pse+0x3a>
    7de2:	e0 e8       	ldi	r30, 0x80	; 128
    7de4:	30 d0       	rcall	.+96     	; 0x7e46 <__divsf3_pse+0x90>
    7de6:	91 50       	subi	r25, 0x01	; 1
    7de8:	50 40       	sbci	r21, 0x00	; 0
    7dea:	e6 95       	lsr	r30
    7dec:	00 1c       	adc	r0, r0
    7dee:	ca f7       	brpl	.-14     	; 0x7de2 <__divsf3_pse+0x2c>
    7df0:	29 d0       	rcall	.+82     	; 0x7e44 <__divsf3_pse+0x8e>
    7df2:	fe 2f       	mov	r31, r30
    7df4:	27 d0       	rcall	.+78     	; 0x7e44 <__divsf3_pse+0x8e>
    7df6:	66 0f       	add	r22, r22
    7df8:	77 1f       	adc	r23, r23
    7dfa:	88 1f       	adc	r24, r24
    7dfc:	bb 1f       	adc	r27, r27
    7dfe:	26 17       	cp	r18, r22
    7e00:	37 07       	cpc	r19, r23
    7e02:	48 07       	cpc	r20, r24
    7e04:	ab 07       	cpc	r26, r27
    7e06:	b0 e8       	ldi	r27, 0x80	; 128
    7e08:	09 f0       	breq	.+2      	; 0x7e0c <__divsf3_pse+0x56>
    7e0a:	bb 0b       	sbc	r27, r27
    7e0c:	80 2d       	mov	r24, r0
    7e0e:	bf 01       	movw	r22, r30
    7e10:	ff 27       	eor	r31, r31
    7e12:	93 58       	subi	r25, 0x83	; 131
    7e14:	5f 4f       	sbci	r21, 0xFF	; 255
    7e16:	2a f0       	brmi	.+10     	; 0x7e22 <__divsf3_pse+0x6c>
    7e18:	9e 3f       	cpi	r25, 0xFE	; 254
    7e1a:	51 05       	cpc	r21, r1
    7e1c:	68 f0       	brcs	.+26     	; 0x7e38 <__divsf3_pse+0x82>
    7e1e:	c9 c0       	rjmp	.+402    	; 0x7fb2 <__fp_inf>
    7e20:	b1 c1       	rjmp	.+866    	; 0x8184 <__fp_szero>
    7e22:	5f 3f       	cpi	r21, 0xFF	; 255
    7e24:	ec f3       	brlt	.-6      	; 0x7e20 <__divsf3_pse+0x6a>
    7e26:	98 3e       	cpi	r25, 0xE8	; 232
    7e28:	dc f3       	brlt	.-10     	; 0x7e20 <__divsf3_pse+0x6a>
    7e2a:	86 95       	lsr	r24
    7e2c:	77 95       	ror	r23
    7e2e:	67 95       	ror	r22
    7e30:	b7 95       	ror	r27
    7e32:	f7 95       	ror	r31
    7e34:	9f 5f       	subi	r25, 0xFF	; 255
    7e36:	c9 f7       	brne	.-14     	; 0x7e2a <__divsf3_pse+0x74>
    7e38:	88 0f       	add	r24, r24
    7e3a:	91 1d       	adc	r25, r1
    7e3c:	96 95       	lsr	r25
    7e3e:	87 95       	ror	r24
    7e40:	97 f9       	bld	r25, 7
    7e42:	08 95       	ret
    7e44:	e1 e0       	ldi	r30, 0x01	; 1
    7e46:	66 0f       	add	r22, r22
    7e48:	77 1f       	adc	r23, r23
    7e4a:	88 1f       	adc	r24, r24
    7e4c:	bb 1f       	adc	r27, r27
    7e4e:	62 17       	cp	r22, r18
    7e50:	73 07       	cpc	r23, r19
    7e52:	84 07       	cpc	r24, r20
    7e54:	ba 07       	cpc	r27, r26
    7e56:	20 f0       	brcs	.+8      	; 0x7e60 <__divsf3_pse+0xaa>
    7e58:	62 1b       	sub	r22, r18
    7e5a:	73 0b       	sbc	r23, r19
    7e5c:	84 0b       	sbc	r24, r20
    7e5e:	ba 0b       	sbc	r27, r26
    7e60:	ee 1f       	adc	r30, r30
    7e62:	88 f7       	brcc	.-30     	; 0x7e46 <__divsf3_pse+0x90>
    7e64:	e0 95       	com	r30
    7e66:	08 95       	ret

00007e68 <__fixsfsi>:
    7e68:	04 d0       	rcall	.+8      	; 0x7e72 <__fixunssfsi>
    7e6a:	68 94       	set
    7e6c:	b1 11       	cpse	r27, r1
    7e6e:	8a c1       	rjmp	.+788    	; 0x8184 <__fp_szero>
    7e70:	08 95       	ret

00007e72 <__fixunssfsi>:
    7e72:	56 d1       	rcall	.+684    	; 0x8120 <__fp_splitA>
    7e74:	88 f0       	brcs	.+34     	; 0x7e98 <__fixunssfsi+0x26>
    7e76:	9f 57       	subi	r25, 0x7F	; 127
    7e78:	90 f0       	brcs	.+36     	; 0x7e9e <__fixunssfsi+0x2c>
    7e7a:	b9 2f       	mov	r27, r25
    7e7c:	99 27       	eor	r25, r25
    7e7e:	b7 51       	subi	r27, 0x17	; 23
    7e80:	a0 f0       	brcs	.+40     	; 0x7eaa <__fixunssfsi+0x38>
    7e82:	d1 f0       	breq	.+52     	; 0x7eb8 <__fixunssfsi+0x46>
    7e84:	66 0f       	add	r22, r22
    7e86:	77 1f       	adc	r23, r23
    7e88:	88 1f       	adc	r24, r24
    7e8a:	99 1f       	adc	r25, r25
    7e8c:	1a f0       	brmi	.+6      	; 0x7e94 <__fixunssfsi+0x22>
    7e8e:	ba 95       	dec	r27
    7e90:	c9 f7       	brne	.-14     	; 0x7e84 <__fixunssfsi+0x12>
    7e92:	12 c0       	rjmp	.+36     	; 0x7eb8 <__fixunssfsi+0x46>
    7e94:	b1 30       	cpi	r27, 0x01	; 1
    7e96:	81 f0       	breq	.+32     	; 0x7eb8 <__fixunssfsi+0x46>
    7e98:	74 d1       	rcall	.+744    	; 0x8182 <__fp_zero>
    7e9a:	b1 e0       	ldi	r27, 0x01	; 1
    7e9c:	08 95       	ret
    7e9e:	71 c1       	rjmp	.+738    	; 0x8182 <__fp_zero>
    7ea0:	67 2f       	mov	r22, r23
    7ea2:	78 2f       	mov	r23, r24
    7ea4:	88 27       	eor	r24, r24
    7ea6:	b8 5f       	subi	r27, 0xF8	; 248
    7ea8:	39 f0       	breq	.+14     	; 0x7eb8 <__fixunssfsi+0x46>
    7eaa:	b9 3f       	cpi	r27, 0xF9	; 249
    7eac:	cc f3       	brlt	.-14     	; 0x7ea0 <__fixunssfsi+0x2e>
    7eae:	86 95       	lsr	r24
    7eb0:	77 95       	ror	r23
    7eb2:	67 95       	ror	r22
    7eb4:	b3 95       	inc	r27
    7eb6:	d9 f7       	brne	.-10     	; 0x7eae <__fixunssfsi+0x3c>
    7eb8:	3e f4       	brtc	.+14     	; 0x7ec8 <__fixunssfsi+0x56>
    7eba:	90 95       	com	r25
    7ebc:	80 95       	com	r24
    7ebe:	70 95       	com	r23
    7ec0:	61 95       	neg	r22
    7ec2:	7f 4f       	sbci	r23, 0xFF	; 255
    7ec4:	8f 4f       	sbci	r24, 0xFF	; 255
    7ec6:	9f 4f       	sbci	r25, 0xFF	; 255
    7ec8:	08 95       	ret

00007eca <__floatunsisf>:
    7eca:	e8 94       	clt
    7ecc:	09 c0       	rjmp	.+18     	; 0x7ee0 <__floatsisf+0x12>

00007ece <__floatsisf>:
    7ece:	97 fb       	bst	r25, 7
    7ed0:	3e f4       	brtc	.+14     	; 0x7ee0 <__floatsisf+0x12>
    7ed2:	90 95       	com	r25
    7ed4:	80 95       	com	r24
    7ed6:	70 95       	com	r23
    7ed8:	61 95       	neg	r22
    7eda:	7f 4f       	sbci	r23, 0xFF	; 255
    7edc:	8f 4f       	sbci	r24, 0xFF	; 255
    7ede:	9f 4f       	sbci	r25, 0xFF	; 255
    7ee0:	99 23       	and	r25, r25
    7ee2:	a9 f0       	breq	.+42     	; 0x7f0e <__floatsisf+0x40>
    7ee4:	f9 2f       	mov	r31, r25
    7ee6:	96 e9       	ldi	r25, 0x96	; 150
    7ee8:	bb 27       	eor	r27, r27
    7eea:	93 95       	inc	r25
    7eec:	f6 95       	lsr	r31
    7eee:	87 95       	ror	r24
    7ef0:	77 95       	ror	r23
    7ef2:	67 95       	ror	r22
    7ef4:	b7 95       	ror	r27
    7ef6:	f1 11       	cpse	r31, r1
    7ef8:	f8 cf       	rjmp	.-16     	; 0x7eea <__floatsisf+0x1c>
    7efa:	fa f4       	brpl	.+62     	; 0x7f3a <__floatsisf+0x6c>
    7efc:	bb 0f       	add	r27, r27
    7efe:	11 f4       	brne	.+4      	; 0x7f04 <__floatsisf+0x36>
    7f00:	60 ff       	sbrs	r22, 0
    7f02:	1b c0       	rjmp	.+54     	; 0x7f3a <__floatsisf+0x6c>
    7f04:	6f 5f       	subi	r22, 0xFF	; 255
    7f06:	7f 4f       	sbci	r23, 0xFF	; 255
    7f08:	8f 4f       	sbci	r24, 0xFF	; 255
    7f0a:	9f 4f       	sbci	r25, 0xFF	; 255
    7f0c:	16 c0       	rjmp	.+44     	; 0x7f3a <__floatsisf+0x6c>
    7f0e:	88 23       	and	r24, r24
    7f10:	11 f0       	breq	.+4      	; 0x7f16 <__floatsisf+0x48>
    7f12:	96 e9       	ldi	r25, 0x96	; 150
    7f14:	11 c0       	rjmp	.+34     	; 0x7f38 <__floatsisf+0x6a>
    7f16:	77 23       	and	r23, r23
    7f18:	21 f0       	breq	.+8      	; 0x7f22 <__floatsisf+0x54>
    7f1a:	9e e8       	ldi	r25, 0x8E	; 142
    7f1c:	87 2f       	mov	r24, r23
    7f1e:	76 2f       	mov	r23, r22
    7f20:	05 c0       	rjmp	.+10     	; 0x7f2c <__floatsisf+0x5e>
    7f22:	66 23       	and	r22, r22
    7f24:	71 f0       	breq	.+28     	; 0x7f42 <__floatsisf+0x74>
    7f26:	96 e8       	ldi	r25, 0x86	; 134
    7f28:	86 2f       	mov	r24, r22
    7f2a:	70 e0       	ldi	r23, 0x00	; 0
    7f2c:	60 e0       	ldi	r22, 0x00	; 0
    7f2e:	2a f0       	brmi	.+10     	; 0x7f3a <__floatsisf+0x6c>
    7f30:	9a 95       	dec	r25
    7f32:	66 0f       	add	r22, r22
    7f34:	77 1f       	adc	r23, r23
    7f36:	88 1f       	adc	r24, r24
    7f38:	da f7       	brpl	.-10     	; 0x7f30 <__floatsisf+0x62>
    7f3a:	88 0f       	add	r24, r24
    7f3c:	96 95       	lsr	r25
    7f3e:	87 95       	ror	r24
    7f40:	97 f9       	bld	r25, 7
    7f42:	08 95       	ret

00007f44 <floor>:
    7f44:	07 d1       	rcall	.+526    	; 0x8154 <__fp_trunc>
    7f46:	80 f0       	brcs	.+32     	; 0x7f68 <floor+0x24>
    7f48:	9f 37       	cpi	r25, 0x7F	; 127
    7f4a:	40 f4       	brcc	.+16     	; 0x7f5c <floor+0x18>
    7f4c:	91 11       	cpse	r25, r1
    7f4e:	0e f0       	brts	.+2      	; 0x7f52 <floor+0xe>
    7f50:	19 c1       	rjmp	.+562    	; 0x8184 <__fp_szero>
    7f52:	60 e0       	ldi	r22, 0x00	; 0
    7f54:	70 e0       	ldi	r23, 0x00	; 0
    7f56:	80 e8       	ldi	r24, 0x80	; 128
    7f58:	9f eb       	ldi	r25, 0xBF	; 191
    7f5a:	08 95       	ret
    7f5c:	26 f4       	brtc	.+8      	; 0x7f66 <floor+0x22>
    7f5e:	1b 16       	cp	r1, r27
    7f60:	61 1d       	adc	r22, r1
    7f62:	71 1d       	adc	r23, r1
    7f64:	81 1d       	adc	r24, r1
    7f66:	2b c0       	rjmp	.+86     	; 0x7fbe <__fp_mintl>
    7f68:	45 c0       	rjmp	.+138    	; 0x7ff4 <__fp_mpack>

00007f6a <__fp_cmp>:
    7f6a:	99 0f       	add	r25, r25
    7f6c:	00 08       	sbc	r0, r0
    7f6e:	55 0f       	add	r21, r21
    7f70:	aa 0b       	sbc	r26, r26
    7f72:	e0 e8       	ldi	r30, 0x80	; 128
    7f74:	fe ef       	ldi	r31, 0xFE	; 254
    7f76:	16 16       	cp	r1, r22
    7f78:	17 06       	cpc	r1, r23
    7f7a:	e8 07       	cpc	r30, r24
    7f7c:	f9 07       	cpc	r31, r25
    7f7e:	c0 f0       	brcs	.+48     	; 0x7fb0 <__fp_cmp+0x46>
    7f80:	12 16       	cp	r1, r18
    7f82:	13 06       	cpc	r1, r19
    7f84:	e4 07       	cpc	r30, r20
    7f86:	f5 07       	cpc	r31, r21
    7f88:	98 f0       	brcs	.+38     	; 0x7fb0 <__fp_cmp+0x46>
    7f8a:	62 1b       	sub	r22, r18
    7f8c:	73 0b       	sbc	r23, r19
    7f8e:	84 0b       	sbc	r24, r20
    7f90:	95 0b       	sbc	r25, r21
    7f92:	39 f4       	brne	.+14     	; 0x7fa2 <__fp_cmp+0x38>
    7f94:	0a 26       	eor	r0, r26
    7f96:	61 f0       	breq	.+24     	; 0x7fb0 <__fp_cmp+0x46>
    7f98:	23 2b       	or	r18, r19
    7f9a:	24 2b       	or	r18, r20
    7f9c:	25 2b       	or	r18, r21
    7f9e:	21 f4       	brne	.+8      	; 0x7fa8 <__fp_cmp+0x3e>
    7fa0:	08 95       	ret
    7fa2:	0a 26       	eor	r0, r26
    7fa4:	09 f4       	brne	.+2      	; 0x7fa8 <__fp_cmp+0x3e>
    7fa6:	a1 40       	sbci	r26, 0x01	; 1
    7fa8:	a6 95       	lsr	r26
    7faa:	8f ef       	ldi	r24, 0xFF	; 255
    7fac:	81 1d       	adc	r24, r1
    7fae:	81 1d       	adc	r24, r1
    7fb0:	08 95       	ret

00007fb2 <__fp_inf>:
    7fb2:	97 f9       	bld	r25, 7
    7fb4:	9f 67       	ori	r25, 0x7F	; 127
    7fb6:	80 e8       	ldi	r24, 0x80	; 128
    7fb8:	70 e0       	ldi	r23, 0x00	; 0
    7fba:	60 e0       	ldi	r22, 0x00	; 0
    7fbc:	08 95       	ret

00007fbe <__fp_mintl>:
    7fbe:	88 23       	and	r24, r24
    7fc0:	71 f4       	brne	.+28     	; 0x7fde <__fp_mintl+0x20>
    7fc2:	77 23       	and	r23, r23
    7fc4:	21 f0       	breq	.+8      	; 0x7fce <__fp_mintl+0x10>
    7fc6:	98 50       	subi	r25, 0x08	; 8
    7fc8:	87 2b       	or	r24, r23
    7fca:	76 2f       	mov	r23, r22
    7fcc:	07 c0       	rjmp	.+14     	; 0x7fdc <__fp_mintl+0x1e>
    7fce:	66 23       	and	r22, r22
    7fd0:	11 f4       	brne	.+4      	; 0x7fd6 <__fp_mintl+0x18>
    7fd2:	99 27       	eor	r25, r25
    7fd4:	0d c0       	rjmp	.+26     	; 0x7ff0 <__fp_mintl+0x32>
    7fd6:	90 51       	subi	r25, 0x10	; 16
    7fd8:	86 2b       	or	r24, r22
    7fda:	70 e0       	ldi	r23, 0x00	; 0
    7fdc:	60 e0       	ldi	r22, 0x00	; 0
    7fde:	2a f0       	brmi	.+10     	; 0x7fea <__fp_mintl+0x2c>
    7fe0:	9a 95       	dec	r25
    7fe2:	66 0f       	add	r22, r22
    7fe4:	77 1f       	adc	r23, r23
    7fe6:	88 1f       	adc	r24, r24
    7fe8:	da f7       	brpl	.-10     	; 0x7fe0 <__fp_mintl+0x22>
    7fea:	88 0f       	add	r24, r24
    7fec:	96 95       	lsr	r25
    7fee:	87 95       	ror	r24
    7ff0:	97 f9       	bld	r25, 7
    7ff2:	08 95       	ret

00007ff4 <__fp_mpack>:
    7ff4:	9f 3f       	cpi	r25, 0xFF	; 255
    7ff6:	31 f0       	breq	.+12     	; 0x8004 <__fp_mpack_finite+0xc>

00007ff8 <__fp_mpack_finite>:
    7ff8:	91 50       	subi	r25, 0x01	; 1
    7ffa:	20 f4       	brcc	.+8      	; 0x8004 <__fp_mpack_finite+0xc>
    7ffc:	87 95       	ror	r24
    7ffe:	77 95       	ror	r23
    8000:	67 95       	ror	r22
    8002:	b7 95       	ror	r27
    8004:	88 0f       	add	r24, r24
    8006:	91 1d       	adc	r25, r1
    8008:	96 95       	lsr	r25
    800a:	87 95       	ror	r24
    800c:	97 f9       	bld	r25, 7
    800e:	08 95       	ret

00008010 <__fp_nan>:
    8010:	9f ef       	ldi	r25, 0xFF	; 255
    8012:	80 ec       	ldi	r24, 0xC0	; 192
    8014:	08 95       	ret

00008016 <__fp_powser>:
    8016:	df 93       	push	r29
    8018:	cf 93       	push	r28
    801a:	1f 93       	push	r17
    801c:	0f 93       	push	r16
    801e:	ff 92       	push	r15
    8020:	ef 92       	push	r14
    8022:	df 92       	push	r13
    8024:	7b 01       	movw	r14, r22
    8026:	8c 01       	movw	r16, r24
    8028:	68 94       	set
    802a:	05 c0       	rjmp	.+10     	; 0x8036 <__fp_powser+0x20>
    802c:	da 2e       	mov	r13, r26
    802e:	ef 01       	movw	r28, r30
    8030:	f6 d0       	rcall	.+492    	; 0x821e <__mulsf3x>
    8032:	fe 01       	movw	r30, r28
    8034:	e8 94       	clt
    8036:	a5 91       	lpm	r26, Z+
    8038:	25 91       	lpm	r18, Z+
    803a:	35 91       	lpm	r19, Z+
    803c:	45 91       	lpm	r20, Z+
    803e:	55 91       	lpm	r21, Z+
    8040:	ae f3       	brts	.-22     	; 0x802c <__fp_powser+0x16>
    8042:	ef 01       	movw	r28, r30
    8044:	da dd       	rcall	.-1100   	; 0x7bfa <__addsf3x>
    8046:	fe 01       	movw	r30, r28
    8048:	97 01       	movw	r18, r14
    804a:	a8 01       	movw	r20, r16
    804c:	da 94       	dec	r13
    804e:	79 f7       	brne	.-34     	; 0x802e <__fp_powser+0x18>
    8050:	df 90       	pop	r13
    8052:	ef 90       	pop	r14
    8054:	ff 90       	pop	r15
    8056:	0f 91       	pop	r16
    8058:	1f 91       	pop	r17
    805a:	cf 91       	pop	r28
    805c:	df 91       	pop	r29
    805e:	08 95       	ret

00008060 <__fp_pscA>:
    8060:	00 24       	eor	r0, r0
    8062:	0a 94       	dec	r0
    8064:	16 16       	cp	r1, r22
    8066:	17 06       	cpc	r1, r23
    8068:	18 06       	cpc	r1, r24
    806a:	09 06       	cpc	r0, r25
    806c:	08 95       	ret

0000806e <__fp_pscB>:
    806e:	00 24       	eor	r0, r0
    8070:	0a 94       	dec	r0
    8072:	12 16       	cp	r1, r18
    8074:	13 06       	cpc	r1, r19
    8076:	14 06       	cpc	r1, r20
    8078:	05 06       	cpc	r0, r21
    807a:	08 95       	ret
    807c:	c9 cf       	rjmp	.-110    	; 0x8010 <__fp_nan>

0000807e <__fp_rempio2>:
    807e:	50 d0       	rcall	.+160    	; 0x8120 <__fp_splitA>
    8080:	e8 f3       	brcs	.-6      	; 0x807c <__fp_pscB+0xe>
    8082:	e8 94       	clt
    8084:	e0 e0       	ldi	r30, 0x00	; 0
    8086:	bb 27       	eor	r27, r27
    8088:	9f 57       	subi	r25, 0x7F	; 127
    808a:	f0 f0       	brcs	.+60     	; 0x80c8 <__fp_rempio2+0x4a>
    808c:	2a ed       	ldi	r18, 0xDA	; 218
    808e:	3f e0       	ldi	r19, 0x0F	; 15
    8090:	49 ec       	ldi	r20, 0xC9	; 201
    8092:	06 c0       	rjmp	.+12     	; 0x80a0 <__fp_rempio2+0x22>
    8094:	ee 0f       	add	r30, r30
    8096:	bb 0f       	add	r27, r27
    8098:	66 1f       	adc	r22, r22
    809a:	77 1f       	adc	r23, r23
    809c:	88 1f       	adc	r24, r24
    809e:	28 f0       	brcs	.+10     	; 0x80aa <__fp_rempio2+0x2c>
    80a0:	b2 3a       	cpi	r27, 0xA2	; 162
    80a2:	62 07       	cpc	r22, r18
    80a4:	73 07       	cpc	r23, r19
    80a6:	84 07       	cpc	r24, r20
    80a8:	28 f0       	brcs	.+10     	; 0x80b4 <__fp_rempio2+0x36>
    80aa:	b2 5a       	subi	r27, 0xA2	; 162
    80ac:	62 0b       	sbc	r22, r18
    80ae:	73 0b       	sbc	r23, r19
    80b0:	84 0b       	sbc	r24, r20
    80b2:	e3 95       	inc	r30
    80b4:	9a 95       	dec	r25
    80b6:	72 f7       	brpl	.-36     	; 0x8094 <__fp_rempio2+0x16>
    80b8:	80 38       	cpi	r24, 0x80	; 128
    80ba:	30 f4       	brcc	.+12     	; 0x80c8 <__fp_rempio2+0x4a>
    80bc:	9a 95       	dec	r25
    80be:	bb 0f       	add	r27, r27
    80c0:	66 1f       	adc	r22, r22
    80c2:	77 1f       	adc	r23, r23
    80c4:	88 1f       	adc	r24, r24
    80c6:	d2 f7       	brpl	.-12     	; 0x80bc <__fp_rempio2+0x3e>
    80c8:	90 48       	sbci	r25, 0x80	; 128
    80ca:	96 cf       	rjmp	.-212    	; 0x7ff8 <__fp_mpack_finite>

000080cc <__fp_round>:
    80cc:	09 2e       	mov	r0, r25
    80ce:	03 94       	inc	r0
    80d0:	00 0c       	add	r0, r0
    80d2:	11 f4       	brne	.+4      	; 0x80d8 <__fp_round+0xc>
    80d4:	88 23       	and	r24, r24
    80d6:	52 f0       	brmi	.+20     	; 0x80ec <__fp_round+0x20>
    80d8:	bb 0f       	add	r27, r27
    80da:	40 f4       	brcc	.+16     	; 0x80ec <__fp_round+0x20>
    80dc:	bf 2b       	or	r27, r31
    80de:	11 f4       	brne	.+4      	; 0x80e4 <__fp_round+0x18>
    80e0:	60 ff       	sbrs	r22, 0
    80e2:	04 c0       	rjmp	.+8      	; 0x80ec <__fp_round+0x20>
    80e4:	6f 5f       	subi	r22, 0xFF	; 255
    80e6:	7f 4f       	sbci	r23, 0xFF	; 255
    80e8:	8f 4f       	sbci	r24, 0xFF	; 255
    80ea:	9f 4f       	sbci	r25, 0xFF	; 255
    80ec:	08 95       	ret

000080ee <__fp_sinus>:
    80ee:	ef 93       	push	r30
    80f0:	e0 ff       	sbrs	r30, 0
    80f2:	06 c0       	rjmp	.+12     	; 0x8100 <__fp_sinus+0x12>
    80f4:	a2 ea       	ldi	r26, 0xA2	; 162
    80f6:	2a ed       	ldi	r18, 0xDA	; 218
    80f8:	3f e0       	ldi	r19, 0x0F	; 15
    80fa:	49 ec       	ldi	r20, 0xC9	; 201
    80fc:	5f eb       	ldi	r21, 0xBF	; 191
    80fe:	7d dd       	rcall	.-1286   	; 0x7bfa <__addsf3x>
    8100:	e5 df       	rcall	.-54     	; 0x80cc <__fp_round>
    8102:	0f 90       	pop	r0
    8104:	03 94       	inc	r0
    8106:	01 fc       	sbrc	r0, 1
    8108:	90 58       	subi	r25, 0x80	; 128
    810a:	eb ec       	ldi	r30, 0xCB	; 203
    810c:	f2 e0       	ldi	r31, 0x02	; 2
    810e:	57 c1       	rjmp	.+686    	; 0x83be <__fp_powsodd>

00008110 <__fp_split3>:
    8110:	57 fd       	sbrc	r21, 7
    8112:	90 58       	subi	r25, 0x80	; 128
    8114:	44 0f       	add	r20, r20
    8116:	55 1f       	adc	r21, r21
    8118:	59 f0       	breq	.+22     	; 0x8130 <__fp_splitA+0x10>
    811a:	5f 3f       	cpi	r21, 0xFF	; 255
    811c:	71 f0       	breq	.+28     	; 0x813a <__fp_splitA+0x1a>
    811e:	47 95       	ror	r20

00008120 <__fp_splitA>:
    8120:	88 0f       	add	r24, r24
    8122:	97 fb       	bst	r25, 7
    8124:	99 1f       	adc	r25, r25
    8126:	61 f0       	breq	.+24     	; 0x8140 <__fp_splitA+0x20>
    8128:	9f 3f       	cpi	r25, 0xFF	; 255
    812a:	79 f0       	breq	.+30     	; 0x814a <__fp_splitA+0x2a>
    812c:	87 95       	ror	r24
    812e:	08 95       	ret
    8130:	12 16       	cp	r1, r18
    8132:	13 06       	cpc	r1, r19
    8134:	14 06       	cpc	r1, r20
    8136:	55 1f       	adc	r21, r21
    8138:	f2 cf       	rjmp	.-28     	; 0x811e <__fp_split3+0xe>
    813a:	46 95       	lsr	r20
    813c:	f1 df       	rcall	.-30     	; 0x8120 <__fp_splitA>
    813e:	08 c0       	rjmp	.+16     	; 0x8150 <__fp_splitA+0x30>
    8140:	16 16       	cp	r1, r22
    8142:	17 06       	cpc	r1, r23
    8144:	18 06       	cpc	r1, r24
    8146:	99 1f       	adc	r25, r25
    8148:	f1 cf       	rjmp	.-30     	; 0x812c <__fp_splitA+0xc>
    814a:	86 95       	lsr	r24
    814c:	71 05       	cpc	r23, r1
    814e:	61 05       	cpc	r22, r1
    8150:	08 94       	sec
    8152:	08 95       	ret

00008154 <__fp_trunc>:
    8154:	e5 df       	rcall	.-54     	; 0x8120 <__fp_splitA>
    8156:	a0 f0       	brcs	.+40     	; 0x8180 <__fp_trunc+0x2c>
    8158:	be e7       	ldi	r27, 0x7E	; 126
    815a:	b9 17       	cp	r27, r25
    815c:	88 f4       	brcc	.+34     	; 0x8180 <__fp_trunc+0x2c>
    815e:	bb 27       	eor	r27, r27
    8160:	9f 38       	cpi	r25, 0x8F	; 143
    8162:	60 f4       	brcc	.+24     	; 0x817c <__fp_trunc+0x28>
    8164:	16 16       	cp	r1, r22
    8166:	b1 1d       	adc	r27, r1
    8168:	67 2f       	mov	r22, r23
    816a:	78 2f       	mov	r23, r24
    816c:	88 27       	eor	r24, r24
    816e:	98 5f       	subi	r25, 0xF8	; 248
    8170:	f7 cf       	rjmp	.-18     	; 0x8160 <__fp_trunc+0xc>
    8172:	86 95       	lsr	r24
    8174:	77 95       	ror	r23
    8176:	67 95       	ror	r22
    8178:	b1 1d       	adc	r27, r1
    817a:	93 95       	inc	r25
    817c:	96 39       	cpi	r25, 0x96	; 150
    817e:	c8 f3       	brcs	.-14     	; 0x8172 <__fp_trunc+0x1e>
    8180:	08 95       	ret

00008182 <__fp_zero>:
    8182:	e8 94       	clt

00008184 <__fp_szero>:
    8184:	bb 27       	eor	r27, r27
    8186:	66 27       	eor	r22, r22
    8188:	77 27       	eor	r23, r23
    818a:	cb 01       	movw	r24, r22
    818c:	97 f9       	bld	r25, 7
    818e:	08 95       	ret

00008190 <__gesf2>:
    8190:	ec de       	rcall	.-552    	; 0x7f6a <__fp_cmp>
    8192:	08 f4       	brcc	.+2      	; 0x8196 <__gesf2+0x6>
    8194:	8f ef       	ldi	r24, 0xFF	; 255
    8196:	08 95       	ret

00008198 <inverse>:
    8198:	9b 01       	movw	r18, r22
    819a:	ac 01       	movw	r20, r24
    819c:	60 e0       	ldi	r22, 0x00	; 0
    819e:	70 e0       	ldi	r23, 0x00	; 0
    81a0:	80 e8       	ldi	r24, 0x80	; 128
    81a2:	9f e3       	ldi	r25, 0x3F	; 63
    81a4:	f9 cd       	rjmp	.-1038   	; 0x7d98 <__divsf3>

000081a6 <lround>:
    81a6:	bc df       	rcall	.-136    	; 0x8120 <__fp_splitA>
    81a8:	58 f1       	brcs	.+86     	; 0x8200 <lround+0x5a>
    81aa:	9e 57       	subi	r25, 0x7E	; 126
    81ac:	58 f1       	brcs	.+86     	; 0x8204 <lround+0x5e>
    81ae:	98 51       	subi	r25, 0x18	; 24
    81b0:	a0 f0       	brcs	.+40     	; 0x81da <lround+0x34>
    81b2:	e9 f0       	breq	.+58     	; 0x81ee <lround+0x48>
    81b4:	98 30       	cpi	r25, 0x08	; 8
    81b6:	20 f5       	brcc	.+72     	; 0x8200 <lround+0x5a>
    81b8:	09 2e       	mov	r0, r25
    81ba:	99 27       	eor	r25, r25
    81bc:	66 0f       	add	r22, r22
    81be:	77 1f       	adc	r23, r23
    81c0:	88 1f       	adc	r24, r24
    81c2:	99 1f       	adc	r25, r25
    81c4:	0a 94       	dec	r0
    81c6:	d1 f7       	brne	.-12     	; 0x81bc <lround+0x16>
    81c8:	12 c0       	rjmp	.+36     	; 0x81ee <lround+0x48>
    81ca:	06 2e       	mov	r0, r22
    81cc:	67 2f       	mov	r22, r23
    81ce:	78 2f       	mov	r23, r24
    81d0:	88 27       	eor	r24, r24
    81d2:	98 5f       	subi	r25, 0xF8	; 248
    81d4:	11 f4       	brne	.+4      	; 0x81da <lround+0x34>
    81d6:	00 0c       	add	r0, r0
    81d8:	07 c0       	rjmp	.+14     	; 0x81e8 <lround+0x42>
    81da:	99 3f       	cpi	r25, 0xF9	; 249
    81dc:	b4 f3       	brlt	.-20     	; 0x81ca <lround+0x24>
    81de:	86 95       	lsr	r24
    81e0:	77 95       	ror	r23
    81e2:	67 95       	ror	r22
    81e4:	93 95       	inc	r25
    81e6:	d9 f7       	brne	.-10     	; 0x81de <lround+0x38>
    81e8:	61 1d       	adc	r22, r1
    81ea:	71 1d       	adc	r23, r1
    81ec:	81 1d       	adc	r24, r1
    81ee:	3e f4       	brtc	.+14     	; 0x81fe <lround+0x58>
    81f0:	90 95       	com	r25
    81f2:	80 95       	com	r24
    81f4:	70 95       	com	r23
    81f6:	61 95       	neg	r22
    81f8:	7f 4f       	sbci	r23, 0xFF	; 255
    81fa:	8f 4f       	sbci	r24, 0xFF	; 255
    81fc:	9f 4f       	sbci	r25, 0xFF	; 255
    81fe:	08 95       	ret
    8200:	68 94       	set
    8202:	c0 cf       	rjmp	.-128    	; 0x8184 <__fp_szero>
    8204:	be cf       	rjmp	.-132    	; 0x8182 <__fp_zero>

00008206 <__mulsf3>:
    8206:	0b d0       	rcall	.+22     	; 0x821e <__mulsf3x>
    8208:	61 cf       	rjmp	.-318    	; 0x80cc <__fp_round>
    820a:	2a df       	rcall	.-428    	; 0x8060 <__fp_pscA>
    820c:	28 f0       	brcs	.+10     	; 0x8218 <__mulsf3+0x12>
    820e:	2f df       	rcall	.-418    	; 0x806e <__fp_pscB>
    8210:	18 f0       	brcs	.+6      	; 0x8218 <__mulsf3+0x12>
    8212:	95 23       	and	r25, r21
    8214:	09 f0       	breq	.+2      	; 0x8218 <__mulsf3+0x12>
    8216:	cd ce       	rjmp	.-614    	; 0x7fb2 <__fp_inf>
    8218:	fb ce       	rjmp	.-522    	; 0x8010 <__fp_nan>
    821a:	11 24       	eor	r1, r1
    821c:	b3 cf       	rjmp	.-154    	; 0x8184 <__fp_szero>

0000821e <__mulsf3x>:
    821e:	78 df       	rcall	.-272    	; 0x8110 <__fp_split3>
    8220:	a0 f3       	brcs	.-24     	; 0x820a <__mulsf3+0x4>

00008222 <__mulsf3_pse>:
    8222:	95 9f       	mul	r25, r21
    8224:	d1 f3       	breq	.-12     	; 0x821a <__mulsf3+0x14>
    8226:	95 0f       	add	r25, r21
    8228:	50 e0       	ldi	r21, 0x00	; 0
    822a:	55 1f       	adc	r21, r21
    822c:	62 9f       	mul	r22, r18
    822e:	f0 01       	movw	r30, r0
    8230:	72 9f       	mul	r23, r18
    8232:	bb 27       	eor	r27, r27
    8234:	f0 0d       	add	r31, r0
    8236:	b1 1d       	adc	r27, r1
    8238:	63 9f       	mul	r22, r19
    823a:	aa 27       	eor	r26, r26
    823c:	f0 0d       	add	r31, r0
    823e:	b1 1d       	adc	r27, r1
    8240:	aa 1f       	adc	r26, r26
    8242:	64 9f       	mul	r22, r20
    8244:	66 27       	eor	r22, r22
    8246:	b0 0d       	add	r27, r0
    8248:	a1 1d       	adc	r26, r1
    824a:	66 1f       	adc	r22, r22
    824c:	82 9f       	mul	r24, r18
    824e:	22 27       	eor	r18, r18
    8250:	b0 0d       	add	r27, r0
    8252:	a1 1d       	adc	r26, r1
    8254:	62 1f       	adc	r22, r18
    8256:	73 9f       	mul	r23, r19
    8258:	b0 0d       	add	r27, r0
    825a:	a1 1d       	adc	r26, r1
    825c:	62 1f       	adc	r22, r18
    825e:	83 9f       	mul	r24, r19
    8260:	a0 0d       	add	r26, r0
    8262:	61 1d       	adc	r22, r1
    8264:	22 1f       	adc	r18, r18
    8266:	74 9f       	mul	r23, r20
    8268:	33 27       	eor	r19, r19
    826a:	a0 0d       	add	r26, r0
    826c:	61 1d       	adc	r22, r1
    826e:	23 1f       	adc	r18, r19
    8270:	84 9f       	mul	r24, r20
    8272:	60 0d       	add	r22, r0
    8274:	21 1d       	adc	r18, r1
    8276:	82 2f       	mov	r24, r18
    8278:	76 2f       	mov	r23, r22
    827a:	6a 2f       	mov	r22, r26
    827c:	11 24       	eor	r1, r1
    827e:	9f 57       	subi	r25, 0x7F	; 127
    8280:	50 40       	sbci	r21, 0x00	; 0
    8282:	8a f0       	brmi	.+34     	; 0x82a6 <__mulsf3_pse+0x84>
    8284:	e1 f0       	breq	.+56     	; 0x82be <__mulsf3_pse+0x9c>
    8286:	88 23       	and	r24, r24
    8288:	4a f0       	brmi	.+18     	; 0x829c <__mulsf3_pse+0x7a>
    828a:	ee 0f       	add	r30, r30
    828c:	ff 1f       	adc	r31, r31
    828e:	bb 1f       	adc	r27, r27
    8290:	66 1f       	adc	r22, r22
    8292:	77 1f       	adc	r23, r23
    8294:	88 1f       	adc	r24, r24
    8296:	91 50       	subi	r25, 0x01	; 1
    8298:	50 40       	sbci	r21, 0x00	; 0
    829a:	a9 f7       	brne	.-22     	; 0x8286 <__mulsf3_pse+0x64>
    829c:	9e 3f       	cpi	r25, 0xFE	; 254
    829e:	51 05       	cpc	r21, r1
    82a0:	70 f0       	brcs	.+28     	; 0x82be <__mulsf3_pse+0x9c>
    82a2:	87 ce       	rjmp	.-754    	; 0x7fb2 <__fp_inf>
    82a4:	6f cf       	rjmp	.-290    	; 0x8184 <__fp_szero>
    82a6:	5f 3f       	cpi	r21, 0xFF	; 255
    82a8:	ec f3       	brlt	.-6      	; 0x82a4 <__mulsf3_pse+0x82>
    82aa:	98 3e       	cpi	r25, 0xE8	; 232
    82ac:	dc f3       	brlt	.-10     	; 0x82a4 <__mulsf3_pse+0x82>
    82ae:	86 95       	lsr	r24
    82b0:	77 95       	ror	r23
    82b2:	67 95       	ror	r22
    82b4:	b7 95       	ror	r27
    82b6:	f7 95       	ror	r31
    82b8:	e7 95       	ror	r30
    82ba:	9f 5f       	subi	r25, 0xFF	; 255
    82bc:	c1 f7       	brne	.-16     	; 0x82ae <__mulsf3_pse+0x8c>
    82be:	fe 2b       	or	r31, r30
    82c0:	88 0f       	add	r24, r24
    82c2:	91 1d       	adc	r25, r1
    82c4:	96 95       	lsr	r25
    82c6:	87 95       	ror	r24
    82c8:	97 f9       	bld	r25, 7
    82ca:	08 95       	ret

000082cc <round>:
    82cc:	29 df       	rcall	.-430    	; 0x8120 <__fp_splitA>
    82ce:	e0 f0       	brcs	.+56     	; 0x8308 <round+0x3c>
    82d0:	9e 37       	cpi	r25, 0x7E	; 126
    82d2:	d8 f0       	brcs	.+54     	; 0x830a <round+0x3e>
    82d4:	96 39       	cpi	r25, 0x96	; 150
    82d6:	b8 f4       	brcc	.+46     	; 0x8306 <round+0x3a>
    82d8:	9e 38       	cpi	r25, 0x8E	; 142
    82da:	48 f4       	brcc	.+18     	; 0x82ee <round+0x22>
    82dc:	67 2f       	mov	r22, r23
    82de:	78 2f       	mov	r23, r24
    82e0:	88 27       	eor	r24, r24
    82e2:	98 5f       	subi	r25, 0xF8	; 248
    82e4:	f9 cf       	rjmp	.-14     	; 0x82d8 <round+0xc>
    82e6:	86 95       	lsr	r24
    82e8:	77 95       	ror	r23
    82ea:	67 95       	ror	r22
    82ec:	93 95       	inc	r25
    82ee:	95 39       	cpi	r25, 0x95	; 149
    82f0:	d0 f3       	brcs	.-12     	; 0x82e6 <round+0x1a>
    82f2:	b6 2f       	mov	r27, r22
    82f4:	b1 70       	andi	r27, 0x01	; 1
    82f6:	6b 0f       	add	r22, r27
    82f8:	71 1d       	adc	r23, r1
    82fa:	81 1d       	adc	r24, r1
    82fc:	20 f4       	brcc	.+8      	; 0x8306 <round+0x3a>
    82fe:	87 95       	ror	r24
    8300:	77 95       	ror	r23
    8302:	67 95       	ror	r22
    8304:	93 95       	inc	r25
    8306:	5b ce       	rjmp	.-842    	; 0x7fbe <__fp_mintl>
    8308:	75 ce       	rjmp	.-790    	; 0x7ff4 <__fp_mpack>
    830a:	3c cf       	rjmp	.-392    	; 0x8184 <__fp_szero>

0000830c <sin>:
    830c:	9f 93       	push	r25
    830e:	b7 de       	rcall	.-658    	; 0x807e <__fp_rempio2>
    8310:	0f 90       	pop	r0
    8312:	07 fc       	sbrc	r0, 7
    8314:	ee 5f       	subi	r30, 0xFE	; 254
    8316:	eb ce       	rjmp	.-554    	; 0x80ee <__fp_sinus>
    8318:	11 f4       	brne	.+4      	; 0x831e <sin+0x12>
    831a:	0e f4       	brtc	.+2      	; 0x831e <sin+0x12>
    831c:	79 ce       	rjmp	.-782    	; 0x8010 <__fp_nan>
    831e:	6a ce       	rjmp	.-812    	; 0x7ff4 <__fp_mpack>

00008320 <sqrt>:
    8320:	ff de       	rcall	.-514    	; 0x8120 <__fp_splitA>
    8322:	d0 f3       	brcs	.-12     	; 0x8318 <sin+0xc>
    8324:	99 23       	and	r25, r25
    8326:	d9 f3       	breq	.-10     	; 0x831e <sin+0x12>
    8328:	ce f3       	brts	.-14     	; 0x831c <sin+0x10>
    832a:	9f 57       	subi	r25, 0x7F	; 127
    832c:	55 0b       	sbc	r21, r21
    832e:	87 ff       	sbrs	r24, 7
    8330:	3f d0       	rcall	.+126    	; 0x83b0 <__fp_norm2>
    8332:	00 24       	eor	r0, r0
    8334:	a0 e6       	ldi	r26, 0x60	; 96
    8336:	40 ea       	ldi	r20, 0xA0	; 160
    8338:	90 01       	movw	r18, r0
    833a:	80 58       	subi	r24, 0x80	; 128
    833c:	56 95       	lsr	r21
    833e:	97 95       	ror	r25
    8340:	28 f4       	brcc	.+10     	; 0x834c <sqrt+0x2c>
    8342:	80 5c       	subi	r24, 0xC0	; 192
    8344:	66 0f       	add	r22, r22
    8346:	77 1f       	adc	r23, r23
    8348:	88 1f       	adc	r24, r24
    834a:	20 f0       	brcs	.+8      	; 0x8354 <sqrt+0x34>
    834c:	26 17       	cp	r18, r22
    834e:	37 07       	cpc	r19, r23
    8350:	48 07       	cpc	r20, r24
    8352:	30 f4       	brcc	.+12     	; 0x8360 <sqrt+0x40>
    8354:	62 1b       	sub	r22, r18
    8356:	73 0b       	sbc	r23, r19
    8358:	84 0b       	sbc	r24, r20
    835a:	20 29       	or	r18, r0
    835c:	31 29       	or	r19, r1
    835e:	4a 2b       	or	r20, r26
    8360:	a6 95       	lsr	r26
    8362:	17 94       	ror	r1
    8364:	07 94       	ror	r0
    8366:	20 25       	eor	r18, r0
    8368:	31 25       	eor	r19, r1
    836a:	4a 27       	eor	r20, r26
    836c:	58 f7       	brcc	.-42     	; 0x8344 <sqrt+0x24>
    836e:	66 0f       	add	r22, r22
    8370:	77 1f       	adc	r23, r23
    8372:	88 1f       	adc	r24, r24
    8374:	20 f0       	brcs	.+8      	; 0x837e <sqrt+0x5e>
    8376:	26 17       	cp	r18, r22
    8378:	37 07       	cpc	r19, r23
    837a:	48 07       	cpc	r20, r24
    837c:	30 f4       	brcc	.+12     	; 0x838a <sqrt+0x6a>
    837e:	62 0b       	sbc	r22, r18
    8380:	73 0b       	sbc	r23, r19
    8382:	84 0b       	sbc	r24, r20
    8384:	20 0d       	add	r18, r0
    8386:	31 1d       	adc	r19, r1
    8388:	41 1d       	adc	r20, r1
    838a:	a0 95       	com	r26
    838c:	81 f7       	brne	.-32     	; 0x836e <sqrt+0x4e>
    838e:	b9 01       	movw	r22, r18
    8390:	84 2f       	mov	r24, r20
    8392:	91 58       	subi	r25, 0x81	; 129
    8394:	88 0f       	add	r24, r24
    8396:	96 95       	lsr	r25
    8398:	87 95       	ror	r24
    839a:	08 95       	ret

0000839c <square>:
    839c:	9b 01       	movw	r18, r22
    839e:	ac 01       	movw	r20, r24
    83a0:	32 cf       	rjmp	.-412    	; 0x8206 <__mulsf3>

000083a2 <trunc>:
    83a2:	d8 de       	rcall	.-592    	; 0x8154 <__fp_trunc>
    83a4:	20 f0       	brcs	.+8      	; 0x83ae <trunc+0xc>
    83a6:	9f 37       	cpi	r25, 0x7F	; 127
    83a8:	08 f4       	brcc	.+2      	; 0x83ac <trunc+0xa>
    83aa:	ec ce       	rjmp	.-552    	; 0x8184 <__fp_szero>
    83ac:	08 ce       	rjmp	.-1008   	; 0x7fbe <__fp_mintl>
    83ae:	22 ce       	rjmp	.-956    	; 0x7ff4 <__fp_mpack>

000083b0 <__fp_norm2>:
    83b0:	91 50       	subi	r25, 0x01	; 1
    83b2:	50 40       	sbci	r21, 0x00	; 0
    83b4:	66 0f       	add	r22, r22
    83b6:	77 1f       	adc	r23, r23
    83b8:	88 1f       	adc	r24, r24
    83ba:	d2 f7       	brpl	.-12     	; 0x83b0 <__fp_norm2>
    83bc:	08 95       	ret

000083be <__fp_powsodd>:
    83be:	9f 93       	push	r25
    83c0:	8f 93       	push	r24
    83c2:	7f 93       	push	r23
    83c4:	6f 93       	push	r22
    83c6:	ff 93       	push	r31
    83c8:	ef 93       	push	r30
    83ca:	9b 01       	movw	r18, r22
    83cc:	ac 01       	movw	r20, r24
    83ce:	1b df       	rcall	.-458    	; 0x8206 <__mulsf3>
    83d0:	ef 91       	pop	r30
    83d2:	ff 91       	pop	r31
    83d4:	20 de       	rcall	.-960    	; 0x8016 <__fp_powser>
    83d6:	2f 91       	pop	r18
    83d8:	3f 91       	pop	r19
    83da:	4f 91       	pop	r20
    83dc:	5f 91       	pop	r21
    83de:	13 cf       	rjmp	.-474    	; 0x8206 <__mulsf3>

000083e0 <__udivmodsi4>:
    83e0:	a1 e2       	ldi	r26, 0x21	; 33
    83e2:	1a 2e       	mov	r1, r26
    83e4:	aa 1b       	sub	r26, r26
    83e6:	bb 1b       	sub	r27, r27
    83e8:	fd 01       	movw	r30, r26
    83ea:	0d c0       	rjmp	.+26     	; 0x8406 <__udivmodsi4_ep>

000083ec <__udivmodsi4_loop>:
    83ec:	aa 1f       	adc	r26, r26
    83ee:	bb 1f       	adc	r27, r27
    83f0:	ee 1f       	adc	r30, r30
    83f2:	ff 1f       	adc	r31, r31
    83f4:	a2 17       	cp	r26, r18
    83f6:	b3 07       	cpc	r27, r19
    83f8:	e4 07       	cpc	r30, r20
    83fa:	f5 07       	cpc	r31, r21
    83fc:	20 f0       	brcs	.+8      	; 0x8406 <__udivmodsi4_ep>
    83fe:	a2 1b       	sub	r26, r18
    8400:	b3 0b       	sbc	r27, r19
    8402:	e4 0b       	sbc	r30, r20
    8404:	f5 0b       	sbc	r31, r21

00008406 <__udivmodsi4_ep>:
    8406:	66 1f       	adc	r22, r22
    8408:	77 1f       	adc	r23, r23
    840a:	88 1f       	adc	r24, r24
    840c:	99 1f       	adc	r25, r25
    840e:	1a 94       	dec	r1
    8410:	69 f7       	brne	.-38     	; 0x83ec <__udivmodsi4_loop>
    8412:	60 95       	com	r22
    8414:	70 95       	com	r23
    8416:	80 95       	com	r24
    8418:	90 95       	com	r25
    841a:	9b 01       	movw	r18, r22
    841c:	ac 01       	movw	r20, r24
    841e:	bd 01       	movw	r22, r26
    8420:	cf 01       	movw	r24, r30
    8422:	08 95       	ret

00008424 <__tablejump2__>:
    8424:	ee 0f       	add	r30, r30
    8426:	ff 1f       	adc	r31, r31
    8428:	88 1f       	adc	r24, r24
    842a:	8b bf       	out	0x3b, r24	; 59
    842c:	07 90       	elpm	r0, Z+
    842e:	f6 91       	elpm	r31, Z
    8430:	e0 2d       	mov	r30, r0
    8432:	19 94       	eijmp

00008434 <__umulhisi3>:
    8434:	a2 9f       	mul	r26, r18
    8436:	b0 01       	movw	r22, r0
    8438:	b3 9f       	mul	r27, r19
    843a:	c0 01       	movw	r24, r0
    843c:	a3 9f       	mul	r26, r19
    843e:	70 0d       	add	r23, r0
    8440:	81 1d       	adc	r24, r1
    8442:	11 24       	eor	r1, r1
    8444:	91 1d       	adc	r25, r1
    8446:	b2 9f       	mul	r27, r18
    8448:	70 0d       	add	r23, r0
    844a:	81 1d       	adc	r24, r1
    844c:	11 24       	eor	r1, r1
    844e:	91 1d       	adc	r25, r1
    8450:	08 95       	ret

00008452 <memcmp>:
    8452:	fb 01       	movw	r30, r22
    8454:	dc 01       	movw	r26, r24
    8456:	04 c0       	rjmp	.+8      	; 0x8460 <memcmp+0xe>
    8458:	8d 91       	ld	r24, X+
    845a:	01 90       	ld	r0, Z+
    845c:	80 19       	sub	r24, r0
    845e:	21 f4       	brne	.+8      	; 0x8468 <memcmp+0x16>
    8460:	41 50       	subi	r20, 0x01	; 1
    8462:	50 40       	sbci	r21, 0x00	; 0
    8464:	c8 f7       	brcc	.-14     	; 0x8458 <memcmp+0x6>
    8466:	88 1b       	sub	r24, r24
    8468:	99 0b       	sbc	r25, r25
    846a:	08 95       	ret

0000846c <_exit>:
    846c:	f8 94       	cli

0000846e <__stop_program>:
    846e:	ff cf       	rjmp	.-2      	; 0x846e <__stop_program>

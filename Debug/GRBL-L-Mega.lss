
GRBL-L-Mega.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800200  00800200  0000869a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00008626  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000d27  00800200  00800200  0000869a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000869a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000086cc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006d0  00000000  00000000  0000870c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000b082  00000000  00000000  00008ddc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002c8c  00000000  00000000  00013e5e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000063a8  00000000  00000000  00016aea  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000016a4  00000000  00000000  0001ce94  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000021e1  00000000  00000000  0001e538  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000070b7  00000000  00000000  00020719  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000006d8  00000000  00000000  000277d0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	9b c2       	rjmp	.+1334   	; 0x538 <__ctors_end>
       2:	00 00       	nop
       4:	ac c2       	rjmp	.+1368   	; 0x55e <__bad_interrupt>
       6:	00 00       	nop
       8:	aa c2       	rjmp	.+1364   	; 0x55e <__bad_interrupt>
       a:	00 00       	nop
       c:	a8 c2       	rjmp	.+1360   	; 0x55e <__bad_interrupt>
       e:	00 00       	nop
      10:	a6 c2       	rjmp	.+1356   	; 0x55e <__bad_interrupt>
      12:	00 00       	nop
      14:	a4 c2       	rjmp	.+1352   	; 0x55e <__bad_interrupt>
      16:	00 00       	nop
      18:	a2 c2       	rjmp	.+1348   	; 0x55e <__bad_interrupt>
      1a:	00 00       	nop
      1c:	a0 c2       	rjmp	.+1344   	; 0x55e <__bad_interrupt>
      1e:	00 00       	nop
      20:	9e c2       	rjmp	.+1340   	; 0x55e <__bad_interrupt>
      22:	00 00       	nop
      24:	0c 94 aa 30 	jmp	0x6154	; 0x6154 <__vector_9>
      28:	9a c2       	rjmp	.+1332   	; 0x55e <__bad_interrupt>
      2a:	00 00       	nop
      2c:	0c 94 c0 3a 	jmp	0x7580	; 0x7580 <__vector_11>
      30:	0c 94 c7 30 	jmp	0x618e	; 0x618e <__vector_12>
      34:	94 c2       	rjmp	.+1320   	; 0x55e <__bad_interrupt>
      36:	00 00       	nop
      38:	92 c2       	rjmp	.+1316   	; 0x55e <__bad_interrupt>
      3a:	00 00       	nop
      3c:	90 c2       	rjmp	.+1312   	; 0x55e <__bad_interrupt>
      3e:	00 00       	nop
      40:	8e c2       	rjmp	.+1308   	; 0x55e <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 87 19 	jmp	0x330e	; 0x330e <__vector_17>
      48:	8a c2       	rjmp	.+1300   	; 0x55e <__bad_interrupt>
      4a:	00 00       	nop
      4c:	88 c2       	rjmp	.+1296   	; 0x55e <__bad_interrupt>
      4e:	00 00       	nop
      50:	86 c2       	rjmp	.+1292   	; 0x55e <__bad_interrupt>
      52:	00 00       	nop
      54:	84 c2       	rjmp	.+1288   	; 0x55e <__bad_interrupt>
      56:	00 00       	nop
      58:	82 c2       	rjmp	.+1284   	; 0x55e <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0c 94 85 1b 	jmp	0x370a	; 0x370a <__vector_23>
      60:	7e c2       	rjmp	.+1276   	; 0x55e <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 7b 14 	jmp	0x28f6	; 0x28f6 <__vector_25>
      68:	0c 94 3f 14 	jmp	0x287e	; 0x287e <__vector_26>
      6c:	78 c2       	rjmp	.+1264   	; 0x55e <__bad_interrupt>
      6e:	00 00       	nop
      70:	76 c2       	rjmp	.+1260   	; 0x55e <__bad_interrupt>
      72:	00 00       	nop
      74:	74 c2       	rjmp	.+1256   	; 0x55e <__bad_interrupt>
      76:	00 00       	nop
      78:	72 c2       	rjmp	.+1252   	; 0x55e <__bad_interrupt>
      7a:	00 00       	nop
      7c:	70 c2       	rjmp	.+1248   	; 0x55e <__bad_interrupt>
      7e:	00 00       	nop
      80:	6e c2       	rjmp	.+1244   	; 0x55e <__bad_interrupt>
      82:	00 00       	nop
      84:	6c c2       	rjmp	.+1240   	; 0x55e <__bad_interrupt>
      86:	00 00       	nop
      88:	6a c2       	rjmp	.+1236   	; 0x55e <__bad_interrupt>
      8a:	00 00       	nop
      8c:	0c 94 74 3e 	jmp	0x7ce8	; 0x7ce8 <__vector_35>
      90:	66 c2       	rjmp	.+1228   	; 0x55e <__bad_interrupt>
      92:	00 00       	nop
      94:	64 c2       	rjmp	.+1224   	; 0x55e <__bad_interrupt>
      96:	00 00       	nop
      98:	62 c2       	rjmp	.+1220   	; 0x55e <__bad_interrupt>
      9a:	00 00       	nop
      9c:	60 c2       	rjmp	.+1216   	; 0x55e <__bad_interrupt>
      9e:	00 00       	nop
      a0:	5e c2       	rjmp	.+1212   	; 0x55e <__bad_interrupt>
      a2:	00 00       	nop
      a4:	5c c2       	rjmp	.+1208   	; 0x55e <__bad_interrupt>
      a6:	00 00       	nop
      a8:	5a c2       	rjmp	.+1204   	; 0x55e <__bad_interrupt>
      aa:	00 00       	nop
      ac:	58 c2       	rjmp	.+1200   	; 0x55e <__bad_interrupt>
      ae:	00 00       	nop
      b0:	56 c2       	rjmp	.+1196   	; 0x55e <__bad_interrupt>
      b2:	00 00       	nop
      b4:	54 c2       	rjmp	.+1192   	; 0x55e <__bad_interrupt>
      b6:	00 00       	nop
      b8:	52 c2       	rjmp	.+1188   	; 0x55e <__bad_interrupt>
      ba:	00 00       	nop
      bc:	50 c2       	rjmp	.+1184   	; 0x55e <__bad_interrupt>
      be:	00 00       	nop
      c0:	4e c2       	rjmp	.+1180   	; 0x55e <__bad_interrupt>
      c2:	00 00       	nop
      c4:	4c c2       	rjmp	.+1176   	; 0x55e <__bad_interrupt>
      c6:	00 00       	nop
      c8:	4b c2       	rjmp	.+1174   	; 0x560 <__vector_50>
      ca:	00 00       	nop
      cc:	48 c2       	rjmp	.+1168   	; 0x55e <__bad_interrupt>
      ce:	00 00       	nop
      d0:	46 c2       	rjmp	.+1164   	; 0x55e <__bad_interrupt>
      d2:	00 00       	nop
      d4:	44 c2       	rjmp	.+1160   	; 0x55e <__bad_interrupt>
      d6:	00 00       	nop
      d8:	42 c2       	rjmp	.+1156   	; 0x55e <__bad_interrupt>
      da:	00 00       	nop
      dc:	40 c2       	rjmp	.+1152   	; 0x55e <__bad_interrupt>
      de:	00 00       	nop
      e0:	3e c2       	rjmp	.+1148   	; 0x55e <__bad_interrupt>
      e2:	00 00       	nop
      e4:	31 08       	sbc	r3, r1
      e6:	31 08       	sbc	r3, r1
      e8:	31 08       	sbc	r3, r1
      ea:	31 08       	sbc	r3, r1
      ec:	12 08       	sbc	r1, r2
      ee:	a9 11       	cpse	r26, r9
      f0:	a9 11       	cpse	r26, r9
      f2:	a9 11       	cpse	r26, r9
      f4:	a9 11       	cpse	r26, r9
      f6:	a9 11       	cpse	r26, r9
      f8:	06 08       	sbc	r0, r6
      fa:	a9 11       	cpse	r26, r9
      fc:	a9 11       	cpse	r26, r9
      fe:	a9 11       	cpse	r26, r9
     100:	a9 11       	cpse	r26, r9
     102:	a9 11       	cpse	r26, r9
     104:	a9 11       	cpse	r26, r9
     106:	5b 08       	sbc	r5, r11
     108:	5b 08       	sbc	r5, r11
     10a:	5b 08       	sbc	r5, r11
     10c:	7c 08       	sbc	r7, r12
     10e:	7c 08       	sbc	r7, r12
     110:	a9 11       	cpse	r26, r9
     112:	a9 11       	cpse	r26, r9
     114:	a9 11       	cpse	r26, r9
     116:	a9 11       	cpse	r26, r9
     118:	a9 11       	cpse	r26, r9
     11a:	a9 11       	cpse	r26, r9
     11c:	06 08       	sbc	r0, r6
     11e:	a9 11       	cpse	r26, r9
     120:	06 08       	sbc	r0, r6
     122:	a9 11       	cpse	r26, r9
     124:	a9 11       	cpse	r26, r9
     126:	a9 11       	cpse	r26, r9
     128:	a9 11       	cpse	r26, r9
     12a:	a9 11       	cpse	r26, r9
     12c:	a9 11       	cpse	r26, r9
     12e:	a9 11       	cpse	r26, r9
     130:	31 08       	sbc	r3, r1
     132:	a9 11       	cpse	r26, r9
     134:	a7 08       	sbc	r10, r7
     136:	a9 11       	cpse	r26, r9
     138:	a9 11       	cpse	r26, r9
     13a:	82 08       	sbc	r8, r2
     13c:	a9 11       	cpse	r26, r9
     13e:	a9 11       	cpse	r26, r9
     140:	a9 11       	cpse	r26, r9
     142:	a9 11       	cpse	r26, r9
     144:	a9 11       	cpse	r26, r9
     146:	82 08       	sbc	r8, r2
     148:	a9 11       	cpse	r26, r9
     14a:	a9 11       	cpse	r26, r9
     14c:	a9 11       	cpse	r26, r9
     14e:	12 08       	sbc	r1, r2
     150:	9b 08       	sbc	r9, r11
     152:	9b 08       	sbc	r9, r11
     154:	9b 08       	sbc	r9, r11
     156:	9b 08       	sbc	r9, r11
     158:	9b 08       	sbc	r9, r11
     15a:	9b 08       	sbc	r9, r11
     15c:	a9 11       	cpse	r26, r9
     15e:	a1 08       	sbc	r10, r1
     160:	a9 11       	cpse	r26, r9
     162:	a9 11       	cpse	r26, r9
     164:	a9 11       	cpse	r26, r9
     166:	a9 11       	cpse	r26, r9
     168:	a9 11       	cpse	r26, r9
     16a:	a9 11       	cpse	r26, r9
     16c:	a9 11       	cpse	r26, r9
     16e:	a9 11       	cpse	r26, r9
     170:	a9 11       	cpse	r26, r9
     172:	a9 11       	cpse	r26, r9
     174:	a9 11       	cpse	r26, r9
     176:	a9 11       	cpse	r26, r9
     178:	a9 11       	cpse	r26, r9
     17a:	a9 11       	cpse	r26, r9
     17c:	a9 11       	cpse	r26, r9
     17e:	a9 11       	cpse	r26, r9
     180:	a9 11       	cpse	r26, r9
     182:	a9 11       	cpse	r26, r9
     184:	37 08       	sbc	r3, r7
     186:	a9 11       	cpse	r26, r9
     188:	a9 11       	cpse	r26, r9
     18a:	a9 11       	cpse	r26, r9
     18c:	a9 11       	cpse	r26, r9
     18e:	a9 11       	cpse	r26, r9
     190:	a9 11       	cpse	r26, r9
     192:	a9 11       	cpse	r26, r9
     194:	a9 11       	cpse	r26, r9
     196:	a9 11       	cpse	r26, r9
     198:	61 08       	sbc	r6, r1
     19a:	61 08       	sbc	r6, r1
     19c:	06 08       	sbc	r0, r6
     19e:	76 08       	sbc	r7, r6
     1a0:	76 08       	sbc	r7, r6
     1a2:	d2 08       	sbc	r13, r2
     1a4:	d2 08       	sbc	r13, r2
     1a6:	d2 08       	sbc	r13, r2
     1a8:	e1 08       	sbc	r14, r1
     1aa:	e1 08       	sbc	r14, r1
     1ac:	e1 08       	sbc	r14, r1
     1ae:	c3 11       	cpse	r28, r3
     1b0:	f8 08       	sbc	r15, r8
     1b2:	f8 08       	sbc	r15, r8
     1b4:	f8 08       	sbc	r15, r8
     1b6:	c3 11       	cpse	r28, r3
     1b8:	c3 11       	cpse	r28, r3
     1ba:	c3 11       	cpse	r28, r3
     1bc:	c3 11       	cpse	r28, r3
     1be:	c3 11       	cpse	r28, r3
     1c0:	c3 11       	cpse	r28, r3
     1c2:	c3 11       	cpse	r28, r3
     1c4:	c3 11       	cpse	r28, r3
     1c6:	c3 11       	cpse	r28, r3
     1c8:	c3 11       	cpse	r28, r3
     1ca:	c3 11       	cpse	r28, r3
     1cc:	c3 11       	cpse	r28, r3
     1ce:	c3 11       	cpse	r28, r3
     1d0:	c3 11       	cpse	r28, r3
     1d2:	c3 11       	cpse	r28, r3
     1d4:	c3 11       	cpse	r28, r3
     1d6:	c3 11       	cpse	r28, r3
     1d8:	c3 11       	cpse	r28, r3
     1da:	c3 11       	cpse	r28, r3
     1dc:	c3 11       	cpse	r28, r3
     1de:	d2 08       	sbc	r13, r2
     1e0:	38 09       	sbc	r19, r8
     1e2:	c7 11       	cpse	r28, r7
     1e4:	c7 11       	cpse	r28, r7
     1e6:	42 09       	sbc	r20, r2
     1e8:	4f 09       	sbc	r20, r15
     1ea:	5c 09       	sbc	r21, r12
     1ec:	69 09       	sbc	r22, r9
     1ee:	c7 11       	cpse	r28, r7
     1f0:	6d 09       	sbc	r22, r13
     1f2:	c7 11       	cpse	r28, r7
     1f4:	7b 09       	sbc	r23, r11
     1f6:	c7 11       	cpse	r28, r7
     1f8:	85 09       	sbc	r24, r5
     1fa:	8f 09       	sbc	r24, r15
     1fc:	99 09       	sbc	r25, r9
     1fe:	c7 11       	cpse	r28, r7
     200:	c7 11       	cpse	r28, r7
     202:	c7 11       	cpse	r28, r7
     204:	a9 09       	sbc	r26, r9
     206:	b6 09       	sbc	r27, r6
     208:	c3 09       	sbc	r28, r3
     20a:	bc 14       	cp	r11, r12
     20c:	c0 14       	cp	r12, r0
     20e:	c8 14       	cp	r12, r8
     210:	1f 15       	cp	r17, r15
     212:	1f 15       	cp	r17, r15
     214:	1f 15       	cp	r17, r15
     216:	1f 15       	cp	r17, r15
     218:	1f 15       	cp	r17, r15
     21a:	1f 15       	cp	r17, r15
     21c:	1f 15       	cp	r17, r15
     21e:	1f 15       	cp	r17, r15
     220:	1f 15       	cp	r17, r15
     222:	d1 14       	cp	r13, r1
     224:	d5 14       	cp	r13, r5
     226:	d9 14       	cp	r13, r9
     228:	dd 14       	cp	r13, r13
     22a:	e1 14       	cp	r14, r1
     22c:	e5 14       	cp	r14, r5
     22e:	e9 14       	cp	r14, r9
     230:	ed 14       	cp	r14, r13
     232:	1f 15       	cp	r17, r15
     234:	f1 14       	cp	r15, r1
     236:	f5 14       	cp	r15, r5
     238:	f9 14       	cp	r15, r9
     23a:	fd 14       	cp	r15, r13
     23c:	01 15       	cp	r16, r1
     23e:	05 15       	cp	r16, r5
     240:	1f 15       	cp	r17, r15
     242:	09 15       	cp	r16, r9
     244:	0d 15       	cp	r16, r13
     246:	8b 26       	eor	r8, r27
     248:	91 26       	eor	r9, r17
     24a:	94 26       	eor	r9, r20
     24c:	99 26       	eor	r9, r25
     24e:	9e 26       	eor	r9, r30
     250:	ac 26       	eor	r10, r28
     252:	ba 26       	eor	r11, r26
     254:	6d 27       	eor	r22, r29
     256:	6d 27       	eor	r22, r29
     258:	6d 27       	eor	r22, r29
     25a:	cb 26       	eor	r12, r27
     25c:	ce 26       	eor	r12, r30
     25e:	d7 26       	eor	r13, r23
     260:	e0 26       	eor	r14, r16
     262:	6d 27       	eor	r22, r29
     264:	6d 27       	eor	r22, r29
     266:	6d 27       	eor	r22, r29
     268:	6d 27       	eor	r22, r29
     26a:	6d 27       	eor	r22, r29
     26c:	6d 27       	eor	r22, r29
     26e:	f0 26       	eor	r15, r16
     270:	00 27       	eor	r16, r16
     272:	10 27       	eor	r17, r16
     274:	1e 27       	eor	r17, r30
     276:	21 27       	eor	r18, r17
     278:	2a 27       	eor	r18, r26
     27a:	33 27       	eor	r19, r19
     27c:	3a 27       	eor	r19, r26
     27e:	6d 27       	eor	r22, r29
     280:	6d 27       	eor	r22, r29
     282:	43 27       	eor	r20, r19
     284:	4e 27       	eor	r20, r30
     286:	59 27       	eor	r21, r25
     288:	e7 35       	cpi	r30, 0x57	; 87
     28a:	eb 35       	cpi	r30, 0x5B	; 91
     28c:	ef 35       	cpi	r30, 0x5F	; 95
     28e:	f3 35       	cpi	r31, 0x53	; 83
     290:	f7 35       	cpi	r31, 0x57	; 87
     292:	fb 35       	cpi	r31, 0x5B	; 91
     294:	ff 35       	cpi	r31, 0x5F	; 95
     296:	03 36       	cpi	r16, 0x63	; 99
     298:	07 36       	cpi	r16, 0x67	; 103
     29a:	0b 36       	cpi	r16, 0x6B	; 107
     29c:	0f 36       	cpi	r16, 0x6F	; 111
     29e:	08 4a       	sbci	r16, 0xA8	; 168
     2a0:	d7 3b       	cpi	r29, 0xB7	; 183
     2a2:	3b ce       	rjmp	.-906    	; 0xffffff1a <__eeprom_end+0xff7eff1a>
     2a4:	01 6e       	ori	r16, 0xE1	; 225
     2a6:	84 bc       	out	0x24, r8	; 36
     2a8:	bf fd       	.word	0xfdbf	; ????
     2aa:	c1 2f       	mov	r28, r17
     2ac:	3d 6c       	ori	r19, 0xCD	; 205
     2ae:	74 31       	cpi	r23, 0x14	; 20
     2b0:	9a bd       	out	0x2a, r25	; 42
     2b2:	56 83       	std	Z+6, r21	; 0x06
     2b4:	3d da       	rcall	.-2950   	; 0xfffff730 <__eeprom_end+0xff7ef730>
     2b6:	3d 00       	.word	0x003d	; ????
     2b8:	c7 7f       	andi	r28, 0xF7	; 247
     2ba:	11 be       	out	0x31, r1	; 49
     2bc:	d9 e4       	ldi	r29, 0x49	; 73
     2be:	bb 4c       	sbci	r27, 0xCB	; 203
     2c0:	3e 91       	ld	r19, -X
     2c2:	6b aa       	std	Y+51, r6	; 0x33
     2c4:	aa be       	out	0x3a, r10	; 58
     2c6:	00 00       	nop
     2c8:	00 80       	ld	r0, Z
     2ca:	3f 05       	cpc	r19, r15
     2cc:	a8 4c       	sbci	r26, 0xC8	; 200
     2ce:	cd b2       	in	r12, 0x1d	; 29
     2d0:	d4 4e       	sbci	r29, 0xE4	; 228
     2d2:	b9 38       	cpi	r27, 0x89	; 137
     2d4:	36 a9       	ldd	r19, Z+54	; 0x36
     2d6:	02 0c       	add	r0, r2
     2d8:	50 b9       	out	0x00, r21	; 0
     2da:	91 86       	std	Z+9, r9	; 0x09
     2dc:	88 08       	sbc	r8, r8
     2de:	3c a6       	std	Y+44, r3	; 0x2c
     2e0:	aa aa       	std	Y+50, r10	; 0x32
     2e2:	2a be       	out	0x3a, r2	; 58
     2e4:	00 00       	nop
     2e6:	00 80       	ld	r0, Z
     2e8:	3f 00       	.word	0x003f	; ????

000002ea <__trampolines_end>:
     2ea:	00 00       	nop
     2ec:	7a 43       	sbci	r23, 0x3A	; 58
     2ee:	00 00       	nop
     2f0:	7a 43       	sbci	r23, 0x3A	; 58
     2f2:	00 00       	nop
     2f4:	7a 43       	sbci	r23, 0x3A	; 58
     2f6:	00 00       	nop
     2f8:	fa 43       	sbci	r31, 0x3A	; 58
     2fa:	00 00       	nop
     2fc:	fa 43       	sbci	r31, 0x3A	; 58
     2fe:	00 00       	nop
     300:	fa 43       	sbci	r31, 0x3A	; 58
     302:	00 a0       	ldd	r0, Z+32	; 0x20
     304:	0c 47       	sbci	r16, 0x7C	; 124
     306:	00 a0       	ldd	r0, Z+32	; 0x20
     308:	0c 47       	sbci	r16, 0x7C	; 124
     30a:	00 a0       	ldd	r0, Z+32	; 0x20
     30c:	0c 47       	sbci	r16, 0x7C	; 124
     30e:	00 00       	nop
     310:	48 c3       	rjmp	.+1680   	; 0x9a2 <mc_arc+0x252>
     312:	00 00       	nop
     314:	48 c3       	rjmp	.+1680   	; 0x9a6 <mc_arc+0x256>
     316:	00 00       	nop
     318:	48 c3       	rjmp	.+1680   	; 0x9aa <mc_arc+0x25a>
     31a:	0a 00       	.word	0x000a	; ????
     31c:	00 19       	sub	r16, r0
     31e:	01 0a       	sbc	r0, r17
     320:	d7 23       	and	r29, r23
     322:	3c 6f       	ori	r19, 0xFC	; 252
     324:	12 03       	mulsu	r17, r18
     326:	3b 00       	.word	0x003b	; ????
     328:	00 7a       	andi	r16, 0xA0	; 160
     32a:	44 00       	.word	0x0044	; ????
     32c:	00 00       	nop
     32e:	00 00       	nop
     330:	00 00       	nop
     332:	00 c8       	rjmp	.-4096   	; 0xfffff334 <__eeprom_end+0xff7ef334>
     334:	41 00       	.word	0x0041	; ????
     336:	00 fa       	bst	r0, 0
     338:	43 fa       	bst	r4, 3
     33a:	00 00       	nop
     33c:	00 80       	ld	r0, Z
     33e:	3f 7c       	Address 0x0000033e is out of bounds.
.word	0xffff	; ????

0000033f <__c.2811>:
     33f:	7c 53 69 3a 00                                      |Si:.

00000344 <__c.2809>:
     344:	7c 53 70 3a 00                                      |Sp:.

00000349 <__c.2807>:
     349:	7c 41 3a 00                                         |A:.

0000034d <__c.2803>:
     34d:	7c 4f 76 3a 00                                      |Ov:.

00000352 <__c.2801>:
     352:	7c 57 43 4f 3a 00                                   |WCO:.

00000358 <__c.2799>:
     358:	7c 50 6e 3a 00                                      |Pn:.

0000035d <__c.2794>:
     35d:	7c 46 53 3a 00                                      |FS:.

00000362 <__c.2792>:
     362:	7c 4c 6e 3a 00                                      |Ln:.

00000367 <__c.2788>:
     367:	7c 42 66 3a 00                                      |Bf:.

0000036c <__c.2786>:
     36c:	7c 57 50 6f 73 3a 00                                |WPos:.

00000373 <__c.2784>:
     373:	7c 4d 50 6f 73 3a 00                                |MPos:.

0000037a <__c.2778>:
     37a:	53 6c 65 65 70 00                                   Sleep.

00000380 <__c.2775>:
     380:	44 6f 6f 72 3a 00                                   Door:.

00000386 <__c.2772>:
     386:	43 68 65 63 6b 00                                   Check.

0000038c <__c.2769>:
     38c:	41 6c 61 72 6d 00                                   Alarm.

00000392 <__c.2766>:
     392:	48 6f 6d 65 00                                      Home.

00000397 <__c.2763>:
     397:	4a 6f 67 00                                         Jog.

0000039b <__c.2760>:
     39b:	48 6f 6c 64 3a 00                                   Hold:.

000003a1 <__c.2757>:
     3a1:	52 75 6e 00                                         Run.

000003a5 <__c.2753>:
     3a5:	49 64 6c 65 00                                      Idle.

000003aa <__c.2740>:
     3aa:	5b 4f 50 54 3a 00                                   [OPT:.

000003b0 <__c.2738>:
     3b0:	5b 56 45 52 3a 31 2e 31 67 2e 32 30 31 38 30 38     [VER:1.1g.201808
     3c0:	31 33 2e 4d 65 67 61 3a 00                          13.Mega:.

000003c9 <__c.2729>:
     3c9:	24 4e 00                                            $N.

000003cc <__c.2570>:
     3cc:	20 4d 00                                             M.

000003cf <__c.2566>:
     3cf:	20 47 00                                             G.

000003d2 <__c.2723>:
     3d2:	20 53 00                                             S.

000003d5 <__c.2721>:
     3d5:	20 46 00                                             F.

000003d8 <__c.2719>:
     3d8:	20 54 00                                             T.

000003db <__c.2709>:
     3db:	33 38 2e 00                                         38..

000003df <__c.2707>:
     3df:	5b 47 43 3a 47 00                                   [GC:G.

000003e5 <__c.2703>:
     3e5:	5b 54 4c 4f 3a 00                                   [TLO:.

000003eb <__c.2701>:
     3eb:	5b 47 39 32 3a 00                                   [G92:.

000003f1 <__c.2695>:
     3f1:	33 30 00                                            30.

000003f4 <__c.2691>:
     3f4:	32 38 00                                            28.

000003f7 <__c.2688>:
     3f7:	5b 47 00                                            [G.

000003fa <__c.2681>:
     3fa:	5b 50 52 42 3a 00                                   [PRB:.

00000400 <__c.2661>:
     400:	5b 48 4c 50 3a 24 24 20 24 23 20 24 47 20 24 49     [HLP:$$ $# $G $I
     410:	20 24 4e 20 24 78 3d 76 61 6c 20 24 4e 78 3d 6c      $N $x=val $Nx=l
     420:	69 6e 65 20 24 4a 3d 6c 69 6e 65 20 24 53 4c 50     ine $J=line $SLP
     430:	20 24 43 20 24 58 20 24 48 20 7e 20 21 20 3f 20      $C $X $H ~ ! ? 
     440:	63 74 72 6c 2d 78 5d 0d 0a 00                       ctrl-x]...

0000044a <__c.2657>:
     44a:	0d 0a 47 72 62 6c 20 31 2e 31 67 20 5b 27 24 27     ..Grbl 1.1g ['$'
     45a:	20 66 6f 72 20 68 65 6c 70 5d 0d 0a 00               for help]...

00000467 <__c.2653>:
     467:	53 6c 65 65 70 69 6e 67 00                          Sleeping.

00000470 <__c.2650>:
     470:	52 65 73 74 6f 72 69 6e 67 20 73 70 69 6e 64 6c     Restoring spindl
     480:	65 00                                               e.

00000482 <__c.2647>:
     482:	52 65 73 74 6f 72 69 6e 67 20 64 65 66 61 75 6c     Restoring defaul
     492:	74 73 00                                            ts.

00000495 <__c.2644>:
     495:	50 67 6d 20 45 6e 64 00                             Pgm End.

0000049d <__c.2641>:
     49d:	43 68 65 63 6b 20 4c 69 6d 69 74 73 00              Check Limits.

000004aa <__c.2638>:
     4aa:	43 68 65 63 6b 20 44 6f 6f 72 00                    Check Door.

000004b5 <__c.2635>:
     4b5:	44 69 73 61 62 6c 65 64 00                          Disabled.

000004be <__c.2632>:
     4be:	45 6e 61 62 6c 65 64 00                             Enabled.

000004c6 <__c.2629>:
     4c6:	43 61 75 74 69 6f 6e 3a 20 55 6e 6c 6f 63 6b 65     Caution: Unlocke
     4d6:	64 00                                               d.

000004d8 <__c.2626>:
     4d8:	27 24 48 27 7c 27 24 58 27 20 74 6f 20 75 6e 6c     '$H'|'$X' to unl
     4e8:	6f 63 6b 00                                         ock.

000004ec <__c.2622>:
     4ec:	52 65 73 65 74 20 74 6f 20 63 6f 6e 74 69 6e 75     Reset to continu
     4fc:	65 00                                               e.

000004fe <__c.2619>:
     4fe:	5b 4d 53 47 3a 00                                   [MSG:.

00000504 <__c.2614>:
     504:	7c 52 50 4d 3a 20 00                                |RPM: .

0000050b <__c.2612>:
     50b:	7c 53 70 3a 20 00                                   |Sp: .

00000511 <__c.2610>:
     511:	7c 53 74 3a 20 00                                   |St: .

00000517 <__c.2608>:
     517:	7c 53 73 3a 20 00                                   |Ss: .

0000051d <__c.2606>:
     51d:	53 69 3a 20 00                                      Si: .

00000522 <__c.2601>:
     522:	41 4c 41 52 4d 3a 00                                ALARM:.

00000529 <__c.2560>:
     529:	0d 0a 00                                            ...

0000052c <__c.2596>:
     52c:	65 72 72 6f 72 3a 00                                error:.

00000533 <__c.2592>:
     533:	6f 6b 0d 0a 00                                      ok...

00000538 <__ctors_end>:
     538:	11 24       	eor	r1, r1
     53a:	1f be       	out	0x3f, r1	; 63
     53c:	cf ef       	ldi	r28, 0xFF	; 255
     53e:	d1 e2       	ldi	r29, 0x21	; 33
     540:	de bf       	out	0x3e, r29	; 62
     542:	cd bf       	out	0x3d, r28	; 61
     544:	00 e0       	ldi	r16, 0x00	; 0
     546:	0c bf       	out	0x3c, r16	; 60

00000548 <__do_clear_bss>:
     548:	2f e0       	ldi	r18, 0x0F	; 15
     54a:	a0 e0       	ldi	r26, 0x00	; 0
     54c:	b2 e0       	ldi	r27, 0x02	; 2
     54e:	01 c0       	rjmp	.+2      	; 0x552 <.do_clear_bss_start>

00000550 <.do_clear_bss_loop>:
     550:	1d 92       	st	X+, r1

00000552 <.do_clear_bss_start>:
     552:	a7 32       	cpi	r26, 0x27	; 39
     554:	b2 07       	cpc	r27, r18
     556:	e1 f7       	brne	.-8      	; 0x550 <.do_clear_bss_loop>
     558:	5d d0       	rcall	.+186    	; 0x614 <main>
     55a:	0c 94 11 43 	jmp	0x8622	; 0x8622 <_exit>

0000055e <__bad_interrupt>:
     55e:	50 cd       	rjmp	.-1376   	; 0x0 <__vectors>

00000560 <__vector_50>:
#include "timekeeper.h"

uint32_t overflows;

// overflow interrupt for timekeeper - counts timer ticks beyond 16 bits
ISR(TIMER5_OVF_vect) {
     560:	1f 92       	push	r1
     562:	0f 92       	push	r0
     564:	0f b6       	in	r0, 0x3f	; 63
     566:	0f 92       	push	r0
     568:	11 24       	eor	r1, r1
     56a:	8f 93       	push	r24
     56c:	9f 93       	push	r25
     56e:	af 93       	push	r26
     570:	bf 93       	push	r27
	overflows++;
     572:	80 91 10 0c 	lds	r24, 0x0C10	; 0x800c10 <overflows>
     576:	90 91 11 0c 	lds	r25, 0x0C11	; 0x800c11 <overflows+0x1>
     57a:	a0 91 12 0c 	lds	r26, 0x0C12	; 0x800c12 <overflows+0x2>
     57e:	b0 91 13 0c 	lds	r27, 0x0C13	; 0x800c13 <overflows+0x3>
     582:	01 96       	adiw	r24, 0x01	; 1
     584:	a1 1d       	adc	r26, r1
     586:	b1 1d       	adc	r27, r1
     588:	80 93 10 0c 	sts	0x0C10, r24	; 0x800c10 <overflows>
     58c:	90 93 11 0c 	sts	0x0C11, r25	; 0x800c11 <overflows+0x1>
     590:	a0 93 12 0c 	sts	0x0C12, r26	; 0x800c12 <overflows+0x2>
     594:	b0 93 13 0c 	sts	0x0C13, r27	; 0x800c13 <overflows+0x3>
}
     598:	bf 91       	pop	r27
     59a:	af 91       	pop	r26
     59c:	9f 91       	pop	r25
     59e:	8f 91       	pop	r24
     5a0:	0f 90       	pop	r0
     5a2:	0f be       	out	0x3f, r0	; 63
     5a4:	0f 90       	pop	r0
     5a6:	1f 90       	pop	r1
     5a8:	18 95       	reti

000005aa <timekeeper_reset>:
  timekeeper_reset();
}

void timekeeper_reset()
{
  overflows = 0;
     5aa:	10 92 10 0c 	sts	0x0C10, r1	; 0x800c10 <overflows>
     5ae:	10 92 11 0c 	sts	0x0C11, r1	; 0x800c11 <overflows+0x1>
     5b2:	10 92 12 0c 	sts	0x0C12, r1	; 0x800c12 <overflows+0x2>
     5b6:	10 92 13 0c 	sts	0x0C13, r1	; 0x800c13 <overflows+0x3>
  TCNT5=0;		
     5ba:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <__TEXT_REGION_LENGTH__+0x700125>
     5be:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
     5c2:	08 95       	ret

000005c4 <timekeeper_init>:

void timekeeper_init() {
  // Configure Timer 5: system timer interrupt
  //TCCR5B &= ~(1<<WGM13); // waveform generation = 0100 = CTC
  //TCCR5B |=  (1<<WGM12);
  TCCR5A =0; // timer outputs disconnected, no waveform generation.
     5c4:	e0 e2       	ldi	r30, 0x20	; 32
     5c6:	f1 e0       	ldi	r31, 0x01	; 1
     5c8:	10 82       	st	Z, r1
  TCCR5A &= ~((1<<COM5A1) | (1<<COM5A0) | (1<<COM5B1) | (1<<COM5B0)); // Disconnect OC1 output
     5ca:	80 81       	ld	r24, Z
     5cc:	8f 70       	andi	r24, 0x0F	; 15
     5ce:	80 83       	st	Z, r24
  TCCR5B |=  (1<<CS11) | (1<<CS10); // pre-scaler: 1/64 (4 microseconds per tick @ 16MHz)
     5d0:	e1 e2       	ldi	r30, 0x21	; 33
     5d2:	f1 e0       	ldi	r31, 0x01	; 1
     5d4:	80 81       	ld	r24, Z
     5d6:	83 60       	ori	r24, 0x03	; 3
     5d8:	80 83       	st	Z, r24
  TIMSK5 |=  (1<<TOIE5); // enable overflow interrupt  
     5da:	e3 e7       	ldi	r30, 0x73	; 115
     5dc:	f0 e0       	ldi	r31, 0x00	; 0
     5de:	80 81       	ld	r24, Z
     5e0:	81 60       	ori	r24, 0x01	; 1
     5e2:	80 83       	st	Z, r24
  timekeeper_reset();
     5e4:	e2 cf       	rjmp	.-60     	; 0x5aa <timekeeper_reset>
     5e6:	08 95       	ret

000005e8 <get_timer_ticks>:
	// each timer tick are 4 microseconds
	return (get_timer_ticks()/(uint32_t)250);
}

uint32_t get_timer_ticks(){
	uint32_t ticks = TCNT5;
     5e8:	20 91 24 01 	lds	r18, 0x0124	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
     5ec:	30 91 25 01 	lds	r19, 0x0125	; 0x800125 <__TEXT_REGION_LENGTH__+0x700125>
	return ticks+((overflows)<<16) ;
     5f0:	80 91 10 0c 	lds	r24, 0x0C10	; 0x800c10 <overflows>
     5f4:	90 91 11 0c 	lds	r25, 0x0C11	; 0x800c11 <overflows+0x1>
     5f8:	a0 91 12 0c 	lds	r26, 0x0C12	; 0x800c12 <overflows+0x2>
     5fc:	b0 91 13 0c 	lds	r27, 0x0C13	; 0x800c13 <overflows+0x3>
     600:	dc 01       	movw	r26, r24
     602:	99 27       	eor	r25, r25
     604:	88 27       	eor	r24, r24
     606:	bc 01       	movw	r22, r24
     608:	cd 01       	movw	r24, r26
     60a:	62 0f       	add	r22, r18
     60c:	73 1f       	adc	r23, r19
     60e:	81 1d       	adc	r24, r1
     610:	91 1d       	adc	r25, r1
}
     612:	08 95       	ret

00000614 <main>:


int main(void)
{
  // Initialize system upon power-up.
  serial_init();   // Setup serial baud rate and interrupts
     614:	0e 94 16 14 	call	0x282c	; 0x282c <serial_init>
  settings_init(); // Load Grbl settings from EEPROM
     618:	0e 94 c8 27 	call	0x4f90	; 0x4f90 <settings_init>
  stepper_init();  // Configure stepper pins and interrupt timers
     61c:	0e 94 0c 1c 	call	0x3818	; 0x3818 <stepper_init>
  system_init();   // Configure pinout pins and pin-change interrupt
     620:	0e 94 95 3a 	call	0x752a	; 0x752a <system_init>

  memset(sys_position,0,sizeof(sys_position)); // Clear machine position.
     624:	8c e0       	ldi	r24, 0x0C	; 12
     626:	e3 e4       	ldi	r30, 0x43	; 67
     628:	fc e0       	ldi	r31, 0x0C	; 12
     62a:	df 01       	movw	r26, r30
     62c:	1d 92       	st	X+, r1
     62e:	8a 95       	dec	r24
     630:	e9 f7       	brne	.-6      	; 0x62c <main+0x18>
  sei(); // Enable interrupts
     632:	78 94       	sei
  // Initialize system state.
  #ifdef FORCE_INITIALIZATION_ALARM
    // Force Grbl into an ALARM state upon a power-cycle or hard reset.
    sys.state = STATE_ALARM;
  #else
    sys.state = STATE_IDLE;
     634:	10 92 1e 0c 	sts	0x0C1E, r1	; 0x800c1e <sys>
  // Grbl initialization loop upon power-up or a system abort. For the latter, all processes
  // will return to this loop to be cleanly re-initialized.
  for(;;) {

    // Reset system variables.
    uint8_t prior_state = sys.state;
     638:	ce e1       	ldi	r28, 0x1E	; 30
     63a:	dc e0       	ldi	r29, 0x0C	; 12
    memset(&sys, 0, sizeof(system_t)); // Clear system struct variable.
     63c:	0f 2e       	mov	r0, r31
     63e:	f2 e1       	ldi	r31, 0x12	; 18
     640:	df 2e       	mov	r13, r31
     642:	f0 2d       	mov	r31, r0
    sys.state = prior_state;
    sys.f_override = DEFAULT_FEED_OVERRIDE;  // Set to 100%
     644:	14 e6       	ldi	r17, 0x64	; 100
    sys.r_override = DEFAULT_RAPID_OVERRIDE; // Set to 100%
    sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE; // Set to 100%
		memset(sys_probe_position,0,sizeof(sys_probe_position)); // Clear probe position.
     646:	0f 2e       	mov	r0, r31
     648:	f7 e3       	ldi	r31, 0x37	; 55
     64a:	ef 2e       	mov	r14, r31
     64c:	fc e0       	ldi	r31, 0x0C	; 12
     64e:	ff 2e       	mov	r15, r31
     650:	f0 2d       	mov	r31, r0
     652:	0c e0       	ldi	r16, 0x0C	; 12
  // Grbl initialization loop upon power-up or a system abort. For the latter, all processes
  // will return to this loop to be cleanly re-initialized.
  for(;;) {

    // Reset system variables.
    uint8_t prior_state = sys.state;
     654:	88 81       	ld	r24, Y
    memset(&sys, 0, sizeof(system_t)); // Clear system struct variable.
     656:	fe 01       	movw	r30, r28
     658:	9d 2d       	mov	r25, r13
     65a:	11 92       	st	Z+, r1
     65c:	9a 95       	dec	r25
     65e:	e9 f7       	brne	.-6      	; 0x65a <main+0x46>
    sys.state = prior_state;
     660:	88 83       	st	Y, r24
    sys.f_override = DEFAULT_FEED_OVERRIDE;  // Set to 100%
     662:	1f 83       	std	Y+7, r17	; 0x07
    sys.r_override = DEFAULT_RAPID_OVERRIDE; // Set to 100%
     664:	18 87       	std	Y+8, r17	; 0x08
    sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE; // Set to 100%
     666:	19 87       	std	Y+9, r17	; 0x09
		memset(sys_probe_position,0,sizeof(sys_probe_position)); // Clear probe position.
     668:	d7 01       	movw	r26, r14
     66a:	e0 2f       	mov	r30, r16
     66c:	1d 92       	st	X+, r1
     66e:	ea 95       	dec	r30
     670:	e9 f7       	brne	.-6      	; 0x66c <main+0x58>
    sys_probe_state = 0;
     672:	10 92 32 0c 	sts	0x0C32, r1	; 0x800c32 <sys_probe_state>
    sys_rt_exec_state = 0;
     676:	10 92 31 0c 	sts	0x0C31, r1	; 0x800c31 <sys_rt_exec_state>
    sys_rt_exec_alarm = 0;
     67a:	10 92 53 0c 	sts	0x0C53, r1	; 0x800c53 <sys_rt_exec_alarm>
    sys_rt_exec_motion_override = 0;
     67e:	10 92 19 0c 	sts	0x0C19, r1	; 0x800c19 <sys_rt_exec_motion_override>
    sys_rt_exec_accessory_override = 0;
     682:	10 92 30 0c 	sts	0x0C30, r1	; 0x800c30 <sys_rt_exec_accessory_override>
	
	sys_index_pulse_count=0;
     686:	10 92 55 0c 	sts	0x0C55, r1	; 0x800c55 <sys_index_pulse_count>
	sys_synchronization_pulse_count=0;
     68a:	10 92 15 0c 	sts	0x0C15, r1	; 0x800c15 <sys_synchronization_pulse_count>
     68e:	10 92 16 0c 	sts	0x0C16, r1	; 0x800c16 <sys_synchronization_pulse_count+0x1>
     692:	10 92 17 0c 	sts	0x0C17, r1	; 0x800c17 <sys_synchronization_pulse_count+0x2>
     696:	10 92 18 0c 	sts	0x0C18, r1	; 0x800c18 <sys_synchronization_pulse_count+0x3>

    // Reset Grbl primary systems.
    serial_reset_read_buffer(); // Clear serial read buffer
     69a:	0e 94 32 15 	call	0x2a64	; 0x2a64 <serial_reset_read_buffer>
    gc_init(); // Set g-code parser to default state
     69e:	03 d4       	rcall	.+2054   	; 0xea6 <gc_init>
    spindle_init();
     6a0:	0e 94 91 12 	call	0x2522	; 0x2522 <spindle_init>
	timekeeper_init();
     6a4:	8f df       	rcall	.-226    	; 0x5c4 <timekeeper_init>
    coolant_init();
     6a6:	0e 94 d3 13 	call	0x27a6	; 0x27a6 <coolant_init>
    limits_init();
     6aa:	0e 94 46 30 	call	0x608c	; 0x608c <limits_init>
    probe_init();
     6ae:	0e 94 ef 34 	call	0x69de	; 0x69de <probe_init>
    sleep_init();
     6b2:	0e 94 62 3e 	call	0x7cc4	; 0x7cc4 <sleep_init>
    plan_reset(); // Clear block buffer and planner variables
     6b6:	0e 94 61 29 	call	0x52c2	; 0x52c2 <plan_reset>
    st_reset(); // Clear stepper subsystem variables.
     6ba:	0e 94 db 1b 	call	0x37b6	; 0x37b6 <st_reset>

    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
     6be:	0e 94 09 2e 	call	0x5c12	; 0x5c12 <plan_sync_position>
    gc_sync_position();
     6c2:	03 d4       	rcall	.+2054   	; 0xeca <gc_sync_position>

    // Print welcome message. Indicates an initialization has occured at power-up or with a reset.
    report_init_message();
     6c4:	0e 94 15 36 	call	0x6c2a	; 0x6c2a <report_init_message>

    // Start Grbl main loop. Processes program inputs and executes them.
    protocol_main_loop();
     6c8:	0e 94 7b 18 	call	0x30f6	; 0x30f6 <protocol_main_loop>
     6cc:	c3 cf       	rjmp	.-122    	; 0x654 <main+0x40>

000006ce <mc_line>:
// NOTE: This is the primary gateway to the grbl planner. All line motions, including arc line
// segments, must pass through this routine before being passed to the planner. The seperation of
// mc_line and plan_buffer_line is done primarily to place non-planner-type functions from being
// in the planner and to let backlash compensation or canned cycle integration simple and direct.
void mc_line(float *target, plan_line_data_t *pl_data)
{
     6ce:	ef 92       	push	r14
     6d0:	ff 92       	push	r15
     6d2:	0f 93       	push	r16
     6d4:	1f 93       	push	r17
     6d6:	cf 93       	push	r28
     6d8:	df 93       	push	r29
     6da:	8c 01       	movw	r16, r24
     6dc:	7b 01       	movw	r14, r22
  // If enabled, check for soft limit violations. Placed here all line motions are picked up
  // from everywhere in Grbl.
  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
     6de:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
     6e2:	85 ff       	sbrs	r24, 5
     6e4:	07 c0       	rjmp	.+14     	; 0x6f4 <mc_line+0x26>
    // NOTE: Block jog state. Jogging is a special case and soft limits are handled independently.
    if (sys.state != STATE_JOG) { limits_soft_check(target); }
     6e6:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
     6ea:	80 32       	cpi	r24, 0x20	; 32
     6ec:	39 f0       	breq	.+14     	; 0x6fc <mc_line+0x2e>
     6ee:	c8 01       	movw	r24, r16
     6f0:	0e 94 1a 33 	call	0x6634	; 0x6634 <limits_soft_check>
  }

  // If in check gcode mode, prevent motion by blocking planner. Soft limits still work.
  if (sys.state == STATE_CHECK_MODE) { return; }
     6f4:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
     6f8:	82 30       	cpi	r24, 0x02	; 2
     6fa:	19 f1       	breq	.+70     	; 0x742 <mc_line+0x74>

  // If the buffer is full: good! That means we are well ahead of the robot.
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
    if (sys.abort) { return; } // Bail, if system abort.
     6fc:	ce e1       	ldi	r28, 0x1E	; 30
     6fe:	dc e0       	ldi	r29, 0x0C	; 12
  // parser and planner are separate from the system machine positions, this is doable.

  // If the buffer is full: good! That means we are well ahead of the robot.
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
     700:	0e 94 66 17 	call	0x2ecc	; 0x2ecc <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail, if system abort.
     704:	89 81       	ldd	r24, Y+1	; 0x01
     706:	81 11       	cpse	r24, r1
     708:	1c c0       	rjmp	.+56     	; 0x742 <mc_line+0x74>
    if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffer is full.
     70a:	0e 94 b0 29 	call	0x5360	; 0x5360 <plan_check_full_buffer>
     70e:	88 23       	and	r24, r24
     710:	19 f0       	breq	.+6      	; 0x718 <mc_line+0x4a>
     712:	0e 94 37 15 	call	0x2a6e	; 0x2a6e <protocol_auto_cycle_start>
    else { break; }
  } while (1);
     716:	f4 cf       	rjmp	.-24     	; 0x700 <mc_line+0x32>

  // Plan and queue motion into planner buffer
  if (plan_buffer_line(target, pl_data) == PLAN_EMPTY_BLOCK) {
     718:	b7 01       	movw	r22, r14
     71a:	c8 01       	movw	r24, r16
     71c:	0e 94 ee 2a 	call	0x55dc	; 0x55dc <plan_buffer_line>
     720:	81 11       	cpse	r24, r1
     722:	0f c0       	rjmp	.+30     	; 0x742 <mc_line+0x74>
    if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
     724:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
     728:	81 ff       	sbrs	r24, 1
     72a:	0b c0       	rjmp	.+22     	; 0x742 <mc_line+0x74>
      // Correctly set spindle state, if there is a coincident position passed. Forces a buffer
      // sync while in M3 laser mode only.
      if (pl_data->condition & PL_COND_FLAG_SPINDLE_CW) {
     72c:	f7 01       	movw	r30, r14
     72e:	84 85       	ldd	r24, Z+12	; 0x0c
     730:	84 ff       	sbrs	r24, 4
     732:	07 c0       	rjmp	.+14     	; 0x742 <mc_line+0x74>
        spindle_sync(PL_COND_FLAG_SPINDLE_CW, pl_data->spindle_speed);
     734:	44 81       	ldd	r20, Z+4	; 0x04
     736:	55 81       	ldd	r21, Z+5	; 0x05
     738:	66 81       	ldd	r22, Z+6	; 0x06
     73a:	77 81       	ldd	r23, Z+7	; 0x07
     73c:	80 e1       	ldi	r24, 0x10	; 16
     73e:	0e 94 a7 13 	call	0x274e	; 0x274e <spindle_sync>
      }
    }
  }
}
     742:	df 91       	pop	r29
     744:	cf 91       	pop	r28
     746:	1f 91       	pop	r17
     748:	0f 91       	pop	r16
     74a:	ff 90       	pop	r15
     74c:	ef 90       	pop	r14
     74e:	08 95       	ret

00000750 <mc_arc>:
// The arc is approximated by generating a huge number of tiny, linear segments. The chordal tolerance
// of each segment is configured in settings.arc_tolerance, which is defined to be the maximum normal
// distance from segment to the circle when the end points both lie on the circle.
void mc_arc(float *target, plan_line_data_t *pl_data, float *position, float *offset, float radius,
  uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc)
{
     750:	2f 92       	push	r2
     752:	3f 92       	push	r3
     754:	4f 92       	push	r4
     756:	5f 92       	push	r5
     758:	6f 92       	push	r6
     75a:	7f 92       	push	r7
     75c:	8f 92       	push	r8
     75e:	9f 92       	push	r9
     760:	af 92       	push	r10
     762:	bf 92       	push	r11
     764:	cf 92       	push	r12
     766:	df 92       	push	r13
     768:	ef 92       	push	r14
     76a:	ff 92       	push	r15
     76c:	0f 93       	push	r16
     76e:	1f 93       	push	r17
     770:	cf 93       	push	r28
     772:	df 93       	push	r29
     774:	cd b7       	in	r28, 0x3d	; 61
     776:	de b7       	in	r29, 0x3e	; 62
     778:	e2 97       	sbiw	r28, 0x32	; 50
     77a:	0f b6       	in	r0, 0x3f	; 63
     77c:	f8 94       	cli
     77e:	de bf       	out	0x3e, r29	; 62
     780:	0f be       	out	0x3f, r0	; 63
     782:	cd bf       	out	0x3d, r28	; 61
     784:	9a ab       	std	Y+50, r25	; 0x32
     786:	89 ab       	std	Y+49, r24	; 0x31
     788:	78 8b       	std	Y+16, r23	; 0x10
     78a:	6f 87       	std	Y+15, r22	; 0x0f
     78c:	5e 87       	std	Y+14, r21	; 0x0e
     78e:	4d 87       	std	Y+13, r20	; 0x0d
     790:	39 01       	movw	r6, r18
     792:	ed 82       	std	Y+5, r14	; 0x05
     794:	fe 82       	std	Y+6, r15	; 0x06
     796:	0f 83       	std	Y+7, r16	; 0x07
     798:	18 87       	std	Y+8, r17	; 0x08
     79a:	89 8a       	std	Y+17, r8	; 0x11
  float center_axis0 = position[axis_0] + offset[axis_0];
     79c:	d1 2c       	mov	r13, r1
     79e:	cc 0c       	add	r12, r12
     7a0:	dd 1c       	adc	r13, r13
     7a2:	cc 0c       	add	r12, r12
     7a4:	dd 1c       	adc	r13, r13
     7a6:	ca 01       	movw	r24, r20
     7a8:	8c 0d       	add	r24, r12
     7aa:	9d 1d       	adc	r25, r13
     7ac:	9e 8b       	std	Y+22, r25	; 0x16
     7ae:	8d 8b       	std	Y+21, r24	; 0x15
     7b0:	d9 01       	movw	r26, r18
     7b2:	ac 0d       	add	r26, r12
     7b4:	bd 1d       	adc	r27, r13
     7b6:	be a7       	std	Y+46, r27	; 0x2e
     7b8:	ad a7       	std	Y+45, r26	; 0x2d
     7ba:	2d 90       	ld	r2, X+
     7bc:	3d 90       	ld	r3, X+
     7be:	4d 90       	ld	r4, X+
     7c0:	5c 90       	ld	r5, X
     7c2:	fc 01       	movw	r30, r24
     7c4:	20 81       	ld	r18, Z
     7c6:	31 81       	ldd	r19, Z+1	; 0x01
     7c8:	42 81       	ldd	r20, Z+2	; 0x02
     7ca:	53 81       	ldd	r21, Z+3	; 0x03
     7cc:	c2 01       	movw	r24, r4
     7ce:	b1 01       	movw	r22, r2
     7d0:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
     7d4:	6f 8b       	std	Y+23, r22	; 0x17
     7d6:	78 8f       	std	Y+24, r23	; 0x18
     7d8:	89 8f       	std	Y+25, r24	; 0x19
     7da:	9a 8f       	std	Y+26, r25	; 0x1a
  float center_axis1 = position[axis_1] + offset[axis_1];
     7dc:	0a 2d       	mov	r16, r10
     7de:	10 e0       	ldi	r17, 0x00	; 0
     7e0:	00 0f       	add	r16, r16
     7e2:	11 1f       	adc	r17, r17
     7e4:	00 0f       	add	r16, r16
     7e6:	11 1f       	adc	r17, r17
     7e8:	8d 85       	ldd	r24, Y+13	; 0x0d
     7ea:	9e 85       	ldd	r25, Y+14	; 0x0e
     7ec:	80 0f       	add	r24, r16
     7ee:	91 1f       	adc	r25, r17
     7f0:	9c 8f       	std	Y+28, r25	; 0x1c
     7f2:	8b 8f       	std	Y+27, r24	; 0x1b
     7f4:	d3 01       	movw	r26, r6
     7f6:	a0 0f       	add	r26, r16
     7f8:	b1 1f       	adc	r27, r17
     7fa:	b8 ab       	std	Y+48, r27	; 0x30
     7fc:	af a7       	std	Y+47, r26	; 0x2f
     7fe:	8d 90       	ld	r8, X+
     800:	9d 90       	ld	r9, X+
     802:	ad 90       	ld	r10, X+
     804:	bc 90       	ld	r11, X
     806:	fc 01       	movw	r30, r24
     808:	20 81       	ld	r18, Z
     80a:	31 81       	ldd	r19, Z+1	; 0x01
     80c:	42 81       	ldd	r20, Z+2	; 0x02
     80e:	53 81       	ldd	r21, Z+3	; 0x03
     810:	c5 01       	movw	r24, r10
     812:	b4 01       	movw	r22, r8
     814:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
     818:	6d 8f       	std	Y+29, r22	; 0x1d
     81a:	7e 8f       	std	Y+30, r23	; 0x1e
     81c:	8f 8f       	std	Y+31, r24	; 0x1f
     81e:	98 a3       	std	Y+32, r25	; 0x20
  float r_axis0 = -offset[axis_0];  // Radius vector from center to current location
     820:	d2 01       	movw	r26, r4
     822:	c1 01       	movw	r24, r2
     824:	b0 58       	subi	r27, 0x80	; 128
     826:	89 83       	std	Y+1, r24	; 0x01
     828:	9a 83       	std	Y+2, r25	; 0x02
     82a:	ab 83       	std	Y+3, r26	; 0x03
     82c:	bc 83       	std	Y+4, r27	; 0x04
  float r_axis1 = -offset[axis_1];
     82e:	d5 01       	movw	r26, r10
     830:	c4 01       	movw	r24, r8
     832:	b0 58       	subi	r27, 0x80	; 128
     834:	89 87       	std	Y+9, r24	; 0x09
     836:	9a 87       	std	Y+10, r25	; 0x0a
     838:	ab 87       	std	Y+11, r26	; 0x0b
     83a:	bc 87       	std	Y+12, r27	; 0x0c
  float rt_axis0 = target[axis_0] - center_axis0;
     83c:	e9 a9       	ldd	r30, Y+49	; 0x31
     83e:	fa a9       	ldd	r31, Y+50	; 0x32
     840:	ec 0d       	add	r30, r12
     842:	fd 1d       	adc	r31, r13
     844:	2f 89       	ldd	r18, Y+23	; 0x17
     846:	38 8d       	ldd	r19, Y+24	; 0x18
     848:	49 8d       	ldd	r20, Y+25	; 0x19
     84a:	5a 8d       	ldd	r21, Y+26	; 0x1a
     84c:	60 81       	ld	r22, Z
     84e:	71 81       	ldd	r23, Z+1	; 0x01
     850:	82 81       	ldd	r24, Z+2	; 0x02
     852:	93 81       	ldd	r25, Z+3	; 0x03
     854:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
     858:	6b 01       	movw	r12, r22
     85a:	7c 01       	movw	r14, r24
  float rt_axis1 = target[axis_1] - center_axis1;
     85c:	e9 a9       	ldd	r30, Y+49	; 0x31
     85e:	fa a9       	ldd	r31, Y+50	; 0x32
     860:	e0 0f       	add	r30, r16
     862:	f1 1f       	adc	r31, r17
     864:	2d 8d       	ldd	r18, Y+29	; 0x1d
     866:	3e 8d       	ldd	r19, Y+30	; 0x1e
     868:	4f 8d       	ldd	r20, Y+31	; 0x1f
     86a:	58 a1       	ldd	r21, Y+32	; 0x20
     86c:	60 81       	ld	r22, Z
     86e:	71 81       	ldd	r23, Z+1	; 0x01
     870:	82 81       	ldd	r24, Z+2	; 0x02
     872:	93 81       	ldd	r25, Z+3	; 0x03
     874:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
     878:	4b 01       	movw	r8, r22
     87a:	5c 01       	movw	r10, r24

  // CCW angle between position and target from circle center. Only one atan2() trig computation required.
  float angular_travel = atan2(r_axis0*rt_axis1-r_axis1*rt_axis0, r_axis0*rt_axis0+r_axis1*rt_axis1);
     87c:	a7 01       	movw	r20, r14
     87e:	96 01       	movw	r18, r12
     880:	69 81       	ldd	r22, Y+1	; 0x01
     882:	7a 81       	ldd	r23, Y+2	; 0x02
     884:	8b 81       	ldd	r24, Y+3	; 0x03
     886:	9c 81       	ldd	r25, Y+4	; 0x04
     888:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     88c:	2b 01       	movw	r4, r22
     88e:	3c 01       	movw	r6, r24
     890:	a5 01       	movw	r20, r10
     892:	94 01       	movw	r18, r8
     894:	69 85       	ldd	r22, Y+9	; 0x09
     896:	7a 85       	ldd	r23, Y+10	; 0x0a
     898:	8b 85       	ldd	r24, Y+11	; 0x0b
     89a:	9c 85       	ldd	r25, Y+12	; 0x0c
     89c:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     8a0:	9b 01       	movw	r18, r22
     8a2:	ac 01       	movw	r20, r24
     8a4:	c3 01       	movw	r24, r6
     8a6:	b2 01       	movw	r22, r4
     8a8:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
     8ac:	2b 01       	movw	r4, r22
     8ae:	3c 01       	movw	r6, r24
     8b0:	a5 01       	movw	r20, r10
     8b2:	94 01       	movw	r18, r8
     8b4:	69 81       	ldd	r22, Y+1	; 0x01
     8b6:	7a 81       	ldd	r23, Y+2	; 0x02
     8b8:	8b 81       	ldd	r24, Y+3	; 0x03
     8ba:	9c 81       	ldd	r25, Y+4	; 0x04
     8bc:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     8c0:	4b 01       	movw	r8, r22
     8c2:	5c 01       	movw	r10, r24
     8c4:	a7 01       	movw	r20, r14
     8c6:	96 01       	movw	r18, r12
     8c8:	69 85       	ldd	r22, Y+9	; 0x09
     8ca:	7a 85       	ldd	r23, Y+10	; 0x0a
     8cc:	8b 85       	ldd	r24, Y+11	; 0x0b
     8ce:	9c 85       	ldd	r25, Y+12	; 0x0c
     8d0:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     8d4:	9b 01       	movw	r18, r22
     8d6:	ac 01       	movw	r20, r24
     8d8:	c5 01       	movw	r24, r10
     8da:	b4 01       	movw	r22, r8
     8dc:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
     8e0:	a3 01       	movw	r20, r6
     8e2:	92 01       	movw	r18, r4
     8e4:	0e 94 3a 3f 	call	0x7e74	; 0x7e74 <atan2>
     8e8:	4b 01       	movw	r8, r22
     8ea:	5c 01       	movw	r10, r24
  if (is_clockwise_arc) { // Correct atan2 output per direction
     8ec:	29 96       	adiw	r28, 0x09	; 9
     8ee:	8f ad       	ldd	r24, Y+63	; 0x3f
     8f0:	29 97       	sbiw	r28, 0x09	; 9
     8f2:	88 23       	and	r24, r24
     8f4:	a9 f0       	breq	.+42     	; 0x920 <mc_arc+0x1d0>
    if (angular_travel >= -ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel -= 2*M_PI; }
     8f6:	2d eb       	ldi	r18, 0xBD	; 189
     8f8:	37 e3       	ldi	r19, 0x37	; 55
     8fa:	46 e0       	ldi	r20, 0x06	; 6
     8fc:	55 eb       	ldi	r21, 0xB5	; 181
     8fe:	c5 01       	movw	r24, r10
     900:	b4 01       	movw	r22, r8
     902:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
     906:	88 23       	and	r24, r24
     908:	fc f0       	brlt	.+62     	; 0x948 <mc_arc+0x1f8>
     90a:	2b ed       	ldi	r18, 0xDB	; 219
     90c:	3f e0       	ldi	r19, 0x0F	; 15
     90e:	49 ec       	ldi	r20, 0xC9	; 201
     910:	50 e4       	ldi	r21, 0x40	; 64
     912:	c5 01       	movw	r24, r10
     914:	b4 01       	movw	r22, r8
     916:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
     91a:	4b 01       	movw	r8, r22
     91c:	5c 01       	movw	r10, r24
     91e:	14 c0       	rjmp	.+40     	; 0x948 <mc_arc+0x1f8>
  } else {
    if (angular_travel <= ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel += 2*M_PI; }
     920:	2d eb       	ldi	r18, 0xBD	; 189
     922:	37 e3       	ldi	r19, 0x37	; 55
     924:	46 e0       	ldi	r20, 0x06	; 6
     926:	55 e3       	ldi	r21, 0x35	; 53
     928:	c5 01       	movw	r24, r10
     92a:	b4 01       	movw	r22, r8
     92c:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
     930:	18 16       	cp	r1, r24
     932:	54 f0       	brlt	.+20     	; 0x948 <mc_arc+0x1f8>
     934:	2b ed       	ldi	r18, 0xDB	; 219
     936:	3f e0       	ldi	r19, 0x0F	; 15
     938:	49 ec       	ldi	r20, 0xC9	; 201
     93a:	50 e4       	ldi	r21, 0x40	; 64
     93c:	c5 01       	movw	r24, r10
     93e:	b4 01       	movw	r22, r8
     940:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
     944:	4b 01       	movw	r8, r22
     946:	5c 01       	movw	r10, r24
  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
     948:	c0 90 09 0f 	lds	r12, 0x0F09	; 0x800f09 <settings+0x39>
     94c:	d0 90 0a 0f 	lds	r13, 0x0F0A	; 0x800f0a <settings+0x3a>
     950:	e0 90 0b 0f 	lds	r14, 0x0F0B	; 0x800f0b <settings+0x3b>
     954:	f0 90 0c 0f 	lds	r15, 0x0F0C	; 0x800f0c <settings+0x3c>
     958:	2d 81       	ldd	r18, Y+5	; 0x05
     95a:	3e 81       	ldd	r19, Y+6	; 0x06
     95c:	4f 81       	ldd	r20, Y+7	; 0x07
     95e:	58 85       	ldd	r21, Y+8	; 0x08
     960:	ca 01       	movw	r24, r20
     962:	b9 01       	movw	r22, r18
     964:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
     968:	2b 01       	movw	r4, r22
     96a:	3c 01       	movw	r6, r24
     96c:	a7 01       	movw	r20, r14
     96e:	96 01       	movw	r18, r12
     970:	c3 01       	movw	r24, r6
     972:	b2 01       	movw	r22, r4
     974:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
     978:	a7 01       	movw	r20, r14
     97a:	96 01       	movw	r18, r12
     97c:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     980:	0e 94 6b 42 	call	0x84d6	; 0x84d6 <sqrt>
     984:	6b 01       	movw	r12, r22
     986:	7c 01       	movw	r14, r24

  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
     988:	20 e0       	ldi	r18, 0x00	; 0
     98a:	30 e0       	ldi	r19, 0x00	; 0
     98c:	40 e0       	ldi	r20, 0x00	; 0
     98e:	5f e3       	ldi	r21, 0x3F	; 63
     990:	c5 01       	movw	r24, r10
     992:	b4 01       	movw	r22, r8
     994:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     998:	2d 81       	ldd	r18, Y+5	; 0x05
     99a:	3e 81       	ldd	r19, Y+6	; 0x06
     99c:	4f 81       	ldd	r20, Y+7	; 0x07
     99e:	58 85       	ldd	r21, Y+8	; 0x08
     9a0:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     9a4:	9f 77       	andi	r25, 0x7F	; 127
     9a6:	a7 01       	movw	r20, r14
     9a8:	96 01       	movw	r18, r12
     9aa:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <__divsf3>
     9ae:	0e 94 7d 40 	call	0x80fa	; 0x80fa <floor>
     9b2:	0e 94 14 40 	call	0x8028	; 0x8028 <__fixunssfsi>
     9b6:	6b 01       	movw	r12, r22
     9b8:	7c 01       	movw	r14, r24
     9ba:	3b 01       	movw	r6, r22
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );

  if (segments) {
     9bc:	61 15       	cp	r22, r1
     9be:	71 05       	cpc	r23, r1
     9c0:	09 f4       	brne	.+2      	; 0x9c4 <mc_arc+0x274>
     9c2:	87 c1       	rjmp	.+782    	; 0xcd2 <mc_arc+0x582>
    // Multiply inverse feed_rate to compensate for the fact that this movement is approximated
    // by a number of discrete segments. The inverse feed_rate should be correct for the sum of
    // all segments.
    if (pl_data->condition & PL_COND_FLAG_INVERSE_TIME) { 
     9c4:	af 85       	ldd	r26, Y+15	; 0x0f
     9c6:	b8 89       	ldd	r27, Y+16	; 0x10
     9c8:	1c 96       	adiw	r26, 0x0c	; 12
     9ca:	1c 91       	ld	r17, X
     9cc:	13 ff       	sbrs	r17, 3
     9ce:	18 c0       	rjmp	.+48     	; 0xa00 <mc_arc+0x2b0>
      pl_data->feed_rate *= segments; 
     9d0:	80 e0       	ldi	r24, 0x00	; 0
     9d2:	90 e0       	ldi	r25, 0x00	; 0
     9d4:	0e 94 40 40 	call	0x8080	; 0x8080 <__floatunsisf>
     9d8:	9b 01       	movw	r18, r22
     9da:	ac 01       	movw	r20, r24
     9dc:	ef 85       	ldd	r30, Y+15	; 0x0f
     9de:	f8 89       	ldd	r31, Y+16	; 0x10
     9e0:	60 81       	ld	r22, Z
     9e2:	71 81       	ldd	r23, Z+1	; 0x01
     9e4:	82 81       	ldd	r24, Z+2	; 0x02
     9e6:	93 81       	ldd	r25, Z+3	; 0x03
     9e8:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     9ec:	af 85       	ldd	r26, Y+15	; 0x0f
     9ee:	b8 89       	ldd	r27, Y+16	; 0x10
     9f0:	6d 93       	st	X+, r22
     9f2:	7d 93       	st	X+, r23
     9f4:	8d 93       	st	X+, r24
     9f6:	9c 93       	st	X, r25
     9f8:	13 97       	sbiw	r26, 0x03	; 3
      bit_false(pl_data->condition,PL_COND_FLAG_INVERSE_TIME); // Force as feed absolute mode over arc segments.
     9fa:	17 7f       	andi	r17, 0xF7	; 247
     9fc:	1c 96       	adiw	r26, 0x0c	; 12
     9fe:	1c 93       	st	X, r17
    }
    
    float theta_per_segment = angular_travel/segments;
     a00:	b6 01       	movw	r22, r12
     a02:	80 e0       	ldi	r24, 0x00	; 0
     a04:	90 e0       	ldi	r25, 0x00	; 0
     a06:	0e 94 40 40 	call	0x8080	; 0x8080 <__floatunsisf>
     a0a:	6b 01       	movw	r12, r22
     a0c:	7c 01       	movw	r14, r24
     a0e:	9b 01       	movw	r18, r22
     a10:	ac 01       	movw	r20, r24
     a12:	c5 01       	movw	r24, r10
     a14:	b4 01       	movw	r22, r8
     a16:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <__divsf3>
     a1a:	69 a7       	std	Y+41, r22	; 0x29
     a1c:	7a a7       	std	Y+42, r23	; 0x2a
     a1e:	8b a7       	std	Y+43, r24	; 0x2b
     a20:	9c a7       	std	Y+44, r25	; 0x2c
    float linear_per_segment = (target[axis_linear] - position[axis_linear])/segments;
     a22:	b9 89       	ldd	r27, Y+17	; 0x11
     a24:	8b 2e       	mov	r8, r27
     a26:	91 2c       	mov	r9, r1
     a28:	88 0c       	add	r8, r8
     a2a:	99 1c       	adc	r9, r9
     a2c:	88 0c       	add	r8, r8
     a2e:	99 1c       	adc	r9, r9
     a30:	4d 84       	ldd	r4, Y+13	; 0x0d
     a32:	5e 84       	ldd	r5, Y+14	; 0x0e
     a34:	48 0c       	add	r4, r8
     a36:	59 1c       	adc	r5, r9
     a38:	e9 a9       	ldd	r30, Y+49	; 0x31
     a3a:	fa a9       	ldd	r31, Y+50	; 0x32
     a3c:	e8 0d       	add	r30, r8
     a3e:	f9 1d       	adc	r31, r9
     a40:	d2 01       	movw	r26, r4
     a42:	2d 91       	ld	r18, X+
     a44:	3d 91       	ld	r19, X+
     a46:	4d 91       	ld	r20, X+
     a48:	5c 91       	ld	r21, X
     a4a:	60 81       	ld	r22, Z
     a4c:	71 81       	ldd	r23, Z+1	; 0x01
     a4e:	82 81       	ldd	r24, Z+2	; 0x02
     a50:	93 81       	ldd	r25, Z+3	; 0x03
     a52:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
     a56:	a7 01       	movw	r20, r14
     a58:	96 01       	movw	r18, r12
     a5a:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <__divsf3>
     a5e:	69 8b       	std	Y+17, r22	; 0x11
     a60:	7a 8b       	std	Y+18, r23	; 0x12
     a62:	8b 8b       	std	Y+19, r24	; 0x13
     a64:	9c 8b       	std	Y+20, r25	; 0x14
       without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
       a correction, the planner should have caught up to the lag caused by the initial mc_arc overhead.
       This is important when there are successive arc motions.
    */
    // Computes: cos_T = 1 - theta_per_segment^2/2, sin_T = theta_per_segment - theta_per_segment^3/6) in ~52usec
    float cos_T = 2.0 - theta_per_segment*theta_per_segment;
     a66:	29 a5       	ldd	r18, Y+41	; 0x29
     a68:	3a a5       	ldd	r19, Y+42	; 0x2a
     a6a:	4b a5       	ldd	r20, Y+43	; 0x2b
     a6c:	5c a5       	ldd	r21, Y+44	; 0x2c
     a6e:	ca 01       	movw	r24, r20
     a70:	b9 01       	movw	r22, r18
     a72:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     a76:	9b 01       	movw	r18, r22
     a78:	ac 01       	movw	r20, r24
     a7a:	60 e0       	ldi	r22, 0x00	; 0
     a7c:	70 e0       	ldi	r23, 0x00	; 0
     a7e:	80 e0       	ldi	r24, 0x00	; 0
     a80:	90 e4       	ldi	r25, 0x40	; 64
     a82:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
     a86:	6b 01       	movw	r12, r22
     a88:	7c 01       	movw	r14, r24
    float sin_T = theta_per_segment*0.16666667*(cos_T + 4.0);
     a8a:	2b ea       	ldi	r18, 0xAB	; 171
     a8c:	3a ea       	ldi	r19, 0xAA	; 170
     a8e:	4a e2       	ldi	r20, 0x2A	; 42
     a90:	5e e3       	ldi	r21, 0x3E	; 62
     a92:	69 a5       	ldd	r22, Y+41	; 0x29
     a94:	7a a5       	ldd	r23, Y+42	; 0x2a
     a96:	8b a5       	ldd	r24, Y+43	; 0x2b
     a98:	9c a5       	ldd	r25, Y+44	; 0x2c
     a9a:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     a9e:	4b 01       	movw	r8, r22
     aa0:	5c 01       	movw	r10, r24
     aa2:	20 e0       	ldi	r18, 0x00	; 0
     aa4:	30 e0       	ldi	r19, 0x00	; 0
     aa6:	40 e8       	ldi	r20, 0x80	; 128
     aa8:	50 e4       	ldi	r21, 0x40	; 64
     aaa:	c7 01       	movw	r24, r14
     aac:	b6 01       	movw	r22, r12
     aae:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
     ab2:	9b 01       	movw	r18, r22
     ab4:	ac 01       	movw	r20, r24
     ab6:	c5 01       	movw	r24, r10
     ab8:	b4 01       	movw	r22, r8
     aba:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     abe:	69 a3       	std	Y+33, r22	; 0x21
     ac0:	7a a3       	std	Y+34, r23	; 0x22
     ac2:	8b a3       	std	Y+35, r24	; 0x23
     ac4:	9c a3       	std	Y+36, r25	; 0x24
    cos_T *= 0.5;
     ac6:	20 e0       	ldi	r18, 0x00	; 0
     ac8:	30 e0       	ldi	r19, 0x00	; 0
     aca:	40 e0       	ldi	r20, 0x00	; 0
     acc:	5f e3       	ldi	r21, 0x3F	; 63
     ace:	c7 01       	movw	r24, r14
     ad0:	b6 01       	movw	r22, r12
     ad2:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     ad6:	6d a3       	std	Y+37, r22	; 0x25
     ad8:	7e a3       	std	Y+38, r23	; 0x26
     ada:	8f a3       	std	Y+39, r24	; 0x27
     adc:	98 a7       	std	Y+40, r25	; 0x28
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;

    for (i = 1; i<segments; i++) { // Increment (segments-1).
     ade:	b2 e0       	ldi	r27, 0x02	; 2
     ae0:	6b 16       	cp	r6, r27
     ae2:	71 04       	cpc	r7, r1
     ae4:	08 f4       	brcc	.+2      	; 0xae8 <mc_arc+0x398>
     ae6:	f5 c0       	rjmp	.+490    	; 0xcd2 <mc_arc+0x582>
     ae8:	10 e0       	ldi	r17, 0x00	; 0
     aea:	22 24       	eor	r2, r2
     aec:	23 94       	inc	r2
     aee:	31 2c       	mov	r3, r1
      position[axis_linear] += linear_per_segment;

      mc_line(position, pl_data);

      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
     af0:	c9 84       	ldd	r12, Y+9	; 0x09
     af2:	da 84       	ldd	r13, Y+10	; 0x0a
     af4:	eb 84       	ldd	r14, Y+11	; 0x0b
     af6:	fc 84       	ldd	r15, Y+12	; 0x0c
    uint16_t i;
    uint8_t count = 0;

    for (i = 1; i<segments; i++) { // Increment (segments-1).

      if (count < N_ARC_CORRECTION) {
     af8:	1c 30       	cpi	r17, 0x0C	; 12
     afa:	08 f0       	brcs	.+2      	; 0xafe <mc_arc+0x3ae>
     afc:	44 c0       	rjmp	.+136    	; 0xb86 <mc_arc+0x436>
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
     afe:	a7 01       	movw	r20, r14
     b00:	96 01       	movw	r18, r12
     b02:	6d a1       	ldd	r22, Y+37	; 0x25
     b04:	7e a1       	ldd	r23, Y+38	; 0x26
     b06:	8f a1       	ldd	r24, Y+39	; 0x27
     b08:	98 a5       	ldd	r25, Y+40	; 0x28
     b0a:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     b0e:	4b 01       	movw	r8, r22
     b10:	5c 01       	movw	r10, r24
     b12:	29 81       	ldd	r18, Y+1	; 0x01
     b14:	3a 81       	ldd	r19, Y+2	; 0x02
     b16:	4b 81       	ldd	r20, Y+3	; 0x03
     b18:	5c 81       	ldd	r21, Y+4	; 0x04
     b1a:	69 a1       	ldd	r22, Y+33	; 0x21
     b1c:	7a a1       	ldd	r23, Y+34	; 0x22
     b1e:	8b a1       	ldd	r24, Y+35	; 0x23
     b20:	9c a1       	ldd	r25, Y+36	; 0x24
     b22:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     b26:	a5 01       	movw	r20, r10
     b28:	94 01       	movw	r18, r8
     b2a:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
     b2e:	96 2e       	mov	r9, r22
     b30:	a7 2e       	mov	r10, r23
     b32:	b8 2e       	mov	r11, r24
     b34:	09 2f       	mov	r16, r25
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
     b36:	29 81       	ldd	r18, Y+1	; 0x01
     b38:	3a 81       	ldd	r19, Y+2	; 0x02
     b3a:	4b 81       	ldd	r20, Y+3	; 0x03
     b3c:	5c 81       	ldd	r21, Y+4	; 0x04
     b3e:	6d a1       	ldd	r22, Y+37	; 0x25
     b40:	7e a1       	ldd	r23, Y+38	; 0x26
     b42:	8f a1       	ldd	r24, Y+39	; 0x27
     b44:	98 a5       	ldd	r25, Y+40	; 0x28
     b46:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     b4a:	69 83       	std	Y+1, r22	; 0x01
     b4c:	7a 83       	std	Y+2, r23	; 0x02
     b4e:	8b 83       	std	Y+3, r24	; 0x03
     b50:	9c 83       	std	Y+4, r25	; 0x04
     b52:	a7 01       	movw	r20, r14
     b54:	96 01       	movw	r18, r12
     b56:	69 a1       	ldd	r22, Y+33	; 0x21
     b58:	7a a1       	ldd	r23, Y+34	; 0x22
     b5a:	8b a1       	ldd	r24, Y+35	; 0x23
     b5c:	9c a1       	ldd	r25, Y+36	; 0x24
     b5e:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     b62:	9b 01       	movw	r18, r22
     b64:	ac 01       	movw	r20, r24
     b66:	69 81       	ldd	r22, Y+1	; 0x01
     b68:	7a 81       	ldd	r23, Y+2	; 0x02
     b6a:	8b 81       	ldd	r24, Y+3	; 0x03
     b6c:	9c 81       	ldd	r25, Y+4	; 0x04
     b6e:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
     b72:	69 83       	std	Y+1, r22	; 0x01
     b74:	7a 83       	std	Y+2, r23	; 0x02
     b76:	8b 83       	std	Y+3, r24	; 0x03
     b78:	9c 83       	std	Y+4, r25	; 0x04
        r_axis1 = r_axisi;
        count++;
     b7a:	1f 5f       	subi	r17, 0xFF	; 255

      if (count < N_ARC_CORRECTION) {
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
        r_axis1 = r_axisi;
     b7c:	c9 2c       	mov	r12, r9
     b7e:	da 2c       	mov	r13, r10
     b80:	eb 2c       	mov	r14, r11
     b82:	f0 2e       	mov	r15, r16
     b84:	66 c0       	rjmp	.+204    	; 0xc52 <mc_arc+0x502>
        count++;
      } else {
        // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments. ~375 usec
        // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
        cos_Ti = cos(i*theta_per_segment);
     b86:	b1 01       	movw	r22, r2
     b88:	80 e0       	ldi	r24, 0x00	; 0
     b8a:	90 e0       	ldi	r25, 0x00	; 0
     b8c:	0e 94 40 40 	call	0x8080	; 0x8080 <__floatunsisf>
     b90:	29 a5       	ldd	r18, Y+41	; 0x29
     b92:	3a a5       	ldd	r19, Y+42	; 0x2a
     b94:	4b a5       	ldd	r20, Y+43	; 0x2b
     b96:	5c a5       	ldd	r21, Y+44	; 0x2c
     b98:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     b9c:	6b 01       	movw	r12, r22
     b9e:	7c 01       	movw	r14, r24
     ba0:	0e 94 a4 3f 	call	0x7f48	; 0x7f48 <cos>
     ba4:	6d 83       	std	Y+5, r22	; 0x05
     ba6:	7e 83       	std	Y+6, r23	; 0x06
     ba8:	8f 83       	std	Y+7, r24	; 0x07
     baa:	98 87       	std	Y+8, r25	; 0x08
        sin_Ti = sin(i*theta_per_segment);
     bac:	c7 01       	movw	r24, r14
     bae:	b6 01       	movw	r22, r12
     bb0:	0e 94 61 42 	call	0x84c2	; 0x84c2 <sin>
     bb4:	69 87       	std	Y+9, r22	; 0x09
     bb6:	7a 87       	std	Y+10, r23	; 0x0a
     bb8:	8b 87       	std	Y+11, r24	; 0x0b
     bba:	9c 87       	std	Y+12, r25	; 0x0c
        r_axis0 = -offset[axis_0]*cos_Ti + offset[axis_1]*sin_Ti;
     bbc:	ed a5       	ldd	r30, Y+45	; 0x2d
     bbe:	fe a5       	ldd	r31, Y+46	; 0x2e
     bc0:	c0 80       	ld	r12, Z
     bc2:	d1 80       	ldd	r13, Z+1	; 0x01
     bc4:	e2 80       	ldd	r14, Z+2	; 0x02
     bc6:	f3 80       	ldd	r15, Z+3	; 0x03
     bc8:	f7 fa       	bst	r15, 7
     bca:	f0 94       	com	r15
     bcc:	f7 f8       	bld	r15, 7
     bce:	f0 94       	com	r15
     bd0:	af a5       	ldd	r26, Y+47	; 0x2f
     bd2:	b8 a9       	ldd	r27, Y+48	; 0x30
     bd4:	8d 90       	ld	r8, X+
     bd6:	9d 90       	ld	r9, X+
     bd8:	ad 90       	ld	r10, X+
     bda:	bc 90       	ld	r11, X
     bdc:	a7 01       	movw	r20, r14
     bde:	96 01       	movw	r18, r12
     be0:	6d 81       	ldd	r22, Y+5	; 0x05
     be2:	7e 81       	ldd	r23, Y+6	; 0x06
     be4:	8f 81       	ldd	r24, Y+7	; 0x07
     be6:	98 85       	ldd	r25, Y+8	; 0x08
     be8:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     bec:	69 83       	std	Y+1, r22	; 0x01
     bee:	7a 83       	std	Y+2, r23	; 0x02
     bf0:	8b 83       	std	Y+3, r24	; 0x03
     bf2:	9c 83       	std	Y+4, r25	; 0x04
     bf4:	a5 01       	movw	r20, r10
     bf6:	94 01       	movw	r18, r8
     bf8:	69 85       	ldd	r22, Y+9	; 0x09
     bfa:	7a 85       	ldd	r23, Y+10	; 0x0a
     bfc:	8b 85       	ldd	r24, Y+11	; 0x0b
     bfe:	9c 85       	ldd	r25, Y+12	; 0x0c
     c00:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     c04:	9b 01       	movw	r18, r22
     c06:	ac 01       	movw	r20, r24
     c08:	69 81       	ldd	r22, Y+1	; 0x01
     c0a:	7a 81       	ldd	r23, Y+2	; 0x02
     c0c:	8b 81       	ldd	r24, Y+3	; 0x03
     c0e:	9c 81       	ldd	r25, Y+4	; 0x04
     c10:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
     c14:	69 83       	std	Y+1, r22	; 0x01
     c16:	7a 83       	std	Y+2, r23	; 0x02
     c18:	8b 83       	std	Y+3, r24	; 0x03
     c1a:	9c 83       	std	Y+4, r25	; 0x04
        r_axis1 = -offset[axis_0]*sin_Ti - offset[axis_1]*cos_Ti;
     c1c:	a7 01       	movw	r20, r14
     c1e:	96 01       	movw	r18, r12
     c20:	69 85       	ldd	r22, Y+9	; 0x09
     c22:	7a 85       	ldd	r23, Y+10	; 0x0a
     c24:	8b 85       	ldd	r24, Y+11	; 0x0b
     c26:	9c 85       	ldd	r25, Y+12	; 0x0c
     c28:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     c2c:	6b 01       	movw	r12, r22
     c2e:	7c 01       	movw	r14, r24
     c30:	a5 01       	movw	r20, r10
     c32:	94 01       	movw	r18, r8
     c34:	6d 81       	ldd	r22, Y+5	; 0x05
     c36:	7e 81       	ldd	r23, Y+6	; 0x06
     c38:	8f 81       	ldd	r24, Y+7	; 0x07
     c3a:	98 85       	ldd	r25, Y+8	; 0x08
     c3c:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     c40:	9b 01       	movw	r18, r22
     c42:	ac 01       	movw	r20, r24
     c44:	c7 01       	movw	r24, r14
     c46:	b6 01       	movw	r22, r12
     c48:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
     c4c:	6b 01       	movw	r12, r22
     c4e:	7c 01       	movw	r14, r24
        count = 0;
     c50:	10 e0       	ldi	r17, 0x00	; 0
      }

      // Update arc_target location
      position[axis_0] = center_axis0 + r_axis0;
     c52:	2f 89       	ldd	r18, Y+23	; 0x17
     c54:	38 8d       	ldd	r19, Y+24	; 0x18
     c56:	49 8d       	ldd	r20, Y+25	; 0x19
     c58:	5a 8d       	ldd	r21, Y+26	; 0x1a
     c5a:	69 81       	ldd	r22, Y+1	; 0x01
     c5c:	7a 81       	ldd	r23, Y+2	; 0x02
     c5e:	8b 81       	ldd	r24, Y+3	; 0x03
     c60:	9c 81       	ldd	r25, Y+4	; 0x04
     c62:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
     c66:	ed 89       	ldd	r30, Y+21	; 0x15
     c68:	fe 89       	ldd	r31, Y+22	; 0x16
     c6a:	60 83       	st	Z, r22
     c6c:	71 83       	std	Z+1, r23	; 0x01
     c6e:	82 83       	std	Z+2, r24	; 0x02
     c70:	93 83       	std	Z+3, r25	; 0x03
      position[axis_1] = center_axis1 + r_axis1;
     c72:	2d 8d       	ldd	r18, Y+29	; 0x1d
     c74:	3e 8d       	ldd	r19, Y+30	; 0x1e
     c76:	4f 8d       	ldd	r20, Y+31	; 0x1f
     c78:	58 a1       	ldd	r21, Y+32	; 0x20
     c7a:	c7 01       	movw	r24, r14
     c7c:	b6 01       	movw	r22, r12
     c7e:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
     c82:	ab 8d       	ldd	r26, Y+27	; 0x1b
     c84:	bc 8d       	ldd	r27, Y+28	; 0x1c
     c86:	6d 93       	st	X+, r22
     c88:	7d 93       	st	X+, r23
     c8a:	8d 93       	st	X+, r24
     c8c:	9c 93       	st	X, r25
     c8e:	13 97       	sbiw	r26, 0x03	; 3
      position[axis_linear] += linear_per_segment;
     c90:	29 89       	ldd	r18, Y+17	; 0x11
     c92:	3a 89       	ldd	r19, Y+18	; 0x12
     c94:	4b 89       	ldd	r20, Y+19	; 0x13
     c96:	5c 89       	ldd	r21, Y+20	; 0x14
     c98:	f2 01       	movw	r30, r4
     c9a:	60 81       	ld	r22, Z
     c9c:	71 81       	ldd	r23, Z+1	; 0x01
     c9e:	82 81       	ldd	r24, Z+2	; 0x02
     ca0:	93 81       	ldd	r25, Z+3	; 0x03
     ca2:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
     ca6:	d2 01       	movw	r26, r4
     ca8:	6d 93       	st	X+, r22
     caa:	7d 93       	st	X+, r23
     cac:	8d 93       	st	X+, r24
     cae:	9c 93       	st	X, r25
     cb0:	13 97       	sbiw	r26, 0x03	; 3

      mc_line(position, pl_data);
     cb2:	6f 85       	ldd	r22, Y+15	; 0x0f
     cb4:	78 89       	ldd	r23, Y+16	; 0x10
     cb6:	8d 85       	ldd	r24, Y+13	; 0x0d
     cb8:	9e 85       	ldd	r25, Y+14	; 0x0e
     cba:	09 dd       	rcall	.-1518   	; 0x6ce <mc_line>

      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
     cbc:	80 91 1f 0c 	lds	r24, 0x0C1F	; 0x800c1f <sys+0x1>
     cc0:	81 11       	cpse	r24, r1
     cc2:	0c c0       	rjmp	.+24     	; 0xcdc <mc_arc+0x58c>
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;

    for (i = 1; i<segments; i++) { // Increment (segments-1).
     cc4:	bf ef       	ldi	r27, 0xFF	; 255
     cc6:	2b 1a       	sub	r2, r27
     cc8:	3b 0a       	sbc	r3, r27
     cca:	62 14       	cp	r6, r2
     ccc:	73 04       	cpc	r7, r3
     cce:	09 f0       	breq	.+2      	; 0xcd2 <mc_arc+0x582>
     cd0:	13 cf       	rjmp	.-474    	; 0xaf8 <mc_arc+0x3a8>
      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
    }
  }
  // Ensure last segment arrives at target location.
  mc_line(target, pl_data);
     cd2:	6f 85       	ldd	r22, Y+15	; 0x0f
     cd4:	78 89       	ldd	r23, Y+16	; 0x10
     cd6:	89 a9       	ldd	r24, Y+49	; 0x31
     cd8:	9a a9       	ldd	r25, Y+50	; 0x32
     cda:	f9 dc       	rcall	.-1550   	; 0x6ce <mc_line>
}
     cdc:	e2 96       	adiw	r28, 0x32	; 50
     cde:	0f b6       	in	r0, 0x3f	; 63
     ce0:	f8 94       	cli
     ce2:	de bf       	out	0x3e, r29	; 62
     ce4:	0f be       	out	0x3f, r0	; 63
     ce6:	cd bf       	out	0x3d, r28	; 61
     ce8:	df 91       	pop	r29
     cea:	cf 91       	pop	r28
     cec:	1f 91       	pop	r17
     cee:	0f 91       	pop	r16
     cf0:	ff 90       	pop	r15
     cf2:	ef 90       	pop	r14
     cf4:	df 90       	pop	r13
     cf6:	cf 90       	pop	r12
     cf8:	bf 90       	pop	r11
     cfa:	af 90       	pop	r10
     cfc:	9f 90       	pop	r9
     cfe:	8f 90       	pop	r8
     d00:	7f 90       	pop	r7
     d02:	6f 90       	pop	r6
     d04:	5f 90       	pop	r5
     d06:	4f 90       	pop	r4
     d08:	3f 90       	pop	r3
     d0a:	2f 90       	pop	r2
     d0c:	08 95       	ret

00000d0e <mc_dwell>:


// Execute dwell in seconds.
void mc_dwell(float seconds)
{
     d0e:	cf 92       	push	r12
     d10:	df 92       	push	r13
     d12:	ef 92       	push	r14
     d14:	ff 92       	push	r15
  if (sys.state == STATE_CHECK_MODE) { return; }
     d16:	20 91 1e 0c 	lds	r18, 0x0C1E	; 0x800c1e <sys>
     d1a:	22 30       	cpi	r18, 0x02	; 2
     d1c:	49 f0       	breq	.+18     	; 0xd30 <mc_dwell+0x22>
     d1e:	6b 01       	movw	r12, r22
     d20:	7c 01       	movw	r14, r24
  protocol_buffer_synchronize();
     d22:	0e 94 2e 19 	call	0x325c	; 0x325c <protocol_buffer_synchronize>
  delay_sec(seconds, DELAY_MODE_DWELL);
     d26:	40 e0       	ldi	r20, 0x00	; 0
     d28:	c7 01       	movw	r24, r14
     d2a:	b6 01       	movw	r22, r12
     d2c:	0e 94 f5 2e 	call	0x5dea	; 0x5dea <delay_sec>
}
     d30:	ff 90       	pop	r15
     d32:	ef 90       	pop	r14
     d34:	df 90       	pop	r13
     d36:	cf 90       	pop	r12
     d38:	08 95       	ret

00000d3a <mc_homing_cycle>:

// Perform homing cycle to locate and set machine zero. Only '$H' executes this command.
// NOTE: There should be no motions in the buffer and Grbl must be in an idle state before
// executing the homing cycle. This prevents incorrect buffered plans after homing.
void mc_homing_cycle(uint8_t cycle_mask)
{
     d3a:	cf 93       	push	r28
     d3c:	c8 2f       	mov	r28, r24
      system_set_exec_alarm(EXEC_ALARM_HARD_LIMIT);
      return;
    }
  #endif

  limits_disable(); // Disable hard limits pin change register for cycle duration
     d3e:	0e 94 3b 30 	call	0x6076	; 0x6076 <limits_disable>

  // -------------------------------------------------------------------------------------
  // Perform homing routine. NOTE: Special motion case. Only system reset works.
  
  #ifdef HOMING_SINGLE_AXIS_COMMANDS
    if (cycle_mask) { limits_go_home(cycle_mask); } // Perform homing cycle based on mask.
     d42:	cc 23       	and	r28, r28
     d44:	21 f0       	breq	.+8      	; 0xd4e <mc_homing_cycle+0x14>
     d46:	8c 2f       	mov	r24, r28
     d48:	0e 94 02 31 	call	0x6204	; 0x6204 <limits_go_home>
     d4c:	06 c0       	rjmp	.+12     	; 0xd5a <mc_homing_cycle+0x20>
    else
  #endif
  {
    // Search to engage all axes limit switches at faster homing seek rate.
    limits_go_home(HOMING_CYCLE_0);  // Homing cycle 0
     d4e:	81 e0       	ldi	r24, 0x01	; 1
     d50:	0e 94 02 31 	call	0x6204	; 0x6204 <limits_go_home>
    #ifdef HOMING_CYCLE_1
      limits_go_home(HOMING_CYCLE_1);  // Homing cycle 1
     d54:	84 e0       	ldi	r24, 0x04	; 4
     d56:	0e 94 02 31 	call	0x6204	; 0x6204 <limits_go_home>
    #ifdef HOMING_CYCLE_2
      limits_go_home(HOMING_CYCLE_2);  // Homing cycle 2
    #endif
  }

  protocol_execute_realtime(); // Check for reset and set system abort.
     d5a:	0e 94 66 17 	call	0x2ecc	; 0x2ecc <protocol_execute_realtime>
  if (sys.abort) { return; } // Did not complete. Alarm state set by mc_alarm.
     d5e:	80 91 1f 0c 	lds	r24, 0x0C1F	; 0x800c1f <sys+0x1>
     d62:	81 11       	cpse	r24, r1
     d64:	05 c0       	rjmp	.+10     	; 0xd70 <mc_homing_cycle+0x36>

  // Homing cycle complete! Setup system for normal operation.
  // -------------------------------------------------------------------------------------

  // Sync gcode parser and planner positions to homed position.
  gc_sync_position();
     d66:	b1 d0       	rcall	.+354    	; 0xeca <gc_sync_position>
  plan_sync_position();
     d68:	0e 94 09 2e 	call	0x5c12	; 0x5c12 <plan_sync_position>

  // If hard limits feature enabled, re-enable hard limits pin change register after homing cycle.
  limits_init();
     d6c:	0e 94 46 30 	call	0x608c	; 0x608c <limits_init>
}
     d70:	cf 91       	pop	r28
     d72:	08 95       	ret

00000d74 <mc_probe_cycle>:


// Perform tool length probe cycle. Requires probe switch.
// NOTE: Upon probe failure, the program will be stopped and placed into ALARM state.
uint8_t mc_probe_cycle(float *target, plan_line_data_t *pl_data, uint8_t parser_flags)
{
     d74:	df 92       	push	r13
     d76:	ef 92       	push	r14
     d78:	ff 92       	push	r15
     d7a:	0f 93       	push	r16
     d7c:	1f 93       	push	r17
     d7e:	cf 93       	push	r28
     d80:	df 93       	push	r29
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return(GC_PROBE_CHECK_MODE); }
     d82:	20 91 1e 0c 	lds	r18, 0x0C1E	; 0x800c1e <sys>
     d86:	22 30       	cpi	r18, 0x02	; 2
     d88:	09 f4       	brne	.+2      	; 0xd8c <mc_probe_cycle+0x18>
     d8a:	5c c0       	rjmp	.+184    	; 0xe44 <mc_probe_cycle+0xd0>
     d8c:	d4 2e       	mov	r13, r20
     d8e:	7b 01       	movw	r14, r22
     d90:	8c 01       	movw	r16, r24

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
     d92:	0e 94 2e 19 	call	0x325c	; 0x325c <protocol_buffer_synchronize>
  if (sys.abort) { return(GC_PROBE_ABORT); } // Return if system reset has been issued.
     d96:	80 91 1f 0c 	lds	r24, 0x0C1F	; 0x800c1f <sys+0x1>
     d9a:	81 11       	cpse	r24, r1
     d9c:	55 c0       	rjmp	.+170    	; 0xe48 <mc_probe_cycle+0xd4>

  // Initialize probing control variables
  uint8_t is_probe_away = bit_istrue(parser_flags,GC_PARSER_PROBE_IS_AWAY);
  uint8_t is_no_error = bit_istrue(parser_flags,GC_PARSER_PROBE_IS_NO_ERROR);
  sys.probe_succeeded = false; // Re-initialize probe history before beginning cycle.
     d9e:	10 92 23 0c 	sts	0x0C23, r1	; 0x800c23 <sys+0x5>
  probe_configure_invert_mask(is_probe_away);
     da2:	d3 fa       	bst	r13, 3
     da4:	88 27       	eor	r24, r24
     da6:	80 f9       	bld	r24, 0
     da8:	0e 94 de 34 	call	0x69bc	; 0x69bc <probe_configure_invert_mask>

  // After syncing, check if probe is already triggered. If so, halt and issue alarm.
  // NOTE: This probe initialization error applies to all probing cycles.
  if ( probe_get_state() ) { // Check probe pin state.
     dac:	0e 94 fc 34 	call	0x69f8	; 0x69f8 <probe_get_state>
     db0:	88 23       	and	r24, r24
     db2:	51 f0       	breq	.+20     	; 0xdc8 <mc_probe_cycle+0x54>
    system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_INITIAL);
     db4:	84 e0       	ldi	r24, 0x04	; 4
     db6:	0e 94 38 3e 	call	0x7c70	; 0x7c70 <system_set_exec_alarm>
    protocol_execute_realtime();
     dba:	0e 94 66 17 	call	0x2ecc	; 0x2ecc <protocol_execute_realtime>
    probe_configure_invert_mask(false); // Re-initialize invert mask before returning.
     dbe:	80 e0       	ldi	r24, 0x00	; 0
     dc0:	0e 94 de 34 	call	0x69bc	; 0x69bc <probe_configure_invert_mask>
    return(GC_PROBE_FAIL_INIT); // Nothing else to do but bail.
     dc4:	82 e0       	ldi	r24, 0x02	; 2
     dc6:	43 c0       	rjmp	.+134    	; 0xe4e <mc_probe_cycle+0xda>
  }

  // Setup and queue probing motion. Auto cycle-start should not start the cycle.
  mc_line(target, pl_data);
     dc8:	b7 01       	movw	r22, r14
     dca:	c8 01       	movw	r24, r16
     dcc:	80 dc       	rcall	.-1792   	; 0x6ce <mc_line>

  // Activate the probing state monitor in the stepper module.
  sys_probe_state = PROBE_ACTIVE;
     dce:	81 e0       	ldi	r24, 0x01	; 1
     dd0:	80 93 32 0c 	sts	0x0C32, r24	; 0x800c32 <sys_probe_state>

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
     dd4:	82 e0       	ldi	r24, 0x02	; 2
     dd6:	0e 94 d0 3b 	call	0x77a0	; 0x77a0 <system_set_exec_state_flag>
  do {
    protocol_execute_realtime();
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
     dda:	ce e1       	ldi	r28, 0x1E	; 30
     ddc:	dc e0       	ldi	r29, 0x0C	; 12
  sys_probe_state = PROBE_ACTIVE;

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
  do {
    protocol_execute_realtime();
     dde:	0e 94 66 17 	call	0x2ecc	; 0x2ecc <protocol_execute_realtime>
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
     de2:	89 81       	ldd	r24, Y+1	; 0x01
     de4:	81 11       	cpse	r24, r1
     de6:	32 c0       	rjmp	.+100    	; 0xe4c <mc_probe_cycle+0xd8>
  } while (sys.state != STATE_IDLE);
     de8:	88 81       	ld	r24, Y
     dea:	81 11       	cpse	r24, r1
     dec:	f8 cf       	rjmp	.-16     	; 0xdde <mc_probe_cycle+0x6a>

  // Probing cycle complete!

  // Set state variables and error out, if the probe failed and cycle with error is enabled.
  if (sys_probe_state == PROBE_ACTIVE) {
     dee:	80 91 32 0c 	lds	r24, 0x0C32	; 0x800c32 <sys_probe_state>
     df2:	81 30       	cpi	r24, 0x01	; 1
     df4:	81 f4       	brne	.+32     	; 0xe16 <mc_probe_cycle+0xa2>
    if (is_no_error) { memcpy(sys_probe_position, sys_position, sizeof(sys_position)); }
     df6:	d4 fe       	sbrs	r13, 4
     df8:	0a c0       	rjmp	.+20     	; 0xe0e <mc_probe_cycle+0x9a>
     dfa:	8c e0       	ldi	r24, 0x0C	; 12
     dfc:	e3 e4       	ldi	r30, 0x43	; 67
     dfe:	fc e0       	ldi	r31, 0x0C	; 12
     e00:	a7 e3       	ldi	r26, 0x37	; 55
     e02:	bc e0       	ldi	r27, 0x0C	; 12
     e04:	01 90       	ld	r0, Z+
     e06:	0d 92       	st	X+, r0
     e08:	8a 95       	dec	r24
     e0a:	e1 f7       	brne	.-8      	; 0xe04 <mc_probe_cycle+0x90>
     e0c:	07 c0       	rjmp	.+14     	; 0xe1c <mc_probe_cycle+0xa8>
    else { system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_CONTACT); }
     e0e:	85 e0       	ldi	r24, 0x05	; 5
     e10:	0e 94 38 3e 	call	0x7c70	; 0x7c70 <system_set_exec_alarm>
     e14:	03 c0       	rjmp	.+6      	; 0xe1c <mc_probe_cycle+0xa8>
  } else {
    sys.probe_succeeded = true; // Indicate to system the probing cycle completed successfully.
     e16:	81 e0       	ldi	r24, 0x01	; 1
     e18:	80 93 23 0c 	sts	0x0C23, r24	; 0x800c23 <sys+0x5>
  }
  sys_probe_state = PROBE_OFF; // Ensure probe state monitor is disabled.
     e1c:	10 92 32 0c 	sts	0x0C32, r1	; 0x800c32 <sys_probe_state>
  probe_configure_invert_mask(false); // Re-initialize invert mask.
     e20:	80 e0       	ldi	r24, 0x00	; 0
     e22:	0e 94 de 34 	call	0x69bc	; 0x69bc <probe_configure_invert_mask>
  protocol_execute_realtime();   // Check and execute run-time commands
     e26:	0e 94 66 17 	call	0x2ecc	; 0x2ecc <protocol_execute_realtime>

  // Reset the stepper and planner buffers to remove the remainder of the probe motion.
  st_reset(); // Reset step segment buffer.
     e2a:	0e 94 db 1b 	call	0x37b6	; 0x37b6 <st_reset>
  plan_reset(); // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
     e2e:	0e 94 61 29 	call	0x52c2	; 0x52c2 <plan_reset>
  plan_sync_position(); // Sync planner position to current machine position.
     e32:	0e 94 09 2e 	call	0x5c12	; 0x5c12 <plan_sync_position>
// Perform tool length probe cycle. Requires probe switch.
// NOTE: Upon probe failure, the program will be stopped and placed into ALARM state.
uint8_t mc_probe_cycle(float *target, plan_line_data_t *pl_data, uint8_t parser_flags)
{
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return(GC_PROBE_CHECK_MODE); }
     e36:	81 e0       	ldi	r24, 0x01	; 1
     e38:	90 91 23 0c 	lds	r25, 0x0C23	; 0x800c23 <sys+0x5>
     e3c:	91 11       	cpse	r25, r1
     e3e:	07 c0       	rjmp	.+14     	; 0xe4e <mc_probe_cycle+0xda>
     e40:	80 e0       	ldi	r24, 0x00	; 0
     e42:	05 c0       	rjmp	.+10     	; 0xe4e <mc_probe_cycle+0xda>
     e44:	80 e0       	ldi	r24, 0x00	; 0
     e46:	03 c0       	rjmp	.+6      	; 0xe4e <mc_probe_cycle+0xda>

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
  if (sys.abort) { return(GC_PROBE_ABORT); } // Return if system reset has been issued.
     e48:	82 e0       	ldi	r24, 0x02	; 2
     e4a:	01 c0       	rjmp	.+2      	; 0xe4e <mc_probe_cycle+0xda>

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
  do {
    protocol_execute_realtime();
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
     e4c:	82 e0       	ldi	r24, 0x02	; 2
    report_probe_parameters();
  #endif

  if (sys.probe_succeeded) { return(GC_PROBE_FOUND); } // Successful probe cycle.
  else { return(GC_PROBE_FAIL_END); } // Failed to trigger probe within travel. With or without error.
}
     e4e:	df 91       	pop	r29
     e50:	cf 91       	pop	r28
     e52:	1f 91       	pop	r17
     e54:	0f 91       	pop	r16
     e56:	ff 90       	pop	r15
     e58:	ef 90       	pop	r14
     e5a:	df 90       	pop	r13
     e5c:	08 95       	ret

00000e5e <mc_reset>:
// lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
// realtime abort command and hard limits. So, keep to a minimum.
void mc_reset()
{
  // Only this function can set the system reset. Helps prevent multiple kill calls.
  if (bit_isfalse(sys_rt_exec_state, EXEC_RESET)) {
     e5e:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
     e62:	84 fd       	sbrc	r24, 4
     e64:	1f c0       	rjmp	.+62     	; 0xea4 <mc_reset+0x46>
    system_set_exec_state_flag(EXEC_RESET);
     e66:	80 e1       	ldi	r24, 0x10	; 16
     e68:	0e 94 d0 3b 	call	0x77a0	; 0x77a0 <system_set_exec_state_flag>

    // Kill spindle and coolant.
    spindle_stop();
     e6c:	0e 94 86 12 	call	0x250c	; 0x250c <spindle_stop>
    coolant_stop();
     e70:	0e 94 ca 13 	call	0x2794	; 0x2794 <coolant_stop>

    // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
    // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
    // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
    // violated, by which, all bets are off.
    if ((sys.state & (STATE_CYCLE | STATE_HOMING | STATE_JOG)) ||
     e74:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
     e78:	98 2f       	mov	r25, r24
     e7a:	9c 72       	andi	r25, 0x2C	; 44
     e7c:	21 f4       	brne	.+8      	; 0xe86 <mc_reset+0x28>
     e7e:	90 91 22 0c 	lds	r25, 0x0C22	; 0x800c22 <sys+0x4>
     e82:	96 70       	andi	r25, 0x06	; 6
     e84:	79 f0       	breq	.+30     	; 0xea4 <mc_reset+0x46>
    		(sys.step_control & (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION))) {
      if (sys.state == STATE_HOMING) { 
     e86:	84 30       	cpi	r24, 0x04	; 4
     e88:	41 f4       	brne	.+16     	; 0xe9a <mc_reset+0x3c>
        if (!sys_rt_exec_alarm) {system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_RESET); }
     e8a:	80 91 53 0c 	lds	r24, 0x0C53	; 0x800c53 <sys_rt_exec_alarm>
     e8e:	81 11       	cpse	r24, r1
     e90:	07 c0       	rjmp	.+14     	; 0xea0 <mc_reset+0x42>
     e92:	86 e0       	ldi	r24, 0x06	; 6
     e94:	0e 94 38 3e 	call	0x7c70	; 0x7c70 <system_set_exec_alarm>
     e98:	03 c0       	rjmp	.+6      	; 0xea0 <mc_reset+0x42>
      } else { system_set_exec_alarm(EXEC_ALARM_ABORT_CYCLE); }
     e9a:	83 e0       	ldi	r24, 0x03	; 3
     e9c:	0e 94 38 3e 	call	0x7c70	; 0x7c70 <system_set_exec_alarm>
      st_go_idle(); // Force kill steppers. Position has likely been lost.
     ea0:	0c 94 59 19 	jmp	0x32b2	; 0x32b2 <st_go_idle>
     ea4:	08 95       	ret

00000ea6 <gc_init>:
#define FAIL(status) return(status);


void gc_init()
{
  memset(&gc_state, 0, sizeof(parser_state_t));
     ea6:	80 e4       	ldi	r24, 0x40	; 64
     ea8:	e6 e5       	ldi	r30, 0x56	; 86
     eaa:	fc e0       	ldi	r31, 0x0C	; 12
     eac:	df 01       	movw	r26, r30
     eae:	1d 92       	st	X+, r1
     eb0:	8a 95       	dec	r24
     eb2:	e9 f7       	brne	.-6      	; 0xeae <gc_init+0x8>

  // Load default G54 coordinate system.
  if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) {
     eb4:	6a e7       	ldi	r22, 0x7A	; 122
     eb6:	7c e0       	ldi	r23, 0x0C	; 12
     eb8:	80 e0       	ldi	r24, 0x00	; 0
     eba:	0e 94 1c 26 	call	0x4c38	; 0x4c38 <settings_read_coord_data>
     ebe:	81 11       	cpse	r24, r1
     ec0:	03 c0       	rjmp	.+6      	; 0xec8 <gc_init+0x22>
    report_status_message(STATUS_SETTING_READ_FAIL);
     ec2:	87 e0       	ldi	r24, 0x07	; 7
     ec4:	0c 94 60 35 	jmp	0x6ac0	; 0x6ac0 <report_status_message>
     ec8:	08 95       	ret

00000eca <gc_sync_position>:

// Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
// limit pull-off routines.
void gc_sync_position()
{
  system_convert_array_steps_to_mpos(gc_state.position,sys_position);
     eca:	63 e4       	ldi	r22, 0x43	; 67
     ecc:	7c e0       	ldi	r23, 0x0C	; 12
     ece:	8e e6       	ldi	r24, 0x6E	; 110
     ed0:	9c e0       	ldi	r25, 0x0C	; 12
     ed2:	0c 94 51 3b 	jmp	0x76a2	; 0x76a2 <system_convert_array_steps_to_mpos>
     ed6:	08 95       	ret

00000ed8 <gc_execute_line>:
// characters and signed floating point values (no whitespace). Comments and block delete
// characters have been removed. In this function, all units and positions are converted and
// exported to grbl's internal functions in terms of (mm, mm/min) and absolute machine
// coordinates, respectively.
uint8_t gc_execute_line(char *line)
{
     ed8:	2f 92       	push	r2
     eda:	3f 92       	push	r3
     edc:	4f 92       	push	r4
     ede:	5f 92       	push	r5
     ee0:	6f 92       	push	r6
     ee2:	7f 92       	push	r7
     ee4:	8f 92       	push	r8
     ee6:	9f 92       	push	r9
     ee8:	af 92       	push	r10
     eea:	bf 92       	push	r11
     eec:	cf 92       	push	r12
     eee:	df 92       	push	r13
     ef0:	ef 92       	push	r14
     ef2:	ff 92       	push	r15
     ef4:	0f 93       	push	r16
     ef6:	1f 93       	push	r17
     ef8:	cf 93       	push	r28
     efa:	df 93       	push	r29
     efc:	cd b7       	in	r28, 0x3d	; 61
     efe:	de b7       	in	r29, 0x3e	; 62
     f00:	e1 97       	sbiw	r28, 0x31	; 49
     f02:	0f b6       	in	r0, 0x3f	; 63
     f04:	f8 94       	cli
     f06:	de bf       	out	0x3e, r29	; 62
     f08:	0f be       	out	0x3f, r0	; 63
     f0a:	cd bf       	out	0x3d, r28	; 61
     f0c:	8c 01       	movw	r16, r24
     updates these modes and commands as the block line is parser and will only be used and
     executed after successful error-checking. The parser block struct also contains a block
     values struct, word tracking variables, and a non-modal commands tracker for the new
     block. This struct contains all of the necessary information to execute the block. */

  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
     f0e:	8a e3       	ldi	r24, 0x3A	; 58
     f10:	e6 e9       	ldi	r30, 0x96	; 150
     f12:	fc e0       	ldi	r31, 0x0C	; 12
     f14:	df 01       	movw	r26, r30
     f16:	1d 92       	st	X+, r1
     f18:	8a 95       	dec	r24
     f1a:	e9 f7       	brne	.-6      	; 0xf16 <gc_execute_line+0x3e>
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
     f1c:	8b e0       	ldi	r24, 0x0B	; 11
     f1e:	e6 e5       	ldi	r30, 0x56	; 86
     f20:	fc e0       	ldi	r31, 0x0C	; 12
     f22:	a7 e9       	ldi	r26, 0x97	; 151
     f24:	bc e0       	ldi	r27, 0x0C	; 12
     f26:	01 90       	ld	r0, Z+
     f28:	0d 92       	st	X+, r0
     f2a:	8a 95       	dec	r24
     f2c:	e1 f7       	brne	.-8      	; 0xf26 <gc_execute_line+0x4e>
  uint16_t command_words = 0; // Tracks G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Tracks value words.
  uint8_t gc_parser_flags = GC_PARSER_NONE;

  // Determine if the line is a jogging motion or a normal g-code block.
  if (line[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
     f2e:	f8 01       	movw	r30, r16
     f30:	80 81       	ld	r24, Z
     f32:	84 32       	cpi	r24, 0x24	; 36
     f34:	11 f0       	breq	.+4      	; 0xf3a <gc_execute_line+0x62>
     f36:	0c 94 13 12 	jmp	0x2426	; 0x2426 <__stack+0x227>
    // Set G1 and G94 enforced modes to ensure accurate error checks.
    gc_parser_flags |= GC_PARSER_JOG_MOTION;
    gc_block.modal.motion = MOTION_MODE_LINEAR;
     f3a:	e6 e9       	ldi	r30, 0x96	; 150
     f3c:	fc e0       	ldi	r31, 0x0C	; 12
     f3e:	81 e0       	ldi	r24, 0x01	; 1
     f40:	81 83       	std	Z+1, r24	; 0x01
    gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
     f42:	12 82       	std	Z+2, r1	; 0x02
  uint8_t char_counter;
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
     f44:	83 e0       	ldi	r24, 0x03	; 3
     f46:	89 83       	std	Y+1, r24	; 0x01
  uint8_t gc_parser_flags = GC_PARSER_NONE;

  // Determine if the line is a jogging motion or a normal g-code block.
  if (line[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
    // Set G1 and G94 enforced modes to ensure accurate error checks.
    gc_parser_flags |= GC_PARSER_JOG_MOTION;
     f48:	f1 e0       	ldi	r31, 0x01	; 1
     f4a:	fc a3       	std	Y+36, r31	; 0x24
						if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
						gc_block.values.t = int_value;
						break;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
     f4c:	21 2c       	mov	r2, r1
     f4e:	31 2c       	mov	r3, r1
     f50:	e1 2c       	mov	r14, r1
     f52:	f1 2c       	mov	r15, r1
     f54:	1b a2       	std	Y+35, r1	; 0x23
     f56:	19 a2       	std	Y+33, r1	; 0x21
     f58:	1a a2       	std	Y+34, r1	; 0x22
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
     f5a:	cc 24       	eor	r12, r12
     f5c:	c3 94       	inc	r12
     f5e:	d1 2c       	mov	r13, r1

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
     f60:	0f 2e       	mov	r0, r31
     f62:	f1 e6       	ldi	r31, 0x61	; 97
     f64:	8f 2e       	mov	r8, r31
     f66:	f3 e0       	ldi	r31, 0x03	; 3
     f68:	9f 2e       	mov	r9, r31
     f6a:	f0 2d       	mov	r31, r0
     f6c:	18 a3       	std	Y+32, r17	; 0x20
     f6e:	0f 8f       	std	Y+31, r16	; 0x1f
     f70:	37 c2       	rjmp	.+1134   	; 0x13e0 <gc_execute_line+0x508>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.

    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
     f72:	9f eb       	ldi	r25, 0xBF	; 191
     f74:	91 0f       	add	r25, r17
     f76:	9a 31       	cpi	r25, 0x1A	; 26
     f78:	10 f0       	brcs	.+4      	; 0xf7e <gc_execute_line+0xa6>
     f7a:	0c 94 a5 11 	jmp	0x234a	; 0x234a <__stack+0x14b>
    char_counter++;
     f7e:	8f 5f       	subi	r24, 0xFF	; 255
     f80:	89 83       	std	Y+1, r24	; 0x01
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
     f82:	ae 01       	movw	r20, r28
     f84:	4e 5f       	subi	r20, 0xFE	; 254
     f86:	5f 4f       	sbci	r21, 0xFF	; 255
     f88:	be 01       	movw	r22, r28
     f8a:	6f 5f       	subi	r22, 0xFF	; 255
     f8c:	7f 4f       	sbci	r23, 0xFF	; 255
     f8e:	8f 8d       	ldd	r24, Y+31	; 0x1f
     f90:	98 a1       	ldd	r25, Y+32	; 0x20
     f92:	0e 94 2f 2e 	call	0x5c5e	; 0x5c5e <read_float>
     f96:	88 23       	and	r24, r24
     f98:	11 f4       	brne	.+4      	; 0xf9e <gc_execute_line+0xc6>
     f9a:	0c 94 a7 11 	jmp	0x234e	; 0x234e <__stack+0x14f>
    // accurate than the NIST gcode requirement of x10 when used for commands, but not quite
    // accurate enough for value words that require integers to within 0.0001. This should be
    // a good enough comprimise and catch most all non-integer errors. To make it compliant,
    // we would simply need to change the mantissa to int16, but this add compiled flash space.
    // Maybe update this later.
    int_value = trunc(value);
     f9e:	4a 80       	ldd	r4, Y+2	; 0x02
     fa0:	5b 80       	ldd	r5, Y+3	; 0x03
     fa2:	6c 80       	ldd	r6, Y+4	; 0x04
     fa4:	7d 80       	ldd	r7, Y+5	; 0x05
     fa6:	c3 01       	movw	r24, r6
     fa8:	b2 01       	movw	r22, r4
     faa:	0e 94 ac 42 	call	0x8558	; 0x8558 <trunc>
     fae:	0e 94 14 40 	call	0x8028	; 0x8028 <__fixunssfsi>
     fb2:	a6 2e       	mov	r10, r22
    mantissa =  round(100*(value - int_value)); // Compute mantissa for Gxx.x commands.
     fb4:	70 e0       	ldi	r23, 0x00	; 0
     fb6:	80 e0       	ldi	r24, 0x00	; 0
     fb8:	90 e0       	ldi	r25, 0x00	; 0
     fba:	0e 94 42 40 	call	0x8084	; 0x8084 <__floatsisf>
     fbe:	9b 01       	movw	r18, r22
     fc0:	ac 01       	movw	r20, r24
     fc2:	c3 01       	movw	r24, r6
     fc4:	b2 01       	movw	r22, r4
     fc6:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
     fca:	20 e0       	ldi	r18, 0x00	; 0
     fcc:	30 e0       	ldi	r19, 0x00	; 0
     fce:	48 ec       	ldi	r20, 0xC8	; 200
     fd0:	52 e4       	ldi	r21, 0x42	; 66
     fd2:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
     fd6:	0e 94 41 42 	call	0x8482	; 0x8482 <round>
     fda:	0e 94 14 40 	call	0x8028	; 0x8028 <__fixunssfsi>
     fde:	86 2f       	mov	r24, r22
     fe0:	97 2f       	mov	r25, r23
     fe2:	9c 01       	movw	r18, r24
    // NOTE: Rounding must be used to catch small floating point errors.

    // Check if the g-code word is supported or errors due to modal group violations or has
    // been repeated in the g-code block. If ok, update the command or record its value.
    switch(letter) {
     fe4:	17 34       	cpi	r17, 0x47	; 71
     fe6:	21 f0       	breq	.+8      	; 0xff0 <gc_execute_line+0x118>
     fe8:	1d 34       	cpi	r17, 0x4D	; 77
     fea:	09 f4       	brne	.+2      	; 0xfee <gc_execute_line+0x116>
     fec:	c9 c0       	rjmp	.+402    	; 0x1180 <gc_execute_line+0x2a8>
     fee:	30 c1       	rjmp	.+608    	; 0x1250 <gc_execute_line+0x378>
      /* 'G' and 'M' Command Words: Parse commands and check for modal group violations.
         NOTE: Modal group numbers are defined in Table 4 of NIST RS274-NGC v3, pg.20 */

      case 'G':
        // Determine 'G' command and its modal group
        switch(int_value) {
     ff0:	8a 2d       	mov	r24, r10
     ff2:	90 e0       	ldi	r25, 0x00	; 0
     ff4:	8f 35       	cpi	r24, 0x5F	; 95
     ff6:	91 05       	cpc	r25, r1
     ff8:	10 f0       	brcs	.+4      	; 0xffe <gc_execute_line+0x126>
     ffa:	0c 94 a9 11 	jmp	0x2352	; 0x2352 <__stack+0x153>
     ffe:	fc 01       	movw	r30, r24
    1000:	88 27       	eor	r24, r24
    1002:	ee 58       	subi	r30, 0x8E	; 142
    1004:	ff 4f       	sbci	r31, 0xFF	; 255
    1006:	8f 4f       	sbci	r24, 0xFF	; 255
    1008:	0c 94 ed 42 	jmp	0x85da	; 0x85da <__tablejump2__>
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
    100c:	21 15       	cp	r18, r1
    100e:	31 05       	cpc	r19, r1
    1010:	11 f0       	breq	.+4      	; 0x1016 <gc_execute_line+0x13e>
    1012:	0c 94 17 12 	jmp	0x242e	; 0x242e <__stack+0x22f>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    1016:	4a a1       	ldd	r20, Y+34	; 0x22
    1018:	44 23       	and	r20, r20
    101a:	11 f4       	brne	.+4      	; 0x1020 <gc_execute_line+0x148>
    101c:	0c 94 1f 12 	jmp	0x243e	; 0x243e <__stack+0x23f>
    1020:	0c 94 ab 11 	jmp	0x2356	; 0x2356 <__stack+0x157>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
    1024:	a6 e9       	ldi	r26, 0x96	; 150
    1026:	bc e0       	ldi	r27, 0x0C	; 12
    1028:	ac 92       	st	X, r10
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
    102a:	bc e1       	ldi	r27, 0x1C	; 28
    102c:	ab 16       	cp	r10, r27
    102e:	31 f0       	breq	.+12     	; 0x103c <gc_execute_line+0x164>
    1030:	ee e1       	ldi	r30, 0x1E	; 30
    1032:	ae 16       	cp	r10, r30
    1034:	19 f0       	breq	.+6      	; 0x103c <gc_execute_line+0x164>
    1036:	fc e5       	ldi	r31, 0x5C	; 92
    1038:	af 12       	cpse	r10, r31
    103a:	8b c0       	rjmp	.+278    	; 0x1152 <gc_execute_line+0x27a>
              if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
    103c:	21 15       	cp	r18, r1
    103e:	31 05       	cpc	r19, r1
    1040:	51 f0       	breq	.+20     	; 0x1056 <gc_execute_line+0x17e>
    1042:	2a 30       	cpi	r18, 0x0A	; 10
    1044:	31 05       	cpc	r19, r1
    1046:	39 f0       	breq	.+14     	; 0x1056 <gc_execute_line+0x17e>
    1048:	0c 94 ad 11 	jmp	0x235a	; 0x235a <__stack+0x15b>
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
    104c:	21 e0       	ldi	r18, 0x01	; 1
    104e:	2a a3       	std	Y+34, r18	; 0x22
    1050:	02 c0       	rjmp	.+4      	; 0x1056 <gc_execute_line+0x17e>
    1052:	31 e0       	ldi	r19, 0x01	; 1
    1054:	3a a3       	std	Y+34, r19	; 0x22
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
              if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
              gc_block.non_modal_command += mantissa;
    1056:	6a 0d       	add	r22, r10
    1058:	a6 e9       	ldi	r26, 0x96	; 150
    105a:	bc e0       	ldi	r27, 0x0C	; 12
    105c:	6c 93       	st	X, r22
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
    105e:	80 e0       	ldi	r24, 0x00	; 0
    1060:	7f c0       	rjmp	.+254    	; 0x1160 <gc_execute_line+0x288>
            }                
            break;
          case 0: case 1: case 2: case 3: case 38:
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    1062:	ba a1       	ldd	r27, Y+34	; 0x22
    1064:	b1 11       	cpse	r27, r1
    1066:	0c 94 af 11 	jmp	0x235e	; 0x235e <__stack+0x15f>
            axis_command = AXIS_COMMAND_MOTION_MODE;
    106a:	e2 e0       	ldi	r30, 0x02	; 2
    106c:	ea a3       	std	Y+34, r30	; 0x22
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
            gc_block.modal.motion = int_value;
    106e:	a0 92 97 0c 	sts	0x0C97, r10	; 0x800c97 <gc_block+0x1>
            if (int_value == 38){
    1072:	f6 e2       	ldi	r31, 0x26	; 38
    1074:	af 12       	cpse	r10, r31
    1076:	6f c0       	rjmp	.+222    	; 0x1156 <gc_execute_line+0x27e>
              if (!((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))) {
    1078:	24 31       	cpi	r18, 0x14	; 20
    107a:	31 05       	cpc	r19, r1
    107c:	59 f0       	breq	.+22     	; 0x1094 <gc_execute_line+0x1bc>
    107e:	2e 31       	cpi	r18, 0x1E	; 30
    1080:	31 05       	cpc	r19, r1
    1082:	41 f0       	breq	.+16     	; 0x1094 <gc_execute_line+0x1bc>
    1084:	28 32       	cpi	r18, 0x28	; 40
    1086:	31 05       	cpc	r19, r1
    1088:	29 f0       	breq	.+10     	; 0x1094 <gc_execute_line+0x1bc>
    108a:	22 33       	cpi	r18, 0x32	; 50
    108c:	31 05       	cpc	r19, r1
    108e:	11 f0       	breq	.+4      	; 0x1094 <gc_execute_line+0x1bc>
    1090:	0c 94 b1 11 	jmp	0x2362	; 0x2362 <__stack+0x163>
                FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
              }
              gc_block.modal.motion += (mantissa/10)+100;
    1094:	26 2f       	mov	r18, r22
    1096:	37 2f       	mov	r19, r23
    1098:	ad ec       	ldi	r26, 0xCD	; 205
    109a:	bc ec       	ldi	r27, 0xCC	; 204
    109c:	0e 94 f5 42 	call	0x85ea	; 0x85ea <__umulhisi3>
    10a0:	96 95       	lsr	r25
    10a2:	87 95       	ror	r24
    10a4:	96 95       	lsr	r25
    10a6:	87 95       	ror	r24
    10a8:	96 95       	lsr	r25
    10aa:	87 95       	ror	r24
    10ac:	86 57       	subi	r24, 0x76	; 118
    10ae:	80 93 97 0c 	sts	0x0C97, r24	; 0x800c97 <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE;
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
    10b2:	81 e0       	ldi	r24, 0x01	; 1
    10b4:	55 c0       	rjmp	.+170    	; 0x1160 <gc_execute_line+0x288>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
            }  
            break;
          case 17: case 18: case 19:
            word_bit = MODAL_GROUP_G2;
            gc_block.modal.plane_select = int_value - 17;
    10b6:	6f ee       	ldi	r22, 0xEF	; 239
    10b8:	6a 0d       	add	r22, r10
    10ba:	60 93 9b 0c 	sts	0x0C9B, r22	; 0x800c9b <gc_block+0x5>
              gc_block.modal.motion += (mantissa/10)+100;
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
            }  
            break;
          case 17: case 18: case 19:
            word_bit = MODAL_GROUP_G2;
    10be:	82 e0       	ldi	r24, 0x02	; 2
            gc_block.modal.plane_select = int_value - 17;
            break;
    10c0:	4b c0       	rjmp	.+150    	; 0x1158 <gc_execute_line+0x280>
          case 90: case 91:
            if (mantissa == 0) {
    10c2:	21 15       	cp	r18, r1
    10c4:	31 05       	cpc	r19, r1
    10c6:	31 f4       	brne	.+12     	; 0x10d4 <gc_execute_line+0x1fc>
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
    10c8:	66 ea       	ldi	r22, 0xA6	; 166
    10ca:	6a 0d       	add	r22, r10
    10cc:	60 93 9a 0c 	sts	0x0C9A, r22	; 0x800c9a <gc_block+0x4>
            word_bit = MODAL_GROUP_G2;
            gc_block.modal.plane_select = int_value - 17;
            break;
          case 90: case 91:
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
    10d0:	83 e0       	ldi	r24, 0x03	; 3
    10d2:	46 c0       	rjmp	.+140    	; 0x1160 <gc_execute_line+0x288>
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
    10d4:	2a 30       	cpi	r18, 0x0A	; 10
    10d6:	31 05       	cpc	r19, r1
    10d8:	11 f0       	breq	.+4      	; 0x10de <gc_execute_line+0x206>
    10da:	0c 94 b3 11 	jmp	0x2366	; 0x2366 <__stack+0x167>
    10de:	2a e5       	ldi	r18, 0x5A	; 90
    10e0:	a2 16       	cp	r10, r18
    10e2:	11 f4       	brne	.+4      	; 0x10e8 <gc_execute_line+0x210>
    10e4:	0c 94 b5 11 	jmp	0x236a	; 0x236a <__stack+0x16b>
          case 90: case 91:
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
    10e8:	84 e0       	ldi	r24, 0x04	; 4
    10ea:	3a c0       	rjmp	.+116    	; 0x1160 <gc_execute_line+0x288>
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
            gc_block.modal.feed_rate = 94 - int_value;
    10ec:	8e e5       	ldi	r24, 0x5E	; 94
    10ee:	8a 19       	sub	r24, r10
    10f0:	80 93 98 0c 	sts	0x0C98, r24	; 0x800c98 <gc_block+0x2>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
    10f4:	85 e0       	ldi	r24, 0x05	; 5
            gc_block.modal.feed_rate = 94 - int_value;
            break;
    10f6:	30 c0       	rjmp	.+96     	; 0x1158 <gc_execute_line+0x280>
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
            gc_block.modal.units = 21 - int_value;
    10f8:	85 e1       	ldi	r24, 0x15	; 21
    10fa:	8a 19       	sub	r24, r10
    10fc:	80 93 99 0c 	sts	0x0C99, r24	; 0x800c99 <gc_block+0x3>
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
            gc_block.modal.feed_rate = 94 - int_value;
            break;
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
    1100:	86 e0       	ldi	r24, 0x06	; 6
            gc_block.modal.units = 21 - int_value;
            break;
    1102:	2a c0       	rjmp	.+84     	; 0x1158 <gc_execute_line+0x280>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
    1104:	4a a1       	ldd	r20, Y+34	; 0x22
    1106:	41 11       	cpse	r20, r1
    1108:	0c 94 b7 11 	jmp	0x236e	; 0x236e <__stack+0x16f>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
    110c:	81 e3       	ldi	r24, 0x31	; 49
    110e:	a8 12       	cpse	r10, r24
    1110:	06 c0       	rjmp	.+12     	; 0x111e <gc_execute_line+0x246>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
    1112:	10 92 9c 0c 	sts	0x0C9C, r1	; 0x800c9c <gc_block+0x6>
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
    1116:	88 e0       	ldi	r24, 0x08	; 8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
    1118:	93 e0       	ldi	r25, 0x03	; 3
    111a:	9a a3       	std	Y+34, r25	; 0x22
    111c:	21 c0       	rjmp	.+66     	; 0x1160 <gc_execute_line+0x288>
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
            } else if (mantissa == 10) { // G43.1
    111e:	2a 30       	cpi	r18, 0x0A	; 10
    1120:	31 05       	cpc	r19, r1
    1122:	11 f0       	breq	.+4      	; 0x1128 <gc_execute_line+0x250>
    1124:	0c 94 b9 11 	jmp	0x2372	; 0x2372 <__stack+0x173>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
    1128:	a1 e0       	ldi	r26, 0x01	; 1
    112a:	a0 93 9c 0c 	sts	0x0C9C, r26	; 0x800c9c <gc_block+0x6>
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
    112e:	88 e0       	ldi	r24, 0x08	; 8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
    1130:	b3 e0       	ldi	r27, 0x03	; 3
    1132:	ba a3       	std	Y+34, r27	; 0x22
    1134:	15 c0       	rjmp	.+42     	; 0x1160 <gc_execute_line+0x288>
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59:
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
    1136:	6a ec       	ldi	r22, 0xCA	; 202
    1138:	6a 0d       	add	r22, r10
    113a:	60 93 9d 0c 	sts	0x0C9D, r22	; 0x800c9d <gc_block+0x7>
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59:
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
    113e:	89 e0       	ldi	r24, 0x09	; 9
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
            break;
    1140:	0b c0       	rjmp	.+22     	; 0x1158 <gc_execute_line+0x280>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
    1142:	23 2b       	or	r18, r19
    1144:	11 f0       	breq	.+4      	; 0x114a <gc_execute_line+0x272>
    1146:	0c 94 bb 11 	jmp	0x2376	; 0x2376 <__stack+0x177>
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
    114a:	8a e0       	ldi	r24, 0x0A	; 10
    114c:	09 c0       	rjmp	.+18     	; 0x1160 <gc_execute_line+0x288>
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
            gc_block.modal.units = 21 - int_value;
            break;
          case 40:
            word_bit = MODAL_GROUP_G7;
    114e:	87 e0       	ldi	r24, 0x07	; 7
    1150:	03 c0       	rjmp	.+6      	; 0x1158 <gc_execute_line+0x280>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
    1152:	80 e0       	ldi	r24, 0x00	; 0
    1154:	01 c0       	rjmp	.+2      	; 0x1158 <gc_execute_line+0x280>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE;
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
    1156:	81 e0       	ldi	r24, 0x01	; 1
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    1158:	23 2b       	or	r18, r19
    115a:	11 f0       	breq	.+4      	; 0x1160 <gc_execute_line+0x288>
    115c:	0c 94 bd 11 	jmp	0x237a	; 0x237a <__stack+0x17b>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1160:	f6 01       	movw	r30, r12
    1162:	02 c0       	rjmp	.+4      	; 0x1168 <gc_execute_line+0x290>
    1164:	ee 0f       	add	r30, r30
    1166:	ff 1f       	adc	r31, r31
    1168:	8a 95       	dec	r24
    116a:	e2 f7       	brpl	.-8      	; 0x1164 <gc_execute_line+0x28c>
    116c:	97 01       	movw	r18, r14
    116e:	2e 23       	and	r18, r30
    1170:	3f 23       	and	r19, r31
    1172:	23 2b       	or	r18, r19
    1174:	11 f0       	breq	.+4      	; 0x117a <gc_execute_line+0x2a2>
    1176:	0c 94 bf 11 	jmp	0x237e	; 0x237e <__stack+0x17f>
        command_words |= bit(word_bit);
    117a:	ee 2a       	or	r14, r30
    117c:	ff 2a       	or	r15, r31
        break;
    117e:	30 c1       	rjmp	.+608    	; 0x13e0 <gc_execute_line+0x508>

      case 'M':

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    1180:	23 2b       	or	r18, r19
    1182:	11 f0       	breq	.+4      	; 0x1188 <gc_execute_line+0x2b0>
    1184:	0c 94 c1 11 	jmp	0x2382	; 0x2382 <__stack+0x183>
        switch(int_value) {
    1188:	8a 2d       	mov	r24, r10
    118a:	90 e0       	ldi	r25, 0x00	; 0
    118c:	8f 31       	cpi	r24, 0x1F	; 31
    118e:	91 05       	cpc	r25, r1
    1190:	10 f0       	brcs	.+4      	; 0x1196 <gc_execute_line+0x2be>
    1192:	0c 94 c3 11 	jmp	0x2386	; 0x2386 <__stack+0x187>
    1196:	fc 01       	movw	r30, r24
    1198:	88 27       	eor	r24, r24
    119a:	ef 52       	subi	r30, 0x2F	; 47
    119c:	ff 4f       	sbci	r31, 0xFF	; 255
    119e:	8f 4f       	sbci	r24, 0xFF	; 255
    11a0:	0c 94 ed 42 	jmp	0x85da	; 0x85da <__tablejump2__>
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
            switch(int_value) {
    11a4:	aa 20       	and	r10, r10
    11a6:	21 f0       	breq	.+8      	; 0x11b0 <gc_execute_line+0x2d8>
    11a8:	f1 e0       	ldi	r31, 0x01	; 1
    11aa:	af 16       	cp	r10, r31
    11ac:	e1 f1       	breq	.+120    	; 0x1226 <gc_execute_line+0x34e>
    11ae:	05 c0       	rjmp	.+10     	; 0x11ba <gc_execute_line+0x2e2>
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
    11b0:	23 e0       	ldi	r18, 0x03	; 3
    11b2:	20 93 9e 0c 	sts	0x0C9E, r18	; 0x800c9e <gc_block+0x8>

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
    11b6:	8b e0       	ldi	r24, 0x0B	; 11
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
    11b8:	3b c0       	rjmp	.+118    	; 0x1230 <gc_execute_line+0x358>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
    11ba:	a0 92 9e 0c 	sts	0x0C9E, r10	; 0x800c9e <gc_block+0x8>

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
    11be:	8b e0       	ldi	r24, 0x0B	; 11
    11c0:	37 c0       	rjmp	.+110    	; 0x1230 <gc_execute_line+0x358>
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
            switch(int_value) {
    11c2:	34 e0       	ldi	r19, 0x04	; 4
    11c4:	a3 16       	cp	r10, r19
    11c6:	59 f0       	breq	.+22     	; 0x11de <gc_execute_line+0x306>
    11c8:	45 e0       	ldi	r20, 0x05	; 5
    11ca:	a4 16       	cp	r10, r20
    11cc:	69 f0       	breq	.+26     	; 0x11e8 <gc_execute_line+0x310>
    11ce:	83 e0       	ldi	r24, 0x03	; 3
    11d0:	a8 12       	cpse	r10, r24
    11d2:	2b c0       	rjmp	.+86     	; 0x122a <gc_execute_line+0x352>
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    11d4:	80 e1       	ldi	r24, 0x10	; 16
    11d6:	80 93 a0 0c 	sts	0x0CA0, r24	; 0x800ca0 <gc_block+0xa>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
    11da:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    11dc:	29 c0       	rjmp	.+82     	; 0x1230 <gc_execute_line+0x358>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    11de:	80 e2       	ldi	r24, 0x20	; 32
    11e0:	80 93 a0 0c 	sts	0x0CA0, r24	; 0x800ca0 <gc_block+0xa>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
    11e4:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    11e6:	24 c0       	rjmp	.+72     	; 0x1230 <gc_execute_line+0x358>
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    11e8:	10 92 a0 0c 	sts	0x0CA0, r1	; 0x800ca0 <gc_block+0xa>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
    11ec:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    11ee:	20 c0       	rjmp	.+64     	; 0x1230 <gc_execute_line+0x358>
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
            switch(int_value) {      
    11f0:	98 e0       	ldi	r25, 0x08	; 8
    11f2:	a9 16       	cp	r10, r25
    11f4:	69 f0       	breq	.+26     	; 0x1210 <gc_execute_line+0x338>
    11f6:	a9 e0       	ldi	r26, 0x09	; 9
    11f8:	aa 16       	cp	r10, r26
    11fa:	89 f0       	breq	.+34     	; 0x121e <gc_execute_line+0x346>
    11fc:	b7 e0       	ldi	r27, 0x07	; 7
    11fe:	ab 12       	cpse	r10, r27
    1200:	16 c0       	rjmp	.+44     	; 0x122e <gc_execute_line+0x356>
              case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
    1202:	80 91 9f 0c 	lds	r24, 0x0C9F	; 0x800c9f <gc_block+0x9>
    1206:	80 68       	ori	r24, 0x80	; 128
    1208:	80 93 9f 0c 	sts	0x0C9F, r24	; 0x800c9f <gc_block+0x9>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    120c:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {      
              case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
    120e:	10 c0       	rjmp	.+32     	; 0x1230 <gc_execute_line+0x358>
              case 8: gc_block.modal.coolant |= COOLANT_FLOOD_ENABLE; break;
    1210:	80 91 9f 0c 	lds	r24, 0x0C9F	; 0x800c9f <gc_block+0x9>
    1214:	80 64       	ori	r24, 0x40	; 64
    1216:	80 93 9f 0c 	sts	0x0C9F, r24	; 0x800c9f <gc_block+0x9>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    121a:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {      
              case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
              case 8: gc_block.modal.coolant |= COOLANT_FLOOD_ENABLE; break;
    121c:	09 c0       	rjmp	.+18     	; 0x1230 <gc_execute_line+0x358>
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break; // M9 disables both M7 and M8.
    121e:	10 92 9f 0c 	sts	0x0C9F, r1	; 0x800c9f <gc_block+0x9>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1222:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {      
              case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
              case 8: gc_block.modal.coolant |= COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break; // M9 disables both M7 and M8.
    1224:	05 c0       	rjmp	.+10     	; 0x1230 <gc_execute_line+0x358>

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
    1226:	8b e0       	ldi	r24, 0x0B	; 11
    1228:	03 c0       	rjmp	.+6      	; 0x1230 <gc_execute_line+0x358>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
    122a:	8c e0       	ldi	r24, 0x0C	; 12
    122c:	01 c0       	rjmp	.+2      	; 0x1230 <gc_execute_line+0x358>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    122e:	8d e0       	ldi	r24, 0x0D	; 13
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
        }

        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1230:	f6 01       	movw	r30, r12
    1232:	02 c0       	rjmp	.+4      	; 0x1238 <gc_execute_line+0x360>
    1234:	ee 0f       	add	r30, r30
    1236:	ff 1f       	adc	r31, r31
    1238:	8a 95       	dec	r24
    123a:	e2 f7       	brpl	.-8      	; 0x1234 <gc_execute_line+0x35c>
    123c:	97 01       	movw	r18, r14
    123e:	2e 23       	and	r18, r30
    1240:	3f 23       	and	r19, r31
    1242:	23 2b       	or	r18, r19
    1244:	11 f0       	breq	.+4      	; 0x124a <gc_execute_line+0x372>
    1246:	0c 94 c5 11 	jmp	0x238a	; 0x238a <__stack+0x18b>
        command_words |= bit(word_bit);
    124a:	ee 2a       	or	r14, r30
    124c:	ff 2a       	or	r15, r31
        break;
    124e:	c8 c0       	rjmp	.+400    	; 0x13e0 <gc_execute_line+0x508>
      default:

        /* Non-Command Words: This initial parsing phase only checks for repeats of the remaining
           legal g-code words and stores their value. Error-checking is performed later since some
           words (I,J,K,L,P,R) have multiple connotations and/or depend on the issued commands. */
        switch(letter){
    1250:	81 2f       	mov	r24, r17
    1252:	90 e0       	ldi	r25, 0x00	; 0
    1254:	fc 01       	movw	r30, r24
    1256:	e6 54       	subi	r30, 0x46	; 70
    1258:	f1 09       	sbc	r31, r1
    125a:	e5 31       	cpi	r30, 0x15	; 21
    125c:	f1 05       	cpc	r31, r1
    125e:	10 f0       	brcs	.+4      	; 0x1264 <gc_execute_line+0x38c>
    1260:	0c 94 c7 11 	jmp	0x238e	; 0x238e <__stack+0x18f>
    1264:	88 27       	eor	r24, r24
    1266:	e0 51       	subi	r30, 0x10	; 16
    1268:	ff 4f       	sbci	r31, 0xFF	; 255
    126a:	8f 4f       	sbci	r24, 0xFF	; 255
    126c:	0c 94 ed 42 	jmp	0x85da	; 0x85da <__tablejump2__>
          // case 'A': // Not supported
          // case 'B': // Not supported
          // case 'C': // Not supported
          // case 'D': // Not supported
          case 'F': word_bit = WORD_F; gc_block.values.f = value; break;
    1270:	40 92 a2 0c 	sts	0x0CA2, r4	; 0x800ca2 <gc_block+0xc>
    1274:	50 92 a3 0c 	sts	0x0CA3, r5	; 0x800ca3 <gc_block+0xd>
    1278:	60 92 a4 0c 	sts	0x0CA4, r6	; 0x800ca4 <gc_block+0xe>
    127c:	70 92 a5 0c 	sts	0x0CA5, r7	; 0x800ca5 <gc_block+0xf>
    1280:	80 e0       	ldi	r24, 0x00	; 0
    1282:	8d c0       	rjmp	.+282    	; 0x139e <gc_execute_line+0x4c6>
          // case 'H': // Not supported
          case 'I': word_bit = WORD_I; gc_block.values.ijk[X_AXIS] = value; ijk_words |= (1<<X_AXIS); break;
    1284:	40 92 a6 0c 	sts	0x0CA6, r4	; 0x800ca6 <gc_block+0x10>
    1288:	50 92 a7 0c 	sts	0x0CA7, r5	; 0x800ca7 <gc_block+0x11>
    128c:	60 92 a8 0c 	sts	0x0CA8, r6	; 0x800ca8 <gc_block+0x12>
    1290:	70 92 a9 0c 	sts	0x0CA9, r7	; 0x800ca9 <gc_block+0x13>
    1294:	fb a1       	ldd	r31, Y+35	; 0x23
    1296:	f1 60       	ori	r31, 0x01	; 1
    1298:	fb a3       	std	Y+35, r31	; 0x23
    129a:	81 e0       	ldi	r24, 0x01	; 1
    129c:	80 c0       	rjmp	.+256    	; 0x139e <gc_execute_line+0x4c6>
          case 'J': word_bit = WORD_J; gc_block.values.ijk[Y_AXIS] = value; ijk_words |= (1<<Y_AXIS); break;
    129e:	40 92 aa 0c 	sts	0x0CAA, r4	; 0x800caa <gc_block+0x14>
    12a2:	50 92 ab 0c 	sts	0x0CAB, r5	; 0x800cab <gc_block+0x15>
    12a6:	60 92 ac 0c 	sts	0x0CAC, r6	; 0x800cac <gc_block+0x16>
    12aa:	70 92 ad 0c 	sts	0x0CAD, r7	; 0x800cad <gc_block+0x17>
    12ae:	2b a1       	ldd	r18, Y+35	; 0x23
    12b0:	22 60       	ori	r18, 0x02	; 2
    12b2:	2b a3       	std	Y+35, r18	; 0x23
    12b4:	82 e0       	ldi	r24, 0x02	; 2
    12b6:	73 c0       	rjmp	.+230    	; 0x139e <gc_execute_line+0x4c6>
          case 'K': word_bit = WORD_K; gc_block.values.ijk[Z_AXIS] = value; ijk_words |= (1<<Z_AXIS); break;
    12b8:	40 92 ae 0c 	sts	0x0CAE, r4	; 0x800cae <gc_block+0x18>
    12bc:	50 92 af 0c 	sts	0x0CAF, r5	; 0x800caf <gc_block+0x19>
    12c0:	60 92 b0 0c 	sts	0x0CB0, r6	; 0x800cb0 <gc_block+0x1a>
    12c4:	70 92 b1 0c 	sts	0x0CB1, r7	; 0x800cb1 <gc_block+0x1b>
    12c8:	3b a1       	ldd	r19, Y+35	; 0x23
    12ca:	34 60       	ori	r19, 0x04	; 4
    12cc:	3b a3       	std	Y+35, r19	; 0x23
    12ce:	83 e0       	ldi	r24, 0x03	; 3
    12d0:	66 c0       	rjmp	.+204    	; 0x139e <gc_execute_line+0x4c6>
          case 'L': word_bit = WORD_L; gc_block.values.l = int_value; break;
    12d2:	a0 92 b2 0c 	sts	0x0CB2, r10	; 0x800cb2 <gc_block+0x1c>
    12d6:	84 e0       	ldi	r24, 0x04	; 4
    12d8:	62 c0       	rjmp	.+196    	; 0x139e <gc_execute_line+0x4c6>
          case 'N': word_bit = WORD_N; gc_block.values.n = trunc(value); break;
    12da:	c3 01       	movw	r24, r6
    12dc:	b2 01       	movw	r22, r4
    12de:	0e 94 0f 40 	call	0x801e	; 0x801e <__fixsfsi>
    12e2:	60 93 b3 0c 	sts	0x0CB3, r22	; 0x800cb3 <gc_block+0x1d>
    12e6:	70 93 b4 0c 	sts	0x0CB4, r23	; 0x800cb4 <gc_block+0x1e>
    12ea:	80 93 b5 0c 	sts	0x0CB5, r24	; 0x800cb5 <gc_block+0x1f>
    12ee:	90 93 b6 0c 	sts	0x0CB6, r25	; 0x800cb6 <gc_block+0x20>
    12f2:	85 e0       	ldi	r24, 0x05	; 5
    12f4:	54 c0       	rjmp	.+168    	; 0x139e <gc_execute_line+0x4c6>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
    12f6:	40 92 b7 0c 	sts	0x0CB7, r4	; 0x800cb7 <gc_block+0x21>
    12fa:	50 92 b8 0c 	sts	0x0CB8, r5	; 0x800cb8 <gc_block+0x22>
    12fe:	60 92 b9 0c 	sts	0x0CB9, r6	; 0x800cb9 <gc_block+0x23>
    1302:	70 92 ba 0c 	sts	0x0CBA, r7	; 0x800cba <gc_block+0x24>
    1306:	86 e0       	ldi	r24, 0x06	; 6
    1308:	4a c0       	rjmp	.+148    	; 0x139e <gc_execute_line+0x4c6>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
    130a:	40 92 bb 0c 	sts	0x0CBB, r4	; 0x800cbb <gc_block+0x25>
    130e:	50 92 bc 0c 	sts	0x0CBC, r5	; 0x800cbc <gc_block+0x26>
    1312:	60 92 bd 0c 	sts	0x0CBD, r6	; 0x800cbd <gc_block+0x27>
    1316:	70 92 be 0c 	sts	0x0CBE, r7	; 0x800cbe <gc_block+0x28>
    131a:	87 e0       	ldi	r24, 0x07	; 7
    131c:	40 c0       	rjmp	.+128    	; 0x139e <gc_execute_line+0x4c6>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
    131e:	40 92 bf 0c 	sts	0x0CBF, r4	; 0x800cbf <gc_block+0x29>
    1322:	50 92 c0 0c 	sts	0x0CC0, r5	; 0x800cc0 <gc_block+0x2a>
    1326:	60 92 c1 0c 	sts	0x0CC1, r6	; 0x800cc1 <gc_block+0x2b>
    132a:	70 92 c2 0c 	sts	0x0CC2, r7	; 0x800cc2 <gc_block+0x2c>
    132e:	88 e0       	ldi	r24, 0x08	; 8
    1330:	36 c0       	rjmp	.+108    	; 0x139e <gc_execute_line+0x4c6>
          case 'T': word_bit = WORD_T; 
						if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
    1332:	20 e0       	ldi	r18, 0x00	; 0
    1334:	30 e0       	ldi	r19, 0x00	; 0
    1336:	4f e7       	ldi	r20, 0x7F	; 127
    1338:	53 e4       	ldi	r21, 0x43	; 67
    133a:	c3 01       	movw	r24, r6
    133c:	b2 01       	movw	r22, r4
    133e:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    1342:	18 16       	cp	r1, r24
    1344:	14 f4       	brge	.+4      	; 0x134a <gc_execute_line+0x472>
    1346:	0c 94 c9 11 	jmp	0x2392	; 0x2392 <__stack+0x193>
						gc_block.values.t = int_value;
    134a:	a0 92 c3 0c 	sts	0x0CC3, r10	; 0x800cc3 <gc_block+0x2d>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; 
    134e:	89 e0       	ldi	r24, 0x09	; 9
						if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
						gc_block.values.t = int_value;
						break;
    1350:	26 c0       	rjmp	.+76     	; 0x139e <gc_execute_line+0x4c6>
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
    1352:	40 92 c4 0c 	sts	0x0CC4, r4	; 0x800cc4 <gc_block+0x2e>
    1356:	50 92 c5 0c 	sts	0x0CC5, r5	; 0x800cc5 <gc_block+0x2f>
    135a:	60 92 c6 0c 	sts	0x0CC6, r6	; 0x800cc6 <gc_block+0x30>
    135e:	70 92 c7 0c 	sts	0x0CC7, r7	; 0x800cc7 <gc_block+0x31>
    1362:	49 a1       	ldd	r20, Y+33	; 0x21
    1364:	41 60       	ori	r20, 0x01	; 1
    1366:	49 a3       	std	Y+33, r20	; 0x21
    1368:	8a e0       	ldi	r24, 0x0A	; 10
    136a:	19 c0       	rjmp	.+50     	; 0x139e <gc_execute_line+0x4c6>
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
    136c:	40 92 c8 0c 	sts	0x0CC8, r4	; 0x800cc8 <gc_block+0x32>
    1370:	50 92 c9 0c 	sts	0x0CC9, r5	; 0x800cc9 <gc_block+0x33>
    1374:	60 92 ca 0c 	sts	0x0CCA, r6	; 0x800cca <gc_block+0x34>
    1378:	70 92 cb 0c 	sts	0x0CCB, r7	; 0x800ccb <gc_block+0x35>
    137c:	89 a1       	ldd	r24, Y+33	; 0x21
    137e:	82 60       	ori	r24, 0x02	; 2
    1380:	89 a3       	std	Y+33, r24	; 0x21
    1382:	8b e0       	ldi	r24, 0x0B	; 11
    1384:	0c c0       	rjmp	.+24     	; 0x139e <gc_execute_line+0x4c6>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
    1386:	40 92 cc 0c 	sts	0x0CCC, r4	; 0x800ccc <gc_block+0x36>
    138a:	50 92 cd 0c 	sts	0x0CCD, r5	; 0x800ccd <gc_block+0x37>
    138e:	60 92 ce 0c 	sts	0x0CCE, r6	; 0x800cce <gc_block+0x38>
    1392:	70 92 cf 0c 	sts	0x0CCF, r7	; 0x800ccf <gc_block+0x39>
    1396:	99 a1       	ldd	r25, Y+33	; 0x21
    1398:	94 60       	ori	r25, 0x04	; 4
    139a:	99 a3       	std	Y+33, r25	; 0x21
    139c:	8c e0       	ldi	r24, 0x0C	; 12
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        }

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    139e:	56 01       	movw	r10, r12
    13a0:	08 2e       	mov	r0, r24
    13a2:	02 c0       	rjmp	.+4      	; 0x13a8 <gc_execute_line+0x4d0>
    13a4:	aa 0c       	add	r10, r10
    13a6:	bb 1c       	adc	r11, r11
    13a8:	0a 94       	dec	r0
    13aa:	e2 f7       	brpl	.-8      	; 0x13a4 <gc_execute_line+0x4cc>
    13ac:	91 01       	movw	r18, r2
    13ae:	2a 21       	and	r18, r10
    13b0:	3b 21       	and	r19, r11
    13b2:	23 2b       	or	r18, r19
    13b4:	09 f0       	breq	.+2      	; 0x13b8 <gc_execute_line+0x4e0>
    13b6:	ef c7       	rjmp	.+4062   	; 0x2396 <__stack+0x197>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
    13b8:	d4 01       	movw	r26, r8
    13ba:	02 c0       	rjmp	.+4      	; 0x13c0 <gc_execute_line+0x4e8>
    13bc:	b5 95       	asr	r27
    13be:	a7 95       	ror	r26
    13c0:	8a 95       	dec	r24
    13c2:	e2 f7       	brpl	.-8      	; 0x13bc <gc_execute_line+0x4e4>
    13c4:	a0 ff       	sbrs	r26, 0
    13c6:	0a c0       	rjmp	.+20     	; 0x13dc <gc_execute_line+0x504>
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    13c8:	20 e0       	ldi	r18, 0x00	; 0
    13ca:	30 e0       	ldi	r19, 0x00	; 0
    13cc:	a9 01       	movw	r20, r18
    13ce:	c3 01       	movw	r24, r6
    13d0:	b2 01       	movw	r22, r4
    13d2:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    13d6:	88 23       	and	r24, r24
    13d8:	0c f4       	brge	.+2      	; 0x13dc <gc_execute_line+0x504>
    13da:	df c7       	rjmp	.+4030   	; 0x239a <__stack+0x19b>
        }
        value_words |= bit(word_bit); // Flag to indicate parameter assigned.
    13dc:	2a 28       	or	r2, r10
    13de:	3b 28       	or	r3, r11
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
  else { char_counter = 0; }

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    13e0:	89 81       	ldd	r24, Y+1	; 0x01
    13e2:	ef 8d       	ldd	r30, Y+31	; 0x1f
    13e4:	f8 a1       	ldd	r31, Y+32	; 0x20
    13e6:	e8 0f       	add	r30, r24
    13e8:	f1 1d       	adc	r31, r1
    13ea:	10 81       	ld	r17, Z
    13ec:	11 11       	cpse	r17, r1
    13ee:	c1 cd       	rjmp	.-1150   	; 0xf72 <gc_execute_line+0x9a>

  // [0. Non-specific/common error-checks and miscellaneous setup]:

  // Determine implicit axis command conditions. Axis words have been passed, but no explicit axis
  // command has been sent. If so, set axis command to current motion mode.
  if (axis_words) {
    13f0:	b9 a1       	ldd	r27, Y+33	; 0x21
    13f2:	bb 23       	and	r27, r27
    13f4:	29 f0       	breq	.+10     	; 0x1400 <gc_execute_line+0x528>
    if (!axis_command) { axis_command = AXIS_COMMAND_MOTION_MODE; } // Assign implicit motion-mode
    13f6:	ea a1       	ldd	r30, Y+34	; 0x22
    13f8:	e1 11       	cpse	r30, r1
    13fa:	02 c0       	rjmp	.+4      	; 0x1400 <gc_execute_line+0x528>
    13fc:	f2 e0       	ldi	r31, 0x02	; 2
    13fe:	fa a3       	std	Y+34, r31	; 0x22
  }

  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    1400:	25 fe       	sbrs	r2, 5
    1402:	0e c0       	rjmp	.+28     	; 0x1420 <gc_execute_line+0x548>
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    1404:	80 91 b3 0c 	lds	r24, 0x0CB3	; 0x800cb3 <gc_block+0x1d>
    1408:	90 91 b4 0c 	lds	r25, 0x0CB4	; 0x800cb4 <gc_block+0x1e>
    140c:	a0 91 b5 0c 	lds	r26, 0x0CB5	; 0x800cb5 <gc_block+0x1f>
    1410:	b0 91 b6 0c 	lds	r27, 0x0CB6	; 0x800cb6 <gc_block+0x20>
    1414:	81 38       	cpi	r24, 0x81	; 129
    1416:	96 49       	sbci	r25, 0x96	; 150
    1418:	a8 49       	sbci	r26, 0x98	; 152
    141a:	b1 05       	cpc	r27, r1
    141c:	0c f0       	brlt	.+2      	; 0x1420 <gc_execute_line+0x548>
    141e:	bf c7       	rjmp	.+3966   	; 0x239e <__stack+0x19f>
  // [1. Comments ]: MSG's NOT SUPPORTED. Comment handling performed by protocol.

  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  // NOTE: For jogging, ignore prior feed rate mode. Enforce G94 and check for required F word.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    1420:	3c a1       	ldd	r19, Y+36	; 0x24
    1422:	33 23       	and	r19, r19
    1424:	e1 f0       	breq	.+56     	; 0x145e <gc_execute_line+0x586>
    if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); }
    1426:	20 fe       	sbrs	r2, 0
    1428:	bc c7       	rjmp	.+3960   	; 0x23a2 <__stack+0x1a3>
    if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    142a:	80 91 99 0c 	lds	r24, 0x0C99	; 0x800c99 <gc_block+0x3>
    142e:	81 30       	cpi	r24, 0x01	; 1
    1430:	09 f0       	breq	.+2      	; 0x1434 <gc_execute_line+0x55c>
    1432:	54 c0       	rjmp	.+168    	; 0x14dc <gc_execute_line+0x604>
    1434:	06 e9       	ldi	r16, 0x96	; 150
    1436:	1c e0       	ldi	r17, 0x0C	; 12
    1438:	23 e3       	ldi	r18, 0x33	; 51
    143a:	33 e3       	ldi	r19, 0x33	; 51
    143c:	4b ec       	ldi	r20, 0xCB	; 203
    143e:	51 e4       	ldi	r21, 0x41	; 65
    1440:	d8 01       	movw	r26, r16
    1442:	1c 96       	adiw	r26, 0x0c	; 12
    1444:	6d 91       	ld	r22, X+
    1446:	7d 91       	ld	r23, X+
    1448:	8d 91       	ld	r24, X+
    144a:	9c 91       	ld	r25, X
    144c:	1f 97       	sbiw	r26, 0x0f	; 15
    144e:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    1452:	f8 01       	movw	r30, r16
    1454:	64 87       	std	Z+12, r22	; 0x0c
    1456:	75 87       	std	Z+13, r23	; 0x0d
    1458:	86 87       	std	Z+14, r24	; 0x0e
    145a:	97 87       	std	Z+15, r25	; 0x0f
    145c:	3f c0       	rjmp	.+126    	; 0x14dc <gc_execute_line+0x604>
  } else {
    if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    145e:	80 91 98 0c 	lds	r24, 0x0C98	; 0x800c98 <gc_block+0x2>
    1462:	81 30       	cpi	r24, 0x01	; 1
    1464:	61 f4       	brne	.+24     	; 0x147e <gc_execute_line+0x5a6>
      // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
      if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    1466:	fa a1       	ldd	r31, Y+34	; 0x22
    1468:	f2 30       	cpi	r31, 0x02	; 2
    146a:	c1 f5       	brne	.+112    	; 0x14dc <gc_execute_line+0x604>
        if ((gc_block.modal.motion != MOTION_MODE_NONE) && (gc_block.modal.motion != MOTION_MODE_SEEK)) {
    146c:	80 91 97 0c 	lds	r24, 0x0C97	; 0x800c97 <gc_block+0x1>
    1470:	80 35       	cpi	r24, 0x50	; 80
    1472:	a1 f1       	breq	.+104    	; 0x14dc <gc_execute_line+0x604>
    1474:	88 23       	and	r24, r24
    1476:	91 f1       	breq	.+100    	; 0x14dc <gc_execute_line+0x604>
          if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    1478:	20 fe       	sbrs	r2, 0
    147a:	95 c7       	rjmp	.+3882   	; 0x23a6 <__stack+0x1a7>
    147c:	2f c0       	rjmp	.+94     	; 0x14dc <gc_execute_line+0x604>
      // value in the block. If no F word is passed with a motion command that requires a feed rate, this will error
      // out in the motion modes error-checking. However, if no F word is passed with NO motion command that requires
      // a feed rate, we simply move on and the state feed rate value gets updated to zero and remains undefined.
    } else { // = G94
      // - In units per mm mode: If F word passed, ensure value is in mm/min, otherwise push last state value.
      if (gc_state.modal.feed_rate == FEED_RATE_MODE_UNITS_PER_MIN) { // Last state is also G94
    147e:	80 91 57 0c 	lds	r24, 0x0C57	; 0x800c57 <gc_state+0x1>
    1482:	81 11       	cpse	r24, r1
    1484:	2b c0       	rjmp	.+86     	; 0x14dc <gc_execute_line+0x604>
        if (bit_istrue(value_words,bit(WORD_F))) {
    1486:	20 fe       	sbrs	r2, 0
    1488:	19 c0       	rjmp	.+50     	; 0x14bc <gc_execute_line+0x5e4>
          if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    148a:	80 91 99 0c 	lds	r24, 0x0C99	; 0x800c99 <gc_block+0x3>
    148e:	81 30       	cpi	r24, 0x01	; 1
    1490:	29 f5       	brne	.+74     	; 0x14dc <gc_execute_line+0x604>
    1492:	06 e9       	ldi	r16, 0x96	; 150
    1494:	1c e0       	ldi	r17, 0x0C	; 12
    1496:	23 e3       	ldi	r18, 0x33	; 51
    1498:	33 e3       	ldi	r19, 0x33	; 51
    149a:	4b ec       	ldi	r20, 0xCB	; 203
    149c:	51 e4       	ldi	r21, 0x41	; 65
    149e:	d8 01       	movw	r26, r16
    14a0:	1c 96       	adiw	r26, 0x0c	; 12
    14a2:	6d 91       	ld	r22, X+
    14a4:	7d 91       	ld	r23, X+
    14a6:	8d 91       	ld	r24, X+
    14a8:	9c 91       	ld	r25, X
    14aa:	1f 97       	sbiw	r26, 0x0f	; 15
    14ac:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    14b0:	f8 01       	movw	r30, r16
    14b2:	64 87       	std	Z+12, r22	; 0x0c
    14b4:	75 87       	std	Z+13, r23	; 0x0d
    14b6:	86 87       	std	Z+14, r24	; 0x0e
    14b8:	97 87       	std	Z+15, r25	; 0x0f
    14ba:	10 c0       	rjmp	.+32     	; 0x14dc <gc_execute_line+0x604>
        } else {
          gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
    14bc:	80 91 65 0c 	lds	r24, 0x0C65	; 0x800c65 <gc_state+0xf>
    14c0:	90 91 66 0c 	lds	r25, 0x0C66	; 0x800c66 <gc_state+0x10>
    14c4:	a0 91 67 0c 	lds	r26, 0x0C67	; 0x800c67 <gc_state+0x11>
    14c8:	b0 91 68 0c 	lds	r27, 0x0C68	; 0x800c68 <gc_state+0x12>
    14cc:	80 93 a2 0c 	sts	0x0CA2, r24	; 0x800ca2 <gc_block+0xc>
    14d0:	90 93 a3 0c 	sts	0x0CA3, r25	; 0x800ca3 <gc_block+0xd>
    14d4:	a0 93 a4 0c 	sts	0x0CA4, r26	; 0x800ca4 <gc_block+0xe>
    14d8:	b0 93 a5 0c 	sts	0x0CA5, r27	; 0x800ca5 <gc_block+0xf>
    }
  }
  // bit_false(value_words,bit(WORD_F)); // NOTE: Single-meaning value word. Set at end of error-checking.

  // [4. Set spindle speed ]: S is negative (done.)
  if (bit_isfalse(value_words,bit(WORD_S))) { gc_block.values.s = gc_state.spindle_speed; }
    14dc:	30 fc       	sbrc	r3, 0
    14de:	10 c0       	rjmp	.+32     	; 0x1500 <gc_execute_line+0x628>
    14e0:	80 91 61 0c 	lds	r24, 0x0C61	; 0x800c61 <gc_state+0xb>
    14e4:	90 91 62 0c 	lds	r25, 0x0C62	; 0x800c62 <gc_state+0xc>
    14e8:	a0 91 63 0c 	lds	r26, 0x0C63	; 0x800c63 <gc_state+0xd>
    14ec:	b0 91 64 0c 	lds	r27, 0x0C64	; 0x800c64 <gc_state+0xe>
    14f0:	80 93 bf 0c 	sts	0x0CBF, r24	; 0x800cbf <gc_block+0x29>
    14f4:	90 93 c0 0c 	sts	0x0CC0, r25	; 0x800cc0 <gc_block+0x2a>
    14f8:	a0 93 c1 0c 	sts	0x0CC1, r26	; 0x800cc1 <gc_block+0x2b>
    14fc:	b0 93 c2 0c 	sts	0x0CC2, r27	; 0x800cc2 <gc_block+0x2c>
      }
    }
  #endif

  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    1500:	80 91 96 0c 	lds	r24, 0x0C96	; 0x800c96 <gc_block>
    1504:	84 30       	cpi	r24, 0x04	; 4
    1506:	21 f4       	brne	.+8      	; 0x1510 <gc_execute_line+0x638>
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    1508:	26 fe       	sbrs	r2, 6
    150a:	4f c7       	rjmp	.+3742   	; 0x23aa <__stack+0x1ab>
    bit_false(value_words,bit(WORD_P));
    150c:	e8 94       	clt
    150e:	26 f8       	bld	r2, 6
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    1510:	80 91 9b 0c 	lds	r24, 0x0C9B	; 0x800c9b <gc_block+0x5>
    1514:	88 23       	and	r24, r24
    1516:	49 f0       	breq	.+18     	; 0x152a <gc_execute_line+0x652>
    1518:	81 30       	cpi	r24, 0x01	; 1
    151a:	09 f4       	brne	.+2      	; 0x151e <gc_execute_line+0x646>
    151c:	98 c7       	rjmp	.+3888   	; 0x244e <__stack+0x24f>
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
      axis_linear = X_AXIS;
    151e:	1f a6       	std	Y+47, r1	; 0x2f
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
    1520:	f2 e0       	ldi	r31, 0x02	; 2
    1522:	fe a3       	std	Y+38, r31	; 0x26
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
    1524:	21 e0       	ldi	r18, 0x01	; 1
    1526:	2d a3       	std	Y+37, r18	; 0x25
    1528:	97 c7       	rjmp	.+3886   	; 0x2458 <__stack+0x259>
  }

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    152a:	80 91 99 0c 	lds	r24, 0x0C99	; 0x800c99 <gc_block+0x3>
    152e:	81 30       	cpi	r24, 0x01	; 1
    1530:	a1 f5       	brne	.+104    	; 0x159a <gc_execute_line+0x6c2>
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    1532:	32 e0       	ldi	r19, 0x02	; 2
    1534:	3f a7       	std	Y+47, r19	; 0x2f

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    1536:	41 e0       	ldi	r20, 0x01	; 1
    1538:	4e a3       	std	Y+38, r20	; 0x26
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    153a:	1d a2       	std	Y+37, r1	; 0x25
    153c:	0f 2e       	mov	r0, r31
    153e:	f6 e9       	ldi	r31, 0x96	; 150
    1540:	af 2e       	mov	r10, r31
    1542:	fc e0       	ldi	r31, 0x0C	; 12
    1544:	bf 2e       	mov	r11, r31
    1546:	f0 2d       	mov	r31, r0
    1548:	00 e0       	ldi	r16, 0x00	; 0
    154a:	10 e0       	ldi	r17, 0x00	; 0
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
      if (bit_istrue(axis_words,bit(idx)) ) {
    154c:	89 a1       	ldd	r24, Y+33	; 0x21
    154e:	c8 2e       	mov	r12, r24
    1550:	d1 2c       	mov	r13, r1
    1552:	c6 01       	movw	r24, r12
    1554:	00 2e       	mov	r0, r16
    1556:	02 c0       	rjmp	.+4      	; 0x155c <gc_execute_line+0x684>
    1558:	95 95       	asr	r25
    155a:	87 95       	ror	r24
    155c:	0a 94       	dec	r0
    155e:	e2 f7       	brpl	.-8      	; 0x1558 <gc_execute_line+0x680>
    1560:	80 ff       	sbrs	r24, 0
    1562:	12 c0       	rjmp	.+36     	; 0x1588 <gc_execute_line+0x6b0>
        gc_block.values.xyz[idx] *= MM_PER_INCH;
    1564:	23 e3       	ldi	r18, 0x33	; 51
    1566:	33 e3       	ldi	r19, 0x33	; 51
    1568:	4b ec       	ldi	r20, 0xCB	; 203
    156a:	51 e4       	ldi	r21, 0x41	; 65
    156c:	d5 01       	movw	r26, r10
    156e:	9e 96       	adiw	r26, 0x2e	; 46
    1570:	6d 91       	ld	r22, X+
    1572:	7d 91       	ld	r23, X+
    1574:	8d 91       	ld	r24, X+
    1576:	9c 91       	ld	r25, X
    1578:	d1 97       	sbiw	r26, 0x31	; 49
    157a:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    157e:	f5 01       	movw	r30, r10
    1580:	66 a7       	std	Z+46, r22	; 0x2e
    1582:	77 a7       	std	Z+47, r23	; 0x2f
    1584:	80 ab       	std	Z+48, r24	; 0x30
    1586:	91 ab       	std	Z+49, r25	; 0x31
    1588:	0f 5f       	subi	r16, 0xFF	; 255
    158a:	1f 4f       	sbci	r17, 0xFF	; 255
    158c:	f4 e0       	ldi	r31, 0x04	; 4
    158e:	af 0e       	add	r10, r31
    1590:	b1 1c       	adc	r11, r1

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    1592:	03 30       	cpi	r16, 0x03	; 3
    1594:	11 05       	cpc	r17, r1
    1596:	e9 f6       	brne	.-70     	; 0x1552 <gc_execute_line+0x67a>
    1598:	05 c0       	rjmp	.+10     	; 0x15a4 <gc_execute_line+0x6cc>
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    159a:	22 e0       	ldi	r18, 0x02	; 2
    159c:	2f a7       	std	Y+47, r18	; 0x2f

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    159e:	31 e0       	ldi	r19, 0x01	; 1
    15a0:	3e a3       	std	Y+38, r19	; 0x26
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    15a2:	1d a2       	std	Y+37, r1	; 0x25
  // [14. Cutter length compensation ]: G43 NOT SUPPORTED, but G43.1 and G49 are.
  // [G43.1 Errors]: Motion command in same line.
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    15a4:	4a a1       	ldd	r20, Y+34	; 0x22
    15a6:	43 30       	cpi	r20, 0x03	; 3
    15a8:	41 f4       	brne	.+16     	; 0x15ba <gc_execute_line+0x6e2>
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
    15aa:	80 91 9c 0c 	lds	r24, 0x0C9C	; 0x800c9c <gc_block+0x6>
    15ae:	81 30       	cpi	r24, 0x01	; 1
    15b0:	21 f4       	brne	.+8      	; 0x15ba <gc_execute_line+0x6e2>
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    15b2:	89 a1       	ldd	r24, Y+33	; 0x21
    15b4:	84 30       	cpi	r24, 0x04	; 4
    15b6:	09 f0       	breq	.+2      	; 0x15ba <gc_execute_line+0x6e2>
    15b8:	fa c6       	rjmp	.+3572   	; 0x23ae <__stack+0x1af>
  // TODO: An EEPROM read of the coordinate data may require a buffer sync when the cycle
  // is active. The read pauses the processor temporarily and may cause a rare crash. For
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  float block_coord_system[N_AXIS];
  memcpy(block_coord_system,gc_state.coord_system,sizeof(gc_state.coord_system));
    15ba:	8c e0       	ldi	r24, 0x0C	; 12
    15bc:	ea e7       	ldi	r30, 0x7A	; 122
    15be:	fc e0       	ldi	r31, 0x0C	; 12
    15c0:	de 01       	movw	r26, r28
    15c2:	16 96       	adiw	r26, 0x06	; 6
    15c4:	01 90       	ld	r0, Z+
    15c6:	0d 92       	st	X+, r0
    15c8:	8a 95       	dec	r24
    15ca:	e1 f7       	brne	.-8      	; 0x15c4 <gc_execute_line+0x6ec>
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    15cc:	f1 fe       	sbrs	r15, 1
    15ce:	11 c0       	rjmp	.+34     	; 0x15f2 <gc_execute_line+0x71a>
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    15d0:	80 91 9d 0c 	lds	r24, 0x0C9D	; 0x800c9d <gc_block+0x7>
    15d4:	87 30       	cpi	r24, 0x07	; 7
    15d6:	08 f0       	brcs	.+2      	; 0x15da <gc_execute_line+0x702>
    15d8:	ec c6       	rjmp	.+3544   	; 0x23b2 <__stack+0x1b3>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    15da:	90 91 5c 0c 	lds	r25, 0x0C5C	; 0x800c5c <gc_state+0x6>
    15de:	89 17       	cp	r24, r25
    15e0:	41 f0       	breq	.+16     	; 0x15f2 <gc_execute_line+0x71a>
      if (!(settings_read_coord_data(gc_block.modal.coord_select,block_coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    15e2:	be 01       	movw	r22, r28
    15e4:	6a 5f       	subi	r22, 0xFA	; 250
    15e6:	7f 4f       	sbci	r23, 0xFF	; 255
    15e8:	0e 94 1c 26 	call	0x4c38	; 0x4c38 <settings_read_coord_data>
    15ec:	88 23       	and	r24, r24
    15ee:	09 f4       	brne	.+2      	; 0x15f2 <gc_execute_line+0x71a>
    15f0:	e2 c6       	rjmp	.+3524   	; 0x23b6 <__stack+0x1b7>
  // [19. Remaining non-modal actions ]: Check go to predefined position, set G10, or set axis offsets.
  // NOTE: We need to separate the non-modal commands that are axis word-using (G10/G28/G30/G92), as these
  // commands all treat axis words differently. G10 as absolute offsets or computes current position as
  // the axis value, G92 similarly to G10 L20, and G28/30 as an intermediate target position that observes
  // all the current coordinate system and G92 offsets.
  switch (gc_block.non_modal_command) {
    15f2:	b0 90 96 0c 	lds	r11, 0x0C96	; 0x800c96 <gc_block>
    15f6:	9a e0       	ldi	r25, 0x0A	; 10
    15f8:	b9 16       	cp	r11, r25
    15fa:	29 f0       	breq	.+10     	; 0x1606 <gc_execute_line+0x72e>
    15fc:	ac e5       	ldi	r26, 0x5C	; 92
    15fe:	ba 16       	cp	r11, r26
    1600:	09 f4       	brne	.+2      	; 0x1604 <gc_execute_line+0x72c>
    1602:	9a c0       	rjmp	.+308    	; 0x1738 <gc_execute_line+0x860>
    1604:	0e c1       	rjmp	.+540    	; 0x1822 <gc_execute_line+0x94a>
    case NON_MODAL_SET_COORDINATE_DATA:
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    1606:	b9 a1       	ldd	r27, Y+33	; 0x21
    1608:	bb 23       	and	r27, r27
    160a:	09 f4       	brne	.+2      	; 0x160e <gc_execute_line+0x736>
    160c:	d6 c6       	rjmp	.+3500   	; 0x23ba <__stack+0x1bb>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    160e:	c1 01       	movw	r24, r2
    1610:	80 75       	andi	r24, 0x50	; 80
    1612:	99 27       	eor	r25, r25
    1614:	89 2b       	or	r24, r25
    1616:	09 f4       	brne	.+2      	; 0x161a <gc_execute_line+0x742>
    1618:	d2 c6       	rjmp	.+3492   	; 0x23be <__stack+0x1bf>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
    161a:	60 91 b7 0c 	lds	r22, 0x0CB7	; 0x800cb7 <gc_block+0x21>
    161e:	70 91 b8 0c 	lds	r23, 0x0CB8	; 0x800cb8 <gc_block+0x22>
    1622:	80 91 b9 0c 	lds	r24, 0x0CB9	; 0x800cb9 <gc_block+0x23>
    1626:	90 91 ba 0c 	lds	r25, 0x0CBA	; 0x800cba <gc_block+0x24>
    162a:	0e 94 ac 42 	call	0x8558	; 0x8558 <trunc>
    162e:	0e 94 14 40 	call	0x8028	; 0x8028 <__fixunssfsi>
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    1632:	67 30       	cpi	r22, 0x07	; 7
    1634:	08 f0       	brcs	.+2      	; 0x1638 <gc_execute_line+0x760>
    1636:	c5 c6       	rjmp	.+3466   	; 0x23c2 <__stack+0x1c3>
      if (gc_block.values.l != 20) {
    1638:	80 91 b2 0c 	lds	r24, 0x0CB2	; 0x800cb2 <gc_block+0x1c>
    163c:	84 31       	cpi	r24, 0x14	; 20
    163e:	29 f0       	breq	.+10     	; 0x164a <gc_execute_line+0x772>
        if (gc_block.values.l == 2) {
    1640:	82 30       	cpi	r24, 0x02	; 2
    1642:	09 f0       	breq	.+2      	; 0x1646 <gc_execute_line+0x76e>
    1644:	c0 c6       	rjmp	.+3456   	; 0x23c6 <__stack+0x1c7>
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    1646:	27 fc       	sbrc	r2, 7
    1648:	c0 c6       	rjmp	.+3456   	; 0x23ca <__stack+0x1cb>
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
      }
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
    164a:	ef ea       	ldi	r30, 0xAF	; 175
    164c:	2e 22       	and	r2, r30

      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
    164e:	66 23       	and	r22, r22
    1650:	19 f0       	breq	.+6      	; 0x1658 <gc_execute_line+0x780>
    1652:	61 50       	subi	r22, 0x01	; 1
    1654:	6f 8f       	std	Y+31, r22	; 0x1f
    1656:	03 c0       	rjmp	.+6      	; 0x165e <gc_execute_line+0x786>
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
    1658:	f0 91 9d 0c 	lds	r31, 0x0C9D	; 0x800c9d <gc_block+0x7>
    165c:	ff 8f       	std	Y+31, r31	; 0x1f
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    165e:	66 ea       	ldi	r22, 0xA6	; 166
    1660:	7c e0       	ldi	r23, 0x0C	; 12
    1662:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1664:	0e 94 1c 26 	call	0x4c38	; 0x4c38 <settings_read_coord_data>
    1668:	88 23       	and	r24, r24
    166a:	09 f4       	brne	.+2      	; 0x166e <gc_execute_line+0x796>
    166c:	b0 c6       	rjmp	.+3424   	; 0x23ce <__stack+0x1cf>

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
          if (gc_block.values.l == 20) {
    166e:	20 91 b2 0c 	lds	r18, 0x0CB2	; 0x800cb2 <gc_block+0x1c>
    1672:	2f a3       	std	Y+39, r18	; 0x27
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            // WPos = MPos - WCS - G92 - TLO  ->  WCS = MPos - G92 - TLO - WPos
            gc_block.values.ijk[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.ijk[idx] -= gc_state.tool_length_offset; }
    1674:	40 90 92 0c 	lds	r4, 0x0C92	; 0x800c92 <gc_state+0x3c>
    1678:	50 90 93 0c 	lds	r5, 0x0C93	; 0x800c93 <gc_state+0x3d>
    167c:	60 90 94 0c 	lds	r6, 0x0C94	; 0x800c94 <gc_state+0x3e>
    1680:	70 90 95 0c 	lds	r7, 0x0C95	; 0x800c95 <gc_state+0x3f>
    1684:	06 e9       	ldi	r16, 0x96	; 150
    1686:	1c e0       	ldi	r17, 0x0C	; 12
    1688:	0f 2e       	mov	r0, r31
    168a:	f6 e5       	ldi	r31, 0x56	; 86
    168c:	cf 2e       	mov	r12, r31
    168e:	fc e0       	ldi	r31, 0x0C	; 12
    1690:	df 2e       	mov	r13, r31
    1692:	f0 2d       	mov	r31, r0
    1694:	a1 2c       	mov	r10, r1
    1696:	b1 2c       	mov	r11, r1
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
    1698:	39 a1       	ldd	r19, Y+33	; 0x21
    169a:	83 2e       	mov	r8, r19
    169c:	91 2c       	mov	r9, r1
    169e:	c4 01       	movw	r24, r8
    16a0:	0a 2c       	mov	r0, r10
    16a2:	02 c0       	rjmp	.+4      	; 0x16a8 <gc_execute_line+0x7d0>
    16a4:	95 95       	asr	r25
    16a6:	87 95       	ror	r24
    16a8:	0a 94       	dec	r0
    16aa:	e2 f7       	brpl	.-8      	; 0x16a4 <gc_execute_line+0x7cc>
    16ac:	80 ff       	sbrs	r24, 0
    16ae:	36 c0       	rjmp	.+108    	; 0x171c <gc_execute_line+0x844>
          if (gc_block.values.l == 20) {
    16b0:	4f a1       	ldd	r20, Y+39	; 0x27
    16b2:	44 31       	cpi	r20, 0x14	; 20
    16b4:	51 f5       	brne	.+84     	; 0x170a <gc_execute_line+0x832>
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            // WPos = MPos - WCS - G92 - TLO  ->  WCS = MPos - G92 - TLO - WPos
            gc_block.values.ijk[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
    16b6:	d6 01       	movw	r26, r12
    16b8:	d0 96       	adiw	r26, 0x30	; 48
    16ba:	2d 91       	ld	r18, X+
    16bc:	3d 91       	ld	r19, X+
    16be:	4d 91       	ld	r20, X+
    16c0:	5c 91       	ld	r21, X
    16c2:	d3 97       	sbiw	r26, 0x33	; 51
    16c4:	58 96       	adiw	r26, 0x18	; 24
    16c6:	6d 91       	ld	r22, X+
    16c8:	7d 91       	ld	r23, X+
    16ca:	8d 91       	ld	r24, X+
    16cc:	9c 91       	ld	r25, X
    16ce:	5b 97       	sbiw	r26, 0x1b	; 27
    16d0:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    16d4:	f8 01       	movw	r30, r16
    16d6:	26 a5       	ldd	r18, Z+46	; 0x2e
    16d8:	37 a5       	ldd	r19, Z+47	; 0x2f
    16da:	40 a9       	ldd	r20, Z+48	; 0x30
    16dc:	51 a9       	ldd	r21, Z+49	; 0x31
    16de:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    16e2:	d8 01       	movw	r26, r16
    16e4:	50 96       	adiw	r26, 0x10	; 16
    16e6:	6d 93       	st	X+, r22
    16e8:	7d 93       	st	X+, r23
    16ea:	8d 93       	st	X+, r24
    16ec:	9c 93       	st	X, r25
    16ee:	53 97       	sbiw	r26, 0x13	; 19
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.ijk[idx] -= gc_state.tool_length_offset; }
    16f0:	b2 e0       	ldi	r27, 0x02	; 2
    16f2:	ab 12       	cpse	r10, r27
    16f4:	13 c0       	rjmp	.+38     	; 0x171c <gc_execute_line+0x844>
    16f6:	a3 01       	movw	r20, r6
    16f8:	92 01       	movw	r18, r4
    16fa:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    16fe:	f8 01       	movw	r30, r16
    1700:	60 8b       	std	Z+16, r22	; 0x10
    1702:	71 8b       	std	Z+17, r23	; 0x11
    1704:	82 8b       	std	Z+18, r24	; 0x12
    1706:	93 8b       	std	Z+19, r25	; 0x13
    1708:	09 c0       	rjmp	.+18     	; 0x171c <gc_execute_line+0x844>
          } else {
            // L2: Update coordinate system axis to programmed value.
            gc_block.values.ijk[idx] = gc_block.values.xyz[idx];
    170a:	f8 01       	movw	r30, r16
    170c:	86 a5       	ldd	r24, Z+46	; 0x2e
    170e:	97 a5       	ldd	r25, Z+47	; 0x2f
    1710:	a0 a9       	ldd	r26, Z+48	; 0x30
    1712:	b1 a9       	ldd	r27, Z+49	; 0x31
    1714:	80 8b       	std	Z+16, r24	; 0x10
    1716:	91 8b       	std	Z+17, r25	; 0x11
    1718:	a2 8b       	std	Z+18, r26	; 0x12
    171a:	b3 8b       	std	Z+19, r27	; 0x13
    171c:	ff ef       	ldi	r31, 0xFF	; 255
    171e:	af 1a       	sub	r10, r31
    1720:	bf 0a       	sbc	r11, r31
    1722:	0c 5f       	subi	r16, 0xFC	; 252
    1724:	1f 4f       	sbci	r17, 0xFF	; 255
    1726:	24 e0       	ldi	r18, 0x04	; 4
    1728:	c2 0e       	add	r12, r18
    172a:	d1 1c       	adc	r13, r1
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    172c:	33 e0       	ldi	r19, 0x03	; 3
    172e:	a3 16       	cp	r10, r19
    1730:	b1 04       	cpc	r11, r1
    1732:	09 f0       	breq	.+2      	; 0x1736 <gc_execute_line+0x85e>
    1734:	b4 cf       	rjmp	.-152    	; 0x169e <gc_execute_line+0x7c6>
    1736:	a2 c6       	rjmp	.+3396   	; 0x247c <__stack+0x27d>
        } // Else, keep current stored value.
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1738:	49 a1       	ldd	r20, Y+33	; 0x21
    173a:	44 23       	and	r20, r20
    173c:	09 f4       	brne	.+2      	; 0x1740 <gc_execute_line+0x868>
    173e:	49 c6       	rjmp	.+3218   	; 0x23d2 <__stack+0x1d3>
    1740:	0f 2e       	mov	r0, r31
    1742:	f6 e5       	ldi	r31, 0x56	; 86
    1744:	af 2e       	mov	r10, r31
    1746:	fc e0       	ldi	r31, 0x0C	; 12
    1748:	bf 2e       	mov	r11, r31
    174a:	f0 2d       	mov	r31, r0
    174c:	4e 01       	movw	r8, r28
    174e:	86 e0       	ldi	r24, 0x06	; 6
    1750:	88 0e       	add	r8, r24
    1752:	91 1c       	adc	r9, r1
    1754:	06 e9       	ldi	r16, 0x96	; 150
    1756:	1c e0       	ldi	r17, 0x0C	; 12
    1758:	c1 2c       	mov	r12, r1
    175a:	d1 2c       	mov	r13, r1

      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
    175c:	64 2e       	mov	r6, r20
    175e:	71 2c       	mov	r7, r1
    1760:	c3 01       	movw	r24, r6
    1762:	0c 2c       	mov	r0, r12
    1764:	02 c0       	rjmp	.+4      	; 0x176a <gc_execute_line+0x892>
    1766:	95 95       	asr	r25
    1768:	87 95       	ror	r24
    176a:	0a 94       	dec	r0
    176c:	e2 f7       	brpl	.-8      	; 0x1766 <gc_execute_line+0x88e>
    176e:	80 ff       	sbrs	r24, 0
    1770:	3c c0       	rjmp	.+120    	; 0x17ea <gc_execute_line+0x912>
          // WPos = MPos - WCS - G92 - TLO  ->  G92 = MPos - WCS - TLO - WPos
          gc_block.values.xyz[idx] = gc_state.position[idx]-block_coord_system[idx]-gc_block.values.xyz[idx];
    1772:	d4 01       	movw	r26, r8
    1774:	2d 91       	ld	r18, X+
    1776:	3d 91       	ld	r19, X+
    1778:	4d 91       	ld	r20, X+
    177a:	5c 91       	ld	r21, X
    177c:	f5 01       	movw	r30, r10
    177e:	60 8d       	ldd	r22, Z+24	; 0x18
    1780:	71 8d       	ldd	r23, Z+25	; 0x19
    1782:	82 8d       	ldd	r24, Z+26	; 0x1a
    1784:	93 8d       	ldd	r25, Z+27	; 0x1b
    1786:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    178a:	d8 01       	movw	r26, r16
    178c:	9e 96       	adiw	r26, 0x2e	; 46
    178e:	2d 91       	ld	r18, X+
    1790:	3d 91       	ld	r19, X+
    1792:	4d 91       	ld	r20, X+
    1794:	5c 91       	ld	r21, X
    1796:	d1 97       	sbiw	r26, 0x31	; 49
    1798:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    179c:	f8 01       	movw	r30, r16
    179e:	66 a7       	std	Z+46, r22	; 0x2e
    17a0:	77 a7       	std	Z+47, r23	; 0x2f
    17a2:	80 ab       	std	Z+48, r24	; 0x30
    17a4:	91 ab       	std	Z+49, r25	; 0x31
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
    17a6:	f2 e0       	ldi	r31, 0x02	; 2
    17a8:	cf 12       	cpse	r12, r31
    17aa:	29 c0       	rjmp	.+82     	; 0x17fe <gc_execute_line+0x926>
    17ac:	86 01       	movw	r16, r12
    17ae:	00 0f       	add	r16, r16
    17b0:	11 1f       	adc	r17, r17
    17b2:	00 0f       	add	r16, r16
    17b4:	11 1f       	adc	r17, r17
    17b6:	0a 56       	subi	r16, 0x6A	; 106
    17b8:	13 4f       	sbci	r17, 0xF3	; 243
    17ba:	20 91 92 0c 	lds	r18, 0x0C92	; 0x800c92 <gc_state+0x3c>
    17be:	30 91 93 0c 	lds	r19, 0x0C93	; 0x800c93 <gc_state+0x3d>
    17c2:	40 91 94 0c 	lds	r20, 0x0C94	; 0x800c94 <gc_state+0x3e>
    17c6:	50 91 95 0c 	lds	r21, 0x0C95	; 0x800c95 <gc_state+0x3f>
    17ca:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    17ce:	d8 01       	movw	r26, r16
    17d0:	9e 96       	adiw	r26, 0x2e	; 46
    17d2:	6d 93       	st	X+, r22
    17d4:	7d 93       	st	X+, r23
    17d6:	8d 93       	st	X+, r24
    17d8:	9c 93       	st	X, r25
    17da:	d1 97       	sbiw	r26, 0x31	; 49
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    17dc:	10 91 97 0c 	lds	r17, 0x0C97	; 0x800c97 <gc_block+0x1>
    17e0:	10 35       	cpi	r17, 0x50	; 80
    17e2:	09 f4       	brne	.+2      	; 0x17e6 <gc_execute_line+0x90e>
    17e4:	f8 c5       	rjmp	.+3056   	; 0x23d6 <__stack+0x1d7>
    17e6:	1f 8e       	std	Y+31, r1	; 0x1f
    17e8:	f8 c0       	rjmp	.+496    	; 0x19da <gc_execute_line+0xb02>
        if (bit_istrue(axis_words,bit(idx)) ) {
          // WPos = MPos - WCS - G92 - TLO  ->  G92 = MPos - WCS - TLO - WPos
          gc_block.values.xyz[idx] = gc_state.position[idx]-block_coord_system[idx]-gc_block.values.xyz[idx];
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
        } else {
          gc_block.values.xyz[idx] = gc_state.coord_offset[idx];
    17ea:	f5 01       	movw	r30, r10
    17ec:	80 a9       	ldd	r24, Z+48	; 0x30
    17ee:	91 a9       	ldd	r25, Z+49	; 0x31
    17f0:	a2 a9       	ldd	r26, Z+50	; 0x32
    17f2:	b3 a9       	ldd	r27, Z+51	; 0x33
    17f4:	f8 01       	movw	r30, r16
    17f6:	86 a7       	std	Z+46, r24	; 0x2e
    17f8:	97 a7       	std	Z+47, r25	; 0x2f
    17fa:	a0 ab       	std	Z+48, r26	; 0x30
    17fc:	b1 ab       	std	Z+49, r27	; 0x31
    17fe:	ff ef       	ldi	r31, 0xFF	; 255
    1800:	cf 1a       	sub	r12, r31
    1802:	df 0a       	sbc	r13, r31
    1804:	24 e0       	ldi	r18, 0x04	; 4
    1806:	a2 0e       	add	r10, r18
    1808:	b1 1c       	adc	r11, r1
    180a:	34 e0       	ldi	r19, 0x04	; 4
    180c:	83 0e       	add	r8, r19
    180e:	91 1c       	adc	r9, r1
    1810:	0c 5f       	subi	r16, 0xFC	; 252
    1812:	1f 4f       	sbci	r17, 0xFF	; 255
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]

      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    1814:	43 e0       	ldi	r20, 0x03	; 3
    1816:	c4 16       	cp	r12, r20
    1818:	d1 04       	cpc	r13, r1
    181a:	09 f0       	breq	.+2      	; 0x181e <gc_execute_line+0x946>
    181c:	a1 cf       	rjmp	.-190    	; 0x1760 <gc_execute_line+0x888>
  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes

  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    181e:	1f 8e       	std	Y+31, r1	; 0x1f
    1820:	2d c6       	rjmp	.+3162   	; 0x247c <__stack+0x27d>

      // At this point, the rest of the explicit axis commands treat the axis values as the traditional
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
    1822:	8a a1       	ldd	r24, Y+34	; 0x22
    1824:	83 30       	cpi	r24, 0x03	; 3
    1826:	09 f4       	brne	.+2      	; 0x182a <gc_execute_line+0x952>
    1828:	90 c0       	rjmp	.+288    	; 0x194a <gc_execute_line+0xa72>
        if (axis_words) {
    182a:	99 a1       	ldd	r25, Y+33	; 0x21
    182c:	99 23       	and	r25, r25
    182e:	09 f4       	brne	.+2      	; 0x1832 <gc_execute_line+0x95a>
    1830:	8c c0       	rjmp	.+280    	; 0x194a <gc_execute_line+0xa72>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    1832:	a0 90 9a 0c 	lds	r10, 0x0C9A	; 0x800c9a <gc_block+0x4>
    1836:	0f 2e       	mov	r0, r31
    1838:	f6 e5       	ldi	r31, 0x56	; 86
    183a:	cf 2e       	mov	r12, r31
    183c:	fc e0       	ldi	r31, 0x0C	; 12
    183e:	df 2e       	mov	r13, r31
    1840:	f0 2d       	mov	r31, r0
    1842:	06 e9       	ldi	r16, 0x96	; 150
    1844:	1c e0       	ldi	r17, 0x0C	; 12
    1846:	3e 01       	movw	r6, r28
    1848:	a6 e0       	ldi	r26, 0x06	; 6
    184a:	6a 0e       	add	r6, r26
    184c:	71 1c       	adc	r7, r1
    184e:	81 2c       	mov	r8, r1
    1850:	91 2c       	mov	r9, r1
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
            if ( bit_isfalse(axis_words,bit(idx)) ) {
    1852:	49 2e       	mov	r4, r25
    1854:	51 2c       	mov	r5, r1
    1856:	98 a2       	std	Y+32, r9	; 0x20
    1858:	8f 8e       	std	Y+31, r8	; 0x1f
    185a:	c2 01       	movw	r24, r4
    185c:	08 2c       	mov	r0, r8
    185e:	02 c0       	rjmp	.+4      	; 0x1864 <gc_execute_line+0x98c>
    1860:	95 95       	asr	r25
    1862:	87 95       	ror	r24
    1864:	0a 94       	dec	r0
    1866:	e2 f7       	brpl	.-8      	; 0x1860 <gc_execute_line+0x988>
    1868:	80 fd       	sbrc	r24, 0
    186a:	0b c0       	rjmp	.+22     	; 0x1882 <gc_execute_line+0x9aa>
              gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
    186c:	f6 01       	movw	r30, r12
    186e:	80 8d       	ldd	r24, Z+24	; 0x18
    1870:	91 8d       	ldd	r25, Z+25	; 0x19
    1872:	a2 8d       	ldd	r26, Z+26	; 0x1a
    1874:	b3 8d       	ldd	r27, Z+27	; 0x1b
    1876:	f8 01       	movw	r30, r16
    1878:	86 a7       	std	Z+46, r24	; 0x2e
    187a:	97 a7       	std	Z+47, r25	; 0x2f
    187c:	a0 ab       	std	Z+48, r26	; 0x30
    187e:	b1 ab       	std	Z+49, r27	; 0x31
    1880:	54 c0       	rjmp	.+168    	; 0x192a <gc_execute_line+0xa52>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
    1882:	f5 e3       	ldi	r31, 0x35	; 53
    1884:	bf 16       	cp	r11, r31
    1886:	09 f4       	brne	.+2      	; 0x188a <gc_execute_line+0x9b2>
    1888:	50 c0       	rjmp	.+160    	; 0x192a <gc_execute_line+0xa52>
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    188a:	a1 10       	cpse	r10, r1
    188c:	3b c0       	rjmp	.+118    	; 0x1904 <gc_execute_line+0xa2c>
                  gc_block.values.xyz[idx] += block_coord_system[idx] + gc_state.coord_offset[idx];
    188e:	d6 01       	movw	r26, r12
    1890:	d0 96       	adiw	r26, 0x30	; 48
    1892:	2d 91       	ld	r18, X+
    1894:	3d 91       	ld	r19, X+
    1896:	4d 91       	ld	r20, X+
    1898:	5c 91       	ld	r21, X
    189a:	d3 97       	sbiw	r26, 0x33	; 51
    189c:	f3 01       	movw	r30, r6
    189e:	60 81       	ld	r22, Z
    18a0:	71 81       	ldd	r23, Z+1	; 0x01
    18a2:	82 81       	ldd	r24, Z+2	; 0x02
    18a4:	93 81       	ldd	r25, Z+3	; 0x03
    18a6:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    18aa:	d8 01       	movw	r26, r16
    18ac:	9e 96       	adiw	r26, 0x2e	; 46
    18ae:	2d 91       	ld	r18, X+
    18b0:	3d 91       	ld	r19, X+
    18b2:	4d 91       	ld	r20, X+
    18b4:	5c 91       	ld	r21, X
    18b6:	d1 97       	sbiw	r26, 0x31	; 49
    18b8:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    18bc:	9b 01       	movw	r18, r22
    18be:	ac 01       	movw	r20, r24
    18c0:	f8 01       	movw	r30, r16
    18c2:	66 a7       	std	Z+46, r22	; 0x2e
    18c4:	77 a7       	std	Z+47, r23	; 0x2f
    18c6:	80 ab       	std	Z+48, r24	; 0x30
    18c8:	91 ab       	std	Z+49, r25	; 0x31
                  if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_length_offset; }
    18ca:	f2 e0       	ldi	r31, 0x02	; 2
    18cc:	8f 12       	cpse	r8, r31
    18ce:	2d c0       	rjmp	.+90     	; 0x192a <gc_execute_line+0xa52>
    18d0:	0f 8d       	ldd	r16, Y+31	; 0x1f
    18d2:	18 a1       	ldd	r17, Y+32	; 0x20
    18d4:	00 0f       	add	r16, r16
    18d6:	11 1f       	adc	r17, r17
    18d8:	00 0f       	add	r16, r16
    18da:	11 1f       	adc	r17, r17
    18dc:	0a 56       	subi	r16, 0x6A	; 106
    18de:	13 4f       	sbci	r17, 0xF3	; 243
    18e0:	60 91 92 0c 	lds	r22, 0x0C92	; 0x800c92 <gc_state+0x3c>
    18e4:	70 91 93 0c 	lds	r23, 0x0C93	; 0x800c93 <gc_state+0x3d>
    18e8:	80 91 94 0c 	lds	r24, 0x0C94	; 0x800c94 <gc_state+0x3e>
    18ec:	90 91 95 0c 	lds	r25, 0x0C95	; 0x800c95 <gc_state+0x3f>
    18f0:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    18f4:	d8 01       	movw	r26, r16
    18f6:	9e 96       	adiw	r26, 0x2e	; 46
    18f8:	6d 93       	st	X+, r22
    18fa:	7d 93       	st	X+, r23
    18fc:	8d 93       	st	X+, r24
    18fe:	9c 93       	st	X, r25
    1900:	d1 97       	sbiw	r26, 0x31	; 49
    1902:	23 c0       	rjmp	.+70     	; 0x194a <gc_execute_line+0xa72>
                } else {  // Incremental mode
                  gc_block.values.xyz[idx] += gc_state.position[idx];
    1904:	f6 01       	movw	r30, r12
    1906:	20 8d       	ldd	r18, Z+24	; 0x18
    1908:	31 8d       	ldd	r19, Z+25	; 0x19
    190a:	42 8d       	ldd	r20, Z+26	; 0x1a
    190c:	53 8d       	ldd	r21, Z+27	; 0x1b
    190e:	d8 01       	movw	r26, r16
    1910:	9e 96       	adiw	r26, 0x2e	; 46
    1912:	6d 91       	ld	r22, X+
    1914:	7d 91       	ld	r23, X+
    1916:	8d 91       	ld	r24, X+
    1918:	9c 91       	ld	r25, X
    191a:	d1 97       	sbiw	r26, 0x31	; 49
    191c:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    1920:	f8 01       	movw	r30, r16
    1922:	66 a7       	std	Z+46, r22	; 0x2e
    1924:	77 a7       	std	Z+47, r23	; 0x2f
    1926:	80 ab       	std	Z+48, r24	; 0x30
    1928:	91 ab       	std	Z+49, r25	; 0x31
    192a:	ff ef       	ldi	r31, 0xFF	; 255
    192c:	8f 1a       	sub	r8, r31
    192e:	9f 0a       	sbc	r9, r31
    1930:	24 e0       	ldi	r18, 0x04	; 4
    1932:	c2 0e       	add	r12, r18
    1934:	d1 1c       	adc	r13, r1
    1936:	0c 5f       	subi	r16, 0xFC	; 252
    1938:	1f 4f       	sbci	r17, 0xFF	; 255
    193a:	34 e0       	ldi	r19, 0x04	; 4
    193c:	63 0e       	add	r6, r19
    193e:	71 1c       	adc	r7, r1
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    1940:	43 e0       	ldi	r20, 0x03	; 3
    1942:	84 16       	cp	r8, r20
    1944:	91 04       	cpc	r9, r1
    1946:	09 f0       	breq	.+2      	; 0x194a <gc_execute_line+0xa72>
    1948:	86 cf       	rjmp	.-244    	; 0x1856 <gc_execute_line+0x97e>
          }
        }
      }

      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {
    194a:	8e e1       	ldi	r24, 0x1E	; 30
    194c:	b8 16       	cp	r11, r24
    194e:	31 f0       	breq	.+12     	; 0x195c <gc_execute_line+0xa84>
    1950:	95 e3       	ldi	r25, 0x35	; 53
    1952:	b9 16       	cp	r11, r25
    1954:	99 f1       	breq	.+102    	; 0x19bc <gc_execute_line+0xae4>
    1956:	ac e1       	ldi	r26, 0x1C	; 28
    1958:	ba 12       	cpse	r11, r26
    195a:	35 c0       	rjmp	.+106    	; 0x19c6 <gc_execute_line+0xaee>
        case NON_MODAL_GO_HOME_0: // G28
        case NON_MODAL_GO_HOME_1: // G30
          // [G28/30 Errors]: Cutter compensation is enabled.
          // Retreive G28/30 go-home position data (in machine coordinates) from EEPROM
          // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
    195c:	bc e1       	ldi	r27, 0x1C	; 28
    195e:	bb 12       	cpse	r11, r27
    1960:	09 c0       	rjmp	.+18     	; 0x1974 <gc_execute_line+0xa9c>
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    1962:	66 ea       	ldi	r22, 0xA6	; 166
    1964:	7c e0       	ldi	r23, 0x0C	; 12
    1966:	86 e0       	ldi	r24, 0x06	; 6
    1968:	0e 94 1c 26 	call	0x4c38	; 0x4c38 <settings_read_coord_data>
    196c:	88 23       	and	r24, r24
    196e:	09 f4       	brne	.+2      	; 0x1972 <gc_execute_line+0xa9a>
    1970:	34 c5       	rjmp	.+2664   	; 0x23da <__stack+0x1db>
    1972:	78 c5       	rjmp	.+2800   	; 0x2464 <__stack+0x265>
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    1974:	66 ea       	ldi	r22, 0xA6	; 166
    1976:	7c e0       	ldi	r23, 0x0C	; 12
    1978:	87 e0       	ldi	r24, 0x07	; 7
    197a:	0e 94 1c 26 	call	0x4c38	; 0x4c38 <settings_read_coord_data>
    197e:	88 23       	and	r24, r24
    1980:	09 f4       	brne	.+2      	; 0x1984 <gc_execute_line+0xaac>
    1982:	2d c5       	rjmp	.+2650   	; 0x23de <__stack+0x1df>
    1984:	6f c5       	rjmp	.+2782   	; 0x2464 <__stack+0x265>
          }
          if (axis_words) {
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
    1986:	a9 01       	movw	r20, r18
    1988:	08 2e       	mov	r0, r24
    198a:	02 c0       	rjmp	.+4      	; 0x1990 <gc_execute_line+0xab8>
    198c:	55 95       	asr	r21
    198e:	47 95       	ror	r20
    1990:	0a 94       	dec	r0
    1992:	e2 f7       	brpl	.-8      	; 0x198c <gc_execute_line+0xab4>
    1994:	40 fd       	sbrc	r20, 0
    1996:	0a c0       	rjmp	.+20     	; 0x19ac <gc_execute_line+0xad4>
    1998:	58 96       	adiw	r26, 0x18	; 24
    199a:	4d 91       	ld	r20, X+
    199c:	5d 91       	ld	r21, X+
    199e:	6d 91       	ld	r22, X+
    19a0:	7c 91       	ld	r23, X
    19a2:	5b 97       	sbiw	r26, 0x1b	; 27
    19a4:	40 8b       	std	Z+16, r20	; 0x10
    19a6:	51 8b       	std	Z+17, r21	; 0x11
    19a8:	62 8b       	std	Z+18, r22	; 0x12
    19aa:	73 8b       	std	Z+19, r23	; 0x13
    19ac:	01 96       	adiw	r24, 0x01	; 1
    19ae:	14 96       	adiw	r26, 0x04	; 4
    19b0:	34 96       	adiw	r30, 0x04	; 4
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
          }
          if (axis_words) {
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
    19b2:	83 30       	cpi	r24, 0x03	; 3
    19b4:	91 05       	cpc	r25, r1
    19b6:	39 f7       	brne	.-50     	; 0x1986 <gc_execute_line+0xaae>
  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes

  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    19b8:	1f 8e       	std	Y+31, r1	; 0x1f
    19ba:	60 c5       	rjmp	.+2752   	; 0x247c <__stack+0x27d>
          // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
    19bc:	80 91 97 0c 	lds	r24, 0x0C97	; 0x800c97 <gc_block+0x1>
    19c0:	82 30       	cpi	r24, 0x02	; 2
    19c2:	08 f0       	brcs	.+2      	; 0x19c6 <gc_execute_line+0xaee>
    19c4:	0e c5       	rjmp	.+2588   	; 0x23e2 <__stack+0x1e3>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    19c6:	10 91 97 0c 	lds	r17, 0x0C97	; 0x800c97 <gc_block+0x1>
    19ca:	10 35       	cpi	r17, 0x50	; 80
    19cc:	29 f4       	brne	.+10     	; 0x19d8 <gc_execute_line+0xb00>
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    19ce:	e9 a1       	ldd	r30, Y+33	; 0x21
    19d0:	e1 11       	cpse	r30, r1
    19d2:	09 c5       	rjmp	.+2578   	; 0x23e6 <__stack+0x1e7>
    19d4:	1f 8e       	std	Y+31, r1	; 0x1f
    19d6:	46 c2       	rjmp	.+1164   	; 0x1e64 <gc_execute_line+0xf8c>
    19d8:	1f 8e       	std	Y+31, r1	; 0x1f

  // Check remaining motion modes, if axis word are implicit (exist and not used by G10/28/30/92), or
  // was explicitly commanded in the g-code block.
  } else if ( axis_command == AXIS_COMMAND_MOTION_MODE ) {
    19da:	fa a1       	ldd	r31, Y+34	; 0x22
    19dc:	f2 30       	cpi	r31, 0x02	; 2
    19de:	09 f0       	breq	.+2      	; 0x19e2 <gc_execute_line+0xb0a>
    19e0:	41 c2       	rjmp	.+1154   	; 0x1e64 <gc_execute_line+0xf8c>

    if (gc_block.modal.motion == MOTION_MODE_SEEK) {
    19e2:	11 11       	cpse	r17, r1
    19e4:	05 c0       	rjmp	.+10     	; 0x19f0 <gc_execute_line+0xb18>
      // [G0 Errors]: Axis letter not configured or without real value (done.)
      // Axis words are optional. If missing, set axis command flag to ignore execution.
      if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    19e6:	29 a1       	ldd	r18, Y+33	; 0x21
    19e8:	21 11       	cpse	r18, r1
    19ea:	3c c2       	rjmp	.+1144   	; 0x1e64 <gc_execute_line+0xf8c>
    19ec:	1a a2       	std	Y+34, r1	; 0x22
    19ee:	3a c2       	rjmp	.+1140   	; 0x1e64 <gc_execute_line+0xf8c>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    19f0:	20 e0       	ldi	r18, 0x00	; 0
    19f2:	30 e0       	ldi	r19, 0x00	; 0
    19f4:	a9 01       	movw	r20, r18
    19f6:	60 91 a2 0c 	lds	r22, 0x0CA2	; 0x800ca2 <gc_block+0xc>
    19fa:	70 91 a3 0c 	lds	r23, 0x0CA3	; 0x800ca3 <gc_block+0xd>
    19fe:	80 91 a4 0c 	lds	r24, 0x0CA4	; 0x800ca4 <gc_block+0xe>
    1a02:	90 91 a5 0c 	lds	r25, 0x0CA5	; 0x800ca5 <gc_block+0xf>
    1a06:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    1a0a:	88 23       	and	r24, r24
    1a0c:	09 f4       	brne	.+2      	; 0x1a10 <gc_execute_line+0xb38>
    1a0e:	ed c4       	rjmp	.+2522   	; 0x23ea <__stack+0x1eb>

      switch (gc_block.modal.motion) {
    1a10:	1c 38       	cpi	r17, 0x8C	; 140
    1a12:	09 f4       	brne	.+2      	; 0x1a16 <gc_execute_line+0xb3e>
    1a14:	0f c2       	rjmp	.+1054   	; 0x1e34 <gc_execute_line+0xf5c>
    1a16:	40 f4       	brcc	.+16     	; 0x1a28 <gc_execute_line+0xb50>
    1a18:	12 30       	cpi	r17, 0x02	; 2
    1a1a:	a1 f0       	breq	.+40     	; 0x1a44 <gc_execute_line+0xb6c>
    1a1c:	13 30       	cpi	r17, 0x03	; 3
    1a1e:	a9 f0       	breq	.+42     	; 0x1a4a <gc_execute_line+0xb72>
    1a20:	11 30       	cpi	r17, 0x01	; 1
    1a22:	09 f0       	breq	.+2      	; 0x1a26 <gc_execute_line+0xb4e>
    1a24:	1f c2       	rjmp	.+1086   	; 0x1e64 <gc_execute_line+0xf8c>
    1a26:	09 c0       	rjmp	.+18     	; 0x1a3a <gc_execute_line+0xb62>
    1a28:	1e 38       	cpi	r17, 0x8E	; 142
    1a2a:	09 f4       	brne	.+2      	; 0x1a2e <gc_execute_line+0xb56>
    1a2c:	03 c2       	rjmp	.+1030   	; 0x1e34 <gc_execute_line+0xf5c>
    1a2e:	08 f4       	brcc	.+2      	; 0x1a32 <gc_execute_line+0xb5a>
    1a30:	fe c1       	rjmp	.+1020   	; 0x1e2e <gc_execute_line+0xf56>
    1a32:	1f 38       	cpi	r17, 0x8F	; 143
    1a34:	09 f4       	brne	.+2      	; 0x1a38 <gc_execute_line+0xb60>
    1a36:	fb c1       	rjmp	.+1014   	; 0x1e2e <gc_execute_line+0xf56>
    1a38:	15 c2       	rjmp	.+1066   	; 0x1e64 <gc_execute_line+0xf8c>
        case MOTION_MODE_LINEAR:
          // [G1 Errors]: Feed rate undefined. Axis letter not configured or without real value.
          // Axis words are optional. If missing, set axis command flag to ignore execution.
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    1a3a:	39 a1       	ldd	r19, Y+33	; 0x21
    1a3c:	31 11       	cpse	r19, r1
    1a3e:	12 c2       	rjmp	.+1060   	; 0x1e64 <gc_execute_line+0xf8c>
    1a40:	1a a2       	std	Y+34, r1	; 0x22
    1a42:	10 c2       	rjmp	.+1056   	; 0x1e64 <gc_execute_line+0xf8c>
          break;
        case MOTION_MODE_CW_ARC: 
          gc_parser_flags |= GC_PARSER_ARC_IS_CLOCKWISE; // No break intentional.
    1a44:	4c a1       	ldd	r20, Y+36	; 0x24
    1a46:	44 60       	ori	r20, 0x04	; 4
    1a48:	4c a3       	std	Y+36, r20	; 0x24
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.

          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1a4a:	89 a1       	ldd	r24, Y+33	; 0x21
    1a4c:	88 23       	and	r24, r24
    1a4e:	09 f4       	brne	.+2      	; 0x1a52 <gc_execute_line+0xb7a>
    1a50:	ce c4       	rjmp	.+2460   	; 0x23ee <__stack+0x1ef>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    1a52:	bd a1       	ldd	r27, Y+37	; 0x25
    1a54:	ab 2f       	mov	r26, r27
    1a56:	b0 e0       	ldi	r27, 0x00	; 0
    1a58:	b9 ab       	std	Y+49, r27	; 0x31
    1a5a:	a8 ab       	std	Y+48, r26	; 0x30
    1a5c:	ee a1       	ldd	r30, Y+38	; 0x26
    1a5e:	ce 2e       	mov	r12, r30
    1a60:	d1 2c       	mov	r13, r1
    1a62:	81 e0       	ldi	r24, 0x01	; 1
    1a64:	90 e0       	ldi	r25, 0x00	; 0
    1a66:	8c 01       	movw	r16, r24
    1a68:	0d a0       	ldd	r0, Y+37	; 0x25
    1a6a:	02 c0       	rjmp	.+4      	; 0x1a70 <gc_execute_line+0xb98>
    1a6c:	00 0f       	add	r16, r16
    1a6e:	11 1f       	adc	r17, r17
    1a70:	0a 94       	dec	r0
    1a72:	e2 f7       	brpl	.-8      	; 0x1a6c <gc_execute_line+0xb94>
    1a74:	02 c0       	rjmp	.+4      	; 0x1a7a <gc_execute_line+0xba2>
    1a76:	88 0f       	add	r24, r24
    1a78:	99 1f       	adc	r25, r25
    1a7a:	ea 95       	dec	r30
    1a7c:	e2 f7       	brpl	.-8      	; 0x1a76 <gc_execute_line+0xb9e>
    1a7e:	08 2b       	or	r16, r24
    1a80:	19 2b       	or	r17, r25
    1a82:	f9 a1       	ldd	r31, Y+33	; 0x21
    1a84:	8f 2f       	mov	r24, r31
    1a86:	90 e0       	ldi	r25, 0x00	; 0
    1a88:	80 23       	and	r24, r16
    1a8a:	91 23       	and	r25, r17
    1a8c:	89 2b       	or	r24, r25
    1a8e:	09 f4       	brne	.+2      	; 0x1a92 <gc_execute_line+0xbba>
    1a90:	b0 c4       	rjmp	.+2400   	; 0x23f2 <__stack+0x1f3>

          // Calculate the change in position along each selected axis
          float x,y;
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
    1a92:	fd 01       	movw	r30, r26
    1a94:	ee 0f       	add	r30, r30
    1a96:	ff 1f       	adc	r31, r31
    1a98:	ee 0f       	add	r30, r30
    1a9a:	ff 1f       	adc	r31, r31
    1a9c:	ea 56       	subi	r30, 0x6A	; 106
    1a9e:	f3 4f       	sbci	r31, 0xF3	; 243
    1aa0:	aa 0f       	add	r26, r26
    1aa2:	bb 1f       	adc	r27, r27
    1aa4:	aa 0f       	add	r26, r26
    1aa6:	bb 1f       	adc	r27, r27
    1aa8:	a2 59       	subi	r26, 0x92	; 146
    1aaa:	b3 4f       	sbci	r27, 0xF3	; 243
    1aac:	2d 91       	ld	r18, X+
    1aae:	3d 91       	ld	r19, X+
    1ab0:	4d 91       	ld	r20, X+
    1ab2:	5c 91       	ld	r21, X
    1ab4:	66 a5       	ldd	r22, Z+46	; 0x2e
    1ab6:	77 a5       	ldd	r23, Z+47	; 0x2f
    1ab8:	80 a9       	ldd	r24, Z+48	; 0x30
    1aba:	91 a9       	ldd	r25, Z+49	; 0x31
    1abc:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    1ac0:	6f a3       	std	Y+39, r22	; 0x27
    1ac2:	78 a7       	std	Y+40, r23	; 0x28
    1ac4:	89 a7       	std	Y+41, r24	; 0x29
    1ac6:	9a a7       	std	Y+42, r25	; 0x2a
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target
    1ac8:	f6 01       	movw	r30, r12
    1aca:	ee 0f       	add	r30, r30
    1acc:	ff 1f       	adc	r31, r31
    1ace:	ee 0f       	add	r30, r30
    1ad0:	ff 1f       	adc	r31, r31
    1ad2:	ea 56       	subi	r30, 0x6A	; 106
    1ad4:	f3 4f       	sbci	r31, 0xF3	; 243
    1ad6:	d6 01       	movw	r26, r12
    1ad8:	aa 0f       	add	r26, r26
    1ada:	bb 1f       	adc	r27, r27
    1adc:	aa 0f       	add	r26, r26
    1ade:	bb 1f       	adc	r27, r27
    1ae0:	a2 59       	subi	r26, 0x92	; 146
    1ae2:	b3 4f       	sbci	r27, 0xF3	; 243
    1ae4:	2d 91       	ld	r18, X+
    1ae6:	3d 91       	ld	r19, X+
    1ae8:	4d 91       	ld	r20, X+
    1aea:	5c 91       	ld	r21, X
    1aec:	66 a5       	ldd	r22, Z+46	; 0x2e
    1aee:	77 a5       	ldd	r23, Z+47	; 0x2f
    1af0:	80 a9       	ldd	r24, Z+48	; 0x30
    1af2:	91 a9       	ldd	r25, Z+49	; 0x31
    1af4:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    1af8:	6b a7       	std	Y+43, r22	; 0x2b
    1afa:	7c a7       	std	Y+44, r23	; 0x2c
    1afc:	8d a7       	std	Y+45, r24	; 0x2d
    1afe:	9e a7       	std	Y+46, r25	; 0x2e

          if (value_words & bit(WORD_R)) { // Arc Radius Mode
    1b00:	27 fe       	sbrs	r2, 7
    1b02:	ea c0       	rjmp	.+468    	; 0x1cd8 <gc_execute_line+0xe00>
            bit_false(value_words,bit(WORD_R));
    1b04:	e8 94       	clt
    1b06:	27 f8       	bld	r2, 7
            if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    1b08:	4c e0       	ldi	r20, 0x0C	; 12
    1b0a:	50 e0       	ldi	r21, 0x00	; 0
    1b0c:	64 ec       	ldi	r22, 0xC4	; 196
    1b0e:	7c e0       	ldi	r23, 0x0C	; 12
    1b10:	8e e6       	ldi	r24, 0x6E	; 110
    1b12:	9c e0       	ldi	r25, 0x0C	; 12
    1b14:	0e 94 04 43 	call	0x8608	; 0x8608 <memcmp>
    1b18:	89 2b       	or	r24, r25
    1b1a:	09 f4       	brne	.+2      	; 0x1b1e <gc_execute_line+0xc46>
    1b1c:	6c c4       	rjmp	.+2264   	; 0x23f6 <__stack+0x1f7>

            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
    1b1e:	80 91 99 0c 	lds	r24, 0x0C99	; 0x800c99 <gc_block+0x3>
    1b22:	81 30       	cpi	r24, 0x01	; 1
    1b24:	a1 f4       	brne	.+40     	; 0x1b4e <gc_execute_line+0xc76>
    1b26:	06 e9       	ldi	r16, 0x96	; 150
    1b28:	1c e0       	ldi	r17, 0x0C	; 12
    1b2a:	23 e3       	ldi	r18, 0x33	; 51
    1b2c:	33 e3       	ldi	r19, 0x33	; 51
    1b2e:	4b ec       	ldi	r20, 0xCB	; 203
    1b30:	51 e4       	ldi	r21, 0x41	; 65
    1b32:	d8 01       	movw	r26, r16
    1b34:	95 96       	adiw	r26, 0x25	; 37
    1b36:	6d 91       	ld	r22, X+
    1b38:	7d 91       	ld	r23, X+
    1b3a:	8d 91       	ld	r24, X+
    1b3c:	9c 91       	ld	r25, X
    1b3e:	98 97       	sbiw	r26, 0x28	; 40
    1b40:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    1b44:	f8 01       	movw	r30, r16
    1b46:	65 a3       	std	Z+37, r22	; 0x25
    1b48:	76 a3       	std	Z+38, r23	; 0x26
    1b4a:	87 a3       	std	Z+39, r24	; 0x27
    1b4c:	90 a7       	std	Z+40, r25	; 0x28
                j = (y + (x * h_x2_div_d))/2
            */

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;
    1b4e:	80 90 bb 0c 	lds	r8, 0x0CBB	; 0x800cbb <gc_block+0x25>
    1b52:	90 90 bc 0c 	lds	r9, 0x0CBC	; 0x800cbc <gc_block+0x26>
    1b56:	a0 90 bd 0c 	lds	r10, 0x0CBD	; 0x800cbd <gc_block+0x27>
    1b5a:	b0 90 be 0c 	lds	r11, 0x0CBE	; 0x800cbe <gc_block+0x28>
    1b5e:	20 e0       	ldi	r18, 0x00	; 0
    1b60:	30 e0       	ldi	r19, 0x00	; 0
    1b62:	40 e8       	ldi	r20, 0x80	; 128
    1b64:	50 e4       	ldi	r21, 0x40	; 64
    1b66:	c5 01       	movw	r24, r10
    1b68:	b4 01       	movw	r22, r8
    1b6a:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    1b6e:	a5 01       	movw	r20, r10
    1b70:	94 01       	movw	r18, r8
    1b72:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    1b76:	4b 01       	movw	r8, r22
    1b78:	5c 01       	movw	r10, r24
    1b7a:	2f a1       	ldd	r18, Y+39	; 0x27
    1b7c:	38 a5       	ldd	r19, Y+40	; 0x28
    1b7e:	49 a5       	ldd	r20, Y+41	; 0x29
    1b80:	5a a5       	ldd	r21, Y+42	; 0x2a
    1b82:	ca 01       	movw	r24, r20
    1b84:	b9 01       	movw	r22, r18
    1b86:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    1b8a:	9b 01       	movw	r18, r22
    1b8c:	ac 01       	movw	r20, r24
    1b8e:	c5 01       	movw	r24, r10
    1b90:	b4 01       	movw	r22, r8
    1b92:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    1b96:	4b 01       	movw	r8, r22
    1b98:	5c 01       	movw	r10, r24
    1b9a:	2b a5       	ldd	r18, Y+43	; 0x2b
    1b9c:	3c a5       	ldd	r19, Y+44	; 0x2c
    1b9e:	4d a5       	ldd	r20, Y+45	; 0x2d
    1ba0:	5e a5       	ldd	r21, Y+46	; 0x2e
    1ba2:	ca 01       	movw	r24, r20
    1ba4:	b9 01       	movw	r22, r18
    1ba6:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    1baa:	9b 01       	movw	r18, r22
    1bac:	ac 01       	movw	r20, r24
    1bae:	c5 01       	movw	r24, r10
    1bb0:	b4 01       	movw	r22, r8
    1bb2:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    1bb6:	4b 01       	movw	r8, r22
    1bb8:	5c 01       	movw	r10, r24

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    1bba:	20 e0       	ldi	r18, 0x00	; 0
    1bbc:	30 e0       	ldi	r19, 0x00	; 0
    1bbe:	a9 01       	movw	r20, r18
    1bc0:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    1bc4:	88 23       	and	r24, r24
    1bc6:	0c f4       	brge	.+2      	; 0x1bca <gc_execute_line+0xcf2>
    1bc8:	18 c4       	rjmp	.+2096   	; 0x23fa <__stack+0x1fb>

            // Finish computing h_x2_div_d.
            h_x2_div_d = -sqrt(h_x2_div_d)/hypot_f(x,y); // == -(h * 2 / d)
    1bca:	c5 01       	movw	r24, r10
    1bcc:	b4 01       	movw	r22, r8
    1bce:	0e 94 6b 42 	call	0x84d6	; 0x84d6 <sqrt>
    1bd2:	4b 01       	movw	r8, r22
    1bd4:	5c 01       	movw	r10, r24
    1bd6:	2b a5       	ldd	r18, Y+43	; 0x2b
    1bd8:	3c a5       	ldd	r19, Y+44	; 0x2c
    1bda:	4d a5       	ldd	r20, Y+45	; 0x2d
    1bdc:	5e a5       	ldd	r21, Y+46	; 0x2e
    1bde:	6f a1       	ldd	r22, Y+39	; 0x27
    1be0:	78 a5       	ldd	r23, Y+40	; 0x28
    1be2:	89 a5       	ldd	r24, Y+41	; 0x29
    1be4:	9a a5       	ldd	r25, Y+42	; 0x2a
    1be6:	0e 94 3d 2f 	call	0x5e7a	; 0x5e7a <hypot_f>
    1bea:	9b 01       	movw	r18, r22
    1bec:	ac 01       	movw	r20, r24
    1bee:	c5 01       	movw	r24, r10
    1bf0:	b4 01       	movw	r22, r8
    1bf2:	90 58       	subi	r25, 0x80	; 128
    1bf4:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <__divsf3>
    1bf8:	4b 01       	movw	r8, r22
    1bfa:	5c 01       	movw	r10, r24
            // Invert the sign of h_x2_div_d if the circle is counter clockwise (see sketch below)
            if (gc_block.modal.motion == MOTION_MODE_CCW_ARC) { h_x2_div_d = -h_x2_div_d; }
    1bfc:	80 91 97 0c 	lds	r24, 0x0C97	; 0x800c97 <gc_block+0x1>
    1c00:	83 30       	cpi	r24, 0x03	; 3
    1c02:	21 f4       	brne	.+8      	; 0x1c0c <gc_execute_line+0xd34>
    1c04:	b7 fa       	bst	r11, 7
    1c06:	b0 94       	com	r11
    1c08:	b7 f8       	bld	r11, 7
    1c0a:	b0 94       	com	r11
            */
            // Negative R is g-code-alese for "I want a circle with more than 180 degrees of travel" (go figure!),
            // even though it is advised against ever generating such circles in a single line of g-code. By
            // inverting the sign of h_x2_div_d the center of the circles is placed on the opposite side of the line of
            // travel and thus we get the unadvisably long arcs as prescribed.
            if (gc_block.values.r < 0) {
    1c0c:	40 90 bb 0c 	lds	r4, 0x0CBB	; 0x800cbb <gc_block+0x25>
    1c10:	50 90 bc 0c 	lds	r5, 0x0CBC	; 0x800cbc <gc_block+0x26>
    1c14:	60 90 bd 0c 	lds	r6, 0x0CBD	; 0x800cbd <gc_block+0x27>
    1c18:	70 90 be 0c 	lds	r7, 0x0CBE	; 0x800cbe <gc_block+0x28>
    1c1c:	20 e0       	ldi	r18, 0x00	; 0
    1c1e:	30 e0       	ldi	r19, 0x00	; 0
    1c20:	a9 01       	movw	r20, r18
    1c22:	c3 01       	movw	r24, r6
    1c24:	b2 01       	movw	r22, r4
    1c26:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    1c2a:	88 23       	and	r24, r24
    1c2c:	84 f4       	brge	.+32     	; 0x1c4e <gc_execute_line+0xd76>
                h_x2_div_d = -h_x2_div_d;
    1c2e:	b7 fa       	bst	r11, 7
    1c30:	b0 94       	com	r11
    1c32:	b7 f8       	bld	r11, 7
    1c34:	b0 94       	com	r11
                gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
    1c36:	77 fa       	bst	r7, 7
    1c38:	70 94       	com	r7
    1c3a:	77 f8       	bld	r7, 7
    1c3c:	70 94       	com	r7
    1c3e:	40 92 bb 0c 	sts	0x0CBB, r4	; 0x800cbb <gc_block+0x25>
    1c42:	50 92 bc 0c 	sts	0x0CBC, r5	; 0x800cbc <gc_block+0x26>
    1c46:	60 92 bd 0c 	sts	0x0CBD, r6	; 0x800cbd <gc_block+0x27>
    1c4a:	70 92 be 0c 	sts	0x0CBE, r7	; 0x800cbe <gc_block+0x28>
            }
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
    1c4e:	08 a9       	ldd	r16, Y+48	; 0x30
    1c50:	19 a9       	ldd	r17, Y+49	; 0x31
    1c52:	00 0f       	add	r16, r16
    1c54:	11 1f       	adc	r17, r17
    1c56:	00 0f       	add	r16, r16
    1c58:	11 1f       	adc	r17, r17
    1c5a:	0a 55       	subi	r16, 0x5A	; 90
    1c5c:	13 4f       	sbci	r17, 0xF3	; 243
    1c5e:	2b a5       	ldd	r18, Y+43	; 0x2b
    1c60:	3c a5       	ldd	r19, Y+44	; 0x2c
    1c62:	4d a5       	ldd	r20, Y+45	; 0x2d
    1c64:	5e a5       	ldd	r21, Y+46	; 0x2e
    1c66:	c5 01       	movw	r24, r10
    1c68:	b4 01       	movw	r22, r8
    1c6a:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    1c6e:	9b 01       	movw	r18, r22
    1c70:	ac 01       	movw	r20, r24
    1c72:	6f a1       	ldd	r22, Y+39	; 0x27
    1c74:	78 a5       	ldd	r23, Y+40	; 0x28
    1c76:	89 a5       	ldd	r24, Y+41	; 0x29
    1c78:	9a a5       	ldd	r25, Y+42	; 0x2a
    1c7a:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    1c7e:	20 e0       	ldi	r18, 0x00	; 0
    1c80:	30 e0       	ldi	r19, 0x00	; 0
    1c82:	40 e0       	ldi	r20, 0x00	; 0
    1c84:	5f e3       	ldi	r21, 0x3F	; 63
    1c86:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    1c8a:	d8 01       	movw	r26, r16
    1c8c:	6d 93       	st	X+, r22
    1c8e:	7d 93       	st	X+, r23
    1c90:	8d 93       	st	X+, r24
    1c92:	9c 93       	st	X, r25
    1c94:	13 97       	sbiw	r26, 0x03	; 3
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
    1c96:	86 01       	movw	r16, r12
    1c98:	00 0f       	add	r16, r16
    1c9a:	11 1f       	adc	r17, r17
    1c9c:	00 0f       	add	r16, r16
    1c9e:	11 1f       	adc	r17, r17
    1ca0:	0a 55       	subi	r16, 0x5A	; 90
    1ca2:	13 4f       	sbci	r17, 0xF3	; 243
    1ca4:	2f a1       	ldd	r18, Y+39	; 0x27
    1ca6:	38 a5       	ldd	r19, Y+40	; 0x28
    1ca8:	49 a5       	ldd	r20, Y+41	; 0x29
    1caa:	5a a5       	ldd	r21, Y+42	; 0x2a
    1cac:	c5 01       	movw	r24, r10
    1cae:	b4 01       	movw	r22, r8
    1cb0:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    1cb4:	2b a5       	ldd	r18, Y+43	; 0x2b
    1cb6:	3c a5       	ldd	r19, Y+44	; 0x2c
    1cb8:	4d a5       	ldd	r20, Y+45	; 0x2d
    1cba:	5e a5       	ldd	r21, Y+46	; 0x2e
    1cbc:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    1cc0:	20 e0       	ldi	r18, 0x00	; 0
    1cc2:	30 e0       	ldi	r19, 0x00	; 0
    1cc4:	40 e0       	ldi	r20, 0x00	; 0
    1cc6:	5f e3       	ldi	r21, 0x3F	; 63
    1cc8:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    1ccc:	f8 01       	movw	r30, r16
    1cce:	60 83       	st	Z, r22
    1cd0:	71 83       	std	Z+1, r23	; 0x01
    1cd2:	82 83       	std	Z+2, r24	; 0x02
    1cd4:	93 83       	std	Z+3, r25	; 0x03
    1cd6:	c6 c0       	rjmp	.+396    	; 0x1e64 <gc_execute_line+0xf8c>

          } else { // Arc Center Format Offset Mode
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    1cd8:	fb a1       	ldd	r31, Y+35	; 0x23
    1cda:	8f 2e       	mov	r8, r31
    1cdc:	91 2c       	mov	r9, r1
    1cde:	08 21       	and	r16, r8
    1ce0:	19 21       	and	r17, r9
    1ce2:	01 2b       	or	r16, r17
    1ce4:	09 f4       	brne	.+2      	; 0x1ce8 <gc_execute_line+0xe10>
    1ce6:	8b c3       	rjmp	.+1814   	; 0x23fe <__stack+0x1ff>
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));
    1ce8:	21 ef       	ldi	r18, 0xF1	; 241
    1cea:	22 22       	and	r2, r18

            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
    1cec:	80 91 99 0c 	lds	r24, 0x0C99	; 0x800c99 <gc_block+0x3>
    1cf0:	81 30       	cpi	r24, 0x01	; 1
    1cf2:	41 f5       	brne	.+80     	; 0x1d44 <gc_execute_line+0xe6c>
    1cf4:	06 e9       	ldi	r16, 0x96	; 150
    1cf6:	1c e0       	ldi	r17, 0x0C	; 12
    1cf8:	a1 2c       	mov	r10, r1
    1cfa:	b1 2c       	mov	r11, r1
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
    1cfc:	c4 01       	movw	r24, r8
    1cfe:	0a 2c       	mov	r0, r10
    1d00:	02 c0       	rjmp	.+4      	; 0x1d06 <gc_execute_line+0xe2e>
    1d02:	95 95       	asr	r25
    1d04:	87 95       	ror	r24
    1d06:	0a 94       	dec	r0
    1d08:	e2 f7       	brpl	.-8      	; 0x1d02 <gc_execute_line+0xe2a>
    1d0a:	80 ff       	sbrs	r24, 0
    1d0c:	12 c0       	rjmp	.+36     	; 0x1d32 <gc_execute_line+0xe5a>
    1d0e:	23 e3       	ldi	r18, 0x33	; 51
    1d10:	33 e3       	ldi	r19, 0x33	; 51
    1d12:	4b ec       	ldi	r20, 0xCB	; 203
    1d14:	51 e4       	ldi	r21, 0x41	; 65
    1d16:	d8 01       	movw	r26, r16
    1d18:	50 96       	adiw	r26, 0x10	; 16
    1d1a:	6d 91       	ld	r22, X+
    1d1c:	7d 91       	ld	r23, X+
    1d1e:	8d 91       	ld	r24, X+
    1d20:	9c 91       	ld	r25, X
    1d22:	53 97       	sbiw	r26, 0x13	; 19
    1d24:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    1d28:	f8 01       	movw	r30, r16
    1d2a:	60 8b       	std	Z+16, r22	; 0x10
    1d2c:	71 8b       	std	Z+17, r23	; 0x11
    1d2e:	82 8b       	std	Z+18, r24	; 0x12
    1d30:	93 8b       	std	Z+19, r25	; 0x13
    1d32:	ff ef       	ldi	r31, 0xFF	; 255
    1d34:	af 1a       	sub	r10, r31
    1d36:	bf 0a       	sbc	r11, r31
    1d38:	0c 5f       	subi	r16, 0xFC	; 252
    1d3a:	1f 4f       	sbci	r17, 0xFF	; 255
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));

            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    1d3c:	23 e0       	ldi	r18, 0x03	; 3
    1d3e:	a2 16       	cp	r10, r18
    1d40:	b1 04       	cpc	r11, r1
    1d42:	e1 f6       	brne	.-72     	; 0x1cfc <gc_execute_line+0xe24>
              }
            }

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
    1d44:	c6 01       	movw	r24, r12
    1d46:	88 0f       	add	r24, r24
    1d48:	99 1f       	adc	r25, r25
    1d4a:	88 0f       	add	r24, r24
    1d4c:	99 1f       	adc	r25, r25
    1d4e:	dc 01       	movw	r26, r24
    1d50:	aa 55       	subi	r26, 0x5A	; 90
    1d52:	b3 4f       	sbci	r27, 0xF3	; 243
    1d54:	6d 01       	movw	r12, r26
            float target_r = hypot_f(x,y);
    1d56:	2d 91       	ld	r18, X+
    1d58:	3d 91       	ld	r19, X+
    1d5a:	4d 91       	ld	r20, X+
    1d5c:	5c 91       	ld	r21, X
    1d5e:	6b a5       	ldd	r22, Y+43	; 0x2b
    1d60:	7c a5       	ldd	r23, Y+44	; 0x2c
    1d62:	8d a5       	ldd	r24, Y+45	; 0x2d
    1d64:	9e a5       	ldd	r25, Y+46	; 0x2e
    1d66:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    1d6a:	4b 01       	movw	r8, r22
    1d6c:	5c 01       	movw	r10, r24
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
              }
            }

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
    1d6e:	08 a9       	ldd	r16, Y+48	; 0x30
    1d70:	19 a9       	ldd	r17, Y+49	; 0x31
    1d72:	00 0f       	add	r16, r16
    1d74:	11 1f       	adc	r17, r17
    1d76:	00 0f       	add	r16, r16
    1d78:	11 1f       	adc	r17, r17
    1d7a:	0a 55       	subi	r16, 0x5A	; 90
    1d7c:	13 4f       	sbci	r17, 0xF3	; 243
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
            float target_r = hypot_f(x,y);
    1d7e:	f8 01       	movw	r30, r16
    1d80:	20 81       	ld	r18, Z
    1d82:	31 81       	ldd	r19, Z+1	; 0x01
    1d84:	42 81       	ldd	r20, Z+2	; 0x02
    1d86:	53 81       	ldd	r21, Z+3	; 0x03
    1d88:	6f a1       	ldd	r22, Y+39	; 0x27
    1d8a:	78 a5       	ldd	r23, Y+40	; 0x28
    1d8c:	89 a5       	ldd	r24, Y+41	; 0x29
    1d8e:	9a a5       	ldd	r25, Y+42	; 0x2a
    1d90:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    1d94:	a5 01       	movw	r20, r10
    1d96:	94 01       	movw	r18, r8
    1d98:	0e 94 3d 2f 	call	0x5e7a	; 0x5e7a <hypot_f>
    1d9c:	4b 01       	movw	r8, r22
    1d9e:	5c 01       	movw	r10, r24

            // Compute arc radius for mc_arc. Defined from current location to center.
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]);
    1da0:	d6 01       	movw	r26, r12
    1da2:	2d 91       	ld	r18, X+
    1da4:	3d 91       	ld	r19, X+
    1da6:	4d 91       	ld	r20, X+
    1da8:	5c 91       	ld	r21, X
    1daa:	f8 01       	movw	r30, r16
    1dac:	60 81       	ld	r22, Z
    1dae:	71 81       	ldd	r23, Z+1	; 0x01
    1db0:	82 81       	ldd	r24, Z+2	; 0x02
    1db2:	93 81       	ldd	r25, Z+3	; 0x03
    1db4:	0e 94 3d 2f 	call	0x5e7a	; 0x5e7a <hypot_f>
    1db8:	2b 01       	movw	r4, r22
    1dba:	3c 01       	movw	r6, r24
    1dbc:	60 93 bb 0c 	sts	0x0CBB, r22	; 0x800cbb <gc_block+0x25>
    1dc0:	70 93 bc 0c 	sts	0x0CBC, r23	; 0x800cbc <gc_block+0x26>
    1dc4:	80 93 bd 0c 	sts	0x0CBD, r24	; 0x800cbd <gc_block+0x27>
    1dc8:	90 93 be 0c 	sts	0x0CBE, r25	; 0x800cbe <gc_block+0x28>

            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
    1dcc:	9b 01       	movw	r18, r22
    1dce:	ac 01       	movw	r20, r24
    1dd0:	c5 01       	movw	r24, r10
    1dd2:	b4 01       	movw	r22, r8
    1dd4:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    1dd8:	4b 01       	movw	r8, r22
    1dda:	5c 01       	movw	r10, r24
    1ddc:	e8 94       	clt
    1dde:	b7 f8       	bld	r11, 7
            if (delta_r > 0.005) {
    1de0:	2a e0       	ldi	r18, 0x0A	; 10
    1de2:	37 ed       	ldi	r19, 0xD7	; 215
    1de4:	43 ea       	ldi	r20, 0xA3	; 163
    1de6:	5b e3       	ldi	r21, 0x3B	; 59
    1de8:	c5 01       	movw	r24, r10
    1dea:	b4 01       	movw	r22, r8
    1dec:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    1df0:	18 16       	cp	r1, r24
    1df2:	c4 f5       	brge	.+112    	; 0x1e64 <gc_execute_line+0xf8c>
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    1df4:	20 e0       	ldi	r18, 0x00	; 0
    1df6:	30 e0       	ldi	r19, 0x00	; 0
    1df8:	40 e0       	ldi	r20, 0x00	; 0
    1dfa:	5f e3       	ldi	r21, 0x3F	; 63
    1dfc:	c5 01       	movw	r24, r10
    1dfe:	b4 01       	movw	r22, r8
    1e00:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    1e04:	18 16       	cp	r1, r24
    1e06:	0c f4       	brge	.+2      	; 0x1e0a <gc_execute_line+0xf32>
    1e08:	fc c2       	rjmp	.+1528   	; 0x2402 <__stack+0x203>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    1e0a:	2f e6       	ldi	r18, 0x6F	; 111
    1e0c:	32 e1       	ldi	r19, 0x12	; 18
    1e0e:	43 e8       	ldi	r20, 0x83	; 131
    1e10:	5a e3       	ldi	r21, 0x3A	; 58
    1e12:	c3 01       	movw	r24, r6
    1e14:	b2 01       	movw	r22, r4
    1e16:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    1e1a:	9b 01       	movw	r18, r22
    1e1c:	ac 01       	movw	r20, r24
    1e1e:	c5 01       	movw	r24, r10
    1e20:	b4 01       	movw	r22, r8
    1e22:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    1e26:	18 16       	cp	r1, r24
    1e28:	0c f4       	brge	.+2      	; 0x1e2c <gc_execute_line+0xf54>
    1e2a:	ed c2       	rjmp	.+1498   	; 0x2406 <__stack+0x207>
    1e2c:	1b c0       	rjmp	.+54     	; 0x1e64 <gc_execute_line+0xf8c>
            }
          }
          break;
        case MOTION_MODE_PROBE_TOWARD_NO_ERROR: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          gc_parser_flags |= GC_PARSER_PROBE_IS_NO_ERROR; // No break intentional.
    1e2e:	fc a1       	ldd	r31, Y+36	; 0x24
    1e30:	f0 61       	ori	r31, 0x10	; 16
    1e32:	fc a3       	std	Y+36, r31	; 0x24
        case MOTION_MODE_PROBE_TOWARD: case MOTION_MODE_PROBE_AWAY:
          if ((gc_block.modal.motion == MOTION_MODE_PROBE_AWAY) || 
    1e34:	1e 58       	subi	r17, 0x8E	; 142
    1e36:	12 30       	cpi	r17, 0x02	; 2
    1e38:	18 f4       	brcc	.+6      	; 0x1e40 <gc_execute_line+0xf68>
              (gc_block.modal.motion == MOTION_MODE_PROBE_AWAY_NO_ERROR)) { gc_parser_flags |= GC_PARSER_PROBE_IS_AWAY; }
    1e3a:	2c a1       	ldd	r18, Y+36	; 0x24
    1e3c:	28 60       	ori	r18, 0x08	; 8
    1e3e:	2c a3       	std	Y+36, r18	; 0x24
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1e40:	39 a1       	ldd	r19, Y+33	; 0x21
    1e42:	33 23       	and	r19, r19
    1e44:	09 f4       	brne	.+2      	; 0x1e48 <gc_execute_line+0xf70>
    1e46:	e1 c2       	rjmp	.+1474   	; 0x240a <__stack+0x20b>
          if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    1e48:	4c e0       	ldi	r20, 0x0C	; 12
    1e4a:	50 e0       	ldi	r21, 0x00	; 0
    1e4c:	64 ec       	ldi	r22, 0xC4	; 196
    1e4e:	7c e0       	ldi	r23, 0x0C	; 12
    1e50:	8e e6       	ldi	r24, 0x6E	; 110
    1e52:	9c e0       	ldi	r25, 0x0C	; 12
    1e54:	0e 94 04 43 	call	0x8608	; 0x8608 <memcmp>
    1e58:	89 2b       	or	r24, r25
    1e5a:	09 f4       	brne	.+2      	; 0x1e5e <gc_execute_line+0xf86>
    1e5c:	d8 c2       	rjmp	.+1456   	; 0x240e <__stack+0x20f>
    1e5e:	02 c0       	rjmp	.+4      	; 0x1e64 <gc_execute_line+0xf8c>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    1e60:	1f 8e       	std	Y+31, r1	; 0x1f
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
            }
          } else {
            axis_command = AXIS_COMMAND_NONE; // Set to none if no intermediate motion.
    1e62:	1a a2       	std	Y+34, r1	; 0x22

  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    1e64:	4c a1       	ldd	r20, Y+36	; 0x24
    1e66:	41 70       	andi	r20, 0x01	; 1
    1e68:	d4 2e       	mov	r13, r20
    1e6a:	8c a1       	ldd	r24, Y+36	; 0x24
    1e6c:	80 ff       	sbrs	r24, 0
    1e6e:	03 c0       	rjmp	.+6      	; 0x1e76 <gc_execute_line+0xf9e>
    // Jogging only uses the F feed rate and XYZ value words. N is valid, but S and T are invalid.
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)));
    1e70:	c1 01       	movw	r24, r2
    1e72:	8e 7d       	andi	r24, 0xDE	; 222
    1e74:	03 c0       	rjmp	.+6      	; 0x1e7c <gc_execute_line+0xfa4>
  } else {
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words.
    1e76:	c1 01       	movw	r24, r2
    1e78:	8e 7d       	andi	r24, 0xDE	; 222
    1e7a:	9c 7f       	andi	r25, 0xFC	; 252
  }
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words.
    1e7c:	aa a1       	ldd	r26, Y+34	; 0x22
    1e7e:	a1 11       	cpse	r26, r1
    1e80:	93 7e       	andi	r25, 0xE3	; 227
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    1e82:	89 2b       	or	r24, r25
    1e84:	09 f0       	breq	.+2      	; 0x1e88 <gc_execute_line+0xfb0>
    1e86:	c5 c2       	rjmp	.+1418   	; 0x2412 <__stack+0x213>
  */

  // Initialize planner data struct for motion blocks.
  plan_line_data_t plan_data;
  plan_line_data_t *pl_data = &plan_data;
  memset(pl_data,0,sizeof(plan_line_data_t)); // Zero pl_data struct
    1e88:	fe 01       	movw	r30, r28
    1e8a:	72 96       	adiw	r30, 0x12	; 18
    1e8c:	8d e0       	ldi	r24, 0x0D	; 13
    1e8e:	df 01       	movw	r26, r30
    1e90:	1d 92       	st	X+, r1
    1e92:	8a 95       	dec	r24
    1e94:	e9 f7       	brne	.-6      	; 0x1e90 <gc_execute_line+0xfb8>

  // Intercept jog commands and complete error checking for valid jog commands and execute.
  // NOTE: G-code parser state is not updated, except the position to ensure sequential jog
  // targets are computed correctly. The final parser position after a jog is updated in
  // protocol_execute_realtime() when jogging completes or is canceled.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    1e96:	dd 20       	and	r13, r13
    1e98:	59 f1       	breq	.+86     	; 0x1ef0 <gc_execute_line+0x1018>
    // Only distance and unit modal commands and G53 absolute override command are allowed.
    // NOTE: Feed rate word and axis word checks have already been performed in STEP 3.
    if (command_words & ~(bit(MODAL_GROUP_G3) | bit(MODAL_GROUP_G6 | bit(MODAL_GROUP_G0))) ) { FAIL(STATUS_INVALID_JOG_COMMAND) };
    1e9a:	b6 eb       	ldi	r27, 0xB6	; 182
    1e9c:	eb 22       	and	r14, r27
    1e9e:	ef 28       	or	r14, r15
    1ea0:	09 f0       	breq	.+2      	; 0x1ea4 <gc_execute_line+0xfcc>
    1ea2:	b9 c2       	rjmp	.+1394   	; 0x2416 <__stack+0x217>
    if (!(gc_block.non_modal_command == NON_MODAL_ABSOLUTE_OVERRIDE || gc_block.non_modal_command == NON_MODAL_NO_ACTION)) { FAIL(STATUS_INVALID_JOG_COMMAND); }
    1ea4:	80 91 96 0c 	lds	r24, 0x0C96	; 0x800c96 <gc_block>
    1ea8:	85 33       	cpi	r24, 0x35	; 53
    1eaa:	11 f0       	breq	.+4      	; 0x1eb0 <gc_execute_line+0xfd8>
    1eac:	81 11       	cpse	r24, r1
    1eae:	b5 c2       	rjmp	.+1386   	; 0x241a <__stack+0x21b>

    // Initialize planner data to current spindle and coolant modal state.
    pl_data->spindle_speed = gc_state.spindle_speed;
    1eb0:	e6 e5       	ldi	r30, 0x56	; 86
    1eb2:	fc e0       	ldi	r31, 0x0C	; 12
    1eb4:	83 85       	ldd	r24, Z+11	; 0x0b
    1eb6:	94 85       	ldd	r25, Z+12	; 0x0c
    1eb8:	a5 85       	ldd	r26, Z+13	; 0x0d
    1eba:	b6 85       	ldd	r27, Z+14	; 0x0e
    1ebc:	8e 8b       	std	Y+22, r24	; 0x16
    1ebe:	9f 8b       	std	Y+23, r25	; 0x17
    1ec0:	a8 8f       	std	Y+24, r26	; 0x18
    1ec2:	b9 8f       	std	Y+25, r27	; 0x19
    plan_data.condition = (gc_state.modal.spindle | gc_state.modal.coolant);
    1ec4:	91 85       	ldd	r25, Z+9	; 0x09
    1ec6:	80 85       	ldd	r24, Z+8	; 0x08
    1ec8:	89 2b       	or	r24, r25
    1eca:	8e 8f       	std	Y+30, r24	; 0x1e

    uint8_t status = jog_execute(&plan_data, &gc_block);
    1ecc:	66 e9       	ldi	r22, 0x96	; 150
    1ece:	7c e0       	ldi	r23, 0x0C	; 12
    1ed0:	ce 01       	movw	r24, r28
    1ed2:	42 96       	adiw	r24, 0x12	; 18
    1ed4:	0e 94 85 3e 	call	0x7d0a	; 0x7d0a <jog_execute>
    if (status == STATUS_OK) { memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); }
    1ed8:	81 11       	cpse	r24, r1
    1eda:	ed c2       	rjmp	.+1498   	; 0x24b6 <__stack+0x2b7>
    1edc:	9c e0       	ldi	r25, 0x0C	; 12
    1ede:	e4 ec       	ldi	r30, 0xC4	; 196
    1ee0:	fc e0       	ldi	r31, 0x0C	; 12
    1ee2:	ae e6       	ldi	r26, 0x6E	; 110
    1ee4:	bc e0       	ldi	r27, 0x0C	; 12
    1ee6:	01 90       	ld	r0, Z+
    1ee8:	0d 92       	st	X+, r0
    1eea:	9a 95       	dec	r25
    1eec:	e1 f7       	brne	.-8      	; 0x1ee6 <gc_execute_line+0x100e>
    1eee:	e3 c2       	rjmp	.+1478   	; 0x24b6 <__stack+0x2b7>
    return(status);
  }
  
  // If in laser mode, setup laser power based on current and past parser conditions.
  if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    1ef0:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    1ef4:	81 ff       	sbrs	r24, 1
    1ef6:	26 c0       	rjmp	.+76     	; 0x1f44 <gc_execute_line+0x106c>
    if ( !((gc_block.modal.motion == MOTION_MODE_LINEAR) || (gc_block.modal.motion == MOTION_MODE_CW_ARC) 
    1ef8:	80 91 97 0c 	lds	r24, 0x0C97	; 0x800c97 <gc_block+0x1>
    1efc:	81 50       	subi	r24, 0x01	; 1
    1efe:	83 30       	cpi	r24, 0x03	; 3
    1f00:	18 f0       	brcs	.+6      	; 0x1f08 <gc_execute_line+0x1030>
        || (gc_block.modal.motion == MOTION_MODE_CCW_ARC)) ) {
      gc_parser_flags |= GC_PARSER_LASER_DISABLE;
    1f02:	ec a1       	ldd	r30, Y+36	; 0x24
    1f04:	e0 64       	ori	r30, 0x40	; 64
    1f06:	ec a3       	std	Y+36, r30	; 0x24
    }

    // Any motion mode with axis words is allowed to be passed from a spindle speed update. 
    // NOTE: G1 and G0 without axis words sets axis_command to none. G28/30 are intentionally omitted.
    // TODO: Check sync conditions for M3 enabled motions that don't enter the planner. (zero length).
    if (axis_words && (axis_command == AXIS_COMMAND_MOTION_MODE)) { 
    1f08:	f9 a1       	ldd	r31, Y+33	; 0x21
    1f0a:	ff 23       	and	r31, r31
    1f0c:	39 f0       	breq	.+14     	; 0x1f1c <gc_execute_line+0x1044>
    1f0e:	2a a1       	ldd	r18, Y+34	; 0x22
    1f10:	22 30       	cpi	r18, 0x02	; 2
    1f12:	21 f4       	brne	.+8      	; 0x1f1c <gc_execute_line+0x1044>
      gc_parser_flags |= GC_PARSER_LASER_ISMOTION; 
    1f14:	3c a1       	ldd	r19, Y+36	; 0x24
    1f16:	30 68       	ori	r19, 0x80	; 128
    1f18:	3c a3       	std	Y+36, r19	; 0x24
    1f1a:	14 c0       	rjmp	.+40     	; 0x1f44 <gc_execute_line+0x106c>
    } else {
      // M3 constant power laser requires planner syncs to update the laser when changing between
      // a G1/2/3 motion mode state and vice versa when there is no motion in the line.
      if (gc_state.modal.spindle == SPINDLE_ENABLE_CW) {
    1f1c:	80 91 5f 0c 	lds	r24, 0x0C5F	; 0x800c5f <gc_state+0x9>
    1f20:	80 31       	cpi	r24, 0x10	; 16
    1f22:	81 f4       	brne	.+32     	; 0x1f44 <gc_execute_line+0x106c>
        if ((gc_state.modal.motion == MOTION_MODE_LINEAR) || (gc_state.modal.motion == MOTION_MODE_CW_ARC) 
    1f24:	80 91 56 0c 	lds	r24, 0x0C56	; 0x800c56 <gc_state>
    1f28:	81 50       	subi	r24, 0x01	; 1
    1f2a:	83 30       	cpi	r24, 0x03	; 3
    1f2c:	30 f4       	brcc	.+12     	; 0x1f3a <gc_execute_line+0x1062>
            || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
          if (bit_istrue(gc_parser_flags,GC_PARSER_LASER_DISABLE)) { 
    1f2e:	4c a1       	ldd	r20, Y+36	; 0x24
    1f30:	46 ff       	sbrs	r20, 6
    1f32:	08 c0       	rjmp	.+16     	; 0x1f44 <gc_execute_line+0x106c>
            gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC; // Change from G1/2/3 motion mode.
    1f34:	40 62       	ori	r20, 0x20	; 32
    1f36:	4c a3       	std	Y+36, r20	; 0x24
    1f38:	05 c0       	rjmp	.+10     	; 0x1f44 <gc_execute_line+0x106c>
          }
        } else {
          // When changing to a G1 motion mode without axis words from a non-G1/2/3 motion mode.
          if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_DISABLE)) { 
    1f3a:	8c a1       	ldd	r24, Y+36	; 0x24
    1f3c:	86 fd       	sbrc	r24, 6
    1f3e:	02 c0       	rjmp	.+4      	; 0x1f44 <gc_execute_line+0x106c>
            gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC;
    1f40:	80 62       	ori	r24, 0x20	; 32
    1f42:	8c a3       	std	Y+36, r24	; 0x24
    }
  }

  // [0. Non-specific/common error-checks and miscellaneous setup]:
  // NOTE: If no line number is present, the value is zero.
  gc_state.line_number = gc_block.values.n;
    1f44:	a6 e9       	ldi	r26, 0x96	; 150
    1f46:	bc e0       	ldi	r27, 0x0C	; 12
    1f48:	5d 96       	adiw	r26, 0x1d	; 29
    1f4a:	4d 91       	ld	r20, X+
    1f4c:	5d 91       	ld	r21, X+
    1f4e:	6d 91       	ld	r22, X+
    1f50:	7c 91       	ld	r23, X
    1f52:	90 97       	sbiw	r26, 0x20	; 32
    1f54:	e6 e5       	ldi	r30, 0x56	; 86
    1f56:	fc e0       	ldi	r31, 0x0C	; 12
    1f58:	44 8b       	std	Z+20, r20	; 0x14
    1f5a:	55 8b       	std	Z+21, r21	; 0x15
    1f5c:	66 8b       	std	Z+22, r22	; 0x16
    1f5e:	77 8b       	std	Z+23, r23	; 0x17
  pl_data->line_number = gc_state.line_number; // Record data for planner use.
    1f60:	4a 8f       	std	Y+26, r20	; 0x1a
    1f62:	5b 8f       	std	Y+27, r21	; 0x1b
    1f64:	6c 8f       	std	Y+28, r22	; 0x1c
    1f66:	7d 8f       	std	Y+29, r23	; 0x1d

  // [1. Comments feedback ]:  NOT SUPPORTED

  // [2. Set feed rate mode ]:
  gc_state.modal.feed_rate = gc_block.modal.feed_rate;
    1f68:	12 96       	adiw	r26, 0x02	; 2
    1f6a:	8c 91       	ld	r24, X
    1f6c:	81 83       	std	Z+1, r24	; 0x01
  if (gc_state.modal.feed_rate) { pl_data->condition |= PL_COND_FLAG_INVERSE_TIME; } // Set condition flag for planner use.
    1f6e:	88 23       	and	r24, r24
    1f70:	11 f0       	breq	.+4      	; 0x1f76 <gc_execute_line+0x109e>
    1f72:	88 e0       	ldi	r24, 0x08	; 8
    1f74:	8e 8f       	std	Y+30, r24	; 0x1e

  // [3. Set feed rate ]:
  gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
    1f76:	a6 e9       	ldi	r26, 0x96	; 150
    1f78:	bc e0       	ldi	r27, 0x0C	; 12
    1f7a:	1c 96       	adiw	r26, 0x0c	; 12
    1f7c:	4d 91       	ld	r20, X+
    1f7e:	5d 91       	ld	r21, X+
    1f80:	6d 91       	ld	r22, X+
    1f82:	7c 91       	ld	r23, X
    1f84:	1f 97       	sbiw	r26, 0x0f	; 15
    1f86:	e6 e5       	ldi	r30, 0x56	; 86
    1f88:	fc e0       	ldi	r31, 0x0C	; 12
    1f8a:	47 87       	std	Z+15, r20	; 0x0f
    1f8c:	50 8b       	std	Z+16, r21	; 0x10
    1f8e:	61 8b       	std	Z+17, r22	; 0x11
    1f90:	72 8b       	std	Z+18, r23	; 0x12
  pl_data->feed_rate = gc_state.feed_rate; // Record data for planner use.
    1f92:	4a 8b       	std	Y+18, r20	; 0x12
    1f94:	5b 8b       	std	Y+19, r21	; 0x13
    1f96:	6c 8b       	std	Y+20, r22	; 0x14
    1f98:	7d 8b       	std	Y+21, r23	; 0x15

  // [4. Set spindle speed ]:
  if ((gc_state.spindle_speed != gc_block.values.s) || bit_istrue(gc_parser_flags,GC_PARSER_LASER_FORCE_SYNC)) {
    1f9a:	99 96       	adiw	r26, 0x29	; 41
    1f9c:	8d 90       	ld	r8, X+
    1f9e:	9d 90       	ld	r9, X+
    1fa0:	ad 90       	ld	r10, X+
    1fa2:	bc 90       	ld	r11, X
    1fa4:	9c 97       	sbiw	r26, 0x2c	; 44
    1fa6:	a5 01       	movw	r20, r10
    1fa8:	94 01       	movw	r18, r8
    1faa:	63 85       	ldd	r22, Z+11	; 0x0b
    1fac:	74 85       	ldd	r23, Z+12	; 0x0c
    1fae:	85 85       	ldd	r24, Z+13	; 0x0d
    1fb0:	96 85       	ldd	r25, Z+14	; 0x0e
    1fb2:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    1fb6:	81 11       	cpse	r24, r1
    1fb8:	03 c0       	rjmp	.+6      	; 0x1fc0 <gc_execute_line+0x10e8>
    1fba:	9c a1       	ldd	r25, Y+36	; 0x24
    1fbc:	95 ff       	sbrs	r25, 5
    1fbe:	21 c0       	rjmp	.+66     	; 0x2002 <gc_execute_line+0x112a>
    if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
    1fc0:	80 91 5f 0c 	lds	r24, 0x0C5F	; 0x800c5f <gc_state+0x9>
    1fc4:	88 23       	and	r24, r24
    1fc6:	69 f0       	breq	.+26     	; 0x1fe2 <gc_execute_line+0x110a>
      if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_ISMOTION)) {
    1fc8:	ac a1       	ldd	r26, Y+36	; 0x24
    1fca:	aa 23       	and	r26, r26
    1fcc:	54 f0       	brlt	.+20     	; 0x1fe2 <gc_execute_line+0x110a>
        if (bit_istrue(gc_parser_flags,GC_PARSER_LASER_DISABLE)) {
    1fce:	a6 ff       	sbrs	r26, 6
    1fd0:	05 c0       	rjmp	.+10     	; 0x1fdc <gc_execute_line+0x1104>
           spindle_sync(gc_state.modal.spindle, 0.0);
    1fd2:	40 e0       	ldi	r20, 0x00	; 0
    1fd4:	50 e0       	ldi	r21, 0x00	; 0
    1fd6:	ba 01       	movw	r22, r20
    1fd8:	ba d3       	rcall	.+1908   	; 0x274e <spindle_sync>
    1fda:	03 c0       	rjmp	.+6      	; 0x1fe2 <gc_execute_line+0x110a>
        } else { spindle_sync(gc_state.modal.spindle, gc_block.values.s); }
    1fdc:	b5 01       	movw	r22, r10
    1fde:	a4 01       	movw	r20, r8
    1fe0:	b6 d3       	rcall	.+1900   	; 0x274e <spindle_sync>
      }
    }
    gc_state.spindle_speed = gc_block.values.s; // Update spindle speed state.
    1fe2:	80 91 bf 0c 	lds	r24, 0x0CBF	; 0x800cbf <gc_block+0x29>
    1fe6:	90 91 c0 0c 	lds	r25, 0x0CC0	; 0x800cc0 <gc_block+0x2a>
    1fea:	a0 91 c1 0c 	lds	r26, 0x0CC1	; 0x800cc1 <gc_block+0x2b>
    1fee:	b0 91 c2 0c 	lds	r27, 0x0CC2	; 0x800cc2 <gc_block+0x2c>
    1ff2:	80 93 61 0c 	sts	0x0C61, r24	; 0x800c61 <gc_state+0xb>
    1ff6:	90 93 62 0c 	sts	0x0C62, r25	; 0x800c62 <gc_state+0xc>
    1ffa:	a0 93 63 0c 	sts	0x0C63, r26	; 0x800c63 <gc_state+0xd>
    1ffe:	b0 93 64 0c 	sts	0x0C64, r27	; 0x800c64 <gc_state+0xe>
  }
  // NOTE: Pass zero spindle speed for all restricted laser motions.
  if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_DISABLE)) {
    2002:	bc a1       	ldd	r27, Y+36	; 0x24
    2004:	b6 fd       	sbrc	r27, 6
    2006:	0c c0       	rjmp	.+24     	; 0x2020 <gc_execute_line+0x1148>
    pl_data->spindle_speed = gc_state.spindle_speed; // Record data for planner use. 
    2008:	80 91 61 0c 	lds	r24, 0x0C61	; 0x800c61 <gc_state+0xb>
    200c:	90 91 62 0c 	lds	r25, 0x0C62	; 0x800c62 <gc_state+0xc>
    2010:	a0 91 63 0c 	lds	r26, 0x0C63	; 0x800c63 <gc_state+0xd>
    2014:	b0 91 64 0c 	lds	r27, 0x0C64	; 0x800c64 <gc_state+0xe>
    2018:	8e 8b       	std	Y+22, r24	; 0x16
    201a:	9f 8b       	std	Y+23, r25	; 0x17
    201c:	a8 8f       	std	Y+24, r26	; 0x18
    201e:	b9 8f       	std	Y+25, r27	; 0x19
  } // else { pl_data->spindle_speed = 0.0; } // Initialized as zero already.
  
  // [5. Select tool ]: NOT SUPPORTED. Only tracks tool value.
  gc_state.tool = gc_block.values.t;
    2020:	e6 e5       	ldi	r30, 0x56	; 86
    2022:	fc e0       	ldi	r31, 0x0C	; 12
    2024:	a6 e9       	ldi	r26, 0x96	; 150
    2026:	bc e0       	ldi	r27, 0x0C	; 12
    2028:	9d 96       	adiw	r26, 0x2d	; 45
    202a:	8c 91       	ld	r24, X
    202c:	9d 97       	sbiw	r26, 0x2d	; 45
    202e:	83 8b       	std	Z+19, r24	; 0x13

  // [6. Change tool ]: NOT SUPPORTED

  // [7. Spindle control ]:
  if (gc_state.modal.spindle != gc_block.modal.spindle) {
    2030:	1a 96       	adiw	r26, 0x0a	; 10
    2032:	8c 91       	ld	r24, X
    2034:	91 85       	ldd	r25, Z+9	; 0x09
    2036:	98 17       	cp	r25, r24
    2038:	49 f0       	breq	.+18     	; 0x204c <gc_execute_line+0x1174>
    // Update spindle control and apply spindle speed when enabling it in this block.
    // NOTE: All spindle state changes are synced, even in laser mode. Also, pl_data,
    // rather than gc_state, is used to manage laser state for non-laser motions.
    spindle_sync(gc_block.modal.spindle, pl_data->spindle_speed);
    203a:	4e 89       	ldd	r20, Y+22	; 0x16
    203c:	5f 89       	ldd	r21, Y+23	; 0x17
    203e:	68 8d       	ldd	r22, Y+24	; 0x18
    2040:	79 8d       	ldd	r23, Y+25	; 0x19
    2042:	85 d3       	rcall	.+1802   	; 0x274e <spindle_sync>
    gc_state.modal.spindle = gc_block.modal.spindle;
    2044:	80 91 a0 0c 	lds	r24, 0x0CA0	; 0x800ca0 <gc_block+0xa>
    2048:	80 93 5f 0c 	sts	0x0C5F, r24	; 0x800c5f <gc_state+0x9>
  }
  pl_data->condition |= gc_state.modal.spindle; // Set condition flag for planner use.
    204c:	e6 e5       	ldi	r30, 0x56	; 86
    204e:	fc e0       	ldi	r31, 0x0C	; 12
    2050:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2052:	81 85       	ldd	r24, Z+9	; 0x09
    2054:	89 2b       	or	r24, r25
    2056:	8e 8f       	std	Y+30, r24	; 0x1e

  // [8. Coolant control ]:
  if (gc_state.modal.coolant != gc_block.modal.coolant) {
    2058:	80 91 9f 0c 	lds	r24, 0x0C9F	; 0x800c9f <gc_block+0x9>
    205c:	90 85       	ldd	r25, Z+8	; 0x08
    205e:	98 17       	cp	r25, r24
    // NOTE: Coolant M-codes are modal. Only one command per line is allowed. But, multiple states
    // can exist at the same time, while coolant disable clears all states.
    coolant_sync(gc_block.modal.coolant);
    2060:	29 f0       	breq	.+10     	; 0x206c <gc_execute_line+0x1194>
    2062:	cc d3       	rcall	.+1944   	; 0x27fc <coolant_sync>
    gc_state.modal.coolant = gc_block.modal.coolant;
    2064:	80 91 9f 0c 	lds	r24, 0x0C9F	; 0x800c9f <gc_block+0x9>
    2068:	80 93 5e 0c 	sts	0x0C5E, r24	; 0x800c5e <gc_state+0x8>
  }
  pl_data->condition |= gc_state.modal.coolant; // Set condition flag for planner use.
    206c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    206e:	80 91 5e 0c 	lds	r24, 0x0C5E	; 0x800c5e <gc_state+0x8>
    2072:	89 2b       	or	r24, r25
    2074:	8e 8f       	std	Y+30, r24	; 0x1e
      mc_override_ctrl_update(gc_state.modal.override);
    }
  #endif

  // [10. Dwell ]:
  if (gc_block.non_modal_command == NON_MODAL_DWELL) { mc_dwell(gc_block.values.p); }
    2076:	80 91 96 0c 	lds	r24, 0x0C96	; 0x800c96 <gc_block>
    207a:	84 30       	cpi	r24, 0x04	; 4
    207c:	51 f4       	brne	.+20     	; 0x2092 <gc_execute_line+0x11ba>
    207e:	60 91 b7 0c 	lds	r22, 0x0CB7	; 0x800cb7 <gc_block+0x21>
    2082:	70 91 b8 0c 	lds	r23, 0x0CB8	; 0x800cb8 <gc_block+0x22>
    2086:	80 91 b9 0c 	lds	r24, 0x0CB9	; 0x800cb9 <gc_block+0x23>
    208a:	90 91 ba 0c 	lds	r25, 0x0CBA	; 0x800cba <gc_block+0x24>
    208e:	0e 94 87 06 	call	0xd0e	; 0xd0e <mc_dwell>

  // [11. Set active plane ]:
  gc_state.modal.plane_select = gc_block.modal.plane_select;
    2092:	e6 e5       	ldi	r30, 0x56	; 86
    2094:	fc e0       	ldi	r31, 0x0C	; 12
    2096:	a6 e9       	ldi	r26, 0x96	; 150
    2098:	bc e0       	ldi	r27, 0x0C	; 12
    209a:	15 96       	adiw	r26, 0x05	; 5
    209c:	8c 91       	ld	r24, X
    209e:	15 97       	sbiw	r26, 0x05	; 5
    20a0:	84 83       	std	Z+4, r24	; 0x04

  // [12. Set length units ]:
  gc_state.modal.units = gc_block.modal.units;
    20a2:	13 96       	adiw	r26, 0x03	; 3
    20a4:	8c 91       	ld	r24, X
    20a6:	82 83       	std	Z+2, r24	; 0x02

  // [14. Cutter length compensation ]: G43.1 and G49 supported. G43 NOT SUPPORTED.
  // NOTE: If G43 were supported, its operation wouldn't be any different from G43.1 in terms
  // of execution. The error-checking step would simply load the offset value into the correct
  // axis of the block XYZ value array.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates a change.
    20a8:	ea a1       	ldd	r30, Y+34	; 0x22
    20aa:	e3 30       	cpi	r30, 0x03	; 3
    20ac:	71 f5       	brne	.+92     	; 0x210a <gc_execute_line+0x1232>
    gc_state.modal.tool_length = gc_block.modal.tool_length;
    20ae:	80 91 9c 0c 	lds	r24, 0x0C9C	; 0x800c9c <gc_block+0x6>
    20b2:	80 93 5b 0c 	sts	0x0C5B, r24	; 0x800c5b <gc_state+0x5>
    if (gc_state.modal.tool_length == TOOL_LENGTH_OFFSET_CANCEL) { // G49
    20b6:	81 11       	cpse	r24, r1
    20b8:	08 c0       	rjmp	.+16     	; 0x20ca <gc_execute_line+0x11f2>
      gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] = 0.0;
    20ba:	10 92 cc 0c 	sts	0x0CCC, r1	; 0x800ccc <gc_block+0x36>
    20be:	10 92 cd 0c 	sts	0x0CCD, r1	; 0x800ccd <gc_block+0x37>
    20c2:	10 92 ce 0c 	sts	0x0CCE, r1	; 0x800cce <gc_block+0x38>
    20c6:	10 92 cf 0c 	sts	0x0CCF, r1	; 0x800ccf <gc_block+0x39>
    } // else G43.1
    if ( gc_state.tool_length_offset != gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] ) {
    20ca:	80 90 cc 0c 	lds	r8, 0x0CCC	; 0x800ccc <gc_block+0x36>
    20ce:	90 90 cd 0c 	lds	r9, 0x0CCD	; 0x800ccd <gc_block+0x37>
    20d2:	a0 90 ce 0c 	lds	r10, 0x0CCE	; 0x800cce <gc_block+0x38>
    20d6:	b0 90 cf 0c 	lds	r11, 0x0CCF	; 0x800ccf <gc_block+0x39>
    20da:	a5 01       	movw	r20, r10
    20dc:	94 01       	movw	r18, r8
    20de:	60 91 92 0c 	lds	r22, 0x0C92	; 0x800c92 <gc_state+0x3c>
    20e2:	70 91 93 0c 	lds	r23, 0x0C93	; 0x800c93 <gc_state+0x3d>
    20e6:	80 91 94 0c 	lds	r24, 0x0C94	; 0x800c94 <gc_state+0x3e>
    20ea:	90 91 95 0c 	lds	r25, 0x0C95	; 0x800c95 <gc_state+0x3f>
    20ee:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    20f2:	88 23       	and	r24, r24
    20f4:	51 f0       	breq	.+20     	; 0x210a <gc_execute_line+0x1232>
      gc_state.tool_length_offset = gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS];
    20f6:	80 92 92 0c 	sts	0x0C92, r8	; 0x800c92 <gc_state+0x3c>
    20fa:	90 92 93 0c 	sts	0x0C93, r9	; 0x800c93 <gc_state+0x3d>
    20fe:	a0 92 94 0c 	sts	0x0C94, r10	; 0x800c94 <gc_state+0x3e>
    2102:	b0 92 95 0c 	sts	0x0C95, r11	; 0x800c95 <gc_state+0x3f>
      system_flag_wco_change();
    2106:	0e 94 32 3b 	call	0x7664	; 0x7664 <system_flag_wco_change>
    }
  }

  // [15. Coordinate system selection ]:
  if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    210a:	80 91 9d 0c 	lds	r24, 0x0C9D	; 0x800c9d <gc_block+0x7>
    210e:	90 91 5c 0c 	lds	r25, 0x0C5C	; 0x800c5c <gc_state+0x6>
    2112:	98 17       	cp	r25, r24
    2114:	69 f0       	breq	.+26     	; 0x2130 <gc_execute_line+0x1258>
    gc_state.modal.coord_select = gc_block.modal.coord_select;
    2116:	80 93 5c 0c 	sts	0x0C5C, r24	; 0x800c5c <gc_state+0x6>
    memcpy(gc_state.coord_system,block_coord_system,N_AXIS*sizeof(float));
    211a:	8c e0       	ldi	r24, 0x0C	; 12
    211c:	fe 01       	movw	r30, r28
    211e:	36 96       	adiw	r30, 0x06	; 6
    2120:	aa e7       	ldi	r26, 0x7A	; 122
    2122:	bc e0       	ldi	r27, 0x0C	; 12
    2124:	01 90       	ld	r0, Z+
    2126:	0d 92       	st	X+, r0
    2128:	8a 95       	dec	r24
    212a:	e1 f7       	brne	.-8      	; 0x2124 <gc_execute_line+0x124c>
    system_flag_wco_change();
    212c:	0e 94 32 3b 	call	0x7664	; 0x7664 <system_flag_wco_change>

  // [16. Set path control mode ]: G61.1/G64 NOT SUPPORTED
  // gc_state.modal.control = gc_block.modal.control; // NOTE: Always default.

  // [17. Set distance mode ]:
  gc_state.modal.distance = gc_block.modal.distance;
    2130:	e6 e9       	ldi	r30, 0x96	; 150
    2132:	fc e0       	ldi	r31, 0x0C	; 12
    2134:	84 81       	ldd	r24, Z+4	; 0x04
    2136:	80 93 59 0c 	sts	0x0C59, r24	; 0x800c59 <gc_state+0x3>

  // [18. Set retract mode ]: NOT SUPPORTED

  // [19. Go to predefined position, Set G10, or Set axis offsets ]:
  switch(gc_block.non_modal_command) {
    213a:	80 81       	ld	r24, Z
    213c:	86 32       	cpi	r24, 0x26	; 38
    213e:	09 f4       	brne	.+2      	; 0x2142 <gc_execute_line+0x126a>
    2140:	46 c0       	rjmp	.+140    	; 0x21ce <gc_execute_line+0x12f6>
    2142:	38 f4       	brcc	.+14     	; 0x2152 <gc_execute_line+0x127a>
    2144:	8c 31       	cpi	r24, 0x1C	; 28
    2146:	29 f1       	breq	.+74     	; 0x2192 <gc_execute_line+0x12ba>
    2148:	8e 31       	cpi	r24, 0x1E	; 30
    214a:	19 f1       	breq	.+70     	; 0x2192 <gc_execute_line+0x12ba>
    214c:	8a 30       	cpi	r24, 0x0A	; 10
    214e:	59 f0       	breq	.+22     	; 0x2166 <gc_execute_line+0x128e>
    2150:	5f c0       	rjmp	.+190    	; 0x2210 <__stack+0x11>
    2152:	8c 35       	cpi	r24, 0x5C	; 92
    2154:	09 f4       	brne	.+2      	; 0x2158 <gc_execute_line+0x1280>
    2156:	47 c0       	rjmp	.+142    	; 0x21e6 <gc_execute_line+0x130e>
    2158:	86 36       	cpi	r24, 0x66	; 102
    215a:	09 f4       	brne	.+2      	; 0x215e <gc_execute_line+0x1286>
    215c:	50 c0       	rjmp	.+160    	; 0x21fe <gc_execute_line+0x1326>
    215e:	88 32       	cpi	r24, 0x28	; 40
    2160:	09 f0       	breq	.+2      	; 0x2164 <gc_execute_line+0x128c>
    2162:	56 c0       	rjmp	.+172    	; 0x2210 <__stack+0x11>
    2164:	3a c0       	rjmp	.+116    	; 0x21da <gc_execute_line+0x1302>
    case NON_MODAL_SET_COORDINATE_DATA:
      settings_write_coord_data(coord_select,gc_block.values.ijk);
    2166:	66 ea       	ldi	r22, 0xA6	; 166
    2168:	7c e0       	ldi	r23, 0x0C	; 12
    216a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    216c:	0e 94 79 25 	call	0x4af2	; 0x4af2 <settings_write_coord_data>
      // Update system coordinate system if currently active.
      if (gc_state.modal.coord_select == coord_select) {
    2170:	80 91 5c 0c 	lds	r24, 0x0C5C	; 0x800c5c <gc_state+0x6>
    2174:	ff 8d       	ldd	r31, Y+31	; 0x1f
    2176:	8f 13       	cpse	r24, r31
    2178:	4b c0       	rjmp	.+150    	; 0x2210 <__stack+0x11>
        memcpy(gc_state.coord_system,gc_block.values.ijk,N_AXIS*sizeof(float));
    217a:	8c e0       	ldi	r24, 0x0C	; 12
    217c:	e6 ea       	ldi	r30, 0xA6	; 166
    217e:	fc e0       	ldi	r31, 0x0C	; 12
    2180:	aa e7       	ldi	r26, 0x7A	; 122
    2182:	bc e0       	ldi	r27, 0x0C	; 12
    2184:	01 90       	ld	r0, Z+
    2186:	0d 92       	st	X+, r0
    2188:	8a 95       	dec	r24
    218a:	e1 f7       	brne	.-8      	; 0x2184 <gc_execute_line+0x12ac>
        system_flag_wco_change();
    218c:	0e 94 32 3b 	call	0x7664	; 0x7664 <system_flag_wco_change>
    2190:	3f c0       	rjmp	.+126    	; 0x2210 <__stack+0x11>
      }
      break;
    case NON_MODAL_GO_HOME_0: case NON_MODAL_GO_HOME_1:
      // Move to intermediate position before going home. Obeys current coordinate system and offsets
      // and absolute and incremental modes.
      pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
    2192:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2194:	81 60       	ori	r24, 0x01	; 1
    2196:	8e 8f       	std	Y+30, r24	; 0x1e
      if (axis_command) { mc_line(gc_block.values.xyz, pl_data); }
    2198:	2a a1       	ldd	r18, Y+34	; 0x22
    219a:	22 23       	and	r18, r18
    219c:	39 f0       	breq	.+14     	; 0x21ac <gc_execute_line+0x12d4>
    219e:	be 01       	movw	r22, r28
    21a0:	6e 5e       	subi	r22, 0xEE	; 238
    21a2:	7f 4f       	sbci	r23, 0xFF	; 255
    21a4:	84 ec       	ldi	r24, 0xC4	; 196
    21a6:	9c e0       	ldi	r25, 0x0C	; 12
    21a8:	0e 94 67 03 	call	0x6ce	; 0x6ce <mc_line>
      mc_line(gc_block.values.ijk, pl_data);
    21ac:	be 01       	movw	r22, r28
    21ae:	6e 5e       	subi	r22, 0xEE	; 238
    21b0:	7f 4f       	sbci	r23, 0xFF	; 255
    21b2:	86 ea       	ldi	r24, 0xA6	; 166
    21b4:	9c e0       	ldi	r25, 0x0C	; 12
    21b6:	0e 94 67 03 	call	0x6ce	; 0x6ce <mc_line>
      memcpy(gc_state.position, gc_block.values.ijk, N_AXIS*sizeof(float));
    21ba:	8c e0       	ldi	r24, 0x0C	; 12
    21bc:	e6 ea       	ldi	r30, 0xA6	; 166
    21be:	fc e0       	ldi	r31, 0x0C	; 12
    21c0:	ae e6       	ldi	r26, 0x6E	; 110
    21c2:	bc e0       	ldi	r27, 0x0C	; 12
    21c4:	01 90       	ld	r0, Z+
    21c6:	0d 92       	st	X+, r0
    21c8:	8a 95       	dec	r24
    21ca:	e1 f7       	brne	.-8      	; 0x21c4 <gc_execute_line+0x12ec>
      break;
    21cc:	21 c0       	rjmp	.+66     	; 0x2210 <__stack+0x11>
    case NON_MODAL_SET_HOME_0:
      settings_write_coord_data(SETTING_INDEX_G28,gc_state.position);
    21ce:	6e e6       	ldi	r22, 0x6E	; 110
    21d0:	7c e0       	ldi	r23, 0x0C	; 12
    21d2:	86 e0       	ldi	r24, 0x06	; 6
    21d4:	0e 94 79 25 	call	0x4af2	; 0x4af2 <settings_write_coord_data>
      break;
    21d8:	1b c0       	rjmp	.+54     	; 0x2210 <__stack+0x11>
    case NON_MODAL_SET_HOME_1:
      settings_write_coord_data(SETTING_INDEX_G30,gc_state.position);
    21da:	6e e6       	ldi	r22, 0x6E	; 110
    21dc:	7c e0       	ldi	r23, 0x0C	; 12
    21de:	87 e0       	ldi	r24, 0x07	; 7
    21e0:	0e 94 79 25 	call	0x4af2	; 0x4af2 <settings_write_coord_data>
      break;
    21e4:	15 c0       	rjmp	.+42     	; 0x2210 <__stack+0x11>
    case NON_MODAL_SET_COORDINATE_OFFSET:
      memcpy(gc_state.coord_offset,gc_block.values.xyz,sizeof(gc_block.values.xyz));
    21e6:	8c e0       	ldi	r24, 0x0C	; 12
    21e8:	e4 ec       	ldi	r30, 0xC4	; 196
    21ea:	fc e0       	ldi	r31, 0x0C	; 12
    21ec:	a6 e8       	ldi	r26, 0x86	; 134
    21ee:	bc e0       	ldi	r27, 0x0C	; 12
    21f0:	01 90       	ld	r0, Z+
    21f2:	0d 92       	st	X+, r0
    21f4:	8a 95       	dec	r24
    21f6:	e1 f7       	brne	.-8      	; 0x21f0 <gc_execute_line+0x1318>
      system_flag_wco_change();
    21f8:	0e 94 32 3b 	call	0x7664	; 0x7664 <system_flag_wco_change>
      break;
    21fc:	09 c0       	rjmp	.+18     	; 0x2210 <__stack+0x11>
    case NON_MODAL_RESET_COORDINATE_OFFSET:
      clear_vector(gc_state.coord_offset); // Disable G92 offsets by zeroing offset vector.
    21fe:	8c e0       	ldi	r24, 0x0C	; 12
    2200:	e6 e8       	ldi	r30, 0x86	; 134
    2202:	fc e0       	ldi	r31, 0x0C	; 12
    2204:	df 01       	movw	r26, r30
    2206:	1d 92       	st	X+, r1
    2208:	8a 95       	dec	r24
    220a:	e9 f7       	brne	.-6      	; 0x2206 <__stack+0x7>
      system_flag_wco_change();
    220c:	0e 94 32 3b 	call	0x7664	; 0x7664 <system_flag_wco_change>


  // [20. Motion modes ]:
  // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes.
  // Enter motion modes only if there are axis words or a motion mode command word in the block.
  gc_state.modal.motion = gc_block.modal.motion;
    2210:	80 91 97 0c 	lds	r24, 0x0C97	; 0x800c97 <gc_block+0x1>
    2214:	80 93 56 0c 	sts	0x0C56, r24	; 0x800c56 <gc_state>
  if (gc_state.modal.motion != MOTION_MODE_NONE) {
    2218:	80 35       	cpi	r24, 0x50	; 80
    221a:	09 f4       	brne	.+2      	; 0x221e <__stack+0x1f>
    221c:	56 c0       	rjmp	.+172    	; 0x22ca <__stack+0xcb>
    if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    221e:	ba a1       	ldd	r27, Y+34	; 0x22
    2220:	b2 30       	cpi	r27, 0x02	; 2
    2222:	09 f0       	breq	.+2      	; 0x2226 <__stack+0x27>
    2224:	52 c0       	rjmp	.+164    	; 0x22ca <__stack+0xcb>
      uint8_t gc_update_pos = GC_UPDATE_POS_TARGET;
      if (gc_state.modal.motion == MOTION_MODE_LINEAR) {
    2226:	81 30       	cpi	r24, 0x01	; 1
    2228:	41 f4       	brne	.+16     	; 0x223a <__stack+0x3b>
        mc_line(gc_block.values.xyz, pl_data);
    222a:	be 01       	movw	r22, r28
    222c:	6e 5e       	subi	r22, 0xEE	; 238
    222e:	7f 4f       	sbci	r23, 0xFF	; 255
    2230:	84 ec       	ldi	r24, 0xC4	; 196
    2232:	9c e0       	ldi	r25, 0x0C	; 12
    2234:	0e 94 67 03 	call	0x6ce	; 0x6ce <mc_line>
    2238:	3a c0       	rjmp	.+116    	; 0x22ae <__stack+0xaf>
      } else if (gc_state.modal.motion == MOTION_MODE_SEEK) {
    223a:	81 11       	cpse	r24, r1
    223c:	0b c0       	rjmp	.+22     	; 0x2254 <__stack+0x55>
        pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
    223e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2240:	81 60       	ori	r24, 0x01	; 1
    2242:	8e 8f       	std	Y+30, r24	; 0x1e
        mc_line(gc_block.values.xyz, pl_data);
    2244:	be 01       	movw	r22, r28
    2246:	6e 5e       	subi	r22, 0xEE	; 238
    2248:	7f 4f       	sbci	r23, 0xFF	; 255
    224a:	84 ec       	ldi	r24, 0xC4	; 196
    224c:	9c e0       	ldi	r25, 0x0C	; 12
    224e:	0e 94 67 03 	call	0x6ce	; 0x6ce <mc_line>
    2252:	2d c0       	rjmp	.+90     	; 0x22ae <__stack+0xaf>
      } else if ((gc_state.modal.motion == MOTION_MODE_CW_ARC) || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
    2254:	82 50       	subi	r24, 0x02	; 2
    2256:	82 30       	cpi	r24, 0x02	; 2
    2258:	e8 f4       	brcc	.+58     	; 0x2294 <__stack+0x95>
        mc_arc(gc_block.values.xyz, pl_data, gc_state.position, gc_block.values.ijk, gc_block.values.r,
    225a:	e0 90 bb 0c 	lds	r14, 0x0CBB	; 0x800cbb <gc_block+0x25>
    225e:	f0 90 bc 0c 	lds	r15, 0x0CBC	; 0x800cbc <gc_block+0x26>
    2262:	00 91 bd 0c 	lds	r16, 0x0CBD	; 0x800cbd <gc_block+0x27>
    2266:	10 91 be 0c 	lds	r17, 0x0CBE	; 0x800cbe <gc_block+0x28>
    226a:	ec a1       	ldd	r30, Y+36	; 0x24
    226c:	e2 fb       	bst	r30, 2
    226e:	88 27       	eor	r24, r24
    2270:	80 f9       	bld	r24, 0
    2272:	8f 93       	push	r24
    2274:	8f a4       	ldd	r8, Y+47	; 0x2f
    2276:	ae a0       	ldd	r10, Y+38	; 0x26
    2278:	cd a0       	ldd	r12, Y+37	; 0x25
    227a:	26 ea       	ldi	r18, 0xA6	; 166
    227c:	3c e0       	ldi	r19, 0x0C	; 12
    227e:	4e e6       	ldi	r20, 0x6E	; 110
    2280:	5c e0       	ldi	r21, 0x0C	; 12
    2282:	be 01       	movw	r22, r28
    2284:	6e 5e       	subi	r22, 0xEE	; 238
    2286:	7f 4f       	sbci	r23, 0xFF	; 255
    2288:	84 ec       	ldi	r24, 0xC4	; 196
    228a:	9c e0       	ldi	r25, 0x0C	; 12
    228c:	0e 94 a8 03 	call	0x750	; 0x750 <mc_arc>
    2290:	0f 90       	pop	r0
    2292:	0d c0       	rjmp	.+26     	; 0x22ae <__stack+0xaf>
            axis_0, axis_1, axis_linear, bit_istrue(gc_parser_flags,GC_PARSER_ARC_IS_CLOCKWISE));
      } else {
        // NOTE: gc_block.values.xyz is returned from mc_probe_cycle with the updated position value. So
        // upon a successful probing cycle, the machine position and the returned value should be the same.
        #ifndef ALLOW_FEED_OVERRIDE_DURING_PROBE_CYCLES
          pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
    2294:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2296:	84 60       	ori	r24, 0x04	; 4
    2298:	8e 8f       	std	Y+30, r24	; 0x1e
        #endif
        gc_update_pos = mc_probe_cycle(gc_block.values.xyz, pl_data, gc_parser_flags);
    229a:	4c a1       	ldd	r20, Y+36	; 0x24
    229c:	be 01       	movw	r22, r28
    229e:	6e 5e       	subi	r22, 0xEE	; 238
    22a0:	7f 4f       	sbci	r23, 0xFF	; 255
    22a2:	84 ec       	ldi	r24, 0xC4	; 196
    22a4:	9c e0       	ldi	r25, 0x0C	; 12
    22a6:	0e 94 ba 06 	call	0xd74	; 0xd74 <mc_probe_cycle>
      }  
     
      // As far as the parser is concerned, the position is now == target. In reality the
      // motion control system might still be processing the action and the real tool position
      // in any intermediate location.
      if (gc_update_pos == GC_UPDATE_POS_TARGET) {
    22aa:	81 11       	cpse	r24, r1
    22ac:	0a c0       	rjmp	.+20     	; 0x22c2 <__stack+0xc3>
        memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); // gc_state.position[] = gc_block.values.xyz[]
    22ae:	8c e0       	ldi	r24, 0x0C	; 12
    22b0:	e4 ec       	ldi	r30, 0xC4	; 196
    22b2:	fc e0       	ldi	r31, 0x0C	; 12
    22b4:	ae e6       	ldi	r26, 0x6E	; 110
    22b6:	bc e0       	ldi	r27, 0x0C	; 12
    22b8:	01 90       	ld	r0, Z+
    22ba:	0d 92       	st	X+, r0
    22bc:	8a 95       	dec	r24
    22be:	e1 f7       	brne	.-8      	; 0x22b8 <__stack+0xb9>
    22c0:	04 c0       	rjmp	.+8      	; 0x22ca <__stack+0xcb>
      } else if (gc_update_pos == GC_UPDATE_POS_SYSTEM) {
    22c2:	81 30       	cpi	r24, 0x01	; 1
    22c4:	11 f4       	brne	.+4      	; 0x22ca <__stack+0xcb>
        gc_sync_position(); // gc_state.position[] = sys_position
    22c6:	0e 94 65 07 	call	0xeca	; 0xeca <gc_sync_position>
  }

  // [21. Program flow ]:
  // M0,M1,M2,M30: Perform non-running program flow actions. During a program pause, the buffer may
  // refill and can only be resumed by the cycle start run-time command.
  gc_state.modal.program_flow = gc_block.modal.program_flow;
    22ca:	80 91 9e 0c 	lds	r24, 0x0C9E	; 0x800c9e <gc_block+0x8>
    22ce:	80 93 5d 0c 	sts	0x0C5D, r24	; 0x800c5d <gc_state+0x7>
  if (gc_state.modal.program_flow) {
    22d2:	88 23       	and	r24, r24
    22d4:	09 f4       	brne	.+2      	; 0x22d8 <__stack+0xd9>
    protocol_buffer_synchronize(); // Sync and finish all remaining buffered motions before moving on.
    22d6:	ef c0       	rjmp	.+478    	; 0x24b6 <__stack+0x2b7>
    22d8:	c1 d7       	rcall	.+3970   	; 0x325c <protocol_buffer_synchronize>
    if (gc_state.modal.program_flow == PROGRAM_FLOW_PAUSED) {
    22da:	80 91 5d 0c 	lds	r24, 0x0C5D	; 0x800c5d <gc_state+0x7>
    22de:	83 30       	cpi	r24, 0x03	; 3
    22e0:	49 f4       	brne	.+18     	; 0x22f4 <__stack+0xf5>
      if (sys.state != STATE_CHECK_MODE) {
    22e2:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    22e6:	82 30       	cpi	r24, 0x02	; 2
        system_set_exec_state_flag(EXEC_FEED_HOLD); // Use feed hold for program pause.
    22e8:	61 f1       	breq	.+88     	; 0x2342 <__stack+0x143>
    22ea:	88 e0       	ldi	r24, 0x08	; 8
    22ec:	0e 94 d0 3b 	call	0x77a0	; 0x77a0 <system_set_exec_state_flag>
        protocol_execute_realtime(); // Execute suspend.
    22f0:	ed d5       	rcall	.+3034   	; 0x2ecc <protocol_execute_realtime>
    22f2:	27 c0       	rjmp	.+78     	; 0x2342 <__stack+0x143>
    } else { // == PROGRAM_FLOW_COMPLETED
      // Upon program complete, only a subset of g-codes reset to certain defaults, according to
      // LinuxCNC's program end descriptions and testing. Only modal groups [G-code 1,2,3,5,7,12]
      // and [M-code 7,8,9] reset to [G1,G17,G90,G94,G40,G54,M5,M9,M48]. The remaining modal groups
      // [G-code 4,6,8,10,13,14,15] and [M-code 4,5,6] and the modal words [F,S,T,H] do not reset.
      gc_state.modal.motion = MOTION_MODE_LINEAR;
    22f4:	e6 e5       	ldi	r30, 0x56	; 86
    22f6:	fc e0       	ldi	r31, 0x0C	; 12
    22f8:	81 e0       	ldi	r24, 0x01	; 1
    22fa:	80 83       	st	Z, r24
      gc_state.modal.plane_select = PLANE_SELECT_XY;
    22fc:	14 82       	std	Z+4, r1	; 0x04
      gc_state.modal.distance = DISTANCE_MODE_ABSOLUTE;
    22fe:	13 82       	std	Z+3, r1	; 0x03
      gc_state.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
    2300:	11 82       	std	Z+1, r1	; 0x01
      // gc_state.modal.cutter_comp = CUTTER_COMP_DISABLE; // Not supported.
      gc_state.modal.coord_select = 0; // G54
    2302:	16 82       	std	Z+6, r1	; 0x06
      gc_state.modal.spindle = SPINDLE_DISABLE;
    2304:	11 86       	std	Z+9, r1	; 0x09
      gc_state.modal.coolant = COOLANT_DISABLE;
    2306:	10 86       	std	Z+8, r1	; 0x08
          gc_state.modal.override = OVERRIDE_PARKING_MOTION;
        #endif
      #endif

      #ifdef RESTORE_OVERRIDES_AFTER_PROGRAM_END
        sys.f_override = DEFAULT_FEED_OVERRIDE;
    2308:	ee e1       	ldi	r30, 0x1E	; 30
    230a:	fc e0       	ldi	r31, 0x0C	; 12
    230c:	84 e6       	ldi	r24, 0x64	; 100
    230e:	87 83       	std	Z+7, r24	; 0x07
        sys.r_override = DEFAULT_RAPID_OVERRIDE;
    2310:	80 87       	std	Z+8, r24	; 0x08
        sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE;
    2312:	81 87       	std	Z+9, r24	; 0x09
      #endif

      // Execute coordinate change and spindle/coolant stop.
      if (sys.state != STATE_CHECK_MODE) {
    2314:	80 81       	ld	r24, Z
    2316:	82 30       	cpi	r24, 0x02	; 2
    2318:	89 f0       	breq	.+34     	; 0x233c <__stack+0x13d>
        if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    231a:	6a e7       	ldi	r22, 0x7A	; 122
    231c:	7c e0       	ldi	r23, 0x0C	; 12
    231e:	80 e0       	ldi	r24, 0x00	; 0
    2320:	0e 94 1c 26 	call	0x4c38	; 0x4c38 <settings_read_coord_data>
    2324:	88 23       	and	r24, r24
    2326:	09 f4       	brne	.+2      	; 0x232a <__stack+0x12b>
        system_flag_wco_change(); // Set to refresh immediately just in case something altered.
    2328:	7a c0       	rjmp	.+244    	; 0x241e <__stack+0x21f>
        spindle_set_state(SPINDLE_DISABLE,0.0);
    232a:	0e 94 32 3b 	call	0x7664	; 0x7664 <system_flag_wco_change>
    232e:	40 e0       	ldi	r20, 0x00	; 0
    2330:	50 e0       	ldi	r21, 0x00	; 0
    2332:	ba 01       	movw	r22, r20
    2334:	80 e0       	ldi	r24, 0x00	; 0
        coolant_set_state(COOLANT_DISABLE);
    2336:	e1 d1       	rcall	.+962    	; 0x26fa <spindle_set_state>
    2338:	80 e0       	ldi	r24, 0x00	; 0
    233a:	3f d2       	rcall	.+1150   	; 0x27ba <coolant_set_state>
      }
      report_feedback_message(MESSAGE_PROGRAM_END);
    233c:	88 e0       	ldi	r24, 0x08	; 8
    233e:	0e 94 d5 35 	call	0x6baa	; 0x6baa <report_feedback_message>
    }
    gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; // Reset program flow.
    2342:	10 92 5d 0c 	sts	0x0C5D, r1	; 0x800c5d <gc_state+0x7>
  }

  // TODO: % to denote start of program.

  return(STATUS_OK);
    2346:	8d 2d       	mov	r24, r13
    2348:	b6 c0       	rjmp	.+364    	; 0x24b6 <__stack+0x2b7>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.

    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
    234a:	81 e0       	ldi	r24, 0x01	; 1
    234c:	b4 c0       	rjmp	.+360    	; 0x24b6 <__stack+0x2b7>
    char_counter++;
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
    234e:	82 e0       	ldi	r24, 0x02	; 2
    2350:	b2 c0       	rjmp	.+356    	; 0x24b6 <__stack+0x2b7>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
    2352:	84 e1       	ldi	r24, 0x14	; 20
    2354:	b0 c0       	rjmp	.+352    	; 0x24b6 <__stack+0x2b7>
        switch(int_value) {
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    2356:	88 e1       	ldi	r24, 0x18	; 24
    2358:	ae c0       	rjmp	.+348    	; 0x24b6 <__stack+0x2b7>
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
              if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
    235a:	84 e1       	ldi	r24, 0x14	; 20
    235c:	ac c0       	rjmp	.+344    	; 0x24b6 <__stack+0x2b7>
            }                
            break;
          case 0: case 1: case 2: case 3: case 38:
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    235e:	88 e1       	ldi	r24, 0x18	; 24
    2360:	aa c0       	rjmp	.+340    	; 0x24b6 <__stack+0x2b7>
          case 80:
            word_bit = MODAL_GROUP_G1;
            gc_block.modal.motion = int_value;
            if (int_value == 38){
              if (!((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))) {
                FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
    2362:	84 e1       	ldi	r24, 0x14	; 20
    2364:	a8 c0       	rjmp	.+336    	; 0x24b6 <__stack+0x2b7>
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
    2366:	84 e1       	ldi	r24, 0x14	; 20
    2368:	a6 c0       	rjmp	.+332    	; 0x24b6 <__stack+0x2b7>
    236a:	84 e1       	ldi	r24, 0x14	; 20
    236c:	a4 c0       	rjmp	.+328    	; 0x24b6 <__stack+0x2b7>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
    236e:	88 e1       	ldi	r24, 0x18	; 24
    2370:	a2 c0       	rjmp	.+324    	; 0x24b6 <__stack+0x2b7>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
            } else if (mantissa == 10) { // G43.1
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
    2372:	84 e1       	ldi	r24, 0x14	; 20
    2374:	a0 c0       	rjmp	.+320    	; 0x24b6 <__stack+0x2b7>
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
    2376:	84 e1       	ldi	r24, 0x14	; 20
    2378:	9e c0       	rjmp	.+316    	; 0x24b6 <__stack+0x2b7>
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    237a:	87 e1       	ldi	r24, 0x17	; 23
    237c:	9c c0       	rjmp	.+312    	; 0x24b6 <__stack+0x2b7>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    237e:	85 e1       	ldi	r24, 0x15	; 21
    2380:	9a c0       	rjmp	.+308    	; 0x24b6 <__stack+0x2b7>
        break;

      case 'M':

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    2382:	87 e1       	ldi	r24, 0x17	; 23
    2384:	98 c0       	rjmp	.+304    	; 0x24b6 <__stack+0x2b7>
            case 56:
              word_bit = MODAL_GROUP_M9;
              gc_block.modal.override = OVERRIDE_PARKING_MOTION;
              break;
          #endif
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
    2386:	84 e1       	ldi	r24, 0x14	; 20
    2388:	96 c0       	rjmp	.+300    	; 0x24b6 <__stack+0x2b7>
        }

        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    238a:	85 e1       	ldi	r24, 0x15	; 21
    238c:	94 c0       	rjmp	.+296    	; 0x24b6 <__stack+0x2b7>
						gc_block.values.t = int_value;
						break;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
    238e:	84 e1       	ldi	r24, 0x14	; 20
    2390:	92 c0       	rjmp	.+292    	; 0x24b6 <__stack+0x2b7>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; 
						if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
    2392:	86 e2       	ldi	r24, 0x26	; 38
    2394:	90 c0       	rjmp	.+288    	; 0x24b6 <__stack+0x2b7>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        }

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    2396:	89 e1       	ldi	r24, 0x19	; 25
    2398:	8e c0       	rjmp	.+284    	; 0x24b6 <__stack+0x2b7>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    239a:	84 e0       	ldi	r24, 0x04	; 4
    239c:	8c c0       	rjmp	.+280    	; 0x24b6 <__stack+0x2b7>
  }

  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    239e:	8b e1       	ldi	r24, 0x1B	; 27
    23a0:	8a c0       	rjmp	.+276    	; 0x24b6 <__stack+0x2b7>

  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  // NOTE: For jogging, ignore prior feed rate mode. Enforce G94 and check for required F word.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); }
    23a2:	86 e1       	ldi	r24, 0x16	; 22
    23a4:	88 c0       	rjmp	.+272    	; 0x24b6 <__stack+0x2b7>
  } else {
    if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
      // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
      if (axis_command == AXIS_COMMAND_MOTION_MODE) {
        if ((gc_block.modal.motion != MOTION_MODE_NONE) && (gc_block.modal.motion != MOTION_MODE_SEEK)) {
          if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    23a6:	86 e1       	ldi	r24, 0x16	; 22
    23a8:	86 c0       	rjmp	.+268    	; 0x24b6 <__stack+0x2b7>
    }
  #endif

  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    23aa:	8c e1       	ldi	r24, 0x1C	; 28
    23ac:	84 c0       	rjmp	.+264    	; 0x24b6 <__stack+0x2b7>
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    23ae:	85 e2       	ldi	r24, 0x25	; 37
    23b0:	82 c0       	rjmp	.+260    	; 0x24b6 <__stack+0x2b7>
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  float block_coord_system[N_AXIS];
  memcpy(block_coord_system,gc_state.coord_system,sizeof(gc_state.coord_system));
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    23b2:	8d e1       	ldi	r24, 0x1D	; 29
    23b4:	80 c0       	rjmp	.+256    	; 0x24b6 <__stack+0x2b7>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
      if (!(settings_read_coord_data(gc_block.modal.coord_select,block_coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    23b6:	87 e0       	ldi	r24, 0x07	; 7
    23b8:	7e c0       	rjmp	.+252    	; 0x24b6 <__stack+0x2b7>
  switch (gc_block.non_modal_command) {
    case NON_MODAL_SET_COORDINATE_DATA:
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    23ba:	8a e1       	ldi	r24, 0x1A	; 26
    23bc:	7c c0       	rjmp	.+248    	; 0x24b6 <__stack+0x2b7>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    23be:	8c e1       	ldi	r24, 0x1C	; 28
    23c0:	7a c0       	rjmp	.+244    	; 0x24b6 <__stack+0x2b7>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    23c2:	8d e1       	ldi	r24, 0x1D	; 29
    23c4:	78 c0       	rjmp	.+240    	; 0x24b6 <__stack+0x2b7>
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
    23c6:	84 e1       	ldi	r24, 0x14	; 20
    23c8:	76 c0       	rjmp	.+236    	; 0x24b6 <__stack+0x2b7>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    23ca:	84 e1       	ldi	r24, 0x14	; 20
    23cc:	74 c0       	rjmp	.+232    	; 0x24b6 <__stack+0x2b7>
      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    23ce:	87 e0       	ldi	r24, 0x07	; 7
    23d0:	72 c0       	rjmp	.+228    	; 0x24b6 <__stack+0x2b7>
        } // Else, keep current stored value.
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    23d2:	8a e1       	ldi	r24, 0x1A	; 26
    23d4:	70 c0       	rjmp	.+224    	; 0x24b6 <__stack+0x2b7>

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    23d6:	8f e1       	ldi	r24, 0x1F	; 31
    23d8:	6e c0       	rjmp	.+220    	; 0x24b6 <__stack+0x2b7>
        case NON_MODAL_GO_HOME_1: // G30
          // [G28/30 Errors]: Cutter compensation is enabled.
          // Retreive G28/30 go-home position data (in machine coordinates) from EEPROM
          // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    23da:	87 e0       	ldi	r24, 0x07	; 7
    23dc:	6c c0       	rjmp	.+216    	; 0x24b6 <__stack+0x2b7>
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    23de:	87 e0       	ldi	r24, 0x07	; 7
    23e0:	6a c0       	rjmp	.+212    	; 0x24b6 <__stack+0x2b7>
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
            FAIL(STATUS_GCODE_G53_INVALID_MOTION_MODE); // [G53 G0/1 not active]
    23e2:	8e e1       	ldi	r24, 0x1E	; 30
    23e4:	68 c0       	rjmp	.+208    	; 0x24b6 <__stack+0x2b7>

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    23e6:	8f e1       	ldi	r24, 0x1F	; 31
    23e8:	66 c0       	rjmp	.+204    	; 0x24b6 <__stack+0x2b7>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    23ea:	86 e1       	ldi	r24, 0x16	; 22
    23ec:	64 c0       	rjmp	.+200    	; 0x24b6 <__stack+0x2b7>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.

          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    23ee:	8a e1       	ldi	r24, 0x1A	; 26
    23f0:	62 c0       	rjmp	.+196    	; 0x24b6 <__stack+0x2b7>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    23f2:	80 e2       	ldi	r24, 0x20	; 32
    23f4:	60 c0       	rjmp	.+192    	; 0x24b6 <__stack+0x2b7>
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target

          if (value_words & bit(WORD_R)) { // Arc Radius Mode
            bit_false(value_words,bit(WORD_R));
            if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    23f6:	81 e2       	ldi	r24, 0x21	; 33
    23f8:	5e c0       	rjmp	.+188    	; 0x24b6 <__stack+0x2b7>

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    23fa:	82 e2       	ldi	r24, 0x22	; 34
    23fc:	5c c0       	rjmp	.+184    	; 0x24b6 <__stack+0x2b7>
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));

          } else { // Arc Center Format Offset Mode
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    23fe:	83 e2       	ldi	r24, 0x23	; 35
    2400:	5a c0       	rjmp	.+180    	; 0x24b6 <__stack+0x2b7>
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]);

            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
            if (delta_r > 0.005) {
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    2402:	81 e2       	ldi	r24, 0x21	; 33
    2404:	58 c0       	rjmp	.+176    	; 0x24b6 <__stack+0x2b7>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    2406:	81 e2       	ldi	r24, 0x21	; 33
    2408:	56 c0       	rjmp	.+172    	; 0x24b6 <__stack+0x2b7>
              (gc_block.modal.motion == MOTION_MODE_PROBE_AWAY_NO_ERROR)) { gc_parser_flags |= GC_PARSER_PROBE_IS_AWAY; }
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    240a:	8a e1       	ldi	r24, 0x1A	; 26
    240c:	54 c0       	rjmp	.+168    	; 0x24b6 <__stack+0x2b7>
          if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    240e:	81 e2       	ldi	r24, 0x21	; 33
    2410:	52 c0       	rjmp	.+164    	; 0x24b6 <__stack+0x2b7>
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)));
  } else {
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words.
  }
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words.
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    2412:	84 e2       	ldi	r24, 0x24	; 36
    2414:	50 c0       	rjmp	.+160    	; 0x24b6 <__stack+0x2b7>
  // targets are computed correctly. The final parser position after a jog is updated in
  // protocol_execute_realtime() when jogging completes or is canceled.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    // Only distance and unit modal commands and G53 absolute override command are allowed.
    // NOTE: Feed rate word and axis word checks have already been performed in STEP 3.
    if (command_words & ~(bit(MODAL_GROUP_G3) | bit(MODAL_GROUP_G6 | bit(MODAL_GROUP_G0))) ) { FAIL(STATUS_INVALID_JOG_COMMAND) };
    2416:	80 e1       	ldi	r24, 0x10	; 16
    2418:	4e c0       	rjmp	.+156    	; 0x24b6 <__stack+0x2b7>
    if (!(gc_block.non_modal_command == NON_MODAL_ABSOLUTE_OVERRIDE || gc_block.non_modal_command == NON_MODAL_NO_ACTION)) { FAIL(STATUS_INVALID_JOG_COMMAND); }
    241a:	80 e1       	ldi	r24, 0x10	; 16
    241c:	4c c0       	rjmp	.+152    	; 0x24b6 <__stack+0x2b7>
        sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE;
      #endif

      // Execute coordinate change and spindle/coolant stop.
      if (sys.state != STATE_CHECK_MODE) {
        if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    241e:	87 e0       	ldi	r24, 0x07	; 7
    2420:	4a c0       	rjmp	.+148    	; 0x24b6 <__stack+0x2b7>

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    2422:	8f e1       	ldi	r24, 0x1F	; 31
    2424:	48 c0       	rjmp	.+144    	; 0x24b6 <__stack+0x2b7>
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
  else { char_counter = 0; }
    2426:	19 82       	std	Y+1, r1	; 0x01
  uint8_t ijk_words = 0; // IJK tracking

  // Initialize command and value words and parser flags variables.
  uint16_t command_words = 0; // Tracks G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Tracks value words.
  uint8_t gc_parser_flags = GC_PARSER_NONE;
    2428:	1c a2       	std	Y+36, r1	; 0x24
    242a:	0c 94 a6 07 	jmp	0xf4c	; 0xf4c <gc_execute_line+0x74>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
    242e:	a6 e9       	ldi	r26, 0x96	; 150
    2430:	bc e0       	ldi	r27, 0x0C	; 12
    2432:	ac 92       	st	X, r10
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
    2434:	bc e1       	ldi	r27, 0x1C	; 28
    2436:	ab 12       	cpse	r10, r27
    2438:	27 c0       	rjmp	.+78     	; 0x2488 <__stack+0x289>
    243a:	0c 94 21 08 	jmp	0x1042	; 0x1042 <gc_execute_line+0x16a>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
    243e:	e6 e9       	ldi	r30, 0x96	; 150
    2440:	fc e0       	ldi	r31, 0x0C	; 12
    2442:	a0 82       	st	Z, r10
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
    2444:	fc e1       	ldi	r31, 0x1C	; 28
    2446:	af 12       	cpse	r10, r31
    2448:	25 c0       	rjmp	.+74     	; 0x2494 <__stack+0x295>
    244a:	0c 94 26 08 	jmp	0x104c	; 0x104c <gc_execute_line+0x174>
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
    244e:	21 e0       	ldi	r18, 0x01	; 1
    2450:	2f a7       	std	Y+47, r18	; 0x2f
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
    2452:	1e a2       	std	Y+38, r1	; 0x26
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
    2454:	32 e0       	ldi	r19, 0x02	; 2
    2456:	3d a3       	std	Y+37, r19	; 0x25
  }

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    2458:	80 91 99 0c 	lds	r24, 0x0C99	; 0x800c99 <gc_block+0x3>
    245c:	81 30       	cpi	r24, 0x01	; 1
    245e:	09 f0       	breq	.+2      	; 0x2462 <__stack+0x263>
    2460:	a1 c8       	rjmp	.-3774   	; 0x15a4 <gc_execute_line+0x6cc>
    2462:	6c c8       	rjmp	.-3880   	; 0x153c <gc_execute_line+0x664>
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
          }
          if (axis_words) {
    2464:	49 a1       	ldd	r20, Y+33	; 0x21
    2466:	44 23       	and	r20, r20
    2468:	f1 f0       	breq	.+60     	; 0x24a6 <__stack+0x2a7>
    246a:	a6 e5       	ldi	r26, 0x56	; 86
    246c:	bc e0       	ldi	r27, 0x0C	; 12
    246e:	e6 e9       	ldi	r30, 0x96	; 150
    2470:	fc e0       	ldi	r31, 0x0C	; 12
    2472:	80 e0       	ldi	r24, 0x00	; 0
    2474:	90 e0       	ldi	r25, 0x00	; 0
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
    2476:	24 2f       	mov	r18, r20
    2478:	30 e0       	ldi	r19, 0x00	; 0
    247a:	85 ca       	rjmp	.-2806   	; 0x1986 <gc_execute_line+0xaae>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    247c:	10 91 97 0c 	lds	r17, 0x0C97	; 0x800c97 <gc_block+0x1>
    2480:	10 35       	cpi	r17, 0x50	; 80
    2482:	09 f0       	breq	.+2      	; 0x2486 <__stack+0x287>
    2484:	aa ca       	rjmp	.-2732   	; 0x19da <gc_execute_line+0xb02>
    2486:	cd cf       	rjmp	.-102    	; 0x2422 <__stack+0x223>
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
    2488:	8e e1       	ldi	r24, 0x1E	; 30
    248a:	a8 12       	cpse	r10, r24
    248c:	0c 94 1b 08 	jmp	0x1036	; 0x1036 <gc_execute_line+0x15e>
    2490:	0c 94 21 08 	jmp	0x1042	; 0x1042 <gc_execute_line+0x16a>
    2494:	9e e1       	ldi	r25, 0x1E	; 30
    2496:	a9 16       	cp	r10, r25
    2498:	11 f4       	brne	.+4      	; 0x249e <__stack+0x29f>
    249a:	0c 94 29 08 	jmp	0x1052	; 0x1052 <gc_execute_line+0x17a>
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
    249e:	a1 e0       	ldi	r26, 0x01	; 1
    24a0:	aa a3       	std	Y+34, r26	; 0x22
    24a2:	0c 94 1b 08 	jmp	0x1036	; 0x1036 <gc_execute_line+0x15e>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    24a6:	10 91 97 0c 	lds	r17, 0x0C97	; 0x800c97 <gc_block+0x1>
    24aa:	10 35       	cpi	r17, 0x50	; 80
    24ac:	09 f4       	brne	.+2      	; 0x24b0 <__stack+0x2b1>
    24ae:	d8 cc       	rjmp	.-1616   	; 0x1e60 <gc_execute_line+0xf88>
    24b0:	1f 8e       	std	Y+31, r1	; 0x1f
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
            }
          } else {
            axis_command = AXIS_COMMAND_NONE; // Set to none if no intermediate motion.
    24b2:	1a a2       	std	Y+34, r1	; 0x22
    24b4:	92 ca       	rjmp	.-2780   	; 0x19da <gc_execute_line+0xb02>
  }

  // TODO: % to denote start of program.

  return(STATUS_OK);
}
    24b6:	e1 96       	adiw	r28, 0x31	; 49
    24b8:	0f b6       	in	r0, 0x3f	; 63
    24ba:	f8 94       	cli
    24bc:	de bf       	out	0x3e, r29	; 62
    24be:	0f be       	out	0x3f, r0	; 63
    24c0:	cd bf       	out	0x3d, r28	; 61
    24c2:	df 91       	pop	r29
    24c4:	cf 91       	pop	r28
    24c6:	1f 91       	pop	r17
    24c8:	0f 91       	pop	r16
    24ca:	ff 90       	pop	r15
    24cc:	ef 90       	pop	r14
    24ce:	df 90       	pop	r13
    24d0:	cf 90       	pop	r12
    24d2:	bf 90       	pop	r11
    24d4:	af 90       	pop	r10
    24d6:	9f 90       	pop	r9
    24d8:	8f 90       	pop	r8
    24da:	7f 90       	pop	r7
    24dc:	6f 90       	pop	r6
    24de:	5f 90       	pop	r5
    24e0:	4f 90       	pop	r4
    24e2:	3f 90       	pop	r3
    24e4:	2f 90       	pop	r2
    24e6:	08 95       	ret

000024e8 <spindle_get_state>:
uint8_t spindle_get_state()
{
  #ifdef INVERT_SPINDLE_ENABLE_PIN
    if (bit_isfalse(SPINDLE_ENABLE_PORT,(1<<SPINDLE_ENABLE_BIT)) && (SPINDLE_TCCRA_REGISTER & (1<<SPINDLE_COMB_BIT))) {
  #else
    if (bit_istrue(SPINDLE_ENABLE_PORT,(1<<SPINDLE_ENABLE_BIT)) && (SPINDLE_TCCRA_REGISTER & (1<<SPINDLE_COMB_BIT))) {
    24e8:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    24ec:	89 2f       	mov	r24, r25
    24ee:	88 70       	andi	r24, 0x08	; 8
    24f0:	93 ff       	sbrs	r25, 3
    24f2:	0b c0       	rjmp	.+22     	; 0x250a <spindle_get_state+0x22>
    24f4:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
    24f8:	89 2f       	mov	r24, r25
    24fa:	80 72       	andi	r24, 0x20	; 32
    24fc:	95 ff       	sbrs	r25, 5
    24fe:	05 c0       	rjmp	.+10     	; 0x250a <spindle_get_state+0x22>
  #endif
    if (SPINDLE_DIRECTION_PORT & (1<<SPINDLE_DIRECTION_BIT)) { return(SPINDLE_STATE_CCW); }
    2500:	73 99       	sbic	0x0e, 3	; 14
    2502:	02 c0       	rjmp	.+4      	; 0x2508 <spindle_get_state+0x20>
    else { return(SPINDLE_STATE_CW); }
    2504:	81 e0       	ldi	r24, 0x01	; 1
    2506:	08 95       	ret
  #ifdef INVERT_SPINDLE_ENABLE_PIN
    if (bit_isfalse(SPINDLE_ENABLE_PORT,(1<<SPINDLE_ENABLE_BIT)) && (SPINDLE_TCCRA_REGISTER & (1<<SPINDLE_COMB_BIT))) {
  #else
    if (bit_istrue(SPINDLE_ENABLE_PORT,(1<<SPINDLE_ENABLE_BIT)) && (SPINDLE_TCCRA_REGISTER & (1<<SPINDLE_COMB_BIT))) {
  #endif
    if (SPINDLE_DIRECTION_PORT & (1<<SPINDLE_DIRECTION_BIT)) { return(SPINDLE_STATE_CCW); }
    2508:	82 e0       	ldi	r24, 0x02	; 2
    else { return(SPINDLE_STATE_CW); }
  }
	return(SPINDLE_STATE_DISABLE);
}
    250a:	08 95       	ret

0000250c <spindle_stop>:
// Disables the spindle and sets PWM output to zero when PWM variable spindle speed is enabled.
// Called by various main program and ISR routines. Keep routine small, fast, and efficient.
// Called by spindle_init(), spindle_set_speed(), spindle_set_state(), and mc_reset().
void spindle_stop()
{
  SPINDLE_TCCRA_REGISTER &= ~(1<<SPINDLE_COMB_BIT); // Disable PWM. Output voltage is zero.
    250c:	e0 ea       	ldi	r30, 0xA0	; 160
    250e:	f0 e0       	ldi	r31, 0x00	; 0
    2510:	80 81       	ld	r24, Z
    2512:	8f 7d       	andi	r24, 0xDF	; 223
    2514:	80 83       	st	Z, r24
  #ifdef INVERT_SPINDLE_ENABLE_PIN
    SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);  // Set pin to high
  #else
    SPINDLE_ENABLE_PORT &= ~(1<<SPINDLE_ENABLE_BIT); // Set pin to low
    2516:	e2 e0       	ldi	r30, 0x02	; 2
    2518:	f1 e0       	ldi	r31, 0x01	; 1
    251a:	80 81       	ld	r24, Z
    251c:	87 7f       	andi	r24, 0xF7	; 247
    251e:	80 83       	st	Z, r24
    2520:	08 95       	ret

00002522 <spindle_init>:


void spindle_init()
{    
  // Configure variable spindle PWM and enable pin, if required.
  SPINDLE_PWM_DDR |= (1<<SPINDLE_PWM_BIT); // Configure as PWM output pin.
    2522:	e1 e0       	ldi	r30, 0x01	; 1
    2524:	f1 e0       	ldi	r31, 0x01	; 1
    2526:	80 81       	ld	r24, Z
    2528:	80 61       	ori	r24, 0x10	; 16
    252a:	80 83       	st	Z, r24
  SPINDLE_TCCRA_REGISTER = SPINDLE_TCCRA_INIT_MASK; // Configure PWM output compare timer
    252c:	83 e0       	ldi	r24, 0x03	; 3
    252e:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
  SPINDLE_TCCRB_REGISTER = SPINDLE_TCCRB_INIT_MASK;
    2532:	8a e1       	ldi	r24, 0x1A	; 26
    2534:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
  SPINDLE_OCRA_REGISTER = SPINDLE_OCRA_TOP_VALUE; // Set the top value for 16-bit fast PWM mode
    2538:	80 e0       	ldi	r24, 0x00	; 0
    253a:	94 e0       	ldi	r25, 0x04	; 4
    253c:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
    2540:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
  SPINDLE_ENABLE_DDR |= (1<<SPINDLE_ENABLE_BIT); // Configure as output pin.
    2544:	80 81       	ld	r24, Z
    2546:	88 60       	ori	r24, 0x08	; 8
    2548:	80 83       	st	Z, r24
  SPINDLE_DIRECTION_DDR |= (1<<SPINDLE_DIRECTION_BIT); // Configure as output pin.
    254a:	6b 9a       	sbi	0x0d, 3	; 13

  pwm_gradient = SPINDLE_PWM_RANGE/(settings.rpm_max-settings.rpm_min);
    254c:	20 91 11 0f 	lds	r18, 0x0F11	; 0x800f11 <settings+0x41>
    2550:	30 91 12 0f 	lds	r19, 0x0F12	; 0x800f12 <settings+0x42>
    2554:	40 91 13 0f 	lds	r20, 0x0F13	; 0x800f13 <settings+0x43>
    2558:	50 91 14 0f 	lds	r21, 0x0F14	; 0x800f14 <settings+0x44>
    255c:	60 91 0d 0f 	lds	r22, 0x0F0D	; 0x800f0d <settings+0x3d>
    2560:	70 91 0e 0f 	lds	r23, 0x0F0E	; 0x800f0e <settings+0x3e>
    2564:	80 91 0f 0f 	lds	r24, 0x0F0F	; 0x800f0f <settings+0x3f>
    2568:	90 91 10 0f 	lds	r25, 0x0F10	; 0x800f10 <settings+0x40>
    256c:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    2570:	9b 01       	movw	r18, r22
    2572:	ac 01       	movw	r20, r24
    2574:	60 e0       	ldi	r22, 0x00	; 0
    2576:	70 ec       	ldi	r23, 0xC0	; 192
    2578:	8f e7       	ldi	r24, 0x7F	; 127
    257a:	94 e4       	ldi	r25, 0x44	; 68
    257c:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <__divsf3>
    2580:	60 93 00 02 	sts	0x0200, r22	; 0x800200 <_edata>
    2584:	70 93 01 02 	sts	0x0201, r23	; 0x800201 <_edata+0x1>
    2588:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <_edata+0x2>
    258c:	90 93 03 02 	sts	0x0203, r25	; 0x800203 <_edata+0x3>
  spindle_stop();
    2590:	bd cf       	rjmp	.-134    	; 0x250c <spindle_stop>
    2592:	08 95       	ret

00002594 <spindle_set_speed>:

// Sets spindle speed PWM output and enable pin, if configured. Called by spindle_set_state()
// and stepper ISR. Keep routine small and efficient.
void spindle_set_speed(uint16_t pwm_value)
{
  SPINDLE_OCR_REGISTER = pwm_value; // Set PWM output level.
    2594:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
    2598:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
      #else
        SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
      #endif
    }
  #else
    if (pwm_value == SPINDLE_PWM_OFF_VALUE) {
    259c:	89 2b       	or	r24, r25
    259e:	31 f4       	brne	.+12     	; 0x25ac <spindle_set_speed+0x18>
      SPINDLE_TCCRA_REGISTER &= ~(1<<SPINDLE_COMB_BIT); // Disable PWM. Output voltage is zero.
    25a0:	e0 ea       	ldi	r30, 0xA0	; 160
    25a2:	f0 e0       	ldi	r31, 0x00	; 0
    25a4:	80 81       	ld	r24, Z
    25a6:	8f 7d       	andi	r24, 0xDF	; 223
    25a8:	80 83       	st	Z, r24
    25aa:	08 95       	ret
    } else {
      SPINDLE_TCCRA_REGISTER |= (1<<SPINDLE_COMB_BIT); // Ensure PWM output is enabled.
    25ac:	e0 ea       	ldi	r30, 0xA0	; 160
    25ae:	f0 e0       	ldi	r31, 0x00	; 0
    25b0:	80 81       	ld	r24, Z
    25b2:	80 62       	ori	r24, 0x20	; 32
    25b4:	80 83       	st	Z, r24
    25b6:	08 95       	ret

000025b8 <spindle_compute_pwm_value>:

#else 

  // Called by spindle_set_state() and step segment generator. Keep routine small and efficient.
  uint16_t spindle_compute_pwm_value(float rpm) // Mega2560 PWM register is 16-bit.
  {
    25b8:	4f 92       	push	r4
    25ba:	5f 92       	push	r5
    25bc:	6f 92       	push	r6
    25be:	7f 92       	push	r7
    25c0:	8f 92       	push	r8
    25c2:	9f 92       	push	r9
    25c4:	af 92       	push	r10
    25c6:	bf 92       	push	r11
    25c8:	cf 92       	push	r12
    25ca:	df 92       	push	r13
    25cc:	ef 92       	push	r14
    25ce:	ff 92       	push	r15
    25d0:	2b 01       	movw	r4, r22
    25d2:	3c 01       	movw	r6, r24
	uint16_t pwm_value;
	rpm *= (0.010*sys.spindle_speed_ovr); // Scale by spindle speed override value.
	// Calculate PWM register value based on rpm max/min settings and programmed rpm.
	if ((settings.rpm_min >= settings.rpm_max) || (rpm >= settings.rpm_max)) {
    25d4:	80 90 11 0f 	lds	r8, 0x0F11	; 0x800f11 <settings+0x41>
    25d8:	90 90 12 0f 	lds	r9, 0x0F12	; 0x800f12 <settings+0x42>
    25dc:	a0 90 13 0f 	lds	r10, 0x0F13	; 0x800f13 <settings+0x43>
    25e0:	b0 90 14 0f 	lds	r11, 0x0F14	; 0x800f14 <settings+0x44>
    25e4:	c0 90 0d 0f 	lds	r12, 0x0F0D	; 0x800f0d <settings+0x3d>
    25e8:	d0 90 0e 0f 	lds	r13, 0x0F0E	; 0x800f0e <settings+0x3e>
    25ec:	e0 90 0f 0f 	lds	r14, 0x0F0F	; 0x800f0f <settings+0x3f>
    25f0:	f0 90 10 0f 	lds	r15, 0x0F10	; 0x800f10 <settings+0x40>
    25f4:	a7 01       	movw	r20, r14
    25f6:	96 01       	movw	r18, r12
    25f8:	c5 01       	movw	r24, r10
    25fa:	b4 01       	movw	r22, r8
    25fc:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    2600:	88 23       	and	r24, r24
    2602:	cc f4       	brge	.+50     	; 0x2636 <spindle_compute_pwm_value+0x7e>

  // Called by spindle_set_state() and step segment generator. Keep routine small and efficient.
  uint16_t spindle_compute_pwm_value(float rpm) // Mega2560 PWM register is 16-bit.
  {
	uint16_t pwm_value;
	rpm *= (0.010*sys.spindle_speed_ovr); // Scale by spindle speed override value.
    2604:	60 91 27 0c 	lds	r22, 0x0C27	; 0x800c27 <sys+0x9>
    2608:	70 e0       	ldi	r23, 0x00	; 0
    260a:	80 e0       	ldi	r24, 0x00	; 0
    260c:	90 e0       	ldi	r25, 0x00	; 0
    260e:	0e 94 42 40 	call	0x8084	; 0x8084 <__floatsisf>
    2612:	2a e0       	ldi	r18, 0x0A	; 10
    2614:	37 ed       	ldi	r19, 0xD7	; 215
    2616:	43 e2       	ldi	r20, 0x23	; 35
    2618:	5c e3       	ldi	r21, 0x3C	; 60
    261a:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    261e:	a3 01       	movw	r20, r6
    2620:	92 01       	movw	r18, r4
    2622:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    2626:	2b 01       	movw	r4, r22
    2628:	3c 01       	movw	r6, r24
	// Calculate PWM register value based on rpm max/min settings and programmed rpm.
	if ((settings.rpm_min >= settings.rpm_max) || (rpm >= settings.rpm_max)) {
    262a:	a7 01       	movw	r20, r14
    262c:	96 01       	movw	r18, r12
    262e:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    2632:	88 23       	and	r24, r24
    2634:	5c f0       	brlt	.+22     	; 0x264c <spindle_compute_pwm_value+0x94>
	  // No PWM range possible. Set simple on/off spindle control pin state.
	  sys.spindle_speed = settings.rpm_max;
    2636:	c0 92 2c 0c 	sts	0x0C2C, r12	; 0x800c2c <sys+0xe>
    263a:	d0 92 2d 0c 	sts	0x0C2D, r13	; 0x800c2d <sys+0xf>
    263e:	e0 92 2e 0c 	sts	0x0C2E, r14	; 0x800c2e <sys+0x10>
    2642:	f0 92 2f 0c 	sts	0x0C2F, r15	; 0x800c2f <sys+0x11>
	  pwm_value = SPINDLE_PWM_MAX_VALUE;
    2646:	80 e0       	ldi	r24, 0x00	; 0
    2648:	94 e0       	ldi	r25, 0x04	; 4
    264a:	4a c0       	rjmp	.+148    	; 0x26e0 <spindle_compute_pwm_value+0x128>
	} else if (rpm <= settings.rpm_min) {
    264c:	a5 01       	movw	r20, r10
    264e:	94 01       	movw	r18, r8
    2650:	c3 01       	movw	r24, r6
    2652:	b2 01       	movw	r22, r4
    2654:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    2658:	18 16       	cp	r1, r24
    265a:	fc f0       	brlt	.+62     	; 0x269a <spindle_compute_pwm_value+0xe2>
	  if (rpm == 0.0) { // S0 disables spindle
    265c:	20 e0       	ldi	r18, 0x00	; 0
    265e:	30 e0       	ldi	r19, 0x00	; 0
    2660:	a9 01       	movw	r20, r18
    2662:	c3 01       	movw	r24, r6
    2664:	b2 01       	movw	r22, r4
    2666:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    266a:	81 11       	cpse	r24, r1
    266c:	0b c0       	rjmp	.+22     	; 0x2684 <spindle_compute_pwm_value+0xcc>
		sys.spindle_speed = 0.0;
    266e:	10 92 2c 0c 	sts	0x0C2C, r1	; 0x800c2c <sys+0xe>
    2672:	10 92 2d 0c 	sts	0x0C2D, r1	; 0x800c2d <sys+0xf>
    2676:	10 92 2e 0c 	sts	0x0C2E, r1	; 0x800c2e <sys+0x10>
    267a:	10 92 2f 0c 	sts	0x0C2F, r1	; 0x800c2f <sys+0x11>
		pwm_value = SPINDLE_PWM_OFF_VALUE;
    267e:	80 e0       	ldi	r24, 0x00	; 0
    2680:	90 e0       	ldi	r25, 0x00	; 0
    2682:	2e c0       	rjmp	.+92     	; 0x26e0 <spindle_compute_pwm_value+0x128>
	  } else { // Set minimum PWM output
		sys.spindle_speed = settings.rpm_min;
    2684:	80 92 2c 0c 	sts	0x0C2C, r8	; 0x800c2c <sys+0xe>
    2688:	90 92 2d 0c 	sts	0x0C2D, r9	; 0x800c2d <sys+0xf>
    268c:	a0 92 2e 0c 	sts	0x0C2E, r10	; 0x800c2e <sys+0x10>
    2690:	b0 92 2f 0c 	sts	0x0C2F, r11	; 0x800c2f <sys+0x11>
		pwm_value = SPINDLE_PWM_MIN_VALUE;
    2694:	81 e0       	ldi	r24, 0x01	; 1
    2696:	90 e0       	ldi	r25, 0x00	; 0
    2698:	23 c0       	rjmp	.+70     	; 0x26e0 <spindle_compute_pwm_value+0x128>
	  }
	} else { 
	  // Compute intermediate PWM value with linear spindle speed model.
	  // NOTE: A nonlinear model could be installed here, if required, but keep it VERY light-weight.
	  sys.spindle_speed = rpm;
    269a:	40 92 2c 0c 	sts	0x0C2C, r4	; 0x800c2c <sys+0xe>
    269e:	50 92 2d 0c 	sts	0x0C2D, r5	; 0x800c2d <sys+0xf>
    26a2:	60 92 2e 0c 	sts	0x0C2E, r6	; 0x800c2e <sys+0x10>
    26a6:	70 92 2f 0c 	sts	0x0C2F, r7	; 0x800c2f <sys+0x11>
	  pwm_value = floor((rpm-settings.rpm_min)*pwm_gradient) + SPINDLE_PWM_MIN_VALUE;
    26aa:	a5 01       	movw	r20, r10
    26ac:	94 01       	movw	r18, r8
    26ae:	c3 01       	movw	r24, r6
    26b0:	b2 01       	movw	r22, r4
    26b2:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    26b6:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <_edata>
    26ba:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <_edata+0x1>
    26be:	40 91 02 02 	lds	r20, 0x0202	; 0x800202 <_edata+0x2>
    26c2:	50 91 03 02 	lds	r21, 0x0203	; 0x800203 <_edata+0x3>
    26c6:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    26ca:	0e 94 7d 40 	call	0x80fa	; 0x80fa <floor>
    26ce:	20 e0       	ldi	r18, 0x00	; 0
    26d0:	30 e0       	ldi	r19, 0x00	; 0
    26d2:	40 e8       	ldi	r20, 0x80	; 128
    26d4:	5f e3       	ldi	r21, 0x3F	; 63
    26d6:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    26da:	0e 94 14 40 	call	0x8028	; 0x8028 <__fixunssfsi>
    26de:	cb 01       	movw	r24, r22
	}
	return(pwm_value);
  }
    26e0:	ff 90       	pop	r15
    26e2:	ef 90       	pop	r14
    26e4:	df 90       	pop	r13
    26e6:	cf 90       	pop	r12
    26e8:	bf 90       	pop	r11
    26ea:	af 90       	pop	r10
    26ec:	9f 90       	pop	r9
    26ee:	8f 90       	pop	r8
    26f0:	7f 90       	pop	r7
    26f2:	6f 90       	pop	r6
    26f4:	5f 90       	pop	r5
    26f6:	4f 90       	pop	r4
    26f8:	08 95       	ret

000026fa <spindle_set_state>:
// Immediately sets spindle running state with direction and spindle rpm via PWM, if enabled.
// Called by g-code parser spindle_sync(), parking retract and restore, g-code program end,
// sleep, and spindle stop override.
void spindle_set_state(uint8_t state, float rpm)
{
  if (sys.abort) { return; } // Block during abort.
    26fa:	90 91 1f 0c 	lds	r25, 0x0C1F	; 0x800c1f <sys+0x1>
    26fe:	91 11       	cpse	r25, r1
    2700:	25 c0       	rjmp	.+74     	; 0x274c <spindle_set_state+0x52>
  if (state == SPINDLE_DISABLE) { // Halt or set spindle direction and rpm.
    2702:	81 11       	cpse	r24, r1
    2704:	0a c0       	rjmp	.+20     	; 0x271a <spindle_set_state+0x20>
  
    sys.spindle_speed = 0.0;
    2706:	10 92 2c 0c 	sts	0x0C2C, r1	; 0x800c2c <sys+0xe>
    270a:	10 92 2d 0c 	sts	0x0C2D, r1	; 0x800c2d <sys+0xf>
    270e:	10 92 2e 0c 	sts	0x0C2E, r1	; 0x800c2e <sys+0x10>
    2712:	10 92 2f 0c 	sts	0x0C2F, r1	; 0x800c2f <sys+0x11>
    spindle_stop();
    2716:	fa de       	rcall	.-524    	; 0x250c <spindle_stop>
    2718:	17 c0       	rjmp	.+46     	; 0x2748 <spindle_set_state+0x4e>
  
  } else {
  
    if (state == SPINDLE_ENABLE_CW) {
    271a:	80 31       	cpi	r24, 0x10	; 16
    271c:	11 f4       	brne	.+4      	; 0x2722 <spindle_set_state+0x28>
      SPINDLE_DIRECTION_PORT &= ~(1<<SPINDLE_DIRECTION_BIT);
    271e:	73 98       	cbi	0x0e, 3	; 14
    2720:	0a c0       	rjmp	.+20     	; 0x2736 <spindle_set_state+0x3c>
    } else {
      SPINDLE_DIRECTION_PORT |= (1<<SPINDLE_DIRECTION_BIT);
    2722:	73 9a       	sbi	0x0e, 3	; 14
    }

    // NOTE: Assumes all calls to this function is when Grbl is not moving or must remain off.
    if (settings.flags & BITFLAG_LASER_MODE) { 
    2724:	90 91 15 0f 	lds	r25, 0x0F15	; 0x800f15 <settings+0x45>
    2728:	91 ff       	sbrs	r25, 1
    272a:	05 c0       	rjmp	.+10     	; 0x2736 <spindle_set_state+0x3c>
      if (state == SPINDLE_ENABLE_CCW) { rpm = 0.0; } // TODO: May need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE);
    272c:	80 32       	cpi	r24, 0x20	; 32
    272e:	19 f4       	brne	.+6      	; 0x2736 <spindle_set_state+0x3c>
    2730:	40 e0       	ldi	r20, 0x00	; 0
    2732:	50 e0       	ldi	r21, 0x00	; 0
    2734:	ba 01       	movw	r22, r20
    }
    spindle_set_speed(spindle_compute_pwm_value(rpm));
    2736:	cb 01       	movw	r24, r22
    2738:	ba 01       	movw	r22, r20
    273a:	3e df       	rcall	.-388    	; 0x25b8 <spindle_compute_pwm_value>
    273c:	2b df       	rcall	.-426    	; 0x2594 <spindle_set_speed>

    #ifndef SPINDLE_ENABLE_OFF_WITH_ZERO_SPEED
      #ifdef INVERT_SPINDLE_ENABLE_PIN
        SPINDLE_ENABLE_PORT &= ~(1<<SPINDLE_ENABLE_BIT);
      #else
        SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
    273e:	e2 e0       	ldi	r30, 0x02	; 2
    2740:	f1 e0       	ldi	r31, 0x01	; 1
    2742:	80 81       	ld	r24, Z
    2744:	88 60       	ori	r24, 0x08	; 8
    2746:	80 83       	st	Z, r24
      #endif   
    #endif
  
  }
  
  sys.report_ovr_counter = 0; // Set to report change immediately
    2748:	10 92 29 0c 	sts	0x0C29, r1	; 0x800c29 <sys+0xb>
    274c:	08 95       	ret

0000274e <spindle_sync>:


// G-code parser entry-point for setting spindle state. Forces a planner buffer sync and bails 
// if an abort or check-mode is active.
void spindle_sync(uint8_t state, float rpm)
{
    274e:	cf 92       	push	r12
    2750:	df 92       	push	r13
    2752:	ef 92       	push	r14
    2754:	ff 92       	push	r15
    2756:	cf 93       	push	r28
  if (sys.state == STATE_CHECK_MODE) { return; }
    2758:	90 91 1e 0c 	lds	r25, 0x0C1E	; 0x800c1e <sys>
    275c:	92 30       	cpi	r25, 0x02	; 2
    275e:	41 f0       	breq	.+16     	; 0x2770 <spindle_sync+0x22>
    2760:	6a 01       	movw	r12, r20
    2762:	7b 01       	movw	r14, r22
    2764:	c8 2f       	mov	r28, r24
  protocol_buffer_synchronize(); // Empty planner buffer to ensure spindle is set when programmed.
    2766:	7a d5       	rcall	.+2804   	; 0x325c <protocol_buffer_synchronize>
  spindle_set_state(state,rpm);
    2768:	b7 01       	movw	r22, r14
    276a:	a6 01       	movw	r20, r12
    276c:	8c 2f       	mov	r24, r28
    276e:	c5 df       	rcall	.-118    	; 0x26fa <spindle_set_state>
}
    2770:	cf 91       	pop	r28
    2772:	ff 90       	pop	r15
    2774:	ef 90       	pop	r14
    2776:	df 90       	pop	r13
    2778:	cf 90       	pop	r12
    277a:	08 95       	ret

0000277c <coolant_get_state>:
{
  uint8_t cl_state = COOLANT_STATE_DISABLE;
  #ifdef INVERT_COOLANT_FLOOD_PIN
    if (bit_isfalse(COOLANT_FLOOD_PORT,(1 << COOLANT_FLOOD_BIT))) {
  #else
    if (bit_istrue(COOLANT_FLOOD_PORT,(1 << COOLANT_FLOOD_BIT))) {
    277c:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2780:	85 ff       	sbrs	r24, 5
    2782:	02 c0       	rjmp	.+4      	; 0x2788 <coolant_get_state+0xc>
  #endif
    cl_state |= COOLANT_STATE_FLOOD;
    2784:	80 e4       	ldi	r24, 0x40	; 64
    2786:	01 c0       	rjmp	.+2      	; 0x278a <coolant_get_state+0xe>


// Returns current coolant output state. Overrides may alter it from programmed state.
uint8_t coolant_get_state()
{
  uint8_t cl_state = COOLANT_STATE_DISABLE;
    2788:	80 e0       	ldi	r24, 0x00	; 0
    cl_state |= COOLANT_STATE_FLOOD;
  }
  #ifdef INVERT_COOLANT_MIST_PIN
    if (bit_isfalse(COOLANT_MIST_PORT,(1 << COOLANT_MIST_BIT))) {
  #else
    if (bit_istrue(COOLANT_MIST_PORT,(1 << COOLANT_MIST_BIT))) {
    278a:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    278e:	96 fd       	sbrc	r25, 6
  #endif
    cl_state |= COOLANT_STATE_MIST;
    2790:	80 68       	ori	r24, 0x80	; 128
  }
  return(cl_state);
}
    2792:	08 95       	ret

00002794 <coolant_stop>:
void coolant_stop()
{
  #ifdef INVERT_COOLANT_FLOOD_PIN
    COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
  #else
    COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    2794:	e2 e0       	ldi	r30, 0x02	; 2
    2796:	f1 e0       	ldi	r31, 0x01	; 1
    2798:	80 81       	ld	r24, Z
    279a:	8f 7d       	andi	r24, 0xDF	; 223
    279c:	80 83       	st	Z, r24
  #endif
  #ifdef INVERT_COOLANT_MIST_PIN
    COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
  #else
    COOLANT_MIST_PORT &= ~(1 << COOLANT_MIST_BIT);
    279e:	80 81       	ld	r24, Z
    27a0:	8f 7b       	andi	r24, 0xBF	; 191
    27a2:	80 83       	st	Z, r24
    27a4:	08 95       	ret

000027a6 <coolant_init>:
#include "grbl.h"


void coolant_init()
{
  COOLANT_FLOOD_DDR |= (1 << COOLANT_FLOOD_BIT); // Configure as output pin.
    27a6:	e1 e0       	ldi	r30, 0x01	; 1
    27a8:	f1 e0       	ldi	r31, 0x01	; 1
    27aa:	80 81       	ld	r24, Z
    27ac:	80 62       	ori	r24, 0x20	; 32
    27ae:	80 83       	st	Z, r24
  COOLANT_MIST_DDR |= (1 << COOLANT_MIST_BIT); // Configure as output pin.
    27b0:	80 81       	ld	r24, Z
    27b2:	80 64       	ori	r24, 0x40	; 64
    27b4:	80 83       	st	Z, r24
  coolant_stop();
    27b6:	ee cf       	rjmp	.-36     	; 0x2794 <coolant_stop>
    27b8:	08 95       	ret

000027ba <coolant_set_state>:
// if enabled. Also sets a flag to report an update to a coolant state.
// Called by coolant toggle override, parking restore, parking retract, sleep mode, g-code
// parser program end, and g-code parser coolant_sync().
void coolant_set_state(uint8_t mode)
{
  if (sys.abort) { return; } // Block during abort.  
    27ba:	90 91 1f 0c 	lds	r25, 0x0C1F	; 0x800c1f <sys+0x1>
    27be:	91 11       	cpse	r25, r1
    27c0:	1c c0       	rjmp	.+56     	; 0x27fa <coolant_set_state+0x40>
  
  if (mode & COOLANT_FLOOD_ENABLE) {
    27c2:	86 ff       	sbrs	r24, 6
    27c4:	06 c0       	rjmp	.+12     	; 0x27d2 <coolant_set_state+0x18>
    #ifdef INVERT_COOLANT_FLOOD_PIN
      COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    #else
      COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
    27c6:	e2 e0       	ldi	r30, 0x02	; 2
    27c8:	f1 e0       	ldi	r31, 0x01	; 1
    27ca:	90 81       	ld	r25, Z
    27cc:	90 62       	ori	r25, 0x20	; 32
    27ce:	90 83       	st	Z, r25
    27d0:	05 c0       	rjmp	.+10     	; 0x27dc <coolant_set_state+0x22>
    #endif
	} else {
	  #ifdef INVERT_COOLANT_FLOOD_PIN
			COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
		#else
			COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    27d2:	e2 e0       	ldi	r30, 0x02	; 2
    27d4:	f1 e0       	ldi	r31, 0x01	; 1
    27d6:	90 81       	ld	r25, Z
    27d8:	9f 7d       	andi	r25, 0xDF	; 223
    27da:	90 83       	st	Z, r25
		#endif
	}
  
	if (mode & COOLANT_MIST_ENABLE) {
    27dc:	88 23       	and	r24, r24
    27de:	34 f4       	brge	.+12     	; 0x27ec <coolant_set_state+0x32>
		#ifdef INVERT_COOLANT_MIST_PIN
			COOLANT_MIST_PORT &= ~(1 << COOLANT_MIST_BIT);
		#else
			COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
    27e0:	e2 e0       	ldi	r30, 0x02	; 2
    27e2:	f1 e0       	ldi	r31, 0x01	; 1
    27e4:	80 81       	ld	r24, Z
    27e6:	80 64       	ori	r24, 0x40	; 64
    27e8:	80 83       	st	Z, r24
    27ea:	05 c0       	rjmp	.+10     	; 0x27f6 <coolant_set_state+0x3c>
		#endif
	} else {
		#ifdef INVERT_COOLANT_MIST_PIN
			COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
		#else
			COOLANT_MIST_PORT &= ~(1 << COOLANT_MIST_BIT);
    27ec:	e2 e0       	ldi	r30, 0x02	; 2
    27ee:	f1 e0       	ldi	r31, 0x01	; 1
    27f0:	80 81       	ld	r24, Z
    27f2:	8f 7b       	andi	r24, 0xBF	; 191
    27f4:	80 83       	st	Z, r24
		#endif
	}
	
  sys.report_ovr_counter = 0; // Set to report change immediately
    27f6:	10 92 29 0c 	sts	0x0C29, r1	; 0x800c29 <sys+0xb>
    27fa:	08 95       	ret

000027fc <coolant_sync>:


// G-code parser entry-point for setting coolant state. Forces a planner buffer sync and bails 
// if an abort or check-mode is active.
void coolant_sync(uint8_t mode)
{
    27fc:	cf 93       	push	r28
  if (sys.state == STATE_CHECK_MODE) { return; }
    27fe:	90 91 1e 0c 	lds	r25, 0x0C1E	; 0x800c1e <sys>
    2802:	92 30       	cpi	r25, 0x02	; 2
    2804:	21 f0       	breq	.+8      	; 0x280e <coolant_sync+0x12>
    2806:	c8 2f       	mov	r28, r24
  protocol_buffer_synchronize(); // Ensure coolant turns on when specified in program.
    2808:	29 d5       	rcall	.+2642   	; 0x325c <protocol_buffer_synchronize>
  coolant_set_state(mode);
    280a:	8c 2f       	mov	r24, r28
    280c:	d6 df       	rcall	.-84     	; 0x27ba <coolant_set_state>
}
    280e:	cf 91       	pop	r28
    2810:	08 95       	ret

00002812 <serial_get_rx_buffer_available>:
uint8_t serial_get_tx_buffer_count()
{
  uint8_t ttail = serial_tx_buffer_tail; // Copy to limit multiple calls to volatile
  if (serial_tx_buffer_head >= ttail) { return(serial_tx_buffer_head-ttail); }
  return (TX_RING_BUFFER - (ttail-serial_tx_buffer_head));
}
    2812:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <serial_rx_buffer_tail>
    2816:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <serial_rx_buffer_head>
    281a:	98 17       	cp	r25, r24
    281c:	20 f0       	brcs	.+8      	; 0x2826 <serial_get_rx_buffer_available+0x14>
    281e:	98 1b       	sub	r25, r24
    2820:	89 2f       	mov	r24, r25
    2822:	80 95       	com	r24
    2824:	08 95       	ret
    2826:	81 50       	subi	r24, 0x01	; 1
    2828:	89 1b       	sub	r24, r25
    282a:	08 95       	ret

0000282c <serial_init>:
  #if BAUD_RATE < 57600
    uint16_t UBRR0_value = ((F_CPU / (8L * BAUD_RATE)) - 1)/2 ;
    UCSR0A &= ~(1 << U2X0); // baud doubler off  - Only needed on Uno XXX
  #else
    uint16_t UBRR0_value = ((F_CPU / (4L * BAUD_RATE)) - 1)/2;
    UCSR0A |= (1 << U2X0);  // baud doubler on for high baud rates, i.e. 115200
    282c:	e0 ec       	ldi	r30, 0xC0	; 192
    282e:	f0 e0       	ldi	r31, 0x00	; 0
    2830:	80 81       	ld	r24, Z
    2832:	82 60       	ori	r24, 0x02	; 2
    2834:	80 83       	st	Z, r24
  #endif
  UBRR0H = UBRR0_value >> 8;
    2836:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
  UBRR0L = UBRR0_value;
    283a:	80 e1       	ldi	r24, 0x10	; 16
    283c:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>

  // enable rx, tx, and interrupt on complete reception of a byte
  UCSR0B |= (1<<RXEN0 | 1<<TXEN0 | 1<<RXCIE0);
    2840:	e1 ec       	ldi	r30, 0xC1	; 193
    2842:	f0 e0       	ldi	r31, 0x00	; 0
    2844:	80 81       	ld	r24, Z
    2846:	88 69       	ori	r24, 0x98	; 152
    2848:	80 83       	st	Z, r24
    284a:	08 95       	ret

0000284c <serial_write>:


// Writes one byte to the TX serial buffer. Called by main program.
void serial_write(uint8_t data) {
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
    284c:	e0 91 05 02 	lds	r30, 0x0205	; 0x800205 <serial_tx_buffer_head>
    2850:	21 e0       	ldi	r18, 0x01	; 1
    2852:	2e 0f       	add	r18, r30
  if (next_head == TX_RING_BUFFER) { next_head = 0; }

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) {
    2854:	04 c0       	rjmp	.+8      	; 0x285e <serial_write+0x12>
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.
    if (sys_rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
    2856:	90 91 31 0c 	lds	r25, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    285a:	94 fd       	sbrc	r25, 4
    285c:	0f c0       	rjmp	.+30     	; 0x287c <serial_write+0x30>
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
  if (next_head == TX_RING_BUFFER) { next_head = 0; }

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) {
    285e:	90 91 04 02 	lds	r25, 0x0204	; 0x800204 <serial_tx_buffer_tail>
    2862:	29 17       	cp	r18, r25
    2864:	c1 f3       	breq	.-16     	; 0x2856 <serial_write+0xa>
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.
    if (sys_rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
  }

  // Store data and advance head
  serial_tx_buffer[serial_tx_buffer_head] = data;
    2866:	f0 e0       	ldi	r31, 0x00	; 0
    2868:	e0 53       	subi	r30, 0x30	; 48
    286a:	f3 4f       	sbci	r31, 0xF3	; 243
    286c:	80 83       	st	Z, r24
  serial_tx_buffer_head = next_head;
    286e:	20 93 05 02 	sts	0x0205, r18	; 0x800205 <serial_tx_buffer_head>

  // Enable Data Register Empty Interrupt to make sure tx-streaming is running
  UCSR0B |=  (1 << UDRIE0);
    2872:	e1 ec       	ldi	r30, 0xC1	; 193
    2874:	f0 e0       	ldi	r31, 0x00	; 0
    2876:	80 81       	ld	r24, Z
    2878:	80 62       	ori	r24, 0x20	; 32
    287a:	80 83       	st	Z, r24
    287c:	08 95       	ret

0000287e <__vector_26>:
}


// Data Register Empty Interrupt handler
ISR(SERIAL_UDRE)
{
    287e:	1f 92       	push	r1
    2880:	0f 92       	push	r0
    2882:	0f b6       	in	r0, 0x3f	; 63
    2884:	0f 92       	push	r0
    2886:	11 24       	eor	r1, r1
    2888:	0b b6       	in	r0, 0x3b	; 59
    288a:	0f 92       	push	r0
    288c:	8f 93       	push	r24
    288e:	9f 93       	push	r25
    2890:	ef 93       	push	r30
    2892:	ff 93       	push	r31
  uint8_t tail = serial_tx_buffer_tail; // Temporary serial_tx_buffer_tail (to optimize for volatile)
    2894:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <serial_tx_buffer_tail>

  // Send a byte from the buffer
  UDR0 = serial_tx_buffer[tail];
    2898:	e8 2f       	mov	r30, r24
    289a:	f0 e0       	ldi	r31, 0x00	; 0
    289c:	e0 53       	subi	r30, 0x30	; 48
    289e:	f3 4f       	sbci	r31, 0xF3	; 243
    28a0:	90 81       	ld	r25, Z
    28a2:	90 93 c6 00 	sts	0x00C6, r25	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>

  // Update tail position
  tail++;
    28a6:	8f 5f       	subi	r24, 0xFF	; 255
  if (tail == TX_RING_BUFFER) { tail = 0; }

  serial_tx_buffer_tail = tail;
    28a8:	80 93 04 02 	sts	0x0204, r24	; 0x800204 <serial_tx_buffer_tail>

  // Turn off Data Register Empty Interrupt to stop tx-streaming if this concludes the transfer
  if (tail == serial_tx_buffer_head) { UCSR0B &= ~(1 << UDRIE0); }
    28ac:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <serial_tx_buffer_head>
    28b0:	89 13       	cpse	r24, r25
    28b2:	05 c0       	rjmp	.+10     	; 0x28be <__vector_26+0x40>
    28b4:	e1 ec       	ldi	r30, 0xC1	; 193
    28b6:	f0 e0       	ldi	r31, 0x00	; 0
    28b8:	80 81       	ld	r24, Z
    28ba:	8f 7d       	andi	r24, 0xDF	; 223
    28bc:	80 83       	st	Z, r24
}
    28be:	ff 91       	pop	r31
    28c0:	ef 91       	pop	r30
    28c2:	9f 91       	pop	r25
    28c4:	8f 91       	pop	r24
    28c6:	0f 90       	pop	r0
    28c8:	0b be       	out	0x3b, r0	; 59
    28ca:	0f 90       	pop	r0
    28cc:	0f be       	out	0x3f, r0	; 63
    28ce:	0f 90       	pop	r0
    28d0:	1f 90       	pop	r1
    28d2:	18 95       	reti

000028d4 <serial_read>:


// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
    28d4:	90 91 06 02 	lds	r25, 0x0206	; 0x800206 <serial_rx_buffer_tail>
  if (serial_rx_buffer_head == tail) {
    28d8:	80 91 07 02 	lds	r24, 0x0207	; 0x800207 <serial_rx_buffer_head>
    28dc:	98 17       	cp	r25, r24
    28de:	49 f0       	breq	.+18     	; 0x28f2 <serial_read+0x1e>
    return SERIAL_NO_DATA;
  } else {
    uint8_t data = serial_rx_buffer[tail];
    28e0:	e9 2f       	mov	r30, r25
    28e2:	f0 e0       	ldi	r31, 0x00	; 0
    28e4:	e0 53       	subi	r30, 0x30	; 48
    28e6:	f2 4f       	sbci	r31, 0xF2	; 242
    28e8:	80 81       	ld	r24, Z

    tail++;
    28ea:	9f 5f       	subi	r25, 0xFF	; 255
    if (tail == RX_RING_BUFFER) { tail = 0; }
    serial_rx_buffer_tail = tail;
    28ec:	90 93 06 02 	sts	0x0206, r25	; 0x800206 <serial_rx_buffer_tail>

    return data;
    28f0:	08 95       	ret
// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
  if (serial_rx_buffer_head == tail) {
    return SERIAL_NO_DATA;
    28f2:	8f ef       	ldi	r24, 0xFF	; 255
    if (tail == RX_RING_BUFFER) { tail = 0; }
    serial_rx_buffer_tail = tail;

    return data;
  }
}
    28f4:	08 95       	ret

000028f6 <__vector_25>:


ISR(SERIAL_RX)
{
    28f6:	1f 92       	push	r1
    28f8:	0f 92       	push	r0
    28fa:	0f b6       	in	r0, 0x3f	; 63
    28fc:	0f 92       	push	r0
    28fe:	11 24       	eor	r1, r1
    2900:	0b b6       	in	r0, 0x3b	; 59
    2902:	0f 92       	push	r0
    2904:	2f 93       	push	r18
    2906:	3f 93       	push	r19
    2908:	4f 93       	push	r20
    290a:	5f 93       	push	r21
    290c:	6f 93       	push	r22
    290e:	7f 93       	push	r23
    2910:	8f 93       	push	r24
    2912:	9f 93       	push	r25
    2914:	af 93       	push	r26
    2916:	bf 93       	push	r27
    2918:	ef 93       	push	r30
    291a:	ff 93       	push	r31
  uint8_t data = UDR0;
    291c:	e0 91 c6 00 	lds	r30, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
  uint8_t next_head;

  // Pick off realtime command characters directly from the serial stream. These characters are
  // not passed into the main buffer, but these set system state flag bits for realtime execution.
  switch (data) {
    2920:	e1 32       	cpi	r30, 0x21	; 33
    2922:	a1 f0       	breq	.+40     	; 0x294c <__vector_25+0x56>
    2924:	18 f4       	brcc	.+6      	; 0x292c <__vector_25+0x36>
    2926:	e8 31       	cpi	r30, 0x18	; 24
    2928:	31 f0       	breq	.+12     	; 0x2936 <__vector_25+0x40>
    292a:	14 c0       	rjmp	.+40     	; 0x2954 <__vector_25+0x5e>
    292c:	ef 33       	cpi	r30, 0x3F	; 63
    292e:	31 f0       	breq	.+12     	; 0x293c <__vector_25+0x46>
    2930:	ee 37       	cpi	r30, 0x7E	; 126
    2932:	41 f0       	breq	.+16     	; 0x2944 <__vector_25+0x4e>
    2934:	0f c0       	rjmp	.+30     	; 0x2954 <__vector_25+0x5e>
    case CMD_RESET:         mc_reset(); break; // Call motion control reset routine.
    2936:	0e 94 2f 07 	call	0xe5e	; 0xe5e <mc_reset>
    293a:	81 c0       	rjmp	.+258    	; 0x2a3e <__vector_25+0x148>
    case CMD_STATUS_REPORT: system_set_exec_state_flag(EXEC_STATUS_REPORT); break; // Set as true
    293c:	81 e0       	ldi	r24, 0x01	; 1
    293e:	0e 94 d0 3b 	call	0x77a0	; 0x77a0 <system_set_exec_state_flag>
    2942:	7d c0       	rjmp	.+250    	; 0x2a3e <__vector_25+0x148>
    case CMD_CYCLE_START:   system_set_exec_state_flag(EXEC_CYCLE_START); break; // Set as true
    2944:	82 e0       	ldi	r24, 0x02	; 2
    2946:	0e 94 d0 3b 	call	0x77a0	; 0x77a0 <system_set_exec_state_flag>
    294a:	79 c0       	rjmp	.+242    	; 0x2a3e <__vector_25+0x148>
    case CMD_FEED_HOLD:     system_set_exec_state_flag(EXEC_FEED_HOLD); break; // Set as true
    294c:	88 e0       	ldi	r24, 0x08	; 8
    294e:	0e 94 d0 3b 	call	0x77a0	; 0x77a0 <system_set_exec_state_flag>
    2952:	75 c0       	rjmp	.+234    	; 0x2a3e <__vector_25+0x148>
    default :
      if (data > 0x7F) { // Real-time control characters are extended ACSII only.
    2954:	ee 23       	and	r30, r30
    2956:	0c f0       	brlt	.+2      	; 0x295a <__vector_25+0x64>
    2958:	64 c0       	rjmp	.+200    	; 0x2a22 <__vector_25+0x12c>
        switch(data) {
    295a:	8e 2f       	mov	r24, r30
    295c:	90 e0       	ldi	r25, 0x00	; 0
    295e:	fc 01       	movw	r30, r24
    2960:	e4 58       	subi	r30, 0x84	; 132
    2962:	f1 09       	sbc	r31, r1
    2964:	ee 31       	cpi	r30, 0x1E	; 30
    2966:	f1 05       	cpc	r31, r1
    2968:	08 f0       	brcs	.+2      	; 0x296c <__vector_25+0x76>
    296a:	69 c0       	rjmp	.+210    	; 0x2a3e <__vector_25+0x148>
    296c:	88 27       	eor	r24, r24
    296e:	eb 5f       	subi	r30, 0xFB	; 251
    2970:	fe 4f       	sbci	r31, 0xFE	; 254
    2972:	8f 4f       	sbci	r24, 0xFF	; 255
    2974:	0c 94 ed 42 	jmp	0x85da	; 0x85da <__tablejump2__>
          case CMD_SAFETY_DOOR:   system_set_exec_state_flag(EXEC_SAFETY_DOOR); break; // Set as true
    2978:	80 e2       	ldi	r24, 0x20	; 32
    297a:	0e 94 d0 3b 	call	0x77a0	; 0x77a0 <system_set_exec_state_flag>
    297e:	5f c0       	rjmp	.+190    	; 0x2a3e <__vector_25+0x148>
          case CMD_JOG_CANCEL:   
            if (sys.state & STATE_JOG) { // Block all other states from invoking motion cancel.
    2980:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2984:	85 ff       	sbrs	r24, 5
    2986:	5b c0       	rjmp	.+182    	; 0x2a3e <__vector_25+0x148>
              system_set_exec_state_flag(EXEC_MOTION_CANCEL); 
    2988:	80 e4       	ldi	r24, 0x40	; 64
    298a:	0e 94 d0 3b 	call	0x77a0	; 0x77a0 <system_set_exec_state_flag>
    298e:	57 c0       	rjmp	.+174    	; 0x2a3e <__vector_25+0x148>
            }
            break; 
          #ifdef DEBUG
            case CMD_DEBUG_REPORT: {uint8_t sreg = SREG; cli(); bit_true(sys_rt_exec_debug,EXEC_DEBUG_REPORT); SREG = sreg;} break;
    2990:	9f b7       	in	r25, 0x3f	; 63
    2992:	f8 94       	cli
    2994:	80 91 54 0c 	lds	r24, 0x0C54	; 0x800c54 <sys_rt_exec_debug>
    2998:	81 60       	ori	r24, 0x01	; 1
    299a:	80 93 54 0c 	sts	0x0C54, r24	; 0x800c54 <sys_rt_exec_debug>
    299e:	9f bf       	out	0x3f, r25	; 63
    29a0:	4e c0       	rjmp	.+156    	; 0x2a3e <__vector_25+0x148>
          #endif
          case CMD_FEED_OVR_RESET: system_set_exec_motion_override_flag(EXEC_FEED_OVR_RESET); break;
    29a2:	81 e0       	ldi	r24, 0x01	; 1
    29a4:	0e 94 44 3e 	call	0x7c88	; 0x7c88 <system_set_exec_motion_override_flag>
    29a8:	4a c0       	rjmp	.+148    	; 0x2a3e <__vector_25+0x148>
          case CMD_FEED_OVR_COARSE_PLUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_COARSE_PLUS); break;
    29aa:	82 e0       	ldi	r24, 0x02	; 2
    29ac:	0e 94 44 3e 	call	0x7c88	; 0x7c88 <system_set_exec_motion_override_flag>
    29b0:	46 c0       	rjmp	.+140    	; 0x2a3e <__vector_25+0x148>
          case CMD_FEED_OVR_COARSE_MINUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_COARSE_MINUS); break;
    29b2:	84 e0       	ldi	r24, 0x04	; 4
    29b4:	0e 94 44 3e 	call	0x7c88	; 0x7c88 <system_set_exec_motion_override_flag>
    29b8:	42 c0       	rjmp	.+132    	; 0x2a3e <__vector_25+0x148>
          case CMD_FEED_OVR_FINE_PLUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_FINE_PLUS); break;
    29ba:	88 e0       	ldi	r24, 0x08	; 8
    29bc:	0e 94 44 3e 	call	0x7c88	; 0x7c88 <system_set_exec_motion_override_flag>
    29c0:	3e c0       	rjmp	.+124    	; 0x2a3e <__vector_25+0x148>
          case CMD_FEED_OVR_FINE_MINUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_FINE_MINUS); break;
    29c2:	80 e1       	ldi	r24, 0x10	; 16
    29c4:	0e 94 44 3e 	call	0x7c88	; 0x7c88 <system_set_exec_motion_override_flag>
    29c8:	3a c0       	rjmp	.+116    	; 0x2a3e <__vector_25+0x148>
          case CMD_RAPID_OVR_RESET: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_RESET); break;
    29ca:	80 e2       	ldi	r24, 0x20	; 32
    29cc:	0e 94 44 3e 	call	0x7c88	; 0x7c88 <system_set_exec_motion_override_flag>
    29d0:	36 c0       	rjmp	.+108    	; 0x2a3e <__vector_25+0x148>
          case CMD_RAPID_OVR_MEDIUM: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_MEDIUM); break;
    29d2:	80 e4       	ldi	r24, 0x40	; 64
    29d4:	0e 94 44 3e 	call	0x7c88	; 0x7c88 <system_set_exec_motion_override_flag>
    29d8:	32 c0       	rjmp	.+100    	; 0x2a3e <__vector_25+0x148>
          case CMD_RAPID_OVR_LOW: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_LOW); break;
    29da:	80 e8       	ldi	r24, 0x80	; 128
    29dc:	0e 94 44 3e 	call	0x7c88	; 0x7c88 <system_set_exec_motion_override_flag>
    29e0:	2e c0       	rjmp	.+92     	; 0x2a3e <__vector_25+0x148>
          case CMD_SPINDLE_OVR_RESET: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_RESET); break;
    29e2:	81 e0       	ldi	r24, 0x01	; 1
    29e4:	0e 94 4d 3e 	call	0x7c9a	; 0x7c9a <system_set_exec_accessory_override_flag>
    29e8:	2a c0       	rjmp	.+84     	; 0x2a3e <__vector_25+0x148>
          case CMD_SPINDLE_OVR_COARSE_PLUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_COARSE_PLUS); break;
    29ea:	82 e0       	ldi	r24, 0x02	; 2
    29ec:	0e 94 4d 3e 	call	0x7c9a	; 0x7c9a <system_set_exec_accessory_override_flag>
    29f0:	26 c0       	rjmp	.+76     	; 0x2a3e <__vector_25+0x148>
          case CMD_SPINDLE_OVR_COARSE_MINUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_COARSE_MINUS); break;
    29f2:	84 e0       	ldi	r24, 0x04	; 4
    29f4:	0e 94 4d 3e 	call	0x7c9a	; 0x7c9a <system_set_exec_accessory_override_flag>
    29f8:	22 c0       	rjmp	.+68     	; 0x2a3e <__vector_25+0x148>
          case CMD_SPINDLE_OVR_FINE_PLUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_FINE_PLUS); break;
    29fa:	88 e0       	ldi	r24, 0x08	; 8
    29fc:	0e 94 4d 3e 	call	0x7c9a	; 0x7c9a <system_set_exec_accessory_override_flag>
    2a00:	1e c0       	rjmp	.+60     	; 0x2a3e <__vector_25+0x148>
          case CMD_SPINDLE_OVR_FINE_MINUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_FINE_MINUS); break;
    2a02:	80 e1       	ldi	r24, 0x10	; 16
    2a04:	0e 94 4d 3e 	call	0x7c9a	; 0x7c9a <system_set_exec_accessory_override_flag>
    2a08:	1a c0       	rjmp	.+52     	; 0x2a3e <__vector_25+0x148>
          case CMD_SPINDLE_OVR_STOP: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP); break;
    2a0a:	80 e2       	ldi	r24, 0x20	; 32
    2a0c:	0e 94 4d 3e 	call	0x7c9a	; 0x7c9a <system_set_exec_accessory_override_flag>
    2a10:	16 c0       	rjmp	.+44     	; 0x2a3e <__vector_25+0x148>
          case CMD_COOLANT_FLOOD_OVR_TOGGLE: system_set_exec_accessory_override_flag(EXEC_COOLANT_FLOOD_OVR_TOGGLE); break;
    2a12:	80 e4       	ldi	r24, 0x40	; 64
    2a14:	0e 94 4d 3e 	call	0x7c9a	; 0x7c9a <system_set_exec_accessory_override_flag>
    2a18:	12 c0       	rjmp	.+36     	; 0x2a3e <__vector_25+0x148>
          case CMD_COOLANT_MIST_OVR_TOGGLE: system_set_exec_accessory_override_flag(EXEC_COOLANT_MIST_OVR_TOGGLE); break;
    2a1a:	80 e8       	ldi	r24, 0x80	; 128
    2a1c:	0e 94 4d 3e 	call	0x7c9a	; 0x7c9a <system_set_exec_accessory_override_flag>
    2a20:	0e c0       	rjmp	.+28     	; 0x2a3e <__vector_25+0x148>
        }
        // Throw away any unfound extended-ASCII character by not passing it to the serial buffer.
      } else { // Write character to buffer
        next_head = serial_rx_buffer_head + 1;
    2a22:	a0 91 07 02 	lds	r26, 0x0207	; 0x800207 <serial_rx_buffer_head>
    2a26:	81 e0       	ldi	r24, 0x01	; 1
    2a28:	8a 0f       	add	r24, r26
        if (next_head == RX_RING_BUFFER) { next_head = 0; }

        // Write data to buffer unless it is full.
        if (next_head != serial_rx_buffer_tail) {
    2a2a:	90 91 06 02 	lds	r25, 0x0206	; 0x800206 <serial_rx_buffer_tail>
    2a2e:	89 17       	cp	r24, r25
    2a30:	31 f0       	breq	.+12     	; 0x2a3e <__vector_25+0x148>
          serial_rx_buffer[serial_rx_buffer_head] = data;
    2a32:	b0 e0       	ldi	r27, 0x00	; 0
    2a34:	a0 53       	subi	r26, 0x30	; 48
    2a36:	b2 4f       	sbci	r27, 0xF2	; 242
    2a38:	ec 93       	st	X, r30
          serial_rx_buffer_head = next_head;
    2a3a:	80 93 07 02 	sts	0x0207, r24	; 0x800207 <serial_rx_buffer_head>
        }
      }
  }
}
    2a3e:	ff 91       	pop	r31
    2a40:	ef 91       	pop	r30
    2a42:	bf 91       	pop	r27
    2a44:	af 91       	pop	r26
    2a46:	9f 91       	pop	r25
    2a48:	8f 91       	pop	r24
    2a4a:	7f 91       	pop	r23
    2a4c:	6f 91       	pop	r22
    2a4e:	5f 91       	pop	r21
    2a50:	4f 91       	pop	r20
    2a52:	3f 91       	pop	r19
    2a54:	2f 91       	pop	r18
    2a56:	0f 90       	pop	r0
    2a58:	0b be       	out	0x3b, r0	; 59
    2a5a:	0f 90       	pop	r0
    2a5c:	0f be       	out	0x3f, r0	; 63
    2a5e:	0f 90       	pop	r0
    2a60:	1f 90       	pop	r1
    2a62:	18 95       	reti

00002a64 <serial_reset_read_buffer>:


void serial_reset_read_buffer()
{
  serial_rx_buffer_tail = serial_rx_buffer_head;
    2a64:	80 91 07 02 	lds	r24, 0x0207	; 0x800207 <serial_rx_buffer_head>
    2a68:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <serial_rx_buffer_tail>
    2a6c:	08 95       	ret

00002a6e <protocol_auto_cycle_start>:
// when one of these conditions exist respectively: There are no more blocks sent (i.e. streaming
// is finished, single commands), a command that needs to wait for the motions in the buffer to
// execute calls a buffer sync, or the planner buffer is full and ready to go.
void protocol_auto_cycle_start()
{
  if (plan_get_current_block() != NULL) { // Check if there are any blocks in the buffer.
    2a6e:	0e 94 87 29 	call	0x530e	; 0x530e <plan_get_current_block>
    2a72:	89 2b       	or	r24, r25
    2a74:	19 f0       	breq	.+6      	; 0x2a7c <protocol_auto_cycle_start+0xe>
    system_set_exec_state_flag(EXEC_CYCLE_START); // If so, execute them!
    2a76:	82 e0       	ldi	r24, 0x02	; 2
    2a78:	0c 94 d0 3b 	jmp	0x77a0	; 0x77a0 <system_set_exec_state_flag>
    2a7c:	08 95       	ret

00002a7e <protocol_exec_rt_system>:

// Executes run-time commands, when required. This function primarily operates as Grbl's state
// machine and controls the various real-time features Grbl has to offer.
// NOTE: Do not alter this unless you know exactly what you are doing!
void protocol_exec_rt_system()
{
    2a7e:	cf 93       	push	r28
    2a80:	df 93       	push	r29
  uint8_t rt_exec; // Temp variable to avoid calling volatile multiple times.
  rt_exec = sys_rt_exec_alarm; // Copy volatile sys_rt_exec_alarm.
    2a82:	c0 91 53 0c 	lds	r28, 0x0C53	; 0x800c53 <sys_rt_exec_alarm>
  if (rt_exec) { // Enter only if any bit flag is true
    2a86:	cc 23       	and	r28, r28
    2a88:	a9 f0       	breq	.+42     	; 0x2ab4 <protocol_exec_rt_system+0x36>
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
    2a8a:	81 e0       	ldi	r24, 0x01	; 1
    2a8c:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
    report_alarm_message(rt_exec);
    2a90:	8c 2f       	mov	r24, r28
    2a92:	0e 94 70 35 	call	0x6ae0	; 0x6ae0 <report_alarm_message>
    // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
    if ((rt_exec == EXEC_ALARM_HARD_LIMIT) || (rt_exec == EXEC_ALARM_SOFT_LIMIT)) {
    2a96:	c1 50       	subi	r28, 0x01	; 1
    2a98:	c2 30       	cpi	r28, 0x02	; 2
    2a9a:	50 f4       	brcc	.+20     	; 0x2ab0 <protocol_exec_rt_system+0x32>
      report_feedback_message(MESSAGE_CRITICAL_EVENT);
    2a9c:	81 e0       	ldi	r24, 0x01	; 1
    2a9e:	0e 94 d5 35 	call	0x6baa	; 0x6baa <report_feedback_message>
      system_clear_exec_state_flag(EXEC_RESET); // Disable any existing reset
    2aa2:	80 e1       	ldi	r24, 0x10	; 16
    2aa4:	0e 94 2e 3e 	call	0x7c5c	; 0x7c5c <system_clear_exec_state_flag>
        // Block everything, except reset and status reports, until user issues reset or power
        // cycles. Hard limits typically occur while unattended or not paying attention. Gives
        // the user and a GUI time to do what is needed before resetting, like killing the
        // incoming stream. The same could be said about soft limits. While the position is not
        // lost, continued streaming could cause a serious crash if by chance it gets executed.
      } while (bit_isfalse(sys_rt_exec_state,EXEC_RESET));
    2aa8:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    2aac:	84 ff       	sbrs	r24, 4
    2aae:	fc cf       	rjmp	.-8      	; 0x2aa8 <protocol_exec_rt_system+0x2a>
    }
    system_clear_exec_alarm(); // Clear alarm
    2ab0:	0e 94 3e 3e 	call	0x7c7c	; 0x7c7c <system_clear_exec_alarm>
  }

  rt_exec = sys_rt_exec_state; // Copy volatile sys_rt_exec_state.
    2ab4:	c0 91 31 0c 	lds	r28, 0x0C31	; 0x800c31 <sys_rt_exec_state>
  if (rt_exec) {
    2ab8:	cc 23       	and	r28, r28
    2aba:	09 f4       	brne	.+2      	; 0x2abe <protocol_exec_rt_system+0x40>
    2abc:	f4 c0       	rjmp	.+488    	; 0x2ca6 <protocol_exec_rt_system+0x228>

    // Execute system abort.
    if (rt_exec & EXEC_RESET) {
    2abe:	c4 ff       	sbrs	r28, 4
    2ac0:	04 c0       	rjmp	.+8      	; 0x2aca <protocol_exec_rt_system+0x4c>
      sys.abort = true;  // Only place this is set true.
    2ac2:	81 e0       	ldi	r24, 0x01	; 1
    2ac4:	80 93 1f 0c 	sts	0x0C1F, r24	; 0x800c1f <sys+0x1>
      return; // Nothing else to do but exit.
    2ac8:	fe c1       	rjmp	.+1020   	; 0x2ec6 <protocol_exec_rt_system+0x448>
    }

    // Execute and serial print status
    if (rt_exec & EXEC_STATUS_REPORT) {
    2aca:	c0 ff       	sbrs	r28, 0
    2acc:	05 c0       	rjmp	.+10     	; 0x2ad8 <protocol_exec_rt_system+0x5a>
      report_realtime_status();
    2ace:	0e 94 92 38 	call	0x7124	; 0x7124 <report_realtime_status>
      system_clear_exec_state_flag(EXEC_STATUS_REPORT);
    2ad2:	81 e0       	ldi	r24, 0x01	; 1
    2ad4:	0e 94 2e 3e 	call	0x7c5c	; 0x7c5c <system_clear_exec_state_flag>
    }

    // NOTE: Once hold is initiated, the system immediately enters a suspend state to block all
    // main program processes until either reset or resumed. This ensures a hold completes safely.
    if (rt_exec & (EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR | EXEC_SLEEP)) {
    2ad8:	8c 2f       	mov	r24, r28
    2ada:	88 7e       	andi	r24, 0xE8	; 232
    2adc:	09 f4       	brne	.+2      	; 0x2ae0 <protocol_exec_rt_system+0x62>
    2ade:	63 c0       	rjmp	.+198    	; 0x2ba6 <protocol_exec_rt_system+0x128>

      // State check for allowable states for hold methods.
      if (!(sys.state & (STATE_ALARM | STATE_CHECK_MODE))) {
    2ae0:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2ae4:	98 2f       	mov	r25, r24
    2ae6:	93 70       	andi	r25, 0x03	; 3
    2ae8:	09 f0       	breq	.+2      	; 0x2aec <protocol_exec_rt_system+0x6e>
    2aea:	4c c0       	rjmp	.+152    	; 0x2b84 <protocol_exec_rt_system+0x106>
      
        // If in CYCLE or JOG states, immediately initiate a motion HOLD.
        if (sys.state & (STATE_CYCLE | STATE_JOG)) {
    2aec:	88 72       	andi	r24, 0x28	; 40
    2aee:	91 f0       	breq	.+36     	; 0x2b14 <protocol_exec_rt_system+0x96>
          if (!(sys.suspend & (SUSPEND_MOTION_CANCEL | SUSPEND_JOG_CANCEL))) { // Block, if already holding.
    2af0:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2af4:	80 7c       	andi	r24, 0xC0	; 192
    2af6:	71 f4       	brne	.+28     	; 0x2b14 <protocol_exec_rt_system+0x96>
            st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
    2af8:	b1 d6       	rcall	.+3426   	; 0x385c <st_update_plan_block_parameters>
            sys.step_control = STEP_CONTROL_EXECUTE_HOLD; // Initiate suspend state with active flag.
    2afa:	ee e1       	ldi	r30, 0x1E	; 30
    2afc:	fc e0       	ldi	r31, 0x0C	; 12
    2afe:	82 e0       	ldi	r24, 0x02	; 2
    2b00:	84 83       	std	Z+4, r24	; 0x04
            if (sys.state == STATE_JOG) { // Jog cancelled upon any hold event, except for sleeping.
    2b02:	80 81       	ld	r24, Z
    2b04:	80 32       	cpi	r24, 0x20	; 32
    2b06:	31 f4       	brne	.+12     	; 0x2b14 <protocol_exec_rt_system+0x96>
              if (!(rt_exec & EXEC_SLEEP)) { sys.suspend |= SUSPEND_JOG_CANCEL; } 
    2b08:	cc 23       	and	r28, r28
    2b0a:	bc f0       	brlt	.+46     	; 0x2b3a <protocol_exec_rt_system+0xbc>
    2b0c:	92 81       	ldd	r25, Z+2	; 0x02
    2b0e:	90 68       	ori	r25, 0x80	; 128
    2b10:	92 83       	std	Z+2, r25	; 0x02
    2b12:	13 c0       	rjmp	.+38     	; 0x2b3a <protocol_exec_rt_system+0xbc>
            }
          }
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend state and hold is complete.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_HOLD_COMPLETE; }
    2b14:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2b18:	81 11       	cpse	r24, r1
    2b1a:	06 c0       	rjmp	.+12     	; 0x2b28 <protocol_exec_rt_system+0xaa>
    2b1c:	91 e0       	ldi	r25, 0x01	; 1
    2b1e:	90 93 20 0c 	sts	0x0C20, r25	; 0x800c20 <sys+0x2>

        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
    2b22:	c6 fd       	sbrc	r28, 6
    2b24:	05 c0       	rjmp	.+10     	; 0x2b30 <protocol_exec_rt_system+0xb2>
    2b26:	cc c1       	rjmp	.+920    	; 0x2ec0 <protocol_exec_rt_system+0x442>
    2b28:	c6 ff       	sbrs	r28, 6
    2b2a:	07 c0       	rjmp	.+14     	; 0x2b3a <protocol_exec_rt_system+0xbc>
          // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiated beforehand
          // to hold the CYCLE. Motion cancel is valid for a single planner block motion only, while jog cancel
          // will handle and clear multiple planner block motions.
          if (!(sys.state & STATE_JOG)) { sys.suspend |= SUSPEND_MOTION_CANCEL; } // NOTE: State is STATE_CYCLE.
    2b2c:	85 fd       	sbrc	r24, 5
    2b2e:	05 c0       	rjmp	.+10     	; 0x2b3a <protocol_exec_rt_system+0xbc>
    2b30:	ee e1       	ldi	r30, 0x1E	; 30
    2b32:	fc e0       	ldi	r31, 0x0C	; 12
    2b34:	92 81       	ldd	r25, Z+2	; 0x02
    2b36:	90 64       	ori	r25, 0x40	; 64
    2b38:	92 83       	std	Z+2, r25	; 0x02
        }

        // Execute a feed hold with deceleration, if required. Then, suspend system.
        if (rt_exec & EXEC_FEED_HOLD) {
    2b3a:	c3 ff       	sbrs	r28, 3
    2b3c:	05 c0       	rjmp	.+10     	; 0x2b48 <protocol_exec_rt_system+0xca>
          // Block SAFETY_DOOR, JOG, and SLEEP states from changing to HOLD state.
          if (!(sys.state & (STATE_SAFETY_DOOR | STATE_JOG | STATE_SLEEP))) { sys.state = STATE_HOLD; }
    2b3e:	80 7e       	andi	r24, 0xE0	; 224
    2b40:	19 f4       	brne	.+6      	; 0x2b48 <protocol_exec_rt_system+0xca>
    2b42:	80 e1       	ldi	r24, 0x10	; 16
    2b44:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
        }

        // Execute a safety door stop with a feed hold and disable spindle/coolant.
        // NOTE: Safety door differs from feed holds by stopping everything no matter state, disables powered
        // devices (spindle/coolant), and blocks resuming until switch is re-engaged.
        if (rt_exec & EXEC_SAFETY_DOOR) {
    2b48:	c5 ff       	sbrs	r28, 5
    2b4a:	1c c0       	rjmp	.+56     	; 0x2b84 <protocol_exec_rt_system+0x106>
          report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR);
    2b4c:	86 e0       	ldi	r24, 0x06	; 6
    2b4e:	0e 94 d5 35 	call	0x6baa	; 0x6baa <report_feedback_message>
          // If jogging, block safety door methods until jog cancel is complete. Just flag that it happened.
          if (!(sys.suspend & SUSPEND_JOG_CANCEL)) {
    2b52:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2b56:	88 23       	and	r24, r24
    2b58:	84 f0       	brlt	.+32     	; 0x2b7a <protocol_exec_rt_system+0xfc>
            // Check if the safety re-opened during a restore parking motion only. Ignore if
            // already retracting, parked or in sleep state.
            if (sys.state == STATE_SAFETY_DOOR) {
    2b5a:	90 91 1e 0c 	lds	r25, 0x0C1E	; 0x800c1e <sys>
    2b5e:	90 34       	cpi	r25, 0x40	; 64
    2b60:	39 f4       	brne	.+14     	; 0x2b70 <protocol_exec_rt_system+0xf2>
              if (sys.suspend & SUSPEND_INITIATE_RESTORE) { // Actively restoring
    2b62:	83 ff       	sbrs	r24, 3
    2b64:	07 c0       	rjmp	.+14     	; 0x2b74 <protocol_exec_rt_system+0xf6>
                    sys.step_control = (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION);
                    sys.suspend &= ~(SUSPEND_HOLD_COMPLETE);
                  } // else NO_MOTION is active.
                #endif
                sys.suspend &= ~(SUSPEND_RETRACT_COMPLETE | SUSPEND_INITIATE_RESTORE | SUSPEND_RESTORE_COMPLETE);
                sys.suspend |= SUSPEND_RESTART_RETRACT;
    2b66:	83 7e       	andi	r24, 0xE3	; 227
    2b68:	82 60       	ori	r24, 0x02	; 2
    2b6a:	80 93 20 0c 	sts	0x0C20, r24	; 0x800c20 <sys+0x2>
    2b6e:	02 c0       	rjmp	.+4      	; 0x2b74 <protocol_exec_rt_system+0xf6>
              }
            }
            if (sys.state != STATE_SLEEP) { sys.state = STATE_SAFETY_DOOR; }
    2b70:	90 38       	cpi	r25, 0x80	; 128
    2b72:	19 f0       	breq	.+6      	; 0x2b7a <protocol_exec_rt_system+0xfc>
    2b74:	80 e4       	ldi	r24, 0x40	; 64
    2b76:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
          }
          // NOTE: This flag doesn't change when the door closes, unlike sys.state. Ensures any parking motions
          // are executed if the door switch closes and the state returns to HOLD.
          sys.suspend |= SUSPEND_SAFETY_DOOR_AJAR;
    2b7a:	ee e1       	ldi	r30, 0x1E	; 30
    2b7c:	fc e0       	ldi	r31, 0x0C	; 12
    2b7e:	82 81       	ldd	r24, Z+2	; 0x02
    2b80:	80 62       	ori	r24, 0x20	; 32
    2b82:	82 83       	std	Z+2, r24	; 0x02
        }
        
      }

      if (rt_exec & EXEC_SLEEP) {
    2b84:	cc 23       	and	r28, r28
    2b86:	64 f4       	brge	.+24     	; 0x2ba0 <protocol_exec_rt_system+0x122>
        if (sys.state == STATE_ALARM) { sys.suspend |= (SUSPEND_RETRACT_COMPLETE|SUSPEND_HOLD_COMPLETE); }
    2b88:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2b8c:	81 30       	cpi	r24, 0x01	; 1
    2b8e:	29 f4       	brne	.+10     	; 0x2b9a <protocol_exec_rt_system+0x11c>
    2b90:	ee e1       	ldi	r30, 0x1E	; 30
    2b92:	fc e0       	ldi	r31, 0x0C	; 12
    2b94:	82 81       	ldd	r24, Z+2	; 0x02
    2b96:	85 60       	ori	r24, 0x05	; 5
    2b98:	82 83       	std	Z+2, r24	; 0x02
        sys.state = STATE_SLEEP; 
    2b9a:	80 e8       	ldi	r24, 0x80	; 128
    2b9c:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
      }

      system_clear_exec_state_flag((EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR | EXEC_SLEEP));
    2ba0:	88 ee       	ldi	r24, 0xE8	; 232
    2ba2:	0e 94 2e 3e 	call	0x7c5c	; 0x7c5c <system_clear_exec_state_flag>
    }

    // Execute a cycle start by starting the stepper interrupt to begin executing the blocks in queue.
    if (rt_exec & EXEC_CYCLE_START) {
    2ba6:	c1 ff       	sbrs	r28, 1
    2ba8:	41 c0       	rjmp	.+130    	; 0x2c2c <protocol_exec_rt_system+0x1ae>
      // Block if called at same time as the hold commands: feed hold, motion cancel, and safety door.
      // Ensures auto-cycle-start doesn't resume a hold without an explicit user-input.
      if (!(rt_exec & (EXEC_FEED_HOLD | EXEC_MOTION_CANCEL | EXEC_SAFETY_DOOR))) {
    2baa:	8c 2f       	mov	r24, r28
    2bac:	88 76       	andi	r24, 0x68	; 104
    2bae:	d9 f5       	brne	.+118    	; 0x2c26 <protocol_exec_rt_system+0x1a8>
        // Resume door state when parking motion has retracted and door has been closed.
        if ((sys.state == STATE_SAFETY_DOOR) && !(sys.suspend & SUSPEND_SAFETY_DOOR_AJAR)) {
    2bb0:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2bb4:	80 34       	cpi	r24, 0x40	; 64
    2bb6:	79 f4       	brne	.+30     	; 0x2bd6 <protocol_exec_rt_system+0x158>
    2bb8:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2bbc:	85 fd       	sbrc	r24, 5
    2bbe:	33 c0       	rjmp	.+102    	; 0x2c26 <protocol_exec_rt_system+0x1a8>
          if (sys.suspend & SUSPEND_RESTORE_COMPLETE) {
    2bc0:	84 ff       	sbrs	r24, 4
    2bc2:	03 c0       	rjmp	.+6      	; 0x2bca <protocol_exec_rt_system+0x14c>
            sys.state = STATE_IDLE; // Set to IDLE to immediately resume the cycle.
    2bc4:	10 92 1e 0c 	sts	0x0C1E, r1	; 0x800c1e <sys>
    2bc8:	18 c0       	rjmp	.+48     	; 0x2bfa <protocol_exec_rt_system+0x17c>
          } else if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
    2bca:	82 ff       	sbrs	r24, 2
    2bcc:	2c c0       	rjmp	.+88     	; 0x2c26 <protocol_exec_rt_system+0x1a8>
            // Flag to re-energize powered components and restore original position, if disabled by SAFETY_DOOR.
            // NOTE: For a safety door to resume, the switch must be closed, as indicated by HOLD state, and
            // the retraction execution is complete, which implies the initial feed hold is not active. To
            // restore normal operation, the restore procedures must be initiated by the following flag. Once,
            // they are complete, it will call CYCLE_START automatically to resume and exit the suspend.
            sys.suspend |= SUSPEND_INITIATE_RESTORE;
    2bce:	88 60       	ori	r24, 0x08	; 8
    2bd0:	80 93 20 0c 	sts	0x0C20, r24	; 0x800c20 <sys+0x2>
    2bd4:	28 c0       	rjmp	.+80     	; 0x2c26 <protocol_exec_rt_system+0x1a8>
          }
        }
        // Cycle start only when IDLE or when a hold is complete and ready to resume.
        if ((sys.state == STATE_IDLE) || ((sys.state & STATE_HOLD) && (sys.suspend & SUSPEND_HOLD_COMPLETE))) {
    2bd6:	88 23       	and	r24, r24
    2bd8:	81 f0       	breq	.+32     	; 0x2bfa <protocol_exec_rt_system+0x17c>
    2bda:	84 ff       	sbrs	r24, 4
    2bdc:	24 c0       	rjmp	.+72     	; 0x2c26 <protocol_exec_rt_system+0x1a8>
    2bde:	90 91 20 0c 	lds	r25, 0x0C20	; 0x800c20 <sys+0x2>
    2be2:	90 ff       	sbrs	r25, 0
    2be4:	20 c0       	rjmp	.+64     	; 0x2c26 <protocol_exec_rt_system+0x1a8>
          if (sys.state == STATE_HOLD && sys.spindle_stop_ovr) {
    2be6:	80 31       	cpi	r24, 0x10	; 16
    2be8:	41 f4       	brne	.+16     	; 0x2bfa <protocol_exec_rt_system+0x17c>
    2bea:	80 91 28 0c 	lds	r24, 0x0C28	; 0x800c28 <sys+0xa>
    2bee:	88 23       	and	r24, r24
    2bf0:	21 f0       	breq	.+8      	; 0x2bfa <protocol_exec_rt_system+0x17c>
            sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE_CYCLE; // Set to restore in suspend routine and cycle start after.
    2bf2:	88 60       	ori	r24, 0x08	; 8
    2bf4:	80 93 28 0c 	sts	0x0C28, r24	; 0x800c28 <sys+0xa>
    2bf8:	16 c0       	rjmp	.+44     	; 0x2c26 <protocol_exec_rt_system+0x1a8>
          } else {
            // Start cycle only if queued motions exist in planner buffer and the motion is not canceled.
            sys.step_control = STEP_CONTROL_NORMAL_OP; // Restore step control to normal operation
    2bfa:	10 92 22 0c 	sts	0x0C22, r1	; 0x800c22 <sys+0x4>
            if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
    2bfe:	0e 94 87 29 	call	0x530e	; 0x530e <plan_get_current_block>
    2c02:	89 2b       	or	r24, r25
    2c04:	61 f0       	breq	.+24     	; 0x2c1e <protocol_exec_rt_system+0x1a0>
    2c06:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2c0a:	86 fd       	sbrc	r24, 6
    2c0c:	08 c0       	rjmp	.+16     	; 0x2c1e <protocol_exec_rt_system+0x1a0>
              sys.suspend = SUSPEND_DISABLE; // Break suspend state.
    2c0e:	ee e1       	ldi	r30, 0x1E	; 30
    2c10:	fc e0       	ldi	r31, 0x0C	; 12
    2c12:	12 82       	std	Z+2, r1	; 0x02
              sys.state = STATE_CYCLE;
    2c14:	88 e0       	ldi	r24, 0x08	; 8
              st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
    2c16:	80 83       	st	Z, r24
              st_wake_up();
    2c18:	41 d6       	rcall	.+3202   	; 0x389c <st_prep_buffer>
    2c1a:	33 d3       	rcall	.+1638   	; 0x3282 <st_wake_up>
    2c1c:	04 c0       	rjmp	.+8      	; 0x2c26 <protocol_exec_rt_system+0x1a8>
            } else { // Otherwise, do nothing. Set and resume IDLE state.
              sys.suspend = SUSPEND_DISABLE; // Break suspend state.
    2c1e:	ee e1       	ldi	r30, 0x1E	; 30
    2c20:	fc e0       	ldi	r31, 0x0C	; 12
    2c22:	12 82       	std	Z+2, r1	; 0x02
              sys.state = STATE_IDLE;
    2c24:	10 82       	st	Z, r1
            }
          }
        }
      }
      system_clear_exec_state_flag(EXEC_CYCLE_START);
    2c26:	82 e0       	ldi	r24, 0x02	; 2
    2c28:	0e 94 2e 3e 	call	0x7c5c	; 0x7c5c <system_clear_exec_state_flag>
    }

    if (rt_exec & EXEC_CYCLE_STOP) {
    2c2c:	c2 ff       	sbrs	r28, 2
    2c2e:	3b c0       	rjmp	.+118    	; 0x2ca6 <protocol_exec_rt_system+0x228>
      // Reinitializes the cycle plan and stepper system after a feed hold for a resume. Called by
      // realtime command execution in the main program, ensuring that the planner re-plans safely.
      // NOTE: Bresenham algorithm variables are still maintained through both the planner and stepper
      // cycle reinitializations. The stepper path should continue exactly as if nothing has happened.
      // NOTE: EXEC_CYCLE_STOP is set by the stepper subsystem when a cycle or feed hold completes.
      if ((sys.state & (STATE_HOLD|STATE_SAFETY_DOOR|STATE_SLEEP)) && !(sys.soft_limit) && !(sys.suspend & SUSPEND_JOG_CANCEL)) {
    2c30:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2c34:	80 7d       	andi	r24, 0xD0	; 208
    2c36:	b9 f0       	breq	.+46     	; 0x2c66 <protocol_exec_rt_system+0x1e8>
    2c38:	80 91 21 0c 	lds	r24, 0x0C21	; 0x800c21 <sys+0x3>
    2c3c:	81 11       	cpse	r24, r1
    2c3e:	13 c0       	rjmp	.+38     	; 0x2c66 <protocol_exec_rt_system+0x1e8>
    2c40:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2c44:	88 23       	and	r24, r24
    2c46:	9c f0       	brlt	.+38     	; 0x2c6e <protocol_exec_rt_system+0x1f0>
        // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until user
        // has issued a resume command or reset.
        plan_cycle_reinitialize();
    2c48:	0e 94 27 2e 	call	0x5c4e	; 0x5c4e <plan_cycle_reinitialize>
        if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { sys.suspend |= SUSPEND_HOLD_COMPLETE; }
    2c4c:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    2c50:	81 ff       	sbrs	r24, 1
    2c52:	05 c0       	rjmp	.+10     	; 0x2c5e <protocol_exec_rt_system+0x1e0>
    2c54:	ee e1       	ldi	r30, 0x1E	; 30
    2c56:	fc e0       	ldi	r31, 0x0C	; 12
    2c58:	92 81       	ldd	r25, Z+2	; 0x02
    2c5a:	91 60       	ori	r25, 0x01	; 1
    2c5c:	92 83       	std	Z+2, r25	; 0x02
        bit_false(sys.step_control,(STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION));
    2c5e:	89 7f       	andi	r24, 0xF9	; 249
    2c60:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <sys+0x4>
    2c64:	1d c0       	rjmp	.+58     	; 0x2ca0 <protocol_exec_rt_system+0x222>
      } else {
        // Motion complete. Includes CYCLE/JOG/HOMING states and jog cancel/motion cancel/soft limit events.
        // NOTE: Motion and jog cancel both immediately return to idle after the hold completes.
        if (sys.suspend & SUSPEND_JOG_CANCEL) {   // For jog cancel, flush buffers and sync positions.
    2c66:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2c6a:	88 23       	and	r24, r24
    2c6c:	4c f4       	brge	.+18     	; 0x2c80 <protocol_exec_rt_system+0x202>
          sys.step_control = STEP_CONTROL_NORMAL_OP;
    2c6e:	10 92 22 0c 	sts	0x0C22, r1	; 0x800c22 <sys+0x4>
          plan_reset();
    2c72:	0e 94 61 29 	call	0x52c2	; 0x52c2 <plan_reset>
          st_reset();
    2c76:	9f d5       	rcall	.+2878   	; 0x37b6 <st_reset>
          gc_sync_position();
    2c78:	0e 94 65 07 	call	0xeca	; 0xeca <gc_sync_position>
          plan_sync_position();
    2c7c:	0e 94 09 2e 	call	0x5c12	; 0x5c12 <plan_sync_position>
        }
        if (sys.suspend & SUSPEND_SAFETY_DOOR_AJAR) { // Only occurs when safety door opens during jog.
    2c80:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2c84:	85 ff       	sbrs	r24, 5
    2c86:	08 c0       	rjmp	.+16     	; 0x2c98 <protocol_exec_rt_system+0x21a>
          sys.suspend &= ~(SUSPEND_JOG_CANCEL);
          sys.suspend |= SUSPEND_HOLD_COMPLETE;
    2c88:	ee e1       	ldi	r30, 0x1E	; 30
    2c8a:	fc e0       	ldi	r31, 0x0C	; 12
    2c8c:	8f 77       	andi	r24, 0x7F	; 127
    2c8e:	81 60       	ori	r24, 0x01	; 1
    2c90:	82 83       	std	Z+2, r24	; 0x02
          sys.state = STATE_SAFETY_DOOR;
    2c92:	80 e4       	ldi	r24, 0x40	; 64
    2c94:	80 83       	st	Z, r24
    2c96:	04 c0       	rjmp	.+8      	; 0x2ca0 <protocol_exec_rt_system+0x222>
        } else {
          sys.suspend = SUSPEND_DISABLE;
    2c98:	ee e1       	ldi	r30, 0x1E	; 30
    2c9a:	fc e0       	ldi	r31, 0x0C	; 12
    2c9c:	12 82       	std	Z+2, r1	; 0x02
          sys.state = STATE_IDLE;
    2c9e:	10 82       	st	Z, r1
        }
      }
      system_clear_exec_state_flag(EXEC_CYCLE_STOP);
    2ca0:	84 e0       	ldi	r24, 0x04	; 4
    2ca2:	0e 94 2e 3e 	call	0x7c5c	; 0x7c5c <system_clear_exec_state_flag>
    }
  }

  // Execute overrides.
  rt_exec = sys_rt_exec_motion_override; // Copy volatile sys_rt_exec_motion_override
    2ca6:	c0 91 19 0c 	lds	r28, 0x0C19	; 0x800c19 <sys_rt_exec_motion_override>
  if (rt_exec) {
    2caa:	cc 23       	and	r28, r28
    2cac:	81 f1       	breq	.+96     	; 0x2d0e <protocol_exec_rt_system+0x290>
    system_clear_exec_motion_overrides(); // Clear all motion override flags.
    2cae:	0e 94 56 3e 	call	0x7cac	; 0x7cac <system_clear_exec_motion_overrides>

    uint8_t new_f_override =  sys.f_override;
    2cb2:	20 91 25 0c 	lds	r18, 0x0C25	; 0x800c25 <sys+0x7>
    if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
    2cb6:	c0 ff       	sbrs	r28, 0
    2cb8:	02 c0       	rjmp	.+4      	; 0x2cbe <protocol_exec_rt_system+0x240>
    2cba:	84 e6       	ldi	r24, 0x64	; 100
    2cbc:	01 c0       	rjmp	.+2      	; 0x2cc0 <protocol_exec_rt_system+0x242>
  // Execute overrides.
  rt_exec = sys_rt_exec_motion_override; // Copy volatile sys_rt_exec_motion_override
  if (rt_exec) {
    system_clear_exec_motion_overrides(); // Clear all motion override flags.

    uint8_t new_f_override =  sys.f_override;
    2cbe:	82 2f       	mov	r24, r18
    if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
    if (rt_exec & EXEC_FEED_OVR_COARSE_PLUS) { new_f_override += FEED_OVERRIDE_COARSE_INCREMENT; }
    2cc0:	c1 fd       	sbrc	r28, 1
    2cc2:	86 5f       	subi	r24, 0xF6	; 246
    if (rt_exec & EXEC_FEED_OVR_COARSE_MINUS) { new_f_override -= FEED_OVERRIDE_COARSE_INCREMENT; }
    2cc4:	c2 fd       	sbrc	r28, 2
    2cc6:	8a 50       	subi	r24, 0x0A	; 10
    if (rt_exec & EXEC_FEED_OVR_FINE_PLUS) { new_f_override += FEED_OVERRIDE_FINE_INCREMENT; }
    2cc8:	c3 fd       	sbrc	r28, 3
    2cca:	8f 5f       	subi	r24, 0xFF	; 255
    if (rt_exec & EXEC_FEED_OVR_FINE_MINUS) { new_f_override -= FEED_OVERRIDE_FINE_INCREMENT; }
    2ccc:	c4 fd       	sbrc	r28, 4
    2cce:	81 50       	subi	r24, 0x01	; 1
    new_f_override = min(new_f_override,MAX_FEED_RATE_OVERRIDE);
    2cd0:	89 3c       	cpi	r24, 0xC9	; 201
    2cd2:	08 f0       	brcs	.+2      	; 0x2cd6 <protocol_exec_rt_system+0x258>
    2cd4:	88 ec       	ldi	r24, 0xC8	; 200
    new_f_override = max(new_f_override,MIN_FEED_RATE_OVERRIDE);
    2cd6:	8a 30       	cpi	r24, 0x0A	; 10
    2cd8:	08 f4       	brcc	.+2      	; 0x2cdc <protocol_exec_rt_system+0x25e>
    2cda:	8a e0       	ldi	r24, 0x0A	; 10

    uint8_t new_r_override = sys.r_override;
    2cdc:	30 91 26 0c 	lds	r19, 0x0C26	; 0x800c26 <sys+0x8>
    if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
    2ce0:	c5 ff       	sbrs	r28, 5
    2ce2:	02 c0       	rjmp	.+4      	; 0x2ce8 <protocol_exec_rt_system+0x26a>
    2ce4:	94 e6       	ldi	r25, 0x64	; 100
    2ce6:	01 c0       	rjmp	.+2      	; 0x2cea <protocol_exec_rt_system+0x26c>
    if (rt_exec & EXEC_FEED_OVR_FINE_PLUS) { new_f_override += FEED_OVERRIDE_FINE_INCREMENT; }
    if (rt_exec & EXEC_FEED_OVR_FINE_MINUS) { new_f_override -= FEED_OVERRIDE_FINE_INCREMENT; }
    new_f_override = min(new_f_override,MAX_FEED_RATE_OVERRIDE);
    new_f_override = max(new_f_override,MIN_FEED_RATE_OVERRIDE);

    uint8_t new_r_override = sys.r_override;
    2ce8:	93 2f       	mov	r25, r19
    if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
    if (rt_exec & EXEC_RAPID_OVR_MEDIUM) { new_r_override = RAPID_OVERRIDE_MEDIUM; }
    2cea:	c6 fd       	sbrc	r28, 6
    2cec:	92 e3       	ldi	r25, 0x32	; 50
    if (rt_exec & EXEC_RAPID_OVR_LOW) { new_r_override = RAPID_OVERRIDE_LOW; }
    2cee:	cc 23       	and	r28, r28
    2cf0:	0c f4       	brge	.+2      	; 0x2cf4 <protocol_exec_rt_system+0x276>
    2cf2:	99 e1       	ldi	r25, 0x19	; 25

    if ((new_f_override != sys.f_override) || (new_r_override != sys.r_override)) {
    2cf4:	28 13       	cpse	r18, r24
    2cf6:	02 c0       	rjmp	.+4      	; 0x2cfc <protocol_exec_rt_system+0x27e>
    2cf8:	93 17       	cp	r25, r19
    2cfa:	49 f0       	breq	.+18     	; 0x2d0e <protocol_exec_rt_system+0x290>
      sys.f_override = new_f_override;
    2cfc:	ee e1       	ldi	r30, 0x1E	; 30
    2cfe:	fc e0       	ldi	r31, 0x0C	; 12
    2d00:	87 83       	std	Z+7, r24	; 0x07
      sys.r_override = new_r_override;
    2d02:	90 87       	std	Z+8, r25	; 0x08
      sys.report_ovr_counter = 0; // Set to report change immediately
    2d04:	13 86       	std	Z+11, r1	; 0x0b
      plan_update_velocity_profile_parameters();
    2d06:	0e 94 35 2a 	call	0x546a	; 0x546a <plan_update_velocity_profile_parameters>
      plan_cycle_reinitialize();
    2d0a:	0e 94 27 2e 	call	0x5c4e	; 0x5c4e <plan_cycle_reinitialize>
    }
  }

  rt_exec = sys_rt_exec_accessory_override;
    2d0e:	c0 91 30 0c 	lds	r28, 0x0C30	; 0x800c30 <sys_rt_exec_accessory_override>
  if (rt_exec) {
    2d12:	cc 23       	and	r28, r28
    2d14:	09 f4       	brne	.+2      	; 0x2d18 <protocol_exec_rt_system+0x29a>
    2d16:	60 c0       	rjmp	.+192    	; 0x2dd8 <protocol_exec_rt_system+0x35a>
    system_clear_exec_accessory_overrides(); // Clear all accessory override flags.
    2d18:	0e 94 5c 3e 	call	0x7cb8	; 0x7cb8 <system_clear_exec_accessory_overrides>

    // NOTE: Unlike motion overrides, spindle overrides do not require a planner reinitialization.
    uint8_t last_s_override =  sys.spindle_speed_ovr;
    2d1c:	90 91 27 0c 	lds	r25, 0x0C27	; 0x800c27 <sys+0x9>
    if (rt_exec & EXEC_SPINDLE_OVR_RESET) { last_s_override = DEFAULT_SPINDLE_SPEED_OVERRIDE; }
    2d20:	c0 ff       	sbrs	r28, 0
    2d22:	02 c0       	rjmp	.+4      	; 0x2d28 <protocol_exec_rt_system+0x2aa>
    2d24:	84 e6       	ldi	r24, 0x64	; 100
    2d26:	01 c0       	rjmp	.+2      	; 0x2d2a <protocol_exec_rt_system+0x2ac>
  rt_exec = sys_rt_exec_accessory_override;
  if (rt_exec) {
    system_clear_exec_accessory_overrides(); // Clear all accessory override flags.

    // NOTE: Unlike motion overrides, spindle overrides do not require a planner reinitialization.
    uint8_t last_s_override =  sys.spindle_speed_ovr;
    2d28:	89 2f       	mov	r24, r25
    if (rt_exec & EXEC_SPINDLE_OVR_RESET) { last_s_override = DEFAULT_SPINDLE_SPEED_OVERRIDE; }
    if (rt_exec & EXEC_SPINDLE_OVR_COARSE_PLUS) { last_s_override += SPINDLE_OVERRIDE_COARSE_INCREMENT; }
    2d2a:	c1 fd       	sbrc	r28, 1
    2d2c:	86 5f       	subi	r24, 0xF6	; 246
    if (rt_exec & EXEC_SPINDLE_OVR_COARSE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_COARSE_INCREMENT; }
    2d2e:	c2 fd       	sbrc	r28, 2
    2d30:	8a 50       	subi	r24, 0x0A	; 10
    if (rt_exec & EXEC_SPINDLE_OVR_FINE_PLUS) { last_s_override += SPINDLE_OVERRIDE_FINE_INCREMENT; }
    2d32:	c3 fd       	sbrc	r28, 3
    2d34:	8f 5f       	subi	r24, 0xFF	; 255
    if (rt_exec & EXEC_SPINDLE_OVR_FINE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_FINE_INCREMENT; }
    2d36:	c4 fd       	sbrc	r28, 4
    2d38:	81 50       	subi	r24, 0x01	; 1
    last_s_override = min(last_s_override,MAX_SPINDLE_SPEED_OVERRIDE);
    2d3a:	89 3c       	cpi	r24, 0xC9	; 201
    2d3c:	08 f0       	brcs	.+2      	; 0x2d40 <protocol_exec_rt_system+0x2c2>
    2d3e:	88 ec       	ldi	r24, 0xC8	; 200
    last_s_override = max(last_s_override,MIN_SPINDLE_SPEED_OVERRIDE);
    2d40:	8a 30       	cpi	r24, 0x0A	; 10
    2d42:	08 f4       	brcc	.+2      	; 0x2d46 <protocol_exec_rt_system+0x2c8>
    2d44:	8a e0       	ldi	r24, 0x0A	; 10

    if (last_s_override != sys.spindle_speed_ovr) {
    2d46:	98 17       	cp	r25, r24
    2d48:	b1 f0       	breq	.+44     	; 0x2d76 <protocol_exec_rt_system+0x2f8>
      sys.spindle_speed_ovr = last_s_override;
    2d4a:	ee e1       	ldi	r30, 0x1E	; 30
    2d4c:	fc e0       	ldi	r31, 0x0C	; 12
    2d4e:	81 87       	std	Z+9, r24	; 0x09
      // NOTE: Spindle speed overrides during HOLD state are taken care of by suspend function.
      if (sys.state == STATE_IDLE) { spindle_set_state(gc_state.modal.spindle, gc_state.spindle_speed); }
    2d50:	80 81       	ld	r24, Z
    2d52:	81 11       	cpse	r24, r1
    2d54:	09 c0       	rjmp	.+18     	; 0x2d68 <protocol_exec_rt_system+0x2ea>
    2d56:	e6 e5       	ldi	r30, 0x56	; 86
    2d58:	fc e0       	ldi	r31, 0x0C	; 12
    2d5a:	43 85       	ldd	r20, Z+11	; 0x0b
    2d5c:	54 85       	ldd	r21, Z+12	; 0x0c
    2d5e:	65 85       	ldd	r22, Z+13	; 0x0d
    2d60:	76 85       	ldd	r23, Z+14	; 0x0e
    2d62:	81 85       	ldd	r24, Z+9	; 0x09
    2d64:	ca dc       	rcall	.-1644   	; 0x26fa <spindle_set_state>
    2d66:	05 c0       	rjmp	.+10     	; 0x2d72 <protocol_exec_rt_system+0x2f4>
			else { bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM); }
    2d68:	ee e1       	ldi	r30, 0x1E	; 30
    2d6a:	fc e0       	ldi	r31, 0x0C	; 12
    2d6c:	84 81       	ldd	r24, Z+4	; 0x04
    2d6e:	88 60       	ori	r24, 0x08	; 8
    2d70:	84 83       	std	Z+4, r24	; 0x04
      sys.report_ovr_counter = 0; // Set to report change immediately
    2d72:	10 92 29 0c 	sts	0x0C29, r1	; 0x800c29 <sys+0xb>
    }

    if (rt_exec & EXEC_SPINDLE_OVR_STOP) {
    2d76:	c5 ff       	sbrs	r28, 5
    2d78:	12 c0       	rjmp	.+36     	; 0x2d9e <protocol_exec_rt_system+0x320>
      // Spindle stop override allowed only while in HOLD state.
      // NOTE: Report counters are set in spindle_set_state() when spindle stop is executed.
      if (sys.state == STATE_HOLD) {
    2d7a:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2d7e:	80 31       	cpi	r24, 0x10	; 16
    2d80:	71 f4       	brne	.+28     	; 0x2d9e <protocol_exec_rt_system+0x320>
        if (!(sys.spindle_stop_ovr)) { sys.spindle_stop_ovr = SPINDLE_STOP_OVR_INITIATE; }
    2d82:	80 91 28 0c 	lds	r24, 0x0C28	; 0x800c28 <sys+0xa>
    2d86:	81 11       	cpse	r24, r1
    2d88:	04 c0       	rjmp	.+8      	; 0x2d92 <protocol_exec_rt_system+0x314>
    2d8a:	82 e0       	ldi	r24, 0x02	; 2
    2d8c:	80 93 28 0c 	sts	0x0C28, r24	; 0x800c28 <sys+0xa>
    2d90:	92 c0       	rjmp	.+292    	; 0x2eb6 <protocol_exec_rt_system+0x438>
        else if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_ENABLED) { sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE; }
    2d92:	80 ff       	sbrs	r24, 0
    2d94:	90 c0       	rjmp	.+288    	; 0x2eb6 <protocol_exec_rt_system+0x438>
    2d96:	84 60       	ori	r24, 0x04	; 4
    2d98:	80 93 28 0c 	sts	0x0C28, r24	; 0x800c28 <sys+0xa>
    2d9c:	8c c0       	rjmp	.+280    	; 0x2eb6 <protocol_exec_rt_system+0x438>
    }

    // NOTE: Since coolant state always performs a planner sync whenever it changes, the current
    // run state can be determined by checking the parser state.
    // NOTE: Coolant overrides only operate during IDLE, CYCLE, HOLD, and JOG states. Ignored otherwise.																										
    if (rt_exec & (EXEC_COOLANT_FLOOD_OVR_TOGGLE | EXEC_COOLANT_MIST_OVR_TOGGLE)) {
    2d9e:	8c 2f       	mov	r24, r28
    2da0:	80 7c       	andi	r24, 0xC0	; 192
    2da2:	d1 f0       	breq	.+52     	; 0x2dd8 <protocol_exec_rt_system+0x35a>
      if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_JOG))) {
    2da4:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2da8:	88 23       	and	r24, r24
    2daa:	11 f0       	breq	.+4      	; 0x2db0 <protocol_exec_rt_system+0x332>
    2dac:	88 73       	andi	r24, 0x38	; 56
    2dae:	a1 f0       	breq	.+40     	; 0x2dd8 <protocol_exec_rt_system+0x35a>
        uint8_t coolant_state = gc_state.modal.coolant;
    2db0:	d0 91 5e 0c 	lds	r29, 0x0C5E	; 0x800c5e <gc_state+0x8>
        if (rt_exec & EXEC_COOLANT_MIST_OVR_TOGGLE) {
    2db4:	cc 23       	and	r28, r28
    2db6:	2c f4       	brge	.+10     	; 0x2dc2 <protocol_exec_rt_system+0x344>
          if (coolant_state & COOLANT_MIST_ENABLE) { bit_false(coolant_state,COOLANT_MIST_ENABLE); }
    2db8:	dd 23       	and	r29, r29
    2dba:	14 f4       	brge	.+4      	; 0x2dc0 <protocol_exec_rt_system+0x342>
    2dbc:	df 77       	andi	r29, 0x7F	; 127
    2dbe:	01 c0       	rjmp	.+2      	; 0x2dc2 <protocol_exec_rt_system+0x344>
          else { coolant_state |= COOLANT_MIST_ENABLE; }
    2dc0:	d0 68       	ori	r29, 0x80	; 128
        }
        if (rt_exec & EXEC_COOLANT_FLOOD_OVR_TOGGLE) {
    2dc2:	c6 ff       	sbrs	r28, 6
    2dc4:	05 c0       	rjmp	.+10     	; 0x2dd0 <protocol_exec_rt_system+0x352>
          if (coolant_state & COOLANT_FLOOD_ENABLE) { bit_false(coolant_state,COOLANT_FLOOD_ENABLE); }
    2dc6:	d6 ff       	sbrs	r29, 6
    2dc8:	02 c0       	rjmp	.+4      	; 0x2dce <protocol_exec_rt_system+0x350>
    2dca:	df 7b       	andi	r29, 0xBF	; 191
          else { coolant_state |= COOLANT_FLOOD_ENABLE; }
    2dcc:	01 c0       	rjmp	.+2      	; 0x2dd0 <protocol_exec_rt_system+0x352>
        }
        coolant_set_state(coolant_state); // Report counter set in coolant_set_state().
    2dce:	d0 64       	ori	r29, 0x40	; 64
    2dd0:	8d 2f       	mov	r24, r29
    2dd2:	f3 dc       	rcall	.-1562   	; 0x27ba <coolant_set_state>
        gc_state.modal.coolant = coolant_state;
    2dd4:	d0 93 5e 0c 	sts	0x0C5E, r29	; 0x800c5e <gc_state+0x8>
      }
    }
  }
  #ifdef LATHE		
  //processing spindle pulse and spindle synchronization pulse
   rt_exec = sys_sync_state;	//save the volatile value
    2dd8:	80 91 14 0c 	lds	r24, 0x0C14	; 0x800c14 <sys_sync_state>
   if (bit_istrue(rt_exec,EXEC_SPINDLE_SYNC)){
    2ddc:	81 ff       	sbrs	r24, 1
    2dde:	19 c0       	rjmp	.+50     	; 0x2e12 <protocol_exec_rt_system+0x394>
	   sys_synchronization_pulse_count++;
    2de0:	40 91 15 0c 	lds	r20, 0x0C15	; 0x800c15 <sys_synchronization_pulse_count>
    2de4:	50 91 16 0c 	lds	r21, 0x0C16	; 0x800c16 <sys_synchronization_pulse_count+0x1>
    2de8:	60 91 17 0c 	lds	r22, 0x0C17	; 0x800c17 <sys_synchronization_pulse_count+0x2>
    2dec:	70 91 18 0c 	lds	r23, 0x0C18	; 0x800c18 <sys_synchronization_pulse_count+0x3>
    2df0:	4f 5f       	subi	r20, 0xFF	; 255
    2df2:	5f 4f       	sbci	r21, 0xFF	; 255
    2df4:	6f 4f       	sbci	r22, 0xFF	; 255
    2df6:	7f 4f       	sbci	r23, 0xFF	; 255
    2df8:	40 93 15 0c 	sts	0x0C15, r20	; 0x800c15 <sys_synchronization_pulse_count>
    2dfc:	50 93 16 0c 	sts	0x0C16, r21	; 0x800c16 <sys_synchronization_pulse_count+0x1>
    2e00:	60 93 17 0c 	sts	0x0C17, r22	; 0x800c17 <sys_synchronization_pulse_count+0x2>
    2e04:	70 93 18 0c 	sts	0x0C18, r23	; 0x800c18 <sys_synchronization_pulse_count+0x3>
	   bit_false(sys_sync_state,EXEC_SPINDLE_SYNC);
    2e08:	90 91 14 0c 	lds	r25, 0x0C14	; 0x800c14 <sys_sync_state>
    2e0c:	9d 7f       	andi	r25, 0xFD	; 253
    2e0e:	90 93 14 0c 	sts	0x0C14, r25	; 0x800c14 <sys_sync_state>
	   //report_synchronization_state();
   }
   if (bit_istrue(rt_exec,EXEC_SPINDLE_INDEX)){
    2e12:	80 ff       	sbrs	r24, 0
    2e14:	42 c0       	rjmp	.+132    	; 0x2e9a <protocol_exec_rt_system+0x41c>
	   sys_index_pulse_count++;
    2e16:	80 91 55 0c 	lds	r24, 0x0C55	; 0x800c55 <sys_index_pulse_count>
    2e1a:	8f 5f       	subi	r24, 0xFF	; 255
    2e1c:	80 93 55 0c 	sts	0x0C55, r24	; 0x800c55 <sys_index_pulse_count>
	   sys_sync_time=get_timer_ticks();
    2e20:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <get_timer_ticks>
    2e24:	60 93 4f 0c 	sts	0x0C4F, r22	; 0x800c4f <sys_sync_time>
    2e28:	70 93 50 0c 	sts	0x0C50, r23	; 0x800c50 <sys_sync_time+0x1>
    2e2c:	80 93 51 0c 	sts	0x0C51, r24	; 0x800c51 <sys_sync_time+0x2>
    2e30:	90 93 52 0c 	sts	0x0C52, r25	; 0x800c52 <sys_sync_time+0x3>
	   sys_sync_time_passed=sys_sync_time-sys_sync_Last_time;
    2e34:	80 91 4f 0c 	lds	r24, 0x0C4F	; 0x800c4f <sys_sync_time>
    2e38:	90 91 50 0c 	lds	r25, 0x0C50	; 0x800c50 <sys_sync_time+0x1>
    2e3c:	a0 91 51 0c 	lds	r26, 0x0C51	; 0x800c51 <sys_sync_time+0x2>
    2e40:	b0 91 52 0c 	lds	r27, 0x0C52	; 0x800c52 <sys_sync_time+0x3>
    2e44:	40 91 33 0c 	lds	r20, 0x0C33	; 0x800c33 <sys_sync_Last_time>
    2e48:	50 91 34 0c 	lds	r21, 0x0C34	; 0x800c34 <sys_sync_Last_time+0x1>
    2e4c:	60 91 35 0c 	lds	r22, 0x0C35	; 0x800c35 <sys_sync_Last_time+0x2>
    2e50:	70 91 36 0c 	lds	r23, 0x0C36	; 0x800c36 <sys_sync_Last_time+0x3>
    2e54:	84 1b       	sub	r24, r20
    2e56:	95 0b       	sbc	r25, r21
    2e58:	a6 0b       	sbc	r26, r22
    2e5a:	b7 0b       	sbc	r27, r23
    2e5c:	80 93 1a 0c 	sts	0x0C1A, r24	; 0x800c1a <sys_sync_time_passed>
    2e60:	90 93 1b 0c 	sts	0x0C1B, r25	; 0x800c1b <sys_sync_time_passed+0x1>
    2e64:	a0 93 1c 0c 	sts	0x0C1C, r26	; 0x800c1c <sys_sync_time_passed+0x2>
    2e68:	b0 93 1d 0c 	sts	0x0C1D, r27	; 0x800c1d <sys_sync_time_passed+0x3>
	   sys_sync_Last_time=sys_sync_time;
    2e6c:	80 91 4f 0c 	lds	r24, 0x0C4F	; 0x800c4f <sys_sync_time>
    2e70:	90 91 50 0c 	lds	r25, 0x0C50	; 0x800c50 <sys_sync_time+0x1>
    2e74:	a0 91 51 0c 	lds	r26, 0x0C51	; 0x800c51 <sys_sync_time+0x2>
    2e78:	b0 91 52 0c 	lds	r27, 0x0C52	; 0x800c52 <sys_sync_time+0x3>
    2e7c:	80 93 33 0c 	sts	0x0C33, r24	; 0x800c33 <sys_sync_Last_time>
    2e80:	90 93 34 0c 	sts	0x0C34, r25	; 0x800c34 <sys_sync_Last_time+0x1>
    2e84:	a0 93 35 0c 	sts	0x0C35, r26	; 0x800c35 <sys_sync_Last_time+0x2>
    2e88:	b0 93 36 0c 	sts	0x0C36, r27	; 0x800c36 <sys_sync_Last_time+0x3>
	   report_synchronization_state();					//report on every index pulse
    2e8c:	0e 94 7d 35 	call	0x6afa	; 0x6afa <report_synchronization_state>
	   bit_false(sys_sync_state,EXEC_SPINDLE_INDEX);
    2e90:	80 91 14 0c 	lds	r24, 0x0C14	; 0x800c14 <sys_sync_state>
    2e94:	8e 7f       	andi	r24, 0xFE	; 254
    2e96:	80 93 14 0c 	sts	0x0C14, r24	; 0x800c14 <sys_sync_state>
   }   
  #endif
  
  #ifdef DEBUG
    if (sys_rt_exec_debug) {
    2e9a:	80 91 54 0c 	lds	r24, 0x0C54	; 0x800c54 <sys_rt_exec_debug>
    2e9e:	88 23       	and	r24, r24
    2ea0:	21 f0       	breq	.+8      	; 0x2eaa <protocol_exec_rt_system+0x42c>
      report_realtime_debug();
    2ea2:	0e 94 94 3a 	call	0x7528	; 0x7528 <report_realtime_debug>
      sys_rt_exec_debug = 0;
    2ea6:	10 92 54 0c 	sts	0x0C54, r1	; 0x800c54 <sys_rt_exec_debug>
    }
  #endif

  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_SAFETY_DOOR | STATE_HOMING | STATE_SLEEP| STATE_JOG)) {
    2eaa:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2eae:	8c 7f       	andi	r24, 0xFC	; 252
    st_prep_buffer();
    2eb0:	51 f0       	breq	.+20     	; 0x2ec6 <protocol_exec_rt_system+0x448>
    2eb2:	f4 d4       	rcall	.+2536   	; 0x389c <st_prep_buffer>
    2eb4:	08 c0       	rjmp	.+16     	; 0x2ec6 <protocol_exec_rt_system+0x448>
    }

    // NOTE: Since coolant state always performs a planner sync whenever it changes, the current
    // run state can be determined by checking the parser state.
    // NOTE: Coolant overrides only operate during IDLE, CYCLE, HOLD, and JOG states. Ignored otherwise.																										
    if (rt_exec & (EXEC_COOLANT_FLOOD_OVR_TOGGLE | EXEC_COOLANT_MIST_OVR_TOGGLE)) {
    2eb6:	8c 2f       	mov	r24, r28
    2eb8:	80 7c       	andi	r24, 0xC0	; 192
    2eba:	09 f0       	breq	.+2      	; 0x2ebe <protocol_exec_rt_system+0x440>
    2ebc:	79 cf       	rjmp	.-270    	; 0x2db0 <protocol_exec_rt_system+0x332>
    2ebe:	8c cf       	rjmp	.-232    	; 0x2dd8 <protocol_exec_rt_system+0x35a>
          // will handle and clear multiple planner block motions.
          if (!(sys.state & STATE_JOG)) { sys.suspend |= SUSPEND_MOTION_CANCEL; } // NOTE: State is STATE_CYCLE.
        }

        // Execute a feed hold with deceleration, if required. Then, suspend system.
        if (rt_exec & EXEC_FEED_HOLD) {
    2ec0:	c3 fd       	sbrc	r28, 3
    2ec2:	3f ce       	rjmp	.-898    	; 0x2b42 <protocol_exec_rt_system+0xc4>
    2ec4:	41 ce       	rjmp	.-894    	; 0x2b48 <protocol_exec_rt_system+0xca>
  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_SAFETY_DOOR | STATE_HOMING | STATE_SLEEP| STATE_JOG)) {
    st_prep_buffer();
  }

}
    2ec6:	df 91       	pop	r29
    2ec8:	cf 91       	pop	r28
    2eca:	08 95       	ret

00002ecc <protocol_execute_realtime>:
// also provides a controlled way to execute certain tasks without having two or more instances of
// the same task, such as the planner recalculating the buffer upon a feedhold or overrides.
// NOTE: The sys_rt_exec_state variable flags are set by any process, step or serial interrupts, pinouts,
// limit switches, or the main program.
void protocol_execute_realtime()
{
    2ecc:	7f 92       	push	r7
    2ece:	8f 92       	push	r8
    2ed0:	9f 92       	push	r9
    2ed2:	af 92       	push	r10
    2ed4:	bf 92       	push	r11
    2ed6:	cf 92       	push	r12
    2ed8:	df 92       	push	r13
    2eda:	ef 92       	push	r14
    2edc:	ff 92       	push	r15
    2ede:	0f 93       	push	r16
    2ee0:	1f 93       	push	r17
    2ee2:	cf 93       	push	r28
    2ee4:	df 93       	push	r29
  protocol_exec_rt_system();
    2ee6:	cb dd       	rcall	.-1130   	; 0x2a7e <protocol_exec_rt_system>
  if (sys.suspend) { protocol_exec_rt_suspend(); }
    2ee8:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2eec:	88 23       	and	r24, r24
    2eee:	09 f4       	brne	.+2      	; 0x2ef2 <protocol_execute_realtime+0x26>
    2ef0:	f4 c0       	rjmp	.+488    	; 0x30da <protocol_execute_realtime+0x20e>
    memset(pl_data,0,sizeof(plan_line_data_t));
    pl_data->condition = (PL_COND_FLAG_SYSTEM_MOTION|PL_COND_FLAG_NO_FEED_OVERRIDE);
    pl_data->line_number = PARKING_MOTION_LINE_NUMBER;
  #endif

  plan_block_t *block = plan_get_current_block();
    2ef2:	0e 94 87 29 	call	0x530e	; 0x530e <plan_get_current_block>
    2ef6:	ec 01       	movw	r28, r24
  uint8_t restore_condition;
  float restore_spindle_speed;
  if (block == NULL) {
    2ef8:	89 2b       	or	r24, r25
    2efa:	51 f4       	brne	.+20     	; 0x2f10 <protocol_execute_realtime+0x44>
    restore_condition = (gc_state.modal.spindle | gc_state.modal.coolant);
    2efc:	e6 e5       	ldi	r30, 0x56	; 86
    2efe:	fc e0       	ldi	r31, 0x0C	; 12
    2f00:	d1 84       	ldd	r13, Z+9	; 0x09
    2f02:	80 85       	ldd	r24, Z+8	; 0x08
    2f04:	d8 2a       	or	r13, r24
    restore_spindle_speed = gc_state.spindle_speed;
    2f06:	83 84       	ldd	r8, Z+11	; 0x0b
    2f08:	94 84       	ldd	r9, Z+12	; 0x0c
    2f0a:	a5 84       	ldd	r10, Z+13	; 0x0d
    2f0c:	b6 84       	ldd	r11, Z+14	; 0x0e
    2f0e:	0a c0       	rjmp	.+20     	; 0x2f24 <protocol_execute_realtime+0x58>
  } else {
    restore_condition = (block->condition & PL_COND_SPINDLE_MASK) | coolant_get_state();
    2f10:	89 89       	ldd	r24, Y+17	; 0x11
    2f12:	18 2f       	mov	r17, r24
    2f14:	10 73       	andi	r17, 0x30	; 48
    2f16:	32 dc       	rcall	.-1948   	; 0x277c <coolant_get_state>
    2f18:	d8 2e       	mov	r13, r24
    2f1a:	d1 2a       	or	r13, r17
    restore_spindle_speed = block->spindle_speed;
    2f1c:	8a a8       	ldd	r8, Y+50	; 0x32
    2f1e:	9b a8       	ldd	r9, Y+51	; 0x33
    2f20:	ac a8       	ldd	r10, Y+52	; 0x34
    2f22:	bd a8       	ldd	r11, Y+53	; 0x35
  }
  #ifdef DISABLE_LASER_DURING_HOLD
    if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) { 
    2f24:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    2f28:	81 ff       	sbrs	r24, 1
    2f2a:	03 c0       	rjmp	.+6      	; 0x2f32 <protocol_execute_realtime+0x66>
      system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP);
    2f2c:	80 e2       	ldi	r24, 0x20	; 32
    2f2e:	0e 94 4d 3e 	call	0x7c9a	; 0x7c9a <system_set_exec_accessory_override_flag>
    }
  #endif

  while (sys.suspend) {
    2f32:	90 91 20 0c 	lds	r25, 0x0C20	; 0x800c20 <sys+0x2>
    2f36:	99 23       	and	r25, r25
    2f38:	09 f4       	brne	.+2      	; 0x2f3c <protocol_execute_realtime+0x70>
    2f3a:	cf c0       	rjmp	.+414    	; 0x30da <protocol_execute_realtime+0x20e>

    if (sys.abort) { return; }
    2f3c:	80 91 1f 0c 	lds	r24, 0x0C1F	; 0x800c1f <sys+0x1>
    2f40:	81 11       	cpse	r24, r1
    2f42:	cb c0       	rjmp	.+406    	; 0x30da <protocol_execute_realtime+0x20e>
    // Block until initial hold is complete and the machine has stopped motion.
    if (sys.suspend & SUSPEND_HOLD_COMPLETE) {

      // Parking manager. Handles de/re-energizing, switch state checks, and parking motions for 
      // the safety door and sleep states.
      if (sys.state & (STATE_SAFETY_DOOR | STATE_SLEEP)) {
    2f44:	ce e1       	ldi	r28, 0x1E	; 30
    2f46:	dc e0       	ldi	r29, 0x0C	; 12
          }
        } else {
          // Handles spindle state during hold. NOTE: Spindle speed overrides may be altered during hold state.
          // NOTE: STEP_CONTROL_UPDATE_SPINDLE_PWM is automatically reset upon resume in step generator.
          if (bit_istrue(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
            spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    2f48:	8d 2d       	mov	r24, r13
    2f4a:	80 73       	andi	r24, 0x30	; 48
    2f4c:	c8 2e       	mov	r12, r24
            } else {
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
            }
          // Handles restoring of spindle state
          } else if (sys.spindle_stop_ovr & (SPINDLE_STOP_OVR_RESTORE | SPINDLE_STOP_OVR_RESTORE_CYCLE)) {
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    2f4e:	06 e5       	ldi	r16, 0x56	; 86
    2f50:	1c e0       	ldi	r17, 0x0C	; 12
              report_feedback_message(MESSAGE_SPINDLE_RESTORE);
              if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    2f52:	0f 2e       	mov	r0, r31
    2f54:	f5 e1       	ldi	r31, 0x15	; 21
    2f56:	ef 2e       	mov	r14, r31
    2f58:	ff e0       	ldi	r31, 0x0F	; 15
    2f5a:	ff 2e       	mov	r15, r31
    2f5c:	f0 2d       	mov	r31, r0
        if (sys.spindle_stop_ovr) {
          // Handles beginning of spindle stop
          if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_INITIATE) {
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
              spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_ENABLED; // Set stop override state to enabled, if de-energized.
    2f5e:	77 24       	eor	r7, r7
    2f60:	73 94       	inc	r7
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
                // NOTE: Laser mode will honor this delay. An exhaust system is often controlled by this pin.
                coolant_set_state((restore_condition & (PL_COND_FLAG_COOLANT_FLOOD | PL_COND_FLAG_COOLANT_MIST)));
    2f62:	ed 2d       	mov	r30, r13
    2f64:	e0 7c       	andi	r30, 0xC0	; 192
    2f66:	de 2e       	mov	r13, r30
    2f68:	03 c0       	rjmp	.+6      	; 0x2f70 <protocol_execute_realtime+0xa4>
    }
  #endif

  while (sys.suspend) {

    if (sys.abort) { return; }
    2f6a:	29 81       	ldd	r18, Y+1	; 0x01
    2f6c:	21 11       	cpse	r18, r1
    2f6e:	b5 c0       	rjmp	.+362    	; 0x30da <protocol_execute_realtime+0x20e>

    // Block until initial hold is complete and the machine has stopped motion.
    if (sys.suspend & SUSPEND_HOLD_COMPLETE) {
    2f70:	90 ff       	sbrs	r25, 0
    2f72:	a7 c0       	rjmp	.+334    	; 0x30c2 <protocol_execute_realtime+0x1f6>

      // Parking manager. Handles de/re-energizing, switch state checks, and parking motions for 
      // the safety door and sleep states.
      if (sys.state & (STATE_SAFETY_DOOR | STATE_SLEEP)) {
    2f74:	28 81       	ld	r18, Y
    2f76:	32 2f       	mov	r19, r18
    2f78:	30 7c       	andi	r19, 0xC0	; 192
    2f7a:	09 f4       	brne	.+2      	; 0x2f7e <protocol_execute_realtime+0xb2>
    2f7c:	69 c0       	rjmp	.+210    	; 0x3050 <protocol_execute_realtime+0x184>
      
        // Handles retraction motions and de-energizing.
        if (bit_isfalse(sys.suspend,SUSPEND_RETRACT_COMPLETE)) {
    2f7e:	92 fd       	sbrc	r25, 2
    2f80:	0d c0       	rjmp	.+26     	; 0x2f9c <protocol_execute_realtime+0xd0>

          // Ensure any prior spindle stop override is disabled at start of safety door routine.
          sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED;
    2f82:	1a 86       	std	Y+10, r1	; 0x0a

          #ifndef PARKING_ENABLE

            spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
    2f84:	40 e0       	ldi	r20, 0x00	; 0
    2f86:	50 e0       	ldi	r21, 0x00	; 0
    2f88:	ba 01       	movw	r22, r20
    2f8a:	80 e0       	ldi	r24, 0x00	; 0
            coolant_set_state(COOLANT_DISABLE);     // De-energize
    2f8c:	b6 db       	rcall	.-2196   	; 0x26fa <spindle_set_state>
    2f8e:	80 e0       	ldi	r24, 0x00	; 0
    2f90:	14 dc       	rcall	.-2008   	; 0x27ba <coolant_set_state>
            }

          #endif

          sys.suspend &= ~(SUSPEND_RESTART_RETRACT);
          sys.suspend |= SUSPEND_RETRACT_COMPLETE;
    2f92:	8a 81       	ldd	r24, Y+2	; 0x02
    2f94:	8d 7f       	andi	r24, 0xFD	; 253
    2f96:	84 60       	ori	r24, 0x04	; 4
    2f98:	8a 83       	std	Y+2, r24	; 0x02
    2f9a:	93 c0       	rjmp	.+294    	; 0x30c2 <protocol_execute_realtime+0x1f6>

        } else {

          
          if (sys.state == STATE_SLEEP) {
    2f9c:	20 38       	cpi	r18, 0x80	; 128
    2f9e:	b1 f4       	brne	.+44     	; 0x2fcc <protocol_execute_realtime+0x100>
            report_feedback_message(MESSAGE_SLEEP_MODE);
    2fa0:	8b e0       	ldi	r24, 0x0B	; 11
    2fa2:	0e 94 d5 35 	call	0x6baa	; 0x6baa <report_feedback_message>
            // Spindle and coolant should already be stopped, but do it again just to be sure.
            spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
    2fa6:	40 e0       	ldi	r20, 0x00	; 0
    2fa8:	50 e0       	ldi	r21, 0x00	; 0
    2faa:	ba 01       	movw	r22, r20
            coolant_set_state(COOLANT_DISABLE); // De-energize
    2fac:	80 e0       	ldi	r24, 0x00	; 0
    2fae:	a5 db       	rcall	.-2230   	; 0x26fa <spindle_set_state>
    2fb0:	80 e0       	ldi	r24, 0x00	; 0
            st_go_idle(); // Disable steppers
    2fb2:	03 dc       	rcall	.-2042   	; 0x27ba <coolant_set_state>
            while (!(sys.abort)) { protocol_exec_rt_system(); } // Do nothing until reset.
    2fb4:	7e d1       	rcall	.+764    	; 0x32b2 <st_go_idle>
    2fb6:	80 91 1f 0c 	lds	r24, 0x0C1F	; 0x800c1f <sys+0x1>
    2fba:	81 11       	cpse	r24, r1
    2fbc:	8e c0       	rjmp	.+284    	; 0x30da <protocol_execute_realtime+0x20e>
    2fbe:	ce e1       	ldi	r28, 0x1E	; 30
    2fc0:	dc e0       	ldi	r29, 0x0C	; 12
    2fc2:	5d dd       	rcall	.-1350   	; 0x2a7e <protocol_exec_rt_system>
    2fc4:	89 81       	ldd	r24, Y+1	; 0x01
    2fc6:	88 23       	and	r24, r24
    2fc8:	e1 f3       	breq	.-8      	; 0x2fc2 <protocol_execute_realtime+0xf6>
    2fca:	87 c0       	rjmp	.+270    	; 0x30da <protocol_execute_realtime+0x20e>
            return; // Abort received. Return to re-initialize.
          }    
          
          // Allows resuming from parking/safety door. Actively checks if safety door is closed and ready to resume.
          if (sys.state == STATE_SAFETY_DOOR) {
    2fcc:	20 34       	cpi	r18, 0x40	; 64
    2fce:	39 f4       	brne	.+14     	; 0x2fde <protocol_execute_realtime+0x112>
            if (!(system_check_safety_door_ajar())) {
    2fd0:	0e 94 0d 3b 	call	0x761a	; 0x761a <system_check_safety_door_ajar>
    2fd4:	81 11       	cpse	r24, r1
    2fd6:	03 c0       	rjmp	.+6      	; 0x2fde <protocol_execute_realtime+0x112>
              sys.suspend &= ~(SUSPEND_SAFETY_DOOR_AJAR); // Reset door ajar flag to denote ready to resume.
    2fd8:	8a 81       	ldd	r24, Y+2	; 0x02
    2fda:	8f 7d       	andi	r24, 0xDF	; 223
    2fdc:	8a 83       	std	Y+2, r24	; 0x02
            }
          }

          // Handles parking restore and safety door resume.
          if (sys.suspend & SUSPEND_INITIATE_RESTORE) {
    2fde:	8a 81       	ldd	r24, Y+2	; 0x02
    2fe0:	83 ff       	sbrs	r24, 3
    2fe2:	6f c0       	rjmp	.+222    	; 0x30c2 <protocol_execute_realtime+0x1f6>
                }
              }
            #endif

            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    2fe4:	f8 01       	movw	r30, r16
    2fe6:	91 85       	ldd	r25, Z+9	; 0x09
    2fe8:	99 23       	and	r25, r25
    2fea:	c9 f0       	breq	.+50     	; 0x301e <protocol_execute_realtime+0x152>
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    2fec:	81 fd       	sbrc	r24, 1
    2fee:	6e c0       	rjmp	.+220    	; 0x30cc <protocol_execute_realtime+0x200>
                if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    2ff0:	f7 01       	movw	r30, r14
    2ff2:	80 81       	ld	r24, Z
    2ff4:	81 ff       	sbrs	r24, 1
    2ff6:	08 c0       	rjmp	.+16     	; 0x3008 <protocol_execute_realtime+0x13c>
                  // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                  bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    2ff8:	8c 81       	ldd	r24, Y+4	; 0x04
    2ffa:	88 60       	ori	r24, 0x08	; 8
    2ffc:	8c 83       	std	Y+4, r24	; 0x04
                  spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
                  delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
                }
              }
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
    2ffe:	f8 01       	movw	r30, r16
    3000:	80 85       	ldd	r24, Z+8	; 0x08
    3002:	81 11       	cpse	r24, r1
    3004:	13 c0       	rjmp	.+38     	; 0x302c <protocol_execute_realtime+0x160>
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
                if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
                  // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                  bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
                } else {
                  spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    3006:	67 c0       	rjmp	.+206    	; 0x30d6 <protocol_execute_realtime+0x20a>
    3008:	b5 01       	movw	r22, r10
    300a:	a4 01       	movw	r20, r8
    300c:	8c 2d       	mov	r24, r12
    300e:	75 db       	rcall	.-2326   	; 0x26fa <spindle_set_state>
                  delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
    3010:	47 2d       	mov	r20, r7
    3012:	60 e0       	ldi	r22, 0x00	; 0
    3014:	70 e0       	ldi	r23, 0x00	; 0
    3016:	80 e8       	ldi	r24, 0x80	; 128
    3018:	90 e4       	ldi	r25, 0x40	; 64
    301a:	0e 94 f5 2e 	call	0x5dea	; 0x5dea <delay_sec>
                }
              }
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
    301e:	f8 01       	movw	r30, r16
    3020:	80 85       	ldd	r24, Z+8	; 0x08
    3022:	88 23       	and	r24, r24
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    3024:	61 f0       	breq	.+24     	; 0x303e <protocol_execute_realtime+0x172>
    3026:	8a 81       	ldd	r24, Y+2	; 0x02
    3028:	81 fd       	sbrc	r24, 1
                // NOTE: Laser mode will honor this delay. An exhaust system is often controlled by this pin.
                coolant_set_state((restore_condition & (PL_COND_FLAG_COOLANT_FLOOD | PL_COND_FLAG_COOLANT_MIST)));
    302a:	4b c0       	rjmp	.+150    	; 0x30c2 <protocol_execute_realtime+0x1f6>
    302c:	8d 2d       	mov	r24, r13
    302e:	c5 db       	rcall	.-2166   	; 0x27ba <coolant_set_state>
                delay_sec(SAFETY_DOOR_COOLANT_DELAY, DELAY_MODE_SYS_SUSPEND);
    3030:	47 2d       	mov	r20, r7
    3032:	60 e0       	ldi	r22, 0x00	; 0
    3034:	70 e0       	ldi	r23, 0x00	; 0
    3036:	80 e8       	ldi	r24, 0x80	; 128
    3038:	9f e3       	ldi	r25, 0x3F	; 63
    303a:	0e 94 f5 2e 	call	0x5dea	; 0x5dea <delay_sec>
                  mc_parking_motion(restore_target, pl_data);
                }
              }
            #endif

            if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    303e:	8a 81       	ldd	r24, Y+2	; 0x02
    3040:	81 fd       	sbrc	r24, 1
    3042:	3f c0       	rjmp	.+126    	; 0x30c2 <protocol_execute_realtime+0x1f6>
              sys.suspend |= SUSPEND_RESTORE_COMPLETE;
    3044:	80 61       	ori	r24, 0x10	; 16
    3046:	8a 83       	std	Y+2, r24	; 0x02
              system_set_exec_state_flag(EXEC_CYCLE_START); // Set to resume program.
    3048:	82 e0       	ldi	r24, 0x02	; 2
    304a:	0e 94 d0 3b 	call	0x77a0	; 0x77a0 <system_set_exec_state_flag>
    304e:	39 c0       	rjmp	.+114    	; 0x30c2 <protocol_execute_realtime+0x1f6>

      } else {

        // Feed hold manager. Controls spindle stop override states.
        // NOTE: Hold ensured as completed by condition check at the beginning of suspend routine.
        if (sys.spindle_stop_ovr) {
    3050:	9a 85       	ldd	r25, Y+10	; 0x0a
    3052:	99 23       	and	r25, r25
    3054:	61 f1       	breq	.+88     	; 0x30ae <protocol_execute_realtime+0x1e2>
          // Handles beginning of spindle stop
          if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_INITIATE) {
    3056:	91 ff       	sbrs	r25, 1
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    3058:	0d c0       	rjmp	.+26     	; 0x3074 <protocol_execute_realtime+0x1a8>
    305a:	f8 01       	movw	r30, r16
    305c:	81 85       	ldd	r24, Z+9	; 0x09
    305e:	88 23       	and	r24, r24
              spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
    3060:	39 f0       	breq	.+14     	; 0x3070 <protocol_execute_realtime+0x1a4>
    3062:	40 e0       	ldi	r20, 0x00	; 0
    3064:	50 e0       	ldi	r21, 0x00	; 0
    3066:	ba 01       	movw	r22, r20
    3068:	80 e0       	ldi	r24, 0x00	; 0
    306a:	47 db       	rcall	.-2418   	; 0x26fa <spindle_set_state>
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_ENABLED; // Set stop override state to enabled, if de-energized.
    306c:	7a 86       	std	Y+10, r7	; 0x0a
    306e:	29 c0       	rjmp	.+82     	; 0x30c2 <protocol_execute_realtime+0x1f6>
            } else {
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
    3070:	1a 86       	std	Y+10, r1	; 0x0a
    3072:	27 c0       	rjmp	.+78     	; 0x30c2 <protocol_execute_realtime+0x1f6>
            }
          // Handles restoring of spindle state
          } else if (sys.spindle_stop_ovr & (SPINDLE_STOP_OVR_RESTORE | SPINDLE_STOP_OVR_RESTORE_CYCLE)) {
    3074:	9c 70       	andi	r25, 0x0C	; 12
    3076:	29 f1       	breq	.+74     	; 0x30c2 <protocol_execute_realtime+0x1f6>
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    3078:	f8 01       	movw	r30, r16
    307a:	81 85       	ldd	r24, Z+9	; 0x09
    307c:	88 23       	and	r24, r24
    307e:	79 f0       	breq	.+30     	; 0x309e <protocol_execute_realtime+0x1d2>
              report_feedback_message(MESSAGE_SPINDLE_RESTORE);
    3080:	8a e0       	ldi	r24, 0x0A	; 10
    3082:	0e 94 d5 35 	call	0x6baa	; 0x6baa <report_feedback_message>
              if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    3086:	f7 01       	movw	r30, r14
    3088:	80 81       	ld	r24, Z
    308a:	81 ff       	sbrs	r24, 1
                // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    308c:	04 c0       	rjmp	.+8      	; 0x3096 <protocol_execute_realtime+0x1ca>
    308e:	8c 81       	ldd	r24, Y+4	; 0x04
    3090:	88 60       	ori	r24, 0x08	; 8
    3092:	8c 83       	std	Y+4, r24	; 0x04
              } else {
                spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    3094:	04 c0       	rjmp	.+8      	; 0x309e <protocol_execute_realtime+0x1d2>
    3096:	b5 01       	movw	r22, r10
    3098:	a4 01       	movw	r20, r8
    309a:	8c 2d       	mov	r24, r12
    309c:	2e db       	rcall	.-2468   	; 0x26fa <spindle_set_state>
              }
            }
            if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_RESTORE_CYCLE) {
    309e:	8a 85       	ldd	r24, Y+10	; 0x0a
    30a0:	83 ff       	sbrs	r24, 3
              system_set_exec_state_flag(EXEC_CYCLE_START);  // Set to resume program.
    30a2:	03 c0       	rjmp	.+6      	; 0x30aa <protocol_execute_realtime+0x1de>
    30a4:	82 e0       	ldi	r24, 0x02	; 2
    30a6:	0e 94 d0 3b 	call	0x77a0	; 0x77a0 <system_set_exec_state_flag>
            sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
          }
        } else {
          // Handles spindle state during hold. NOTE: Spindle speed overrides may be altered during hold state.
          // NOTE: STEP_CONTROL_UPDATE_SPINDLE_PWM is automatically reset upon resume in step generator.
          if (bit_istrue(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
    30aa:	1a 86       	std	Y+10, r1	; 0x0a
    30ac:	0a c0       	rjmp	.+20     	; 0x30c2 <protocol_execute_realtime+0x1f6>
    30ae:	8c 81       	ldd	r24, Y+4	; 0x04
            spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    30b0:	83 ff       	sbrs	r24, 3
    30b2:	07 c0       	rjmp	.+14     	; 0x30c2 <protocol_execute_realtime+0x1f6>
    30b4:	b5 01       	movw	r22, r10
    30b6:	a4 01       	movw	r20, r8
    30b8:	8c 2d       	mov	r24, r12
            bit_false(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    30ba:	1f db       	rcall	.-2498   	; 0x26fa <spindle_set_state>
    30bc:	8c 81       	ldd	r24, Y+4	; 0x04
    30be:	87 7f       	andi	r24, 0xF7	; 247
      // Sleep is valid for both hold and door states, if the spindle or coolant are on or
      // set to be re-enabled.
      sleep_check();
    #endif

    protocol_exec_rt_system();
    30c0:	8c 83       	std	Y+4, r24	; 0x04
    30c2:	dd dc       	rcall	.-1606   	; 0x2a7e <protocol_exec_rt_system>
    if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) { 
      system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP);
    }
  #endif

  while (sys.suspend) {
    30c4:	9a 81       	ldd	r25, Y+2	; 0x02
    30c6:	91 11       	cpse	r25, r1
    30c8:	50 cf       	rjmp	.-352    	; 0x2f6a <protocol_execute_realtime+0x9e>
    30ca:	07 c0       	rjmp	.+14     	; 0x30da <protocol_execute_realtime+0x20e>
                  spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
                  delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
                }
              }
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
    30cc:	f8 01       	movw	r30, r16
    30ce:	80 85       	ldd	r24, Z+8	; 0x08
    30d0:	81 11       	cpse	r24, r1
    30d2:	f7 cf       	rjmp	.-18     	; 0x30c2 <protocol_execute_realtime+0x1f6>
    30d4:	b4 cf       	rjmp	.-152    	; 0x303e <protocol_execute_realtime+0x172>
                  mc_parking_motion(restore_target, pl_data);
                }
              }
            #endif

            if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    30d6:	8a 81       	ldd	r24, Y+2	; 0x02
    30d8:	b5 cf       	rjmp	.-150    	; 0x3044 <protocol_execute_realtime+0x178>
// limit switches, or the main program.
void protocol_execute_realtime()
{
  protocol_exec_rt_system();
  if (sys.suspend) { protocol_exec_rt_suspend(); }
}
    30da:	df 91       	pop	r29
    30dc:	cf 91       	pop	r28
    30de:	1f 91       	pop	r17
    30e0:	0f 91       	pop	r16
    30e2:	ff 90       	pop	r15
    30e4:	ef 90       	pop	r14
    30e6:	df 90       	pop	r13
    30e8:	cf 90       	pop	r12
    30ea:	bf 90       	pop	r11
    30ec:	af 90       	pop	r10
    30ee:	9f 90       	pop	r9
    30f0:	8f 90       	pop	r8
    30f2:	7f 90       	pop	r7
    30f4:	08 95       	ret

000030f6 <protocol_main_loop>:

/*
  GRBL PRIMARY LOOP:
*/
void protocol_main_loop()
{
    30f6:	df 92       	push	r13
    30f8:	ef 92       	push	r14
    30fa:	ff 92       	push	r15
    30fc:	0f 93       	push	r16
    30fe:	1f 93       	push	r17
    3100:	cf 93       	push	r28
    3102:	df 93       	push	r29
  // Perform some machine checks to make sure everything is good to go.
  #ifdef CHECK_LIMITS_AT_INIT
    if (bit_istrue(settings.flags, BITFLAG_HARD_LIMIT_ENABLE)) {
    3104:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    3108:	83 ff       	sbrs	r24, 3
    310a:	0a c0       	rjmp	.+20     	; 0x3120 <protocol_main_loop+0x2a>
      if (limits_get_state()) {
    310c:	0e 94 67 30 	call	0x60ce	; 0x60ce <limits_get_state>
    3110:	88 23       	and	r24, r24
    3112:	31 f0       	breq	.+12     	; 0x3120 <protocol_main_loop+0x2a>
        sys.state = STATE_ALARM; // Ensure alarm state is active.
    3114:	81 e0       	ldi	r24, 0x01	; 1
    3116:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
        report_feedback_message(MESSAGE_CHECK_LIMITS);
    311a:	87 e0       	ldi	r24, 0x07	; 7
    311c:	0e 94 d5 35 	call	0x6baa	; 0x6baa <report_feedback_message>
    }
  #endif
  // Check for and report alarm state after a reset, error, or an initial power up.
  // NOTE: Sleep mode disables the stepper drivers and position can't be guaranteed.
  // Re-initialize the sleep state as an ALARM mode to ensure user homes or acknowledges.
  if (sys.state & (STATE_ALARM | STATE_SLEEP)) {
    3120:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    3124:	81 78       	andi	r24, 0x81	; 129
    3126:	71 f0       	breq	.+28     	; 0x3144 <protocol_main_loop+0x4e>
    report_feedback_message(MESSAGE_ALARM_LOCK);
    3128:	82 e0       	ldi	r24, 0x02	; 2
    312a:	0e 94 d5 35 	call	0x6baa	; 0x6baa <report_feedback_message>
    sys.state = STATE_ALARM; // Ensure alarm state is set.
    312e:	81 e0       	ldi	r24, 0x01	; 1
    3130:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
          } else if (c == '(') {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            line_flags |= LINE_FLAG_COMMENT_PARENTHESES;
    3134:	f1 2c       	mov	r15, r1
    3136:	e1 2c       	mov	r14, r1
    // this indicates that g-code streaming has either filled the planner buffer or has
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();

    protocol_execute_realtime();  // Runtime command check point.
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    3138:	ce e1       	ldi	r28, 0x1E	; 30
    313a:	dc e0       	ldi	r29, 0x0C	; 12

        // Direct and execute one line of formatted input, and report status of execution.
        if (line_flags & LINE_FLAG_OVERFLOW) {
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
        } else if (line[0] == 0) {
    313c:	08 e0       	ldi	r16, 0x08	; 8
    313e:	12 e0       	ldi	r17, 0x02	; 2
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    3140:	d1 2c       	mov	r13, r1
    3142:	7b c0       	rjmp	.+246    	; 0x323a <protocol_main_loop+0x144>
  if (sys.state & (STATE_ALARM | STATE_SLEEP)) {
    report_feedback_message(MESSAGE_ALARM_LOCK);
    sys.state = STATE_ALARM; // Ensure alarm state is set.
  } else {
    // Check if the safety door is open.
    sys.state = STATE_IDLE;
    3144:	10 92 1e 0c 	sts	0x0C1E, r1	; 0x800c1e <sys>
    if (system_check_safety_door_ajar()) {
    3148:	0e 94 0d 3b 	call	0x761a	; 0x761a <system_check_safety_door_ajar>
    314c:	88 23       	and	r24, r24
    314e:	31 f0       	breq	.+12     	; 0x315c <protocol_main_loop+0x66>
      bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
    3150:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    3154:	80 62       	ori	r24, 0x20	; 32
    3156:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <sys_rt_exec_state>
      protocol_execute_realtime(); // Enter safety door mode. Should return as IDLE state.
    315a:	b8 de       	rcall	.-656    	; 0x2ecc <protocol_execute_realtime>
    }
    // All systems go!
    system_execute_startup(line); // Execute startup script.
    315c:	88 e0       	ldi	r24, 0x08	; 8
    315e:	92 e0       	ldi	r25, 0x02	; 2
    3160:	0e 94 10 3b 	call	0x7620	; 0x7620 <system_execute_startup>
    3164:	e7 cf       	rjmp	.-50     	; 0x3134 <protocol_main_loop+0x3e>
  for (;;) {

    // Process one line of incoming serial data, as the data becomes available. Performs an
    // initial filtering by removing spaces and comments and capitalizing all letters.
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
    3166:	8a 30       	cpi	r24, 0x0A	; 10
    3168:	11 f0       	breq	.+4      	; 0x316e <protocol_main_loop+0x78>
    316a:	8d 30       	cpi	r24, 0x0D	; 13

        protocol_execute_realtime(); // Runtime command check point.
    316c:	b1 f5       	brne	.+108    	; 0x31da <protocol_main_loop+0xe4>
    316e:	ae de       	rcall	.-676    	; 0x2ecc <protocol_execute_realtime>
        if (sys.abort) { return; } // Bail to calling function upon system abort
    3170:	89 81       	ldd	r24, Y+1	; 0x01
    3172:	81 11       	cpse	r24, r1
    3174:	6b c0       	rjmp	.+214    	; 0x324c <protocol_main_loop+0x156>

        line[char_counter] = 0; // Set string termination character.
    3176:	ef 2d       	mov	r30, r15
    3178:	f0 e0       	ldi	r31, 0x00	; 0
    317a:	e8 5f       	subi	r30, 0xF8	; 248
    317c:	fd 4f       	sbci	r31, 0xFD	; 253
    317e:	10 82       	st	Z, r1
        #ifdef REPORT_ECHO_LINE_RECEIVED
          report_echo_line_received(line);
        #endif

        // Direct and execute one line of formatted input, and report status of execution.
        if (line_flags & LINE_FLAG_OVERFLOW) {
    3180:	e0 fe       	sbrs	r14, 0
    3182:	06 c0       	rjmp	.+12     	; 0x3190 <protocol_main_loop+0x9a>
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
    3184:	8b e0       	ldi	r24, 0x0B	; 11
    3186:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    318a:	fd 2c       	mov	r15, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    318c:	e1 2c       	mov	r14, r1
    318e:	55 c0       	rjmp	.+170    	; 0x323a <protocol_main_loop+0x144>

        // Direct and execute one line of formatted input, and report status of execution.
        if (line_flags & LINE_FLAG_OVERFLOW) {
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
        } else if (line[0] == 0) {
    3190:	f8 01       	movw	r30, r16
    3192:	80 81       	ld	r24, Z
    3194:	81 11       	cpse	r24, r1
    3196:	06 c0       	rjmp	.+12     	; 0x31a4 <protocol_main_loop+0xae>
          // Empty or comment line. For syncing purposes.
          report_status_message(STATUS_OK);
    3198:	8d 2d       	mov	r24, r13
    319a:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    319e:	fd 2c       	mov	r15, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    31a0:	e1 2c       	mov	r14, r1
    31a2:	4b c0       	rjmp	.+150    	; 0x323a <protocol_main_loop+0x144>
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
        } else if (line[0] == 0) {
          // Empty or comment line. For syncing purposes.
          report_status_message(STATUS_OK);
        } else if (line[0] == '$') {
    31a4:	84 32       	cpi	r24, 0x24	; 36
    31a6:	41 f4       	brne	.+16     	; 0x31b8 <protocol_main_loop+0xc2>
          // Grbl '$' system command
          report_status_message(system_execute_line(line));
    31a8:	c8 01       	movw	r24, r16
    31aa:	0e 94 d9 3b 	call	0x77b2	; 0x77b2 <system_execute_line>
    31ae:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    31b2:	fd 2c       	mov	r15, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    31b4:	e1 2c       	mov	r14, r1
    31b6:	41 c0       	rjmp	.+130    	; 0x323a <protocol_main_loop+0x144>
          // Empty or comment line. For syncing purposes.
          report_status_message(STATUS_OK);
        } else if (line[0] == '$') {
          // Grbl '$' system command
          report_status_message(system_execute_line(line));
        } else if (sys.state & (STATE_ALARM | STATE_JOG)) {
    31b8:	88 81       	ld	r24, Y
    31ba:	81 72       	andi	r24, 0x21	; 33
    31bc:	31 f0       	breq	.+12     	; 0x31ca <protocol_main_loop+0xd4>
          // Everything else is gcode. Block if in alarm or jog mode.
          report_status_message(STATUS_SYSTEM_GC_LOCK);
    31be:	89 e0       	ldi	r24, 0x09	; 9
    31c0:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    31c4:	fd 2c       	mov	r15, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    31c6:	e1 2c       	mov	r14, r1
    31c8:	38 c0       	rjmp	.+112    	; 0x323a <protocol_main_loop+0x144>
        } else if (sys.state & (STATE_ALARM | STATE_JOG)) {
          // Everything else is gcode. Block if in alarm or jog mode.
          report_status_message(STATUS_SYSTEM_GC_LOCK);
        } else {
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
    31ca:	c8 01       	movw	r24, r16
    31cc:	0e 94 6c 07 	call	0xed8	; 0xed8 <gc_execute_line>
    31d0:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <report_status_message>
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    31d4:	fd 2c       	mov	r15, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    31d6:	e1 2c       	mov	r14, r1
    31d8:	30 c0       	rjmp	.+96     	; 0x323a <protocol_main_loop+0x144>
        char_counter = 0;

      } else {

        if (line_flags) {
    31da:	ee 20       	and	r14, r14
    31dc:	31 f0       	breq	.+12     	; 0x31ea <protocol_main_loop+0xf4>
          // Throw away all (except EOL) comment characters and overflow characters.
          if (c == ')') {
    31de:	89 32       	cpi	r24, 0x29	; 41
    31e0:	61 f5       	brne	.+88     	; 0x323a <protocol_main_loop+0x144>
            // End of '()' comment. Resume line allowed.
            if (line_flags & LINE_FLAG_COMMENT_PARENTHESES) { line_flags &= ~(LINE_FLAG_COMMENT_PARENTHESES); }
    31e2:	fe 2d       	mov	r31, r14
    31e4:	fd 7f       	andi	r31, 0xFD	; 253
    31e6:	ef 2e       	mov	r14, r31
    31e8:	28 c0       	rjmp	.+80     	; 0x323a <protocol_main_loop+0x144>
          }
        } else {
          if (c <= ' ') {
    31ea:	81 32       	cpi	r24, 0x21	; 33
    31ec:	30 f1       	brcs	.+76     	; 0x323a <protocol_main_loop+0x144>
            // Throw away whitepace and control characters
          } else if (c == '/') {
    31ee:	8f 32       	cpi	r24, 0x2F	; 47
    31f0:	21 f1       	breq	.+72     	; 0x323a <protocol_main_loop+0x144>
            // Block delete NOT SUPPORTED. Ignore character.
            // NOTE: If supported, would simply need to check the system if block delete is enabled.
          } else if (c == '(') {
    31f2:	88 32       	cpi	r24, 0x28	; 40
    31f4:	c1 f0       	breq	.+48     	; 0x3226 <protocol_main_loop+0x130>
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            line_flags |= LINE_FLAG_COMMENT_PARENTHESES;
          } else if (c == ';') {
    31f6:	8b 33       	cpi	r24, 0x3B	; 59
    31f8:	d1 f0       	breq	.+52     	; 0x322e <protocol_main_loop+0x138>
            // Program start-end percent sign NOT SUPPORTED.
            // NOTE: This maybe installed to tell Grbl when a program is running vs manual input,
            // where, during a program, the system auto-cycle start will continue to execute
            // everything until the next '%' sign. This will help fix resuming issues with certain
            // functions that empty the planner buffer to execute its task on-time.
          } else if (char_counter >= (LINE_BUFFER_SIZE-1)) {
    31fa:	9f ef       	ldi	r25, 0xFF	; 255
    31fc:	f9 16       	cp	r15, r25
    31fe:	d9 f0       	breq	.+54     	; 0x3236 <protocol_main_loop+0x140>
            // Detect line buffer overflow and set flag.
            line_flags |= LINE_FLAG_OVERFLOW;
          } else if (c >= 'a' && c <= 'z') { // Upcase lowercase
    3200:	9f e9       	ldi	r25, 0x9F	; 159
    3202:	98 0f       	add	r25, r24
    3204:	9a 31       	cpi	r25, 0x1A	; 26
    3206:	40 f4       	brcc	.+16     	; 0x3218 <protocol_main_loop+0x122>
            line[char_counter++] = c-'a'+'A';
    3208:	ef 2d       	mov	r30, r15
    320a:	f0 e0       	ldi	r31, 0x00	; 0
    320c:	e8 5f       	subi	r30, 0xF8	; 248
    320e:	fd 4f       	sbci	r31, 0xFD	; 253
    3210:	80 52       	subi	r24, 0x20	; 32
    3212:	80 83       	st	Z, r24
    3214:	f3 94       	inc	r15
    3216:	11 c0       	rjmp	.+34     	; 0x323a <protocol_main_loop+0x144>
          } else {
            line[char_counter++] = c;
    3218:	ef 2d       	mov	r30, r15
    321a:	f0 e0       	ldi	r31, 0x00	; 0
    321c:	e8 5f       	subi	r30, 0xF8	; 248
    321e:	fd 4f       	sbci	r31, 0xFD	; 253
    3220:	80 83       	st	Z, r24
    3222:	f3 94       	inc	r15
    3224:	0a c0       	rjmp	.+20     	; 0x323a <protocol_main_loop+0x144>
          } else if (c == '(') {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            line_flags |= LINE_FLAG_COMMENT_PARENTHESES;
    3226:	68 94       	set
    3228:	ee 24       	eor	r14, r14
    322a:	e1 f8       	bld	r14, 1
    322c:	06 c0       	rjmp	.+12     	; 0x323a <protocol_main_loop+0x144>
          } else if (c == ';') {
            // NOTE: ';' comment to EOL is a LinuxCNC definition. Not NIST.
            line_flags |= LINE_FLAG_COMMENT_SEMICOLON;
    322e:	68 94       	set
    3230:	ee 24       	eor	r14, r14
    3232:	e2 f8       	bld	r14, 2
    3234:	02 c0       	rjmp	.+4      	; 0x323a <protocol_main_loop+0x144>
            // where, during a program, the system auto-cycle start will continue to execute
            // everything until the next '%' sign. This will help fix resuming issues with certain
            // functions that empty the planner buffer to execute its task on-time.
          } else if (char_counter >= (LINE_BUFFER_SIZE-1)) {
            // Detect line buffer overflow and set flag.
            line_flags |= LINE_FLAG_OVERFLOW;
    3236:	ee 24       	eor	r14, r14
  uint8_t c;
  for (;;) {

    // Process one line of incoming serial data, as the data becomes available. Performs an
    // initial filtering by removing spaces and comments and capitalizing all letters.
    while((c = serial_read()) != SERIAL_NO_DATA) {
    3238:	e3 94       	inc	r14
    323a:	4c db       	rcall	.-2408   	; 0x28d4 <serial_read>
    323c:	8f 3f       	cpi	r24, 0xFF	; 255
    }

    // If there are no more characters in the serial read buffer to be processed and executed,
    // this indicates that g-code streaming has either filled the planner buffer or has
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();
    323e:	09 f0       	breq	.+2      	; 0x3242 <protocol_main_loop+0x14c>
    3240:	92 cf       	rjmp	.-220    	; 0x3166 <protocol_main_loop+0x70>

    protocol_execute_realtime();  // Runtime command check point.
    3242:	15 dc       	rcall	.-2006   	; 0x2a6e <protocol_auto_cycle_start>
    3244:	43 de       	rcall	.-890    	; 0x2ecc <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    3246:	89 81       	ldd	r24, Y+1	; 0x01
    3248:	88 23       	and	r24, r24
    324a:	b9 f3       	breq	.-18     	; 0x323a <protocol_main_loop+0x144>
      sleep_check();    
    #endif
  }

  return; /* Never reached */
}
    324c:	df 91       	pop	r29
    324e:	cf 91       	pop	r28
    3250:	1f 91       	pop	r17
    3252:	0f 91       	pop	r16
    3254:	ff 90       	pop	r15
    3256:	ef 90       	pop	r14
    3258:	df 90       	pop	r13
    325a:	08 95       	ret

0000325c <protocol_buffer_synchronize>:


// Block until all buffered steps are executed or in a cycle state. Works with feed hold
// during a synchronize call, if it should happen. Also, waits for clean cycle end.
void protocol_buffer_synchronize()
{
    325c:	cf 93       	push	r28
    325e:	df 93       	push	r29
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
    3260:	06 dc       	rcall	.-2036   	; 0x2a6e <protocol_auto_cycle_start>
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    if (sys.abort) { return; } // Check for system abort
    3262:	ce e1       	ldi	r28, 0x1E	; 30
void protocol_buffer_synchronize()
{
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    3264:	dc e0       	ldi	r29, 0x0C	; 12
    3266:	32 de       	rcall	.-924    	; 0x2ecc <protocol_execute_realtime>
    if (sys.abort) { return; } // Check for system abort
    3268:	89 81       	ldd	r24, Y+1	; 0x01
    326a:	81 11       	cpse	r24, r1
    326c:	07 c0       	rjmp	.+14     	; 0x327c <protocol_buffer_synchronize+0x20>
  } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
    326e:	0e 94 87 29 	call	0x530e	; 0x530e <plan_get_current_block>
    3272:	89 2b       	or	r24, r25
    3274:	c1 f7       	brne	.-16     	; 0x3266 <protocol_buffer_synchronize+0xa>
    3276:	88 81       	ld	r24, Y
    3278:	88 30       	cpi	r24, 0x08	; 8
    327a:	a9 f3       	breq	.-22     	; 0x3266 <protocol_buffer_synchronize+0xa>
}
    327c:	df 91       	pop	r29
    327e:	cf 91       	pop	r28
    3280:	08 95       	ret

00003282 <st_wake_up>:
    // Initialize stepper output bits to ensure first ISR call does not step.
    for (idx = 0; idx < N_AXIS; idx++) {
      st.step_outbits[idx] = step_port_invert_mask[idx];
    }
  #else
    if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    3282:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    3286:	82 ff       	sbrs	r24, 2
    3288:	02 c0       	rjmp	.+4      	; 0x328e <st_wake_up+0xc>
    328a:	2f 9a       	sbi	0x05, 7	; 5
    328c:	01 c0       	rjmp	.+2      	; 0x3290 <st_wake_up+0xe>
    else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    328e:	2f 98       	cbi	0x05, 7	; 5
    // Initialize stepper output bits to ensure first ISR call does not step.
    st.step_outbits = step_port_invert_mask;
    3290:	e3 e4       	ldi	r30, 0x43	; 67
    3292:	f3 e0       	ldi	r31, 0x03	; 3
    3294:	80 91 3f 03 	lds	r24, 0x033F	; 0x80033f <step_port_invert_mask>
    3298:	86 87       	std	Z+14, r24	; 0x0e
    st.step_pulse_time = -(((settings.pulse_microseconds+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND) >> 3);
    // Set delay between direction pin write and step command.
    OCR0A = -(((settings.pulse_microseconds)*TICKS_PER_MICROSECOND) >> 3);
  #else // Normal operation
    // Set step pulse time. Ad hoc computation from oscilloscope. Uses two's complement.
    st.step_pulse_time = -(((settings.pulse_microseconds-2)*TICKS_PER_MICROSECOND) >> 3);
    329a:	80 91 00 0f 	lds	r24, 0x0F00	; 0x800f00 <settings+0x30>
    329e:	88 0f       	add	r24, r24
    32a0:	84 50       	subi	r24, 0x04	; 4
    32a2:	81 95       	neg	r24
    32a4:	85 87       	std	Z+13, r24	; 0x0d
  #endif

  // Enable Stepper Driver Interrupt
  TIMSK1 |= (1<<OCIE1A);
    32a6:	ef e6       	ldi	r30, 0x6F	; 111
    32a8:	f0 e0       	ldi	r31, 0x00	; 0
    32aa:	80 81       	ld	r24, Z
    32ac:	82 60       	ori	r24, 0x02	; 2
    32ae:	80 83       	st	Z, r24
    32b0:	08 95       	ret

000032b2 <st_go_idle>:

// Stepper shutdown
void st_go_idle()
{
  // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.
  TIMSK1 &= ~(1<<OCIE1A); // Disable Timer1 interrupt
    32b2:	ef e6       	ldi	r30, 0x6F	; 111
    32b4:	f0 e0       	ldi	r31, 0x00	; 0
    32b6:	80 81       	ld	r24, Z
    32b8:	8d 7f       	andi	r24, 0xFD	; 253
    32ba:	80 83       	st	Z, r24
  TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Reset clock to no prescaling.
    32bc:	e1 e8       	ldi	r30, 0x81	; 129
    32be:	f0 e0       	ldi	r31, 0x00	; 0
    32c0:	80 81       	ld	r24, Z
    32c2:	88 7f       	andi	r24, 0xF8	; 248
    32c4:	81 60       	ori	r24, 0x01	; 1
    32c6:	80 83       	st	Z, r24
  busy = false;
    32c8:	10 92 3d 03 	sts	0x033D, r1	; 0x80033d <busy>

  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
  if (((settings.stepper_idle_lock_time != 0xff) || sys_rt_exec_alarm || sys.state == STATE_SLEEP) && sys.state != STATE_HOMING) {
    32cc:	80 91 03 0f 	lds	r24, 0x0F03	; 0x800f03 <settings+0x33>
    32d0:	8f 3f       	cpi	r24, 0xFF	; 255
    32d2:	49 f4       	brne	.+18     	; 0x32e6 <st_go_idle+0x34>
    32d4:	90 91 53 0c 	lds	r25, 0x0C53	; 0x800c53 <sys_rt_exec_alarm>
    32d8:	91 11       	cpse	r25, r1
    32da:	05 c0       	rjmp	.+10     	; 0x32e6 <st_go_idle+0x34>
    32dc:	90 91 1e 0c 	lds	r25, 0x0C1E	; 0x800c1e <sys>
    32e0:	90 38       	cpi	r25, 0x80	; 128
    32e2:	81 f4       	brne	.+32     	; 0x3304 <st_go_idle+0x52>
    32e4:	04 c0       	rjmp	.+8      	; 0x32ee <st_go_idle+0x3c>
    32e6:	90 91 1e 0c 	lds	r25, 0x0C1E	; 0x800c1e <sys>
    32ea:	94 30       	cpi	r25, 0x04	; 4
    32ec:	59 f0       	breq	.+22     	; 0x3304 <st_go_idle+0x52>
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    32ee:	90 e0       	ldi	r25, 0x00	; 0
    32f0:	0e 94 32 2f 	call	0x5e64	; 0x5e64 <delay_ms>
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    32f4:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    32f8:	82 fd       	sbrc	r24, 2
    32fa:	02 c0       	rjmp	.+4      	; 0x3300 <st_go_idle+0x4e>
      STEPPER_DISABLE_PORT(0) &= ~(1 << STEPPER_DISABLE_BIT(0));
      STEPPER_DISABLE_PORT(1) &= ~(1 << STEPPER_DISABLE_BIT(1));
      STEPPER_DISABLE_PORT(2) &= ~(1 << STEPPER_DISABLE_BIT(2));
    }
  #else
    if (pin_state) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    32fc:	2f 9a       	sbi	0x05, 7	; 5
    32fe:	08 95       	ret
    else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    3300:	2f 98       	cbi	0x05, 7	; 5
  #endif // Ramps Board
}
    3302:	08 95       	ret
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    3304:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    3308:	82 ff       	sbrs	r24, 2
    330a:	fa cf       	rjmp	.-12     	; 0x3300 <st_go_idle+0x4e>
    330c:	f7 cf       	rjmp	.-18     	; 0x32fc <st_go_idle+0x4a>

0000330e <__vector_17>:
*/
// TODO: Replace direct updating of the int32 position counters in the ISR somehow. Perhaps use smaller
// int8 variables and update position counters only when a segment completes. This can get complicated
// with probing and homing cycles that require true real-time positions.
ISR(TIMER1_COMPA_vect)
{
    330e:	1f 92       	push	r1
    3310:	0f 92       	push	r0
    3312:	0f b6       	in	r0, 0x3f	; 63
    3314:	0f 92       	push	r0
    3316:	11 24       	eor	r1, r1
    3318:	0b b6       	in	r0, 0x3b	; 59
    331a:	0f 92       	push	r0
    331c:	2f 93       	push	r18
    331e:	3f 93       	push	r19
    3320:	4f 93       	push	r20
    3322:	5f 93       	push	r21
    3324:	6f 93       	push	r22
    3326:	7f 93       	push	r23
    3328:	8f 93       	push	r24
    332a:	9f 93       	push	r25
    332c:	af 93       	push	r26
    332e:	bf 93       	push	r27
    3330:	cf 93       	push	r28
    3332:	df 93       	push	r29
    3334:	ef 93       	push	r30
    3336:	ff 93       	push	r31
  #ifdef DEFAULTS_RAMPS_BOARD
    int i;
  #endif // Ramps Board

  if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
    3338:	80 91 3d 03 	lds	r24, 0x033D	; 0x80033d <busy>
    333c:	81 11       	cpse	r24, r1
    333e:	d0 c1       	rjmp	.+928    	; 0x36e0 <__vector_17+0x3d2>
  #ifdef DEFAULTS_RAMPS_BOARD
    DIRECTION_PORT(0) = (DIRECTION_PORT(0) & ~(1 << DIRECTION_BIT(0))) | st.dir_outbits[0];
    DIRECTION_PORT(1) = (DIRECTION_PORT(1) & ~(1 << DIRECTION_BIT(1))) | st.dir_outbits[1];
    DIRECTION_PORT(2) = (DIRECTION_PORT(2) & ~(1 << DIRECTION_BIT(2))) | st.dir_outbits[2];
  #else
    DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK);
    3340:	88 b1       	in	r24, 0x08	; 8
    3342:	e3 e4       	ldi	r30, 0x43	; 67
    3344:	f3 e0       	ldi	r31, 0x03	; 3
    3346:	97 85       	ldd	r25, Z+15	; 0x0f
    3348:	90 7e       	andi	r25, 0xE0	; 224
    334a:	8f 71       	andi	r24, 0x1F	; 31
    334c:	89 2b       	or	r24, r25
    334e:	88 b9       	out	0x08, r24	; 8
    #endif
  #else  
    #ifdef STEP_PULSE_DELAY
      st.step_bits = (STEP_PORT & ~STEP_MASK) | st.step_outbits; // Store out_bits to prevent overwriting.
    #else  // Normal operation
      STEP_PORT = (STEP_PORT & ~STEP_MASK) | st.step_outbits;
    3350:	82 b1       	in	r24, 0x02	; 2
    3352:	83 7e       	andi	r24, 0xE3	; 227
    3354:	96 85       	ldd	r25, Z+14	; 0x0e
    3356:	89 2b       	or	r24, r25
    3358:	82 b9       	out	0x02, r24	; 2
    #endif
  #endif // Ramps Board

  // Enable step pulse reset timer so that The Stepper Port Reset Interrupt can reset the signal after
  // exactly settings.pulse_microseconds microseconds, independent of the main Timer1 prescaler.
  TCNT0 = st.step_pulse_time; // Reload Timer0 counter
    335a:	85 85       	ldd	r24, Z+13	; 0x0d
    335c:	86 bd       	out	0x26, r24	; 38
  TCCR0B = (1<<CS01); // Begin Timer0. Full speed, 1/8 prescaler
    335e:	82 e0       	ldi	r24, 0x02	; 2
    3360:	85 bd       	out	0x25, r24	; 37

  busy = true;
    3362:	81 e0       	ldi	r24, 0x01	; 1
    3364:	80 93 3d 03 	sts	0x033D, r24	; 0x80033d <busy>
  sei(); // Re-enable interrupts to allow Stepper Port Reset Interrupt to fire on-time.
    3368:	78 94       	sei
         // NOTE: The remaining code in this ISR will finish before returning to main program.

  // If there is no step segment, attempt to pop one from the stepper buffer
  if (st.exec_segment == NULL) {
    336a:	81 a1       	ldd	r24, Z+33	; 0x21
    336c:	92 a1       	ldd	r25, Z+34	; 0x22
    336e:	89 2b       	or	r24, r25
    3370:	09 f0       	breq	.+2      	; 0x3374 <__vector_17+0x66>
    3372:	a9 c0       	rjmp	.+338    	; 0x34c6 <__vector_17+0x1b8>
    // Anything in the buffer? If so, load and initialize next step segment.
    if (segment_buffer_head != segment_buffer_tail) {
    3374:	80 91 42 03 	lds	r24, 0x0342	; 0x800342 <segment_buffer_tail>
    3378:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <segment_buffer_head>
    337c:	98 17       	cp	r25, r24
    337e:	09 f4       	brne	.+2      	; 0x3382 <__vector_17+0x74>
    3380:	93 c0       	rjmp	.+294    	; 0x34a8 <__vector_17+0x19a>
      // Initialize new step segment and load number of steps to execute
      st.exec_segment = &segment_buffer[segment_buffer_tail];
    3382:	e0 91 42 03 	lds	r30, 0x0342	; 0x800342 <segment_buffer_tail>
    3386:	f0 e0       	ldi	r31, 0x00	; 0
    3388:	a3 e4       	ldi	r26, 0x43	; 67
    338a:	b3 e0       	ldi	r27, 0x03	; 3
    338c:	ee 0f       	add	r30, r30
    338e:	ff 1f       	adc	r31, r31
    3390:	ee 0f       	add	r30, r30
    3392:	ff 1f       	adc	r31, r31
    3394:	ee 0f       	add	r30, r30
    3396:	ff 1f       	adc	r31, r31
    3398:	ea 59       	subi	r30, 0x9A	; 154
    339a:	fc 4f       	sbci	r31, 0xFC	; 252
    339c:	92 96       	adiw	r26, 0x22	; 34
    339e:	fc 93       	st	X, r31
    33a0:	ee 93       	st	-X, r30
    33a2:	91 97       	sbiw	r26, 0x21	; 33
        // With AMASS is disabled, set timer prescaler for segments with slow step frequencies (< 250Hz).
        TCCR1B = (TCCR1B & ~(0x07<<CS10)) | (st.exec_segment->prescaler<<CS10);
      #endif

      // Initialize step segment timing per step and load number of steps to execute.
      OCR1A = st.exec_segment->cycles_per_tick;
    33a4:	82 81       	ldd	r24, Z+2	; 0x02
    33a6:	93 81       	ldd	r25, Z+3	; 0x03
    33a8:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    33ac:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
      st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
    33b0:	80 81       	ld	r24, Z
    33b2:	91 81       	ldd	r25, Z+1	; 0x01
    33b4:	5d 96       	adiw	r26, 0x1d	; 29
    33b6:	9c 93       	st	X, r25
    33b8:	8e 93       	st	-X, r24
    33ba:	5c 97       	sbiw	r26, 0x1c	; 28
      // If the new segment starts a new planner block, initialize stepper variables and counters.
      // NOTE: When the segment data index changes, this indicates a new planner block.
      if ( st.exec_block_index != st.exec_segment->st_block_index ) {
    33bc:	84 81       	ldd	r24, Z+4	; 0x04
    33be:	5e 96       	adiw	r26, 0x1e	; 30
    33c0:	9c 91       	ld	r25, X
    33c2:	5e 97       	sbiw	r26, 0x1e	; 30
    33c4:	98 17       	cp	r25, r24
    33c6:	49 f1       	breq	.+82     	; 0x341a <__vector_17+0x10c>
        st.exec_block_index = st.exec_segment->st_block_index;
    33c8:	ed 01       	movw	r28, r26
    33ca:	8e 8f       	std	Y+30, r24	; 0x1e
        st.exec_block = &st_block_buffer[st.exec_block_index];
    33cc:	90 e0       	ldi	r25, 0x00	; 0
    33ce:	88 0f       	add	r24, r24
    33d0:	99 1f       	adc	r25, r25
    33d2:	dc 01       	movw	r26, r24
    33d4:	aa 0f       	add	r26, r26
    33d6:	bb 1f       	adc	r27, r27
    33d8:	aa 0f       	add	r26, r26
    33da:	bb 1f       	adc	r27, r27
    33dc:	aa 0f       	add	r26, r26
    33de:	bb 1f       	adc	r27, r27
    33e0:	8a 0f       	add	r24, r26
    33e2:	9b 1f       	adc	r25, r27
    33e4:	dc 01       	movw	r26, r24
    33e6:	aa 54       	subi	r26, 0x4A	; 74
    33e8:	bc 4f       	sbci	r27, 0xFC	; 252
    33ea:	b8 a3       	std	Y+32, r27	; 0x20
    33ec:	af 8f       	std	Y+31, r26	; 0x1f

        // Initialize Bresenham line and distance counters
        st.counter_x = st.counter_y = st.counter_z = (st.exec_block->step_event_count >> 1);
    33ee:	1c 96       	adiw	r26, 0x0c	; 12
    33f0:	8d 91       	ld	r24, X+
    33f2:	9d 91       	ld	r25, X+
    33f4:	0d 90       	ld	r0, X+
    33f6:	bc 91       	ld	r27, X
    33f8:	a0 2d       	mov	r26, r0
    33fa:	b6 95       	lsr	r27
    33fc:	a7 95       	ror	r26
    33fe:	97 95       	ror	r25
    3400:	87 95       	ror	r24
    3402:	88 87       	std	Y+8, r24	; 0x08
    3404:	99 87       	std	Y+9, r25	; 0x09
    3406:	aa 87       	std	Y+10, r26	; 0x0a
    3408:	bb 87       	std	Y+11, r27	; 0x0b
    340a:	8c 83       	std	Y+4, r24	; 0x04
    340c:	9d 83       	std	Y+5, r25	; 0x05
    340e:	ae 83       	std	Y+6, r26	; 0x06
    3410:	bf 83       	std	Y+7, r27	; 0x07
    3412:	88 83       	st	Y, r24
    3414:	99 83       	std	Y+1, r25	; 0x01
    3416:	aa 83       	std	Y+2, r26	; 0x02
    3418:	bb 83       	std	Y+3, r27	; 0x03
      }
      #ifdef DEFAULTS_RAMPS_BOARD
        for (i = 0; i < N_AXIS; i++)
          st.dir_outbits[i] = st.exec_block->direction_bits[i] ^ dir_port_invert_mask[i];
      #else
        st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask;
    341a:	a3 e4       	ldi	r26, 0x43	; 67
    341c:	b3 e0       	ldi	r27, 0x03	; 3
    341e:	5f 96       	adiw	r26, 0x1f	; 31
    3420:	cd 91       	ld	r28, X+
    3422:	dc 91       	ld	r29, X
    3424:	90 97       	sbiw	r26, 0x20	; 32
    3426:	98 89       	ldd	r25, Y+16	; 0x10
    3428:	80 91 3e 03 	lds	r24, 0x033E	; 0x80033e <dir_port_invert_mask>
    342c:	89 27       	eor	r24, r25
    342e:	1f 96       	adiw	r26, 0x0f	; 15
    3430:	8c 93       	st	X, r24
    3432:	1f 97       	sbiw	r26, 0x0f	; 15
      #endif // Ramps Board

      #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
        // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
        st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.exec_segment->amass_level;
    3434:	48 81       	ld	r20, Y
    3436:	59 81       	ldd	r21, Y+1	; 0x01
    3438:	6a 81       	ldd	r22, Y+2	; 0x02
    343a:	7b 81       	ldd	r23, Y+3	; 0x03
    343c:	05 80       	ldd	r0, Z+5	; 0x05
    343e:	04 c0       	rjmp	.+8      	; 0x3448 <__vector_17+0x13a>
    3440:	76 95       	lsr	r23
    3442:	67 95       	ror	r22
    3444:	57 95       	ror	r21
    3446:	47 95       	ror	r20
    3448:	0a 94       	dec	r0
    344a:	d2 f7       	brpl	.-12     	; 0x3440 <__vector_17+0x132>
    344c:	50 96       	adiw	r26, 0x10	; 16
    344e:	4d 93       	st	X+, r20
    3450:	5d 93       	st	X+, r21
    3452:	6d 93       	st	X+, r22
    3454:	7c 93       	st	X, r23
    3456:	53 97       	sbiw	r26, 0x13	; 19
        st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.exec_segment->amass_level;
    3458:	4c 81       	ldd	r20, Y+4	; 0x04
    345a:	5d 81       	ldd	r21, Y+5	; 0x05
    345c:	6e 81       	ldd	r22, Y+6	; 0x06
    345e:	7f 81       	ldd	r23, Y+7	; 0x07
    3460:	05 80       	ldd	r0, Z+5	; 0x05
    3462:	04 c0       	rjmp	.+8      	; 0x346c <__vector_17+0x15e>
    3464:	76 95       	lsr	r23
    3466:	67 95       	ror	r22
    3468:	57 95       	ror	r21
    346a:	47 95       	ror	r20
    346c:	0a 94       	dec	r0
    346e:	d2 f7       	brpl	.-12     	; 0x3464 <__vector_17+0x156>
    3470:	54 96       	adiw	r26, 0x14	; 20
    3472:	4d 93       	st	X+, r20
    3474:	5d 93       	st	X+, r21
    3476:	6d 93       	st	X+, r22
    3478:	7c 93       	st	X, r23
    347a:	57 97       	sbiw	r26, 0x17	; 23
        st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
    347c:	48 85       	ldd	r20, Y+8	; 0x08
    347e:	59 85       	ldd	r21, Y+9	; 0x09
    3480:	6a 85       	ldd	r22, Y+10	; 0x0a
    3482:	7b 85       	ldd	r23, Y+11	; 0x0b
    3484:	05 80       	ldd	r0, Z+5	; 0x05
    3486:	04 c0       	rjmp	.+8      	; 0x3490 <__vector_17+0x182>
    3488:	76 95       	lsr	r23
    348a:	67 95       	ror	r22
    348c:	57 95       	ror	r21
    348e:	47 95       	ror	r20
    3490:	0a 94       	dec	r0
    3492:	d2 f7       	brpl	.-12     	; 0x3488 <__vector_17+0x17a>
    3494:	58 96       	adiw	r26, 0x18	; 24
    3496:	4d 93       	st	X+, r20
    3498:	5d 93       	st	X+, r21
    349a:	6d 93       	st	X+, r22
    349c:	7c 93       	st	X, r23
    349e:	5b 97       	sbiw	r26, 0x1b	; 27
      #endif

      // Set real-time spindle output as segment is loaded, just prior to the first step.
      spindle_set_speed(st.exec_segment->spindle_pwm);
    34a0:	86 81       	ldd	r24, Z+6	; 0x06
    34a2:	97 81       	ldd	r25, Z+7	; 0x07
    34a4:	77 d8       	rcall	.-3858   	; 0x2594 <spindle_set_speed>
    34a6:	0f c0       	rjmp	.+30     	; 0x34c6 <__vector_17+0x1b8>

    } else {
      // Segment buffer empty. Shutdown.
      st_go_idle();
    34a8:	04 df       	rcall	.-504    	; 0x32b2 <st_go_idle>
      // Ensure pwm is set properly upon completion of rate-controlled motion.
      if (st.exec_block->is_pwm_rate_adjusted) { spindle_set_speed(SPINDLE_PWM_OFF_VALUE); }
    34aa:	e0 91 62 03 	lds	r30, 0x0362	; 0x800362 <st+0x1f>
    34ae:	f0 91 63 03 	lds	r31, 0x0363	; 0x800363 <st+0x20>
    34b2:	81 89       	ldd	r24, Z+17	; 0x11
    34b4:	88 23       	and	r24, r24
    34b6:	19 f0       	breq	.+6      	; 0x34be <__vector_17+0x1b0>
    34b8:	80 e0       	ldi	r24, 0x00	; 0
    34ba:	90 e0       	ldi	r25, 0x00	; 0
    34bc:	6b d8       	rcall	.-3882   	; 0x2594 <spindle_set_speed>
      system_set_exec_state_flag(EXEC_CYCLE_STOP); // Flag main program for cycle end
    34be:	84 e0       	ldi	r24, 0x04	; 4
    34c0:	0e 94 d0 3b 	call	0x77a0	; 0x77a0 <system_set_exec_state_flag>
      return; // Nothing to do but exit.
    34c4:	0d c1       	rjmp	.+538    	; 0x36e0 <__vector_17+0x3d2>
    }
  }


  // Check probing state.
  if (sys_probe_state == PROBE_ACTIVE) { probe_state_monitor(); }
    34c6:	80 91 32 0c 	lds	r24, 0x0C32	; 0x800c32 <sys_probe_state>
    34ca:	81 30       	cpi	r24, 0x01	; 1
    34cc:	11 f4       	brne	.+4      	; 0x34d2 <__vector_17+0x1c4>
    34ce:	0e 94 03 35 	call	0x6a06	; 0x6a06 <probe_state_monitor>
  // Reset step out bits.
  #ifdef DEFAULTS_RAMPS_BOARD
    for (i = 0; i < N_AXIS; i++)
      st.step_outbits[i] = 0;
  #else
    st.step_outbits = 0;
    34d2:	e3 e4       	ldi	r30, 0x43	; 67
    34d4:	f3 e0       	ldi	r31, 0x03	; 3
    34d6:	16 86       	std	Z+14, r1	; 0x0e
  #endif // Ramps Board

  // Execute step displacement profile by Bresenham line algorithm
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_x += st.steps[X_AXIS];
    34d8:	40 81       	ld	r20, Z
    34da:	51 81       	ldd	r21, Z+1	; 0x01
    34dc:	62 81       	ldd	r22, Z+2	; 0x02
    34de:	73 81       	ldd	r23, Z+3	; 0x03
    34e0:	80 89       	ldd	r24, Z+16	; 0x10
    34e2:	91 89       	ldd	r25, Z+17	; 0x11
    34e4:	a2 89       	ldd	r26, Z+18	; 0x12
    34e6:	b3 89       	ldd	r27, Z+19	; 0x13
    34e8:	84 0f       	add	r24, r20
    34ea:	95 1f       	adc	r25, r21
    34ec:	a6 1f       	adc	r26, r22
    34ee:	b7 1f       	adc	r27, r23
    34f0:	80 83       	st	Z, r24
    34f2:	91 83       	std	Z+1, r25	; 0x01
    34f4:	a2 83       	std	Z+2, r26	; 0x02
    34f6:	b3 83       	std	Z+3, r27	; 0x03
      st.counter_x -= st.exec_block->step_event_count;
      if (st.exec_block->direction_bits[X_AXIS] & (1<<DIRECTION_BIT(X_AXIS))) { sys_position[X_AXIS]--; }
      else { sys_position[X_AXIS]++; }
    }
  #else
    if (st.counter_x > st.exec_block->step_event_count) {
    34f8:	07 8c       	ldd	r0, Z+31	; 0x1f
    34fa:	f0 a1       	ldd	r31, Z+32	; 0x20
    34fc:	e0 2d       	mov	r30, r0
    34fe:	44 85       	ldd	r20, Z+12	; 0x0c
    3500:	55 85       	ldd	r21, Z+13	; 0x0d
    3502:	66 85       	ldd	r22, Z+14	; 0x0e
    3504:	77 85       	ldd	r23, Z+15	; 0x0f
    3506:	48 17       	cp	r20, r24
    3508:	59 07       	cpc	r21, r25
    350a:	6a 07       	cpc	r22, r26
    350c:	7b 07       	cpc	r23, r27
    350e:	70 f5       	brcc	.+92     	; 0x356c <__vector_17+0x25e>
      st.step_outbits |= (1<<X_STEP_BIT);
    3510:	c3 e4       	ldi	r28, 0x43	; 67
    3512:	d3 e0       	ldi	r29, 0x03	; 3
    3514:	24 e0       	ldi	r18, 0x04	; 4
    3516:	2e 87       	std	Y+14, r18	; 0x0e
      st.counter_x -= st.exec_block->step_event_count;
    3518:	44 85       	ldd	r20, Z+12	; 0x0c
    351a:	55 85       	ldd	r21, Z+13	; 0x0d
    351c:	66 85       	ldd	r22, Z+14	; 0x0e
    351e:	77 85       	ldd	r23, Z+15	; 0x0f
    3520:	84 1b       	sub	r24, r20
    3522:	95 0b       	sbc	r25, r21
    3524:	a6 0b       	sbc	r26, r22
    3526:	b7 0b       	sbc	r27, r23
    3528:	88 83       	st	Y, r24
    352a:	99 83       	std	Y+1, r25	; 0x01
    352c:	aa 83       	std	Y+2, r26	; 0x02
    352e:	bb 83       	std	Y+3, r27	; 0x03
      if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys_position[X_AXIS]--; }
    3530:	80 89       	ldd	r24, Z+16	; 0x10
    3532:	88 23       	and	r24, r24
    3534:	74 f4       	brge	.+28     	; 0x3552 <__vector_17+0x244>
    3536:	c3 e4       	ldi	r28, 0x43	; 67
    3538:	dc e0       	ldi	r29, 0x0C	; 12
    353a:	88 81       	ld	r24, Y
    353c:	99 81       	ldd	r25, Y+1	; 0x01
    353e:	aa 81       	ldd	r26, Y+2	; 0x02
    3540:	bb 81       	ldd	r27, Y+3	; 0x03
    3542:	01 97       	sbiw	r24, 0x01	; 1
    3544:	a1 09       	sbc	r26, r1
    3546:	b1 09       	sbc	r27, r1
    3548:	88 83       	st	Y, r24
    354a:	99 83       	std	Y+1, r25	; 0x01
    354c:	aa 83       	std	Y+2, r26	; 0x02
    354e:	bb 83       	std	Y+3, r27	; 0x03
    3550:	0d c0       	rjmp	.+26     	; 0x356c <__vector_17+0x25e>
      else { sys_position[X_AXIS]++; }
    3552:	c3 e4       	ldi	r28, 0x43	; 67
    3554:	dc e0       	ldi	r29, 0x0C	; 12
    3556:	88 81       	ld	r24, Y
    3558:	99 81       	ldd	r25, Y+1	; 0x01
    355a:	aa 81       	ldd	r26, Y+2	; 0x02
    355c:	bb 81       	ldd	r27, Y+3	; 0x03
    355e:	01 96       	adiw	r24, 0x01	; 1
    3560:	a1 1d       	adc	r26, r1
    3562:	b1 1d       	adc	r27, r1
    3564:	88 83       	st	Y, r24
    3566:	99 83       	std	Y+1, r25	; 0x01
    3568:	aa 83       	std	Y+2, r26	; 0x02
    356a:	bb 83       	std	Y+3, r27	; 0x03
    }
  #endif // Ramps Board

  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_y += st.steps[Y_AXIS];
    356c:	c3 e4       	ldi	r28, 0x43	; 67
    356e:	d3 e0       	ldi	r29, 0x03	; 3
    3570:	4c 81       	ldd	r20, Y+4	; 0x04
    3572:	5d 81       	ldd	r21, Y+5	; 0x05
    3574:	6e 81       	ldd	r22, Y+6	; 0x06
    3576:	7f 81       	ldd	r23, Y+7	; 0x07
    3578:	8c 89       	ldd	r24, Y+20	; 0x14
    357a:	9d 89       	ldd	r25, Y+21	; 0x15
    357c:	ae 89       	ldd	r26, Y+22	; 0x16
    357e:	bf 89       	ldd	r27, Y+23	; 0x17
    3580:	84 0f       	add	r24, r20
    3582:	95 1f       	adc	r25, r21
    3584:	a6 1f       	adc	r26, r22
    3586:	b7 1f       	adc	r27, r23
    3588:	8c 83       	std	Y+4, r24	; 0x04
    358a:	9d 83       	std	Y+5, r25	; 0x05
    358c:	ae 83       	std	Y+6, r26	; 0x06
    358e:	bf 83       	std	Y+7, r27	; 0x07
      st.counter_y -= st.exec_block->step_event_count;
      if (st.exec_block->direction_bits[Y_AXIS] & (1<<DIRECTION_BIT(Y_AXIS))) { sys_position[Y_AXIS]--; }
      else { sys_position[Y_AXIS]++; }
    }
  #else
    if (st.counter_y > st.exec_block->step_event_count) {
    3590:	44 85       	ldd	r20, Z+12	; 0x0c
    3592:	55 85       	ldd	r21, Z+13	; 0x0d
    3594:	66 85       	ldd	r22, Z+14	; 0x0e
    3596:	77 85       	ldd	r23, Z+15	; 0x0f
    3598:	48 17       	cp	r20, r24
    359a:	59 07       	cpc	r21, r25
    359c:	6a 07       	cpc	r22, r26
    359e:	7b 07       	cpc	r23, r27
    35a0:	68 f5       	brcc	.+90     	; 0x35fc <__vector_17+0x2ee>
      st.step_outbits |= (1<<Y_STEP_BIT);
    35a2:	2e 85       	ldd	r18, Y+14	; 0x0e
    35a4:	28 60       	ori	r18, 0x08	; 8
    35a6:	2e 87       	std	Y+14, r18	; 0x0e
      st.counter_y -= st.exec_block->step_event_count;
    35a8:	44 85       	ldd	r20, Z+12	; 0x0c
    35aa:	55 85       	ldd	r21, Z+13	; 0x0d
    35ac:	66 85       	ldd	r22, Z+14	; 0x0e
    35ae:	77 85       	ldd	r23, Z+15	; 0x0f
    35b0:	84 1b       	sub	r24, r20
    35b2:	95 0b       	sbc	r25, r21
    35b4:	a6 0b       	sbc	r26, r22
    35b6:	b7 0b       	sbc	r27, r23
    35b8:	8c 83       	std	Y+4, r24	; 0x04
    35ba:	9d 83       	std	Y+5, r25	; 0x05
    35bc:	ae 83       	std	Y+6, r26	; 0x06
    35be:	bf 83       	std	Y+7, r27	; 0x07
      if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys_position[Y_AXIS]--; }
    35c0:	80 89       	ldd	r24, Z+16	; 0x10
    35c2:	86 ff       	sbrs	r24, 6
    35c4:	0e c0       	rjmp	.+28     	; 0x35e2 <__vector_17+0x2d4>
    35c6:	c3 e4       	ldi	r28, 0x43	; 67
    35c8:	dc e0       	ldi	r29, 0x0C	; 12
    35ca:	8c 81       	ldd	r24, Y+4	; 0x04
    35cc:	9d 81       	ldd	r25, Y+5	; 0x05
    35ce:	ae 81       	ldd	r26, Y+6	; 0x06
    35d0:	bf 81       	ldd	r27, Y+7	; 0x07
    35d2:	01 97       	sbiw	r24, 0x01	; 1
    35d4:	a1 09       	sbc	r26, r1
    35d6:	b1 09       	sbc	r27, r1
    35d8:	8c 83       	std	Y+4, r24	; 0x04
    35da:	9d 83       	std	Y+5, r25	; 0x05
    35dc:	ae 83       	std	Y+6, r26	; 0x06
    35de:	bf 83       	std	Y+7, r27	; 0x07
    35e0:	0d c0       	rjmp	.+26     	; 0x35fc <__vector_17+0x2ee>
      else { sys_position[Y_AXIS]++; }
    35e2:	c3 e4       	ldi	r28, 0x43	; 67
    35e4:	dc e0       	ldi	r29, 0x0C	; 12
    35e6:	8c 81       	ldd	r24, Y+4	; 0x04
    35e8:	9d 81       	ldd	r25, Y+5	; 0x05
    35ea:	ae 81       	ldd	r26, Y+6	; 0x06
    35ec:	bf 81       	ldd	r27, Y+7	; 0x07
    35ee:	01 96       	adiw	r24, 0x01	; 1
    35f0:	a1 1d       	adc	r26, r1
    35f2:	b1 1d       	adc	r27, r1
    35f4:	8c 83       	std	Y+4, r24	; 0x04
    35f6:	9d 83       	std	Y+5, r25	; 0x05
    35f8:	ae 83       	std	Y+6, r26	; 0x06
    35fa:	bf 83       	std	Y+7, r27	; 0x07
    }
  #endif // Ramps Board
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_z += st.steps[Z_AXIS];
    35fc:	c3 e4       	ldi	r28, 0x43	; 67
    35fe:	d3 e0       	ldi	r29, 0x03	; 3
    3600:	48 85       	ldd	r20, Y+8	; 0x08
    3602:	59 85       	ldd	r21, Y+9	; 0x09
    3604:	6a 85       	ldd	r22, Y+10	; 0x0a
    3606:	7b 85       	ldd	r23, Y+11	; 0x0b
    3608:	88 8d       	ldd	r24, Y+24	; 0x18
    360a:	99 8d       	ldd	r25, Y+25	; 0x19
    360c:	aa 8d       	ldd	r26, Y+26	; 0x1a
    360e:	bb 8d       	ldd	r27, Y+27	; 0x1b
    3610:	84 0f       	add	r24, r20
    3612:	95 1f       	adc	r25, r21
    3614:	a6 1f       	adc	r26, r22
    3616:	b7 1f       	adc	r27, r23
    3618:	88 87       	std	Y+8, r24	; 0x08
    361a:	99 87       	std	Y+9, r25	; 0x09
    361c:	aa 87       	std	Y+10, r26	; 0x0a
    361e:	bb 87       	std	Y+11, r27	; 0x0b
      st.counter_z -= st.exec_block->step_event_count;
      if (st.exec_block->direction_bits[Z_AXIS] & (1<<DIRECTION_BIT(Z_AXIS))) { sys_position[Z_AXIS]--; }
      else { sys_position[Z_AXIS]++; }
    }
  #else
    if (st.counter_z > st.exec_block->step_event_count) {
    3620:	44 85       	ldd	r20, Z+12	; 0x0c
    3622:	55 85       	ldd	r21, Z+13	; 0x0d
    3624:	66 85       	ldd	r22, Z+14	; 0x0e
    3626:	77 85       	ldd	r23, Z+15	; 0x0f
    3628:	48 17       	cp	r20, r24
    362a:	59 07       	cpc	r21, r25
    362c:	6a 07       	cpc	r22, r26
    362e:	7b 07       	cpc	r23, r27
    3630:	68 f5       	brcc	.+90     	; 0x368c <__vector_17+0x37e>
      st.step_outbits |= (1<<Z_STEP_BIT);
    3632:	2e 85       	ldd	r18, Y+14	; 0x0e
    3634:	20 61       	ori	r18, 0x10	; 16
    3636:	2e 87       	std	Y+14, r18	; 0x0e
      st.counter_z -= st.exec_block->step_event_count;
    3638:	44 85       	ldd	r20, Z+12	; 0x0c
    363a:	55 85       	ldd	r21, Z+13	; 0x0d
    363c:	66 85       	ldd	r22, Z+14	; 0x0e
    363e:	77 85       	ldd	r23, Z+15	; 0x0f
    3640:	84 1b       	sub	r24, r20
    3642:	95 0b       	sbc	r25, r21
    3644:	a6 0b       	sbc	r26, r22
    3646:	b7 0b       	sbc	r27, r23
    3648:	88 87       	std	Y+8, r24	; 0x08
    364a:	99 87       	std	Y+9, r25	; 0x09
    364c:	aa 87       	std	Y+10, r26	; 0x0a
    364e:	bb 87       	std	Y+11, r27	; 0x0b
      if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys_position[Z_AXIS]--; }
    3650:	80 89       	ldd	r24, Z+16	; 0x10
    3652:	85 ff       	sbrs	r24, 5
    3654:	0e c0       	rjmp	.+28     	; 0x3672 <__vector_17+0x364>
    3656:	e3 e4       	ldi	r30, 0x43	; 67
    3658:	fc e0       	ldi	r31, 0x0C	; 12
    365a:	80 85       	ldd	r24, Z+8	; 0x08
    365c:	91 85       	ldd	r25, Z+9	; 0x09
    365e:	a2 85       	ldd	r26, Z+10	; 0x0a
    3660:	b3 85       	ldd	r27, Z+11	; 0x0b
    3662:	01 97       	sbiw	r24, 0x01	; 1
    3664:	a1 09       	sbc	r26, r1
    3666:	b1 09       	sbc	r27, r1
    3668:	80 87       	std	Z+8, r24	; 0x08
    366a:	91 87       	std	Z+9, r25	; 0x09
    366c:	a2 87       	std	Z+10, r26	; 0x0a
    366e:	b3 87       	std	Z+11, r27	; 0x0b
    3670:	0d c0       	rjmp	.+26     	; 0x368c <__vector_17+0x37e>
      else { sys_position[Z_AXIS]++; }
    3672:	e3 e4       	ldi	r30, 0x43	; 67
    3674:	fc e0       	ldi	r31, 0x0C	; 12
    3676:	80 85       	ldd	r24, Z+8	; 0x08
    3678:	91 85       	ldd	r25, Z+9	; 0x09
    367a:	a2 85       	ldd	r26, Z+10	; 0x0a
    367c:	b3 85       	ldd	r27, Z+11	; 0x0b
    367e:	01 96       	adiw	r24, 0x01	; 1
    3680:	a1 1d       	adc	r26, r1
    3682:	b1 1d       	adc	r27, r1
    3684:	80 87       	std	Z+8, r24	; 0x08
    3686:	91 87       	std	Z+9, r25	; 0x09
    3688:	a2 87       	std	Z+10, r26	; 0x0a
    368a:	b3 87       	std	Z+11, r27	; 0x0b
  // During a homing cycle, lock out and prevent desired axes from moving.
  #ifdef DEFAULTS_RAMPS_BOARD
    for (i = 0; i < N_AXIS; i++)
    if (sys.state == STATE_HOMING) { st.step_outbits[i] &= sys.homing_axis_lock[i]; }
  #else
    if (sys.state == STATE_HOMING) { st.step_outbits &= sys.homing_axis_lock; }
    368c:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    3690:	84 30       	cpi	r24, 0x04	; 4
    3692:	39 f4       	brne	.+14     	; 0x36a2 <__vector_17+0x394>
    3694:	e3 e4       	ldi	r30, 0x43	; 67
    3696:	f3 e0       	ldi	r31, 0x03	; 3
    3698:	96 85       	ldd	r25, Z+14	; 0x0e
    369a:	80 91 24 0c 	lds	r24, 0x0C24	; 0x800c24 <sys+0x6>
    369e:	89 23       	and	r24, r25
    36a0:	86 87       	std	Z+14, r24	; 0x0e
  #endif // Ramps Board
  st.step_count--; // Decrement step events count
    36a2:	e3 e4       	ldi	r30, 0x43	; 67
    36a4:	f3 e0       	ldi	r31, 0x03	; 3
    36a6:	84 8d       	ldd	r24, Z+28	; 0x1c
    36a8:	95 8d       	ldd	r25, Z+29	; 0x1d
    36aa:	01 97       	sbiw	r24, 0x01	; 1
    36ac:	95 8f       	std	Z+29, r25	; 0x1d
    36ae:	84 8f       	std	Z+28, r24	; 0x1c
  if (st.step_count == 0) {
    36b0:	89 2b       	or	r24, r25
    36b2:	69 f4       	brne	.+26     	; 0x36ce <__vector_17+0x3c0>
    // Segment is complete. Discard current segment and advance segment indexing.
    st.exec_segment = NULL;
    36b4:	10 92 65 03 	sts	0x0365, r1	; 0x800365 <st+0x22>
    36b8:	10 92 64 03 	sts	0x0364, r1	; 0x800364 <st+0x21>
    if ( ++segment_buffer_tail == SEGMENT_BUFFER_SIZE) { segment_buffer_tail = 0; }
    36bc:	80 91 42 03 	lds	r24, 0x0342	; 0x800342 <segment_buffer_tail>
    36c0:	8f 5f       	subi	r24, 0xFF	; 255
    36c2:	80 93 42 03 	sts	0x0342, r24	; 0x800342 <segment_buffer_tail>
    36c6:	8a 30       	cpi	r24, 0x0A	; 10
    36c8:	11 f4       	brne	.+4      	; 0x36ce <__vector_17+0x3c0>
    36ca:	10 92 42 03 	sts	0x0342, r1	; 0x800342 <segment_buffer_tail>
  }
  #ifdef DEFAULTS_RAMPS_BOARD
    for (i = 0; i < N_AXIS; i++)
      st.step_outbits[i] ^= step_port_invert_mask[i];  // Apply step port invert mask
  #else
    st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask
    36ce:	e3 e4       	ldi	r30, 0x43	; 67
    36d0:	f3 e0       	ldi	r31, 0x03	; 3
    36d2:	96 85       	ldd	r25, Z+14	; 0x0e
    36d4:	80 91 3f 03 	lds	r24, 0x033F	; 0x80033f <step_port_invert_mask>
    36d8:	89 27       	eor	r24, r25
    36da:	86 87       	std	Z+14, r24	; 0x0e
  #endif // Ramps Board
  busy = false;
    36dc:	10 92 3d 03 	sts	0x033D, r1	; 0x80033d <busy>
}
    36e0:	ff 91       	pop	r31
    36e2:	ef 91       	pop	r30
    36e4:	df 91       	pop	r29
    36e6:	cf 91       	pop	r28
    36e8:	bf 91       	pop	r27
    36ea:	af 91       	pop	r26
    36ec:	9f 91       	pop	r25
    36ee:	8f 91       	pop	r24
    36f0:	7f 91       	pop	r23
    36f2:	6f 91       	pop	r22
    36f4:	5f 91       	pop	r21
    36f6:	4f 91       	pop	r20
    36f8:	3f 91       	pop	r19
    36fa:	2f 91       	pop	r18
    36fc:	0f 90       	pop	r0
    36fe:	0b be       	out	0x3b, r0	; 59
    3700:	0f 90       	pop	r0
    3702:	0f be       	out	0x3f, r0	; 63
    3704:	0f 90       	pop	r0
    3706:	1f 90       	pop	r1
    3708:	18 95       	reti

0000370a <__vector_23>:
*/
// This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute
// a step. This ISR resets the motor port after a short period (settings.pulse_microseconds)
// completing one step cycle.
ISR(TIMER0_OVF_vect)
{
    370a:	1f 92       	push	r1
    370c:	0f 92       	push	r0
    370e:	0f b6       	in	r0, 0x3f	; 63
    3710:	0f 92       	push	r0
    3712:	11 24       	eor	r1, r1
    3714:	8f 93       	push	r24
    3716:	9f 93       	push	r25
  #ifdef DEFAULTS_RAMPS_BOARD
    STEP_PORT(0) = (STEP_PORT(0) & ~(1 << STEP_BIT(0))) | step_port_invert_mask[0];
    STEP_PORT(1) = (STEP_PORT(1) & ~(1 << STEP_BIT(1))) | step_port_invert_mask[1];
    STEP_PORT(2) = (STEP_PORT(2) & ~(1 << STEP_BIT(2))) | step_port_invert_mask[2];
  #else
    STEP_PORT = (STEP_PORT & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK);
    3718:	82 b1       	in	r24, 0x02	; 2
    371a:	90 91 3f 03 	lds	r25, 0x033F	; 0x80033f <step_port_invert_mask>
    371e:	9c 71       	andi	r25, 0x1C	; 28
    3720:	83 7e       	andi	r24, 0xE3	; 227
    3722:	89 2b       	or	r24, r25
    3724:	82 b9       	out	0x02, r24	; 2
  #endif // Ramps Board
  TCCR0B = 0; // Disable Timer0 to prevent re-entering this interrupt when it's not needed.
    3726:	15 bc       	out	0x25, r1	; 37
}
    3728:	9f 91       	pop	r25
    372a:	8f 91       	pop	r24
    372c:	0f 90       	pop	r0
    372e:	0f be       	out	0x3f, r0	; 63
    3730:	0f 90       	pop	r0
    3732:	1f 90       	pop	r1
    3734:	18 95       	reti

00003736 <st_generate_step_dir_invert_masks>:
#endif


// Generates the step and direction port invert masks used in the Stepper Interrupt Driver.
void st_generate_step_dir_invert_masks()
{
    3736:	ef 92       	push	r14
    3738:	ff 92       	push	r15
    373a:	0f 93       	push	r16
    373c:	1f 93       	push	r17
    373e:	cf 93       	push	r28
    3740:	df 93       	push	r29

      if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask[idx] = get_direction_pin_mask(idx); }
      else { dir_port_invert_mask[idx] = 0; }
    }
  #else
    step_port_invert_mask = 0;
    3742:	10 92 3f 03 	sts	0x033F, r1	; 0x80033f <step_port_invert_mask>
    dir_port_invert_mask = 0;
    3746:	10 92 3e 03 	sts	0x033E, r1	; 0x80033e <dir_port_invert_mask>
    374a:	c0 e0       	ldi	r28, 0x00	; 0
    374c:	d0 e0       	ldi	r29, 0x00	; 0
    for (idx=0; idx<N_AXIS; idx++) {
      if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    374e:	00 ed       	ldi	r16, 0xD0	; 208
    3750:	1e e0       	ldi	r17, 0x0E	; 14
    3752:	ec 2e       	mov	r14, r28
    3754:	fc 2e       	mov	r15, r28
    3756:	f8 01       	movw	r30, r16
    3758:	81 a9       	ldd	r24, Z+49	; 0x31
    375a:	90 e0       	ldi	r25, 0x00	; 0
    375c:	0c 2e       	mov	r0, r28
    375e:	02 c0       	rjmp	.+4      	; 0x3764 <st_generate_step_dir_invert_masks+0x2e>
    3760:	95 95       	asr	r25
    3762:	87 95       	ror	r24
    3764:	0a 94       	dec	r0
    3766:	e2 f7       	brpl	.-8      	; 0x3760 <st_generate_step_dir_invert_masks+0x2a>
    3768:	80 ff       	sbrs	r24, 0
    376a:	08 c0       	rjmp	.+16     	; 0x377c <st_generate_step_dir_invert_masks+0x46>
    376c:	8c 2f       	mov	r24, r28
    376e:	0e 94 d3 27 	call	0x4fa6	; 0x4fa6 <get_step_pin_mask>
    3772:	90 91 3f 03 	lds	r25, 0x033F	; 0x80033f <step_port_invert_mask>
    3776:	89 2b       	or	r24, r25
    3778:	80 93 3f 03 	sts	0x033F, r24	; 0x80033f <step_port_invert_mask>
      if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    377c:	f8 01       	movw	r30, r16
    377e:	82 a9       	ldd	r24, Z+50	; 0x32
    3780:	90 e0       	ldi	r25, 0x00	; 0
    3782:	02 c0       	rjmp	.+4      	; 0x3788 <st_generate_step_dir_invert_masks+0x52>
    3784:	95 95       	asr	r25
    3786:	87 95       	ror	r24
    3788:	fa 94       	dec	r15
    378a:	e2 f7       	brpl	.-8      	; 0x3784 <st_generate_step_dir_invert_masks+0x4e>
    378c:	80 ff       	sbrs	r24, 0
    378e:	08 c0       	rjmp	.+16     	; 0x37a0 <st_generate_step_dir_invert_masks+0x6a>
    3790:	8e 2d       	mov	r24, r14
    3792:	0e 94 dd 27 	call	0x4fba	; 0x4fba <get_direction_pin_mask>
    3796:	90 91 3e 03 	lds	r25, 0x033E	; 0x80033e <dir_port_invert_mask>
    379a:	89 2b       	or	r24, r25
    379c:	80 93 3e 03 	sts	0x033E, r24	; 0x80033e <dir_port_invert_mask>
    37a0:	21 96       	adiw	r28, 0x01	; 1
      else { dir_port_invert_mask[idx] = 0; }
    }
  #else
    step_port_invert_mask = 0;
    dir_port_invert_mask = 0;
    for (idx=0; idx<N_AXIS; idx++) {
    37a2:	c3 30       	cpi	r28, 0x03	; 3
    37a4:	d1 05       	cpc	r29, r1
    37a6:	a9 f6       	brne	.-86     	; 0x3752 <st_generate_step_dir_invert_masks+0x1c>
      if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
      if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    }
  #endif // Ramps Board
}
    37a8:	df 91       	pop	r29
    37aa:	cf 91       	pop	r28
    37ac:	1f 91       	pop	r17
    37ae:	0f 91       	pop	r16
    37b0:	ff 90       	pop	r15
    37b2:	ef 90       	pop	r14
    37b4:	08 95       	ret

000037b6 <st_reset>:


// Reset and clear stepper subsystem variables
void st_reset()
{
    37b6:	cf 93       	push	r28
    37b8:	df 93       	push	r29
  #ifdef DEFAULTS_RAMPS_BOARD
    uint8_t idx;
  #endif // Ramps Board

  // Initialize stepper driver idle state.
  st_go_idle();
    37ba:	7b dd       	rcall	.-1290   	; 0x32b2 <st_go_idle>

  // Initialize stepper algorithm variables.
  memset(&prep, 0, sizeof(st_prep_t));
    37bc:	81 e3       	ldi	r24, 0x31	; 49
    37be:	e8 e0       	ldi	r30, 0x08	; 8
    37c0:	f3 e0       	ldi	r31, 0x03	; 3
    37c2:	df 01       	movw	r26, r30
    37c4:	1d 92       	st	X+, r1
    37c6:	8a 95       	dec	r24
    37c8:	e9 f7       	brne	.-6      	; 0x37c4 <st_reset+0xe>
  memset(&st, 0, sizeof(stepper_t));
    37ca:	c3 e4       	ldi	r28, 0x43	; 67
    37cc:	d3 e0       	ldi	r29, 0x03	; 3
    37ce:	83 e2       	ldi	r24, 0x23	; 35
    37d0:	fe 01       	movw	r30, r28
    37d2:	11 92       	st	Z+, r1
    37d4:	8a 95       	dec	r24
    37d6:	e9 f7       	brne	.-6      	; 0x37d2 <st_reset+0x1c>
  st.exec_segment = NULL;
  pl_block = NULL;  // Planner block pointer used by segment buffer
    37d8:	10 92 3c 03 	sts	0x033C, r1	; 0x80033c <pl_block+0x1>
    37dc:	10 92 3b 03 	sts	0x033B, r1	; 0x80033b <pl_block>
  segment_buffer_tail = 0;
    37e0:	10 92 42 03 	sts	0x0342, r1	; 0x800342 <segment_buffer_tail>
  segment_buffer_head = 0; // empty = tail
    37e4:	10 92 41 03 	sts	0x0341, r1	; 0x800341 <segment_buffer_head>
  segment_next_head = 1;
    37e8:	81 e0       	ldi	r24, 0x01	; 1
    37ea:	80 93 40 03 	sts	0x0340, r24	; 0x800340 <segment_next_head>
  busy = false;
    37ee:	10 92 3d 03 	sts	0x033D, r1	; 0x80033d <busy>

  st_generate_step_dir_invert_masks();
    37f2:	a1 df       	rcall	.-190    	; 0x3736 <st_generate_step_dir_invert_masks>
    DIRECTION_PORT(1) = (DIRECTION_PORT(1) & ~(1 << DIRECTION_BIT(1))) | dir_port_invert_mask[1];
  
    STEP_PORT(2) = (STEP_PORT(2) & ~(1 << STEP_BIT(2))) | step_port_invert_mask[2];
    DIRECTION_PORT(2) = (DIRECTION_PORT(2) & ~(1 << DIRECTION_BIT(2))) | dir_port_invert_mask[2];
  #else
    st.dir_outbits = dir_port_invert_mask; // Initialize direction bits to default.
    37f4:	80 91 3e 03 	lds	r24, 0x033E	; 0x80033e <dir_port_invert_mask>
    37f8:	8f 87       	std	Y+15, r24	; 0x0f

    // Initialize step and direction port pins.
    STEP_PORT = (STEP_PORT & ~STEP_MASK) | step_port_invert_mask;
    37fa:	82 b1       	in	r24, 0x02	; 2
    37fc:	83 7e       	andi	r24, 0xE3	; 227
    37fe:	90 91 3f 03 	lds	r25, 0x033F	; 0x80033f <step_port_invert_mask>
    3802:	89 2b       	or	r24, r25
    3804:	82 b9       	out	0x02, r24	; 2
    DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | dir_port_invert_mask;
    3806:	88 b1       	in	r24, 0x08	; 8
    3808:	8f 71       	andi	r24, 0x1F	; 31
    380a:	90 91 3e 03 	lds	r25, 0x033E	; 0x80033e <dir_port_invert_mask>
    380e:	89 2b       	or	r24, r25
    3810:	88 b9       	out	0x08, r24	; 8
  #endif // Ramps Board
}
    3812:	df 91       	pop	r29
    3814:	cf 91       	pop	r28
    3816:	08 95       	ret

00003818 <stepper_init>:
  
    DIRECTION_DDR(0) |= 1<<DIRECTION_BIT(0);
    DIRECTION_DDR(1) |= 1<<DIRECTION_BIT(1);
    DIRECTION_DDR(2) |= 1<<DIRECTION_BIT(2);
  #else
    STEP_DDR |= STEP_MASK;
    3818:	81 b1       	in	r24, 0x01	; 1
    381a:	8c 61       	ori	r24, 0x1C	; 28
    381c:	81 b9       	out	0x01, r24	; 1
    STEPPERS_DISABLE_DDR |= 1<<STEPPERS_DISABLE_BIT;
    381e:	27 9a       	sbi	0x04, 7	; 4
    DIRECTION_DDR |= DIRECTION_MASK;
    3820:	87 b1       	in	r24, 0x07	; 7
    3822:	80 6e       	ori	r24, 0xE0	; 224
    3824:	87 b9       	out	0x07, r24	; 7
  #endif // Ramps Board

  // Configure Timer 1: Stepper Driver Interrupt
  TCCR1B &= ~(1<<WGM13); // waveform generation = 0100 = CTC
    3826:	e1 e8       	ldi	r30, 0x81	; 129
    3828:	f0 e0       	ldi	r31, 0x00	; 0
    382a:	80 81       	ld	r24, Z
    382c:	8f 7e       	andi	r24, 0xEF	; 239
    382e:	80 83       	st	Z, r24
  TCCR1B |=  (1<<WGM12);
    3830:	80 81       	ld	r24, Z
    3832:	88 60       	ori	r24, 0x08	; 8
    3834:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<WGM11) | (1<<WGM10));
    3836:	e0 e8       	ldi	r30, 0x80	; 128
    3838:	f0 e0       	ldi	r31, 0x00	; 0
    383a:	80 81       	ld	r24, Z
    383c:	8c 7f       	andi	r24, 0xFC	; 252
    383e:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<COM1A1) | (1<<COM1A0) | (1<<COM1B1) | (1<<COM1B0)); // Disconnect OC1 output
    3840:	80 81       	ld	r24, Z
    3842:	8f 70       	andi	r24, 0x0F	; 15
    3844:	80 83       	st	Z, r24
  // TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Set in st_go_idle().
  // TIMSK1 &= ~(1<<OCIE1A);  // Set in st_go_idle().

  // Configure Timer 0: Stepper Port Reset Interrupt
  TIMSK0 &= ~((1<<OCIE0B) | (1<<OCIE0A) | (1<<TOIE0)); // Disconnect OC0 outputs and OVF interrupt.
    3846:	ee e6       	ldi	r30, 0x6E	; 110
    3848:	f0 e0       	ldi	r31, 0x00	; 0
    384a:	80 81       	ld	r24, Z
    384c:	88 7f       	andi	r24, 0xF8	; 248
    384e:	80 83       	st	Z, r24
  TCCR0A = 0; // Normal operation
    3850:	14 bc       	out	0x24, r1	; 36
  TCCR0B = 0; // Disable Timer0 until needed
    3852:	15 bc       	out	0x25, r1	; 37
  TIMSK0 |= (1<<TOIE0); // Enable Timer0 overflow interrupt
    3854:	80 81       	ld	r24, Z
    3856:	81 60       	ori	r24, 0x01	; 1
    3858:	80 83       	st	Z, r24
    385a:	08 95       	ret

0000385c <st_update_plan_block_parameters>:
}


// Called by planner_recalculate() when the executing block is updated by the new plan.
void st_update_plan_block_parameters()
{
    385c:	cf 93       	push	r28
    385e:	df 93       	push	r29
  if (pl_block != NULL) { // Ignore if at start of a new block.
    3860:	c0 91 3b 03 	lds	r28, 0x033B	; 0x80033b <pl_block>
    3864:	d0 91 3c 03 	lds	r29, 0x033C	; 0x80033c <pl_block+0x1>
    3868:	20 97       	sbiw	r28, 0x00	; 0
    386a:	a9 f0       	breq	.+42     	; 0x3896 <st_update_plan_block_parameters+0x3a>
    prep.recalculate_flag |= PREP_FLAG_RECALCULATE;
    386c:	e8 e0       	ldi	r30, 0x08	; 8
    386e:	f3 e0       	ldi	r31, 0x03	; 3
    3870:	81 81       	ldd	r24, Z+1	; 0x01
    3872:	81 60       	ori	r24, 0x01	; 1
    3874:	81 83       	std	Z+1, r24	; 0x01
    pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
    3876:	67 89       	ldd	r22, Z+23	; 0x17
    3878:	70 8d       	ldd	r23, Z+24	; 0x18
    387a:	81 8d       	ldd	r24, Z+25	; 0x19
    387c:	92 8d       	ldd	r25, Z+26	; 0x1a
    387e:	9b 01       	movw	r18, r22
    3880:	ac 01       	movw	r20, r24
    3882:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    3886:	6e 8b       	std	Y+22, r22	; 0x16
    3888:	7f 8b       	std	Y+23, r23	; 0x17
    388a:	88 8f       	std	Y+24, r24	; 0x18
    388c:	99 8f       	std	Y+25, r25	; 0x19
    pl_block = NULL; // Flag st_prep_segment() to load and check active velocity profile.
    388e:	10 92 3c 03 	sts	0x033C, r1	; 0x80033c <pl_block+0x1>
    3892:	10 92 3b 03 	sts	0x033B, r1	; 0x80033b <pl_block>
  }
}
    3896:	df 91       	pop	r29
    3898:	cf 91       	pop	r28
    389a:	08 95       	ret

0000389c <st_prep_buffer>:
   longer than the time it takes the stepper algorithm to empty it before refilling it.
   Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer()
{
    389c:	2f 92       	push	r2
    389e:	3f 92       	push	r3
    38a0:	4f 92       	push	r4
    38a2:	5f 92       	push	r5
    38a4:	6f 92       	push	r6
    38a6:	7f 92       	push	r7
    38a8:	8f 92       	push	r8
    38aa:	9f 92       	push	r9
    38ac:	af 92       	push	r10
    38ae:	bf 92       	push	r11
    38b0:	cf 92       	push	r12
    38b2:	df 92       	push	r13
    38b4:	ef 92       	push	r14
    38b6:	ff 92       	push	r15
    38b8:	0f 93       	push	r16
    38ba:	1f 93       	push	r17
    38bc:	cf 93       	push	r28
    38be:	df 93       	push	r29
    38c0:	cd b7       	in	r28, 0x3d	; 61
    38c2:	de b7       	in	r29, 0x3e	; 62
    38c4:	ec 97       	sbiw	r28, 0x3c	; 60
    38c6:	0f b6       	in	r0, 0x3f	; 63
    38c8:	f8 94       	cli
    38ca:	de bf       	out	0x3e, r29	; 62
    38cc:	0f be       	out	0x3f, r0	; 63
    38ce:	cd bf       	out	0x3d, r28	; 61
  // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }
    38d0:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    38d4:	80 ff       	sbrs	r24, 0
    38d6:	02 c0       	rjmp	.+4      	; 0x38dc <st_prep_buffer+0x40>
    38d8:	0c 94 7e 24 	jmp	0x48fc	; 0x48fc <st_prep_buffer+0x1060>
      if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) { pl_block = plan_get_system_motion_block(); }
      else { pl_block = plan_get_current_block(); }
      if (pl_block == NULL) { return; } // No planner blocks. Exit.

      // Check if we need to only recompute the velocity profile or load a new block.
      if (prep.recalculate_flag & PREP_FLAG_RECALCULATE) {
    38dc:	0f 2e       	mov	r0, r31
    38de:	f8 e0       	ldi	r31, 0x08	; 8
    38e0:	6f 2e       	mov	r6, r31
    38e2:	f3 e0       	ldi	r31, 0x03	; 3
    38e4:	7f 2e       	mov	r7, r31
    38e6:	f0 2d       	mov	r31, r0
          mm_var = mm_remaining - prep.maximum_speed*time_var;
          if (mm_var < prep.decelerate_after) { // End of cruise.
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
    38e8:	22 e0       	ldi	r18, 0x02	; 2
    38ea:	2a af       	std	Y+58, r18	; 0x3a
    38ec:	29 af       	std	Y+57, r18	; 0x39
    38ee:	cd c7       	rjmp	.+3994   	; 0x488a <st_prep_buffer+0xfee>
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }

  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.

    // Determine if we need to load a new planner block or if the block needs to be recomputed.
    if (pl_block == NULL) {
    38f0:	80 91 3b 03 	lds	r24, 0x033B	; 0x80033b <pl_block>
    38f4:	90 91 3c 03 	lds	r25, 0x033C	; 0x80033c <pl_block+0x1>
    38f8:	89 2b       	or	r24, r25
    38fa:	09 f0       	breq	.+2      	; 0x38fe <st_prep_buffer+0x62>
    38fc:	11 c3       	rjmp	.+1570   	; 0x3f20 <st_prep_buffer+0x684>

      // Query planner for a queued block
      if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) { pl_block = plan_get_system_motion_block(); }
    38fe:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    3902:	82 ff       	sbrs	r24, 2
    3904:	07 c0       	rjmp	.+14     	; 0x3914 <st_prep_buffer+0x78>
    3906:	0e 94 7e 29 	call	0x52fc	; 0x52fc <plan_get_system_motion_block>
    390a:	90 93 3c 03 	sts	0x033C, r25	; 0x80033c <pl_block+0x1>
    390e:	80 93 3b 03 	sts	0x033B, r24	; 0x80033b <pl_block>
    3912:	06 c0       	rjmp	.+12     	; 0x3920 <st_prep_buffer+0x84>
      else { pl_block = plan_get_current_block(); }
    3914:	0e 94 87 29 	call	0x530e	; 0x530e <plan_get_current_block>
    3918:	90 93 3c 03 	sts	0x033C, r25	; 0x80033c <pl_block+0x1>
    391c:	80 93 3b 03 	sts	0x033B, r24	; 0x80033b <pl_block>
      if (pl_block == NULL) { return; } // No planner blocks. Exit.
    3920:	e0 90 3b 03 	lds	r14, 0x033B	; 0x80033b <pl_block>
    3924:	f0 90 3c 03 	lds	r15, 0x033C	; 0x80033c <pl_block+0x1>
    3928:	e1 14       	cp	r14, r1
    392a:	f1 04       	cpc	r15, r1
    392c:	09 f4       	brne	.+2      	; 0x3930 <st_prep_buffer+0x94>
    392e:	e6 c7       	rjmp	.+4044   	; 0x48fc <st_prep_buffer+0x1060>

      // Check if we need to only recompute the velocity profile or load a new block.
      if (prep.recalculate_flag & PREP_FLAG_RECALCULATE) {
    3930:	d3 01       	movw	r26, r6
    3932:	11 96       	adiw	r26, 0x01	; 1
    3934:	1c 91       	ld	r17, X
    3936:	11 97       	sbiw	r26, 0x01	; 1
    3938:	81 2f       	mov	r24, r17
    393a:	81 70       	andi	r24, 0x01	; 1
    393c:	10 ff       	sbrs	r17, 0
    393e:	03 c0       	rjmp	.+6      	; 0x3946 <st_prep_buffer+0xaa>

        #ifdef PARKING_ENABLE
          if (prep.recalculate_flag & PREP_FLAG_PARKING) { prep.recalculate_flag &= ~(PREP_FLAG_RECALCULATE); }
          else { prep.recalculate_flag = false; }
        #else
          prep.recalculate_flag = false;
    3940:	11 96       	adiw	r26, 0x01	; 1
    3942:	1c 92       	st	X, r1
    3944:	eb c0       	rjmp	.+470    	; 0x3b1c <st_prep_buffer+0x280>


// Increments the step segment buffer block data ring buffer.
static uint8_t st_next_block_index(uint8_t block_index)
{
  block_index++;
    3946:	f3 01       	movw	r30, r6
    3948:	90 81       	ld	r25, Z
    394a:	9f 5f       	subi	r25, 0xFF	; 255
  if ( block_index == (SEGMENT_BUFFER_SIZE-1) ) { return(0); }
    394c:	99 30       	cpi	r25, 0x09	; 9
    394e:	09 f0       	breq	.+2      	; 0x3952 <st_prep_buffer+0xb6>
  return(block_index);
    3950:	89 2f       	mov	r24, r25
        #endif

      } else {

        // Load the Bresenham stepping data for the block.
        prep.st_block_index = st_next_block_index(prep.st_block_index);
    3952:	d3 01       	movw	r26, r6
    3954:	8c 93       	st	X, r24

        // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
        // when the segment buffer completes the planner block, it may be discarded when the
        // segment buffer finishes the prepped block, but the stepper ISR is still executing it.
        st_prep_block = &st_block_buffer[prep.st_block_index];
    3956:	90 e0       	ldi	r25, 0x00	; 0
    3958:	fc 01       	movw	r30, r24
    395a:	ee 0f       	add	r30, r30
    395c:	ff 1f       	adc	r31, r31
    395e:	9f 01       	movw	r18, r30
    3960:	22 0f       	add	r18, r18
    3962:	33 1f       	adc	r19, r19
    3964:	22 0f       	add	r18, r18
    3966:	33 1f       	adc	r19, r19
    3968:	22 0f       	add	r18, r18
    396a:	33 1f       	adc	r19, r19
    396c:	e2 0f       	add	r30, r18
    396e:	f3 1f       	adc	r31, r19
    3970:	ea 54       	subi	r30, 0x4A	; 74
    3972:	fc 4f       	sbci	r31, 0xFC	; 252
    3974:	f0 93 3a 03 	sts	0x033A, r31	; 0x80033a <st_prep_block+0x1>
    3978:	e0 93 39 03 	sts	0x0339, r30	; 0x800339 <st_prep_block>
        #ifdef DEFAULTS_RAMPS_BOARD
          for (idx=0; idx<N_AXIS; idx++) {
            st_prep_block->direction_bits[idx] = pl_block->direction_bits[idx];
          }
        #else
          st_prep_block->direction_bits = pl_block->direction_bits;
    397c:	d7 01       	movw	r26, r14
    397e:	50 96       	adiw	r26, 0x10	; 16
    3980:	2c 91       	ld	r18, X
    3982:	50 97       	sbiw	r26, 0x10	; 16
    3984:	20 8b       	std	Z+16, r18	; 0x10
    3986:	97 01       	movw	r18, r14
    3988:	24 5f       	subi	r18, 0xF4	; 244
    398a:	3f 4f       	sbci	r19, 0xFF	; 255
    398c:	fa 82       	std	Y+2, r15	; 0x02
    398e:	e9 82       	std	Y+1, r14	; 0x01
          st_prep_block->step_event_count = (pl_block->step_event_count << 1);
        #else
          // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS
          // level, such that we never divide beyond the original data anywhere in the algorithm.
          // If the original data is divided, we can lose a step from integer roundoff.
          for (idx=0; idx<N_AXIS; idx++) { st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_AMASS_LEVEL; }
    3990:	4d 91       	ld	r20, X+
    3992:	5d 91       	ld	r21, X+
    3994:	6d 91       	ld	r22, X+
    3996:	7d 91       	ld	r23, X+
    3998:	44 0f       	add	r20, r20
    399a:	55 1f       	adc	r21, r21
    399c:	66 1f       	adc	r22, r22
    399e:	77 1f       	adc	r23, r23
    39a0:	44 0f       	add	r20, r20
    39a2:	55 1f       	adc	r21, r21
    39a4:	66 1f       	adc	r22, r22
    39a6:	77 1f       	adc	r23, r23
    39a8:	44 0f       	add	r20, r20
    39aa:	55 1f       	adc	r21, r21
    39ac:	66 1f       	adc	r22, r22
    39ae:	77 1f       	adc	r23, r23
    39b0:	41 93       	st	Z+, r20
    39b2:	51 93       	st	Z+, r21
    39b4:	61 93       	st	Z+, r22
    39b6:	71 93       	st	Z+, r23
    39b8:	a2 17       	cp	r26, r18
    39ba:	b3 07       	cpc	r27, r19
    39bc:	49 f7       	brne	.-46     	; 0x3990 <st_prep_buffer+0xf4>
    39be:	e9 80       	ldd	r14, Y+1	; 0x01
    39c0:	fa 80       	ldd	r15, Y+2	; 0x02
          st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
    39c2:	88 0f       	add	r24, r24
    39c4:	99 1f       	adc	r25, r25
    39c6:	fc 01       	movw	r30, r24
    39c8:	ee 0f       	add	r30, r30
    39ca:	ff 1f       	adc	r31, r31
    39cc:	ee 0f       	add	r30, r30
    39ce:	ff 1f       	adc	r31, r31
    39d0:	ee 0f       	add	r30, r30
    39d2:	ff 1f       	adc	r31, r31
    39d4:	8e 0f       	add	r24, r30
    39d6:	9f 1f       	adc	r25, r31
    39d8:	9c 01       	movw	r18, r24
    39da:	2a 54       	subi	r18, 0x4A	; 74
    39dc:	3c 4f       	sbci	r19, 0xFC	; 252
    39de:	f7 01       	movw	r30, r14
    39e0:	84 85       	ldd	r24, Z+12	; 0x0c
    39e2:	95 85       	ldd	r25, Z+13	; 0x0d
    39e4:	a6 85       	ldd	r26, Z+14	; 0x0e
    39e6:	b7 85       	ldd	r27, Z+15	; 0x0f
    39e8:	88 0f       	add	r24, r24
    39ea:	99 1f       	adc	r25, r25
    39ec:	aa 1f       	adc	r26, r26
    39ee:	bb 1f       	adc	r27, r27
    39f0:	88 0f       	add	r24, r24
    39f2:	99 1f       	adc	r25, r25
    39f4:	aa 1f       	adc	r26, r26
    39f6:	bb 1f       	adc	r27, r27
    39f8:	88 0f       	add	r24, r24
    39fa:	99 1f       	adc	r25, r25
    39fc:	aa 1f       	adc	r26, r26
    39fe:	bb 1f       	adc	r27, r27
    3a00:	f9 01       	movw	r30, r18
    3a02:	84 87       	std	Z+12, r24	; 0x0c
    3a04:	95 87       	std	Z+13, r25	; 0x0d
    3a06:	a6 87       	std	Z+14, r26	; 0x0e
    3a08:	b7 87       	std	Z+15, r27	; 0x0f
        #endif

        // Initialize segment buffer data for generating the segments.
        prep.steps_remaining = (float)pl_block->step_event_count;
    3a0a:	d7 01       	movw	r26, r14
    3a0c:	1c 96       	adiw	r26, 0x0c	; 12
    3a0e:	6d 91       	ld	r22, X+
    3a10:	7d 91       	ld	r23, X+
    3a12:	8d 91       	ld	r24, X+
    3a14:	9c 91       	ld	r25, X
    3a16:	1f 97       	sbiw	r26, 0x0f	; 15
    3a18:	0e 94 40 40 	call	0x8080	; 0x8080 <__floatunsisf>
    3a1c:	f3 01       	movw	r30, r6
    3a1e:	66 83       	std	Z+6, r22	; 0x06
    3a20:	77 83       	std	Z+7, r23	; 0x07
    3a22:	80 87       	std	Z+8, r24	; 0x08
    3a24:	91 87       	std	Z+9, r25	; 0x09
        prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
    3a26:	d7 01       	movw	r26, r14
    3a28:	92 96       	adiw	r26, 0x22	; 34
    3a2a:	2d 91       	ld	r18, X+
    3a2c:	3d 91       	ld	r19, X+
    3a2e:	4d 91       	ld	r20, X+
    3a30:	5c 91       	ld	r21, X
    3a32:	95 97       	sbiw	r26, 0x25	; 37
    3a34:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <__divsf3>
    3a38:	9b 01       	movw	r18, r22
    3a3a:	ac 01       	movw	r20, r24
    3a3c:	f3 01       	movw	r30, r6
    3a3e:	62 87       	std	Z+10, r22	; 0x0a
    3a40:	73 87       	std	Z+11, r23	; 0x0b
    3a42:	84 87       	std	Z+12, r24	; 0x0c
    3a44:	95 87       	std	Z+13, r25	; 0x0d
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
    3a46:	60 e0       	ldi	r22, 0x00	; 0
    3a48:	70 e0       	ldi	r23, 0x00	; 0
    3a4a:	80 ea       	ldi	r24, 0xA0	; 160
    3a4c:	9f e3       	ldi	r25, 0x3F	; 63
    3a4e:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <__divsf3>
    3a52:	d3 01       	movw	r26, r6
    3a54:	1e 96       	adiw	r26, 0x0e	; 14
    3a56:	6d 93       	st	X+, r22
    3a58:	7d 93       	st	X+, r23
    3a5a:	8d 93       	st	X+, r24
    3a5c:	9c 93       	st	X, r25
    3a5e:	51 97       	sbiw	r26, 0x11	; 17
        prep.dt_remainder = 0.0; // Reset for new segment block
    3a60:	f3 01       	movw	r30, r6
    3a62:	12 82       	std	Z+2, r1	; 0x02
    3a64:	13 82       	std	Z+3, r1	; 0x03
    3a66:	14 82       	std	Z+4, r1	; 0x04
    3a68:	15 82       	std	Z+5, r1	; 0x05

        if ((sys.step_control & STEP_CONTROL_EXECUTE_HOLD) || (prep.recalculate_flag & PREP_FLAG_DECEL_OVERRIDE)) {
    3a6a:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    3a6e:	81 fd       	sbrc	r24, 1
    3a70:	02 c0       	rjmp	.+4      	; 0x3a76 <st_prep_buffer+0x1da>
    3a72:	13 ff       	sbrs	r17, 3
    3a74:	1b c0       	rjmp	.+54     	; 0x3aac <st_prep_buffer+0x210>
          // New block loaded mid-hold. Override planner block entry speed to enforce deceleration.
          prep.current_speed = prep.exit_speed;
    3a76:	d3 01       	movw	r26, r6
    3a78:	5f 96       	adiw	r26, 0x1f	; 31
    3a7a:	6d 91       	ld	r22, X+
    3a7c:	7d 91       	ld	r23, X+
    3a7e:	8d 91       	ld	r24, X+
    3a80:	9c 91       	ld	r25, X
    3a82:	92 97       	sbiw	r26, 0x22	; 34
    3a84:	f3 01       	movw	r30, r6
    3a86:	67 8b       	std	Z+23, r22	; 0x17
    3a88:	70 8f       	std	Z+24, r23	; 0x18
    3a8a:	81 8f       	std	Z+25, r24	; 0x19
    3a8c:	92 8f       	std	Z+26, r25	; 0x1a
          pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed;
    3a8e:	9b 01       	movw	r18, r22
    3a90:	ac 01       	movw	r20, r24
    3a92:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    3a96:	d7 01       	movw	r26, r14
    3a98:	56 96       	adiw	r26, 0x16	; 22
    3a9a:	6d 93       	st	X+, r22
    3a9c:	7d 93       	st	X+, r23
    3a9e:	8d 93       	st	X+, r24
    3aa0:	9c 93       	st	X, r25
    3aa2:	59 97       	sbiw	r26, 0x19	; 25
          prep.recalculate_flag &= ~(PREP_FLAG_DECEL_OVERRIDE);
    3aa4:	17 7f       	andi	r17, 0xF7	; 247
    3aa6:	f3 01       	movw	r30, r6
    3aa8:	11 83       	std	Z+1, r17	; 0x01
    3aaa:	0e c0       	rjmp	.+28     	; 0x3ac8 <st_prep_buffer+0x22c>
        } else {
          prep.current_speed = sqrt(pl_block->entry_speed_sqr);
    3aac:	d7 01       	movw	r26, r14
    3aae:	56 96       	adiw	r26, 0x16	; 22
    3ab0:	6d 91       	ld	r22, X+
    3ab2:	7d 91       	ld	r23, X+
    3ab4:	8d 91       	ld	r24, X+
    3ab6:	9c 91       	ld	r25, X
    3ab8:	59 97       	sbiw	r26, 0x19	; 25
    3aba:	0e 94 6b 42 	call	0x84d6	; 0x84d6 <sqrt>
    3abe:	f3 01       	movw	r30, r6
    3ac0:	67 8b       	std	Z+23, r22	; 0x17
    3ac2:	70 8f       	std	Z+24, r23	; 0x18
    3ac4:	81 8f       	std	Z+25, r24	; 0x19
    3ac6:	92 8f       	std	Z+26, r25	; 0x1a
        }
        
        // Setup laser mode variables. PWM rate adjusted motions will always complete a motion with the
        // spindle off. 
        st_prep_block->is_pwm_rate_adjusted = false;
    3ac8:	20 91 39 03 	lds	r18, 0x0339	; 0x800339 <st_prep_block>
    3acc:	30 91 3a 03 	lds	r19, 0x033A	; 0x80033a <st_prep_block+0x1>
    3ad0:	3a 83       	std	Y+2, r19	; 0x02
    3ad2:	29 83       	std	Y+1, r18	; 0x01
    3ad4:	d9 01       	movw	r26, r18
    3ad6:	51 96       	adiw	r26, 0x11	; 17
    3ad8:	1c 92       	st	X, r1
        if (settings.flags & BITFLAG_LASER_MODE) {
    3ada:	e5 e1       	ldi	r30, 0x15	; 21
    3adc:	ff e0       	ldi	r31, 0x0F	; 15
    3ade:	80 81       	ld	r24, Z
    3ae0:	81 ff       	sbrs	r24, 1
    3ae2:	1c c0       	rjmp	.+56     	; 0x3b1c <st_prep_buffer+0x280>
          if (pl_block->condition & PL_COND_FLAG_SPINDLE_CCW) { 
    3ae4:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    3ae8:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    3aec:	81 89       	ldd	r24, Z+17	; 0x11
    3aee:	85 ff       	sbrs	r24, 5
    3af0:	15 c0       	rjmp	.+42     	; 0x3b1c <st_prep_buffer+0x280>
            // Pre-compute inverse programmed rate to speed up PWM updating per step segment.
            prep.inv_rate = 1.0/pl_block->programmed_rate;
    3af2:	26 a5       	ldd	r18, Z+46	; 0x2e
    3af4:	37 a5       	ldd	r19, Z+47	; 0x2f
    3af6:	40 a9       	ldd	r20, Z+48	; 0x30
    3af8:	51 a9       	ldd	r21, Z+49	; 0x31
    3afa:	60 e0       	ldi	r22, 0x00	; 0
    3afc:	70 e0       	ldi	r23, 0x00	; 0
    3afe:	80 e8       	ldi	r24, 0x80	; 128
    3b00:	9f e3       	ldi	r25, 0x3F	; 63
    3b02:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <__divsf3>
    3b06:	d3 01       	movw	r26, r6
    3b08:	9b 96       	adiw	r26, 0x2b	; 43
    3b0a:	6d 93       	st	X+, r22
    3b0c:	7d 93       	st	X+, r23
    3b0e:	8d 93       	st	X+, r24
    3b10:	9c 93       	st	X, r25
    3b12:	9e 97       	sbiw	r26, 0x2e	; 46
            st_prep_block->is_pwm_rate_adjusted = true; 
    3b14:	21 e0       	ldi	r18, 0x01	; 1
    3b16:	e9 81       	ldd	r30, Y+1	; 0x01
    3b18:	fa 81       	ldd	r31, Y+2	; 0x02
    3b1a:	21 8b       	std	Z+17, r18	; 0x11
			 Compute the velocity profile of a new planner block based on its entry and exit
			 speeds, or recompute the profile of a partially-completed planner block if the
			 planner has updated it. For a commanded forced-deceleration, such as from a feed
			 hold, override the planner velocities and decelerate to the target exit speed.
			*/
			prep.mm_complete = 0.0; // Default velocity profile complete at 0.0mm from end of block.
    3b1c:	d3 01       	movw	r26, r6
    3b1e:	53 96       	adiw	r26, 0x13	; 19
    3b20:	1d 92       	st	X+, r1
    3b22:	1d 92       	st	X+, r1
    3b24:	1d 92       	st	X+, r1
    3b26:	1c 92       	st	X, r1
    3b28:	56 97       	sbiw	r26, 0x16	; 22
			float inv_2_accel = 0.5/pl_block->acceleration;
    3b2a:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    3b2e:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    3b32:	fe 83       	std	Y+6, r31	; 0x06
    3b34:	ed 83       	std	Y+5, r30	; 0x05
    3b36:	86 8c       	ldd	r8, Z+30	; 0x1e
    3b38:	97 8c       	ldd	r9, Z+31	; 0x1f
    3b3a:	a0 a0       	ldd	r10, Z+32	; 0x20
    3b3c:	b1 a0       	ldd	r11, Z+33	; 0x21
    3b3e:	a5 01       	movw	r20, r10
    3b40:	94 01       	movw	r18, r8
    3b42:	60 e0       	ldi	r22, 0x00	; 0
    3b44:	70 e0       	ldi	r23, 0x00	; 0
    3b46:	80 e0       	ldi	r24, 0x00	; 0
    3b48:	9f e3       	ldi	r25, 0x3F	; 63
    3b4a:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <__divsf3>
    3b4e:	69 83       	std	Y+1, r22	; 0x01
    3b50:	7a 83       	std	Y+2, r23	; 0x02
    3b52:	8b 83       	std	Y+3, r24	; 0x03
    3b54:	9c 83       	std	Y+4, r25	; 0x04
			if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { // [Forced Deceleration to Zero Velocity]
    3b56:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    3b5a:	81 ff       	sbrs	r24, 1
    3b5c:	54 c0       	rjmp	.+168    	; 0x3c06 <st_prep_buffer+0x36a>
				// Compute velocity profile parameters for a feed hold in-progress. This profile overrides
				// the planner block profile, enforcing a deceleration to zero speed.
				prep.ramp_type = RAMP_DECEL;
    3b5e:	e2 e0       	ldi	r30, 0x02	; 2
    3b60:	d3 01       	movw	r26, r6
    3b62:	52 96       	adiw	r26, 0x12	; 18
    3b64:	ec 93       	st	X, r30
				// Compute decelerate distance relative to end of block.
				float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
    3b66:	ad 81       	ldd	r26, Y+5	; 0x05
    3b68:	be 81       	ldd	r27, Y+6	; 0x06
    3b6a:	92 96       	adiw	r26, 0x22	; 34
    3b6c:	2d 90       	ld	r2, X+
    3b6e:	3d 90       	ld	r3, X+
    3b70:	4d 90       	ld	r4, X+
    3b72:	5c 90       	ld	r5, X
    3b74:	95 97       	sbiw	r26, 0x25	; 37
    3b76:	56 96       	adiw	r26, 0x16	; 22
    3b78:	cd 90       	ld	r12, X+
    3b7a:	dd 90       	ld	r13, X+
    3b7c:	ed 90       	ld	r14, X+
    3b7e:	fc 90       	ld	r15, X
    3b80:	59 97       	sbiw	r26, 0x19	; 25
    3b82:	a7 01       	movw	r20, r14
    3b84:	96 01       	movw	r18, r12
    3b86:	69 81       	ldd	r22, Y+1	; 0x01
    3b88:	7a 81       	ldd	r23, Y+2	; 0x02
    3b8a:	8b 81       	ldd	r24, Y+3	; 0x03
    3b8c:	9c 81       	ldd	r25, Y+4	; 0x04
    3b8e:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    3b92:	9b 01       	movw	r18, r22
    3b94:	ac 01       	movw	r20, r24
    3b96:	c2 01       	movw	r24, r4
    3b98:	b1 01       	movw	r22, r2
    3b9a:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    3b9e:	69 83       	std	Y+1, r22	; 0x01
    3ba0:	7a 83       	std	Y+2, r23	; 0x02
    3ba2:	8b 83       	std	Y+3, r24	; 0x03
    3ba4:	9c 83       	std	Y+4, r25	; 0x04
				if (decel_dist < 0.0) {
    3ba6:	20 e0       	ldi	r18, 0x00	; 0
    3ba8:	30 e0       	ldi	r19, 0x00	; 0
    3baa:	a9 01       	movw	r20, r18
    3bac:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    3bb0:	88 23       	and	r24, r24
    3bb2:	c4 f4       	brge	.+48     	; 0x3be4 <st_prep_buffer+0x348>
					// Deceleration through entire planner block. End of feed hold is not in this block.
					prep.exit_speed = sqrt(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);
    3bb4:	a5 01       	movw	r20, r10
    3bb6:	94 01       	movw	r18, r8
    3bb8:	c5 01       	movw	r24, r10
    3bba:	b4 01       	movw	r22, r8
    3bbc:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    3bc0:	a2 01       	movw	r20, r4
    3bc2:	91 01       	movw	r18, r2
    3bc4:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    3bc8:	9b 01       	movw	r18, r22
    3bca:	ac 01       	movw	r20, r24
    3bcc:	c7 01       	movw	r24, r14
    3bce:	b6 01       	movw	r22, r12
    3bd0:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    3bd4:	0e 94 6b 42 	call	0x84d6	; 0x84d6 <sqrt>
    3bd8:	f3 01       	movw	r30, r6
    3bda:	67 8f       	std	Z+31, r22	; 0x1f
    3bdc:	70 a3       	std	Z+32, r23	; 0x20
    3bde:	81 a3       	std	Z+33, r24	; 0x21
    3be0:	92 a3       	std	Z+34, r25	; 0x22
    3be2:	99 c1       	rjmp	.+818    	; 0x3f16 <st_prep_buffer+0x67a>
				} else {
					prep.mm_complete = decel_dist; // End of feed hold.
    3be4:	29 81       	ldd	r18, Y+1	; 0x01
    3be6:	3a 81       	ldd	r19, Y+2	; 0x02
    3be8:	4b 81       	ldd	r20, Y+3	; 0x03
    3bea:	5c 81       	ldd	r21, Y+4	; 0x04
    3bec:	d3 01       	movw	r26, r6
    3bee:	53 96       	adiw	r26, 0x13	; 19
    3bf0:	2d 93       	st	X+, r18
    3bf2:	3d 93       	st	X+, r19
    3bf4:	4d 93       	st	X+, r20
    3bf6:	5c 93       	st	X, r21
    3bf8:	56 97       	sbiw	r26, 0x16	; 22
					prep.exit_speed = 0.0;
    3bfa:	f3 01       	movw	r30, r6
    3bfc:	17 8e       	std	Z+31, r1	; 0x1f
    3bfe:	10 a2       	std	Z+32, r1	; 0x20
    3c00:	11 a2       	std	Z+33, r1	; 0x21
    3c02:	12 a2       	std	Z+34, r1	; 0x22
    3c04:	88 c1       	rjmp	.+784    	; 0x3f16 <st_prep_buffer+0x67a>
				}
			} else { // [Normal Operation]
				// Compute or recompute velocity profile parameters of the prepped planner block.
				prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
    3c06:	d3 01       	movw	r26, r6
    3c08:	52 96       	adiw	r26, 0x12	; 18
    3c0a:	1c 92       	st	X, r1
    3c0c:	52 97       	sbiw	r26, 0x12	; 18
				prep.accelerate_until = pl_block->millimeters;
    3c0e:	ed 81       	ldd	r30, Y+5	; 0x05
    3c10:	fe 81       	ldd	r31, Y+6	; 0x06
    3c12:	42 a1       	ldd	r20, Z+34	; 0x22
    3c14:	53 a1       	ldd	r21, Z+35	; 0x23
    3c16:	64 a1       	ldd	r22, Z+36	; 0x24
    3c18:	75 a1       	ldd	r23, Z+37	; 0x25
    3c1a:	93 96       	adiw	r26, 0x23	; 35
    3c1c:	4d 93       	st	X+, r20
    3c1e:	5d 93       	st	X+, r21
    3c20:	6d 93       	st	X+, r22
    3c22:	7c 93       	st	X, r23
    3c24:	96 97       	sbiw	r26, 0x26	; 38

				float exit_speed_sqr;
				float nominal_speed;
        if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
    3c26:	82 ff       	sbrs	r24, 2
    3c28:	0a c0       	rjmp	.+20     	; 0x3c3e <st_prep_buffer+0x3a2>
          prep.exit_speed = exit_speed_sqr = 0.0; // Enforce stop at end of system motion.
    3c2a:	f3 01       	movw	r30, r6
    3c2c:	17 8e       	std	Z+31, r1	; 0x1f
    3c2e:	10 a2       	std	Z+32, r1	; 0x20
    3c30:	11 a2       	std	Z+33, r1	; 0x21
    3c32:	12 a2       	std	Z+34, r1	; 0x22
    3c34:	19 86       	std	Y+9, r1	; 0x09
    3c36:	1a 86       	std	Y+10, r1	; 0x0a
    3c38:	1b 86       	std	Y+11, r1	; 0x0b
    3c3a:	1c 86       	std	Y+12, r1	; 0x0c
    3c3c:	0f c0       	rjmp	.+30     	; 0x3c5c <st_prep_buffer+0x3c0>
        } else {
          exit_speed_sqr = plan_get_exec_block_exit_speed_sqr();
    3c3e:	0e 94 97 29 	call	0x532e	; 0x532e <plan_get_exec_block_exit_speed_sqr>
    3c42:	69 87       	std	Y+9, r22	; 0x09
    3c44:	7a 87       	std	Y+10, r23	; 0x0a
    3c46:	8b 87       	std	Y+11, r24	; 0x0b
    3c48:	9c 87       	std	Y+12, r25	; 0x0c
          prep.exit_speed = sqrt(exit_speed_sqr);
    3c4a:	0e 94 6b 42 	call	0x84d6	; 0x84d6 <sqrt>
    3c4e:	d3 01       	movw	r26, r6
    3c50:	5f 96       	adiw	r26, 0x1f	; 31
    3c52:	6d 93       	st	X+, r22
    3c54:	7d 93       	st	X+, r23
    3c56:	8d 93       	st	X+, r24
    3c58:	9c 93       	st	X, r25
    3c5a:	92 97       	sbiw	r26, 0x22	; 34
        }

        nominal_speed = plan_compute_profile_nominal_speed(pl_block);
    3c5c:	80 91 3b 03 	lds	r24, 0x033B	; 0x80033b <pl_block>
    3c60:	90 91 3c 03 	lds	r25, 0x033C	; 0x80033c <pl_block+0x1>
    3c64:	0e 94 b8 29 	call	0x5370	; 0x5370 <plan_compute_profile_nominal_speed>
    3c68:	4b 01       	movw	r8, r22
    3c6a:	5c 01       	movw	r10, r24
				float nominal_speed_sqr = nominal_speed*nominal_speed;
    3c6c:	9b 01       	movw	r18, r22
    3c6e:	ac 01       	movw	r20, r24
    3c70:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    3c74:	6d 83       	std	Y+5, r22	; 0x05
    3c76:	7e 83       	std	Y+6, r23	; 0x06
    3c78:	8f 83       	std	Y+7, r24	; 0x07
    3c7a:	98 87       	std	Y+8, r25	; 0x08
				float intersect_distance =
								0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
    3c7c:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    3c80:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    3c84:	fe 87       	std	Y+14, r31	; 0x0e
    3c86:	ed 87       	std	Y+13, r30	; 0x0d
    3c88:	c2 a0       	ldd	r12, Z+34	; 0x22
    3c8a:	d3 a0       	ldd	r13, Z+35	; 0x23
    3c8c:	e4 a0       	ldd	r14, Z+36	; 0x24
    3c8e:	f5 a0       	ldd	r15, Z+37	; 0x25
    3c90:	26 88       	ldd	r2, Z+22	; 0x16
    3c92:	37 88       	ldd	r3, Z+23	; 0x17
    3c94:	40 8c       	ldd	r4, Z+24	; 0x18
    3c96:	51 8c       	ldd	r5, Z+25	; 0x19

        if (pl_block->entry_speed_sqr > nominal_speed_sqr) { // Only occurs during override reductions.
    3c98:	a2 01       	movw	r20, r4
    3c9a:	91 01       	movw	r18, r2
    3c9c:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    3ca0:	88 23       	and	r24, r24
    3ca2:	0c f0       	brlt	.+2      	; 0x3ca6 <st_prep_buffer+0x40a>
    3ca4:	71 c0       	rjmp	.+226    	; 0x3d88 <st_prep_buffer+0x4ec>
          prep.accelerate_until = pl_block->millimeters - inv_2_accel*(pl_block->entry_speed_sqr-nominal_speed_sqr);
    3ca6:	2d 81       	ldd	r18, Y+5	; 0x05
    3ca8:	3e 81       	ldd	r19, Y+6	; 0x06
    3caa:	4f 81       	ldd	r20, Y+7	; 0x07
    3cac:	58 85       	ldd	r21, Y+8	; 0x08
    3cae:	c2 01       	movw	r24, r4
    3cb0:	b1 01       	movw	r22, r2
    3cb2:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    3cb6:	29 81       	ldd	r18, Y+1	; 0x01
    3cb8:	3a 81       	ldd	r19, Y+2	; 0x02
    3cba:	4b 81       	ldd	r20, Y+3	; 0x03
    3cbc:	5c 81       	ldd	r21, Y+4	; 0x04
    3cbe:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    3cc2:	9b 01       	movw	r18, r22
    3cc4:	ac 01       	movw	r20, r24
    3cc6:	c7 01       	movw	r24, r14
    3cc8:	b6 01       	movw	r22, r12
    3cca:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    3cce:	d3 01       	movw	r26, r6
    3cd0:	93 96       	adiw	r26, 0x23	; 35
    3cd2:	6d 93       	st	X+, r22
    3cd4:	7d 93       	st	X+, r23
    3cd6:	8d 93       	st	X+, r24
    3cd8:	9c 93       	st	X, r25
    3cda:	96 97       	sbiw	r26, 0x26	; 38
          if (prep.accelerate_until <= 0.0) { // Deceleration-only.
    3cdc:	20 e0       	ldi	r18, 0x00	; 0
    3cde:	30 e0       	ldi	r19, 0x00	; 0
    3ce0:	a9 01       	movw	r20, r18
    3ce2:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    3ce6:	18 16       	cp	r1, r24
    3ce8:	84 f1       	brlt	.+96     	; 0x3d4a <st_prep_buffer+0x4ae>
            prep.ramp_type = RAMP_DECEL;
    3cea:	22 e0       	ldi	r18, 0x02	; 2
    3cec:	f3 01       	movw	r30, r6
    3cee:	22 8b       	std	Z+18, r18	; 0x12
            // prep.decelerate_after = pl_block->millimeters;
            // prep.maximum_speed = prep.current_speed;

            // Compute override block exit speed since it doesn't match the planner exit speed.
            prep.exit_speed = sqrt(pl_block->entry_speed_sqr - 2*pl_block->acceleration*pl_block->millimeters);
    3cf0:	ad 85       	ldd	r26, Y+13	; 0x0d
    3cf2:	be 85       	ldd	r27, Y+14	; 0x0e
    3cf4:	5e 96       	adiw	r26, 0x1e	; 30
    3cf6:	cd 90       	ld	r12, X+
    3cf8:	dd 90       	ld	r13, X+
    3cfa:	ed 90       	ld	r14, X+
    3cfc:	fc 90       	ld	r15, X
    3cfe:	91 97       	sbiw	r26, 0x21	; 33
    3d00:	a7 01       	movw	r20, r14
    3d02:	96 01       	movw	r18, r12
    3d04:	c7 01       	movw	r24, r14
    3d06:	b6 01       	movw	r22, r12
    3d08:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    3d0c:	ed 85       	ldd	r30, Y+13	; 0x0d
    3d0e:	fe 85       	ldd	r31, Y+14	; 0x0e
    3d10:	22 a1       	ldd	r18, Z+34	; 0x22
    3d12:	33 a1       	ldd	r19, Z+35	; 0x23
    3d14:	44 a1       	ldd	r20, Z+36	; 0x24
    3d16:	55 a1       	ldd	r21, Z+37	; 0x25
    3d18:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    3d1c:	9b 01       	movw	r18, r22
    3d1e:	ac 01       	movw	r20, r24
    3d20:	ad 85       	ldd	r26, Y+13	; 0x0d
    3d22:	be 85       	ldd	r27, Y+14	; 0x0e
    3d24:	56 96       	adiw	r26, 0x16	; 22
    3d26:	6d 91       	ld	r22, X+
    3d28:	7d 91       	ld	r23, X+
    3d2a:	8d 91       	ld	r24, X+
    3d2c:	9c 91       	ld	r25, X
    3d2e:	59 97       	sbiw	r26, 0x19	; 25
    3d30:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    3d34:	0e 94 6b 42 	call	0x84d6	; 0x84d6 <sqrt>
    3d38:	f3 01       	movw	r30, r6
    3d3a:	67 8f       	std	Z+31, r22	; 0x1f
    3d3c:	70 a3       	std	Z+32, r23	; 0x20
    3d3e:	81 a3       	std	Z+33, r24	; 0x21
    3d40:	92 a3       	std	Z+34, r25	; 0x22
            prep.recalculate_flag |= PREP_FLAG_DECEL_OVERRIDE; // Flag to load next block as deceleration override.
    3d42:	81 81       	ldd	r24, Z+1	; 0x01
    3d44:	88 60       	ori	r24, 0x08	; 8
    3d46:	81 83       	std	Z+1, r24	; 0x01
    3d48:	e6 c0       	rjmp	.+460    	; 0x3f16 <st_prep_buffer+0x67a>
            // Can be tricky since entry speed will be current speed, as in feed holds.
            // Also, look into near-zero speed handling issues with this.

          } else {
            // Decelerate to cruise or cruise-decelerate types. Guaranteed to intersect updated plan.
            prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
    3d4a:	29 85       	ldd	r18, Y+9	; 0x09
    3d4c:	3a 85       	ldd	r19, Y+10	; 0x0a
    3d4e:	4b 85       	ldd	r20, Y+11	; 0x0b
    3d50:	5c 85       	ldd	r21, Y+12	; 0x0c
    3d52:	6d 81       	ldd	r22, Y+5	; 0x05
    3d54:	7e 81       	ldd	r23, Y+6	; 0x06
    3d56:	8f 81       	ldd	r24, Y+7	; 0x07
    3d58:	98 85       	ldd	r25, Y+8	; 0x08
    3d5a:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    3d5e:	29 81       	ldd	r18, Y+1	; 0x01
    3d60:	3a 81       	ldd	r19, Y+2	; 0x02
    3d62:	4b 81       	ldd	r20, Y+3	; 0x03
    3d64:	5c 81       	ldd	r21, Y+4	; 0x04
    3d66:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    3d6a:	d3 01       	movw	r26, r6
    3d6c:	97 96       	adiw	r26, 0x27	; 39
    3d6e:	6d 93       	st	X+, r22
    3d70:	7d 93       	st	X+, r23
    3d72:	8d 93       	st	X+, r24
    3d74:	9c 93       	st	X, r25
    3d76:	9a 97       	sbiw	r26, 0x2a	; 42
            prep.maximum_speed = nominal_speed;
    3d78:	f3 01       	movw	r30, r6
    3d7a:	83 8e       	std	Z+27, r8	; 0x1b
    3d7c:	94 8e       	std	Z+28, r9	; 0x1c
    3d7e:	a5 8e       	std	Z+29, r10	; 0x1d
    3d80:	b6 8e       	std	Z+30, r11	; 0x1e
            prep.ramp_type = RAMP_DECEL_OVERRIDE;
    3d82:	23 e0       	ldi	r18, 0x03	; 3
    3d84:	22 8b       	std	Z+18, r18	; 0x12
    3d86:	c7 c0       	rjmp	.+398    	; 0x3f16 <st_prep_buffer+0x67a>
          prep.exit_speed = sqrt(exit_speed_sqr);
        }

        nominal_speed = plan_compute_profile_nominal_speed(pl_block);
				float nominal_speed_sqr = nominal_speed*nominal_speed;
				float intersect_distance =
    3d88:	29 85       	ldd	r18, Y+9	; 0x09
    3d8a:	3a 85       	ldd	r19, Y+10	; 0x0a
    3d8c:	4b 85       	ldd	r20, Y+11	; 0x0b
    3d8e:	5c 85       	ldd	r21, Y+12	; 0x0c
    3d90:	c2 01       	movw	r24, r4
    3d92:	b1 01       	movw	r22, r2
    3d94:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    3d98:	29 81       	ldd	r18, Y+1	; 0x01
    3d9a:	3a 81       	ldd	r19, Y+2	; 0x02
    3d9c:	4b 81       	ldd	r20, Y+3	; 0x03
    3d9e:	5c 81       	ldd	r21, Y+4	; 0x04
    3da0:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    3da4:	a7 01       	movw	r20, r14
    3da6:	96 01       	movw	r18, r12
    3da8:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    3dac:	20 e0       	ldi	r18, 0x00	; 0
    3dae:	30 e0       	ldi	r19, 0x00	; 0
    3db0:	40 e0       	ldi	r20, 0x00	; 0
    3db2:	5f e3       	ldi	r21, 0x3F	; 63
    3db4:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    3db8:	1b 01       	movw	r2, r22
    3dba:	2c 01       	movw	r4, r24
            // Decelerate to cruise or cruise-decelerate types. Guaranteed to intersect updated plan.
            prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
            prep.maximum_speed = nominal_speed;
            prep.ramp_type = RAMP_DECEL_OVERRIDE;
          }
				} else if (intersect_distance > 0.0) {
    3dbc:	20 e0       	ldi	r18, 0x00	; 0
    3dbe:	30 e0       	ldi	r19, 0x00	; 0
    3dc0:	a9 01       	movw	r20, r18
    3dc2:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    3dc6:	18 16       	cp	r1, r24
    3dc8:	0c f0       	brlt	.+2      	; 0x3dcc <st_prep_buffer+0x530>
    3dca:	93 c0       	rjmp	.+294    	; 0x3ef2 <st_prep_buffer+0x656>
					if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
    3dcc:	a2 01       	movw	r20, r4
    3dce:	91 01       	movw	r18, r2
    3dd0:	c7 01       	movw	r24, r14
    3dd2:	b6 01       	movw	r22, r12
    3dd4:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    3dd8:	18 16       	cp	r1, r24
    3dda:	0c f0       	brlt	.+2      	; 0x3dde <st_prep_buffer+0x542>
    3ddc:	85 c0       	rjmp	.+266    	; 0x3ee8 <st_prep_buffer+0x64c>
						// NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
						prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
    3dde:	29 85       	ldd	r18, Y+9	; 0x09
    3de0:	3a 85       	ldd	r19, Y+10	; 0x0a
    3de2:	4b 85       	ldd	r20, Y+11	; 0x0b
    3de4:	5c 85       	ldd	r21, Y+12	; 0x0c
    3de6:	6d 81       	ldd	r22, Y+5	; 0x05
    3de8:	7e 81       	ldd	r23, Y+6	; 0x06
    3dea:	8f 81       	ldd	r24, Y+7	; 0x07
    3dec:	98 85       	ldd	r25, Y+8	; 0x08
    3dee:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    3df2:	29 81       	ldd	r18, Y+1	; 0x01
    3df4:	3a 81       	ldd	r19, Y+2	; 0x02
    3df6:	4b 81       	ldd	r20, Y+3	; 0x03
    3df8:	5c 81       	ldd	r21, Y+4	; 0x04
    3dfa:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    3dfe:	9b 01       	movw	r18, r22
    3e00:	ac 01       	movw	r20, r24
    3e02:	d3 01       	movw	r26, r6
    3e04:	97 96       	adiw	r26, 0x27	; 39
    3e06:	6d 93       	st	X+, r22
    3e08:	7d 93       	st	X+, r23
    3e0a:	8d 93       	st	X+, r24
    3e0c:	9c 93       	st	X, r25
    3e0e:	9a 97       	sbiw	r26, 0x2a	; 42
						if (prep.decelerate_after < intersect_distance) { // Trapezoid type
    3e10:	c2 01       	movw	r24, r4
    3e12:	b1 01       	movw	r22, r2
    3e14:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    3e18:	18 16       	cp	r1, r24
    3e1a:	d4 f5       	brge	.+116    	; 0x3e90 <st_prep_buffer+0x5f4>
							prep.maximum_speed = nominal_speed;
    3e1c:	f3 01       	movw	r30, r6
    3e1e:	83 8e       	std	Z+27, r8	; 0x1b
    3e20:	94 8e       	std	Z+28, r9	; 0x1c
    3e22:	a5 8e       	std	Z+29, r10	; 0x1d
    3e24:	b6 8e       	std	Z+30, r11	; 0x1e
							if (pl_block->entry_speed_sqr == nominal_speed_sqr) {
    3e26:	ad 85       	ldd	r26, Y+13	; 0x0d
    3e28:	be 85       	ldd	r27, Y+14	; 0x0e
    3e2a:	56 96       	adiw	r26, 0x16	; 22
    3e2c:	2d 90       	ld	r2, X+
    3e2e:	3d 90       	ld	r3, X+
    3e30:	4d 90       	ld	r4, X+
    3e32:	5c 90       	ld	r5, X
    3e34:	59 97       	sbiw	r26, 0x19	; 25
    3e36:	a2 01       	movw	r20, r4
    3e38:	91 01       	movw	r18, r2
    3e3a:	6d 81       	ldd	r22, Y+5	; 0x05
    3e3c:	7e 81       	ldd	r23, Y+6	; 0x06
    3e3e:	8f 81       	ldd	r24, Y+7	; 0x07
    3e40:	98 85       	ldd	r25, Y+8	; 0x08
    3e42:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    3e46:	81 11       	cpse	r24, r1
    3e48:	04 c0       	rjmp	.+8      	; 0x3e52 <st_prep_buffer+0x5b6>
								// Cruise-deceleration or cruise-only type.
								prep.ramp_type = RAMP_CRUISE;
    3e4a:	21 e0       	ldi	r18, 0x01	; 1
    3e4c:	f3 01       	movw	r30, r6
    3e4e:	22 8b       	std	Z+18, r18	; 0x12
    3e50:	62 c0       	rjmp	.+196    	; 0x3f16 <st_prep_buffer+0x67a>
							} else {
								// Full-trapezoid or acceleration-cruise types
								prep.accelerate_until -= inv_2_accel*(nominal_speed_sqr-pl_block->entry_speed_sqr);
    3e52:	a2 01       	movw	r20, r4
    3e54:	91 01       	movw	r18, r2
    3e56:	6d 81       	ldd	r22, Y+5	; 0x05
    3e58:	7e 81       	ldd	r23, Y+6	; 0x06
    3e5a:	8f 81       	ldd	r24, Y+7	; 0x07
    3e5c:	98 85       	ldd	r25, Y+8	; 0x08
    3e5e:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    3e62:	29 81       	ldd	r18, Y+1	; 0x01
    3e64:	3a 81       	ldd	r19, Y+2	; 0x02
    3e66:	4b 81       	ldd	r20, Y+3	; 0x03
    3e68:	5c 81       	ldd	r21, Y+4	; 0x04
    3e6a:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    3e6e:	9b 01       	movw	r18, r22
    3e70:	ac 01       	movw	r20, r24
    3e72:	d3 01       	movw	r26, r6
    3e74:	93 96       	adiw	r26, 0x23	; 35
    3e76:	6d 91       	ld	r22, X+
    3e78:	7d 91       	ld	r23, X+
    3e7a:	8d 91       	ld	r24, X+
    3e7c:	9c 91       	ld	r25, X
    3e7e:	96 97       	sbiw	r26, 0x26	; 38
    3e80:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    3e84:	f3 01       	movw	r30, r6
    3e86:	63 a3       	std	Z+35, r22	; 0x23
    3e88:	74 a3       	std	Z+36, r23	; 0x24
    3e8a:	85 a3       	std	Z+37, r24	; 0x25
    3e8c:	96 a3       	std	Z+38, r25	; 0x26
    3e8e:	43 c0       	rjmp	.+134    	; 0x3f16 <st_prep_buffer+0x67a>
							}
						} else { // Triangle type
							prep.accelerate_until = intersect_distance;
    3e90:	d3 01       	movw	r26, r6
    3e92:	93 96       	adiw	r26, 0x23	; 35
    3e94:	2d 92       	st	X+, r2
    3e96:	3d 92       	st	X+, r3
    3e98:	4d 92       	st	X+, r4
    3e9a:	5c 92       	st	X, r5
    3e9c:	96 97       	sbiw	r26, 0x26	; 38
							prep.decelerate_after = intersect_distance;
    3e9e:	f3 01       	movw	r30, r6
    3ea0:	27 a2       	std	Z+39, r2	; 0x27
    3ea2:	30 a6       	std	Z+40, r3	; 0x28
    3ea4:	41 a6       	std	Z+41, r4	; 0x29
    3ea6:	52 a6       	std	Z+42, r5	; 0x2a
							prep.maximum_speed = sqrt(2.0*pl_block->acceleration*intersect_distance+exit_speed_sqr);
    3ea8:	ad 85       	ldd	r26, Y+13	; 0x0d
    3eaa:	be 85       	ldd	r27, Y+14	; 0x0e
    3eac:	5e 96       	adiw	r26, 0x1e	; 30
    3eae:	cd 90       	ld	r12, X+
    3eb0:	dd 90       	ld	r13, X+
    3eb2:	ed 90       	ld	r14, X+
    3eb4:	fc 90       	ld	r15, X
    3eb6:	91 97       	sbiw	r26, 0x21	; 33
    3eb8:	a7 01       	movw	r20, r14
    3eba:	96 01       	movw	r18, r12
    3ebc:	c7 01       	movw	r24, r14
    3ebe:	b6 01       	movw	r22, r12
    3ec0:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    3ec4:	a2 01       	movw	r20, r4
    3ec6:	91 01       	movw	r18, r2
    3ec8:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    3ecc:	29 85       	ldd	r18, Y+9	; 0x09
    3ece:	3a 85       	ldd	r19, Y+10	; 0x0a
    3ed0:	4b 85       	ldd	r20, Y+11	; 0x0b
    3ed2:	5c 85       	ldd	r21, Y+12	; 0x0c
    3ed4:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    3ed8:	0e 94 6b 42 	call	0x84d6	; 0x84d6 <sqrt>
    3edc:	f3 01       	movw	r30, r6
    3ede:	63 8f       	std	Z+27, r22	; 0x1b
    3ee0:	74 8f       	std	Z+28, r23	; 0x1c
    3ee2:	85 8f       	std	Z+29, r24	; 0x1d
    3ee4:	96 8f       	std	Z+30, r25	; 0x1e
    3ee6:	17 c0       	rjmp	.+46     	; 0x3f16 <st_prep_buffer+0x67a>
						}
					} else { // Deceleration-only type
            prep.ramp_type = RAMP_DECEL;
    3ee8:	e2 e0       	ldi	r30, 0x02	; 2
    3eea:	d3 01       	movw	r26, r6
    3eec:	52 96       	adiw	r26, 0x12	; 18
    3eee:	ec 93       	st	X, r30
    3ef0:	12 c0       	rjmp	.+36     	; 0x3f16 <st_prep_buffer+0x67a>
            // prep.decelerate_after = pl_block->millimeters;
            // prep.maximum_speed = prep.current_speed;
					}
				} else { // Acceleration-only type
					prep.accelerate_until = 0.0;
    3ef2:	d3 01       	movw	r26, r6
    3ef4:	93 96       	adiw	r26, 0x23	; 35
    3ef6:	1d 92       	st	X+, r1
    3ef8:	1d 92       	st	X+, r1
    3efa:	1d 92       	st	X+, r1
    3efc:	1c 92       	st	X, r1
    3efe:	96 97       	sbiw	r26, 0x26	; 38
					// prep.decelerate_after = 0.0;
					prep.maximum_speed = prep.exit_speed;
    3f00:	5f 96       	adiw	r26, 0x1f	; 31
    3f02:	8d 91       	ld	r24, X+
    3f04:	9d 91       	ld	r25, X+
    3f06:	0d 90       	ld	r0, X+
    3f08:	bc 91       	ld	r27, X
    3f0a:	a0 2d       	mov	r26, r0
    3f0c:	f3 01       	movw	r30, r6
    3f0e:	83 8f       	std	Z+27, r24	; 0x1b
    3f10:	94 8f       	std	Z+28, r25	; 0x1c
    3f12:	a5 8f       	std	Z+29, r26	; 0x1d
    3f14:	b6 8f       	std	Z+30, r27	; 0x1e
				}
			}
      
      bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM); // Force update whenever updating block.
    3f16:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    3f1a:	88 60       	ori	r24, 0x08	; 8
    3f1c:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <sys+0x4>
    }
    
    // Initialize new segment
    segment_t *prep_segment = &segment_buffer[segment_buffer_head];
    3f20:	e0 91 41 03 	lds	r30, 0x0341	; 0x800341 <segment_buffer_head>
    3f24:	2e 2f       	mov	r18, r30
    3f26:	30 e0       	ldi	r19, 0x00	; 0
    3f28:	3b ab       	std	Y+51, r19	; 0x33
    3f2a:	2a ab       	std	Y+50, r18	; 0x32

    // Set new segment to point to the current segment data block.
    prep_segment->st_block_index = prep.st_block_index;
    3f2c:	f9 01       	movw	r30, r18
    3f2e:	ee 0f       	add	r30, r30
    3f30:	ff 1f       	adc	r31, r31
    3f32:	ee 0f       	add	r30, r30
    3f34:	ff 1f       	adc	r31, r31
    3f36:	ee 0f       	add	r30, r30
    3f38:	ff 1f       	adc	r31, r31
    3f3a:	ea 59       	subi	r30, 0x9A	; 154
    3f3c:	fc 4f       	sbci	r31, 0xFC	; 252
    3f3e:	d3 01       	movw	r26, r6
    3f40:	8c 91       	ld	r24, X
    3f42:	84 83       	std	Z+4, r24	; 0x04
    float dt_max = DT_SEGMENT; // Maximum segment time
    float dt = 0.0; // Initialize segment time
    float time_var = dt_max; // Time worker variable
    float mm_var; // mm-Distance worker variable
    float speed_var; // Speed worker variable
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    3f44:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    3f48:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    3f4c:	fb 8f       	std	Y+27, r31	; 0x1b
    3f4e:	ea 8f       	std	Y+26, r30	; 0x1a
    3f50:	f2 a1       	ldd	r31, Z+34	; 0x22
    3f52:	fa a7       	std	Y+42, r31	; 0x2a
    3f54:	aa 8d       	ldd	r26, Y+26	; 0x1a
    3f56:	bb 8d       	ldd	r27, Y+27	; 0x1b
    3f58:	93 96       	adiw	r26, 0x23	; 35
    3f5a:	bc 91       	ld	r27, X
    3f5c:	bb a7       	std	Y+43, r27	; 0x2b
    3f5e:	ea 8d       	ldd	r30, Y+26	; 0x1a
    3f60:	fb 8d       	ldd	r31, Y+27	; 0x1b
    3f62:	f4 a1       	ldd	r31, Z+36	; 0x24
    3f64:	fc a7       	std	Y+44, r31	; 0x2c
    3f66:	aa 8d       	ldd	r26, Y+26	; 0x1a
    3f68:	bb 8d       	ldd	r27, Y+27	; 0x1b
    3f6a:	95 96       	adiw	r26, 0x25	; 37
    3f6c:	bc 91       	ld	r27, X
    3f6e:	bd a7       	std	Y+45, r27	; 0x2d
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    3f70:	f3 01       	movw	r30, r6
    3f72:	26 85       	ldd	r18, Z+14	; 0x0e
    3f74:	37 85       	ldd	r19, Z+15	; 0x0f
    3f76:	40 89       	ldd	r20, Z+16	; 0x10
    3f78:	51 89       	ldd	r21, Z+17	; 0x11
    3f7a:	6a a5       	ldd	r22, Y+42	; 0x2a
    3f7c:	7b a5       	ldd	r23, Y+43	; 0x2b
    3f7e:	8c a5       	ldd	r24, Y+44	; 0x2c
    3f80:	9b 2f       	mov	r25, r27
    3f82:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    3f86:	6a a3       	std	Y+34, r22	; 0x22
    3f88:	7b a3       	std	Y+35, r23	; 0x23
    3f8a:	8c a3       	std	Y+36, r24	; 0x24
    3f8c:	9d a3       	std	Y+37, r25	; 0x25
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }
    3f8e:	20 e0       	ldi	r18, 0x00	; 0
    3f90:	30 e0       	ldi	r19, 0x00	; 0
    3f92:	a9 01       	movw	r20, r18
    3f94:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    3f98:	88 23       	and	r24, r24
    3f9a:	24 f4       	brge	.+8      	; 0x3fa4 <st_prep_buffer+0x708>
    3f9c:	1a a2       	std	Y+34, r1	; 0x22
    3f9e:	1b a2       	std	Y+35, r1	; 0x23
    3fa0:	1c a2       	std	Y+36, r1	; 0x24
    3fa2:	1d a2       	std	Y+37, r1	; 0x25

    do {
      switch (prep.ramp_type) {
        case RAMP_DECEL_OVERRIDE:
          speed_var = pl_block->acceleration*time_var;
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
    3fa4:	d3 01       	movw	r26, r6
    3fa6:	5b 96       	adiw	r26, 0x1b	; 27
    3fa8:	bc 91       	ld	r27, X
    3faa:	be 8b       	std	Y+22, r27	; 0x16
    3fac:	f3 01       	movw	r30, r6
    3fae:	f4 8d       	ldd	r31, Z+28	; 0x1c
    3fb0:	ff 8b       	std	Y+23, r31	; 0x17
    3fb2:	d3 01       	movw	r26, r6
    3fb4:	5d 96       	adiw	r26, 0x1d	; 29
    3fb6:	bc 91       	ld	r27, X
    3fb8:	b8 8f       	std	Y+24, r27	; 0x18
    3fba:	f3 01       	movw	r30, r6
    3fbc:	f6 8d       	ldd	r31, Z+30	; 0x1e
    3fbe:	f9 8f       	std	Y+25, r31	; 0x19
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
    3fc0:	d3 01       	movw	r26, r6
    3fc2:	93 96       	adiw	r26, 0x23	; 35
    3fc4:	bc 91       	ld	r27, X
    3fc6:	be 8f       	std	Y+30, r27	; 0x1e
    3fc8:	f3 01       	movw	r30, r6
    3fca:	f4 a1       	ldd	r31, Z+36	; 0x24
    3fcc:	ff 8f       	std	Y+31, r31	; 0x1f
    3fce:	d3 01       	movw	r26, r6
    3fd0:	95 96       	adiw	r26, 0x25	; 37
    3fd2:	bc 91       	ld	r27, X
    3fd4:	b8 a3       	std	Y+32, r27	; 0x20
    3fd6:	f3 01       	movw	r30, r6
    3fd8:	f6 a1       	ldd	r31, Z+38	; 0x26
    3fda:	f9 a3       	std	Y+33, r31	; 0x21
    3fdc:	d3 01       	movw	r26, r6
    3fde:	57 96       	adiw	r26, 0x17	; 23
    3fe0:	bc 91       	ld	r27, X
    3fe2:	b9 83       	std	Y+1, r27	; 0x01
    3fe4:	f3 01       	movw	r30, r6
    3fe6:	f0 8d       	ldd	r31, Z+24	; 0x18
    3fe8:	fd 83       	std	Y+5, r31	; 0x05
    3fea:	d3 01       	movw	r26, r6
    3fec:	59 96       	adiw	r26, 0x19	; 25
    3fee:	bc 91       	ld	r27, X
    3ff0:	b9 87       	std	Y+9, r27	; 0x09
    3ff2:	f3 01       	movw	r30, r6
    3ff4:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3ff6:	f9 8b       	std	Y+17, r31	; 0x11
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    3ff8:	d3 01       	movw	r26, r6
    3ffa:	97 96       	adiw	r26, 0x27	; 39
    3ffc:	bc 91       	ld	r27, X
    3ffe:	be a3       	std	Y+38, r27	; 0x26
    4000:	f3 01       	movw	r30, r6
    4002:	f0 a5       	ldd	r31, Z+40	; 0x28
    4004:	ff a3       	std	Y+39, r31	; 0x27
    4006:	d3 01       	movw	r26, r6
    4008:	99 96       	adiw	r26, 0x29	; 41
    400a:	bc 91       	ld	r27, X
    400c:	b8 a7       	std	Y+40, r27	; 0x28
    400e:	f3 01       	movw	r30, r6
    4010:	f2 a5       	ldd	r31, Z+42	; 0x2a
    4012:	f9 a7       	std	Y+41, r31	; 0x29
    4014:	d3 01       	movw	r26, r6
    4016:	52 96       	adiw	r26, 0x12	; 18
    4018:	bc 91       	ld	r27, X
    401a:	bd 8f       	std	Y+29, r27	; 0x1d
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
    401c:	f3 01       	movw	r30, r6
    401e:	f3 89       	ldd	r31, Z+19	; 0x13
    4020:	fa 8b       	std	Y+18, r31	; 0x12
    4022:	d3 01       	movw	r26, r6
    4024:	54 96       	adiw	r26, 0x14	; 20
    4026:	bc 91       	ld	r27, X
    4028:	bb 8b       	std	Y+19, r27	; 0x13
    402a:	f3 01       	movw	r30, r6
    402c:	f5 89       	ldd	r31, Z+21	; 0x15
    402e:	fc 8b       	std	Y+20, r31	; 0x14
    4030:	d3 01       	movw	r26, r6
    4032:	56 96       	adiw	r26, 0x16	; 22
    4034:	bc 91       	ld	r27, X
    4036:	bd 8b       	std	Y+21, r27	; 0x15
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    4038:	f3 01       	movw	r30, r6
    403a:	f7 8d       	ldd	r31, Z+31	; 0x1f
    403c:	fe a7       	std	Y+46, r31	; 0x2e
    403e:	d3 01       	movw	r26, r6
    4040:	90 96       	adiw	r26, 0x20	; 32
    4042:	bc 91       	ld	r27, X
    4044:	bf a7       	std	Y+47, r27	; 0x2f
    4046:	f3 01       	movw	r30, r6
    4048:	f1 a1       	ldd	r31, Z+33	; 0x21
    404a:	f8 ab       	std	Y+48, r31	; 0x30
    404c:	d3 01       	movw	r26, r6
    404e:	92 96       	adiw	r26, 0x22	; 34
    4050:	bc 91       	ld	r27, X
    4052:	b9 ab       	std	Y+49, r27	; 0x31
    4054:	2e a1       	ldd	r18, Y+38	; 0x26
    4056:	3f a1       	ldd	r19, Y+39	; 0x27
    4058:	48 a5       	ldd	r20, Y+40	; 0x28
    405a:	59 a5       	ldd	r21, Y+41	; 0x29
    405c:	6e 8d       	ldd	r22, Y+30	; 0x1e
    405e:	7f 8d       	ldd	r23, Y+31	; 0x1f
    4060:	88 a1       	ldd	r24, Y+32	; 0x20
    4062:	99 a1       	ldd	r25, Y+33	; 0x21
    4064:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    4068:	81 11       	cpse	r24, r1
    406a:	02 c0       	rjmp	.+4      	; 0x4070 <st_prep_buffer+0x7d4>
    406c:	8a ad       	ldd	r24, Y+58	; 0x3a
    406e:	01 c0       	rjmp	.+2      	; 0x4072 <st_prep_buffer+0x7d6>
    4070:	81 e0       	ldi	r24, 0x01	; 1
    4072:	5a a4       	ldd	r5, Y+42	; 0x2a
    4074:	1b a5       	ldd	r17, Y+43	; 0x2b
    4076:	0c a5       	ldd	r16, Y+44	; 0x2c
    4078:	ed a5       	ldd	r30, Y+45	; 0x2d
    407a:	ec 8f       	std	Y+28, r30	; 0x1c
    407c:	0f 2e       	mov	r0, r31
    407e:	fe e3       	ldi	r31, 0x3E	; 62
    4080:	4f 2e       	mov	r4, r31
    4082:	f0 2d       	mov	r31, r0
    4084:	0f 2e       	mov	r0, r31
    4086:	f3 ec       	ldi	r31, 0xC3	; 195
    4088:	3f 2e       	mov	r3, r31
    408a:	f0 2d       	mov	r31, r0
    408c:	0f 2e       	mov	r0, r31
    408e:	fe e2       	ldi	r31, 0x2E	; 46
    4090:	2f 2e       	mov	r2, r31
    4092:	f0 2d       	mov	r31, r0
    4094:	0f 2e       	mov	r0, r31
    4096:	f9 e3       	ldi	r31, 0x39	; 57
    4098:	ff 2e       	mov	r15, r31
    409a:	f0 2d       	mov	r31, r0
    409c:	81 2c       	mov	r8, r1
    409e:	91 2c       	mov	r9, r1
    40a0:	54 01       	movw	r10, r8
    40a2:	0f 2e       	mov	r0, r31
    40a4:	fe e3       	ldi	r31, 0x3E	; 62
    40a6:	cf 2e       	mov	r12, r31
    40a8:	f0 2d       	mov	r31, r0
    40aa:	0f 2e       	mov	r0, r31
    40ac:	f3 ec       	ldi	r31, 0xC3	; 195
    40ae:	df 2e       	mov	r13, r31
    40b0:	f0 2d       	mov	r31, r0
    40b2:	0f 2e       	mov	r0, r31
    40b4:	fe e2       	ldi	r31, 0x2E	; 46
    40b6:	ef 2e       	mov	r14, r31
    40b8:	f0 2d       	mov	r31, r0
    40ba:	f9 e3       	ldi	r31, 0x39	; 57
    40bc:	fd 87       	std	Y+13, r31	; 0x0d
    40be:	8d ab       	std	Y+53, r24	; 0x35
    40c0:	2d 8d       	ldd	r18, Y+29	; 0x1d
    40c2:	2c af       	std	Y+60, r18	; 0x3c
    40c4:	7f aa       	std	Y+55, r7	; 0x37
    40c6:	6e aa       	std	Y+54, r6	; 0x36
    40c8:	7c 2c       	mov	r7, r12
    40ca:	81 2f       	mov	r24, r17
    40cc:	1e 2d       	mov	r17, r14
    40ce:	e5 2c       	mov	r14, r5
    40d0:	5d 2c       	mov	r5, r13
    40d2:	c0 2e       	mov	r12, r16
    40d4:	09 e3       	ldi	r16, 0x39	; 57
    40d6:	fb ae       	std	Y+59, r15	; 0x3b
    40d8:	fe 2e       	mov	r15, r30
    40da:	d8 2e       	mov	r13, r24
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }

    do {
      switch (prep.ramp_type) {
    40dc:	3c ad       	ldd	r19, Y+60	; 0x3c
    40de:	31 30       	cpi	r19, 0x01	; 1
    40e0:	09 f4       	brne	.+2      	; 0x40e4 <st_prep_buffer+0x848>
    40e2:	0f c1       	rjmp	.+542    	; 0x4302 <st_prep_buffer+0xa66>
    40e4:	08 f4       	brcc	.+2      	; 0x40e8 <st_prep_buffer+0x84c>
    40e6:	8f c0       	rjmp	.+286    	; 0x4206 <st_prep_buffer+0x96a>
    40e8:	33 30       	cpi	r19, 0x03	; 3
    40ea:	09 f0       	breq	.+2      	; 0x40ee <st_prep_buffer+0x852>
    40ec:	48 c1       	rjmp	.+656    	; 0x437e <st_prep_buffer+0xae2>
        case RAMP_DECEL_OVERRIDE:
          speed_var = pl_block->acceleration*time_var;
    40ee:	aa 8d       	ldd	r26, Y+26	; 0x1a
    40f0:	bb 8d       	ldd	r27, Y+27	; 0x1b
    40f2:	5e 96       	adiw	r26, 0x1e	; 30
    40f4:	2d 91       	ld	r18, X+
    40f6:	3d 91       	ld	r19, X+
    40f8:	4d 91       	ld	r20, X+
    40fa:	5c 91       	ld	r21, X
    40fc:	91 97       	sbiw	r26, 0x21	; 33
    40fe:	64 2d       	mov	r22, r4
    4100:	73 2d       	mov	r23, r3
    4102:	82 2d       	mov	r24, r2
    4104:	9b ad       	ldd	r25, Y+59	; 0x3b
    4106:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    410a:	6d 87       	std	Y+13, r22	; 0x0d
    410c:	7e 87       	std	Y+14, r23	; 0x0e
    410e:	8f 87       	std	Y+15, r24	; 0x0f
    4110:	98 8b       	std	Y+16, r25	; 0x10
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
    4112:	2e 89       	ldd	r18, Y+22	; 0x16
    4114:	3f 89       	ldd	r19, Y+23	; 0x17
    4116:	48 8d       	ldd	r20, Y+24	; 0x18
    4118:	59 8d       	ldd	r21, Y+25	; 0x19
    411a:	69 81       	ldd	r22, Y+1	; 0x01
    411c:	7d 81       	ldd	r23, Y+5	; 0x05
    411e:	89 85       	ldd	r24, Y+9	; 0x09
    4120:	99 89       	ldd	r25, Y+17	; 0x11
    4122:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    4126:	9b 01       	movw	r18, r22
    4128:	ac 01       	movw	r20, r24
    412a:	6d 85       	ldd	r22, Y+13	; 0x0d
    412c:	7e 85       	ldd	r23, Y+14	; 0x0e
    412e:	8f 85       	ldd	r24, Y+15	; 0x0f
    4130:	98 89       	ldd	r25, Y+16	; 0x10
    4132:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    4136:	88 23       	and	r24, r24
    4138:	9c f1       	brlt	.+102    	; 0x41a0 <st_prep_buffer+0x904>
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    413a:	2e 8d       	ldd	r18, Y+30	; 0x1e
    413c:	3f 8d       	ldd	r19, Y+31	; 0x1f
    413e:	48 a1       	ldd	r20, Y+32	; 0x20
    4140:	59 a1       	ldd	r21, Y+33	; 0x21
    4142:	6a a5       	ldd	r22, Y+42	; 0x2a
    4144:	7b a5       	ldd	r23, Y+43	; 0x2b
    4146:	8c a5       	ldd	r24, Y+44	; 0x2c
    4148:	9d a5       	ldd	r25, Y+45	; 0x2d
    414a:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    414e:	9b 01       	movw	r18, r22
    4150:	ac 01       	movw	r20, r24
    4152:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    4156:	6b 01       	movw	r12, r22
    4158:	7c 01       	movw	r14, r24
    415a:	29 81       	ldd	r18, Y+1	; 0x01
    415c:	3d 81       	ldd	r19, Y+5	; 0x05
    415e:	49 85       	ldd	r20, Y+9	; 0x09
    4160:	59 89       	ldd	r21, Y+17	; 0x11
    4162:	6e 89       	ldd	r22, Y+22	; 0x16
    4164:	7f 89       	ldd	r23, Y+23	; 0x17
    4166:	88 8d       	ldd	r24, Y+24	; 0x18
    4168:	99 8d       	ldd	r25, Y+25	; 0x19
    416a:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    416e:	9b 01       	movw	r18, r22
    4170:	ac 01       	movw	r20, r24
    4172:	c7 01       	movw	r24, r14
    4174:	b6 01       	movw	r22, r12
    4176:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <__divsf3>
    417a:	46 2e       	mov	r4, r22
    417c:	37 2e       	mov	r3, r23
    417e:	28 2e       	mov	r2, r24
    4180:	9b af       	std	Y+59, r25	; 0x3b
            prep.ramp_type = RAMP_CRUISE;
            prep.current_speed = prep.maximum_speed;
    4182:	be 89       	ldd	r27, Y+22	; 0x16
    4184:	b9 83       	std	Y+1, r27	; 0x01
    4186:	ef 89       	ldd	r30, Y+23	; 0x17
    4188:	ed 83       	std	Y+5, r30	; 0x05
    418a:	f8 8d       	ldd	r31, Y+24	; 0x18
    418c:	f9 87       	std	Y+9, r31	; 0x09
    418e:	29 8d       	ldd	r18, Y+25	; 0x19
    4190:	29 8b       	std	Y+17, r18	; 0x11
      switch (prep.ramp_type) {
        case RAMP_DECEL_OVERRIDE:
          speed_var = pl_block->acceleration*time_var;
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
    4192:	ee 8c       	ldd	r14, Y+30	; 0x1e
    4194:	df 8c       	ldd	r13, Y+31	; 0x1f
    4196:	c8 a0       	ldd	r12, Y+32	; 0x20
    4198:	f9 a0       	ldd	r15, Y+33	; 0x21
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            prep.ramp_type = RAMP_CRUISE;
    419a:	38 ad       	ldd	r19, Y+56	; 0x38
    419c:	3c af       	std	Y+60, r19	; 0x3c
    419e:	80 c1       	rjmp	.+768    	; 0x44a0 <st_prep_buffer+0xc04>
            prep.current_speed = prep.maximum_speed;
          } else { // Mid-deceleration override ramp.
            mm_remaining -= time_var*(prep.current_speed - 0.5*speed_var);
    41a0:	20 e0       	ldi	r18, 0x00	; 0
    41a2:	30 e0       	ldi	r19, 0x00	; 0
    41a4:	40 e0       	ldi	r20, 0x00	; 0
    41a6:	5f e3       	ldi	r21, 0x3F	; 63
    41a8:	6d 85       	ldd	r22, Y+13	; 0x0d
    41aa:	7e 85       	ldd	r23, Y+14	; 0x0e
    41ac:	8f 85       	ldd	r24, Y+15	; 0x0f
    41ae:	98 89       	ldd	r25, Y+16	; 0x10
    41b0:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    41b4:	9b 01       	movw	r18, r22
    41b6:	ac 01       	movw	r20, r24
    41b8:	69 81       	ldd	r22, Y+1	; 0x01
    41ba:	7d 81       	ldd	r23, Y+5	; 0x05
    41bc:	89 85       	ldd	r24, Y+9	; 0x09
    41be:	99 89       	ldd	r25, Y+17	; 0x11
    41c0:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    41c4:	24 2d       	mov	r18, r4
    41c6:	33 2d       	mov	r19, r3
    41c8:	42 2d       	mov	r20, r2
    41ca:	5b ad       	ldd	r21, Y+59	; 0x3b
    41cc:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    41d0:	9b 01       	movw	r18, r22
    41d2:	ac 01       	movw	r20, r24
    41d4:	6e 2d       	mov	r22, r14
    41d6:	7d 2d       	mov	r23, r13
    41d8:	8c 2d       	mov	r24, r12
    41da:	9f 2d       	mov	r25, r15
    41dc:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    41e0:	e6 2e       	mov	r14, r22
    41e2:	d7 2e       	mov	r13, r23
    41e4:	c8 2e       	mov	r12, r24
    41e6:	f9 2e       	mov	r15, r25
            prep.current_speed -= speed_var;
    41e8:	2d 85       	ldd	r18, Y+13	; 0x0d
    41ea:	3e 85       	ldd	r19, Y+14	; 0x0e
    41ec:	4f 85       	ldd	r20, Y+15	; 0x0f
    41ee:	58 89       	ldd	r21, Y+16	; 0x10
    41f0:	69 81       	ldd	r22, Y+1	; 0x01
    41f2:	7d 81       	ldd	r23, Y+5	; 0x05
    41f4:	89 85       	ldd	r24, Y+9	; 0x09
    41f6:	99 89       	ldd	r25, Y+17	; 0x11
    41f8:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    41fc:	69 83       	std	Y+1, r22	; 0x01
    41fe:	7d 83       	std	Y+5, r23	; 0x05
    4200:	89 87       	std	Y+9, r24	; 0x09
    4202:	99 8b       	std	Y+17, r25	; 0x11
    4204:	4d c1       	rjmp	.+666    	; 0x44a0 <st_prep_buffer+0xc04>
          }
          break;
        case RAMP_ACCEL:
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
    4206:	aa 8d       	ldd	r26, Y+26	; 0x1a
    4208:	bb 8d       	ldd	r27, Y+27	; 0x1b
    420a:	5e 96       	adiw	r26, 0x1e	; 30
    420c:	2d 91       	ld	r18, X+
    420e:	3d 91       	ld	r19, X+
    4210:	4d 91       	ld	r20, X+
    4212:	5c 91       	ld	r21, X
    4214:	91 97       	sbiw	r26, 0x21	; 33
    4216:	64 2d       	mov	r22, r4
    4218:	73 2d       	mov	r23, r3
    421a:	82 2d       	mov	r24, r2
    421c:	9b ad       	ldd	r25, Y+59	; 0x3b
    421e:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    4222:	6d 87       	std	Y+13, r22	; 0x0d
    4224:	7e 87       	std	Y+14, r23	; 0x0e
    4226:	8f 87       	std	Y+15, r24	; 0x0f
    4228:	98 8b       	std	Y+16, r25	; 0x10
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
    422a:	20 e0       	ldi	r18, 0x00	; 0
    422c:	30 e0       	ldi	r19, 0x00	; 0
    422e:	40 e0       	ldi	r20, 0x00	; 0
    4230:	5f e3       	ldi	r21, 0x3F	; 63
    4232:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    4236:	29 81       	ldd	r18, Y+1	; 0x01
    4238:	3d 81       	ldd	r19, Y+5	; 0x05
    423a:	49 85       	ldd	r20, Y+9	; 0x09
    423c:	59 89       	ldd	r21, Y+17	; 0x11
    423e:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    4242:	24 2d       	mov	r18, r4
    4244:	33 2d       	mov	r19, r3
    4246:	42 2d       	mov	r20, r2
    4248:	5b ad       	ldd	r21, Y+59	; 0x3b
    424a:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    424e:	9b 01       	movw	r18, r22
    4250:	ac 01       	movw	r20, r24
    4252:	6e 2d       	mov	r22, r14
    4254:	7d 2d       	mov	r23, r13
    4256:	8c 2d       	mov	r24, r12
    4258:	9f 2d       	mov	r25, r15
    425a:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    425e:	e6 2e       	mov	r14, r22
    4260:	d7 2e       	mov	r13, r23
    4262:	c8 2e       	mov	r12, r24
    4264:	f9 2e       	mov	r15, r25
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    4266:	26 2f       	mov	r18, r22
    4268:	37 2f       	mov	r19, r23
    426a:	48 2f       	mov	r20, r24
    426c:	59 2f       	mov	r21, r25
    426e:	6e 8d       	ldd	r22, Y+30	; 0x1e
    4270:	7f 8d       	ldd	r23, Y+31	; 0x1f
    4272:	88 a1       	ldd	r24, Y+32	; 0x20
    4274:	99 a1       	ldd	r25, Y+33	; 0x21
    4276:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    427a:	18 16       	cp	r1, r24
    427c:	9c f5       	brge	.+102    	; 0x42e4 <st_prep_buffer+0xa48>
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    427e:	2e 8d       	ldd	r18, Y+30	; 0x1e
    4280:	3f 8d       	ldd	r19, Y+31	; 0x1f
    4282:	48 a1       	ldd	r20, Y+32	; 0x20
    4284:	59 a1       	ldd	r21, Y+33	; 0x21
    4286:	6a a5       	ldd	r22, Y+42	; 0x2a
    4288:	7b a5       	ldd	r23, Y+43	; 0x2b
    428a:	8c a5       	ldd	r24, Y+44	; 0x2c
    428c:	9d a5       	ldd	r25, Y+45	; 0x2d
    428e:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    4292:	9b 01       	movw	r18, r22
    4294:	ac 01       	movw	r20, r24
    4296:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    429a:	6b 01       	movw	r12, r22
    429c:	7c 01       	movw	r14, r24
    429e:	29 81       	ldd	r18, Y+1	; 0x01
    42a0:	3d 81       	ldd	r19, Y+5	; 0x05
    42a2:	49 85       	ldd	r20, Y+9	; 0x09
    42a4:	59 89       	ldd	r21, Y+17	; 0x11
    42a6:	6e 89       	ldd	r22, Y+22	; 0x16
    42a8:	7f 89       	ldd	r23, Y+23	; 0x17
    42aa:	88 8d       	ldd	r24, Y+24	; 0x18
    42ac:	99 8d       	ldd	r25, Y+25	; 0x19
    42ae:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    42b2:	9b 01       	movw	r18, r22
    42b4:	ac 01       	movw	r20, r24
    42b6:	c7 01       	movw	r24, r14
    42b8:	b6 01       	movw	r22, r12
    42ba:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <__divsf3>
    42be:	46 2e       	mov	r4, r22
    42c0:	37 2e       	mov	r3, r23
    42c2:	28 2e       	mov	r2, r24
    42c4:	9b af       	std	Y+59, r25	; 0x3b
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
    42c6:	be 89       	ldd	r27, Y+22	; 0x16
    42c8:	b9 83       	std	Y+1, r27	; 0x01
    42ca:	ef 89       	ldd	r30, Y+23	; 0x17
    42cc:	ed 83       	std	Y+5, r30	; 0x05
    42ce:	f8 8d       	ldd	r31, Y+24	; 0x18
    42d0:	f9 87       	std	Y+9, r31	; 0x09
    42d2:	29 8d       	ldd	r18, Y+25	; 0x19
    42d4:	29 8b       	std	Y+17, r18	; 0x11
    42d6:	3d a9       	ldd	r19, Y+53	; 0x35
    42d8:	3c af       	std	Y+60, r19	; 0x3c
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
    42da:	ee 8c       	ldd	r14, Y+30	; 0x1e
    42dc:	df 8c       	ldd	r13, Y+31	; 0x1f
    42de:	c8 a0       	ldd	r12, Y+32	; 0x20
    42e0:	f9 a0       	ldd	r15, Y+33	; 0x21
    42e2:	de c0       	rjmp	.+444    	; 0x44a0 <st_prep_buffer+0xc04>
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
          } else { // Acceleration only.
            prep.current_speed += speed_var;
    42e4:	2d 85       	ldd	r18, Y+13	; 0x0d
    42e6:	3e 85       	ldd	r19, Y+14	; 0x0e
    42e8:	4f 85       	ldd	r20, Y+15	; 0x0f
    42ea:	58 89       	ldd	r21, Y+16	; 0x10
    42ec:	69 81       	ldd	r22, Y+1	; 0x01
    42ee:	7d 81       	ldd	r23, Y+5	; 0x05
    42f0:	89 85       	ldd	r24, Y+9	; 0x09
    42f2:	99 89       	ldd	r25, Y+17	; 0x11
    42f4:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    42f8:	69 83       	std	Y+1, r22	; 0x01
    42fa:	7d 83       	std	Y+5, r23	; 0x05
    42fc:	89 87       	std	Y+9, r24	; 0x09
    42fe:	99 8b       	std	Y+17, r25	; 0x11
    4300:	cf c0       	rjmp	.+414    	; 0x44a0 <st_prep_buffer+0xc04>
          break;
        case RAMP_CRUISE:
          // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
          // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To
          //   prevent this, simply enforce a minimum speed threshold in the planner.
          mm_var = mm_remaining - prep.maximum_speed*time_var;
    4302:	2e 89       	ldd	r18, Y+22	; 0x16
    4304:	3f 89       	ldd	r19, Y+23	; 0x17
    4306:	48 8d       	ldd	r20, Y+24	; 0x18
    4308:	59 8d       	ldd	r21, Y+25	; 0x19
    430a:	64 2d       	mov	r22, r4
    430c:	73 2d       	mov	r23, r3
    430e:	82 2d       	mov	r24, r2
    4310:	9b ad       	ldd	r25, Y+59	; 0x3b
    4312:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    4316:	9b 01       	movw	r18, r22
    4318:	ac 01       	movw	r20, r24
    431a:	6e 2d       	mov	r22, r14
    431c:	7d 2d       	mov	r23, r13
    431e:	8c 2d       	mov	r24, r12
    4320:	9f 2d       	mov	r25, r15
    4322:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    4326:	6d 87       	std	Y+13, r22	; 0x0d
    4328:	7c 8f       	std	Y+28, r23	; 0x1c
    432a:	8d 8f       	std	Y+29, r24	; 0x1d
    432c:	69 2e       	mov	r6, r25
          if (mm_var < prep.decelerate_after) { // End of cruise.
    432e:	26 2f       	mov	r18, r22
    4330:	37 2f       	mov	r19, r23
    4332:	48 2f       	mov	r20, r24
    4334:	59 2f       	mov	r21, r25
    4336:	6e a1       	ldd	r22, Y+38	; 0x26
    4338:	7f a1       	ldd	r23, Y+39	; 0x27
    433a:	88 a5       	ldd	r24, Y+40	; 0x28
    433c:	99 a5       	ldd	r25, Y+41	; 0x29
    433e:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    4342:	18 16       	cp	r1, r24
    4344:	0c f0       	brlt	.+2      	; 0x4348 <st_prep_buffer+0xaac>
    4346:	a8 c0       	rjmp	.+336    	; 0x4498 <st_prep_buffer+0xbfc>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
    4348:	2e a1       	ldd	r18, Y+38	; 0x26
    434a:	3f a1       	ldd	r19, Y+39	; 0x27
    434c:	48 a5       	ldd	r20, Y+40	; 0x28
    434e:	59 a5       	ldd	r21, Y+41	; 0x29
    4350:	6e 2d       	mov	r22, r14
    4352:	7d 2d       	mov	r23, r13
    4354:	8c 2d       	mov	r24, r12
    4356:	9f 2d       	mov	r25, r15
    4358:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    435c:	2e 89       	ldd	r18, Y+22	; 0x16
    435e:	3f 89       	ldd	r19, Y+23	; 0x17
    4360:	48 8d       	ldd	r20, Y+24	; 0x18
    4362:	59 8d       	ldd	r21, Y+25	; 0x19
    4364:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <__divsf3>
    4368:	46 2e       	mov	r4, r22
    436a:	37 2e       	mov	r3, r23
    436c:	28 2e       	mov	r2, r24
    436e:	9b af       	std	Y+59, r25	; 0x3b
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
    4370:	ee a0       	ldd	r14, Y+38	; 0x26
    4372:	df a0       	ldd	r13, Y+39	; 0x27
    4374:	c8 a4       	ldd	r12, Y+40	; 0x28
    4376:	f9 a4       	ldd	r15, Y+41	; 0x29
            prep.ramp_type = RAMP_DECEL;
    4378:	49 ad       	ldd	r20, Y+57	; 0x39
    437a:	4c af       	std	Y+60, r20	; 0x3c
    437c:	91 c0       	rjmp	.+290    	; 0x44a0 <st_prep_buffer+0xc04>
            mm_remaining = mm_var;
          }
          break;
        default: // case RAMP_DECEL:
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
    437e:	aa 8d       	ldd	r26, Y+26	; 0x1a
    4380:	bb 8d       	ldd	r27, Y+27	; 0x1b
    4382:	5e 96       	adiw	r26, 0x1e	; 30
    4384:	2d 91       	ld	r18, X+
    4386:	3d 91       	ld	r19, X+
    4388:	4d 91       	ld	r20, X+
    438a:	5c 91       	ld	r21, X
    438c:	91 97       	sbiw	r26, 0x21	; 33
    438e:	64 2d       	mov	r22, r4
    4390:	73 2d       	mov	r23, r3
    4392:	82 2d       	mov	r24, r2
    4394:	9b ad       	ldd	r25, Y+59	; 0x3b
    4396:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    439a:	6d 87       	std	Y+13, r22	; 0x0d
    439c:	7e 87       	std	Y+14, r23	; 0x0e
    439e:	8f 87       	std	Y+15, r24	; 0x0f
    43a0:	98 8b       	std	Y+16, r25	; 0x10
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
    43a2:	9b 01       	movw	r18, r22
    43a4:	ac 01       	movw	r20, r24
    43a6:	69 81       	ldd	r22, Y+1	; 0x01
    43a8:	7d 81       	ldd	r23, Y+5	; 0x05
    43aa:	89 85       	ldd	r24, Y+9	; 0x09
    43ac:	99 89       	ldd	r25, Y+17	; 0x11
    43ae:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    43b2:	18 16       	cp	r1, r24
    43b4:	0c f0       	brlt	.+2      	; 0x43b8 <st_prep_buffer+0xb1c>
    43b6:	3f c0       	rjmp	.+126    	; 0x4436 <st_prep_buffer+0xb9a>
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
    43b8:	20 e0       	ldi	r18, 0x00	; 0
    43ba:	30 e0       	ldi	r19, 0x00	; 0
    43bc:	40 e0       	ldi	r20, 0x00	; 0
    43be:	5f e3       	ldi	r21, 0x3F	; 63
    43c0:	6d 85       	ldd	r22, Y+13	; 0x0d
    43c2:	7e 85       	ldd	r23, Y+14	; 0x0e
    43c4:	8f 85       	ldd	r24, Y+15	; 0x0f
    43c6:	98 89       	ldd	r25, Y+16	; 0x10
    43c8:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    43cc:	9b 01       	movw	r18, r22
    43ce:	ac 01       	movw	r20, r24
    43d0:	69 81       	ldd	r22, Y+1	; 0x01
    43d2:	7d 81       	ldd	r23, Y+5	; 0x05
    43d4:	89 85       	ldd	r24, Y+9	; 0x09
    43d6:	99 89       	ldd	r25, Y+17	; 0x11
    43d8:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    43dc:	24 2d       	mov	r18, r4
    43de:	33 2d       	mov	r19, r3
    43e0:	42 2d       	mov	r20, r2
    43e2:	5b ad       	ldd	r21, Y+59	; 0x3b
    43e4:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    43e8:	9b 01       	movw	r18, r22
    43ea:	ac 01       	movw	r20, r24
    43ec:	6e 2d       	mov	r22, r14
    43ee:	7d 2d       	mov	r23, r13
    43f0:	8c 2d       	mov	r24, r12
    43f2:	9f 2d       	mov	r25, r15
    43f4:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    43f8:	6c 8f       	std	Y+28, r22	; 0x1c
    43fa:	7d 8f       	std	Y+29, r23	; 0x1d
    43fc:	8c ab       	std	Y+52, r24	; 0x34
    43fe:	69 2e       	mov	r6, r25
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
    4400:	2a 89       	ldd	r18, Y+18	; 0x12
    4402:	3b 89       	ldd	r19, Y+19	; 0x13
    4404:	4c 89       	ldd	r20, Y+20	; 0x14
    4406:	5d 89       	ldd	r21, Y+21	; 0x15
    4408:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    440c:	18 16       	cp	r1, r24
    440e:	9c f4       	brge	.+38     	; 0x4436 <st_prep_buffer+0xb9a>
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
    4410:	2d 85       	ldd	r18, Y+13	; 0x0d
    4412:	3e 85       	ldd	r19, Y+14	; 0x0e
    4414:	4f 85       	ldd	r20, Y+15	; 0x0f
    4416:	58 89       	ldd	r21, Y+16	; 0x10
    4418:	69 81       	ldd	r22, Y+1	; 0x01
    441a:	7d 81       	ldd	r23, Y+5	; 0x05
    441c:	89 85       	ldd	r24, Y+9	; 0x09
    441e:	99 89       	ldd	r25, Y+17	; 0x11
    4420:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    4424:	69 83       	std	Y+1, r22	; 0x01
    4426:	7d 83       	std	Y+5, r23	; 0x05
    4428:	89 87       	std	Y+9, r24	; 0x09
    442a:	99 8b       	std	Y+17, r25	; 0x11
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
              mm_remaining = mm_var;
    442c:	ec 8c       	ldd	r14, Y+28	; 0x1c
    442e:	dd 8c       	ldd	r13, Y+29	; 0x1d
    4430:	cc a8       	ldd	r12, Y+52	; 0x34
    4432:	f6 2c       	mov	r15, r6
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
    4434:	35 c0       	rjmp	.+106    	; 0x44a0 <st_prep_buffer+0xc04>
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    4436:	2a 89       	ldd	r18, Y+18	; 0x12
    4438:	3b 89       	ldd	r19, Y+19	; 0x13
    443a:	4c 89       	ldd	r20, Y+20	; 0x14
    443c:	5d 89       	ldd	r21, Y+21	; 0x15
    443e:	6e 2d       	mov	r22, r14
    4440:	7d 2d       	mov	r23, r13
    4442:	8c 2d       	mov	r24, r12
    4444:	9f 2d       	mov	r25, r15
    4446:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    444a:	9b 01       	movw	r18, r22
    444c:	ac 01       	movw	r20, r24
    444e:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    4452:	6b 01       	movw	r12, r22
    4454:	7c 01       	movw	r14, r24
    4456:	2e a5       	ldd	r18, Y+46	; 0x2e
    4458:	3f a5       	ldd	r19, Y+47	; 0x2f
    445a:	48 a9       	ldd	r20, Y+48	; 0x30
    445c:	59 a9       	ldd	r21, Y+49	; 0x31
    445e:	69 81       	ldd	r22, Y+1	; 0x01
    4460:	7d 81       	ldd	r23, Y+5	; 0x05
    4462:	89 85       	ldd	r24, Y+9	; 0x09
    4464:	99 89       	ldd	r25, Y+17	; 0x11
    4466:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    446a:	9b 01       	movw	r18, r22
    446c:	ac 01       	movw	r20, r24
    446e:	c7 01       	movw	r24, r14
    4470:	b6 01       	movw	r22, r12
    4472:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <__divsf3>
    4476:	46 2e       	mov	r4, r22
    4478:	37 2e       	mov	r3, r23
    447a:	28 2e       	mov	r2, r24
    447c:	9b af       	std	Y+59, r25	; 0x3b
          mm_remaining = prep.mm_complete;
          prep.current_speed = prep.exit_speed;
    447e:	be a5       	ldd	r27, Y+46	; 0x2e
    4480:	b9 83       	std	Y+1, r27	; 0x01
    4482:	ef a5       	ldd	r30, Y+47	; 0x2f
    4484:	ed 83       	std	Y+5, r30	; 0x05
    4486:	f8 a9       	ldd	r31, Y+48	; 0x30
    4488:	f9 87       	std	Y+9, r31	; 0x09
    448a:	29 a9       	ldd	r18, Y+49	; 0x31
    448c:	29 8b       	std	Y+17, r18	; 0x11
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete;
    448e:	ea 88       	ldd	r14, Y+18	; 0x12
    4490:	db 88       	ldd	r13, Y+19	; 0x13
    4492:	cc 88       	ldd	r12, Y+20	; 0x14
    4494:	fd 88       	ldd	r15, Y+21	; 0x15
    4496:	04 c0       	rjmp	.+8      	; 0x44a0 <st_prep_buffer+0xc04>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
          } else { // Cruising only.
            mm_remaining = mm_var;
    4498:	ed 84       	ldd	r14, Y+13	; 0x0d
    449a:	dc 8c       	ldd	r13, Y+28	; 0x1c
    449c:	cd 8c       	ldd	r12, Y+29	; 0x1d
    449e:	f6 2c       	mov	r15, r6
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete;
          prep.current_speed = prep.exit_speed;
      }
      dt += time_var; // Add computed ramp time to total segment time.
    44a0:	24 2d       	mov	r18, r4
    44a2:	33 2d       	mov	r19, r3
    44a4:	42 2d       	mov	r20, r2
    44a6:	5b ad       	ldd	r21, Y+59	; 0x3b
    44a8:	c5 01       	movw	r24, r10
    44aa:	b4 01       	movw	r22, r8
    44ac:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    44b0:	4b 01       	movw	r8, r22
    44b2:	5c 01       	movw	r10, r24
      if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
    44b4:	9b 01       	movw	r18, r22
    44b6:	ac 01       	movw	r20, r24
    44b8:	67 2d       	mov	r22, r7
    44ba:	75 2d       	mov	r23, r5
    44bc:	81 2f       	mov	r24, r17
    44be:	90 2f       	mov	r25, r16
    44c0:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    44c4:	18 16       	cp	r1, r24
    44c6:	6c f4       	brge	.+26     	; 0x44e2 <st_prep_buffer+0xc46>
    44c8:	a5 01       	movw	r20, r10
    44ca:	94 01       	movw	r18, r8
    44cc:	67 2d       	mov	r22, r7
    44ce:	75 2d       	mov	r23, r5
    44d0:	81 2f       	mov	r24, r17
    44d2:	90 2f       	mov	r25, r16
    44d4:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    44d8:	46 2e       	mov	r4, r22
    44da:	37 2e       	mov	r3, r23
    44dc:	28 2e       	mov	r2, r24
    44de:	9b af       	std	Y+59, r25	; 0x3b
    44e0:	36 c0       	rjmp	.+108    	; 0x454e <st_prep_buffer+0xcb2>
      else {
        if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
    44e2:	2a a1       	ldd	r18, Y+34	; 0x22
    44e4:	3b a1       	ldd	r19, Y+35	; 0x23
    44e6:	4c a1       	ldd	r20, Y+36	; 0x24
    44e8:	5d a1       	ldd	r21, Y+37	; 0x25
    44ea:	6e 2d       	mov	r22, r14
    44ec:	7d 2d       	mov	r23, r13
    44ee:	8c 2d       	mov	r24, r12
    44f0:	9f 2d       	mov	r25, r15
    44f2:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    44f6:	18 16       	cp	r1, r24
    44f8:	a4 f0       	brlt	.+40     	; 0x4522 <st_prep_buffer+0xc86>
    44fa:	3c ad       	ldd	r19, Y+60	; 0x3c
    44fc:	6e a8       	ldd	r6, Y+54	; 0x36
    44fe:	7f a8       	ldd	r7, Y+55	; 0x37
    4500:	5e 2c       	mov	r5, r14
    4502:	1d 2d       	mov	r17, r13
    4504:	0c 2d       	mov	r16, r12
    4506:	fc 8e       	std	Y+28, r15	; 0x1c
    4508:	d3 01       	movw	r26, r6
    450a:	52 96       	adiw	r26, 0x12	; 18
    450c:	3c 93       	st	X, r19
    450e:	89 81       	ldd	r24, Y+1	; 0x01
    4510:	9d 81       	ldd	r25, Y+5	; 0x05
    4512:	a9 85       	ldd	r26, Y+9	; 0x09
    4514:	b9 89       	ldd	r27, Y+17	; 0x11
    4516:	f3 01       	movw	r30, r6
    4518:	87 8b       	std	Z+23, r24	; 0x17
    451a:	90 8f       	std	Z+24, r25	; 0x18
    451c:	a1 8f       	std	Z+25, r26	; 0x19
    451e:	b2 8f       	std	Z+26, r27	; 0x1a
    4520:	37 c0       	rjmp	.+110    	; 0x4590 <st_prep_buffer+0xcf4>
          // Increase segment time to ensure at least one step in segment. Override and loop
          // through distance calculations until minimum_mm or mm_complete.
          dt_max += DT_SEGMENT;
    4522:	2e e3       	ldi	r18, 0x3E	; 62
    4524:	33 ec       	ldi	r19, 0xC3	; 195
    4526:	4e e2       	ldi	r20, 0x2E	; 46
    4528:	59 e3       	ldi	r21, 0x39	; 57
    452a:	67 2d       	mov	r22, r7
    452c:	75 2d       	mov	r23, r5
    452e:	81 2f       	mov	r24, r17
    4530:	90 2f       	mov	r25, r16
    4532:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    4536:	76 2e       	mov	r7, r22
    4538:	57 2e       	mov	r5, r23
    453a:	18 2f       	mov	r17, r24
    453c:	09 2f       	mov	r16, r25
          time_var = dt_max - dt;
    453e:	a5 01       	movw	r20, r10
    4540:	94 01       	movw	r18, r8
    4542:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    4546:	46 2e       	mov	r4, r22
    4548:	37 2e       	mov	r3, r23
    454a:	28 2e       	mov	r2, r24
    454c:	9b af       	std	Y+59, r25	; 0x3b
        } else {
          break; // **Complete** Exit loop. Segment execution time maxed.
        }
      }
    } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
    454e:	2a 89       	ldd	r18, Y+18	; 0x12
    4550:	3b 89       	ldd	r19, Y+19	; 0x13
    4552:	4c 89       	ldd	r20, Y+20	; 0x14
    4554:	5d 89       	ldd	r21, Y+21	; 0x15
    4556:	6e 2d       	mov	r22, r14
    4558:	7d 2d       	mov	r23, r13
    455a:	8c 2d       	mov	r24, r12
    455c:	9f 2d       	mov	r25, r15
    455e:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    4562:	18 16       	cp	r1, r24
    4564:	0c f4       	brge	.+2      	; 0x4568 <st_prep_buffer+0xccc>
    4566:	ba cd       	rjmp	.-1164   	; 0x40dc <st_prep_buffer+0x840>
    4568:	fc ad       	ldd	r31, Y+60	; 0x3c
    456a:	fd 8f       	std	Y+29, r31	; 0x1d
    456c:	6e a8       	ldd	r6, Y+54	; 0x36
    456e:	7f a8       	ldd	r7, Y+55	; 0x37
    4570:	5e 2c       	mov	r5, r14
    4572:	1d 2d       	mov	r17, r13
    4574:	0c 2d       	mov	r16, r12
    4576:	fc 8e       	std	Y+28, r15	; 0x1c
    4578:	d3 01       	movw	r26, r6
    457a:	52 96       	adiw	r26, 0x12	; 18
    457c:	fc 93       	st	X, r31
    457e:	89 81       	ldd	r24, Y+1	; 0x01
    4580:	9d 81       	ldd	r25, Y+5	; 0x05
    4582:	a9 85       	ldd	r26, Y+9	; 0x09
    4584:	b9 89       	ldd	r27, Y+17	; 0x11
    4586:	f3 01       	movw	r30, r6
    4588:	87 8b       	std	Z+23, r24	; 0x17
    458a:	90 8f       	std	Z+24, r25	; 0x18
    458c:	a1 8f       	std	Z+25, r26	; 0x19
    458e:	b2 8f       	std	Z+26, r27	; 0x1a

    /* -----------------------------------------------------------------------------------
      Compute spindle speed PWM output for step segment
    */
    
    if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
    4590:	e0 91 39 03 	lds	r30, 0x0339	; 0x800339 <st_prep_block>
    4594:	f0 91 3a 03 	lds	r31, 0x033A	; 0x80033a <st_prep_block+0x1>
    4598:	81 89       	ldd	r24, Z+17	; 0x11
    459a:	81 11       	cpse	r24, r1
    459c:	99 c1       	rjmp	.+818    	; 0x48d0 <st_prep_buffer+0x1034>
    459e:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    45a2:	83 fd       	sbrc	r24, 3
    45a4:	a5 c1       	rjmp	.+842    	; 0x48f0 <st_prep_buffer+0x1054>
    45a6:	18 c0       	rjmp	.+48     	; 0x45d8 <st_prep_buffer+0xd3c>
        float rpm = pl_block->spindle_speed;
        // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.        
        if (st_prep_block->is_pwm_rate_adjusted) { rpm *= (prep.current_speed * prep.inv_rate); }
        // If current_speed is zero, then may need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE)
        // but this would be instantaneous only and during a motion. May not matter at all.
        prep.current_spindle_pwm = spindle_compute_pwm_value(rpm);
    45a8:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <spindle_compute_pwm_value>
    45ac:	d3 01       	movw	r26, r6
    45ae:	d0 96       	adiw	r26, 0x30	; 48
    45b0:	9c 93       	st	X, r25
    45b2:	8e 93       	st	-X, r24
    45b4:	9f 97       	sbiw	r26, 0x2f	; 47
    45b6:	0b c0       	rjmp	.+22     	; 0x45ce <st_prep_buffer+0xd32>
      } else { 
        sys.spindle_speed = 0.0;
    45b8:	10 92 2c 0c 	sts	0x0C2C, r1	; 0x800c2c <sys+0xe>
    45bc:	10 92 2d 0c 	sts	0x0C2D, r1	; 0x800c2d <sys+0xf>
    45c0:	10 92 2e 0c 	sts	0x0C2E, r1	; 0x800c2e <sys+0x10>
    45c4:	10 92 2f 0c 	sts	0x0C2F, r1	; 0x800c2f <sys+0x11>
        prep.current_spindle_pwm = SPINDLE_PWM_OFF_VALUE;
    45c8:	f3 01       	movw	r30, r6
    45ca:	10 aa       	std	Z+48, r1	; 0x30
    45cc:	17 a6       	std	Z+47, r1	; 0x2f
      }
      bit_false(sys.step_control,STEP_CONTROL_UPDATE_SPINDLE_PWM);
    45ce:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    45d2:	87 7f       	andi	r24, 0xF7	; 247
    45d4:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <sys+0x4>
    }
    prep_segment->spindle_pwm = prep.current_spindle_pwm; // Reload segment PWM value
    45d8:	8a a9       	ldd	r24, Y+50	; 0x32
    45da:	9b a9       	ldd	r25, Y+51	; 0x33
    45dc:	88 0f       	add	r24, r24
    45de:	99 1f       	adc	r25, r25
    45e0:	88 0f       	add	r24, r24
    45e2:	99 1f       	adc	r25, r25
    45e4:	88 0f       	add	r24, r24
    45e6:	99 1f       	adc	r25, r25
    45e8:	9c 01       	movw	r18, r24
    45ea:	2a 59       	subi	r18, 0x9A	; 154
    45ec:	3c 4f       	sbci	r19, 0xFC	; 252
    45ee:	19 01       	movw	r2, r18
    45f0:	d3 01       	movw	r26, r6
    45f2:	9f 96       	adiw	r26, 0x2f	; 47
    45f4:	8d 91       	ld	r24, X+
    45f6:	9c 91       	ld	r25, X
    45f8:	d0 97       	sbiw	r26, 0x30	; 48
    45fa:	f9 01       	movw	r30, r18
    45fc:	97 83       	std	Z+7, r25	; 0x07
    45fe:	86 83       	std	Z+6, r24	; 0x06
       However, since floats have only 7.2 significant digits, long moves with extremely
       high step counts can exceed the precision of floats, which can lead to lost steps.
       Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
       supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    */
    float step_dist_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
    4600:	1a 96       	adiw	r26, 0x0a	; 10
    4602:	2d 91       	ld	r18, X+
    4604:	3d 91       	ld	r19, X+
    4606:	4d 91       	ld	r20, X+
    4608:	5c 91       	ld	r21, X
    460a:	1d 97       	sbiw	r26, 0x0d	; 13
    460c:	65 2d       	mov	r22, r5
    460e:	71 2f       	mov	r23, r17
    4610:	80 2f       	mov	r24, r16
    4612:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4614:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    4618:	69 83       	std	Y+1, r22	; 0x01
    461a:	7a 83       	std	Y+2, r23	; 0x02
    461c:	8b 83       	std	Y+3, r24	; 0x03
    461e:	9c 83       	std	Y+4, r25	; 0x04
    float n_steps_remaining = ceil(step_dist_remaining); // Round-up current steps remaining
    4620:	0e 94 8d 3f 	call	0x7f1a	; 0x7f1a <ceil>
    4624:	6d 83       	std	Y+5, r22	; 0x05
    4626:	7e 83       	std	Y+6, r23	; 0x06
    4628:	8f 83       	std	Y+7, r24	; 0x07
    462a:	98 87       	std	Y+8, r25	; 0x08
    float last_n_steps_remaining = ceil(prep.steps_remaining); // Round-up last steps remaining
    462c:	d3 01       	movw	r26, r6
    462e:	16 96       	adiw	r26, 0x06	; 6
    4630:	6d 91       	ld	r22, X+
    4632:	7d 91       	ld	r23, X+
    4634:	8d 91       	ld	r24, X+
    4636:	9c 91       	ld	r25, X
    4638:	19 97       	sbiw	r26, 0x09	; 9
    463a:	0e 94 8d 3f 	call	0x7f1a	; 0x7f1a <ceil>
    463e:	69 87       	std	Y+9, r22	; 0x09
    4640:	7a 87       	std	Y+10, r23	; 0x0a
    4642:	8b 87       	std	Y+11, r24	; 0x0b
    4644:	9c 87       	std	Y+12, r25	; 0x0c
    prep_segment->n_step = last_n_steps_remaining-n_steps_remaining; // Compute number of steps to execute.
    4646:	2d 81       	ldd	r18, Y+5	; 0x05
    4648:	3e 81       	ldd	r19, Y+6	; 0x06
    464a:	4f 81       	ldd	r20, Y+7	; 0x07
    464c:	58 85       	ldd	r21, Y+8	; 0x08
    464e:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    4652:	0e 94 14 40 	call	0x8028	; 0x8028 <__fixunssfsi>
    4656:	6b 01       	movw	r12, r22
    4658:	7c 01       	movw	r14, r24
    465a:	f1 01       	movw	r30, r2
    465c:	71 83       	std	Z+1, r23	; 0x01
    465e:	60 83       	st	Z, r22

    // Bail if we are at the end of a feed hold and don't have a step to execute.
    if (prep_segment->n_step == 0) {
    4660:	67 2b       	or	r22, r23
    4662:	41 f4       	brne	.+16     	; 0x4674 <st_prep_buffer+0xdd8>
      if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) {
    4664:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    4668:	81 ff       	sbrs	r24, 1
    466a:	04 c0       	rjmp	.+8      	; 0x4674 <st_prep_buffer+0xdd8>
        // Less than one step to decelerate to zero speed, but already very close. AMASS
        // requires full steps to execute. So, just bail.
        bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    466c:	81 60       	ori	r24, 0x01	; 1
    466e:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <sys+0x4>
        #ifdef PARKING_ENABLE
          if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
        #endif
        return; // Segment not generated, but current step data still retained.
    4672:	44 c1       	rjmp	.+648    	; 0x48fc <st_prep_buffer+0x1060>
    // apply it with the partial step distance to the current segment, so that it minutely
    // adjusts the whole segment rate to keep step output exact. These rate adjustments are
    // typically very small and do not adversely effect performance, but ensures that Grbl
    // outputs the exact acceleration and velocity profiles as computed by the planner.
    dt += prep.dt_remainder; // Apply previous segment partial step execute time
    float inv_rate = dt/(last_n_steps_remaining - step_dist_remaining); // Compute adjusted step rate inverse
    4674:	d3 01       	movw	r26, r6
    4676:	12 96       	adiw	r26, 0x02	; 2
    4678:	2d 91       	ld	r18, X+
    467a:	3d 91       	ld	r19, X+
    467c:	4d 91       	ld	r20, X+
    467e:	5c 91       	ld	r21, X
    4680:	15 97       	sbiw	r26, 0x05	; 5
    4682:	c5 01       	movw	r24, r10
    4684:	b4 01       	movw	r22, r8
    4686:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    468a:	4b 01       	movw	r8, r22
    468c:	5c 01       	movw	r10, r24
    468e:	29 81       	ldd	r18, Y+1	; 0x01
    4690:	3a 81       	ldd	r19, Y+2	; 0x02
    4692:	4b 81       	ldd	r20, Y+3	; 0x03
    4694:	5c 81       	ldd	r21, Y+4	; 0x04
    4696:	69 85       	ldd	r22, Y+9	; 0x09
    4698:	7a 85       	ldd	r23, Y+10	; 0x0a
    469a:	8b 85       	ldd	r24, Y+11	; 0x0b
    469c:	9c 85       	ldd	r25, Y+12	; 0x0c
    469e:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    46a2:	9b 01       	movw	r18, r22
    46a4:	ac 01       	movw	r20, r24
    46a6:	c5 01       	movw	r24, r10
    46a8:	b4 01       	movw	r22, r8
    46aa:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <__divsf3>
    46ae:	4b 01       	movw	r8, r22
    46b0:	5c 01       	movw	r10, r24

    // Compute CPU cycles per step for the prepped segment.
    uint32_t cycles = ceil( (TICKS_PER_MICROSECOND*1000000*60)*inv_rate ); // (cycles/step)
    46b2:	20 ec       	ldi	r18, 0xC0	; 192
    46b4:	31 ee       	ldi	r19, 0xE1	; 225
    46b6:	44 e6       	ldi	r20, 0x64	; 100
    46b8:	5e e4       	ldi	r21, 0x4E	; 78
    46ba:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    46be:	0e 94 8d 3f 	call	0x7f1a	; 0x7f1a <ceil>
    46c2:	0e 94 14 40 	call	0x8028	; 0x8028 <__fixunssfsi>

    #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
      // Compute step timing and multi-axis smoothing level.
      // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
      if (cycles < AMASS_LEVEL1) { prep_segment->amass_level = 0; }
    46c6:	60 3d       	cpi	r22, 0xD0	; 208
    46c8:	b7 e0       	ldi	r27, 0x07	; 7
    46ca:	7b 07       	cpc	r23, r27
    46cc:	81 05       	cpc	r24, r1
    46ce:	91 05       	cpc	r25, r1
    46d0:	60 f4       	brcc	.+24     	; 0x46ea <st_prep_buffer+0xe4e>
    46d2:	ea a9       	ldd	r30, Y+50	; 0x32
    46d4:	fb a9       	ldd	r31, Y+51	; 0x33
    46d6:	ee 0f       	add	r30, r30
    46d8:	ff 1f       	adc	r31, r31
    46da:	ee 0f       	add	r30, r30
    46dc:	ff 1f       	adc	r31, r31
    46de:	ee 0f       	add	r30, r30
    46e0:	ff 1f       	adc	r31, r31
    46e2:	ea 59       	subi	r30, 0x9A	; 154
    46e4:	fc 4f       	sbci	r31, 0xFC	; 252
    46e6:	15 82       	std	Z+5, r1	; 0x05
    46e8:	4d c0       	rjmp	.+154    	; 0x4784 <st_prep_buffer+0xee8>
      else {
        if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }
    46ea:	60 3a       	cpi	r22, 0xA0	; 160
    46ec:	ef e0       	ldi	r30, 0x0F	; 15
    46ee:	7e 07       	cpc	r23, r30
    46f0:	81 05       	cpc	r24, r1
    46f2:	91 05       	cpc	r25, r1
    46f4:	68 f4       	brcc	.+26     	; 0x4710 <st_prep_buffer+0xe74>
    46f6:	ea a9       	ldd	r30, Y+50	; 0x32
    46f8:	fb a9       	ldd	r31, Y+51	; 0x33
    46fa:	ee 0f       	add	r30, r30
    46fc:	ff 1f       	adc	r31, r31
    46fe:	ee 0f       	add	r30, r30
    4700:	ff 1f       	adc	r31, r31
    4702:	ee 0f       	add	r30, r30
    4704:	ff 1f       	adc	r31, r31
    4706:	ea 59       	subi	r30, 0x9A	; 154
    4708:	fc 4f       	sbci	r31, 0xFC	; 252
    470a:	21 e0       	ldi	r18, 0x01	; 1
    470c:	25 83       	std	Z+5, r18	; 0x05
    470e:	1f c0       	rjmp	.+62     	; 0x474e <st_prep_buffer+0xeb2>
        else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }
    4710:	60 34       	cpi	r22, 0x40	; 64
    4712:	3f e1       	ldi	r19, 0x1F	; 31
    4714:	73 07       	cpc	r23, r19
    4716:	81 05       	cpc	r24, r1
    4718:	91 05       	cpc	r25, r1
    471a:	68 f4       	brcc	.+26     	; 0x4736 <st_prep_buffer+0xe9a>
    471c:	ea a9       	ldd	r30, Y+50	; 0x32
    471e:	fb a9       	ldd	r31, Y+51	; 0x33
    4720:	ee 0f       	add	r30, r30
    4722:	ff 1f       	adc	r31, r31
    4724:	ee 0f       	add	r30, r30
    4726:	ff 1f       	adc	r31, r31
    4728:	ee 0f       	add	r30, r30
    472a:	ff 1f       	adc	r31, r31
    472c:	ea 59       	subi	r30, 0x9A	; 154
    472e:	fc 4f       	sbci	r31, 0xFC	; 252
    4730:	42 e0       	ldi	r20, 0x02	; 2
    4732:	45 83       	std	Z+5, r20	; 0x05
    4734:	0c c0       	rjmp	.+24     	; 0x474e <st_prep_buffer+0xeb2>
        else { prep_segment->amass_level = 3; }
    4736:	ea a9       	ldd	r30, Y+50	; 0x32
    4738:	fb a9       	ldd	r31, Y+51	; 0x33
    473a:	ee 0f       	add	r30, r30
    473c:	ff 1f       	adc	r31, r31
    473e:	ee 0f       	add	r30, r30
    4740:	ff 1f       	adc	r31, r31
    4742:	ee 0f       	add	r30, r30
    4744:	ff 1f       	adc	r31, r31
    4746:	ea 59       	subi	r30, 0x9A	; 154
    4748:	fc 4f       	sbci	r31, 0xFC	; 252
    474a:	53 e0       	ldi	r21, 0x03	; 3
    474c:	55 83       	std	Z+5, r21	; 0x05
        cycles >>= prep_segment->amass_level;
    474e:	ea a9       	ldd	r30, Y+50	; 0x32
    4750:	fb a9       	ldd	r31, Y+51	; 0x33
    4752:	ee 0f       	add	r30, r30
    4754:	ff 1f       	adc	r31, r31
    4756:	ee 0f       	add	r30, r30
    4758:	ff 1f       	adc	r31, r31
    475a:	ee 0f       	add	r30, r30
    475c:	ff 1f       	adc	r31, r31
    475e:	ea 59       	subi	r30, 0x9A	; 154
    4760:	fc 4f       	sbci	r31, 0xFC	; 252
    4762:	25 81       	ldd	r18, Z+5	; 0x05
    4764:	02 2e       	mov	r0, r18
    4766:	04 c0       	rjmp	.+8      	; 0x4770 <st_prep_buffer+0xed4>
    4768:	96 95       	lsr	r25
    476a:	87 95       	ror	r24
    476c:	77 95       	ror	r23
    476e:	67 95       	ror	r22
    4770:	0a 94       	dec	r0
    4772:	d2 f7       	brpl	.-12     	; 0x4768 <st_prep_buffer+0xecc>
        prep_segment->n_step <<= prep_segment->amass_level;
    4774:	d6 01       	movw	r26, r12
    4776:	02 c0       	rjmp	.+4      	; 0x477c <st_prep_buffer+0xee0>
    4778:	aa 0f       	add	r26, r26
    477a:	bb 1f       	adc	r27, r27
    477c:	2a 95       	dec	r18
    477e:	e2 f7       	brpl	.-8      	; 0x4778 <st_prep_buffer+0xedc>
    4780:	b1 83       	std	Z+1, r27	; 0x01
    4782:	a0 83       	st	Z, r26
      }
      if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)
    4784:	61 15       	cp	r22, r1
    4786:	71 05       	cpc	r23, r1
    4788:	b1 e0       	ldi	r27, 0x01	; 1
    478a:	8b 07       	cpc	r24, r27
    478c:	91 05       	cpc	r25, r1
    478e:	68 f4       	brcc	.+26     	; 0x47aa <st_prep_buffer+0xf0e>
    4790:	ea a9       	ldd	r30, Y+50	; 0x32
    4792:	fb a9       	ldd	r31, Y+51	; 0x33
    4794:	ee 0f       	add	r30, r30
    4796:	ff 1f       	adc	r31, r31
    4798:	ee 0f       	add	r30, r30
    479a:	ff 1f       	adc	r31, r31
    479c:	ee 0f       	add	r30, r30
    479e:	ff 1f       	adc	r31, r31
    47a0:	ea 59       	subi	r30, 0x9A	; 154
    47a2:	fc 4f       	sbci	r31, 0xFC	; 252
    47a4:	73 83       	std	Z+3, r23	; 0x03
    47a6:	62 83       	std	Z+2, r22	; 0x02
    47a8:	0e c0       	rjmp	.+28     	; 0x47c6 <st_prep_buffer+0xf2a>
      else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
    47aa:	ea a9       	ldd	r30, Y+50	; 0x32
    47ac:	fb a9       	ldd	r31, Y+51	; 0x33
    47ae:	ee 0f       	add	r30, r30
    47b0:	ff 1f       	adc	r31, r31
    47b2:	ee 0f       	add	r30, r30
    47b4:	ff 1f       	adc	r31, r31
    47b6:	ee 0f       	add	r30, r30
    47b8:	ff 1f       	adc	r31, r31
    47ba:	ea 59       	subi	r30, 0x9A	; 154
    47bc:	fc 4f       	sbci	r31, 0xFC	; 252
    47be:	2f ef       	ldi	r18, 0xFF	; 255
    47c0:	3f ef       	ldi	r19, 0xFF	; 255
    47c2:	33 83       	std	Z+3, r19	; 0x03
    47c4:	22 83       	std	Z+2, r18	; 0x02
        }
      }
    #endif

    // Segment complete! Increment segment buffer indices, so stepper ISR can immediately execute it.
    segment_buffer_head = segment_next_head;
    47c6:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <segment_next_head>
    47ca:	80 93 41 03 	sts	0x0341, r24	; 0x800341 <segment_buffer_head>
    if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
    47ce:	8f 5f       	subi	r24, 0xFF	; 255
    47d0:	8a 30       	cpi	r24, 0x0A	; 10
    47d2:	19 f0       	breq	.+6      	; 0x47da <st_prep_buffer+0xf3e>
    47d4:	80 93 40 03 	sts	0x0340, r24	; 0x800340 <segment_next_head>
    47d8:	02 c0       	rjmp	.+4      	; 0x47de <st_prep_buffer+0xf42>
    47da:	10 92 40 03 	sts	0x0340, r1	; 0x800340 <segment_next_head>

    // Update the appropriate planner and segment data.
    pl_block->millimeters = mm_remaining;
    47de:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    47e2:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    47e6:	85 2d       	mov	r24, r5
    47e8:	91 2f       	mov	r25, r17
    47ea:	a0 2f       	mov	r26, r16
    47ec:	bc 8d       	ldd	r27, Y+28	; 0x1c
    47ee:	82 a3       	std	Z+34, r24	; 0x22
    47f0:	93 a3       	std	Z+35, r25	; 0x23
    47f2:	a4 a3       	std	Z+36, r26	; 0x24
    47f4:	b5 a3       	std	Z+37, r27	; 0x25
    prep.steps_remaining = n_steps_remaining;
    47f6:	8d 81       	ldd	r24, Y+5	; 0x05
    47f8:	9e 81       	ldd	r25, Y+6	; 0x06
    47fa:	af 81       	ldd	r26, Y+7	; 0x07
    47fc:	b8 85       	ldd	r27, Y+8	; 0x08
    47fe:	f3 01       	movw	r30, r6
    4800:	86 83       	std	Z+6, r24	; 0x06
    4802:	97 83       	std	Z+7, r25	; 0x07
    4804:	a0 87       	std	Z+8, r26	; 0x08
    4806:	b1 87       	std	Z+9, r27	; 0x09
    prep.dt_remainder = (n_steps_remaining - step_dist_remaining)*inv_rate;
    4808:	29 81       	ldd	r18, Y+1	; 0x01
    480a:	3a 81       	ldd	r19, Y+2	; 0x02
    480c:	4b 81       	ldd	r20, Y+3	; 0x03
    480e:	5c 81       	ldd	r21, Y+4	; 0x04
    4810:	bc 01       	movw	r22, r24
    4812:	cd 01       	movw	r24, r26
    4814:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    4818:	a5 01       	movw	r20, r10
    481a:	94 01       	movw	r18, r8
    481c:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    4820:	d3 01       	movw	r26, r6
    4822:	12 96       	adiw	r26, 0x02	; 2
    4824:	6d 93       	st	X+, r22
    4826:	7d 93       	st	X+, r23
    4828:	8d 93       	st	X+, r24
    482a:	9c 93       	st	X, r25
    482c:	15 97       	sbiw	r26, 0x05	; 5

    // Check for exit conditions and flag to load next planner block.
    if (mm_remaining == prep.mm_complete) {
    482e:	53 96       	adiw	r26, 0x13	; 19
    4830:	2d 91       	ld	r18, X+
    4832:	3d 91       	ld	r19, X+
    4834:	4d 91       	ld	r20, X+
    4836:	5c 91       	ld	r21, X
    4838:	56 97       	sbiw	r26, 0x16	; 22
    483a:	65 2d       	mov	r22, r5
    483c:	71 2f       	mov	r23, r17
    483e:	80 2f       	mov	r24, r16
    4840:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4842:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    4846:	81 11       	cpse	r24, r1
    4848:	22 c0       	rjmp	.+68     	; 0x488e <st_prep_buffer+0xff2>
    484a:	45 2c       	mov	r4, r5
    484c:	2c 8c       	ldd	r2, Y+28	; 0x1c
      // End of planner block or forced-termination. No more distance to be executed.
      if (mm_remaining > 0.0) { // At end of forced-termination.
    484e:	20 e0       	ldi	r18, 0x00	; 0
    4850:	30 e0       	ldi	r19, 0x00	; 0
    4852:	a9 01       	movw	r20, r18
    4854:	64 2d       	mov	r22, r4
    4856:	71 2f       	mov	r23, r17
    4858:	80 2f       	mov	r24, r16
    485a:	92 2d       	mov	r25, r2
    485c:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    4860:	18 16       	cp	r1, r24
    4862:	34 f4       	brge	.+12     	; 0x4870 <st_prep_buffer+0xfd4>
        // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
        // the segment queue, where realtime protocol will set new state upon receiving the
        // cycle stop flag from the ISR. Prep_segment is blocked until then.
        bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    4864:	ee e1       	ldi	r30, 0x1E	; 30
    4866:	fc e0       	ldi	r31, 0x0C	; 12
    4868:	84 81       	ldd	r24, Z+4	; 0x04
    486a:	81 60       	ori	r24, 0x01	; 1
    486c:	84 83       	std	Z+4, r24	; 0x04
        #ifdef PARKING_ENABLE
          if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
        #endif
        return; // Bail!
    486e:	46 c0       	rjmp	.+140    	; 0x48fc <st_prep_buffer+0x1060>
      } else { // End of planner block
        // The planner block is complete. All steps are set to be executed in the segment buffer.
        if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
    4870:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    4874:	82 ff       	sbrs	r24, 2
    4876:	04 c0       	rjmp	.+8      	; 0x4880 <st_prep_buffer+0xfe4>
          bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    4878:	81 60       	ori	r24, 0x01	; 1
    487a:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <sys+0x4>
          return;
    487e:	3e c0       	rjmp	.+124    	; 0x48fc <st_prep_buffer+0x1060>
        }
        pl_block = NULL; // Set pointer to indicate check and load next planner block.
    4880:	10 92 3c 03 	sts	0x033C, r1	; 0x80033c <pl_block+0x1>
    4884:	10 92 3b 03 	sts	0x033B, r1	; 0x80033b <pl_block>
        plan_discard_current_block();
    4888:	25 d5       	rcall	.+2634   	; 0x52d4 <plan_discard_current_block>
          speed_var = pl_block->acceleration*time_var;
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            prep.ramp_type = RAMP_CRUISE;
    488a:	b1 e0       	ldi	r27, 0x01	; 1
    488c:	b8 af       	std	Y+56, r27	; 0x38
void st_prep_buffer()
{
  // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }

  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
    488e:	90 91 42 03 	lds	r25, 0x0342	; 0x800342 <segment_buffer_tail>
    4892:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <segment_next_head>
    4896:	98 13       	cpse	r25, r24
    4898:	2b c8       	rjmp	.-4010   	; 0x38f0 <st_prep_buffer+0x54>
    489a:	30 c0       	rjmp	.+96     	; 0x48fc <st_prep_buffer+0x1060>
      Compute spindle speed PWM output for step segment
    */
    
    if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
      if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
        float rpm = pl_block->spindle_speed;
    489c:	ea 8d       	ldd	r30, Y+26	; 0x1a
    489e:	fb 8d       	ldd	r31, Y+27	; 0x1b
    48a0:	c2 a8       	ldd	r12, Z+50	; 0x32
    48a2:	d3 a8       	ldd	r13, Z+51	; 0x33
    48a4:	e4 a8       	ldd	r14, Z+52	; 0x34
    48a6:	f5 a8       	ldd	r15, Z+53	; 0x35
        // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.        
        if (st_prep_block->is_pwm_rate_adjusted) { rpm *= (prep.current_speed * prep.inv_rate); }
    48a8:	d3 01       	movw	r26, r6
    48aa:	9b 96       	adiw	r26, 0x2b	; 43
    48ac:	2d 91       	ld	r18, X+
    48ae:	3d 91       	ld	r19, X+
    48b0:	4d 91       	ld	r20, X+
    48b2:	5c 91       	ld	r21, X
    48b4:	9e 97       	sbiw	r26, 0x2e	; 46
    48b6:	57 96       	adiw	r26, 0x17	; 23
    48b8:	6d 91       	ld	r22, X+
    48ba:	7d 91       	ld	r23, X+
    48bc:	8d 91       	ld	r24, X+
    48be:	9c 91       	ld	r25, X
    48c0:	5a 97       	sbiw	r26, 0x1a	; 26
    48c2:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    48c6:	a7 01       	movw	r20, r14
    48c8:	96 01       	movw	r18, r12
    48ca:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    48ce:	6c ce       	rjmp	.-808    	; 0x45a8 <st_prep_buffer+0xd0c>
    /* -----------------------------------------------------------------------------------
      Compute spindle speed PWM output for step segment
    */
    
    if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
      if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
    48d0:	ea 8d       	ldd	r30, Y+26	; 0x1a
    48d2:	fb 8d       	ldd	r31, Y+27	; 0x1b
    48d4:	81 89       	ldd	r24, Z+17	; 0x11
    48d6:	80 73       	andi	r24, 0x30	; 48
    48d8:	09 f4       	brne	.+2      	; 0x48dc <st_prep_buffer+0x1040>
    48da:	6e ce       	rjmp	.-804    	; 0x45b8 <st_prep_buffer+0xd1c>
    48dc:	df cf       	rjmp	.-66     	; 0x489c <st_prep_buffer+0x1000>
        float rpm = pl_block->spindle_speed;
    48de:	aa 8d       	ldd	r26, Y+26	; 0x1a
    48e0:	bb 8d       	ldd	r27, Y+27	; 0x1b
    48e2:	d2 96       	adiw	r26, 0x32	; 50
    48e4:	6d 91       	ld	r22, X+
    48e6:	7d 91       	ld	r23, X+
    48e8:	8d 91       	ld	r24, X+
    48ea:	9c 91       	ld	r25, X
    48ec:	d5 97       	sbiw	r26, 0x35	; 53
    48ee:	5c ce       	rjmp	.-840    	; 0x45a8 <st_prep_buffer+0xd0c>
    /* -----------------------------------------------------------------------------------
      Compute spindle speed PWM output for step segment
    */
    
    if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
      if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
    48f0:	ea 8d       	ldd	r30, Y+26	; 0x1a
    48f2:	fb 8d       	ldd	r31, Y+27	; 0x1b
    48f4:	81 89       	ldd	r24, Z+17	; 0x11
    48f6:	80 73       	andi	r24, 0x30	; 48
    48f8:	91 f7       	brne	.-28     	; 0x48de <st_prep_buffer+0x1042>
    48fa:	5e ce       	rjmp	.-836    	; 0x45b8 <st_prep_buffer+0xd1c>
        plan_discard_current_block();
      }
    }

  }
}
    48fc:	ec 96       	adiw	r28, 0x3c	; 60
    48fe:	0f b6       	in	r0, 0x3f	; 63
    4900:	f8 94       	cli
    4902:	de bf       	out	0x3e, r29	; 62
    4904:	0f be       	out	0x3f, r0	; 63
    4906:	cd bf       	out	0x3d, r28	; 61
    4908:	df 91       	pop	r29
    490a:	cf 91       	pop	r28
    490c:	1f 91       	pop	r17
    490e:	0f 91       	pop	r16
    4910:	ff 90       	pop	r15
    4912:	ef 90       	pop	r14
    4914:	df 90       	pop	r13
    4916:	cf 90       	pop	r12
    4918:	bf 90       	pop	r11
    491a:	af 90       	pop	r10
    491c:	9f 90       	pop	r9
    491e:	8f 90       	pop	r8
    4920:	7f 90       	pop	r7
    4922:	6f 90       	pop	r6
    4924:	5f 90       	pop	r5
    4926:	4f 90       	pop	r4
    4928:	3f 90       	pop	r3
    492a:	2f 90       	pop	r2
    492c:	08 95       	ret

0000492e <st_get_realtime_rate>:
// however is not exactly the current speed, but the speed computed in the last step segment
// in the segment buffer. It will always be behind by up to the number of segment blocks (-1)
// divided by the ACCELERATION TICKS PER SECOND in seconds.
float st_get_realtime_rate()
{
  if (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)){
    492e:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    4932:	8c 77       	andi	r24, 0x7C	; 124
    4934:	49 f0       	breq	.+18     	; 0x4948 <st_get_realtime_rate+0x1a>
    return prep.current_speed;
    4936:	60 91 1f 03 	lds	r22, 0x031F	; 0x80031f <prep+0x17>
    493a:	70 91 20 03 	lds	r23, 0x0320	; 0x800320 <prep+0x18>
    493e:	80 91 21 03 	lds	r24, 0x0321	; 0x800321 <prep+0x19>
    4942:	90 91 22 03 	lds	r25, 0x0322	; 0x800322 <prep+0x1a>
    4946:	08 95       	ret
  }
  return 0.0f;
    4948:	60 e0       	ldi	r22, 0x00	; 0
    494a:	70 e0       	ldi	r23, 0x00	; 0
    494c:	cb 01       	movw	r24, r22
}
    494e:	08 95       	ret

00004950 <eeprom_get_char>:
 *  \param  addr  EEPROM address to read from.
 *  \return  The byte read from the EEPROM address.
 */
unsigned char eeprom_get_char( unsigned int addr )
{
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    4950:	f9 99       	sbic	0x1f, 1	; 31
    4952:	fe cf       	rjmp	.-4      	; 0x4950 <eeprom_get_char>
	EEAR = addr; // Set EEPROM address register.
    4954:	92 bd       	out	0x22, r25	; 34
    4956:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    4958:	81 e0       	ldi	r24, 0x01	; 1
    495a:	8f bb       	out	0x1f, r24	; 31
	return EEDR; // Return the byte read from EEPROM.
    495c:	80 b5       	in	r24, 0x20	; 32
}
    495e:	08 95       	ret

00004960 <eeprom_put_char>:
void eeprom_put_char( unsigned int addr, unsigned char new_value )
{
	char old_value; // Old EEPROM value.
	char diff_mask; // Difference mask, i.e. old value XOR new value.

	cli(); // Ensure atomic operation for the write operation.
    4960:	f8 94       	cli
	
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    4962:	f9 99       	sbic	0x1f, 1	; 31
    4964:	fe cf       	rjmp	.-4      	; 0x4962 <eeprom_put_char+0x2>
	#ifndef EEPROM_IGNORE_SELFPROG
	do {} while( SPMCSR & (1<<SELFPRGEN) ); // Wait for completion of SPM.
	#endif
	
	EEAR = addr; // Set EEPROM address register.
    4966:	92 bd       	out	0x22, r25	; 34
    4968:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    496a:	81 e0       	ldi	r24, 0x01	; 1
    496c:	8f bb       	out	0x1f, r24	; 31
	old_value = EEDR; // Get old EEPROM value.
    496e:	80 b5       	in	r24, 0x20	; 32
	diff_mask = old_value ^ new_value; // Get bit differences.
    4970:	86 27       	eor	r24, r22
	
	// Check if any bits are changed to '1' in the new value.
	if( diff_mask & new_value ) {
    4972:	96 2f       	mov	r25, r22
    4974:	98 23       	and	r25, r24
    4976:	59 f0       	breq	.+22     	; 0x498e <eeprom_put_char+0x2e>
		// Now we know that _some_ bits need to be erased to '1'.
		
		// Check if any bits in the new value are '0'.
		if( new_value != 0xff ) {
    4978:	6f 3f       	cpi	r22, 0xFF	; 255
    497a:	29 f0       	breq	.+10     	; 0x4986 <eeprom_put_char+0x26>
			// Now we know that some bits need to be programmed to '0' also.
			
			EEDR = new_value; // Set EEPROM data register.
    497c:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    497e:	84 e0       	ldi	r24, 0x04	; 4
    4980:	8f bb       	out	0x1f, r24	; 31
			       (0<<EEPM1) | (0<<EEPM0); // ...and Erase+Write mode.
			EECR |= (1<<EEPE);  // Start Erase+Write operation.
    4982:	f9 9a       	sbi	0x1f, 1	; 31
    4984:	0a c0       	rjmp	.+20     	; 0x499a <eeprom_put_char+0x3a>
		} else {
			// Now we know that all bits should be erased.

			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    4986:	84 e1       	ldi	r24, 0x14	; 20
    4988:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM0);  // ...and Erase-only mode.
			EECR |= (1<<EEPE);  // Start Erase-only operation.
    498a:	f9 9a       	sbi	0x1f, 1	; 31
    498c:	06 c0       	rjmp	.+12     	; 0x499a <eeprom_put_char+0x3a>
		}
	} else {
		// Now we know that _no_ bits need to be erased to '1'.
		
		// Check if any bits are changed from '1' in the old value.
		if( diff_mask ) {
    498e:	88 23       	and	r24, r24
    4990:	21 f0       	breq	.+8      	; 0x499a <eeprom_put_char+0x3a>
			// Now we know that _some_ bits need to the programmed to '0'.
			
			EEDR = new_value;   // Set EEPROM data register.
    4992:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    4994:	84 e2       	ldi	r24, 0x24	; 36
    4996:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM1);  // ...and Write-only mode.
			EECR |= (1<<EEPE);  // Start Write-only operation.
    4998:	f9 9a       	sbi	0x1f, 1	; 31
		}
	}
	
	sei(); // Restore interrupt flag state.
    499a:	78 94       	sei
    499c:	08 95       	ret

0000499e <memcpy_to_eeprom_with_checksum>:
}

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
    499e:	8f 92       	push	r8
    49a0:	9f 92       	push	r9
    49a2:	af 92       	push	r10
    49a4:	bf 92       	push	r11
    49a6:	cf 92       	push	r12
    49a8:	df 92       	push	r13
    49aa:	ef 92       	push	r14
    49ac:	ff 92       	push	r15
    49ae:	0f 93       	push	r16
    49b0:	1f 93       	push	r17
    49b2:	cf 93       	push	r28
    49b4:	df 93       	push	r29
    49b6:	7c 01       	movw	r14, r24
    49b8:	8b 01       	movw	r16, r22
    49ba:	6a 01       	movw	r12, r20
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    49bc:	41 15       	cp	r20, r1
    49be:	51 05       	cpc	r21, r1
    49c0:	01 f1       	breq	.+64     	; 0x4a02 <memcpy_to_eeprom_with_checksum+0x64>
    49c2:	5a 01       	movw	r10, r20
    49c4:	c0 e0       	ldi	r28, 0x00	; 0
    checksum = (checksum << 1) || (checksum >> 7);
    49c6:	d1 e0       	ldi	r29, 0x01	; 1
    49c8:	01 c0       	rjmp	.+2      	; 0x49cc <memcpy_to_eeprom_with_checksum+0x2e>
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
    49ca:	c4 01       	movw	r24, r8


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    49cc:	c1 11       	cpse	r28, r1
    49ce:	08 c0       	rjmp	.+16     	; 0x49e0 <memcpy_to_eeprom_with_checksum+0x42>
    49d0:	6c 2f       	mov	r22, r28
    49d2:	cc 0f       	add	r28, r28
    49d4:	77 0b       	sbc	r23, r23
    49d6:	c7 2f       	mov	r28, r23
    49d8:	cc 1f       	adc	r28, r28
    49da:	cc 27       	eor	r28, r28
    49dc:	cc 1f       	adc	r28, r28
    49de:	01 c0       	rjmp	.+2      	; 0x49e2 <memcpy_to_eeprom_with_checksum+0x44>
    49e0:	cd 2f       	mov	r28, r29
    checksum += *source;
    49e2:	f8 01       	movw	r30, r16
    49e4:	61 91       	ld	r22, Z+
    49e6:	8f 01       	movw	r16, r30
    49e8:	c6 0f       	add	r28, r22
    eeprom_put_char(destination++, *(source++)); 
    49ea:	4c 01       	movw	r8, r24
    49ec:	ff ef       	ldi	r31, 0xFF	; 255
    49ee:	8f 1a       	sub	r8, r31
    49f0:	9f 0a       	sbc	r9, r31
    49f2:	b6 df       	rcall	.-148    	; 0x4960 <eeprom_put_char>
// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    49f4:	21 e0       	ldi	r18, 0x01	; 1
    49f6:	a2 1a       	sub	r10, r18
    49f8:	b1 08       	sbc	r11, r1
    49fa:	39 f7       	brne	.-50     	; 0x49ca <memcpy_to_eeprom_with_checksum+0x2c>
    49fc:	ec 0c       	add	r14, r12
    49fe:	fd 1c       	adc	r15, r13
    4a00:	01 c0       	rjmp	.+2      	; 0x4a04 <memcpy_to_eeprom_with_checksum+0x66>

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
    4a02:	c0 e0       	ldi	r28, 0x00	; 0
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
  }
  eeprom_put_char(destination, checksum);
    4a04:	6c 2f       	mov	r22, r28
    4a06:	c7 01       	movw	r24, r14
    4a08:	ab df       	rcall	.-170    	; 0x4960 <eeprom_put_char>
}
    4a0a:	df 91       	pop	r29
    4a0c:	cf 91       	pop	r28
    4a0e:	1f 91       	pop	r17
    4a10:	0f 91       	pop	r16
    4a12:	ff 90       	pop	r15
    4a14:	ef 90       	pop	r14
    4a16:	df 90       	pop	r13
    4a18:	cf 90       	pop	r12
    4a1a:	bf 90       	pop	r11
    4a1c:	af 90       	pop	r10
    4a1e:	9f 90       	pop	r9
    4a20:	8f 90       	pop	r8
    4a22:	08 95       	ret

00004a24 <memcpy_from_eeprom_with_checksum>:

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
    4a24:	8f 92       	push	r8
    4a26:	9f 92       	push	r9
    4a28:	af 92       	push	r10
    4a2a:	bf 92       	push	r11
    4a2c:	cf 92       	push	r12
    4a2e:	df 92       	push	r13
    4a30:	ef 92       	push	r14
    4a32:	ff 92       	push	r15
    4a34:	0f 93       	push	r16
    4a36:	1f 93       	push	r17
    4a38:	cf 93       	push	r28
    4a3a:	df 93       	push	r29
    4a3c:	7b 01       	movw	r14, r22
    4a3e:	6a 01       	movw	r12, r20
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    4a40:	41 15       	cp	r20, r1
    4a42:	51 05       	cpc	r21, r1
    4a44:	09 f1       	breq	.+66     	; 0x4a88 <memcpy_from_eeprom_with_checksum+0x64>
    4a46:	c8 2f       	mov	r28, r24
    4a48:	d9 2f       	mov	r29, r25
    4a4a:	5a 01       	movw	r10, r20
    4a4c:	cb 01       	movw	r24, r22
    4a4e:	91 2c       	mov	r9, r1
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    4a50:	88 24       	eor	r8, r8
    4a52:	83 94       	inc	r8
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    data = eeprom_get_char(source++);
    4a54:	8c 01       	movw	r16, r24
    4a56:	0f 5f       	subi	r16, 0xFF	; 255
    4a58:	1f 4f       	sbci	r17, 0xFF	; 255
    4a5a:	7a df       	rcall	.-268    	; 0x4950 <eeprom_get_char>
    checksum = (checksum << 1) || (checksum >> 7);
    4a5c:	91 10       	cpse	r9, r1
    4a5e:	08 c0       	rjmp	.+16     	; 0x4a70 <memcpy_from_eeprom_with_checksum+0x4c>
    4a60:	29 2d       	mov	r18, r9
    4a62:	99 0c       	add	r9, r9
    4a64:	33 0b       	sbc	r19, r19
    4a66:	23 2f       	mov	r18, r19
    4a68:	22 1f       	adc	r18, r18
    4a6a:	22 27       	eor	r18, r18
    4a6c:	22 1f       	adc	r18, r18
    4a6e:	01 c0       	rjmp	.+2      	; 0x4a72 <memcpy_from_eeprom_with_checksum+0x4e>
    4a70:	28 2d       	mov	r18, r8
    checksum += data;    
    4a72:	98 2e       	mov	r9, r24
    4a74:	92 0e       	add	r9, r18
    *(destination++) = data; 
    4a76:	89 93       	st	Y+, r24
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    4a78:	81 e0       	ldi	r24, 0x01	; 1
    4a7a:	a8 1a       	sub	r10, r24
    4a7c:	b1 08       	sbc	r11, r1
    data = eeprom_get_char(source++);
    4a7e:	c8 01       	movw	r24, r16
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    4a80:	49 f7       	brne	.-46     	; 0x4a54 <memcpy_from_eeprom_with_checksum+0x30>
    4a82:	ec 0c       	add	r14, r12
    4a84:	fd 1c       	adc	r15, r13
    4a86:	01 c0       	rjmp	.+2      	; 0x4a8a <memcpy_from_eeprom_with_checksum+0x66>
  }
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
    4a88:	91 2c       	mov	r9, r1
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += data;    
    *(destination++) = data; 
  }
  return(checksum == eeprom_get_char(source));
    4a8a:	c7 01       	movw	r24, r14
    4a8c:	61 df       	rcall	.-318    	; 0x4950 <eeprom_get_char>
    4a8e:	21 e0       	ldi	r18, 0x01	; 1
    4a90:	30 e0       	ldi	r19, 0x00	; 0
    4a92:	89 15       	cp	r24, r9
    4a94:	11 f0       	breq	.+4      	; 0x4a9a <memcpy_from_eeprom_with_checksum+0x76>
    4a96:	20 e0       	ldi	r18, 0x00	; 0
    4a98:	30 e0       	ldi	r19, 0x00	; 0
}
    4a9a:	c9 01       	movw	r24, r18
    4a9c:	df 91       	pop	r29
    4a9e:	cf 91       	pop	r28
    4aa0:	1f 91       	pop	r17
    4aa2:	0f 91       	pop	r16
    4aa4:	ff 90       	pop	r15
    4aa6:	ef 90       	pop	r14
    4aa8:	df 90       	pop	r13
    4aaa:	cf 90       	pop	r12
    4aac:	bf 90       	pop	r11
    4aae:	af 90       	pop	r10
    4ab0:	9f 90       	pop	r9
    4ab2:	8f 90       	pop	r8
    4ab4:	08 95       	ret

00004ab6 <settings_store_startup_line>:
    .max_travel[Z_AXIS] = (-DEFAULT_Z_MAX_TRAVEL)};


// Method to store startup lines into EEPROM
void settings_store_startup_line(uint8_t n, char *line)
{
    4ab6:	1f 93       	push	r17
    4ab8:	cf 93       	push	r28
    4aba:	df 93       	push	r29
    4abc:	18 2f       	mov	r17, r24
    4abe:	eb 01       	movw	r28, r22
  #ifdef FORCE_BUFFER_SYNC_DURING_EEPROM_WRITE
    protocol_buffer_synchronize(); // A startup line may contain a motion and be executing. 
    4ac0:	0e 94 2e 19 	call	0x325c	; 0x325c <protocol_buffer_synchronize>
  #endif
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
  memcpy_to_eeprom_with_checksum(addr,(char*)line, LINE_BUFFER_SIZE);
    4ac4:	21 e0       	ldi	r18, 0x01	; 1
    4ac6:	31 e0       	ldi	r19, 0x01	; 1
    4ac8:	12 9f       	mul	r17, r18
    4aca:	c0 01       	movw	r24, r0
    4acc:	13 9f       	mul	r17, r19
    4ace:	90 0d       	add	r25, r0
    4ad0:	11 24       	eor	r1, r1
    4ad2:	40 e0       	ldi	r20, 0x00	; 0
    4ad4:	51 e0       	ldi	r21, 0x01	; 1
    4ad6:	be 01       	movw	r22, r28
    4ad8:	9d 5f       	subi	r25, 0xFD	; 253
    4ada:	61 df       	rcall	.-318    	; 0x499e <memcpy_to_eeprom_with_checksum>
}
    4adc:	df 91       	pop	r29
    4ade:	cf 91       	pop	r28
    4ae0:	1f 91       	pop	r17
    4ae2:	08 95       	ret

00004ae4 <settings_store_build_info>:
// Method to store build info into EEPROM
// NOTE: This function can only be called in IDLE state.
void settings_store_build_info(char *line)
{
  // Build info can only be stored when state is IDLE.
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_BUILD_INFO,(char*)line, LINE_BUFFER_SIZE);
    4ae4:	40 e0       	ldi	r20, 0x00	; 0
    4ae6:	51 e0       	ldi	r21, 0x01	; 1
    4ae8:	bc 01       	movw	r22, r24
    4aea:	8e ea       	ldi	r24, 0xAE	; 174
    4aec:	93 e0       	ldi	r25, 0x03	; 3
    4aee:	57 cf       	rjmp	.-338    	; 0x499e <memcpy_to_eeprom_with_checksum>
    4af0:	08 95       	ret

00004af2 <settings_write_coord_data>:
}


// Method to store coord data parameters into EEPROM
void settings_write_coord_data(uint8_t coord_select, float *coord_data)
{
    4af2:	0f 93       	push	r16
    4af4:	1f 93       	push	r17
    4af6:	cf 93       	push	r28
    4af8:	c8 2f       	mov	r28, r24
    4afa:	8b 01       	movw	r16, r22
  #ifdef FORCE_BUFFER_SYNC_DURING_EEPROM_WRITE
    protocol_buffer_synchronize();
    4afc:	0e 94 2e 19 	call	0x325c	; 0x325c <protocol_buffer_synchronize>
  #endif
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
  memcpy_to_eeprom_with_checksum(addr,(char*)coord_data, sizeof(float)*N_AXIS);
    4b00:	2d e0       	ldi	r18, 0x0D	; 13
    4b02:	c2 9f       	mul	r28, r18
    4b04:	c0 01       	movw	r24, r0
    4b06:	11 24       	eor	r1, r1
    4b08:	4c e0       	ldi	r20, 0x0C	; 12
    4b0a:	50 e0       	ldi	r21, 0x00	; 0
    4b0c:	b8 01       	movw	r22, r16
    4b0e:	9e 5f       	subi	r25, 0xFE	; 254
    4b10:	46 df       	rcall	.-372    	; 0x499e <memcpy_to_eeprom_with_checksum>
}
    4b12:	cf 91       	pop	r28
    4b14:	1f 91       	pop	r17
    4b16:	0f 91       	pop	r16
    4b18:	08 95       	ret

00004b1a <write_global_settings>:

// Method to store Grbl global settings struct and version number into EEPROM
// NOTE: This function can only be called in IDLE state.
void write_global_settings()
{
  eeprom_put_char(0, SETTINGS_VERSION);
    4b1a:	6a e0       	ldi	r22, 0x0A	; 10
    4b1c:	80 e0       	ldi	r24, 0x00	; 0
    4b1e:	90 e0       	ldi	r25, 0x00	; 0
    4b20:	1f df       	rcall	.-450    	; 0x4960 <eeprom_put_char>
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_GLOBAL, (char*)&settings, sizeof(settings_t));
    4b22:	45 e5       	ldi	r20, 0x55	; 85
    4b24:	50 e0       	ldi	r21, 0x00	; 0
    4b26:	60 ed       	ldi	r22, 0xD0	; 208
    4b28:	7e e0       	ldi	r23, 0x0E	; 14
    4b2a:	81 e0       	ldi	r24, 0x01	; 1
    4b2c:	90 e0       	ldi	r25, 0x00	; 0
    4b2e:	37 cf       	rjmp	.-402    	; 0x499e <memcpy_to_eeprom_with_checksum>
    4b30:	08 95       	ret

00004b32 <settings_restore>:
}


// Method to restore EEPROM-saved Grbl global settings back to defaults.
void settings_restore(uint8_t restore_flag) {
    4b32:	0f 93       	push	r16
    4b34:	1f 93       	push	r17
    4b36:	cf 93       	push	r28
    4b38:	df 93       	push	r29
    4b3a:	cd b7       	in	r28, 0x3d	; 61
    4b3c:	de b7       	in	r29, 0x3e	; 62
    4b3e:	2c 97       	sbiw	r28, 0x0c	; 12
    4b40:	0f b6       	in	r0, 0x3f	; 63
    4b42:	f8 94       	cli
    4b44:	de bf       	out	0x3e, r29	; 62
    4b46:	0f be       	out	0x3f, r0	; 63
    4b48:	cd bf       	out	0x3d, r28	; 61
    4b4a:	08 2f       	mov	r16, r24
  if (restore_flag & SETTINGS_RESTORE_DEFAULTS) {
    4b4c:	80 ff       	sbrs	r24, 0
    4b4e:	0a c0       	rjmp	.+20     	; 0x4b64 <settings_restore+0x32>
    settings = defaults;
    4b50:	85 e5       	ldi	r24, 0x55	; 85
    4b52:	ea ee       	ldi	r30, 0xEA	; 234
    4b54:	f2 e0       	ldi	r31, 0x02	; 2
    4b56:	a0 ed       	ldi	r26, 0xD0	; 208
    4b58:	be e0       	ldi	r27, 0x0E	; 14
    4b5a:	05 90       	lpm	r0, Z+
    4b5c:	0d 92       	st	X+, r0
    4b5e:	8a 95       	dec	r24
    4b60:	e1 f7       	brne	.-8      	; 0x4b5a <settings_restore+0x28>
    write_global_settings();
    4b62:	db df       	rcall	.-74     	; 0x4b1a <write_global_settings>
  }

  if (restore_flag & SETTINGS_RESTORE_PARAMETERS) {
    4b64:	01 ff       	sbrs	r16, 1
    4b66:	10 c0       	rjmp	.+32     	; 0x4b88 <settings_restore+0x56>
    uint8_t idx;
    float coord_data[N_AXIS];
    memset(&coord_data, 0, sizeof(coord_data));
    4b68:	fe 01       	movw	r30, r28
    4b6a:	31 96       	adiw	r30, 0x01	; 1
    4b6c:	8c e0       	ldi	r24, 0x0C	; 12
    4b6e:	df 01       	movw	r26, r30
    4b70:	1d 92       	st	X+, r1
    4b72:	8a 95       	dec	r24
    4b74:	e9 f7       	brne	.-6      	; 0x4b70 <settings_restore+0x3e>
    for (idx=0; idx <= SETTING_INDEX_NCOORD; idx++) { settings_write_coord_data(idx, coord_data); }
    4b76:	10 e0       	ldi	r17, 0x00	; 0
    4b78:	be 01       	movw	r22, r28
    4b7a:	6f 5f       	subi	r22, 0xFF	; 255
    4b7c:	7f 4f       	sbci	r23, 0xFF	; 255
    4b7e:	81 2f       	mov	r24, r17
    4b80:	b8 df       	rcall	.-144    	; 0x4af2 <settings_write_coord_data>
    4b82:	1f 5f       	subi	r17, 0xFF	; 255
    4b84:	18 30       	cpi	r17, 0x08	; 8
    4b86:	c1 f7       	brne	.-16     	; 0x4b78 <settings_restore+0x46>
  }

  if (restore_flag & SETTINGS_RESTORE_STARTUP_LINES) {
    4b88:	02 ff       	sbrs	r16, 2
    4b8a:	10 c0       	rjmp	.+32     	; 0x4bac <settings_restore+0x7a>
    #if N_STARTUP_LINE > 0
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK, 0);
    4b8c:	60 e0       	ldi	r22, 0x00	; 0
    4b8e:	80 e0       	ldi	r24, 0x00	; 0
    4b90:	93 e0       	ldi	r25, 0x03	; 3
    4b92:	e6 de       	rcall	.-564    	; 0x4960 <eeprom_put_char>
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+1, 0); // Checksum
    4b94:	60 e0       	ldi	r22, 0x00	; 0
    4b96:	81 e0       	ldi	r24, 0x01	; 1
    4b98:	93 e0       	ldi	r25, 0x03	; 3
    4b9a:	e2 de       	rcall	.-572    	; 0x4960 <eeprom_put_char>
    #endif
    #if N_STARTUP_LINE > 1
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+1), 0);
    4b9c:	60 e0       	ldi	r22, 0x00	; 0
    4b9e:	81 e0       	ldi	r24, 0x01	; 1
    4ba0:	94 e0       	ldi	r25, 0x04	; 4
    4ba2:	de de       	rcall	.-580    	; 0x4960 <eeprom_put_char>
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+2), 0); // Checksum
    4ba4:	60 e0       	ldi	r22, 0x00	; 0
    4ba6:	82 e0       	ldi	r24, 0x02	; 2
    4ba8:	94 e0       	ldi	r25, 0x04	; 4
    4baa:	da de       	rcall	.-588    	; 0x4960 <eeprom_put_char>
    #endif
  }

  if (restore_flag & SETTINGS_RESTORE_BUILD_INFO) {
    4bac:	03 ff       	sbrs	r16, 3
    4bae:	08 c0       	rjmp	.+16     	; 0x4bc0 <settings_restore+0x8e>
    eeprom_put_char(EEPROM_ADDR_BUILD_INFO , 0);
    4bb0:	60 e0       	ldi	r22, 0x00	; 0
    4bb2:	8e ea       	ldi	r24, 0xAE	; 174
    4bb4:	93 e0       	ldi	r25, 0x03	; 3
    4bb6:	d4 de       	rcall	.-600    	; 0x4960 <eeprom_put_char>
    eeprom_put_char(EEPROM_ADDR_BUILD_INFO+1 , 0); // Checksum
    4bb8:	60 e0       	ldi	r22, 0x00	; 0
    4bba:	8f ea       	ldi	r24, 0xAF	; 175
    4bbc:	93 e0       	ldi	r25, 0x03	; 3
    4bbe:	d0 de       	rcall	.-608    	; 0x4960 <eeprom_put_char>
    4bc0:	2c 96       	adiw	r28, 0x0c	; 12
  }
}
    4bc2:	0f b6       	in	r0, 0x3f	; 63
    4bc4:	f8 94       	cli
    4bc6:	de bf       	out	0x3e, r29	; 62
    4bc8:	0f be       	out	0x3f, r0	; 63
    4bca:	cd bf       	out	0x3d, r28	; 61
    4bcc:	df 91       	pop	r29
    4bce:	cf 91       	pop	r28
    4bd0:	1f 91       	pop	r17
    4bd2:	0f 91       	pop	r16
    4bd4:	08 95       	ret

00004bd6 <settings_read_startup_line>:
    4bd6:	1f 93       	push	r17


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_startup_line(uint8_t n, char *line)
{
    4bd8:	cf 93       	push	r28
    4bda:	df 93       	push	r29
    4bdc:	18 2f       	mov	r17, r24
    4bde:	eb 01       	movw	r28, r22
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
  if (!(memcpy_from_eeprom_with_checksum((char*)line, addr, LINE_BUFFER_SIZE))) {
    4be0:	81 e0       	ldi	r24, 0x01	; 1
    4be2:	91 e0       	ldi	r25, 0x01	; 1
    4be4:	18 9f       	mul	r17, r24
    4be6:	b0 01       	movw	r22, r0
    4be8:	19 9f       	mul	r17, r25
    4bea:	70 0d       	add	r23, r0
    4bec:	11 24       	eor	r1, r1
    4bee:	7d 5f       	subi	r23, 0xFD	; 253
    4bf0:	40 e0       	ldi	r20, 0x00	; 0
    4bf2:	51 e0       	ldi	r21, 0x01	; 1
    4bf4:	ce 01       	movw	r24, r28
    4bf6:	16 df       	rcall	.-468    	; 0x4a24 <memcpy_from_eeprom_with_checksum>
    4bf8:	89 2b       	or	r24, r25
    4bfa:	31 f4       	brne	.+12     	; 0x4c08 <settings_read_startup_line+0x32>
    // Reset line with default value
    line[0] = 0; // Empty line
    4bfc:	18 82       	st	Y, r1
    settings_store_startup_line(n, line);
    4bfe:	be 01       	movw	r22, r28
    4c00:	81 2f       	mov	r24, r17
    4c02:	59 df       	rcall	.-334    	; 0x4ab6 <settings_store_startup_line>
    return(false);
    4c04:	80 e0       	ldi	r24, 0x00	; 0
    4c06:	01 c0       	rjmp	.+2      	; 0x4c0a <settings_read_startup_line+0x34>
  }
  return(true);
    4c08:	81 e0       	ldi	r24, 0x01	; 1
}
    4c0a:	df 91       	pop	r29
    4c0c:	cf 91       	pop	r28
    4c0e:	1f 91       	pop	r17
    4c10:	08 95       	ret

00004c12 <settings_read_build_info>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_build_info(char *line)
{
    4c12:	cf 93       	push	r28
    4c14:	df 93       	push	r29
    4c16:	ec 01       	movw	r28, r24
  if (!(memcpy_from_eeprom_with_checksum((char*)line, EEPROM_ADDR_BUILD_INFO, LINE_BUFFER_SIZE))) {
    4c18:	40 e0       	ldi	r20, 0x00	; 0
    4c1a:	51 e0       	ldi	r21, 0x01	; 1
    4c1c:	6e ea       	ldi	r22, 0xAE	; 174
    4c1e:	73 e0       	ldi	r23, 0x03	; 3
    4c20:	01 df       	rcall	.-510    	; 0x4a24 <memcpy_from_eeprom_with_checksum>
    4c22:	89 2b       	or	r24, r25
    4c24:	29 f4       	brne	.+10     	; 0x4c30 <settings_read_build_info+0x1e>
    // Reset line with default value
    line[0] = 0; // Empty line
    4c26:	18 82       	st	Y, r1
    settings_store_build_info(line);
    4c28:	ce 01       	movw	r24, r28
    4c2a:	5c df       	rcall	.-328    	; 0x4ae4 <settings_store_build_info>
    return(false);
    4c2c:	80 e0       	ldi	r24, 0x00	; 0
    4c2e:	01 c0       	rjmp	.+2      	; 0x4c32 <settings_read_build_info+0x20>
  }
  return(true);
    4c30:	81 e0       	ldi	r24, 0x01	; 1
}
    4c32:	df 91       	pop	r29
    4c34:	cf 91       	pop	r28
    4c36:	08 95       	ret

00004c38 <settings_read_coord_data>:


// Read selected coordinate data from EEPROM. Updates pointed coord_data value.
uint8_t settings_read_coord_data(uint8_t coord_select, float *coord_data)
{
    4c38:	1f 93       	push	r17
    4c3a:	cf 93       	push	r28
    4c3c:	df 93       	push	r29
    4c3e:	18 2f       	mov	r17, r24
    4c40:	eb 01       	movw	r28, r22
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
  if (!(memcpy_from_eeprom_with_checksum((char*)coord_data, addr, sizeof(float)*N_AXIS))) {
    4c42:	8d e0       	ldi	r24, 0x0D	; 13
    4c44:	18 9f       	mul	r17, r24
    4c46:	b0 01       	movw	r22, r0
    4c48:	11 24       	eor	r1, r1
    4c4a:	7e 5f       	subi	r23, 0xFE	; 254
    4c4c:	4c e0       	ldi	r20, 0x0C	; 12
    4c4e:	50 e0       	ldi	r21, 0x00	; 0
    4c50:	ce 01       	movw	r24, r28
    4c52:	e8 de       	rcall	.-560    	; 0x4a24 <memcpy_from_eeprom_with_checksum>
    4c54:	89 2b       	or	r24, r25
    4c56:	51 f4       	brne	.+20     	; 0x4c6c <settings_read_coord_data+0x34>
    // Reset with default zero vector
    clear_vector_float(coord_data);
    4c58:	8c e0       	ldi	r24, 0x0C	; 12
    4c5a:	fe 01       	movw	r30, r28
    4c5c:	11 92       	st	Z+, r1
    4c5e:	8a 95       	dec	r24
    4c60:	e9 f7       	brne	.-6      	; 0x4c5c <settings_read_coord_data+0x24>
    settings_write_coord_data(coord_select,coord_data);
    4c62:	be 01       	movw	r22, r28
    4c64:	81 2f       	mov	r24, r17
    4c66:	45 df       	rcall	.-374    	; 0x4af2 <settings_write_coord_data>
    return(false);
    4c68:	80 e0       	ldi	r24, 0x00	; 0
    4c6a:	01 c0       	rjmp	.+2      	; 0x4c6e <settings_read_coord_data+0x36>
  }
  return(true);
    4c6c:	81 e0       	ldi	r24, 0x01	; 1
}
    4c6e:	df 91       	pop	r29
    4c70:	cf 91       	pop	r28
    4c72:	1f 91       	pop	r17
    4c74:	08 95       	ret

00004c76 <read_global_settings>:


// Reads Grbl global settings struct from EEPROM.
uint8_t read_global_settings() {
  // Check version-byte of eeprom
  uint8_t version = eeprom_get_char(0);
    4c76:	80 e0       	ldi	r24, 0x00	; 0
    4c78:	90 e0       	ldi	r25, 0x00	; 0
    4c7a:	6a de       	rcall	.-812    	; 0x4950 <eeprom_get_char>
  if (version == SETTINGS_VERSION) {
    4c7c:	8a 30       	cpi	r24, 0x0A	; 10
    4c7e:	61 f4       	brne	.+24     	; 0x4c98 <read_global_settings+0x22>
    // Read settings-record and check checksum
    if (!(memcpy_from_eeprom_with_checksum((char*)&settings, EEPROM_ADDR_GLOBAL, sizeof(settings_t)))) {
    4c80:	45 e5       	ldi	r20, 0x55	; 85
    4c82:	50 e0       	ldi	r21, 0x00	; 0
    4c84:	61 e0       	ldi	r22, 0x01	; 1
    4c86:	70 e0       	ldi	r23, 0x00	; 0
    4c88:	80 ed       	ldi	r24, 0xD0	; 208
    4c8a:	9e e0       	ldi	r25, 0x0E	; 14
    4c8c:	cb de       	rcall	.-618    	; 0x4a24 <memcpy_from_eeprom_with_checksum>
      return(false);
    4c8e:	21 e0       	ldi	r18, 0x01	; 1
    4c90:	89 2b       	or	r24, r25
    4c92:	19 f4       	brne	.+6      	; 0x4c9a <read_global_settings+0x24>
    4c94:	20 e0       	ldi	r18, 0x00	; 0
    4c96:	01 c0       	rjmp	.+2      	; 0x4c9a <read_global_settings+0x24>
    }
  } else {
    return(false);
    4c98:	20 e0       	ldi	r18, 0x00	; 0
  }
  return(true);
}
    4c9a:	82 2f       	mov	r24, r18
    4c9c:	08 95       	ret

00004c9e <settings_store_global_setting>:


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
    4c9e:	cf 92       	push	r12
    4ca0:	df 92       	push	r13
    4ca2:	ef 92       	push	r14
    4ca4:	ff 92       	push	r15
    4ca6:	cf 93       	push	r28
    4ca8:	df 93       	push	r29
    4caa:	c8 2f       	mov	r28, r24
    4cac:	6a 01       	movw	r12, r20
    4cae:	7b 01       	movw	r14, r22
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); }
    4cb0:	20 e0       	ldi	r18, 0x00	; 0
    4cb2:	30 e0       	ldi	r19, 0x00	; 0
    4cb4:	a9 01       	movw	r20, r18
    4cb6:	c7 01       	movw	r24, r14
    4cb8:	b6 01       	movw	r22, r12
    4cba:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    4cbe:	88 23       	and	r24, r24
    4cc0:	0c f4       	brge	.+2      	; 0x4cc4 <settings_store_global_setting+0x26>
    4cc2:	07 c1       	rjmp	.+526    	; 0x4ed2 <settings_store_global_setting+0x234>
  if (parameter >= AXIS_SETTINGS_START_VAL) {
    4cc4:	c4 36       	cpi	r28, 0x64	; 100
    4cc6:	a0 f0       	brcs	.+40     	; 0x4cf0 <settings_store_global_setting+0x52>
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    4cc8:	ec e9       	ldi	r30, 0x9C	; 156
    4cca:	ec 0f       	add	r30, r28
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    4ccc:	e3 30       	cpi	r30, 0x03	; 3
    4cce:	20 f0       	brcs	.+8      	; 0x4cd8 <settings_store_global_setting+0x3a>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4cd0:	ea 30       	cpi	r30, 0x0A	; 10
    4cd2:	08 f0       	brcs	.+2      	; 0x4cd6 <settings_store_global_setting+0x38>
    4cd4:	0c c1       	rjmp	.+536    	; 0x4eee <settings_store_global_setting+0x250>
    4cd6:	ff c0       	rjmp	.+510    	; 0x4ed6 <settings_store_global_setting+0x238>
        switch (set_idx) {
          case 0:
            #ifdef MAX_STEP_RATE_HZ
              if (value*settings.max_rate[parameter] > (MAX_STEP_RATE_HZ*60.0)) { return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            #endif
            settings.steps_per_mm[parameter] = value;
    4cd8:	f0 e0       	ldi	r31, 0x00	; 0
    4cda:	ee 0f       	add	r30, r30
    4cdc:	ff 1f       	adc	r31, r31
    4cde:	ee 0f       	add	r30, r30
    4ce0:	ff 1f       	adc	r31, r31
    4ce2:	e0 53       	subi	r30, 0x30	; 48
    4ce4:	f1 4f       	sbci	r31, 0xF1	; 241
    4ce6:	c0 82       	st	Z, r12
    4ce8:	d1 82       	std	Z+1, r13	; 0x01
    4cea:	e2 82       	std	Z+2, r14	; 0x02
    4cec:	f3 82       	std	Z+3, r15	; 0x03
            break;
    4cee:	ee c0       	rjmp	.+476    	; 0x4ecc <settings_store_global_setting+0x22e>
        parameter -= AXIS_SETTINGS_INCREMENT;
      }
    }
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    4cf0:	c7 01       	movw	r24, r14
    4cf2:	b6 01       	movw	r22, r12
    4cf4:	0e 94 ac 42 	call	0x8558	; 0x8558 <trunc>
    4cf8:	0e 94 14 40 	call	0x8028	; 0x8028 <__fixunssfsi>
    switch(parameter) {
    4cfc:	8c 2f       	mov	r24, r28
    4cfe:	90 e0       	ldi	r25, 0x00	; 0
    4d00:	81 32       	cpi	r24, 0x21	; 33
    4d02:	91 05       	cpc	r25, r1
    4d04:	08 f0       	brcs	.+2      	; 0x4d08 <settings_store_global_setting+0x6a>
    4d06:	e9 c0       	rjmp	.+466    	; 0x4eda <settings_store_global_setting+0x23c>
    4d08:	fc 01       	movw	r30, r24
    4d0a:	88 27       	eor	r24, r24
    4d0c:	ed 5d       	subi	r30, 0xDD	; 221
    4d0e:	fe 4f       	sbci	r31, 0xFE	; 254
    4d10:	8f 4f       	sbci	r24, 0xFF	; 255
    4d12:	0c 94 ed 42 	jmp	0x85da	; 0x85da <__tablejump2__>
      case 0:
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    4d16:	63 30       	cpi	r22, 0x03	; 3
    4d18:	08 f4       	brcc	.+2      	; 0x4d1c <settings_store_global_setting+0x7e>
    4d1a:	e1 c0       	rjmp	.+450    	; 0x4ede <settings_store_global_setting+0x240>
        settings.pulse_microseconds = int_value; break;
    4d1c:	60 93 00 0f 	sts	0x0F00, r22	; 0x800f00 <settings+0x30>
    4d20:	d5 c0       	rjmp	.+426    	; 0x4ecc <settings_store_global_setting+0x22e>
      case 1: settings.stepper_idle_lock_time = int_value; break;
    4d22:	60 93 03 0f 	sts	0x0F03, r22	; 0x800f03 <settings+0x33>
    4d26:	d2 c0       	rjmp	.+420    	; 0x4ecc <settings_store_global_setting+0x22e>
      case 2:
        settings.step_invert_mask = int_value;
    4d28:	60 93 01 0f 	sts	0x0F01, r22	; 0x800f01 <settings+0x31>
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    4d2c:	0e 94 9b 1b 	call	0x3736	; 0x3736 <st_generate_step_dir_invert_masks>
        break;
    4d30:	cd c0       	rjmp	.+410    	; 0x4ecc <settings_store_global_setting+0x22e>
      case 3:
        settings.dir_invert_mask = int_value;
    4d32:	60 93 02 0f 	sts	0x0F02, r22	; 0x800f02 <settings+0x32>
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    4d36:	0e 94 9b 1b 	call	0x3736	; 0x3736 <st_generate_step_dir_invert_masks>
        break;
    4d3a:	c8 c0       	rjmp	.+400    	; 0x4ecc <settings_store_global_setting+0x22e>
      case 4: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }
    4d3c:	66 23       	and	r22, r22
    4d3e:	31 f0       	breq	.+12     	; 0x4d4c <settings_store_global_setting+0xae>
    4d40:	e5 e1       	ldi	r30, 0x15	; 21
    4d42:	ff e0       	ldi	r31, 0x0F	; 15
    4d44:	80 81       	ld	r24, Z
    4d46:	84 60       	ori	r24, 0x04	; 4
    4d48:	80 83       	st	Z, r24
    4d4a:	c0 c0       	rjmp	.+384    	; 0x4ecc <settings_store_global_setting+0x22e>
        else { settings.flags &= ~BITFLAG_INVERT_ST_ENABLE; }
    4d4c:	e5 e1       	ldi	r30, 0x15	; 21
    4d4e:	ff e0       	ldi	r31, 0x0F	; 15
    4d50:	80 81       	ld	r24, Z
    4d52:	8b 7f       	andi	r24, 0xFB	; 251
    4d54:	80 83       	st	Z, r24
    4d56:	ba c0       	rjmp	.+372    	; 0x4ecc <settings_store_global_setting+0x22e>
        break;
      case 5: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
    4d58:	66 23       	and	r22, r22
    4d5a:	31 f0       	breq	.+12     	; 0x4d68 <settings_store_global_setting+0xca>
    4d5c:	e5 e1       	ldi	r30, 0x15	; 21
    4d5e:	ff e0       	ldi	r31, 0x0F	; 15
    4d60:	80 81       	ld	r24, Z
    4d62:	80 64       	ori	r24, 0x40	; 64
    4d64:	80 83       	st	Z, r24
    4d66:	b2 c0       	rjmp	.+356    	; 0x4ecc <settings_store_global_setting+0x22e>
        else { settings.flags &= ~BITFLAG_INVERT_LIMIT_PINS; }
    4d68:	e5 e1       	ldi	r30, 0x15	; 21
    4d6a:	ff e0       	ldi	r31, 0x0F	; 15
    4d6c:	80 81       	ld	r24, Z
    4d6e:	8f 7b       	andi	r24, 0xBF	; 191
    4d70:	80 83       	st	Z, r24
    4d72:	ac c0       	rjmp	.+344    	; 0x4ecc <settings_store_global_setting+0x22e>
        break;
      case 6: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_PROBE_PIN; }
    4d74:	66 23       	and	r22, r22
    4d76:	31 f0       	breq	.+12     	; 0x4d84 <settings_store_global_setting+0xe6>
    4d78:	e5 e1       	ldi	r30, 0x15	; 21
    4d7a:	ff e0       	ldi	r31, 0x0F	; 15
    4d7c:	80 81       	ld	r24, Z
    4d7e:	80 68       	ori	r24, 0x80	; 128
    4d80:	80 83       	st	Z, r24
    4d82:	05 c0       	rjmp	.+10     	; 0x4d8e <settings_store_global_setting+0xf0>
        else { settings.flags &= ~BITFLAG_INVERT_PROBE_PIN; }
    4d84:	e5 e1       	ldi	r30, 0x15	; 21
    4d86:	ff e0       	ldi	r31, 0x0F	; 15
    4d88:	80 81       	ld	r24, Z
    4d8a:	8f 77       	andi	r24, 0x7F	; 127
    4d8c:	80 83       	st	Z, r24
        probe_configure_invert_mask(false);
    4d8e:	80 e0       	ldi	r24, 0x00	; 0
    4d90:	0e 94 de 34 	call	0x69bc	; 0x69bc <probe_configure_invert_mask>
        break;
    4d94:	9b c0       	rjmp	.+310    	; 0x4ecc <settings_store_global_setting+0x22e>
      case 10: settings.status_report_mask = int_value; break;
    4d96:	60 93 04 0f 	sts	0x0F04, r22	; 0x800f04 <settings+0x34>
    4d9a:	98 c0       	rjmp	.+304    	; 0x4ecc <settings_store_global_setting+0x22e>
      case 11: settings.junction_deviation = value; break;
    4d9c:	c0 92 05 0f 	sts	0x0F05, r12	; 0x800f05 <settings+0x35>
    4da0:	d0 92 06 0f 	sts	0x0F06, r13	; 0x800f06 <settings+0x36>
    4da4:	e0 92 07 0f 	sts	0x0F07, r14	; 0x800f07 <settings+0x37>
    4da8:	f0 92 08 0f 	sts	0x0F08, r15	; 0x800f08 <settings+0x38>
    4dac:	8f c0       	rjmp	.+286    	; 0x4ecc <settings_store_global_setting+0x22e>
      case 12: settings.arc_tolerance = value; break;
    4dae:	c0 92 09 0f 	sts	0x0F09, r12	; 0x800f09 <settings+0x39>
    4db2:	d0 92 0a 0f 	sts	0x0F0A, r13	; 0x800f0a <settings+0x3a>
    4db6:	e0 92 0b 0f 	sts	0x0F0B, r14	; 0x800f0b <settings+0x3b>
    4dba:	f0 92 0c 0f 	sts	0x0F0C, r15	; 0x800f0c <settings+0x3c>
    4dbe:	86 c0       	rjmp	.+268    	; 0x4ecc <settings_store_global_setting+0x22e>
      case 13:
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
    4dc0:	66 23       	and	r22, r22
    4dc2:	31 f0       	breq	.+12     	; 0x4dd0 <settings_store_global_setting+0x132>
    4dc4:	e5 e1       	ldi	r30, 0x15	; 21
    4dc6:	ff e0       	ldi	r31, 0x0F	; 15
    4dc8:	80 81       	ld	r24, Z
    4dca:	81 60       	ori	r24, 0x01	; 1
    4dcc:	80 83       	st	Z, r24
    4dce:	05 c0       	rjmp	.+10     	; 0x4dda <settings_store_global_setting+0x13c>
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
    4dd0:	e5 e1       	ldi	r30, 0x15	; 21
    4dd2:	ff e0       	ldi	r31, 0x0F	; 15
    4dd4:	80 81       	ld	r24, Z
    4dd6:	8e 7f       	andi	r24, 0xFE	; 254
    4dd8:	80 83       	st	Z, r24
        system_flag_wco_change(); // Make sure WCO is immediately updated.
    4dda:	0e 94 32 3b 	call	0x7664	; 0x7664 <system_flag_wco_change>
        break;
    4dde:	76 c0       	rjmp	.+236    	; 0x4ecc <settings_store_global_setting+0x22e>
      case 20:
        if (int_value) {
    4de0:	66 23       	and	r22, r22
    4de2:	41 f0       	breq	.+16     	; 0x4df4 <settings_store_global_setting+0x156>
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    4de4:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    4de8:	84 ff       	sbrs	r24, 4
    4dea:	7b c0       	rjmp	.+246    	; 0x4ee2 <settings_store_global_setting+0x244>
          settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE;
    4dec:	80 62       	ori	r24, 0x20	; 32
    4dee:	80 93 15 0f 	sts	0x0F15, r24	; 0x800f15 <settings+0x45>
    4df2:	6c c0       	rjmp	.+216    	; 0x4ecc <settings_store_global_setting+0x22e>
        } else { settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; }
    4df4:	e5 e1       	ldi	r30, 0x15	; 21
    4df6:	ff e0       	ldi	r31, 0x0F	; 15
    4df8:	80 81       	ld	r24, Z
    4dfa:	8f 7d       	andi	r24, 0xDF	; 223
    4dfc:	80 83       	st	Z, r24
    4dfe:	66 c0       	rjmp	.+204    	; 0x4ecc <settings_store_global_setting+0x22e>
        break;
      case 21:
        if (int_value) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
    4e00:	66 23       	and	r22, r22
    4e02:	31 f0       	breq	.+12     	; 0x4e10 <settings_store_global_setting+0x172>
    4e04:	e5 e1       	ldi	r30, 0x15	; 21
    4e06:	ff e0       	ldi	r31, 0x0F	; 15
    4e08:	80 81       	ld	r24, Z
    4e0a:	88 60       	ori	r24, 0x08	; 8
    4e0c:	80 83       	st	Z, r24
    4e0e:	05 c0       	rjmp	.+10     	; 0x4e1a <settings_store_global_setting+0x17c>
        else { settings.flags &= ~BITFLAG_HARD_LIMIT_ENABLE; }
    4e10:	e5 e1       	ldi	r30, 0x15	; 21
    4e12:	ff e0       	ldi	r31, 0x0F	; 15
    4e14:	80 81       	ld	r24, Z
    4e16:	87 7f       	andi	r24, 0xF7	; 247
    4e18:	80 83       	st	Z, r24
        limits_init(); // Re-init to immediately change. NOTE: Nice to have but could be problematic later.
    4e1a:	0e 94 46 30 	call	0x608c	; 0x608c <limits_init>
        break;
    4e1e:	56 c0       	rjmp	.+172    	; 0x4ecc <settings_store_global_setting+0x22e>
      case 22:
        if (int_value) { settings.flags |= BITFLAG_HOMING_ENABLE; }
    4e20:	66 23       	and	r22, r22
    4e22:	31 f0       	breq	.+12     	; 0x4e30 <settings_store_global_setting+0x192>
    4e24:	e5 e1       	ldi	r30, 0x15	; 21
    4e26:	ff e0       	ldi	r31, 0x0F	; 15
    4e28:	80 81       	ld	r24, Z
    4e2a:	80 61       	ori	r24, 0x10	; 16
    4e2c:	80 83       	st	Z, r24
    4e2e:	4e c0       	rjmp	.+156    	; 0x4ecc <settings_store_global_setting+0x22e>
        else {
          settings.flags &= ~BITFLAG_HOMING_ENABLE;
          settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; // Force disable soft-limits.
    4e30:	e5 e1       	ldi	r30, 0x15	; 21
    4e32:	ff e0       	ldi	r31, 0x0F	; 15
    4e34:	80 81       	ld	r24, Z
    4e36:	8f 7c       	andi	r24, 0xCF	; 207
    4e38:	80 83       	st	Z, r24
    4e3a:	48 c0       	rjmp	.+144    	; 0x4ecc <settings_store_global_setting+0x22e>
        }
        break;
      case 23: settings.homing_dir_mask = int_value; break;
    4e3c:	60 93 16 0f 	sts	0x0F16, r22	; 0x800f16 <settings+0x46>
    4e40:	45 c0       	rjmp	.+138    	; 0x4ecc <settings_store_global_setting+0x22e>
      case 24: settings.homing_feed_rate = value; break;
    4e42:	c0 92 17 0f 	sts	0x0F17, r12	; 0x800f17 <settings+0x47>
    4e46:	d0 92 18 0f 	sts	0x0F18, r13	; 0x800f18 <settings+0x48>
    4e4a:	e0 92 19 0f 	sts	0x0F19, r14	; 0x800f19 <settings+0x49>
    4e4e:	f0 92 1a 0f 	sts	0x0F1A, r15	; 0x800f1a <settings+0x4a>
    4e52:	3c c0       	rjmp	.+120    	; 0x4ecc <settings_store_global_setting+0x22e>
      case 25: settings.homing_seek_rate = value; break;
    4e54:	c0 92 1b 0f 	sts	0x0F1B, r12	; 0x800f1b <settings+0x4b>
    4e58:	d0 92 1c 0f 	sts	0x0F1C, r13	; 0x800f1c <settings+0x4c>
    4e5c:	e0 92 1d 0f 	sts	0x0F1D, r14	; 0x800f1d <settings+0x4d>
    4e60:	f0 92 1e 0f 	sts	0x0F1E, r15	; 0x800f1e <settings+0x4e>
    4e64:	33 c0       	rjmp	.+102    	; 0x4ecc <settings_store_global_setting+0x22e>
      case 26: settings.homing_debounce_delay = int_value; break;
    4e66:	86 2f       	mov	r24, r22
    4e68:	90 e0       	ldi	r25, 0x00	; 0
    4e6a:	90 93 20 0f 	sts	0x0F20, r25	; 0x800f20 <settings+0x50>
    4e6e:	80 93 1f 0f 	sts	0x0F1F, r24	; 0x800f1f <settings+0x4f>
    4e72:	2c c0       	rjmp	.+88     	; 0x4ecc <settings_store_global_setting+0x22e>
      case 27: settings.homing_pulloff = value; break;
    4e74:	c0 92 21 0f 	sts	0x0F21, r12	; 0x800f21 <settings+0x51>
    4e78:	d0 92 22 0f 	sts	0x0F22, r13	; 0x800f22 <settings+0x52>
    4e7c:	e0 92 23 0f 	sts	0x0F23, r14	; 0x800f23 <settings+0x53>
    4e80:	f0 92 24 0f 	sts	0x0F24, r15	; 0x800f24 <settings+0x54>
    4e84:	23 c0       	rjmp	.+70     	; 0x4ecc <settings_store_global_setting+0x22e>
      case 30: settings.rpm_max = value; spindle_init(); break; // Re-initialize spindle rpm calibration
    4e86:	c0 92 0d 0f 	sts	0x0F0D, r12	; 0x800f0d <settings+0x3d>
    4e8a:	d0 92 0e 0f 	sts	0x0F0E, r13	; 0x800f0e <settings+0x3e>
    4e8e:	e0 92 0f 0f 	sts	0x0F0F, r14	; 0x800f0f <settings+0x3f>
    4e92:	f0 92 10 0f 	sts	0x0F10, r15	; 0x800f10 <settings+0x40>
    4e96:	0e 94 91 12 	call	0x2522	; 0x2522 <spindle_init>
    4e9a:	18 c0       	rjmp	.+48     	; 0x4ecc <settings_store_global_setting+0x22e>
      case 31: settings.rpm_min = value; spindle_init(); break; // Re-initialize spindle rpm calibration
    4e9c:	c0 92 11 0f 	sts	0x0F11, r12	; 0x800f11 <settings+0x41>
    4ea0:	d0 92 12 0f 	sts	0x0F12, r13	; 0x800f12 <settings+0x42>
    4ea4:	e0 92 13 0f 	sts	0x0F13, r14	; 0x800f13 <settings+0x43>
    4ea8:	f0 92 14 0f 	sts	0x0F14, r15	; 0x800f14 <settings+0x44>
    4eac:	0e 94 91 12 	call	0x2522	; 0x2522 <spindle_init>
    4eb0:	0d c0       	rjmp	.+26     	; 0x4ecc <settings_store_global_setting+0x22e>
      case 32:
        if (int_value) { settings.flags |= BITFLAG_LASER_MODE; }
    4eb2:	66 23       	and	r22, r22
    4eb4:	31 f0       	breq	.+12     	; 0x4ec2 <settings_store_global_setting+0x224>
    4eb6:	e5 e1       	ldi	r30, 0x15	; 21
    4eb8:	ff e0       	ldi	r31, 0x0F	; 15
    4eba:	80 81       	ld	r24, Z
    4ebc:	82 60       	ori	r24, 0x02	; 2
    4ebe:	80 83       	st	Z, r24
    4ec0:	05 c0       	rjmp	.+10     	; 0x4ecc <settings_store_global_setting+0x22e>
        else { settings.flags &= ~BITFLAG_LASER_MODE; }
    4ec2:	e5 e1       	ldi	r30, 0x15	; 21
    4ec4:	ff e0       	ldi	r31, 0x0F	; 15
    4ec6:	80 81       	ld	r24, Z
    4ec8:	8d 7f       	andi	r24, 0xFD	; 253
    4eca:	80 83       	st	Z, r24
        break;
      default:
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
    4ecc:	26 de       	rcall	.-948    	; 0x4b1a <write_global_settings>
  return(STATUS_OK);
    4ece:	80 e0       	ldi	r24, 0x00	; 0
    4ed0:	58 c0       	rjmp	.+176    	; 0x4f82 <settings_store_global_setting+0x2e4>
}


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); }
    4ed2:	84 e0       	ldi	r24, 0x04	; 4
    4ed4:	56 c0       	rjmp	.+172    	; 0x4f82 <settings_store_global_setting+0x2e4>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4ed6:	83 e0       	ldi	r24, 0x03	; 3
    4ed8:	54 c0       	rjmp	.+168    	; 0x4f82 <settings_store_global_setting+0x2e4>
      case 32:
        if (int_value) { settings.flags |= BITFLAG_LASER_MODE; }
        else { settings.flags &= ~BITFLAG_LASER_MODE; }
        break;
      default:
        return(STATUS_INVALID_STATEMENT);
    4eda:	83 e0       	ldi	r24, 0x03	; 3
    4edc:	52 c0       	rjmp	.+164    	; 0x4f82 <settings_store_global_setting+0x2e4>
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    switch(parameter) {
      case 0:
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    4ede:	86 e0       	ldi	r24, 0x06	; 6
    4ee0:	50 c0       	rjmp	.+160    	; 0x4f82 <settings_store_global_setting+0x2e4>
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
        system_flag_wco_change(); // Make sure WCO is immediately updated.
        break;
      case 20:
        if (int_value) {
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    4ee2:	8a e0       	ldi	r24, 0x0A	; 10
    4ee4:	4e c0       	rjmp	.+156    	; 0x4f82 <settings_store_global_setting+0x2e4>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4ee6:	83 e0       	ldi	r24, 0x03	; 3
    4ee8:	4c c0       	rjmp	.+152    	; 0x4f82 <settings_store_global_setting+0x2e4>
    4eea:	83 e0       	ldi	r24, 0x03	; 3
    4eec:	4a c0       	rjmp	.+148    	; 0x4f82 <settings_store_global_setting+0x2e4>
        parameter -= AXIS_SETTINGS_INCREMENT;
    4eee:	e2 e9       	ldi	r30, 0x92	; 146
    4ef0:	ec 0f       	add	r30, r28
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    4ef2:	e3 30       	cpi	r30, 0x03	; 3
    4ef4:	70 f0       	brcs	.+28     	; 0x4f12 <settings_store_global_setting+0x274>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4ef6:	ea 30       	cpi	r30, 0x0A	; 10
    4ef8:	b0 f3       	brcs	.-20     	; 0x4ee6 <settings_store_global_setting+0x248>
        parameter -= AXIS_SETTINGS_INCREMENT;
    4efa:	88 e8       	ldi	r24, 0x88	; 136
    4efc:	8c 0f       	add	r24, r28
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    4efe:	83 30       	cpi	r24, 0x03	; 3
    4f00:	a0 f0       	brcs	.+40     	; 0x4f2a <settings_store_global_setting+0x28c>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4f02:	8a 30       	cpi	r24, 0x0A	; 10
    4f04:	90 f3       	brcs	.-28     	; 0x4eea <settings_store_global_setting+0x24c>
        parameter -= AXIS_SETTINGS_INCREMENT;
    4f06:	8e e7       	ldi	r24, 0x7E	; 126
    4f08:	8c 0f       	add	r24, r28
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    4f0a:	83 30       	cpi	r24, 0x03	; 3
    4f0c:	48 f1       	brcs	.+82     	; 0x4f60 <settings_store_global_setting+0x2c2>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4f0e:	83 e0       	ldi	r24, 0x03	; 3
    4f10:	38 c0       	rjmp	.+112    	; 0x4f82 <settings_store_global_setting+0x2e4>
            break;
          case 1:
            #ifdef MAX_STEP_RATE_HZ
              if (value*settings.steps_per_mm[parameter] > (MAX_STEP_RATE_HZ*60.0)) {  return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            #endif
            settings.max_rate[parameter] = value;
    4f12:	f0 e0       	ldi	r31, 0x00	; 0
    4f14:	ee 0f       	add	r30, r30
    4f16:	ff 1f       	adc	r31, r31
    4f18:	ee 0f       	add	r30, r30
    4f1a:	ff 1f       	adc	r31, r31
    4f1c:	e4 52       	subi	r30, 0x24	; 36
    4f1e:	f1 4f       	sbci	r31, 0xF1	; 241
    4f20:	c0 82       	st	Z, r12
    4f22:	d1 82       	std	Z+1, r13	; 0x01
    4f24:	e2 82       	std	Z+2, r14	; 0x02
    4f26:	f3 82       	std	Z+3, r15	; 0x03
            break;
    4f28:	d1 cf       	rjmp	.-94     	; 0x4ecc <settings_store_global_setting+0x22e>
          case 2: settings.acceleration[parameter] = value*60*60; break; // Convert to mm/min^2 for grbl internal use.
    4f2a:	c8 2f       	mov	r28, r24
    4f2c:	d0 e0       	ldi	r29, 0x00	; 0
    4f2e:	cc 0f       	add	r28, r28
    4f30:	dd 1f       	adc	r29, r29
    4f32:	cc 0f       	add	r28, r28
    4f34:	dd 1f       	adc	r29, r29
    4f36:	c8 51       	subi	r28, 0x18	; 24
    4f38:	d1 4f       	sbci	r29, 0xF1	; 241
    4f3a:	20 e0       	ldi	r18, 0x00	; 0
    4f3c:	30 e0       	ldi	r19, 0x00	; 0
    4f3e:	40 e7       	ldi	r20, 0x70	; 112
    4f40:	52 e4       	ldi	r21, 0x42	; 66
    4f42:	c7 01       	movw	r24, r14
    4f44:	b6 01       	movw	r22, r12
    4f46:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    4f4a:	20 e0       	ldi	r18, 0x00	; 0
    4f4c:	30 e0       	ldi	r19, 0x00	; 0
    4f4e:	40 e7       	ldi	r20, 0x70	; 112
    4f50:	52 e4       	ldi	r21, 0x42	; 66
    4f52:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    4f56:	68 83       	st	Y, r22
    4f58:	79 83       	std	Y+1, r23	; 0x01
    4f5a:	8a 83       	std	Y+2, r24	; 0x02
    4f5c:	9b 83       	std	Y+3, r25	; 0x03
    4f5e:	b6 cf       	rjmp	.-148    	; 0x4ecc <settings_store_global_setting+0x22e>
          case 3: settings.max_travel[parameter] = -value; break;  // Store as negative for grbl internal use.
    4f60:	e8 2f       	mov	r30, r24
    4f62:	f0 e0       	ldi	r31, 0x00	; 0
    4f64:	ee 0f       	add	r30, r30
    4f66:	ff 1f       	adc	r31, r31
    4f68:	ee 0f       	add	r30, r30
    4f6a:	ff 1f       	adc	r31, r31
    4f6c:	ec 50       	subi	r30, 0x0C	; 12
    4f6e:	f1 4f       	sbci	r31, 0xF1	; 241
    4f70:	f7 fa       	bst	r15, 7
    4f72:	f0 94       	com	r15
    4f74:	f7 f8       	bld	r15, 7
    4f76:	f0 94       	com	r15
    4f78:	c0 82       	st	Z, r12
    4f7a:	d1 82       	std	Z+1, r13	; 0x01
    4f7c:	e2 82       	std	Z+2, r14	; 0x02
    4f7e:	f3 82       	std	Z+3, r15	; 0x03
    4f80:	a5 cf       	rjmp	.-182    	; 0x4ecc <settings_store_global_setting+0x22e>
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
  return(STATUS_OK);
}
    4f82:	df 91       	pop	r29
    4f84:	cf 91       	pop	r28
    4f86:	ff 90       	pop	r15
    4f88:	ef 90       	pop	r14
    4f8a:	df 90       	pop	r13
    4f8c:	cf 90       	pop	r12
    4f8e:	08 95       	ret

00004f90 <settings_init>:


// Initialize the config subsystem
void settings_init() {
  if(!read_global_settings()) {
    4f90:	72 de       	rcall	.-796    	; 0x4c76 <read_global_settings>
    4f92:	81 11       	cpse	r24, r1
    4f94:	07 c0       	rjmp	.+14     	; 0x4fa4 <settings_init+0x14>
    report_status_message(STATUS_SETTING_READ_FAIL);
    4f96:	87 e0       	ldi	r24, 0x07	; 7
    4f98:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <report_status_message>
    settings_restore(SETTINGS_RESTORE_ALL); // Force restore all EEPROM data.
    4f9c:	8f ef       	ldi	r24, 0xFF	; 255
    4f9e:	c9 dd       	rcall	.-1134   	; 0x4b32 <settings_restore>
    report_grbl_settings();
    4fa0:	0c 94 1d 36 	jmp	0x6c3a	; 0x6c3a <report_grbl_settings>
    4fa4:	08 95       	ret

00004fa6 <get_step_pin_mask>:
  #ifdef DEFAULTS_RAMPS_BOARD
    if ( axis_idx == X_AXIS ) { return((1<<STEP_BIT(X_AXIS))); }
    if ( axis_idx == Y_AXIS ) { return((1<<STEP_BIT(Y_AXIS))); }
    return((1<<STEP_BIT(Z_AXIS)));
  #else
    if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    4fa6:	88 23       	and	r24, r24
    4fa8:	21 f0       	breq	.+8      	; 0x4fb2 <get_step_pin_mask+0xc>
    if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    4faa:	81 30       	cpi	r24, 0x01	; 1
    4fac:	21 f0       	breq	.+8      	; 0x4fb6 <get_step_pin_mask+0x10>
    return((1<<Z_STEP_BIT));
    4fae:	80 e1       	ldi	r24, 0x10	; 16
    4fb0:	08 95       	ret
  #ifdef DEFAULTS_RAMPS_BOARD
    if ( axis_idx == X_AXIS ) { return((1<<STEP_BIT(X_AXIS))); }
    if ( axis_idx == Y_AXIS ) { return((1<<STEP_BIT(Y_AXIS))); }
    return((1<<STEP_BIT(Z_AXIS)));
  #else
    if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    4fb2:	84 e0       	ldi	r24, 0x04	; 4
    4fb4:	08 95       	ret
    if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    4fb6:	88 e0       	ldi	r24, 0x08	; 8
    return((1<<Z_STEP_BIT));
  #endif // DEFAULTS_RAMPS_BOARD
}
    4fb8:	08 95       	ret

00004fba <get_direction_pin_mask>:
  #ifdef DEFAULTS_RAMPS_BOARD
    if ( axis_idx == X_AXIS ) { return((1<<DIRECTION_BIT(X_AXIS))); }
    if ( axis_idx == Y_AXIS ) { return((1<<DIRECTION_BIT(Y_AXIS))); }
    return((1<<DIRECTION_BIT(Z_AXIS)));
  #else
    if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    4fba:	88 23       	and	r24, r24
    4fbc:	21 f0       	breq	.+8      	; 0x4fc6 <get_direction_pin_mask+0xc>
    if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    4fbe:	81 30       	cpi	r24, 0x01	; 1
    4fc0:	21 f0       	breq	.+8      	; 0x4fca <get_direction_pin_mask+0x10>
    return((1<<Z_DIRECTION_BIT));
    4fc2:	80 e2       	ldi	r24, 0x20	; 32
    4fc4:	08 95       	ret
  #ifdef DEFAULTS_RAMPS_BOARD
    if ( axis_idx == X_AXIS ) { return((1<<DIRECTION_BIT(X_AXIS))); }
    if ( axis_idx == Y_AXIS ) { return((1<<DIRECTION_BIT(Y_AXIS))); }
    return((1<<DIRECTION_BIT(Z_AXIS)));
  #else
    if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    4fc6:	80 e8       	ldi	r24, 0x80	; 128
    4fc8:	08 95       	ret
    if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    4fca:	80 e4       	ldi	r24, 0x40	; 64
    return((1<<Z_DIRECTION_BIT));
  #endif // DEFAULTS_RAMPS_BOARD
}
    4fcc:	08 95       	ret

00004fce <get_limit_pin_mask>:
     return((1<<MAX_LIMIT_BIT(Z_AXIS)));
  }
#else
  uint8_t get_limit_pin_mask(uint8_t axis_idx)
  {
    if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    4fce:	88 23       	and	r24, r24
    4fd0:	21 f0       	breq	.+8      	; 0x4fda <get_limit_pin_mask+0xc>
    if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    4fd2:	81 30       	cpi	r24, 0x01	; 1
    4fd4:	21 f0       	breq	.+8      	; 0x4fde <get_limit_pin_mask+0x10>
    return((1<<Z_LIMIT_BIT));
    4fd6:	80 e4       	ldi	r24, 0x40	; 64
    4fd8:	08 95       	ret
     return((1<<MAX_LIMIT_BIT(Z_AXIS)));
  }
#else
  uint8_t get_limit_pin_mask(uint8_t axis_idx)
  {
    if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    4fda:	80 e1       	ldi	r24, 0x10	; 16
    4fdc:	08 95       	ret
    if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    4fde:	80 e2       	ldi	r24, 0x20	; 32
    return((1<<Z_LIMIT_BIT));
  }
    4fe0:	08 95       	ret

00004fe2 <planner_recalculate>:
// NOTE: Deprecated. Not used unless classic status reports are enabled in config.h
uint8_t plan_get_block_buffer_count()
{
  if (block_buffer_head >= block_buffer_tail) { return(block_buffer_head-block_buffer_tail); }
  return(BLOCK_BUFFER_SIZE - (block_buffer_tail-block_buffer_head));
}
    4fe2:	2f 92       	push	r2
    4fe4:	3f 92       	push	r3
    4fe6:	4f 92       	push	r4
    4fe8:	5f 92       	push	r5
    4fea:	6f 92       	push	r6
    4fec:	7f 92       	push	r7
    4fee:	8f 92       	push	r8
    4ff0:	9f 92       	push	r9
    4ff2:	af 92       	push	r10
    4ff4:	bf 92       	push	r11
    4ff6:	cf 92       	push	r12
    4ff8:	df 92       	push	r13
    4ffa:	ef 92       	push	r14
    4ffc:	ff 92       	push	r15
    4ffe:	0f 93       	push	r16
    5000:	1f 93       	push	r17
    5002:	cf 93       	push	r28
    5004:	df 93       	push	r29
    5006:	c0 91 76 04 	lds	r28, 0x0476	; 0x800476 <block_buffer_head>
    500a:	c1 11       	cpse	r28, r1
    500c:	01 c0       	rjmp	.+2      	; 0x5010 <planner_recalculate+0x2e>
    500e:	c4 e2       	ldi	r28, 0x24	; 36
    5010:	c1 50       	subi	r28, 0x01	; 1
    5012:	d0 91 74 04 	lds	r29, 0x0474	; 0x800474 <block_buffer_planned>
    5016:	dc 17       	cp	r29, r28
    5018:	09 f4       	brne	.+2      	; 0x501c <planner_recalculate+0x3a>
    501a:	36 c1       	rjmp	.+620    	; 0x5288 <planner_recalculate+0x2a6>
    501c:	0c 2f       	mov	r16, r28
    501e:	10 e0       	ldi	r17, 0x00	; 0
    5020:	26 e3       	ldi	r18, 0x36	; 54
    5022:	c2 9f       	mul	r28, r18
    5024:	c0 01       	movw	r24, r0
    5026:	11 24       	eor	r1, r1
    5028:	fc 01       	movw	r30, r24
    502a:	e8 58       	subi	r30, 0x88	; 136
    502c:	fb 4f       	sbci	r31, 0xFB	; 251
    502e:	6f 01       	movw	r12, r30
    5030:	e2 8c       	ldd	r14, Z+26	; 0x1a
    5032:	f3 8c       	ldd	r15, Z+27	; 0x1b
    5034:	94 8c       	ldd	r9, Z+28	; 0x1c
    5036:	85 8c       	ldd	r8, Z+29	; 0x1d
    5038:	66 8d       	ldd	r22, Z+30	; 0x1e
    503a:	77 8d       	ldd	r23, Z+31	; 0x1f
    503c:	80 a1       	ldd	r24, Z+32	; 0x20
    503e:	91 a1       	ldd	r25, Z+33	; 0x21
    5040:	9b 01       	movw	r18, r22
    5042:	ac 01       	movw	r20, r24
    5044:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    5048:	f6 01       	movw	r30, r12
    504a:	22 a1       	ldd	r18, Z+34	; 0x22
    504c:	33 a1       	ldd	r19, Z+35	; 0x23
    504e:	44 a1       	ldd	r20, Z+36	; 0x24
    5050:	55 a1       	ldd	r21, Z+37	; 0x25
    5052:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    5056:	a6 2e       	mov	r10, r22
    5058:	b7 2e       	mov	r11, r23
    505a:	c8 2e       	mov	r12, r24
    505c:	d9 2e       	mov	r13, r25
    505e:	26 2f       	mov	r18, r22
    5060:	37 2f       	mov	r19, r23
    5062:	48 2f       	mov	r20, r24
    5064:	59 2f       	mov	r21, r25
    5066:	6e 2d       	mov	r22, r14
    5068:	7f 2d       	mov	r23, r15
    506a:	89 2d       	mov	r24, r9
    506c:	98 2d       	mov	r25, r8
    506e:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    5072:	88 23       	and	r24, r24
    5074:	24 f0       	brlt	.+8      	; 0x507e <planner_recalculate+0x9c>
    5076:	ea 2c       	mov	r14, r10
    5078:	fb 2c       	mov	r15, r11
    507a:	9c 2c       	mov	r9, r12
    507c:	8d 2c       	mov	r8, r13
    507e:	86 e3       	ldi	r24, 0x36	; 54
    5080:	80 9f       	mul	r24, r16
    5082:	f0 01       	movw	r30, r0
    5084:	81 9f       	mul	r24, r17
    5086:	f0 0d       	add	r31, r0
    5088:	11 24       	eor	r1, r1
    508a:	e8 58       	subi	r30, 0x88	; 136
    508c:	fb 4f       	sbci	r31, 0xFB	; 251
    508e:	8e 2d       	mov	r24, r14
    5090:	9f 2d       	mov	r25, r15
    5092:	a9 2d       	mov	r26, r9
    5094:	b8 2d       	mov	r27, r8
    5096:	86 8b       	std	Z+22, r24	; 0x16
    5098:	97 8b       	std	Z+23, r25	; 0x17
    509a:	a0 8f       	std	Z+24, r26	; 0x18
    509c:	b1 8f       	std	Z+25, r27	; 0x19
    509e:	c1 11       	cpse	r28, r1
    50a0:	01 c0       	rjmp	.+2      	; 0x50a4 <planner_recalculate+0xc2>
    50a2:	c4 e2       	ldi	r28, 0x24	; 36
    50a4:	c1 50       	subi	r28, 0x01	; 1
    50a6:	dc 13       	cpse	r29, r28
    50a8:	07 c0       	rjmp	.+14     	; 0x50b8 <planner_recalculate+0xd6>
    50aa:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    50ae:	d8 13       	cpse	r29, r24
    50b0:	7c c0       	rjmp	.+248    	; 0x51aa <planner_recalculate+0x1c8>
    50b2:	0e 94 2e 1c 	call	0x385c	; 0x385c <st_update_plan_block_parameters>
    50b6:	79 c0       	rjmp	.+242    	; 0x51aa <planner_recalculate+0x1c8>
    50b8:	26 e3       	ldi	r18, 0x36	; 54
    50ba:	20 9f       	mul	r18, r16
    50bc:	c0 01       	movw	r24, r0
    50be:	21 9f       	mul	r18, r17
    50c0:	90 0d       	add	r25, r0
    50c2:	11 24       	eor	r1, r1
    50c4:	9c 01       	movw	r18, r24
    50c6:	28 58       	subi	r18, 0x88	; 136
    50c8:	3b 4f       	sbci	r19, 0xFB	; 251
    50ca:	69 01       	movw	r12, r18
    50cc:	d6 e3       	ldi	r29, 0x36	; 54
    50ce:	ec 2e       	mov	r14, r28
    50d0:	f1 2c       	mov	r15, r1
    50d2:	de 9d       	mul	r29, r14
    50d4:	80 01       	movw	r16, r0
    50d6:	df 9d       	mul	r29, r15
    50d8:	10 0d       	add	r17, r0
    50da:	11 24       	eor	r1, r1
    50dc:	08 58       	subi	r16, 0x88	; 136
    50de:	1b 4f       	sbci	r17, 0xFB	; 251
    50e0:	c1 11       	cpse	r28, r1
    50e2:	01 c0       	rjmp	.+2      	; 0x50e6 <planner_recalculate+0x104>
    50e4:	c4 e2       	ldi	r28, 0x24	; 36
    50e6:	c1 50       	subi	r28, 0x01	; 1
    50e8:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    50ec:	8c 13       	cpse	r24, r28
    50ee:	02 c0       	rjmp	.+4      	; 0x50f4 <planner_recalculate+0x112>
    50f0:	0e 94 2e 1c 	call	0x385c	; 0x385c <st_update_plan_block_parameters>
    50f4:	de 9d       	mul	r29, r14
    50f6:	f0 01       	movw	r30, r0
    50f8:	df 9d       	mul	r29, r15
    50fa:	f0 0d       	add	r31, r0
    50fc:	11 24       	eor	r1, r1
    50fe:	e8 58       	subi	r30, 0x88	; 136
    5100:	fb 4f       	sbci	r31, 0xFB	; 251
    5102:	42 8c       	ldd	r4, Z+26	; 0x1a
    5104:	53 8c       	ldd	r5, Z+27	; 0x1b
    5106:	64 8c       	ldd	r6, Z+28	; 0x1c
    5108:	75 8c       	ldd	r7, Z+29	; 0x1d
    510a:	a3 01       	movw	r20, r6
    510c:	92 01       	movw	r18, r4
    510e:	66 89       	ldd	r22, Z+22	; 0x16
    5110:	77 89       	ldd	r23, Z+23	; 0x17
    5112:	80 8d       	ldd	r24, Z+24	; 0x18
    5114:	91 8d       	ldd	r25, Z+25	; 0x19
    5116:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    511a:	88 23       	and	r24, r24
    511c:	09 f4       	brne	.+2      	; 0x5120 <planner_recalculate+0x13e>
    511e:	40 c0       	rjmp	.+128    	; 0x51a0 <planner_recalculate+0x1be>
    5120:	de 9d       	mul	r29, r14
    5122:	c0 01       	movw	r24, r0
    5124:	df 9d       	mul	r29, r15
    5126:	90 0d       	add	r25, r0
    5128:	11 24       	eor	r1, r1
    512a:	fc 01       	movw	r30, r24
    512c:	e8 58       	subi	r30, 0x88	; 136
    512e:	fb 4f       	sbci	r31, 0xFB	; 251
    5130:	5f 01       	movw	r10, r30
    5132:	66 8d       	ldd	r22, Z+30	; 0x1e
    5134:	77 8d       	ldd	r23, Z+31	; 0x1f
    5136:	80 a1       	ldd	r24, Z+32	; 0x20
    5138:	91 a1       	ldd	r25, Z+33	; 0x21
    513a:	9b 01       	movw	r18, r22
    513c:	ac 01       	movw	r20, r24
    513e:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    5142:	f5 01       	movw	r30, r10
    5144:	22 a1       	ldd	r18, Z+34	; 0x22
    5146:	33 a1       	ldd	r19, Z+35	; 0x23
    5148:	44 a1       	ldd	r20, Z+36	; 0x24
    514a:	55 a1       	ldd	r21, Z+37	; 0x25
    514c:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    5150:	f6 01       	movw	r30, r12
    5152:	26 89       	ldd	r18, Z+22	; 0x16
    5154:	37 89       	ldd	r19, Z+23	; 0x17
    5156:	40 8d       	ldd	r20, Z+24	; 0x18
    5158:	51 8d       	ldd	r21, Z+25	; 0x19
    515a:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    515e:	4b 01       	movw	r8, r22
    5160:	5c 01       	movw	r10, r24
    5162:	9b 01       	movw	r18, r22
    5164:	ac 01       	movw	r20, r24
    5166:	c3 01       	movw	r24, r6
    5168:	b2 01       	movw	r22, r4
    516a:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    516e:	18 16       	cp	r1, r24
    5170:	64 f4       	brge	.+24     	; 0x518a <planner_recalculate+0x1a8>
    5172:	de 9d       	mul	r29, r14
    5174:	f0 01       	movw	r30, r0
    5176:	df 9d       	mul	r29, r15
    5178:	f0 0d       	add	r31, r0
    517a:	11 24       	eor	r1, r1
    517c:	e8 58       	subi	r30, 0x88	; 136
    517e:	fb 4f       	sbci	r31, 0xFB	; 251
    5180:	86 8a       	std	Z+22, r8	; 0x16
    5182:	97 8a       	std	Z+23, r9	; 0x17
    5184:	a0 8e       	std	Z+24, r10	; 0x18
    5186:	b1 8e       	std	Z+25, r11	; 0x19
    5188:	0b c0       	rjmp	.+22     	; 0x51a0 <planner_recalculate+0x1be>
    518a:	de 9d       	mul	r29, r14
    518c:	f0 01       	movw	r30, r0
    518e:	df 9d       	mul	r29, r15
    5190:	f0 0d       	add	r31, r0
    5192:	11 24       	eor	r1, r1
    5194:	e8 58       	subi	r30, 0x88	; 136
    5196:	fb 4f       	sbci	r31, 0xFB	; 251
    5198:	46 8a       	std	Z+22, r4	; 0x16
    519a:	57 8a       	std	Z+23, r5	; 0x17
    519c:	60 8e       	std	Z+24, r6	; 0x18
    519e:	71 8e       	std	Z+25, r7	; 0x19
    51a0:	68 01       	movw	r12, r16
    51a2:	80 91 74 04 	lds	r24, 0x0474	; 0x800474 <block_buffer_planned>
    51a6:	8c 13       	cpse	r24, r28
    51a8:	92 cf       	rjmp	.-220    	; 0x50ce <planner_recalculate+0xec>
    51aa:	20 90 74 04 	lds	r2, 0x0474	; 0x800474 <block_buffer_planned>
    51ae:	f6 e3       	ldi	r31, 0x36	; 54
    51b0:	2f 9e       	mul	r2, r31
    51b2:	c0 01       	movw	r24, r0
    51b4:	11 24       	eor	r1, r1
    51b6:	9c 01       	movw	r18, r24
    51b8:	28 58       	subi	r18, 0x88	; 136
    51ba:	3b 4f       	sbci	r19, 0xFB	; 251
    51bc:	79 01       	movw	r14, r18
    51be:	c1 e0       	ldi	r28, 0x01	; 1
    51c0:	c2 0d       	add	r28, r2
    51c2:	c4 32       	cpi	r28, 0x24	; 36
    51c4:	09 f4       	brne	.+2      	; 0x51c8 <planner_recalculate+0x1e6>
    51c6:	c0 e0       	ldi	r28, 0x00	; 0
    51c8:	30 90 76 04 	lds	r3, 0x0476	; 0x800476 <block_buffer_head>
    51cc:	d6 e3       	ldi	r29, 0x36	; 54
    51ce:	58 c0       	rjmp	.+176    	; 0x5280 <planner_recalculate+0x29e>
    51d0:	cc 2e       	mov	r12, r28
    51d2:	d1 2c       	mov	r13, r1
    51d4:	dc 9d       	mul	r29, r12
    51d6:	80 01       	movw	r16, r0
    51d8:	dd 9d       	mul	r29, r13
    51da:	10 0d       	add	r17, r0
    51dc:	11 24       	eor	r1, r1
    51de:	08 58       	subi	r16, 0x88	; 136
    51e0:	1b 4f       	sbci	r17, 0xFB	; 251
    51e2:	f7 01       	movw	r30, r14
    51e4:	46 88       	ldd	r4, Z+22	; 0x16
    51e6:	57 88       	ldd	r5, Z+23	; 0x17
    51e8:	60 8c       	ldd	r6, Z+24	; 0x18
    51ea:	71 8c       	ldd	r7, Z+25	; 0x19
    51ec:	f8 01       	movw	r30, r16
    51ee:	86 88       	ldd	r8, Z+22	; 0x16
    51f0:	97 88       	ldd	r9, Z+23	; 0x17
    51f2:	a0 8c       	ldd	r10, Z+24	; 0x18
    51f4:	b1 8c       	ldd	r11, Z+25	; 0x19
    51f6:	a5 01       	movw	r20, r10
    51f8:	94 01       	movw	r18, r8
    51fa:	c3 01       	movw	r24, r6
    51fc:	b2 01       	movw	r22, r4
    51fe:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    5202:	88 23       	and	r24, r24
    5204:	24 f5       	brge	.+72     	; 0x524e <planner_recalculate+0x26c>
    5206:	f7 01       	movw	r30, r14
    5208:	66 8d       	ldd	r22, Z+30	; 0x1e
    520a:	77 8d       	ldd	r23, Z+31	; 0x1f
    520c:	80 a1       	ldd	r24, Z+32	; 0x20
    520e:	91 a1       	ldd	r25, Z+33	; 0x21
    5210:	9b 01       	movw	r18, r22
    5212:	ac 01       	movw	r20, r24
    5214:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    5218:	f7 01       	movw	r30, r14
    521a:	22 a1       	ldd	r18, Z+34	; 0x22
    521c:	33 a1       	ldd	r19, Z+35	; 0x23
    521e:	44 a1       	ldd	r20, Z+36	; 0x24
    5220:	55 a1       	ldd	r21, Z+37	; 0x25
    5222:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    5226:	a3 01       	movw	r20, r6
    5228:	92 01       	movw	r18, r4
    522a:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    522e:	2b 01       	movw	r4, r22
    5230:	3c 01       	movw	r6, r24
    5232:	9b 01       	movw	r18, r22
    5234:	ac 01       	movw	r20, r24
    5236:	c5 01       	movw	r24, r10
    5238:	b4 01       	movw	r22, r8
    523a:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    523e:	18 16       	cp	r1, r24
    5240:	34 f4       	brge	.+12     	; 0x524e <planner_recalculate+0x26c>
    5242:	f8 01       	movw	r30, r16
    5244:	46 8a       	std	Z+22, r4	; 0x16
    5246:	57 8a       	std	Z+23, r5	; 0x17
    5248:	60 8e       	std	Z+24, r6	; 0x18
    524a:	71 8e       	std	Z+25, r7	; 0x19
    524c:	2c 2e       	mov	r2, r28
    524e:	dc 9d       	mul	r29, r12
    5250:	f0 01       	movw	r30, r0
    5252:	dd 9d       	mul	r29, r13
    5254:	f0 0d       	add	r31, r0
    5256:	11 24       	eor	r1, r1
    5258:	e8 58       	subi	r30, 0x88	; 136
    525a:	fb 4f       	sbci	r31, 0xFB	; 251
    525c:	22 8d       	ldd	r18, Z+26	; 0x1a
    525e:	33 8d       	ldd	r19, Z+27	; 0x1b
    5260:	44 8d       	ldd	r20, Z+28	; 0x1c
    5262:	55 8d       	ldd	r21, Z+29	; 0x1d
    5264:	66 89       	ldd	r22, Z+22	; 0x16
    5266:	77 89       	ldd	r23, Z+23	; 0x17
    5268:	80 8d       	ldd	r24, Z+24	; 0x18
    526a:	91 8d       	ldd	r25, Z+25	; 0x19
    526c:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    5270:	81 11       	cpse	r24, r1
    5272:	01 c0       	rjmp	.+2      	; 0x5276 <planner_recalculate+0x294>
    5274:	2c 2e       	mov	r2, r28
    5276:	cf 5f       	subi	r28, 0xFF	; 255
    5278:	c4 32       	cpi	r28, 0x24	; 36
    527a:	09 f4       	brne	.+2      	; 0x527e <planner_recalculate+0x29c>
    527c:	c0 e0       	ldi	r28, 0x00	; 0
    527e:	78 01       	movw	r14, r16
    5280:	c3 11       	cpse	r28, r3
    5282:	a6 cf       	rjmp	.-180    	; 0x51d0 <planner_recalculate+0x1ee>
    5284:	20 92 74 04 	sts	0x0474, r2	; 0x800474 <block_buffer_planned>
    5288:	df 91       	pop	r29
    528a:	cf 91       	pop	r28
    528c:	1f 91       	pop	r17
    528e:	0f 91       	pop	r16
    5290:	ff 90       	pop	r15
    5292:	ef 90       	pop	r14
    5294:	df 90       	pop	r13
    5296:	cf 90       	pop	r12
    5298:	bf 90       	pop	r11
    529a:	af 90       	pop	r10
    529c:	9f 90       	pop	r9
    529e:	8f 90       	pop	r8
    52a0:	7f 90       	pop	r7
    52a2:	6f 90       	pop	r6
    52a4:	5f 90       	pop	r5
    52a6:	4f 90       	pop	r4
    52a8:	3f 90       	pop	r3
    52aa:	2f 90       	pop	r2
    52ac:	08 95       	ret

000052ae <plan_reset_buffer>:
    52ae:	10 92 77 04 	sts	0x0477, r1	; 0x800477 <block_buffer_tail>
    52b2:	10 92 76 04 	sts	0x0476, r1	; 0x800476 <block_buffer_head>
    52b6:	81 e0       	ldi	r24, 0x01	; 1
    52b8:	80 93 75 04 	sts	0x0475, r24	; 0x800475 <next_buffer_head>
    52bc:	10 92 74 04 	sts	0x0474, r1	; 0x800474 <block_buffer_planned>
    52c0:	08 95       	ret

000052c2 <plan_reset>:
    52c2:	8c e1       	ldi	r24, 0x1C	; 28
    52c4:	e8 e5       	ldi	r30, 0x58	; 88
    52c6:	f4 e0       	ldi	r31, 0x04	; 4
    52c8:	df 01       	movw	r26, r30
    52ca:	1d 92       	st	X+, r1
    52cc:	8a 95       	dec	r24
    52ce:	e9 f7       	brne	.-6      	; 0x52ca <plan_reset+0x8>
    52d0:	ee cf       	rjmp	.-36     	; 0x52ae <plan_reset_buffer>
    52d2:	08 95       	ret

000052d4 <plan_discard_current_block>:
    52d4:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    52d8:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <block_buffer_head>
    52dc:	98 17       	cp	r25, r24
    52de:	69 f0       	breq	.+26     	; 0x52fa <plan_discard_current_block+0x26>
    52e0:	91 e0       	ldi	r25, 0x01	; 1
    52e2:	98 0f       	add	r25, r24
    52e4:	94 32       	cpi	r25, 0x24	; 36
    52e6:	09 f4       	brne	.+2      	; 0x52ea <plan_discard_current_block+0x16>
    52e8:	90 e0       	ldi	r25, 0x00	; 0
    52ea:	20 91 74 04 	lds	r18, 0x0474	; 0x800474 <block_buffer_planned>
    52ee:	82 13       	cpse	r24, r18
    52f0:	02 c0       	rjmp	.+4      	; 0x52f6 <plan_discard_current_block+0x22>
    52f2:	90 93 74 04 	sts	0x0474, r25	; 0x800474 <block_buffer_planned>
    52f6:	90 93 77 04 	sts	0x0477, r25	; 0x800477 <block_buffer_tail>
    52fa:	08 95       	ret

000052fc <plan_get_system_motion_block>:
    52fc:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <block_buffer_head>
    5300:	26 e3       	ldi	r18, 0x36	; 54
    5302:	82 9f       	mul	r24, r18
    5304:	c0 01       	movw	r24, r0
    5306:	11 24       	eor	r1, r1
    5308:	88 58       	subi	r24, 0x88	; 136
    530a:	9b 4f       	sbci	r25, 0xFB	; 251
    530c:	08 95       	ret

0000530e <plan_get_current_block>:
    530e:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    5312:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <block_buffer_head>
    5316:	98 17       	cp	r25, r24
    5318:	39 f0       	breq	.+14     	; 0x5328 <plan_get_current_block+0x1a>
    531a:	26 e3       	ldi	r18, 0x36	; 54
    531c:	82 9f       	mul	r24, r18
    531e:	c0 01       	movw	r24, r0
    5320:	11 24       	eor	r1, r1
    5322:	88 58       	subi	r24, 0x88	; 136
    5324:	9b 4f       	sbci	r25, 0xFB	; 251
    5326:	08 95       	ret
    5328:	80 e0       	ldi	r24, 0x00	; 0
    532a:	90 e0       	ldi	r25, 0x00	; 0
    532c:	08 95       	ret

0000532e <plan_get_exec_block_exit_speed_sqr>:
    532e:	e0 91 77 04 	lds	r30, 0x0477	; 0x800477 <block_buffer_tail>
    5332:	ef 5f       	subi	r30, 0xFF	; 255
    5334:	e4 32       	cpi	r30, 0x24	; 36
    5336:	09 f4       	brne	.+2      	; 0x533a <plan_get_exec_block_exit_speed_sqr+0xc>
    5338:	e0 e0       	ldi	r30, 0x00	; 0
    533a:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <block_buffer_head>
    533e:	8e 17       	cp	r24, r30
    5340:	59 f0       	breq	.+22     	; 0x5358 <plan_get_exec_block_exit_speed_sqr+0x2a>
    5342:	86 e3       	ldi	r24, 0x36	; 54
    5344:	e8 9f       	mul	r30, r24
    5346:	f0 01       	movw	r30, r0
    5348:	11 24       	eor	r1, r1
    534a:	e8 58       	subi	r30, 0x88	; 136
    534c:	fb 4f       	sbci	r31, 0xFB	; 251
    534e:	66 89       	ldd	r22, Z+22	; 0x16
    5350:	77 89       	ldd	r23, Z+23	; 0x17
    5352:	80 8d       	ldd	r24, Z+24	; 0x18
    5354:	91 8d       	ldd	r25, Z+25	; 0x19
    5356:	08 95       	ret
    5358:	60 e0       	ldi	r22, 0x00	; 0
    535a:	70 e0       	ldi	r23, 0x00	; 0
    535c:	cb 01       	movw	r24, r22
    535e:	08 95       	ret

00005360 <plan_check_full_buffer>:
    5360:	81 e0       	ldi	r24, 0x01	; 1
    5362:	20 91 77 04 	lds	r18, 0x0477	; 0x800477 <block_buffer_tail>
    5366:	90 91 75 04 	lds	r25, 0x0475	; 0x800475 <next_buffer_head>
    536a:	29 13       	cpse	r18, r25
    536c:	80 e0       	ldi	r24, 0x00	; 0
    536e:	08 95       	ret

00005370 <plan_compute_profile_nominal_speed>:
    5370:	af 92       	push	r10
    5372:	bf 92       	push	r11
    5374:	cf 92       	push	r12
    5376:	df 92       	push	r13
    5378:	ef 92       	push	r14
    537a:	ff 92       	push	r15
    537c:	0f 93       	push	r16
    537e:	1f 93       	push	r17
    5380:	cf 93       	push	r28
    5382:	df 93       	push	r29
    5384:	ec 01       	movw	r28, r24
    5386:	1e a5       	ldd	r17, Y+46	; 0x2e
    5388:	af a4       	ldd	r10, Y+47	; 0x2f
    538a:	e8 a8       	ldd	r14, Y+48	; 0x30
    538c:	09 a9       	ldd	r16, Y+49	; 0x31
    538e:	89 89       	ldd	r24, Y+17	; 0x11
    5390:	80 ff       	sbrs	r24, 0
    5392:	1a c0       	rjmp	.+52     	; 0x53c8 <plan_compute_profile_nominal_speed+0x58>
    5394:	60 91 26 0c 	lds	r22, 0x0C26	; 0x800c26 <sys+0x8>
    5398:	70 e0       	ldi	r23, 0x00	; 0
    539a:	80 e0       	ldi	r24, 0x00	; 0
    539c:	90 e0       	ldi	r25, 0x00	; 0
    539e:	0e 94 42 40 	call	0x8084	; 0x8084 <__floatsisf>
    53a2:	2a e0       	ldi	r18, 0x0A	; 10
    53a4:	37 ed       	ldi	r19, 0xD7	; 215
    53a6:	43 e2       	ldi	r20, 0x23	; 35
    53a8:	5c e3       	ldi	r21, 0x3C	; 60
    53aa:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    53ae:	9b 01       	movw	r18, r22
    53b0:	ac 01       	movw	r20, r24
    53b2:	61 2f       	mov	r22, r17
    53b4:	7a 2d       	mov	r23, r10
    53b6:	8e 2d       	mov	r24, r14
    53b8:	90 2f       	mov	r25, r16
    53ba:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    53be:	16 2f       	mov	r17, r22
    53c0:	a7 2e       	mov	r10, r23
    53c2:	e8 2e       	mov	r14, r24
    53c4:	09 2f       	mov	r16, r25
    53c6:	2f c0       	rjmp	.+94     	; 0x5426 <plan_compute_profile_nominal_speed+0xb6>
    53c8:	82 fd       	sbrc	r24, 2
    53ca:	19 c0       	rjmp	.+50     	; 0x53fe <plan_compute_profile_nominal_speed+0x8e>
    53cc:	60 91 25 0c 	lds	r22, 0x0C25	; 0x800c25 <sys+0x7>
    53d0:	70 e0       	ldi	r23, 0x00	; 0
    53d2:	80 e0       	ldi	r24, 0x00	; 0
    53d4:	90 e0       	ldi	r25, 0x00	; 0
    53d6:	0e 94 42 40 	call	0x8084	; 0x8084 <__floatsisf>
    53da:	2a e0       	ldi	r18, 0x0A	; 10
    53dc:	37 ed       	ldi	r19, 0xD7	; 215
    53de:	43 e2       	ldi	r20, 0x23	; 35
    53e0:	5c e3       	ldi	r21, 0x3C	; 60
    53e2:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    53e6:	9b 01       	movw	r18, r22
    53e8:	ac 01       	movw	r20, r24
    53ea:	61 2f       	mov	r22, r17
    53ec:	7a 2d       	mov	r23, r10
    53ee:	8e 2d       	mov	r24, r14
    53f0:	90 2f       	mov	r25, r16
    53f2:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    53f6:	16 2f       	mov	r17, r22
    53f8:	a7 2e       	mov	r10, r23
    53fa:	e8 2e       	mov	r14, r24
    53fc:	09 2f       	mov	r16, r25
    53fe:	ba a4       	ldd	r11, Y+42	; 0x2a
    5400:	cb a4       	ldd	r12, Y+43	; 0x2b
    5402:	dc a4       	ldd	r13, Y+44	; 0x2c
    5404:	fd a4       	ldd	r15, Y+45	; 0x2d
    5406:	2b 2d       	mov	r18, r11
    5408:	3c 2d       	mov	r19, r12
    540a:	4d 2d       	mov	r20, r13
    540c:	5f 2d       	mov	r21, r15
    540e:	61 2f       	mov	r22, r17
    5410:	7a 2d       	mov	r23, r10
    5412:	8e 2d       	mov	r24, r14
    5414:	90 2f       	mov	r25, r16
    5416:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    541a:	18 16       	cp	r1, r24
    541c:	24 f4       	brge	.+8      	; 0x5426 <plan_compute_profile_nominal_speed+0xb6>
    541e:	1b 2d       	mov	r17, r11
    5420:	ac 2c       	mov	r10, r12
    5422:	ed 2c       	mov	r14, r13
    5424:	0f 2d       	mov	r16, r15
    5426:	20 e0       	ldi	r18, 0x00	; 0
    5428:	30 e0       	ldi	r19, 0x00	; 0
    542a:	40 e8       	ldi	r20, 0x80	; 128
    542c:	5f e3       	ldi	r21, 0x3F	; 63
    542e:	61 2f       	mov	r22, r17
    5430:	7a 2d       	mov	r23, r10
    5432:	8e 2d       	mov	r24, r14
    5434:	90 2f       	mov	r25, r16
    5436:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    543a:	18 16       	cp	r1, r24
    543c:	1c f4       	brge	.+6      	; 0x5444 <plan_compute_profile_nominal_speed+0xd4>
    543e:	da 2d       	mov	r29, r10
    5440:	ce 2d       	mov	r28, r14
    5442:	04 c0       	rjmp	.+8      	; 0x544c <plan_compute_profile_nominal_speed+0xdc>
    5444:	10 e0       	ldi	r17, 0x00	; 0
    5446:	d0 e0       	ldi	r29, 0x00	; 0
    5448:	c0 e8       	ldi	r28, 0x80	; 128
    544a:	0f e3       	ldi	r16, 0x3F	; 63
    544c:	61 2f       	mov	r22, r17
    544e:	7d 2f       	mov	r23, r29
    5450:	8c 2f       	mov	r24, r28
    5452:	90 2f       	mov	r25, r16
    5454:	df 91       	pop	r29
    5456:	cf 91       	pop	r28
    5458:	1f 91       	pop	r17
    545a:	0f 91       	pop	r16
    545c:	ff 90       	pop	r15
    545e:	ef 90       	pop	r14
    5460:	df 90       	pop	r13
    5462:	cf 90       	pop	r12
    5464:	bf 90       	pop	r11
    5466:	af 90       	pop	r10
    5468:	08 95       	ret

0000546a <plan_update_velocity_profile_parameters>:
    546a:	5f 92       	push	r5
    546c:	6f 92       	push	r6
    546e:	7f 92       	push	r7
    5470:	8f 92       	push	r8
    5472:	9f 92       	push	r9
    5474:	af 92       	push	r10
    5476:	bf 92       	push	r11
    5478:	cf 92       	push	r12
    547a:	df 92       	push	r13
    547c:	ef 92       	push	r14
    547e:	ff 92       	push	r15
    5480:	0f 93       	push	r16
    5482:	1f 93       	push	r17
    5484:	cf 93       	push	r28
    5486:	df 93       	push	r29
    5488:	10 91 77 04 	lds	r17, 0x0477	; 0x800477 <block_buffer_tail>
    548c:	50 90 76 04 	lds	r5, 0x0476	; 0x800476 <block_buffer_head>
    5490:	0f 2e       	mov	r0, r31
    5492:	f9 e9       	ldi	r31, 0x99	; 153
    5494:	9f 2e       	mov	r9, r31
    5496:	f0 2d       	mov	r31, r0
    5498:	0f 2e       	mov	r0, r31
    549a:	f6 e7       	ldi	r31, 0x76	; 118
    549c:	8f 2e       	mov	r8, r31
    549e:	f0 2d       	mov	r31, r0
    54a0:	0f 2e       	mov	r0, r31
    54a2:	f6 e9       	ldi	r31, 0x96	; 150
    54a4:	7f 2e       	mov	r7, r31
    54a6:	f0 2d       	mov	r31, r0
    54a8:	0f 2e       	mov	r0, r31
    54aa:	fe e7       	ldi	r31, 0x7E	; 126
    54ac:	6f 2e       	mov	r6, r31
    54ae:	f0 2d       	mov	r31, r0
    54b0:	0f 2e       	mov	r0, r31
    54b2:	f6 e3       	ldi	r31, 0x36	; 54
    54b4:	cf 2e       	mov	r12, r31
    54b6:	f0 2d       	mov	r31, r0
    54b8:	73 c0       	rjmp	.+230    	; 0x55a0 <plan_update_velocity_profile_parameters+0x136>
    54ba:	c1 2f       	mov	r28, r17
    54bc:	d0 e0       	ldi	r29, 0x00	; 0
    54be:	cc 9e       	mul	r12, r28
    54c0:	c0 01       	movw	r24, r0
    54c2:	cd 9e       	mul	r12, r29
    54c4:	90 0d       	add	r25, r0
    54c6:	11 24       	eor	r1, r1
    54c8:	88 58       	subi	r24, 0x88	; 136
    54ca:	9b 4f       	sbci	r25, 0xFB	; 251
    54cc:	51 df       	rcall	.-350    	; 0x5370 <plan_compute_profile_nominal_speed>
    54ce:	06 2f       	mov	r16, r22
    54d0:	f7 2e       	mov	r15, r23
    54d2:	e8 2e       	mov	r14, r24
    54d4:	d9 2e       	mov	r13, r25
    54d6:	26 2f       	mov	r18, r22
    54d8:	37 2f       	mov	r19, r23
    54da:	48 2f       	mov	r20, r24
    54dc:	59 2f       	mov	r21, r25
    54de:	69 2d       	mov	r22, r9
    54e0:	78 2d       	mov	r23, r8
    54e2:	87 2d       	mov	r24, r7
    54e4:	96 2d       	mov	r25, r6
    54e6:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    54ea:	88 23       	and	r24, r24
    54ec:	cc f4       	brge	.+50     	; 0x5520 <plan_update_velocity_profile_parameters+0xb6>
    54ee:	cc 9e       	mul	r12, r28
    54f0:	c0 01       	movw	r24, r0
    54f2:	cd 9e       	mul	r12, r29
    54f4:	90 0d       	add	r25, r0
    54f6:	11 24       	eor	r1, r1
    54f8:	9c 01       	movw	r18, r24
    54fa:	28 58       	subi	r18, 0x88	; 136
    54fc:	3b 4f       	sbci	r19, 0xFB	; 251
    54fe:	59 01       	movw	r10, r18
    5500:	29 2d       	mov	r18, r9
    5502:	38 2d       	mov	r19, r8
    5504:	47 2d       	mov	r20, r7
    5506:	56 2d       	mov	r21, r6
    5508:	69 2d       	mov	r22, r9
    550a:	78 2d       	mov	r23, r8
    550c:	87 2d       	mov	r24, r7
    550e:	96 2d       	mov	r25, r6
    5510:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    5514:	f5 01       	movw	r30, r10
    5516:	62 8f       	std	Z+26, r22	; 0x1a
    5518:	73 8f       	std	Z+27, r23	; 0x1b
    551a:	84 8f       	std	Z+28, r24	; 0x1c
    551c:	95 8f       	std	Z+29, r25	; 0x1d
    551e:	18 c0       	rjmp	.+48     	; 0x5550 <plan_update_velocity_profile_parameters+0xe6>
    5520:	cc 9e       	mul	r12, r28
    5522:	c0 01       	movw	r24, r0
    5524:	cd 9e       	mul	r12, r29
    5526:	90 0d       	add	r25, r0
    5528:	11 24       	eor	r1, r1
    552a:	9c 01       	movw	r18, r24
    552c:	28 58       	subi	r18, 0x88	; 136
    552e:	3b 4f       	sbci	r19, 0xFB	; 251
    5530:	59 01       	movw	r10, r18
    5532:	20 2f       	mov	r18, r16
    5534:	3f 2d       	mov	r19, r15
    5536:	4e 2d       	mov	r20, r14
    5538:	5d 2d       	mov	r21, r13
    553a:	60 2f       	mov	r22, r16
    553c:	7f 2d       	mov	r23, r15
    553e:	8e 2d       	mov	r24, r14
    5540:	9d 2d       	mov	r25, r13
    5542:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    5546:	f5 01       	movw	r30, r10
    5548:	62 8f       	std	Z+26, r22	; 0x1a
    554a:	73 8f       	std	Z+27, r23	; 0x1b
    554c:	84 8f       	std	Z+28, r24	; 0x1c
    554e:	95 8f       	std	Z+29, r25	; 0x1d
    5550:	cc 9e       	mul	r12, r28
    5552:	f0 01       	movw	r30, r0
    5554:	cd 9e       	mul	r12, r29
    5556:	f0 0d       	add	r31, r0
    5558:	11 24       	eor	r1, r1
    555a:	e8 58       	subi	r30, 0x88	; 136
    555c:	fb 4f       	sbci	r31, 0xFB	; 251
    555e:	86 a0       	ldd	r8, Z+38	; 0x26
    5560:	97 a0       	ldd	r9, Z+39	; 0x27
    5562:	a0 a4       	ldd	r10, Z+40	; 0x28
    5564:	b1 a4       	ldd	r11, Z+41	; 0x29
    5566:	a5 01       	movw	r20, r10
    5568:	94 01       	movw	r18, r8
    556a:	62 8d       	ldd	r22, Z+26	; 0x1a
    556c:	73 8d       	ldd	r23, Z+27	; 0x1b
    556e:	84 8d       	ldd	r24, Z+28	; 0x1c
    5570:	95 8d       	ldd	r25, Z+29	; 0x1d
    5572:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    5576:	18 16       	cp	r1, r24
    5578:	5c f4       	brge	.+22     	; 0x5590 <plan_update_velocity_profile_parameters+0x126>
    557a:	cc 9e       	mul	r12, r28
    557c:	f0 01       	movw	r30, r0
    557e:	cd 9e       	mul	r12, r29
    5580:	f0 0d       	add	r31, r0
    5582:	11 24       	eor	r1, r1
    5584:	e8 58       	subi	r30, 0x88	; 136
    5586:	fb 4f       	sbci	r31, 0xFB	; 251
    5588:	82 8e       	std	Z+26, r8	; 0x1a
    558a:	93 8e       	std	Z+27, r9	; 0x1b
    558c:	a4 8e       	std	Z+28, r10	; 0x1c
    558e:	b5 8e       	std	Z+29, r11	; 0x1d
    5590:	1f 5f       	subi	r17, 0xFF	; 255
    5592:	14 32       	cpi	r17, 0x24	; 36
    5594:	09 f4       	brne	.+2      	; 0x5598 <plan_update_velocity_profile_parameters+0x12e>
    5596:	10 e0       	ldi	r17, 0x00	; 0
    5598:	90 2e       	mov	r9, r16
    559a:	8f 2c       	mov	r8, r15
    559c:	7e 2c       	mov	r7, r14
    559e:	6d 2c       	mov	r6, r13
    55a0:	15 11       	cpse	r17, r5
    55a2:	8b cf       	rjmp	.-234    	; 0x54ba <plan_update_velocity_profile_parameters+0x50>
    55a4:	89 2d       	mov	r24, r9
    55a6:	98 2d       	mov	r25, r8
    55a8:	a7 2d       	mov	r26, r7
    55aa:	b6 2d       	mov	r27, r6
    55ac:	80 93 70 04 	sts	0x0470, r24	; 0x800470 <pl+0x18>
    55b0:	90 93 71 04 	sts	0x0471, r25	; 0x800471 <pl+0x19>
    55b4:	a0 93 72 04 	sts	0x0472, r26	; 0x800472 <pl+0x1a>
    55b8:	b0 93 73 04 	sts	0x0473, r27	; 0x800473 <pl+0x1b>
    55bc:	df 91       	pop	r29
    55be:	cf 91       	pop	r28
    55c0:	1f 91       	pop	r17
    55c2:	0f 91       	pop	r16
    55c4:	ff 90       	pop	r15
    55c6:	ef 90       	pop	r14
    55c8:	df 90       	pop	r13
    55ca:	cf 90       	pop	r12
    55cc:	bf 90       	pop	r11
    55ce:	af 90       	pop	r10
    55d0:	9f 90       	pop	r9
    55d2:	8f 90       	pop	r8
    55d4:	7f 90       	pop	r7
    55d6:	6f 90       	pop	r6
    55d8:	5f 90       	pop	r5
    55da:	08 95       	ret

000055dc <plan_buffer_line>:
    55dc:	2f 92       	push	r2
    55de:	3f 92       	push	r3
    55e0:	4f 92       	push	r4
    55e2:	5f 92       	push	r5
    55e4:	6f 92       	push	r6
    55e6:	7f 92       	push	r7
    55e8:	8f 92       	push	r8
    55ea:	9f 92       	push	r9
    55ec:	af 92       	push	r10
    55ee:	bf 92       	push	r11
    55f0:	cf 92       	push	r12
    55f2:	df 92       	push	r13
    55f4:	ef 92       	push	r14
    55f6:	ff 92       	push	r15
    55f8:	0f 93       	push	r16
    55fa:	1f 93       	push	r17
    55fc:	cf 93       	push	r28
    55fe:	df 93       	push	r29
    5600:	cd b7       	in	r28, 0x3d	; 61
    5602:	de b7       	in	r29, 0x3e	; 62
    5604:	c6 54       	subi	r28, 0x46	; 70
    5606:	d1 09       	sbc	r29, r1
    5608:	0f b6       	in	r0, 0x3f	; 63
    560a:	f8 94       	cli
    560c:	de bf       	out	0x3e, r29	; 62
    560e:	0f be       	out	0x3f, r0	; 63
    5610:	cd bf       	out	0x3d, r28	; 61
    5612:	23 96       	adiw	r28, 0x03	; 3
    5614:	7f af       	std	Y+63, r23	; 0x3f
    5616:	6e af       	std	Y+62, r22	; 0x3e
    5618:	23 97       	sbiw	r28, 0x03	; 3
    561a:	20 90 76 04 	lds	r2, 0x0476	; 0x800476 <block_buffer_head>
    561e:	a2 2c       	mov	r10, r2
    5620:	b1 2c       	mov	r11, r1
    5622:	26 e3       	ldi	r18, 0x36	; 54
    5624:	2a 9d       	mul	r18, r10
    5626:	a0 01       	movw	r20, r0
    5628:	2b 9d       	mul	r18, r11
    562a:	50 0d       	add	r21, r0
    562c:	11 24       	eor	r1, r1
    562e:	ba 01       	movw	r22, r20
    5630:	68 58       	subi	r22, 0x88	; 136
    5632:	7b 4f       	sbci	r23, 0xFB	; 251
    5634:	21 96       	adiw	r28, 0x01	; 1
    5636:	7f af       	std	Y+63, r23	; 0x3f
    5638:	6e af       	std	Y+62, r22	; 0x3e
    563a:	21 97       	sbiw	r28, 0x01	; 1
    563c:	fb 01       	movw	r30, r22
    563e:	11 92       	st	Z+, r1
    5640:	2a 95       	dec	r18
    5642:	e9 f7       	brne	.-6      	; 0x563e <plan_buffer_line+0x62>
    5644:	23 96       	adiw	r28, 0x03	; 3
    5646:	ee ad       	ldd	r30, Y+62	; 0x3e
    5648:	ff ad       	ldd	r31, Y+63	; 0x3f
    564a:	23 97       	sbiw	r28, 0x03	; 3
    564c:	24 85       	ldd	r18, Z+12	; 0x0c
    564e:	fb 01       	movw	r30, r22
    5650:	21 8b       	std	Z+17, r18	; 0x11
    5652:	23 96       	adiw	r28, 0x03	; 3
    5654:	ee ad       	ldd	r30, Y+62	; 0x3e
    5656:	ff ad       	ldd	r31, Y+63	; 0x3f
    5658:	23 97       	sbiw	r28, 0x03	; 3
    565a:	44 81       	ldd	r20, Z+4	; 0x04
    565c:	55 81       	ldd	r21, Z+5	; 0x05
    565e:	66 81       	ldd	r22, Z+6	; 0x06
    5660:	77 81       	ldd	r23, Z+7	; 0x07
    5662:	21 96       	adiw	r28, 0x01	; 1
    5664:	ee ad       	ldd	r30, Y+62	; 0x3e
    5666:	ff ad       	ldd	r31, Y+63	; 0x3f
    5668:	21 97       	sbiw	r28, 0x01	; 1
    566a:	42 ab       	std	Z+50, r20	; 0x32
    566c:	53 ab       	std	Z+51, r21	; 0x33
    566e:	64 ab       	std	Z+52, r22	; 0x34
    5670:	75 ab       	std	Z+53, r23	; 0x35
    5672:	23 96       	adiw	r28, 0x03	; 3
    5674:	ee ad       	ldd	r30, Y+62	; 0x3e
    5676:	ff ad       	ldd	r31, Y+63	; 0x3f
    5678:	23 97       	sbiw	r28, 0x03	; 3
    567a:	40 85       	ldd	r20, Z+8	; 0x08
    567c:	51 85       	ldd	r21, Z+9	; 0x09
    567e:	62 85       	ldd	r22, Z+10	; 0x0a
    5680:	73 85       	ldd	r23, Z+11	; 0x0b
    5682:	21 96       	adiw	r28, 0x01	; 1
    5684:	ee ad       	ldd	r30, Y+62	; 0x3e
    5686:	ff ad       	ldd	r31, Y+63	; 0x3f
    5688:	21 97       	sbiw	r28, 0x01	; 1
    568a:	42 8b       	std	Z+18, r20	; 0x12
    568c:	53 8b       	std	Z+19, r21	; 0x13
    568e:	64 8b       	std	Z+20, r22	; 0x14
    5690:	75 8b       	std	Z+21, r23	; 0x15
    5692:	21 ff       	sbrs	r18, 1
    5694:	0a c0       	rjmp	.+20     	; 0x56aa <plan_buffer_line+0xce>
    5696:	2c e0       	ldi	r18, 0x0C	; 12
    5698:	e3 e4       	ldi	r30, 0x43	; 67
    569a:	fc e0       	ldi	r31, 0x0C	; 12
    569c:	de 01       	movw	r26, r28
    569e:	1d 96       	adiw	r26, 0x0d	; 13
    56a0:	01 90       	ld	r0, Z+
    56a2:	0d 92       	st	X+, r0
    56a4:	2a 95       	dec	r18
    56a6:	e1 f7       	brne	.-8      	; 0x56a0 <plan_buffer_line+0xc4>
    56a8:	65 c2       	rjmp	.+1226   	; 0x5b74 <plan_buffer_line+0x598>
    56aa:	2c e0       	ldi	r18, 0x0C	; 12
    56ac:	e8 e5       	ldi	r30, 0x58	; 88
    56ae:	f4 e0       	ldi	r31, 0x04	; 4
    56b0:	de 01       	movw	r26, r28
    56b2:	1d 96       	adiw	r26, 0x0d	; 13
    56b4:	01 90       	ld	r0, Z+
    56b6:	0d 92       	st	X+, r0
    56b8:	2a 95       	dec	r18
    56ba:	e1 f7       	brne	.-8      	; 0x56b4 <plan_buffer_line+0xd8>
    56bc:	5b c2       	rjmp	.+1206   	; 0x5b74 <plan_buffer_line+0x598>
    56be:	e9 ad       	ldd	r30, Y+57	; 0x39
    56c0:	fa ad       	ldd	r31, Y+58	; 0x3a
    56c2:	61 91       	ld	r22, Z+
    56c4:	71 91       	ld	r23, Z+
    56c6:	81 91       	ld	r24, Z+
    56c8:	91 91       	ld	r25, Z+
    56ca:	fa af       	std	Y+58, r31	; 0x3a
    56cc:	e9 af       	std	Y+57, r30	; 0x39
    56ce:	eb ad       	ldd	r30, Y+59	; 0x3b
    56d0:	fc ad       	ldd	r31, Y+60	; 0x3c
    56d2:	21 91       	ld	r18, Z+
    56d4:	31 91       	ld	r19, Z+
    56d6:	41 91       	ld	r20, Z+
    56d8:	51 91       	ld	r21, Z+
    56da:	fc af       	std	Y+60, r31	; 0x3c
    56dc:	eb af       	std	Y+59, r30	; 0x3b
    56de:	2d ab       	std	Y+53, r18	; 0x35
    56e0:	3e ab       	std	Y+54, r19	; 0x36
    56e2:	4f ab       	std	Y+55, r20	; 0x37
    56e4:	58 af       	std	Y+56, r21	; 0x38
    56e6:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    56ea:	0e 94 ae 41 	call	0x835c	; 0x835c <lround>
    56ee:	f4 01       	movw	r30, r8
    56f0:	61 93       	st	Z+, r22
    56f2:	71 93       	st	Z+, r23
    56f4:	81 93       	st	Z+, r24
    56f6:	91 93       	st	Z+, r25
    56f8:	4f 01       	movw	r8, r30
    56fa:	f6 01       	movw	r30, r12
    56fc:	01 91       	ld	r16, Z+
    56fe:	11 91       	ld	r17, Z+
    5700:	21 91       	ld	r18, Z+
    5702:	31 91       	ld	r19, Z+
    5704:	6f 01       	movw	r12, r30
    5706:	60 1b       	sub	r22, r16
    5708:	71 0b       	sbc	r23, r17
    570a:	82 0b       	sbc	r24, r18
    570c:	93 0b       	sbc	r25, r19
    570e:	8b 01       	movw	r16, r22
    5710:	9c 01       	movw	r18, r24
    5712:	3a f4       	brpl	.+14     	; 0x5722 <plan_buffer_line+0x146>
    5714:	00 27       	eor	r16, r16
    5716:	11 27       	eor	r17, r17
    5718:	98 01       	movw	r18, r16
    571a:	06 1b       	sub	r16, r22
    571c:	17 0b       	sbc	r17, r23
    571e:	28 0b       	sbc	r18, r24
    5720:	39 0b       	sbc	r19, r25
    5722:	f1 01       	movw	r30, r2
    5724:	01 93       	st	Z+, r16
    5726:	11 93       	st	Z+, r17
    5728:	21 93       	st	Z+, r18
    572a:	31 93       	st	Z+, r19
    572c:	1f 01       	movw	r2, r30
    572e:	f7 01       	movw	r30, r14
    5730:	40 80       	ld	r4, Z
    5732:	51 80       	ldd	r5, Z+1	; 0x01
    5734:	62 80       	ldd	r6, Z+2	; 0x02
    5736:	73 80       	ldd	r7, Z+3	; 0x03
    5738:	40 16       	cp	r4, r16
    573a:	51 06       	cpc	r5, r17
    573c:	62 06       	cpc	r6, r18
    573e:	73 06       	cpc	r7, r19
    5740:	10 f4       	brcc	.+4      	; 0x5746 <plan_buffer_line+0x16a>
    5742:	28 01       	movw	r4, r16
    5744:	39 01       	movw	r6, r18
    5746:	f7 01       	movw	r30, r14
    5748:	40 82       	st	Z, r4
    574a:	51 82       	std	Z+1, r5	; 0x01
    574c:	62 82       	std	Z+2, r6	; 0x02
    574e:	73 82       	std	Z+3, r7	; 0x03
    5750:	0e 94 42 40 	call	0x8084	; 0x8084 <__floatsisf>
    5754:	2d a9       	ldd	r18, Y+53	; 0x35
    5756:	3e a9       	ldd	r19, Y+54	; 0x36
    5758:	4f a9       	ldd	r20, Y+55	; 0x37
    575a:	58 ad       	ldd	r21, Y+56	; 0x38
    575c:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <__divsf3>
    5760:	ed ad       	ldd	r30, Y+61	; 0x3d
    5762:	fe ad       	ldd	r31, Y+62	; 0x3e
    5764:	61 93       	st	Z+, r22
    5766:	71 93       	st	Z+, r23
    5768:	81 93       	st	Z+, r24
    576a:	91 93       	st	Z+, r25
    576c:	fe af       	std	Y+62, r31	; 0x3e
    576e:	ed af       	std	Y+61, r30	; 0x3d
    5770:	20 e0       	ldi	r18, 0x00	; 0
    5772:	30 e0       	ldi	r19, 0x00	; 0
    5774:	a9 01       	movw	r20, r18
    5776:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    577a:	88 23       	and	r24, r24
    577c:	4c f4       	brge	.+18     	; 0x5790 <plan_buffer_line+0x1b4>
    577e:	89 a9       	ldd	r24, Y+49	; 0x31
    5780:	1c dc       	rcall	.-1992   	; 0x4fba <get_direction_pin_mask>
    5782:	27 96       	adiw	r28, 0x07	; 7
    5784:	ee ad       	ldd	r30, Y+62	; 0x3e
    5786:	ff ad       	ldd	r31, Y+63	; 0x3f
    5788:	27 97       	sbiw	r28, 0x07	; 7
    578a:	90 81       	ld	r25, Z
    578c:	89 2b       	or	r24, r25
    578e:	80 83       	st	Z, r24
    5790:	f9 a9       	ldd	r31, Y+49	; 0x31
    5792:	ff 5f       	subi	r31, 0xFF	; 255
    5794:	f9 ab       	std	Y+49, r31	; 0x31
    5796:	f3 30       	cpi	r31, 0x03	; 3
    5798:	09 f0       	breq	.+2      	; 0x579c <plan_buffer_line+0x1c0>
    579a:	91 cf       	rjmp	.-222    	; 0x56be <plan_buffer_line+0xe2>
    579c:	86 e3       	ldi	r24, 0x36	; 54
    579e:	8a 9d       	mul	r24, r10
    57a0:	f0 01       	movw	r30, r0
    57a2:	8b 9d       	mul	r24, r11
    57a4:	f0 0d       	add	r31, r0
    57a6:	11 24       	eor	r1, r1
    57a8:	e8 58       	subi	r30, 0x88	; 136
    57aa:	fb 4f       	sbci	r31, 0xFB	; 251
    57ac:	84 85       	ldd	r24, Z+12	; 0x0c
    57ae:	95 85       	ldd	r25, Z+13	; 0x0d
    57b0:	a6 85       	ldd	r26, Z+14	; 0x0e
    57b2:	b7 85       	ldd	r27, Z+15	; 0x0f
    57b4:	89 2b       	or	r24, r25
    57b6:	8a 2b       	or	r24, r26
    57b8:	8b 2b       	or	r24, r27
    57ba:	09 f4       	brne	.+2      	; 0x57be <plan_buffer_line+0x1e2>
    57bc:	d7 c1       	rjmp	.+942    	; 0x5b6c <plan_buffer_line+0x590>
    57be:	ce 01       	movw	r24, r28
    57c0:	49 96       	adiw	r24, 0x19	; 25
    57c2:	8e d3       	rcall	.+1820   	; 0x5ee0 <convert_delta_vector_to_unit_vector>
    57c4:	26 e3       	ldi	r18, 0x36	; 54
    57c6:	2a 9d       	mul	r18, r10
    57c8:	80 01       	movw	r16, r0
    57ca:	2b 9d       	mul	r18, r11
    57cc:	10 0d       	add	r17, r0
    57ce:	11 24       	eor	r1, r1
    57d0:	08 58       	subi	r16, 0x88	; 136
    57d2:	1b 4f       	sbci	r17, 0xFB	; 251
    57d4:	f8 01       	movw	r30, r16
    57d6:	62 a3       	std	Z+34, r22	; 0x22
    57d8:	73 a3       	std	Z+35, r23	; 0x23
    57da:	84 a3       	std	Z+36, r24	; 0x24
    57dc:	95 a3       	std	Z+37, r25	; 0x25
    57de:	be 01       	movw	r22, r28
    57e0:	67 5e       	subi	r22, 0xE7	; 231
    57e2:	7f 4f       	sbci	r23, 0xFF	; 255
    57e4:	88 ee       	ldi	r24, 0xE8	; 232
    57e6:	9e e0       	ldi	r25, 0x0E	; 14
    57e8:	e2 d3       	rcall	.+1988   	; 0x5fae <limit_value_by_axis_maximum>
    57ea:	f8 01       	movw	r30, r16
    57ec:	66 8f       	std	Z+30, r22	; 0x1e
    57ee:	77 8f       	std	Z+31, r23	; 0x1f
    57f0:	80 a3       	std	Z+32, r24	; 0x20
    57f2:	91 a3       	std	Z+33, r25	; 0x21
    57f4:	be 01       	movw	r22, r28
    57f6:	67 5e       	subi	r22, 0xE7	; 231
    57f8:	7f 4f       	sbci	r23, 0xFF	; 255
    57fa:	8c ed       	ldi	r24, 0xDC	; 220
    57fc:	9e e0       	ldi	r25, 0x0E	; 14
    57fe:	d7 d3       	rcall	.+1966   	; 0x5fae <limit_value_by_axis_maximum>
    5800:	f8 01       	movw	r30, r16
    5802:	62 a7       	std	Z+42, r22	; 0x2a
    5804:	73 a7       	std	Z+43, r23	; 0x2b
    5806:	84 a7       	std	Z+44, r24	; 0x2c
    5808:	95 a7       	std	Z+45, r25	; 0x2d
    580a:	11 89       	ldd	r17, Z+17	; 0x11
    580c:	10 ff       	sbrs	r17, 0
    580e:	0d c0       	rjmp	.+26     	; 0x582a <plan_buffer_line+0x24e>
    5810:	26 e3       	ldi	r18, 0x36	; 54
    5812:	2a 9d       	mul	r18, r10
    5814:	f0 01       	movw	r30, r0
    5816:	2b 9d       	mul	r18, r11
    5818:	f0 0d       	add	r31, r0
    581a:	11 24       	eor	r1, r1
    581c:	e8 58       	subi	r30, 0x88	; 136
    581e:	fb 4f       	sbci	r31, 0xFB	; 251
    5820:	66 a7       	std	Z+46, r22	; 0x2e
    5822:	77 a7       	std	Z+47, r23	; 0x2f
    5824:	80 ab       	std	Z+48, r24	; 0x30
    5826:	91 ab       	std	Z+49, r25	; 0x31
    5828:	22 c0       	rjmp	.+68     	; 0x586e <plan_buffer_line+0x292>
    582a:	23 96       	adiw	r28, 0x03	; 3
    582c:	ee ad       	ldd	r30, Y+62	; 0x3e
    582e:	ff ad       	ldd	r31, Y+63	; 0x3f
    5830:	23 97       	sbiw	r28, 0x03	; 3
    5832:	20 81       	ld	r18, Z
    5834:	31 81       	ldd	r19, Z+1	; 0x01
    5836:	42 81       	ldd	r20, Z+2	; 0x02
    5838:	53 81       	ldd	r21, Z+3	; 0x03
    583a:	86 e3       	ldi	r24, 0x36	; 54
    583c:	8a 9d       	mul	r24, r10
    583e:	f0 01       	movw	r30, r0
    5840:	8b 9d       	mul	r24, r11
    5842:	f0 0d       	add	r31, r0
    5844:	11 24       	eor	r1, r1
    5846:	e8 58       	subi	r30, 0x88	; 136
    5848:	fb 4f       	sbci	r31, 0xFB	; 251
    584a:	26 a7       	std	Z+46, r18	; 0x2e
    584c:	37 a7       	std	Z+47, r19	; 0x2f
    584e:	40 ab       	std	Z+48, r20	; 0x30
    5850:	51 ab       	std	Z+49, r21	; 0x31
    5852:	13 ff       	sbrs	r17, 3
    5854:	0c c0       	rjmp	.+24     	; 0x586e <plan_buffer_line+0x292>
    5856:	7f 01       	movw	r14, r30
    5858:	62 a1       	ldd	r22, Z+34	; 0x22
    585a:	73 a1       	ldd	r23, Z+35	; 0x23
    585c:	84 a1       	ldd	r24, Z+36	; 0x24
    585e:	95 a1       	ldd	r25, Z+37	; 0x25
    5860:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    5864:	f7 01       	movw	r30, r14
    5866:	66 a7       	std	Z+46, r22	; 0x2e
    5868:	77 a7       	std	Z+47, r23	; 0x2f
    586a:	80 ab       	std	Z+48, r24	; 0x30
    586c:	91 ab       	std	Z+49, r25	; 0x31
    586e:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <block_buffer_head>
    5872:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    5876:	98 17       	cp	r25, r24
    5878:	11 f0       	breq	.+4      	; 0x587e <plan_buffer_line+0x2a2>
    587a:	11 ff       	sbrs	r17, 1
    587c:	11 c0       	rjmp	.+34     	; 0x58a0 <plan_buffer_line+0x2c4>
    587e:	86 e3       	ldi	r24, 0x36	; 54
    5880:	8a 9d       	mul	r24, r10
    5882:	f0 01       	movw	r30, r0
    5884:	8b 9d       	mul	r24, r11
    5886:	f0 0d       	add	r31, r0
    5888:	11 24       	eor	r1, r1
    588a:	e8 58       	subi	r30, 0x88	; 136
    588c:	fb 4f       	sbci	r31, 0xFB	; 251
    588e:	16 8a       	std	Z+22, r1	; 0x16
    5890:	17 8a       	std	Z+23, r1	; 0x17
    5892:	10 8e       	std	Z+24, r1	; 0x18
    5894:	11 8e       	std	Z+25, r1	; 0x19
    5896:	16 a2       	std	Z+38, r1	; 0x26
    5898:	17 a2       	std	Z+39, r1	; 0x27
    589a:	10 a6       	std	Z+40, r1	; 0x28
    589c:	11 a6       	std	Z+41, r1	; 0x29
    589e:	d6 c0       	rjmp	.+428    	; 0x5a4c <plan_buffer_line+0x470>
    58a0:	04 e6       	ldi	r16, 0x64	; 100
    58a2:	14 e0       	ldi	r17, 0x04	; 4
    58a4:	1e 01       	movw	r2, r28
    58a6:	f5 e2       	ldi	r31, 0x25	; 37
    58a8:	2f 0e       	add	r2, r31
    58aa:	31 1c       	adc	r3, r1
    58ac:	41 01       	movw	r8, r2
    58ae:	19 aa       	std	Y+49, r1	; 0x31
    58b0:	1a aa       	std	Y+50, r1	; 0x32
    58b2:	1b aa       	std	Y+51, r1	; 0x33
    58b4:	1c aa       	std	Y+52, r1	; 0x34
    58b6:	f8 01       	movw	r30, r16
    58b8:	c1 90       	ld	r12, Z+
    58ba:	d1 90       	ld	r13, Z+
    58bc:	e1 90       	ld	r14, Z+
    58be:	f1 90       	ld	r15, Z+
    58c0:	8f 01       	movw	r16, r30
    58c2:	25 96       	adiw	r28, 0x05	; 5
    58c4:	ee ad       	ldd	r30, Y+62	; 0x3e
    58c6:	ff ad       	ldd	r31, Y+63	; 0x3f
    58c8:	25 97       	sbiw	r28, 0x05	; 5
    58ca:	41 90       	ld	r4, Z+
    58cc:	51 90       	ld	r5, Z+
    58ce:	61 90       	ld	r6, Z+
    58d0:	71 90       	ld	r7, Z+
    58d2:	25 96       	adiw	r28, 0x05	; 5
    58d4:	ff af       	std	Y+63, r31	; 0x3f
    58d6:	ee af       	std	Y+62, r30	; 0x3e
    58d8:	25 97       	sbiw	r28, 0x05	; 5
    58da:	a3 01       	movw	r20, r6
    58dc:	92 01       	movw	r18, r4
    58de:	c7 01       	movw	r24, r14
    58e0:	b6 01       	movw	r22, r12
    58e2:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    58e6:	9b 01       	movw	r18, r22
    58e8:	ac 01       	movw	r20, r24
    58ea:	69 a9       	ldd	r22, Y+49	; 0x31
    58ec:	7a a9       	ldd	r23, Y+50	; 0x32
    58ee:	8b a9       	ldd	r24, Y+51	; 0x33
    58f0:	9c a9       	ldd	r25, Y+52	; 0x34
    58f2:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    58f6:	69 ab       	std	Y+49, r22	; 0x31
    58f8:	7a ab       	std	Y+50, r23	; 0x32
    58fa:	8b ab       	std	Y+51, r24	; 0x33
    58fc:	9c ab       	std	Y+52, r25	; 0x34
    58fe:	a7 01       	movw	r20, r14
    5900:	96 01       	movw	r18, r12
    5902:	c3 01       	movw	r24, r6
    5904:	b2 01       	movw	r22, r4
    5906:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    590a:	f1 01       	movw	r30, r2
    590c:	61 93       	st	Z+, r22
    590e:	71 93       	st	Z+, r23
    5910:	81 93       	st	Z+, r24
    5912:	91 93       	st	Z+, r25
    5914:	1f 01       	movw	r2, r30
    5916:	25 96       	adiw	r28, 0x05	; 5
    5918:	2e ad       	ldd	r18, Y+62	; 0x3e
    591a:	3f ad       	ldd	r19, Y+63	; 0x3f
    591c:	25 97       	sbiw	r28, 0x05	; 5
    591e:	28 15       	cp	r18, r8
    5920:	39 05       	cpc	r19, r9
    5922:	49 f6       	brne	.-110    	; 0x58b6 <plan_buffer_line+0x2da>
    5924:	2f ee       	ldi	r18, 0xEF	; 239
    5926:	3f ef       	ldi	r19, 0xFF	; 255
    5928:	4f e7       	ldi	r20, 0x7F	; 127
    592a:	5f e3       	ldi	r21, 0x3F	; 63
    592c:	69 a9       	ldd	r22, Y+49	; 0x31
    592e:	7a a9       	ldd	r23, Y+50	; 0x32
    5930:	8b a9       	ldd	r24, Y+51	; 0x33
    5932:	9c a9       	ldd	r25, Y+52	; 0x34
    5934:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    5938:	18 16       	cp	r1, r24
    593a:	6c f4       	brge	.+26     	; 0x5956 <plan_buffer_line+0x37a>
    593c:	86 e3       	ldi	r24, 0x36	; 54
    593e:	8a 9d       	mul	r24, r10
    5940:	f0 01       	movw	r30, r0
    5942:	8b 9d       	mul	r24, r11
    5944:	f0 0d       	add	r31, r0
    5946:	11 24       	eor	r1, r1
    5948:	e8 58       	subi	r30, 0x88	; 136
    594a:	fb 4f       	sbci	r31, 0xFB	; 251
    594c:	16 a2       	std	Z+38, r1	; 0x26
    594e:	17 a2       	std	Z+39, r1	; 0x27
    5950:	10 a6       	std	Z+40, r1	; 0x28
    5952:	11 a6       	std	Z+41, r1	; 0x29
    5954:	7b c0       	rjmp	.+246    	; 0x5a4c <plan_buffer_line+0x470>
    5956:	2f ee       	ldi	r18, 0xEF	; 239
    5958:	3f ef       	ldi	r19, 0xFF	; 255
    595a:	4f e7       	ldi	r20, 0x7F	; 127
    595c:	5f eb       	ldi	r21, 0xBF	; 191
    595e:	69 a9       	ldd	r22, Y+49	; 0x31
    5960:	7a a9       	ldd	r23, Y+50	; 0x32
    5962:	8b a9       	ldd	r24, Y+51	; 0x33
    5964:	9c a9       	ldd	r25, Y+52	; 0x34
    5966:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    596a:	88 23       	and	r24, r24
    596c:	8c f4       	brge	.+34     	; 0x5990 <plan_buffer_line+0x3b4>
    596e:	86 e3       	ldi	r24, 0x36	; 54
    5970:	8a 9d       	mul	r24, r10
    5972:	f0 01       	movw	r30, r0
    5974:	8b 9d       	mul	r24, r11
    5976:	f0 0d       	add	r31, r0
    5978:	11 24       	eor	r1, r1
    597a:	e8 58       	subi	r30, 0x88	; 136
    597c:	fb 4f       	sbci	r31, 0xFB	; 251
    597e:	89 e9       	ldi	r24, 0x99	; 153
    5980:	96 e7       	ldi	r25, 0x76	; 118
    5982:	a6 e9       	ldi	r26, 0x96	; 150
    5984:	be e7       	ldi	r27, 0x7E	; 126
    5986:	86 a3       	std	Z+38, r24	; 0x26
    5988:	97 a3       	std	Z+39, r25	; 0x27
    598a:	a0 a7       	std	Z+40, r26	; 0x28
    598c:	b1 a7       	std	Z+41, r27	; 0x29
    598e:	5e c0       	rjmp	.+188    	; 0x5a4c <plan_buffer_line+0x470>
    5990:	ce 01       	movw	r24, r28
    5992:	85 96       	adiw	r24, 0x25	; 37
    5994:	a5 d2       	rcall	.+1354   	; 0x5ee0 <convert_delta_vector_to_unit_vector>
    5996:	be 01       	movw	r22, r28
    5998:	6b 5d       	subi	r22, 0xDB	; 219
    599a:	7f 4f       	sbci	r23, 0xFF	; 255
    599c:	88 ee       	ldi	r24, 0xE8	; 232
    599e:	9e e0       	ldi	r25, 0x0E	; 14
    59a0:	06 d3       	rcall	.+1548   	; 0x5fae <limit_value_by_axis_maximum>
    59a2:	6b 01       	movw	r12, r22
    59a4:	7c 01       	movw	r14, r24
    59a6:	29 a9       	ldd	r18, Y+49	; 0x31
    59a8:	3a a9       	ldd	r19, Y+50	; 0x32
    59aa:	4b a9       	ldd	r20, Y+51	; 0x33
    59ac:	5c a9       	ldd	r21, Y+52	; 0x34
    59ae:	60 e0       	ldi	r22, 0x00	; 0
    59b0:	70 e0       	ldi	r23, 0x00	; 0
    59b2:	80 e8       	ldi	r24, 0x80	; 128
    59b4:	9f e3       	ldi	r25, 0x3F	; 63
    59b6:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    59ba:	20 e0       	ldi	r18, 0x00	; 0
    59bc:	30 e0       	ldi	r19, 0x00	; 0
    59be:	40 e0       	ldi	r20, 0x00	; 0
    59c0:	5f e3       	ldi	r21, 0x3F	; 63
    59c2:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    59c6:	0e 94 6b 42 	call	0x84d6	; 0x84d6 <sqrt>
    59ca:	2b 01       	movw	r4, r22
    59cc:	3c 01       	movw	r6, r24
    59ce:	20 91 05 0f 	lds	r18, 0x0F05	; 0x800f05 <settings+0x35>
    59d2:	30 91 06 0f 	lds	r19, 0x0F06	; 0x800f06 <settings+0x36>
    59d6:	40 91 07 0f 	lds	r20, 0x0F07	; 0x800f07 <settings+0x37>
    59da:	50 91 08 0f 	lds	r21, 0x0F08	; 0x800f08 <settings+0x38>
    59de:	c7 01       	movw	r24, r14
    59e0:	b6 01       	movw	r22, r12
    59e2:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    59e6:	a3 01       	movw	r20, r6
    59e8:	92 01       	movw	r18, r4
    59ea:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    59ee:	6b 01       	movw	r12, r22
    59f0:	7c 01       	movw	r14, r24
    59f2:	a3 01       	movw	r20, r6
    59f4:	92 01       	movw	r18, r4
    59f6:	60 e0       	ldi	r22, 0x00	; 0
    59f8:	70 e0       	ldi	r23, 0x00	; 0
    59fa:	80 e8       	ldi	r24, 0x80	; 128
    59fc:	9f e3       	ldi	r25, 0x3F	; 63
    59fe:	0e 94 c6 3e 	call	0x7d8c	; 0x7d8c <__subsf3>
    5a02:	9b 01       	movw	r18, r22
    5a04:	ac 01       	movw	r20, r24
    5a06:	c7 01       	movw	r24, r14
    5a08:	b6 01       	movw	r22, r12
    5a0a:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <__divsf3>
    5a0e:	e6 2e       	mov	r14, r22
    5a10:	f7 2e       	mov	r15, r23
    5a12:	08 2f       	mov	r16, r24
    5a14:	19 2f       	mov	r17, r25
    5a16:	20 e0       	ldi	r18, 0x00	; 0
    5a18:	30 e0       	ldi	r19, 0x00	; 0
    5a1a:	a9 01       	movw	r20, r18
    5a1c:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    5a20:	88 23       	and	r24, r24
    5a22:	24 f4       	brge	.+8      	; 0x5a2c <plan_buffer_line+0x450>
    5a24:	e1 2c       	mov	r14, r1
    5a26:	f1 2c       	mov	r15, r1
    5a28:	00 e0       	ldi	r16, 0x00	; 0
    5a2a:	10 e0       	ldi	r17, 0x00	; 0
    5a2c:	86 e3       	ldi	r24, 0x36	; 54
    5a2e:	8a 9d       	mul	r24, r10
    5a30:	f0 01       	movw	r30, r0
    5a32:	8b 9d       	mul	r24, r11
    5a34:	f0 0d       	add	r31, r0
    5a36:	11 24       	eor	r1, r1
    5a38:	e8 58       	subi	r30, 0x88	; 136
    5a3a:	fb 4f       	sbci	r31, 0xFB	; 251
    5a3c:	4e 2d       	mov	r20, r14
    5a3e:	5f 2d       	mov	r21, r15
    5a40:	60 2f       	mov	r22, r16
    5a42:	71 2f       	mov	r23, r17
    5a44:	46 a3       	std	Z+38, r20	; 0x26
    5a46:	57 a3       	std	Z+39, r21	; 0x27
    5a48:	60 a7       	std	Z+40, r22	; 0x28
    5a4a:	71 a7       	std	Z+41, r23	; 0x29
    5a4c:	86 e3       	ldi	r24, 0x36	; 54
    5a4e:	8a 9d       	mul	r24, r10
    5a50:	f0 01       	movw	r30, r0
    5a52:	8b 9d       	mul	r24, r11
    5a54:	f0 0d       	add	r31, r0
    5a56:	11 24       	eor	r1, r1
    5a58:	e8 58       	subi	r30, 0x88	; 136
    5a5a:	fb 4f       	sbci	r31, 0xFB	; 251
    5a5c:	81 89       	ldd	r24, Z+17	; 0x11
    5a5e:	81 fd       	sbrc	r24, 1
    5a60:	87 c0       	rjmp	.+270    	; 0x5b70 <plan_buffer_line+0x594>
    5a62:	21 96       	adiw	r28, 0x01	; 1
    5a64:	8e ad       	ldd	r24, Y+62	; 0x3e
    5a66:	9f ad       	ldd	r25, Y+63	; 0x3f
    5a68:	21 97       	sbiw	r28, 0x01	; 1
    5a6a:	82 dc       	rcall	.-1788   	; 0x5370 <plan_compute_profile_nominal_speed>
    5a6c:	6b 01       	movw	r12, r22
    5a6e:	7c 01       	movw	r14, r24
    5a70:	40 90 70 04 	lds	r4, 0x0470	; 0x800470 <pl+0x18>
    5a74:	50 90 71 04 	lds	r5, 0x0471	; 0x800471 <pl+0x19>
    5a78:	60 90 72 04 	lds	r6, 0x0472	; 0x800472 <pl+0x1a>
    5a7c:	70 90 73 04 	lds	r7, 0x0473	; 0x800473 <pl+0x1b>
    5a80:	a3 01       	movw	r20, r6
    5a82:	92 01       	movw	r18, r4
    5a84:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    5a88:	18 16       	cp	r1, r24
    5a8a:	a4 f4       	brge	.+40     	; 0x5ab4 <plan_buffer_line+0x4d8>
    5a8c:	86 e3       	ldi	r24, 0x36	; 54
    5a8e:	8a 9d       	mul	r24, r10
    5a90:	80 01       	movw	r16, r0
    5a92:	8b 9d       	mul	r24, r11
    5a94:	10 0d       	add	r17, r0
    5a96:	11 24       	eor	r1, r1
    5a98:	08 58       	subi	r16, 0x88	; 136
    5a9a:	1b 4f       	sbci	r17, 0xFB	; 251
    5a9c:	a3 01       	movw	r20, r6
    5a9e:	92 01       	movw	r18, r4
    5aa0:	c3 01       	movw	r24, r6
    5aa2:	b2 01       	movw	r22, r4
    5aa4:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    5aa8:	f8 01       	movw	r30, r16
    5aaa:	62 8f       	std	Z+26, r22	; 0x1a
    5aac:	73 8f       	std	Z+27, r23	; 0x1b
    5aae:	84 8f       	std	Z+28, r24	; 0x1c
    5ab0:	95 8f       	std	Z+29, r25	; 0x1d
    5ab2:	13 c0       	rjmp	.+38     	; 0x5ada <plan_buffer_line+0x4fe>
    5ab4:	86 e3       	ldi	r24, 0x36	; 54
    5ab6:	8a 9d       	mul	r24, r10
    5ab8:	80 01       	movw	r16, r0
    5aba:	8b 9d       	mul	r24, r11
    5abc:	10 0d       	add	r17, r0
    5abe:	11 24       	eor	r1, r1
    5ac0:	08 58       	subi	r16, 0x88	; 136
    5ac2:	1b 4f       	sbci	r17, 0xFB	; 251
    5ac4:	a7 01       	movw	r20, r14
    5ac6:	96 01       	movw	r18, r12
    5ac8:	c7 01       	movw	r24, r14
    5aca:	b6 01       	movw	r22, r12
    5acc:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    5ad0:	f8 01       	movw	r30, r16
    5ad2:	62 8f       	std	Z+26, r22	; 0x1a
    5ad4:	73 8f       	std	Z+27, r23	; 0x1b
    5ad6:	84 8f       	std	Z+28, r24	; 0x1c
    5ad8:	95 8f       	std	Z+29, r25	; 0x1d
    5ada:	86 e3       	ldi	r24, 0x36	; 54
    5adc:	8a 9d       	mul	r24, r10
    5ade:	f0 01       	movw	r30, r0
    5ae0:	8b 9d       	mul	r24, r11
    5ae2:	f0 0d       	add	r31, r0
    5ae4:	11 24       	eor	r1, r1
    5ae6:	e8 58       	subi	r30, 0x88	; 136
    5ae8:	fb 4f       	sbci	r31, 0xFB	; 251
    5aea:	46 a0       	ldd	r4, Z+38	; 0x26
    5aec:	57 a0       	ldd	r5, Z+39	; 0x27
    5aee:	60 a4       	ldd	r6, Z+40	; 0x28
    5af0:	71 a4       	ldd	r7, Z+41	; 0x29
    5af2:	a3 01       	movw	r20, r6
    5af4:	92 01       	movw	r18, r4
    5af6:	62 8d       	ldd	r22, Z+26	; 0x1a
    5af8:	73 8d       	ldd	r23, Z+27	; 0x1b
    5afa:	84 8d       	ldd	r24, Z+28	; 0x1c
    5afc:	95 8d       	ldd	r25, Z+29	; 0x1d
    5afe:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    5b02:	18 16       	cp	r1, r24
    5b04:	64 f4       	brge	.+24     	; 0x5b1e <plan_buffer_line+0x542>
    5b06:	86 e3       	ldi	r24, 0x36	; 54
    5b08:	8a 9d       	mul	r24, r10
    5b0a:	f0 01       	movw	r30, r0
    5b0c:	8b 9d       	mul	r24, r11
    5b0e:	f0 0d       	add	r31, r0
    5b10:	11 24       	eor	r1, r1
    5b12:	e8 58       	subi	r30, 0x88	; 136
    5b14:	fb 4f       	sbci	r31, 0xFB	; 251
    5b16:	42 8e       	std	Z+26, r4	; 0x1a
    5b18:	53 8e       	std	Z+27, r5	; 0x1b
    5b1a:	64 8e       	std	Z+28, r6	; 0x1c
    5b1c:	75 8e       	std	Z+29, r7	; 0x1d
    5b1e:	c0 92 70 04 	sts	0x0470, r12	; 0x800470 <pl+0x18>
    5b22:	d0 92 71 04 	sts	0x0471, r13	; 0x800471 <pl+0x19>
    5b26:	e0 92 72 04 	sts	0x0472, r14	; 0x800472 <pl+0x1a>
    5b2a:	f0 92 73 04 	sts	0x0473, r15	; 0x800473 <pl+0x1b>
    5b2e:	8c e0       	ldi	r24, 0x0C	; 12
    5b30:	fe 01       	movw	r30, r28
    5b32:	79 96       	adiw	r30, 0x19	; 25
    5b34:	a4 e6       	ldi	r26, 0x64	; 100
    5b36:	b4 e0       	ldi	r27, 0x04	; 4
    5b38:	01 90       	ld	r0, Z+
    5b3a:	0d 92       	st	X+, r0
    5b3c:	8a 95       	dec	r24
    5b3e:	e1 f7       	brne	.-8      	; 0x5b38 <plan_buffer_line+0x55c>
    5b40:	8c e0       	ldi	r24, 0x0C	; 12
    5b42:	fe 01       	movw	r30, r28
    5b44:	31 96       	adiw	r30, 0x01	; 1
    5b46:	a8 e5       	ldi	r26, 0x58	; 88
    5b48:	b4 e0       	ldi	r27, 0x04	; 4
    5b4a:	01 90       	ld	r0, Z+
    5b4c:	0d 92       	st	X+, r0
    5b4e:	8a 95       	dec	r24
    5b50:	e1 f7       	brne	.-8      	; 0x5b4a <plan_buffer_line+0x56e>
    5b52:	80 91 75 04 	lds	r24, 0x0475	; 0x800475 <next_buffer_head>
    5b56:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <block_buffer_head>
    5b5a:	8f 5f       	subi	r24, 0xFF	; 255
    5b5c:	84 32       	cpi	r24, 0x24	; 36
    5b5e:	09 f4       	brne	.+2      	; 0x5b62 <plan_buffer_line+0x586>
    5b60:	80 e0       	ldi	r24, 0x00	; 0
    5b62:	80 93 75 04 	sts	0x0475, r24	; 0x800475 <next_buffer_head>
    5b66:	3d da       	rcall	.-2950   	; 0x4fe2 <planner_recalculate>
    5b68:	81 e0       	ldi	r24, 0x01	; 1
    5b6a:	39 c0       	rjmp	.+114    	; 0x5bde <plan_buffer_line+0x602>
    5b6c:	80 e0       	ldi	r24, 0x00	; 0
    5b6e:	37 c0       	rjmp	.+110    	; 0x5bde <plan_buffer_line+0x602>
    5b70:	81 e0       	ldi	r24, 0x01	; 1
    5b72:	35 c0       	rjmp	.+106    	; 0x5bde <plan_buffer_line+0x602>
    5b74:	89 af       	std	Y+57, r24	; 0x39
    5b76:	9a af       	std	Y+58, r25	; 0x3a
    5b78:	20 ed       	ldi	r18, 0xD0	; 208
    5b7a:	3e e0       	ldi	r19, 0x0E	; 14
    5b7c:	3c af       	std	Y+60, r19	; 0x3c
    5b7e:	2b af       	std	Y+59, r18	; 0x3b
    5b80:	ae 01       	movw	r20, r28
    5b82:	4f 5f       	subi	r20, 0xFF	; 255
    5b84:	5f 4f       	sbci	r21, 0xFF	; 255
    5b86:	4a 01       	movw	r8, r20
    5b88:	6e 01       	movw	r12, r28
    5b8a:	5d e0       	ldi	r21, 0x0D	; 13
    5b8c:	c5 0e       	add	r12, r21
    5b8e:	d1 1c       	adc	r13, r1
    5b90:	66 e3       	ldi	r22, 0x36	; 54
    5b92:	26 9e       	mul	r2, r22
    5b94:	c0 01       	movw	r24, r0
    5b96:	11 24       	eor	r1, r1
    5b98:	fc 01       	movw	r30, r24
    5b9a:	e8 58       	subi	r30, 0x88	; 136
    5b9c:	fb 4f       	sbci	r31, 0xFB	; 251
    5b9e:	1f 01       	movw	r2, r30
    5ba0:	9e 01       	movw	r18, r28
    5ba2:	27 5e       	subi	r18, 0xE7	; 231
    5ba4:	3f 4f       	sbci	r19, 0xFF	; 255
    5ba6:	25 96       	adiw	r28, 0x05	; 5
    5ba8:	3f af       	std	Y+63, r19	; 0x3f
    5baa:	2e af       	std	Y+62, r18	; 0x3e
    5bac:	25 97       	sbiw	r28, 0x05	; 5
    5bae:	3e af       	std	Y+62, r19	; 0x3e
    5bb0:	2d af       	std	Y+61, r18	; 0x3d
    5bb2:	10 e0       	ldi	r17, 0x00	; 0
    5bb4:	26 e3       	ldi	r18, 0x36	; 54
    5bb6:	2a 9d       	mul	r18, r10
    5bb8:	c0 01       	movw	r24, r0
    5bba:	2b 9d       	mul	r18, r11
    5bbc:	90 0d       	add	r25, r0
    5bbe:	11 24       	eor	r1, r1
    5bc0:	88 58       	subi	r24, 0x88	; 136
    5bc2:	9b 4f       	sbci	r25, 0xFB	; 251
    5bc4:	7c 01       	movw	r14, r24
    5bc6:	3c e0       	ldi	r19, 0x0C	; 12
    5bc8:	e3 0e       	add	r14, r19
    5bca:	f1 1c       	adc	r15, r1
    5bcc:	ac 01       	movw	r20, r24
    5bce:	40 5f       	subi	r20, 0xF0	; 240
    5bd0:	5f 4f       	sbci	r21, 0xFF	; 255
    5bd2:	27 96       	adiw	r28, 0x07	; 7
    5bd4:	5f af       	std	Y+63, r21	; 0x3f
    5bd6:	4e af       	std	Y+62, r20	; 0x3e
    5bd8:	27 97       	sbiw	r28, 0x07	; 7
    5bda:	19 ab       	std	Y+49, r17	; 0x31
    5bdc:	70 cd       	rjmp	.-1312   	; 0x56be <plan_buffer_line+0xe2>
    5bde:	ca 5b       	subi	r28, 0xBA	; 186
    5be0:	df 4f       	sbci	r29, 0xFF	; 255
    5be2:	0f b6       	in	r0, 0x3f	; 63
    5be4:	f8 94       	cli
    5be6:	de bf       	out	0x3e, r29	; 62
    5be8:	0f be       	out	0x3f, r0	; 63
    5bea:	cd bf       	out	0x3d, r28	; 61
    5bec:	df 91       	pop	r29
    5bee:	cf 91       	pop	r28
    5bf0:	1f 91       	pop	r17
    5bf2:	0f 91       	pop	r16
    5bf4:	ff 90       	pop	r15
    5bf6:	ef 90       	pop	r14
    5bf8:	df 90       	pop	r13
    5bfa:	cf 90       	pop	r12
    5bfc:	bf 90       	pop	r11
    5bfe:	af 90       	pop	r10
    5c00:	9f 90       	pop	r9
    5c02:	8f 90       	pop	r8
    5c04:	7f 90       	pop	r7
    5c06:	6f 90       	pop	r6
    5c08:	5f 90       	pop	r5
    5c0a:	4f 90       	pop	r4
    5c0c:	3f 90       	pop	r3
    5c0e:	2f 90       	pop	r2
    5c10:	08 95       	ret

00005c12 <plan_sync_position>:
    5c12:	e3 e4       	ldi	r30, 0x43	; 67
    5c14:	fc e0       	ldi	r31, 0x0C	; 12
    5c16:	a8 e5       	ldi	r26, 0x58	; 88
    5c18:	b4 e0       	ldi	r27, 0x04	; 4
    5c1a:	8f e4       	ldi	r24, 0x4F	; 79
    5c1c:	9c e0       	ldi	r25, 0x0C	; 12
    5c1e:	41 91       	ld	r20, Z+
    5c20:	51 91       	ld	r21, Z+
    5c22:	61 91       	ld	r22, Z+
    5c24:	71 91       	ld	r23, Z+
    5c26:	4d 93       	st	X+, r20
    5c28:	5d 93       	st	X+, r21
    5c2a:	6d 93       	st	X+, r22
    5c2c:	7d 93       	st	X+, r23
    5c2e:	e8 17       	cp	r30, r24
    5c30:	f9 07       	cpc	r31, r25
    5c32:	a9 f7       	brne	.-22     	; 0x5c1e <plan_sync_position+0xc>
    5c34:	08 95       	ret

00005c36 <plan_get_block_buffer_available>:
    5c36:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <block_buffer_head>
    5c3a:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    5c3e:	98 17       	cp	r25, r24
    5c40:	18 f0       	brcs	.+6      	; 0x5c48 <plan_get_block_buffer_available+0x12>
    5c42:	8d 5d       	subi	r24, 0xDD	; 221
    5c44:	89 1b       	sub	r24, r25
    5c46:	08 95       	ret
    5c48:	81 50       	subi	r24, 0x01	; 1
    5c4a:	89 1b       	sub	r24, r25
    5c4c:	08 95       	ret

00005c4e <plan_cycle_reinitialize>:
// Re-initialize buffer plan with a partially completed block, assumed to exist at the buffer tail.
// Called after a steppers have come to a complete stop for a feed hold and the cycle is stopped.
void plan_cycle_reinitialize()
{
  // Re-plan from a complete stop. Reset planner entry speeds and buffer planned pointer.
  st_update_plan_block_parameters();
    5c4e:	0e 94 2e 1c 	call	0x385c	; 0x385c <st_update_plan_block_parameters>
  block_buffer_planned = block_buffer_tail;
    5c52:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    5c56:	80 93 74 04 	sts	0x0474, r24	; 0x800474 <block_buffer_planned>
  planner_recalculate();
    5c5a:	c3 c9       	rjmp	.-3194   	; 0x4fe2 <planner_recalculate>
    5c5c:	08 95       	ret

00005c5e <read_float>:
// Delays variable defined microseconds. Compiler compatibility fix for _delay_us(),
// which only accepts constants in future compiler releases. Written to perform more
// efficiently with larger delays, as the counter adds parasitic time in each iteration.
void delay_us(uint32_t us)
{
  while (us) {
    5c5e:	4f 92       	push	r4
    5c60:	5f 92       	push	r5
    5c62:	6f 92       	push	r6
    5c64:	7f 92       	push	r7
    5c66:	8f 92       	push	r8
    5c68:	9f 92       	push	r9
    5c6a:	af 92       	push	r10
    5c6c:	bf 92       	push	r11
    5c6e:	cf 92       	push	r12
    5c70:	df 92       	push	r13
    5c72:	ef 92       	push	r14
    5c74:	ff 92       	push	r15
    5c76:	0f 93       	push	r16
    5c78:	1f 93       	push	r17
    5c7a:	cf 93       	push	r28
    5c7c:	df 93       	push	r29
    5c7e:	dc 01       	movw	r26, r24
    5c80:	fb 01       	movw	r30, r22
    5c82:	c0 81       	ld	r28, Z
    5c84:	d0 e0       	ldi	r29, 0x00	; 0
    5c86:	fc 01       	movw	r30, r24
    5c88:	ec 0f       	add	r30, r28
    5c8a:	fd 1f       	adc	r31, r29
    5c8c:	90 81       	ld	r25, Z
    5c8e:	9d 32       	cpi	r25, 0x2D	; 45
    5c90:	29 f4       	brne	.+10     	; 0x5c9c <read_float+0x3e>
    5c92:	ef 01       	movw	r28, r30
    5c94:	22 96       	adiw	r28, 0x02	; 2
    5c96:	91 81       	ldd	r25, Z+1	; 0x01
    5c98:	01 e0       	ldi	r16, 0x01	; 1
    5c9a:	0b c0       	rjmp	.+22     	; 0x5cb2 <read_float+0x54>
    5c9c:	9b 32       	cpi	r25, 0x2B	; 43
    5c9e:	29 f0       	breq	.+10     	; 0x5caa <read_float+0x4c>
    5ca0:	21 96       	adiw	r28, 0x01	; 1
    5ca2:	ca 0f       	add	r28, r26
    5ca4:	db 1f       	adc	r29, r27
    5ca6:	00 e0       	ldi	r16, 0x00	; 0
    5ca8:	04 c0       	rjmp	.+8      	; 0x5cb2 <read_float+0x54>
    5caa:	ef 01       	movw	r28, r30
    5cac:	22 96       	adiw	r28, 0x02	; 2
    5cae:	91 81       	ldd	r25, Z+1	; 0x01
    5cb0:	00 e0       	ldi	r16, 0x00	; 0
    5cb2:	80 e0       	ldi	r24, 0x00	; 0
    5cb4:	20 e0       	ldi	r18, 0x00	; 0
    5cb6:	10 e0       	ldi	r17, 0x00	; 0
    5cb8:	41 2c       	mov	r4, r1
    5cba:	51 2c       	mov	r5, r1
    5cbc:	32 01       	movw	r6, r4
    5cbe:	31 e0       	ldi	r19, 0x01	; 1
    5cc0:	fe 01       	movw	r30, r28
    5cc2:	90 53       	subi	r25, 0x30	; 48
    5cc4:	9a 30       	cpi	r25, 0x0A	; 10
    5cc6:	10 f5       	brcc	.+68     	; 0x5d0c <read_float+0xae>
    5cc8:	2f 5f       	subi	r18, 0xFF	; 255
    5cca:	29 30       	cpi	r18, 0x09	; 9
    5ccc:	d8 f4       	brcc	.+54     	; 0x5d04 <read_float+0xa6>
    5cce:	81 11       	cpse	r24, r1
    5cd0:	11 50       	subi	r17, 0x01	; 1
    5cd2:	53 01       	movw	r10, r6
    5cd4:	42 01       	movw	r8, r4
    5cd6:	88 0c       	add	r8, r8
    5cd8:	99 1c       	adc	r9, r9
    5cda:	aa 1c       	adc	r10, r10
    5cdc:	bb 1c       	adc	r11, r11
    5cde:	88 0c       	add	r8, r8
    5ce0:	99 1c       	adc	r9, r9
    5ce2:	aa 1c       	adc	r10, r10
    5ce4:	bb 1c       	adc	r11, r11
    5ce6:	84 0c       	add	r8, r4
    5ce8:	95 1c       	adc	r9, r5
    5cea:	a6 1c       	adc	r10, r6
    5cec:	b7 1c       	adc	r11, r7
    5cee:	88 0c       	add	r8, r8
    5cf0:	99 1c       	adc	r9, r9
    5cf2:	aa 1c       	adc	r10, r10
    5cf4:	bb 1c       	adc	r11, r11
    5cf6:	24 01       	movw	r4, r8
    5cf8:	35 01       	movw	r6, r10
    5cfa:	49 0e       	add	r4, r25
    5cfc:	51 1c       	adc	r5, r1
    5cfe:	61 1c       	adc	r6, r1
    5d00:	71 1c       	adc	r7, r1
    5d02:	09 c0       	rjmp	.+18     	; 0x5d16 <read_float+0xb8>
    5d04:	81 11       	cpse	r24, r1
    5d06:	07 c0       	rjmp	.+14     	; 0x5d16 <read_float+0xb8>
    5d08:	1f 5f       	subi	r17, 0xFF	; 255
    5d0a:	05 c0       	rjmp	.+10     	; 0x5d16 <read_float+0xb8>
    5d0c:	9e 3f       	cpi	r25, 0xFE	; 254
    5d0e:	31 f4       	brne	.+12     	; 0x5d1c <read_float+0xbe>
    5d10:	81 11       	cpse	r24, r1
    5d12:	04 c0       	rjmp	.+8      	; 0x5d1c <read_float+0xbe>
    5d14:	83 2f       	mov	r24, r19
    5d16:	90 81       	ld	r25, Z
    5d18:	21 96       	adiw	r28, 0x01	; 1
    5d1a:	d2 cf       	rjmp	.-92     	; 0x5cc0 <read_float+0x62>
    5d1c:	22 23       	and	r18, r18
    5d1e:	09 f4       	brne	.+2      	; 0x5d22 <read_float+0xc4>
    5d20:	52 c0       	rjmp	.+164    	; 0x5dc6 <read_float+0x168>
    5d22:	6a 01       	movw	r12, r20
    5d24:	7b 01       	movw	r14, r22
    5d26:	5d 01       	movw	r10, r26
    5d28:	c3 01       	movw	r24, r6
    5d2a:	b2 01       	movw	r22, r4
    5d2c:	0e 94 40 40 	call	0x8080	; 0x8080 <__floatunsisf>
    5d30:	2b 01       	movw	r4, r22
    5d32:	3c 01       	movw	r6, r24
    5d34:	20 e0       	ldi	r18, 0x00	; 0
    5d36:	30 e0       	ldi	r19, 0x00	; 0
    5d38:	a9 01       	movw	r20, r18
    5d3a:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    5d3e:	88 23       	and	r24, r24
    5d40:	51 f1       	breq	.+84     	; 0x5d96 <read_float+0x138>
    5d42:	1f 3f       	cpi	r17, 0xFF	; 255
    5d44:	6c f4       	brge	.+26     	; 0x5d60 <read_float+0x102>
    5d46:	2a e0       	ldi	r18, 0x0A	; 10
    5d48:	37 ed       	ldi	r19, 0xD7	; 215
    5d4a:	43 e2       	ldi	r20, 0x23	; 35
    5d4c:	5c e3       	ldi	r21, 0x3C	; 60
    5d4e:	c3 01       	movw	r24, r6
    5d50:	b2 01       	movw	r22, r4
    5d52:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    5d56:	2b 01       	movw	r4, r22
    5d58:	3c 01       	movw	r6, r24
    5d5a:	1e 5f       	subi	r17, 0xFE	; 254
    5d5c:	1f 3f       	cpi	r17, 0xFF	; 255
    5d5e:	9c f3       	brlt	.-26     	; 0x5d46 <read_float+0xe8>
    5d60:	11 23       	and	r17, r17
    5d62:	5c f4       	brge	.+22     	; 0x5d7a <read_float+0x11c>
    5d64:	2d ec       	ldi	r18, 0xCD	; 205
    5d66:	3c ec       	ldi	r19, 0xCC	; 204
    5d68:	4c ec       	ldi	r20, 0xCC	; 204
    5d6a:	5d e3       	ldi	r21, 0x3D	; 61
    5d6c:	c3 01       	movw	r24, r6
    5d6e:	b2 01       	movw	r22, r4
    5d70:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    5d74:	2b 01       	movw	r4, r22
    5d76:	3c 01       	movw	r6, r24
    5d78:	0e c0       	rjmp	.+28     	; 0x5d96 <read_float+0x138>
    5d7a:	11 16       	cp	r1, r17
    5d7c:	64 f4       	brge	.+24     	; 0x5d96 <read_float+0x138>
    5d7e:	20 e0       	ldi	r18, 0x00	; 0
    5d80:	30 e0       	ldi	r19, 0x00	; 0
    5d82:	40 e2       	ldi	r20, 0x20	; 32
    5d84:	51 e4       	ldi	r21, 0x41	; 65
    5d86:	c3 01       	movw	r24, r6
    5d88:	b2 01       	movw	r22, r4
    5d8a:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    5d8e:	2b 01       	movw	r4, r22
    5d90:	3c 01       	movw	r6, r24
    5d92:	11 50       	subi	r17, 0x01	; 1
    5d94:	a1 f7       	brne	.-24     	; 0x5d7e <read_float+0x120>
    5d96:	00 23       	and	r16, r16
    5d98:	51 f0       	breq	.+20     	; 0x5dae <read_float+0x150>
    5d9a:	77 fa       	bst	r7, 7
    5d9c:	70 94       	com	r7
    5d9e:	77 f8       	bld	r7, 7
    5da0:	70 94       	com	r7
    5da2:	f6 01       	movw	r30, r12
    5da4:	40 82       	st	Z, r4
    5da6:	51 82       	std	Z+1, r5	; 0x01
    5da8:	62 82       	std	Z+2, r6	; 0x02
    5daa:	73 82       	std	Z+3, r7	; 0x03
    5dac:	05 c0       	rjmp	.+10     	; 0x5db8 <read_float+0x15a>
    5dae:	f6 01       	movw	r30, r12
    5db0:	40 82       	st	Z, r4
    5db2:	51 82       	std	Z+1, r5	; 0x01
    5db4:	62 82       	std	Z+2, r6	; 0x02
    5db6:	73 82       	std	Z+3, r7	; 0x03
    5db8:	ca 19       	sub	r28, r10
    5dba:	db 09       	sbc	r29, r11
    5dbc:	c1 50       	subi	r28, 0x01	; 1
    5dbe:	f7 01       	movw	r30, r14
    5dc0:	c0 83       	st	Z, r28
    5dc2:	81 e0       	ldi	r24, 0x01	; 1
    5dc4:	01 c0       	rjmp	.+2      	; 0x5dc8 <read_float+0x16a>
    5dc6:	80 e0       	ldi	r24, 0x00	; 0
    5dc8:	df 91       	pop	r29
    5dca:	cf 91       	pop	r28
    5dcc:	1f 91       	pop	r17
    5dce:	0f 91       	pop	r16
    5dd0:	ff 90       	pop	r15
    5dd2:	ef 90       	pop	r14
    5dd4:	df 90       	pop	r13
    5dd6:	cf 90       	pop	r12
    5dd8:	bf 90       	pop	r11
    5dda:	af 90       	pop	r10
    5ddc:	9f 90       	pop	r9
    5dde:	8f 90       	pop	r8
    5de0:	7f 90       	pop	r7
    5de2:	6f 90       	pop	r6
    5de4:	5f 90       	pop	r5
    5de6:	4f 90       	pop	r4
    5de8:	08 95       	ret

00005dea <delay_sec>:
    5dea:	ff 92       	push	r15
    5dec:	0f 93       	push	r16
    5dee:	1f 93       	push	r17
    5df0:	cf 93       	push	r28
    5df2:	df 93       	push	r29
    5df4:	f4 2e       	mov	r15, r20
    5df6:	20 e0       	ldi	r18, 0x00	; 0
    5df8:	30 e0       	ldi	r19, 0x00	; 0
    5dfa:	40 ea       	ldi	r20, 0xA0	; 160
    5dfc:	51 e4       	ldi	r21, 0x41	; 65
    5dfe:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    5e02:	0e 94 8d 3f 	call	0x7f1a	; 0x7f1a <ceil>
    5e06:	0e 94 14 40 	call	0x8028	; 0x8028 <__fixunssfsi>
    5e0a:	61 15       	cp	r22, r1
    5e0c:	71 05       	cpc	r23, r1
    5e0e:	21 f1       	breq	.+72     	; 0x5e58 <delay_sec+0x6e>
    5e10:	20 91 1f 0c 	lds	r18, 0x0C1F	; 0x800c1f <sys+0x1>
    5e14:	21 11       	cpse	r18, r1
    5e16:	20 c0       	rjmp	.+64     	; 0x5e58 <delay_sec+0x6e>
    5e18:	eb 01       	movw	r28, r22
    5e1a:	0e e1       	ldi	r16, 0x1E	; 30
    5e1c:	1c e0       	ldi	r17, 0x0C	; 12
    5e1e:	05 c0       	rjmp	.+10     	; 0x5e2a <delay_sec+0x40>
    5e20:	21 97       	sbiw	r28, 0x01	; 1
    5e22:	f8 01       	movw	r30, r16
    5e24:	81 81       	ldd	r24, Z+1	; 0x01
    5e26:	81 11       	cpse	r24, r1
    5e28:	17 c0       	rjmp	.+46     	; 0x5e58 <delay_sec+0x6e>
    5e2a:	f1 10       	cpse	r15, r1
    5e2c:	03 c0       	rjmp	.+6      	; 0x5e34 <delay_sec+0x4a>
    5e2e:	0e 94 66 17 	call	0x2ecc	; 0x2ecc <protocol_execute_realtime>
    5e32:	06 c0       	rjmp	.+12     	; 0x5e40 <delay_sec+0x56>
    5e34:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <protocol_exec_rt_system>
    5e38:	f8 01       	movw	r30, r16
    5e3a:	82 81       	ldd	r24, Z+2	; 0x02
    5e3c:	81 fd       	sbrc	r24, 1
    5e3e:	0c c0       	rjmp	.+24     	; 0x5e58 <delay_sec+0x6e>
    5e40:	ff ef       	ldi	r31, 0xFF	; 255
    5e42:	20 e7       	ldi	r18, 0x70	; 112
    5e44:	82 e0       	ldi	r24, 0x02	; 2
    5e46:	f1 50       	subi	r31, 0x01	; 1
    5e48:	20 40       	sbci	r18, 0x00	; 0
    5e4a:	80 40       	sbci	r24, 0x00	; 0
    5e4c:	e1 f7       	brne	.-8      	; 0x5e46 <delay_sec+0x5c>
    5e4e:	00 c0       	rjmp	.+0      	; 0x5e50 <delay_sec+0x66>
    5e50:	00 00       	nop
    5e52:	c1 30       	cpi	r28, 0x01	; 1
    5e54:	d1 05       	cpc	r29, r1
    5e56:	21 f7       	brne	.-56     	; 0x5e20 <delay_sec+0x36>
    5e58:	df 91       	pop	r29
    5e5a:	cf 91       	pop	r28
    5e5c:	1f 91       	pop	r17
    5e5e:	0f 91       	pop	r16
    5e60:	ff 90       	pop	r15
    5e62:	08 95       	ret

00005e64 <delay_ms>:
    5e64:	00 97       	sbiw	r24, 0x00	; 0
    5e66:	41 f0       	breq	.+16     	; 0x5e78 <delay_ms+0x14>
    5e68:	ef e9       	ldi	r30, 0x9F	; 159
    5e6a:	ff e0       	ldi	r31, 0x0F	; 15
    5e6c:	31 97       	sbiw	r30, 0x01	; 1
    5e6e:	f1 f7       	brne	.-4      	; 0x5e6c <delay_ms+0x8>
    5e70:	00 c0       	rjmp	.+0      	; 0x5e72 <delay_ms+0xe>
    5e72:	00 00       	nop
    5e74:	01 97       	sbiw	r24, 0x01	; 1
    5e76:	c1 f7       	brne	.-16     	; 0x5e68 <delay_ms+0x4>
    5e78:	08 95       	ret

00005e7a <hypot_f>:
  }
}


// Simple hypotenuse computation function.
float hypot_f(float x, float y) { return(sqrt(x*x + y*y)); }
    5e7a:	4f 92       	push	r4
    5e7c:	5f 92       	push	r5
    5e7e:	6f 92       	push	r6
    5e80:	7f 92       	push	r7
    5e82:	8f 92       	push	r8
    5e84:	9f 92       	push	r9
    5e86:	af 92       	push	r10
    5e88:	bf 92       	push	r11
    5e8a:	cf 92       	push	r12
    5e8c:	df 92       	push	r13
    5e8e:	ef 92       	push	r14
    5e90:	ff 92       	push	r15
    5e92:	4b 01       	movw	r8, r22
    5e94:	5c 01       	movw	r10, r24
    5e96:	69 01       	movw	r12, r18
    5e98:	7a 01       	movw	r14, r20
    5e9a:	a5 01       	movw	r20, r10
    5e9c:	94 01       	movw	r18, r8
    5e9e:	c5 01       	movw	r24, r10
    5ea0:	b4 01       	movw	r22, r8
    5ea2:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    5ea6:	4b 01       	movw	r8, r22
    5ea8:	5c 01       	movw	r10, r24
    5eaa:	a7 01       	movw	r20, r14
    5eac:	96 01       	movw	r18, r12
    5eae:	c7 01       	movw	r24, r14
    5eb0:	b6 01       	movw	r22, r12
    5eb2:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    5eb6:	9b 01       	movw	r18, r22
    5eb8:	ac 01       	movw	r20, r24
    5eba:	c5 01       	movw	r24, r10
    5ebc:	b4 01       	movw	r22, r8
    5ebe:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    5ec2:	0e 94 6b 42 	call	0x84d6	; 0x84d6 <sqrt>
    5ec6:	ff 90       	pop	r15
    5ec8:	ef 90       	pop	r14
    5eca:	df 90       	pop	r13
    5ecc:	cf 90       	pop	r12
    5ece:	bf 90       	pop	r11
    5ed0:	af 90       	pop	r10
    5ed2:	9f 90       	pop	r9
    5ed4:	8f 90       	pop	r8
    5ed6:	7f 90       	pop	r7
    5ed8:	6f 90       	pop	r6
    5eda:	5f 90       	pop	r5
    5edc:	4f 90       	pop	r4
    5ede:	08 95       	ret

00005ee0 <convert_delta_vector_to_unit_vector>:


float convert_delta_vector_to_unit_vector(float *vector)
{
    5ee0:	4f 92       	push	r4
    5ee2:	5f 92       	push	r5
    5ee4:	6f 92       	push	r6
    5ee6:	7f 92       	push	r7
    5ee8:	af 92       	push	r10
    5eea:	bf 92       	push	r11
    5eec:	cf 92       	push	r12
    5eee:	df 92       	push	r13
    5ef0:	ef 92       	push	r14
    5ef2:	ff 92       	push	r15
    5ef4:	0f 93       	push	r16
    5ef6:	1f 93       	push	r17
    5ef8:	cf 93       	push	r28
    5efa:	df 93       	push	r29
    5efc:	ec 01       	movw	r28, r24
    5efe:	5c 01       	movw	r10, r24
    5f00:	8c e0       	ldi	r24, 0x0C	; 12
    5f02:	a8 0e       	add	r10, r24
    5f04:	b1 1c       	adc	r11, r1
    5f06:	8e 01       	movw	r16, r28
  uint8_t idx;
  float magnitude = 0.0;
    5f08:	41 2c       	mov	r4, r1
    5f0a:	51 2c       	mov	r5, r1
    5f0c:	32 01       	movw	r6, r4
  for (idx=0; idx<N_AXIS; idx++) {
    if (vector[idx] != 0.0) {
    5f0e:	f8 01       	movw	r30, r16
    5f10:	c1 90       	ld	r12, Z+
    5f12:	d1 90       	ld	r13, Z+
    5f14:	e1 90       	ld	r14, Z+
    5f16:	f1 90       	ld	r15, Z+
    5f18:	8f 01       	movw	r16, r30
    5f1a:	20 e0       	ldi	r18, 0x00	; 0
    5f1c:	30 e0       	ldi	r19, 0x00	; 0
    5f1e:	a9 01       	movw	r20, r18
    5f20:	c7 01       	movw	r24, r14
    5f22:	b6 01       	movw	r22, r12
    5f24:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    5f28:	88 23       	and	r24, r24
    5f2a:	71 f0       	breq	.+28     	; 0x5f48 <convert_delta_vector_to_unit_vector+0x68>
      magnitude += vector[idx]*vector[idx];
    5f2c:	a7 01       	movw	r20, r14
    5f2e:	96 01       	movw	r18, r12
    5f30:	c7 01       	movw	r24, r14
    5f32:	b6 01       	movw	r22, r12
    5f34:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    5f38:	9b 01       	movw	r18, r22
    5f3a:	ac 01       	movw	r20, r24
    5f3c:	c3 01       	movw	r24, r6
    5f3e:	b2 01       	movw	r22, r4
    5f40:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    5f44:	2b 01       	movw	r4, r22
    5f46:	3c 01       	movw	r6, r24

float convert_delta_vector_to_unit_vector(float *vector)
{
  uint8_t idx;
  float magnitude = 0.0;
  for (idx=0; idx<N_AXIS; idx++) {
    5f48:	0a 15       	cp	r16, r10
    5f4a:	1b 05       	cpc	r17, r11
    5f4c:	01 f7       	brne	.-64     	; 0x5f0e <convert_delta_vector_to_unit_vector+0x2e>
    if (vector[idx] != 0.0) {
      magnitude += vector[idx]*vector[idx];
    }
  }
  magnitude = sqrt(magnitude);
    5f4e:	c3 01       	movw	r24, r6
    5f50:	b2 01       	movw	r22, r4
    5f52:	0e 94 6b 42 	call	0x84d6	; 0x84d6 <sqrt>
    5f56:	2b 01       	movw	r4, r22
    5f58:	3c 01       	movw	r6, r24
  float inv_magnitude = 1.0/magnitude;
    5f5a:	9b 01       	movw	r18, r22
    5f5c:	ac 01       	movw	r20, r24
    5f5e:	60 e0       	ldi	r22, 0x00	; 0
    5f60:	70 e0       	ldi	r23, 0x00	; 0
    5f62:	80 e8       	ldi	r24, 0x80	; 128
    5f64:	9f e3       	ldi	r25, 0x3F	; 63
    5f66:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <__divsf3>
    5f6a:	6b 01       	movw	r12, r22
    5f6c:	7c 01       	movw	r14, r24
  for (idx=0; idx<N_AXIS; idx++) { vector[idx] *= inv_magnitude; }
    5f6e:	a7 01       	movw	r20, r14
    5f70:	96 01       	movw	r18, r12
    5f72:	68 81       	ld	r22, Y
    5f74:	79 81       	ldd	r23, Y+1	; 0x01
    5f76:	8a 81       	ldd	r24, Y+2	; 0x02
    5f78:	9b 81       	ldd	r25, Y+3	; 0x03
    5f7a:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    5f7e:	69 93       	st	Y+, r22
    5f80:	79 93       	st	Y+, r23
    5f82:	89 93       	st	Y+, r24
    5f84:	99 93       	st	Y+, r25
    5f86:	ca 15       	cp	r28, r10
    5f88:	db 05       	cpc	r29, r11
    5f8a:	89 f7       	brne	.-30     	; 0x5f6e <convert_delta_vector_to_unit_vector+0x8e>
  return(magnitude);
}
    5f8c:	c3 01       	movw	r24, r6
    5f8e:	b2 01       	movw	r22, r4
    5f90:	df 91       	pop	r29
    5f92:	cf 91       	pop	r28
    5f94:	1f 91       	pop	r17
    5f96:	0f 91       	pop	r16
    5f98:	ff 90       	pop	r15
    5f9a:	ef 90       	pop	r14
    5f9c:	df 90       	pop	r13
    5f9e:	cf 90       	pop	r12
    5fa0:	bf 90       	pop	r11
    5fa2:	af 90       	pop	r10
    5fa4:	7f 90       	pop	r7
    5fa6:	6f 90       	pop	r6
    5fa8:	5f 90       	pop	r5
    5faa:	4f 90       	pop	r4
    5fac:	08 95       	ret

00005fae <limit_value_by_axis_maximum>:


float limit_value_by_axis_maximum(float *max_value, float *unit_vec)
{
    5fae:	6f 92       	push	r6
    5fb0:	7f 92       	push	r7
    5fb2:	8f 92       	push	r8
    5fb4:	9f 92       	push	r9
    5fb6:	af 92       	push	r10
    5fb8:	bf 92       	push	r11
    5fba:	cf 92       	push	r12
    5fbc:	df 92       	push	r13
    5fbe:	ef 92       	push	r14
    5fc0:	ff 92       	push	r15
    5fc2:	0f 93       	push	r16
    5fc4:	1f 93       	push	r17
    5fc6:	cf 93       	push	r28
    5fc8:	df 93       	push	r29
    5fca:	eb 01       	movw	r28, r22
    5fcc:	8c 01       	movw	r16, r24
    5fce:	7b 01       	movw	r14, r22
    5fd0:	8c e0       	ldi	r24, 0x0C	; 12
    5fd2:	e8 0e       	add	r14, r24
    5fd4:	f1 1c       	adc	r15, r1
  uint8_t idx;
  float limit_value = SOME_LARGE_VALUE;
    5fd6:	0f 2e       	mov	r0, r31
    5fd8:	f9 e9       	ldi	r31, 0x99	; 153
    5fda:	7f 2e       	mov	r7, r31
    5fdc:	f0 2d       	mov	r31, r0
    5fde:	0f 2e       	mov	r0, r31
    5fe0:	f6 e7       	ldi	r31, 0x76	; 118
    5fe2:	cf 2e       	mov	r12, r31
    5fe4:	f0 2d       	mov	r31, r0
    5fe6:	0f 2e       	mov	r0, r31
    5fe8:	f6 e9       	ldi	r31, 0x96	; 150
    5fea:	df 2e       	mov	r13, r31
    5fec:	f0 2d       	mov	r31, r0
    5fee:	0f 2e       	mov	r0, r31
    5ff0:	fe e7       	ldi	r31, 0x7E	; 126
    5ff2:	6f 2e       	mov	r6, r31
    5ff4:	f0 2d       	mov	r31, r0
  for (idx=0; idx<N_AXIS; idx++) {
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
    5ff6:	89 90       	ld	r8, Y+
    5ff8:	99 90       	ld	r9, Y+
    5ffa:	a9 90       	ld	r10, Y+
    5ffc:	b9 90       	ld	r11, Y+
    5ffe:	20 e0       	ldi	r18, 0x00	; 0
    6000:	30 e0       	ldi	r19, 0x00	; 0
    6002:	a9 01       	movw	r20, r18
    6004:	c5 01       	movw	r24, r10
    6006:	b4 01       	movw	r22, r8
    6008:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    600c:	88 23       	and	r24, r24
    600e:	d9 f0       	breq	.+54     	; 0x6046 <limit_value_by_axis_maximum+0x98>
      limit_value = min(limit_value,fabs(max_value[idx]/unit_vec[idx]));
    6010:	a5 01       	movw	r20, r10
    6012:	94 01       	movw	r18, r8
    6014:	f8 01       	movw	r30, r16
    6016:	60 81       	ld	r22, Z
    6018:	71 81       	ldd	r23, Z+1	; 0x01
    601a:	82 81       	ldd	r24, Z+2	; 0x02
    601c:	93 81       	ldd	r25, Z+3	; 0x03
    601e:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <__divsf3>
    6022:	4b 01       	movw	r8, r22
    6024:	5c 01       	movw	r10, r24
    6026:	e8 94       	clt
    6028:	b7 f8       	bld	r11, 7
    602a:	27 2d       	mov	r18, r7
    602c:	3c 2d       	mov	r19, r12
    602e:	4d 2d       	mov	r20, r13
    6030:	56 2d       	mov	r21, r6
    6032:	c5 01       	movw	r24, r10
    6034:	b4 01       	movw	r22, r8
    6036:	0e 94 a3 41 	call	0x8346	; 0x8346 <__gesf2>
    603a:	18 16       	cp	r1, r24
    603c:	24 f0       	brlt	.+8      	; 0x6046 <limit_value_by_axis_maximum+0x98>
    603e:	78 2c       	mov	r7, r8
    6040:	c9 2c       	mov	r12, r9
    6042:	da 2c       	mov	r13, r10
    6044:	6b 2c       	mov	r6, r11
    6046:	0c 5f       	subi	r16, 0xFC	; 252
    6048:	1f 4f       	sbci	r17, 0xFF	; 255

float limit_value_by_axis_maximum(float *max_value, float *unit_vec)
{
  uint8_t idx;
  float limit_value = SOME_LARGE_VALUE;
  for (idx=0; idx<N_AXIS; idx++) {
    604a:	ce 15       	cp	r28, r14
    604c:	df 05       	cpc	r29, r15
    604e:	99 f6       	brne	.-90     	; 0x5ff6 <limit_value_by_axis_maximum+0x48>
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
      limit_value = min(limit_value,fabs(max_value[idx]/unit_vec[idx]));
    }
  }
  return(limit_value);
}
    6050:	67 2d       	mov	r22, r7
    6052:	7c 2d       	mov	r23, r12
    6054:	8d 2d       	mov	r24, r13
    6056:	96 2d       	mov	r25, r6
    6058:	df 91       	pop	r29
    605a:	cf 91       	pop	r28
    605c:	1f 91       	pop	r17
    605e:	0f 91       	pop	r16
    6060:	ff 90       	pop	r15
    6062:	ef 90       	pop	r14
    6064:	df 90       	pop	r13
    6066:	cf 90       	pop	r12
    6068:	bf 90       	pop	r11
    606a:	af 90       	pop	r10
    606c:	9f 90       	pop	r9
    606e:	8f 90       	pop	r8
    6070:	7f 90       	pop	r7
    6072:	6f 90       	pop	r6
    6074:	08 95       	ret

00006076 <limits_disable>:
    #ifndef DISABLE_HW_LIMITS
     LIMIT_PCMSK &= ~LIMIT_MASK;  // Disable specific pins of the Pin Change Interrupt
     PCICR &= ~(1 << LIMIT_INT);  // Disable Pin Change Interrupt
    #endif
  #else
    LIMIT_PCMSK &= ~LIMIT_MASK;  // Disable specific pins of the Pin Change Interrupt
    6076:	eb e6       	ldi	r30, 0x6B	; 107
    6078:	f0 e0       	ldi	r31, 0x00	; 0
    607a:	80 81       	ld	r24, Z
    607c:	8f 78       	andi	r24, 0x8F	; 143
    607e:	80 83       	st	Z, r24
    PCICR &= ~(1 << LIMIT_INT);  // Disable Pin Change Interrupt
    6080:	e8 e6       	ldi	r30, 0x68	; 104
    6082:	f0 e0       	ldi	r31, 0x00	; 0
    6084:	80 81       	ld	r24, Z
    6086:	8e 7f       	andi	r24, 0xFE	; 254
    6088:	80 83       	st	Z, r24
    608a:	08 95       	ret

0000608c <limits_init>:
        WDTCSR |= (1<<WDCE) | (1<<WDE);
        WDTCSR = (1<<WDP0); // Set time-out at ~32msec.
      #endif
    #endif // DISABLE_HW_LIMITS
  #else
    LIMIT_DDR &= ~(LIMIT_MASK); // Set as input pins
    608c:	84 b1       	in	r24, 0x04	; 4
    608e:	8f 78       	andi	r24, 0x8F	; 143
    6090:	84 b9       	out	0x04, r24	; 4

    #ifdef DISABLE_LIMIT_PIN_PULL_UP
      LIMIT_PORT &= ~(LIMIT_MASK); // Normal low operation. Requires external pull-down.
    #else
      LIMIT_PORT |= (LIMIT_MASK);  // Enable internal pull-up resistors. Normal high operation.
    6092:	85 b1       	in	r24, 0x05	; 5
    6094:	80 67       	ori	r24, 0x70	; 112
    6096:	85 b9       	out	0x05, r24	; 5
    #endif

    if (bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE)) {
    6098:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    609c:	83 ff       	sbrs	r24, 3
    609e:	0b c0       	rjmp	.+22     	; 0x60b6 <limits_init+0x2a>
      LIMIT_PCMSK |= LIMIT_MASK; // Enable specific pins of the Pin Change Interrupt
    60a0:	eb e6       	ldi	r30, 0x6B	; 107
    60a2:	f0 e0       	ldi	r31, 0x00	; 0
    60a4:	80 81       	ld	r24, Z
    60a6:	80 67       	ori	r24, 0x70	; 112
    60a8:	80 83       	st	Z, r24
      PCICR |= (1 << LIMIT_INT); // Enable Pin Change Interrupt
    60aa:	e8 e6       	ldi	r30, 0x68	; 104
    60ac:	f0 e0       	ldi	r31, 0x00	; 0
    60ae:	80 81       	ld	r24, Z
    60b0:	81 60       	ori	r24, 0x01	; 1
    60b2:	80 83       	st	Z, r24
    60b4:	01 c0       	rjmp	.+2      	; 0x60b8 <limits_init+0x2c>
    } else {
      limits_disable();
    60b6:	df df       	rcall	.-66     	; 0x6076 <limits_disable>
    }
  
    #ifdef ENABLE_SOFTWARE_DEBOUNCE
      MCUSR &= ~(1<<WDRF);
    60b8:	84 b7       	in	r24, 0x34	; 52
    60ba:	87 7f       	andi	r24, 0xF7	; 247
    60bc:	84 bf       	out	0x34, r24	; 52
      WDTCSR |= (1<<WDCE) | (1<<WDE);
    60be:	e0 e6       	ldi	r30, 0x60	; 96
    60c0:	f0 e0       	ldi	r31, 0x00	; 0
    60c2:	80 81       	ld	r24, Z
    60c4:	88 61       	ori	r24, 0x18	; 24
    60c6:	80 83       	st	Z, r24
      WDTCSR = (1<<WDP0); // Set time-out at ~32msec.
    60c8:	81 e0       	ldi	r24, 0x01	; 1
    60ca:	80 83       	st	Z, r24
    60cc:	08 95       	ret

000060ce <limits_get_state>:

// Returns limit state as a bit-wise uint8 variable. Each bit indicates an axis limit, where 
// triggered is 1 and not triggered is 0. Invert mask is applied. Axes are defined by their
// number in bit position, i.e. Z_AXIS is (1<<2) or bit 2, and Y_AXIS is (1<<1) or bit 1.
uint8_t limits_get_state()
{
    60ce:	ef 92       	push	r14
    60d0:	ff 92       	push	r15
    60d2:	0f 93       	push	r16
    60d4:	1f 93       	push	r17
    60d6:	cf 93       	push	r28
    60d8:	df 93       	push	r29
      if (pin)
        limit_state |= (1 << idx);
    } 
    //return(limit_state);
  #else
    uint8_t pin = (LIMIT_PIN & LIMIT_MASK);
    60da:	c3 b1       	in	r28, 0x03	; 3
    60dc:	c0 77       	andi	r28, 0x70	; 112
    #ifdef INVERT_LIMIT_PIN_MASK
      pin ^= INVERT_LIMIT_PIN_MASK;
    #endif
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
    60de:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    60e2:	86 fd       	sbrc	r24, 6
    60e4:	2b c0       	rjmp	.+86     	; 0x613c <limits_get_state+0x6e>
    60e6:	80 e7       	ldi	r24, 0x70	; 112
    60e8:	c8 27       	eor	r28, r24
    60ea:	28 c0       	rjmp	.+80     	; 0x613c <limits_get_state+0x6e>
    if (pin) {  
    60ec:	00 e0       	ldi	r16, 0x00	; 0
    60ee:	10 e0       	ldi	r17, 0x00	; 0
    60f0:	d0 e0       	ldi	r29, 0x00	; 0
      uint8_t idx;
      for (idx=0; idx<N_AXIS; idx++) {
        if (pin & get_limit_pin_mask(idx)) { limit_state |= (1 << idx); }
    60f2:	ee 24       	eor	r14, r14
    60f4:	e3 94       	inc	r14
    60f6:	f1 2c       	mov	r15, r1
    60f8:	80 2f       	mov	r24, r16
    60fa:	0e 94 e7 27 	call	0x4fce	; 0x4fce <get_limit_pin_mask>
    60fe:	8c 23       	and	r24, r28
    6100:	41 f0       	breq	.+16     	; 0x6112 <limits_get_state+0x44>
    6102:	c7 01       	movw	r24, r14
    6104:	00 2e       	mov	r0, r16
    6106:	02 c0       	rjmp	.+4      	; 0x610c <limits_get_state+0x3e>
    6108:	88 0f       	add	r24, r24
    610a:	99 1f       	adc	r25, r25
    610c:	0a 94       	dec	r0
    610e:	e2 f7       	brpl	.-8      	; 0x6108 <limits_get_state+0x3a>
    6110:	d8 2b       	or	r29, r24
    6112:	0f 5f       	subi	r16, 0xFF	; 255
    6114:	1f 4f       	sbci	r17, 0xFF	; 255
      pin ^= INVERT_LIMIT_PIN_MASK;
    #endif
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
    if (pin) {  
      uint8_t idx;
      for (idx=0; idx<N_AXIS; idx++) {
    6116:	03 30       	cpi	r16, 0x03	; 3
    6118:	11 05       	cpc	r17, r1
    611a:	71 f7       	brne	.-36     	; 0x60f8 <limits_get_state+0x2a>
    }
    //return(limit_state);
  #endif //DEFAULTS_RAMPS_BOARD
//Ignore Hardware Limit triggers on the Y-Axis (Spindle Index Pulse) when LATHE is defined and not Homing, signal index pulse received when not homing
  #ifdef LATHE
	if (sys.state!=STATE_HOMING) {						//when not homing
    611c:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    6120:	84 30       	cpi	r24, 0x04	; 4
    6122:	81 f0       	breq	.+32     	; 0x6144 <limits_get_state+0x76>
	  limit_state &= ~(1<<Y_AXIS);						//Clear state to avoid limit triggered alarm
    6124:	dd 7f       	andi	r29, 0xFD	; 253
      if (pin & get_limit_pin_mask(Y_AXIS))				//If the limit input is set
    6126:	81 e0       	ldi	r24, 0x01	; 1
    6128:	0e 94 e7 27 	call	0x4fce	; 0x4fce <get_limit_pin_mask>
    612c:	8c 23       	and	r24, r28
    612e:	51 f0       	breq	.+20     	; 0x6144 <limits_get_state+0x76>
	    bit_true(sys_sync_state, EXEC_SPINDLE_INDEX);	//Signal the receive of a spindle index pulse
    6130:	80 91 14 0c 	lds	r24, 0x0C14	; 0x800c14 <sys_sync_state>
    6134:	81 60       	ori	r24, 0x01	; 1
    6136:	80 93 14 0c 	sts	0x0C14, r24	; 0x800c14 <sys_sync_state>
	}
  #endif
  return(limit_state);
    613a:	04 c0       	rjmp	.+8      	; 0x6144 <limits_get_state+0x76>
    uint8_t pin = (LIMIT_PIN & LIMIT_MASK);
    #ifdef INVERT_LIMIT_PIN_MASK
      pin ^= INVERT_LIMIT_PIN_MASK;
    #endif
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
    if (pin) {  
    613c:	c1 11       	cpse	r28, r1
    613e:	d6 cf       	rjmp	.-84     	; 0x60ec <limits_get_state+0x1e>
// Returns limit state as a bit-wise uint8 variable. Each bit indicates an axis limit, where 
// triggered is 1 and not triggered is 0. Invert mask is applied. Axes are defined by their
// number in bit position, i.e. Z_AXIS is (1<<2) or bit 2, and Y_AXIS is (1<<1) or bit 1.
uint8_t limits_get_state()
{
  uint8_t limit_state = 0;
    6140:	d0 e0       	ldi	r29, 0x00	; 0
    6142:	ec cf       	rjmp	.-40     	; 0x611c <limits_get_state+0x4e>
      if (pin & get_limit_pin_mask(Y_AXIS))				//If the limit input is set
	    bit_true(sys_sync_state, EXEC_SPINDLE_INDEX);	//Signal the receive of a spindle index pulse
	}
  #endif
  return(limit_state);
}
    6144:	8d 2f       	mov	r24, r29
    6146:	df 91       	pop	r29
    6148:	cf 91       	pop	r28
    614a:	1f 91       	pop	r17
    614c:	0f 91       	pop	r16
    614e:	ff 90       	pop	r15
    6150:	ef 90       	pop	r14
    6152:	08 95       	ret

00006154 <__vector_9>:
        }
      }
    }  
  #else // OPTIONAL: Software debounce limit pin routine.
    // Upon limit pin change, enable watchdog timer to create a short delay. 
    ISR(LIMIT_INT_vect) { if (!(WDTCSR & (1<<WDIE))) { WDTCSR |= (1<<WDIE); } }
    6154:	1f 92       	push	r1
    6156:	0f 92       	push	r0
    6158:	0f b6       	in	r0, 0x3f	; 63
    615a:	0f 92       	push	r0
    615c:	11 24       	eor	r1, r1
    615e:	0b b6       	in	r0, 0x3b	; 59
    6160:	0f 92       	push	r0
    6162:	8f 93       	push	r24
    6164:	ef 93       	push	r30
    6166:	ff 93       	push	r31
    6168:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    616c:	86 fd       	sbrc	r24, 6
    616e:	05 c0       	rjmp	.+10     	; 0x617a <__vector_9+0x26>
    6170:	e0 e6       	ldi	r30, 0x60	; 96
    6172:	f0 e0       	ldi	r31, 0x00	; 0
    6174:	80 81       	ld	r24, Z
    6176:	80 64       	ori	r24, 0x40	; 64
    6178:	80 83       	st	Z, r24
    617a:	ff 91       	pop	r31
    617c:	ef 91       	pop	r30
    617e:	8f 91       	pop	r24
    6180:	0f 90       	pop	r0
    6182:	0b be       	out	0x3b, r0	; 59
    6184:	0f 90       	pop	r0
    6186:	0f be       	out	0x3f, r0	; 63
    6188:	0f 90       	pop	r0
    618a:	1f 90       	pop	r1
    618c:	18 95       	reti

0000618e <__vector_12>:
    ISR(WDT_vect) // Watchdog timer ISR
    {
    618e:	1f 92       	push	r1
    6190:	0f 92       	push	r0
    6192:	0f b6       	in	r0, 0x3f	; 63
    6194:	0f 92       	push	r0
    6196:	11 24       	eor	r1, r1
    6198:	0b b6       	in	r0, 0x3b	; 59
    619a:	0f 92       	push	r0
    619c:	2f 93       	push	r18
    619e:	3f 93       	push	r19
    61a0:	4f 93       	push	r20
    61a2:	5f 93       	push	r21
    61a4:	6f 93       	push	r22
    61a6:	7f 93       	push	r23
    61a8:	8f 93       	push	r24
    61aa:	9f 93       	push	r25
    61ac:	af 93       	push	r26
    61ae:	bf 93       	push	r27
    61b0:	ef 93       	push	r30
    61b2:	ff 93       	push	r31
      WDTCSR &= ~(1<<WDIE); // Disable watchdog timer. 
    61b4:	e0 e6       	ldi	r30, 0x60	; 96
    61b6:	f0 e0       	ldi	r31, 0x00	; 0
    61b8:	80 81       	ld	r24, Z
    61ba:	8f 7b       	andi	r24, 0xBF	; 191
    61bc:	80 83       	st	Z, r24
      if (sys.state != STATE_ALARM) {  // Ignore if already in alarm state. 
    61be:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    61c2:	81 30       	cpi	r24, 0x01	; 1
    61c4:	61 f0       	breq	.+24     	; 0x61de <__vector_12+0x50>
        if (!(sys_rt_exec_alarm)) {
    61c6:	80 91 53 0c 	lds	r24, 0x0C53	; 0x800c53 <sys_rt_exec_alarm>
    61ca:	81 11       	cpse	r24, r1
    61cc:	08 c0       	rjmp	.+16     	; 0x61de <__vector_12+0x50>
          // Check limit pin state. 
          if (limits_get_state()) {
    61ce:	7f df       	rcall	.-258    	; 0x60ce <limits_get_state>
    61d0:	88 23       	and	r24, r24
    61d2:	29 f0       	breq	.+10     	; 0x61de <__vector_12+0x50>
            mc_reset(); // Initiate system kill.
    61d4:	0e 94 2f 07 	call	0xe5e	; 0xe5e <mc_reset>
            system_set_exec_alarm(EXEC_ALARM_HARD_LIMIT); // Indicate hard limit critical event
    61d8:	81 e0       	ldi	r24, 0x01	; 1
    61da:	0e 94 38 3e 	call	0x7c70	; 0x7c70 <system_set_exec_alarm>
          }
        }  
      }
    }
    61de:	ff 91       	pop	r31
    61e0:	ef 91       	pop	r30
    61e2:	bf 91       	pop	r27
    61e4:	af 91       	pop	r26
    61e6:	9f 91       	pop	r25
    61e8:	8f 91       	pop	r24
    61ea:	7f 91       	pop	r23
    61ec:	6f 91       	pop	r22
    61ee:	5f 91       	pop	r21
    61f0:	4f 91       	pop	r20
    61f2:	3f 91       	pop	r19
    61f4:	2f 91       	pop	r18
    61f6:	0f 90       	pop	r0
    61f8:	0b be       	out	0x3b, r0	; 59
    61fa:	0f 90       	pop	r0
    61fc:	0f be       	out	0x3f, r0	; 63
    61fe:	0f 90       	pop	r0
    6200:	1f 90       	pop	r1
    6202:	18 95       	reti

00006204 <limits_go_home>:
// mask, which prevents the stepper algorithm from executing step pulses. Homing motions typically
// circumvent the processes for executing motions in normal operation.
// NOTE: Only the abort realtime command can interrupt this process.
// TODO: Move limit pin-specific calls to a general function for portability.
void limits_go_home(uint8_t cycle_mask)
{
    6204:	2f 92       	push	r2
    6206:	3f 92       	push	r3
    6208:	4f 92       	push	r4
    620a:	5f 92       	push	r5
    620c:	6f 92       	push	r6
    620e:	7f 92       	push	r7
    6210:	8f 92       	push	r8
    6212:	9f 92       	push	r9
    6214:	af 92       	push	r10
    6216:	bf 92       	push	r11
    6218:	cf 92       	push	r12
    621a:	df 92       	push	r13
    621c:	ef 92       	push	r14
    621e:	ff 92       	push	r15
    6220:	0f 93       	push	r16
    6222:	1f 93       	push	r17
    6224:	cf 93       	push	r28
    6226:	df 93       	push	r29
    6228:	cd b7       	in	r28, 0x3d	; 61
    622a:	de b7       	in	r29, 0x3e	; 62
    622c:	a9 97       	sbiw	r28, 0x29	; 41
    622e:	0f b6       	in	r0, 0x3f	; 63
    6230:	f8 94       	cli
    6232:	de bf       	out	0x3e, r29	; 62
    6234:	0f be       	out	0x3f, r0	; 63
    6236:	cd bf       	out	0x3d, r28	; 61
  if (sys.abort) { return; } // Block if system reset has been issued.
    6238:	90 91 1f 0c 	lds	r25, 0x0C1F	; 0x800c1f <sys+0x1>
    623c:	91 11       	cpse	r25, r1
    623e:	e1 c1       	rjmp	.+962    	; 0x6602 <limits_go_home+0x3fe>
    6240:	8f a3       	std	Y+39, r24	; 0x27

  // Initialize plan data struct for homing motion. Spindle and coolant are disabled.
  plan_line_data_t plan_data;
  plan_line_data_t *pl_data = &plan_data;
  memset(pl_data,0,sizeof(plan_line_data_t));
    6242:	fe 01       	movw	r30, r28
    6244:	31 96       	adiw	r30, 0x01	; 1
    6246:	8d e0       	ldi	r24, 0x0D	; 13
    6248:	df 01       	movw	r26, r30
    624a:	1d 92       	st	X+, r1
    624c:	8a 95       	dec	r24
    624e:	e9 f7       	brne	.-6      	; 0x624a <limits_go_home+0x46>
  pl_data->condition = (PL_COND_FLAG_SYSTEM_MOTION|PL_COND_FLAG_NO_FEED_OVERRIDE);
    6250:	86 e0       	ldi	r24, 0x06	; 6
    6252:	8d 87       	std	Y+13, r24	; 0x0d
    6254:	e0 ed       	ldi	r30, 0xD0	; 208
    6256:	fe e0       	ldi	r31, 0x0E	; 14
    6258:	fc a3       	std	Y+36, r31	; 0x24
    625a:	eb a3       	std	Y+35, r30	; 0x23
    625c:	7f 01       	movw	r14, r30
    625e:	9e 01       	movw	r18, r28
    6260:	22 5f       	subi	r18, 0xF2	; 242
    6262:	3f 4f       	sbci	r19, 0xFF	; 255
    6264:	59 01       	movw	r10, r18
    6266:	00 e0       	ldi	r16, 0x00	; 0
    6268:	10 e0       	ldi	r17, 0x00	; 0

  // Initialize variables used for homing computations.
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  uint8_t step_pin[N_AXIS];
  float target[N_AXIS];
  float max_travel = 0.0;
    626a:	41 2c       	mov	r4, r1
    626c:	51 2c       	mov	r5, r1
    626e:	32 01       	movw	r6, r4
    step_pin[idx] = get_step_pin_mask(idx);
    #ifdef COREXY
      if ((idx==A_MOTOR)||(idx==B_MOTOR)) { step_pin[idx] = (get_step_pin_mask(X_AXIS)|get_step_pin_mask(Y_AXIS)); }
    #endif

    if (bit_istrue(cycle_mask,bit(idx))) {
    6270:	3f a1       	ldd	r19, Y+39	; 0x27
    6272:	c3 2e       	mov	r12, r19
    6274:	d1 2c       	mov	r13, r1
  float target[N_AXIS];
  float max_travel = 0.0;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    // Initialize step pin masks
    step_pin[idx] = get_step_pin_mask(idx);
    6276:	80 2f       	mov	r24, r16
    6278:	0e 94 d3 27 	call	0x4fa6	; 0x4fa6 <get_step_pin_mask>
    627c:	d5 01       	movw	r26, r10
    627e:	8d 93       	st	X+, r24
    6280:	5d 01       	movw	r10, r26
    #ifdef COREXY
      if ((idx==A_MOTOR)||(idx==B_MOTOR)) { step_pin[idx] = (get_step_pin_mask(X_AXIS)|get_step_pin_mask(Y_AXIS)); }
    #endif

    if (bit_istrue(cycle_mask,bit(idx))) {
    6282:	de 8e       	std	Y+30, r13	; 0x1e
    6284:	cd 8e       	std	Y+29, r12	; 0x1d
    6286:	c6 01       	movw	r24, r12
    6288:	00 2e       	mov	r0, r16
    628a:	02 c0       	rjmp	.+4      	; 0x6290 <limits_go_home+0x8c>
    628c:	95 95       	asr	r25
    628e:	87 95       	ror	r24
    6290:	0a 94       	dec	r0
    6292:	e2 f7       	brpl	.-8      	; 0x628c <limits_go_home+0x88>
    6294:	80 ff       	sbrs	r24, 0
    6296:	19 c0       	rjmp	.+50     	; 0x62ca <limits_go_home+0xc6>
      // Set target based on max_travel setting. Ensure homing switches engaged with search scalar.
      // NOTE: settings.max_travel[] is stored as a negative value.
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    6298:	20 e0       	ldi	r18, 0x00	; 0
    629a:	30 e0       	ldi	r19, 0x00	; 0
    629c:	40 ec       	ldi	r20, 0xC0	; 192
    629e:	5f eb       	ldi	r21, 0xBF	; 191
    62a0:	f7 01       	movw	r30, r14
    62a2:	64 a1       	ldd	r22, Z+36	; 0x24
    62a4:	75 a1       	ldd	r23, Z+37	; 0x25
    62a6:	86 a1       	ldd	r24, Z+38	; 0x26
    62a8:	97 a1       	ldd	r25, Z+39	; 0x27
    62aa:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    62ae:	86 2e       	mov	r8, r22
    62b0:	97 2e       	mov	r9, r23
    62b2:	28 2e       	mov	r2, r24
    62b4:	39 2e       	mov	r3, r25
    62b6:	a3 01       	movw	r20, r6
    62b8:	92 01       	movw	r18, r4
    62ba:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    62be:	88 23       	and	r24, r24
    62c0:	24 f0       	brlt	.+8      	; 0x62ca <limits_go_home+0xc6>
    62c2:	48 2c       	mov	r4, r8
    62c4:	59 2c       	mov	r5, r9
    62c6:	62 2c       	mov	r6, r2
    62c8:	73 2c       	mov	r7, r3
    62ca:	0f 5f       	subi	r16, 0xFF	; 255
    62cc:	1f 4f       	sbci	r17, 0xFF	; 255
    62ce:	f4 e0       	ldi	r31, 0x04	; 4
    62d0:	ef 0e       	add	r14, r31
    62d2:	f1 1c       	adc	r15, r1
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  uint8_t step_pin[N_AXIS];
  float target[N_AXIS];
  float max_travel = 0.0;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    62d4:	03 30       	cpi	r16, 0x03	; 3
    62d6:	11 05       	cpc	r17, r1
    62d8:	71 f6       	brne	.-100    	; 0x6276 <limits_go_home+0x72>
    62da:	2d 8c       	ldd	r2, Y+29	; 0x1d
    62dc:	3e 8c       	ldd	r3, Y+30	; 0x1e
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    }
  }
  // Set search mode with approach at seek rate to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
  float homing_rate = settings.homing_seek_rate;
    62de:	80 91 1b 0f 	lds	r24, 0x0F1B	; 0x800f1b <settings+0x4b>
    62e2:	90 91 1c 0f 	lds	r25, 0x0F1C	; 0x800f1c <settings+0x4c>
    62e6:	a0 91 1d 0f 	lds	r26, 0x0F1D	; 0x800f1d <settings+0x4d>
    62ea:	b0 91 1e 0f 	lds	r27, 0x0F1E	; 0x800f1e <settings+0x4e>
    62ee:	8f 8f       	std	Y+31, r24	; 0x1f
    62f0:	98 a3       	std	Y+32, r25	; 0x20
    62f2:	a9 a3       	std	Y+33, r26	; 0x21
    62f4:	ba a3       	std	Y+34, r27	; 0x22
    62f6:	94 e0       	ldi	r25, 0x04	; 4
    62f8:	9d 8f       	std	Y+29, r25	; 0x1d
      // NOTE: settings.max_travel[] is stored as a negative value.
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    }
  }
  // Set search mode with approach at seek rate to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
    62fa:	01 e0       	ldi	r16, 0x01	; 1
          axislock |= step_pin[idx];
        }

      }
      homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
      sys.homing_axis_lock = axislock;
    62fc:	0f 2e       	mov	r0, r31
    62fe:	fe e1       	ldi	r31, 0x1E	; 30
    6300:	cf 2e       	mov	r12, r31
    6302:	fc e0       	ldi	r31, 0x0C	; 12
    6304:	df 2e       	mov	r13, r31
    6306:	f0 2d       	mov	r31, r0
    } while (n_cycle-- > 0);
  #else
    uint8_t limit_state, axislock, n_active_axis;
    do {

      system_convert_array_steps_to_mpos(target,sys_position);
    6308:	63 e4       	ldi	r22, 0x43	; 67
    630a:	7c e0       	ldi	r23, 0x0C	; 12
    630c:	ce 01       	movw	r24, r28
    630e:	41 96       	adiw	r24, 0x11	; 17
    6310:	0e 94 51 3b 	call	0x76a2	; 0x76a2 <system_convert_array_steps_to_mpos>
          #else
            sys_position[idx] = 0;
          #endif
          // Set target direction based on cycle mask and homing cycle approach state.
          // NOTE: This happens to compile smaller than any other implementation tried.
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
    6314:	a6 e1       	ldi	r26, 0x16	; 22
    6316:	bf e0       	ldi	r27, 0x0F	; 15
    6318:	ec 90       	ld	r14, X
    631a:	f1 2c       	mov	r15, r1
    631c:	ae 01       	movw	r20, r28
    631e:	4f 5e       	subi	r20, 0xEF	; 239
    6320:	5f 4f       	sbci	r21, 0xFF	; 255
    6322:	e3 e4       	ldi	r30, 0x43	; 67
    6324:	fc e0       	ldi	r31, 0x0C	; 12
    6326:	fe a3       	std	Y+38, r31	; 0x26
    6328:	ed a3       	std	Y+37, r30	; 0x25
    632a:	de 01       	movw	r26, r28
    632c:	1e 96       	adiw	r26, 0x0e	; 14
    632e:	80 e0       	ldi	r24, 0x00	; 0
    6330:	90 e0       	ldi	r25, 0x00	; 0

      system_convert_array_steps_to_mpos(target,sys_position);

      // Initialize and declare variables needed for homing routine.
      axislock = 0;
      n_active_axis = 0;
    6332:	60 e0       	ldi	r22, 0x00	; 0
    do {

      system_convert_array_steps_to_mpos(target,sys_position);

      // Initialize and declare variables needed for homing routine.
      axislock = 0;
    6334:	10 e0       	ldi	r17, 0x00	; 0
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
            if (approach) { target[idx] = -max_travel; }
            else { target[idx] = max_travel; }
          } else {
            if (approach) { target[idx] = max_travel; }
            else { target[idx] = -max_travel; }
    6336:	53 01       	movw	r10, r6
    6338:	42 01       	movw	r8, r4
    633a:	b7 fa       	bst	r11, 7
    633c:	b0 94       	com	r11
    633e:	b7 f8       	bld	r11, 7
    6340:	b0 94       	com	r11
    6342:	b9 a7       	std	Y+41, r27	; 0x29
    6344:	a8 a7       	std	Y+40, r26	; 0x28
      // Initialize and declare variables needed for homing routine.
      axislock = 0;
      n_active_axis = 0;
      for (idx=0; idx<N_AXIS; idx++) {
        // Set target location for active axes and setup computation for homing rate.
        if (bit_istrue(cycle_mask,bit(idx))) {
    6346:	91 01       	movw	r18, r2
    6348:	08 2e       	mov	r0, r24
    634a:	02 c0       	rjmp	.+4      	; 0x6350 <limits_go_home+0x14c>
    634c:	35 95       	asr	r19
    634e:	27 95       	ror	r18
    6350:	0a 94       	dec	r0
    6352:	e2 f7       	brpl	.-8      	; 0x634c <limits_go_home+0x148>
    6354:	20 ff       	sbrs	r18, 0
    6356:	31 c0       	rjmp	.+98     	; 0x63ba <limits_go_home+0x1b6>
          n_active_axis++;
    6358:	6f 5f       	subi	r22, 0xFF	; 255
              sys_position[A_MOTOR] = sys_position[B_MOTOR] = axis_position;
            } else {
              sys_position[Z_AXIS] = 0;
            }
          #else
            sys_position[idx] = 0;
    635a:	10 82       	st	Z, r1
    635c:	11 82       	std	Z+1, r1	; 0x01
    635e:	12 82       	std	Z+2, r1	; 0x02
    6360:	13 82       	std	Z+3, r1	; 0x03
          #endif
          // Set target direction based on cycle mask and homing cycle approach state.
          // NOTE: This happens to compile smaller than any other implementation tried.
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
    6362:	97 01       	movw	r18, r14
    6364:	08 2e       	mov	r0, r24
    6366:	02 c0       	rjmp	.+4      	; 0x636c <limits_go_home+0x168>
    6368:	35 95       	asr	r19
    636a:	27 95       	ror	r18
    636c:	0a 94       	dec	r0
    636e:	e2 f7       	brpl	.-8      	; 0x6368 <limits_go_home+0x164>
    6370:	20 ff       	sbrs	r18, 0
    6372:	10 c0       	rjmp	.+32     	; 0x6394 <limits_go_home+0x190>
            if (approach) { target[idx] = -max_travel; }
    6374:	00 23       	and	r16, r16
    6376:	39 f0       	breq	.+14     	; 0x6386 <limits_go_home+0x182>
    6378:	da 01       	movw	r26, r20
    637a:	8d 92       	st	X+, r8
    637c:	9d 92       	st	X+, r9
    637e:	ad 92       	st	X+, r10
    6380:	bc 92       	st	X, r11
    6382:	13 97       	sbiw	r26, 0x03	; 3
    6384:	16 c0       	rjmp	.+44     	; 0x63b2 <limits_go_home+0x1ae>
            else { target[idx] = max_travel; }
    6386:	da 01       	movw	r26, r20
    6388:	4d 92       	st	X+, r4
    638a:	5d 92       	st	X+, r5
    638c:	6d 92       	st	X+, r6
    638e:	7c 92       	st	X, r7
    6390:	13 97       	sbiw	r26, 0x03	; 3
    6392:	0f c0       	rjmp	.+30     	; 0x63b2 <limits_go_home+0x1ae>
          } else {
            if (approach) { target[idx] = max_travel; }
    6394:	00 23       	and	r16, r16
    6396:	39 f0       	breq	.+14     	; 0x63a6 <limits_go_home+0x1a2>
    6398:	da 01       	movw	r26, r20
    639a:	4d 92       	st	X+, r4
    639c:	5d 92       	st	X+, r5
    639e:	6d 92       	st	X+, r6
    63a0:	7c 92       	st	X, r7
    63a2:	13 97       	sbiw	r26, 0x03	; 3
    63a4:	06 c0       	rjmp	.+12     	; 0x63b2 <limits_go_home+0x1ae>
            else { target[idx] = -max_travel; }
    63a6:	da 01       	movw	r26, r20
    63a8:	8d 92       	st	X+, r8
    63aa:	9d 92       	st	X+, r9
    63ac:	ad 92       	st	X+, r10
    63ae:	bc 92       	st	X, r11
    63b0:	13 97       	sbiw	r26, 0x03	; 3
          }
          // Apply axislock to the step port pins active in this cycle.
          axislock |= step_pin[idx];
    63b2:	a8 a5       	ldd	r26, Y+40	; 0x28
    63b4:	b9 a5       	ldd	r27, Y+41	; 0x29
    63b6:	2c 91       	ld	r18, X
    63b8:	12 2b       	or	r17, r18
    63ba:	01 96       	adiw	r24, 0x01	; 1
    63bc:	28 a5       	ldd	r18, Y+40	; 0x28
    63be:	39 a5       	ldd	r19, Y+41	; 0x29
    63c0:	2f 5f       	subi	r18, 0xFF	; 255
    63c2:	3f 4f       	sbci	r19, 0xFF	; 255
    63c4:	39 a7       	std	Y+41, r19	; 0x29
    63c6:	28 a7       	std	Y+40, r18	; 0x28
    63c8:	4c 5f       	subi	r20, 0xFC	; 252
    63ca:	5f 4f       	sbci	r21, 0xFF	; 255
    63cc:	34 96       	adiw	r30, 0x04	; 4
      system_convert_array_steps_to_mpos(target,sys_position);

      // Initialize and declare variables needed for homing routine.
      axislock = 0;
      n_active_axis = 0;
      for (idx=0; idx<N_AXIS; idx++) {
    63ce:	83 30       	cpi	r24, 0x03	; 3
    63d0:	91 05       	cpc	r25, r1
    63d2:	09 f0       	breq	.+2      	; 0x63d6 <limits_go_home+0x1d2>
    63d4:	b8 cf       	rjmp	.-144    	; 0x6346 <limits_go_home+0x142>
          // Apply axislock to the step port pins active in this cycle.
          axislock |= step_pin[idx];
        }

      }
      homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
    63d6:	46 2e       	mov	r4, r22
    63d8:	51 2c       	mov	r5, r1
    63da:	61 2c       	mov	r6, r1
    63dc:	71 2c       	mov	r7, r1
    63de:	c3 01       	movw	r24, r6
    63e0:	b2 01       	movw	r22, r4
    63e2:	0e 94 40 40 	call	0x8080	; 0x8080 <__floatunsisf>
    63e6:	0e 94 6b 42 	call	0x84d6	; 0x84d6 <sqrt>
    63ea:	9b 01       	movw	r18, r22
    63ec:	ac 01       	movw	r20, r24
      sys.homing_axis_lock = axislock;
    63ee:	d6 01       	movw	r26, r12
    63f0:	16 96       	adiw	r26, 0x06	; 6
    63f2:	1c 93       	st	X, r17

      // Perform homing cycle. Planner buffer should be empty, as required to initiate the homing cycle.
      pl_data->feed_rate = homing_rate; // Set current homing rate.
    63f4:	6f 8d       	ldd	r22, Y+31	; 0x1f
    63f6:	78 a1       	ldd	r23, Y+32	; 0x20
    63f8:	89 a1       	ldd	r24, Y+33	; 0x21
    63fa:	9a a1       	ldd	r25, Y+34	; 0x22
    63fc:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    6400:	69 83       	std	Y+1, r22	; 0x01
    6402:	7a 83       	std	Y+2, r23	; 0x02
    6404:	8b 83       	std	Y+3, r24	; 0x03
    6406:	9c 83       	std	Y+4, r25	; 0x04
      plan_buffer_line(target, pl_data); // Bypass mc_line(). Directly plan homing motion.
    6408:	be 01       	movw	r22, r28
    640a:	6f 5f       	subi	r22, 0xFF	; 255
    640c:	7f 4f       	sbci	r23, 0xFF	; 255
    640e:	ce 01       	movw	r24, r28
    6410:	41 96       	adiw	r24, 0x11	; 17
    6412:	e4 d8       	rcall	.-3640   	; 0x55dc <plan_buffer_line>

      sys.step_control = STEP_CONTROL_EXECUTE_SYS_MOTION; // Set to execute homing motion and clear existing flags.
    6414:	24 e0       	ldi	r18, 0x04	; 4
    6416:	f6 01       	movw	r30, r12
    6418:	24 83       	std	Z+4, r18	; 0x04
      st_prep_buffer(); // Prep and fill segment buffer from newly planned block.
    641a:	0e 94 4e 1c 	call	0x389c	; 0x389c <st_prep_buffer>
      st_wake_up(); // Initiate motion
    641e:	0e 94 41 19 	call	0x3282	; 0x3282 <st_wake_up>
      do {
        if (approach) {
    6422:	00 23       	and	r16, r16
    6424:	f1 f0       	breq	.+60     	; 0x6462 <limits_go_home+0x25e>
          // Check limit state. Lock out cycle axes when they change.
          limit_state = limits_get_state();
    6426:	53 de       	rcall	.-858    	; 0x60ce <limits_get_state>
    6428:	fe 01       	movw	r30, r28
    642a:	3e 96       	adiw	r30, 0x0e	; 14
    642c:	20 e0       	ldi	r18, 0x00	; 0
    642e:	30 e0       	ldi	r19, 0x00	; 0
          for (idx=0; idx<N_AXIS; idx++) {
            if (axislock & step_pin[idx]) {
              if (limit_state & (1 << idx)) {
    6430:	68 2f       	mov	r22, r24
    6432:	70 e0       	ldi	r23, 0x00	; 0
      do {
        if (approach) {
          // Check limit state. Lock out cycle axes when they change.
          limit_state = limits_get_state();
          for (idx=0; idx<N_AXIS; idx++) {
            if (axislock & step_pin[idx]) {
    6434:	81 91       	ld	r24, Z+
    6436:	98 2f       	mov	r25, r24
    6438:	91 23       	and	r25, r17
    643a:	59 f0       	breq	.+22     	; 0x6452 <limits_go_home+0x24e>
              if (limit_state & (1 << idx)) {
    643c:	ab 01       	movw	r20, r22
    643e:	02 2e       	mov	r0, r18
    6440:	02 c0       	rjmp	.+4      	; 0x6446 <limits_go_home+0x242>
    6442:	55 95       	asr	r21
    6444:	47 95       	ror	r20
    6446:	0a 94       	dec	r0
    6448:	e2 f7       	brpl	.-8      	; 0x6442 <limits_go_home+0x23e>
    644a:	40 ff       	sbrs	r20, 0
    644c:	02 c0       	rjmp	.+4      	; 0x6452 <limits_go_home+0x24e>
                #ifdef COREXY
                  if (idx==Z_AXIS) { axislock &= ~(step_pin[Z_AXIS]); }
                  else { axislock &= ~(step_pin[A_MOTOR]|step_pin[B_MOTOR]); }
                #else
                  axislock &= ~(step_pin[idx]);
    644e:	80 95       	com	r24
    6450:	18 23       	and	r17, r24
    6452:	2f 5f       	subi	r18, 0xFF	; 255
    6454:	3f 4f       	sbci	r19, 0xFF	; 255
      st_wake_up(); // Initiate motion
      do {
        if (approach) {
          // Check limit state. Lock out cycle axes when they change.
          limit_state = limits_get_state();
          for (idx=0; idx<N_AXIS; idx++) {
    6456:	23 30       	cpi	r18, 0x03	; 3
    6458:	31 05       	cpc	r19, r1
    645a:	61 f7       	brne	.-40     	; 0x6434 <limits_go_home+0x230>
                  axislock &= ~(step_pin[idx]);
                #endif
              }
            }
          }
          sys.homing_axis_lock = axislock;
    645c:	d6 01       	movw	r26, r12
    645e:	16 96       	adiw	r26, 0x06	; 6
    6460:	1c 93       	st	X, r17
        }

        st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
    6462:	0e 94 4e 1c 	call	0x389c	; 0x389c <st_prep_buffer>

        // Exit routines: No time to run protocol_execute_realtime() in this loop.
        if (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET | EXEC_CYCLE_STOP)) {
    6466:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    646a:	84 73       	andi	r24, 0x34	; 52
    646c:	31 f1       	breq	.+76     	; 0x64ba <limits_go_home+0x2b6>
          uint8_t rt_exec = sys_rt_exec_state;
    646e:	10 91 31 0c 	lds	r17, 0x0C31	; 0x800c31 <sys_rt_exec_state>
          // Homing failure condition: Reset issued during cycle.
          if (rt_exec & EXEC_RESET) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_RESET); }
    6472:	14 ff       	sbrs	r17, 4
    6474:	03 c0       	rjmp	.+6      	; 0x647c <limits_go_home+0x278>
    6476:	86 e0       	ldi	r24, 0x06	; 6
    6478:	0e 94 38 3e 	call	0x7c70	; 0x7c70 <system_set_exec_alarm>
          // Homing failure condition: Safety door was opened.
          if (rt_exec & EXEC_SAFETY_DOOR) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_DOOR); }
    647c:	15 ff       	sbrs	r17, 5
    647e:	03 c0       	rjmp	.+6      	; 0x6486 <limits_go_home+0x282>
    6480:	87 e0       	ldi	r24, 0x07	; 7
    6482:	0e 94 38 3e 	call	0x7c70	; 0x7c70 <system_set_exec_alarm>
          // Homing failure condition: Limit switch still engaged after pull-off motion
          if (!approach && (limits_get_state() & cycle_mask)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_PULLOFF); }
    6486:	01 11       	cpse	r16, r1
    6488:	b9 c0       	rjmp	.+370    	; 0x65fc <limits_go_home+0x3f8>
    648a:	21 de       	rcall	.-958    	; 0x60ce <limits_get_state>
    648c:	bf a1       	ldd	r27, Y+39	; 0x27
    648e:	8b 23       	and	r24, r27
    6490:	39 f0       	breq	.+14     	; 0x64a0 <limits_go_home+0x29c>
    6492:	88 e0       	ldi	r24, 0x08	; 8
    6494:	0e 94 38 3e 	call	0x7c70	; 0x7c70 <system_set_exec_alarm>
    6498:	03 c0       	rjmp	.+6      	; 0x64a0 <limits_go_home+0x29c>
          // Homing failure condition: Limit switch not found during approach.
          if (approach && (rt_exec & EXEC_CYCLE_STOP)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_APPROACH); }
    649a:	89 e0       	ldi	r24, 0x09	; 9
    649c:	0e 94 38 3e 	call	0x7c70	; 0x7c70 <system_set_exec_alarm>
          if (sys_rt_exec_alarm) {
    64a0:	80 91 53 0c 	lds	r24, 0x0C53	; 0x800c53 <sys_rt_exec_alarm>
    64a4:	88 23       	and	r24, r24
    64a6:	29 f0       	breq	.+10     	; 0x64b2 <limits_go_home+0x2ae>
            mc_reset(); // Stop motors, if they are running.
    64a8:	0e 94 2f 07 	call	0xe5e	; 0xe5e <mc_reset>
            protocol_execute_realtime();
    64ac:	0e 94 66 17 	call	0x2ecc	; 0x2ecc <protocol_execute_realtime>
            return;
    64b0:	a8 c0       	rjmp	.+336    	; 0x6602 <limits_go_home+0x3fe>
          } else {
            // Pull-off motion complete. Disable CYCLE_STOP from executing.
            system_clear_exec_state_flag(EXEC_CYCLE_STOP);
    64b2:	84 e0       	ldi	r24, 0x04	; 4
    64b4:	0e 94 2e 3e 	call	0x7c5c	; 0x7c5c <system_clear_exec_state_flag>
            break;
    64b8:	04 c0       	rjmp	.+8      	; 0x64c2 <limits_go_home+0x2be>
          }
        }

      } while (STEP_MASK & axislock);
    64ba:	81 2f       	mov	r24, r17
    64bc:	8c 71       	andi	r24, 0x1C	; 28
    64be:	09 f0       	breq	.+2      	; 0x64c2 <limits_go_home+0x2be>
    64c0:	b0 cf       	rjmp	.-160    	; 0x6422 <limits_go_home+0x21e>
      st_reset(); // Immediately force kill steppers and reset step segment buffer.
    64c2:	0e 94 db 1b 	call	0x37b6	; 0x37b6 <st_reset>
      delay_ms(settings.homing_debounce_delay); // Delay to allow transient dynamics to dissipate.
    64c6:	ef e1       	ldi	r30, 0x1F	; 31
    64c8:	ff e0       	ldi	r31, 0x0F	; 15
    64ca:	80 81       	ld	r24, Z
    64cc:	91 81       	ldd	r25, Z+1	; 0x01
    64ce:	ca dc       	rcall	.-1644   	; 0x5e64 <delay_ms>

      // Reverse direction and reset homing rate for locate cycle(s).
      approach = !approach;
    64d0:	f1 e0       	ldi	r31, 0x01	; 1
    64d2:	0f 27       	eor	r16, r31

      // After first cycle, homing enters locating phase. Shorten search to pull-off distance.
      if (approach) {
    64d4:	d1 f0       	breq	.+52     	; 0x650a <limits_go_home+0x306>
        max_travel = settings.homing_pulloff*HOMING_AXIS_LOCATE_SCALAR;
    64d6:	20 e0       	ldi	r18, 0x00	; 0
    64d8:	30 e0       	ldi	r19, 0x00	; 0
    64da:	40 ea       	ldi	r20, 0xA0	; 160
    64dc:	50 e4       	ldi	r21, 0x40	; 64
    64de:	a1 e2       	ldi	r26, 0x21	; 33
    64e0:	bf e0       	ldi	r27, 0x0F	; 15
    64e2:	6d 91       	ld	r22, X+
    64e4:	7d 91       	ld	r23, X+
    64e6:	8d 91       	ld	r24, X+
    64e8:	9c 91       	ld	r25, X
    64ea:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    64ee:	2b 01       	movw	r4, r22
    64f0:	3c 01       	movw	r6, r24
        homing_rate = settings.homing_feed_rate;
    64f2:	a7 e1       	ldi	r26, 0x17	; 23
    64f4:	bf e0       	ldi	r27, 0x0F	; 15
    64f6:	8d 91       	ld	r24, X+
    64f8:	9d 91       	ld	r25, X+
    64fa:	0d 90       	ld	r0, X+
    64fc:	bc 91       	ld	r27, X
    64fe:	a0 2d       	mov	r26, r0
    6500:	8f 8f       	std	Y+31, r24	; 0x1f
    6502:	98 a3       	std	Y+32, r25	; 0x20
    6504:	a9 a3       	std	Y+33, r26	; 0x21
    6506:	ba a3       	std	Y+34, r27	; 0x22
    6508:	11 c0       	rjmp	.+34     	; 0x652c <limits_go_home+0x328>
      } else {
        max_travel = settings.homing_pulloff;
    650a:	e1 e2       	ldi	r30, 0x21	; 33
    650c:	ff e0       	ldi	r31, 0x0F	; 15
    650e:	40 80       	ld	r4, Z
    6510:	51 80       	ldd	r5, Z+1	; 0x01
    6512:	62 80       	ldd	r6, Z+2	; 0x02
    6514:	73 80       	ldd	r7, Z+3	; 0x03
        homing_rate = settings.homing_seek_rate;
    6516:	ab e1       	ldi	r26, 0x1B	; 27
    6518:	bf e0       	ldi	r27, 0x0F	; 15
    651a:	8d 91       	ld	r24, X+
    651c:	9d 91       	ld	r25, X+
    651e:	0d 90       	ld	r0, X+
    6520:	bc 91       	ld	r27, X
    6522:	a0 2d       	mov	r26, r0
    6524:	8f 8f       	std	Y+31, r24	; 0x1f
    6526:	98 a3       	std	Y+32, r25	; 0x20
    6528:	a9 a3       	std	Y+33, r26	; 0x21
    652a:	ba a3       	std	Y+34, r27	; 0x22
    652c:	bd 8d       	ldd	r27, Y+29	; 0x1d
    652e:	b1 50       	subi	r27, 0x01	; 1
    6530:	bd 8f       	std	Y+29, r27	; 0x1d
      }
    } while (n_cycle-- > 0);
    6532:	b1 11       	cpse	r27, r1
    6534:	e9 ce       	rjmp	.-558    	; 0x6308 <limits_go_home+0x104>
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
      #ifdef HOMING_FORCE_SET_ORIGIN
        set_axis_position = 0;
      #else
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    6536:	e0 90 16 0f 	lds	r14, 0x0F16	; 0x800f16 <settings+0x46>
    653a:	f1 2c       	mov	r15, r1
          set_axis_position = lround((settings.max_travel[idx]+settings.homing_pulloff)*settings.steps_per_mm[idx]);
    653c:	80 90 21 0f 	lds	r8, 0x0F21	; 0x800f21 <settings+0x51>
    6540:	90 90 22 0f 	lds	r9, 0x0F22	; 0x800f22 <settings+0x52>
    6544:	a0 90 23 0f 	lds	r10, 0x0F23	; 0x800f23 <settings+0x53>
    6548:	b0 90 24 0f 	lds	r11, 0x0F24	; 0x800f24 <settings+0x54>
        } else {
          set_axis_position = lround(-settings.homing_pulloff*settings.steps_per_mm[idx]);
    654c:	24 01       	movw	r4, r8
    654e:	35 01       	movw	r6, r10
    6550:	77 fa       	bst	r7, 7
    6552:	70 94       	com	r7
    6554:	77 f8       	bld	r7, 7
    6556:	70 94       	com	r7
    6558:	00 e0       	ldi	r16, 0x00	; 0
    655a:	10 e0       	ldi	r17, 0x00	; 0
    655c:	cd a0       	ldd	r12, Y+37	; 0x25
    655e:	de a0       	ldd	r13, Y+38	; 0x26
  // triggering when hard limits are enabled or when more than one axes shares a limit pin.
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
    6560:	c1 01       	movw	r24, r2
    6562:	00 2e       	mov	r0, r16
    6564:	02 c0       	rjmp	.+4      	; 0x656a <limits_go_home+0x366>
    6566:	95 95       	asr	r25
    6568:	87 95       	ror	r24
    656a:	0a 94       	dec	r0
    656c:	e2 f7       	brpl	.-8      	; 0x6566 <limits_go_home+0x362>
    656e:	80 ff       	sbrs	r24, 0
    6570:	34 c0       	rjmp	.+104    	; 0x65da <limits_go_home+0x3d6>
      #ifdef HOMING_FORCE_SET_ORIGIN
        set_axis_position = 0;
      #else
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    6572:	c7 01       	movw	r24, r14
    6574:	00 2e       	mov	r0, r16
    6576:	02 c0       	rjmp	.+4      	; 0x657c <limits_go_home+0x378>
    6578:	95 95       	asr	r25
    657a:	87 95       	ror	r24
    657c:	0a 94       	dec	r0
    657e:	e2 f7       	brpl	.-8      	; 0x6578 <limits_go_home+0x374>
    6580:	80 ff       	sbrs	r24, 0
    6582:	15 c0       	rjmp	.+42     	; 0x65ae <limits_go_home+0x3aa>
          set_axis_position = lround((settings.max_travel[idx]+settings.homing_pulloff)*settings.steps_per_mm[idx]);
    6584:	eb a1       	ldd	r30, Y+35	; 0x23
    6586:	fc a1       	ldd	r31, Y+36	; 0x24
    6588:	24 a1       	ldd	r18, Z+36	; 0x24
    658a:	35 a1       	ldd	r19, Z+37	; 0x25
    658c:	46 a1       	ldd	r20, Z+38	; 0x26
    658e:	57 a1       	ldd	r21, Z+39	; 0x27
    6590:	c5 01       	movw	r24, r10
    6592:	b4 01       	movw	r22, r8
    6594:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    6598:	ab a1       	ldd	r26, Y+35	; 0x23
    659a:	bc a1       	ldd	r27, Y+36	; 0x24
    659c:	2d 91       	ld	r18, X+
    659e:	3d 91       	ld	r19, X+
    65a0:	4d 91       	ld	r20, X+
    65a2:	5c 91       	ld	r21, X
    65a4:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    65a8:	0e 94 ae 41 	call	0x835c	; 0x835c <lround>
    65ac:	0c c0       	rjmp	.+24     	; 0x65c6 <limits_go_home+0x3c2>
        } else {
          set_axis_position = lround(-settings.homing_pulloff*settings.steps_per_mm[idx]);
    65ae:	eb a1       	ldd	r30, Y+35	; 0x23
    65b0:	fc a1       	ldd	r31, Y+36	; 0x24
    65b2:	20 81       	ld	r18, Z
    65b4:	31 81       	ldd	r19, Z+1	; 0x01
    65b6:	42 81       	ldd	r20, Z+2	; 0x02
    65b8:	53 81       	ldd	r21, Z+3	; 0x03
    65ba:	c3 01       	movw	r24, r6
    65bc:	b2 01       	movw	r22, r4
    65be:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    65c2:	0e 94 ae 41 	call	0x835c	; 0x835c <lround>
          sys_position[B_MOTOR] = off_axis_position - set_axis_position;
        } else {
          sys_position[idx] = set_axis_position;
        }
      #else
        sys_position[idx] = set_axis_position;
    65c6:	d6 01       	movw	r26, r12
    65c8:	6c 93       	st	X, r22
    65ca:	11 96       	adiw	r26, 0x01	; 1
    65cc:	7c 93       	st	X, r23
    65ce:	11 97       	sbiw	r26, 0x01	; 1
    65d0:	12 96       	adiw	r26, 0x02	; 2
    65d2:	8c 93       	st	X, r24
    65d4:	12 97       	sbiw	r26, 0x02	; 2
    65d6:	13 96       	adiw	r26, 0x03	; 3
    65d8:	9c 93       	st	X, r25
    65da:	0f 5f       	subi	r16, 0xFF	; 255
    65dc:	1f 4f       	sbci	r17, 0xFF	; 255
    65de:	b4 e0       	ldi	r27, 0x04	; 4
    65e0:	cb 0e       	add	r12, r27
    65e2:	d1 1c       	adc	r13, r1
    65e4:	eb a1       	ldd	r30, Y+35	; 0x23
    65e6:	fc a1       	ldd	r31, Y+36	; 0x24
    65e8:	34 96       	adiw	r30, 0x04	; 4
    65ea:	fc a3       	std	Y+36, r31	; 0x24
    65ec:	eb a3       	std	Y+35, r30	; 0x23
  // set up pull-off maneuver from axes limit switches that have been homed. This provides
  // some initial clearance off the switches and should also help prevent them from falsely
  // triggering when hard limits are enabled or when more than one axes shares a limit pin.
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    65ee:	03 30       	cpi	r16, 0x03	; 3
    65f0:	11 05       	cpc	r17, r1
    65f2:	09 f0       	breq	.+2      	; 0x65f6 <limits_go_home+0x3f2>
    65f4:	b5 cf       	rjmp	.-150    	; 0x6560 <limits_go_home+0x35c>
        sys_position[idx] = set_axis_position;
      #endif

    }
  }
  sys.step_control = STEP_CONTROL_NORMAL_OP; // Return step control to normal operation.
    65f6:	10 92 22 0c 	sts	0x0C22, r1	; 0x800c22 <sys+0x4>
    65fa:	03 c0       	rjmp	.+6      	; 0x6602 <limits_go_home+0x3fe>
          // Homing failure condition: Safety door was opened.
          if (rt_exec & EXEC_SAFETY_DOOR) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_DOOR); }
          // Homing failure condition: Limit switch still engaged after pull-off motion
          if (!approach && (limits_get_state() & cycle_mask)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_PULLOFF); }
          // Homing failure condition: Limit switch not found during approach.
          if (approach && (rt_exec & EXEC_CYCLE_STOP)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_APPROACH); }
    65fc:	12 ff       	sbrs	r17, 2
    65fe:	50 cf       	rjmp	.-352    	; 0x64a0 <limits_go_home+0x29c>
    6600:	4c cf       	rjmp	.-360    	; 0x649a <limits_go_home+0x296>
      #endif

    }
  }
  sys.step_control = STEP_CONTROL_NORMAL_OP; // Return step control to normal operation.
}
    6602:	a9 96       	adiw	r28, 0x29	; 41
    6604:	0f b6       	in	r0, 0x3f	; 63
    6606:	f8 94       	cli
    6608:	de bf       	out	0x3e, r29	; 62
    660a:	0f be       	out	0x3f, r0	; 63
    660c:	cd bf       	out	0x3d, r28	; 61
    660e:	df 91       	pop	r29
    6610:	cf 91       	pop	r28
    6612:	1f 91       	pop	r17
    6614:	0f 91       	pop	r16
    6616:	ff 90       	pop	r15
    6618:	ef 90       	pop	r14
    661a:	df 90       	pop	r13
    661c:	cf 90       	pop	r12
    661e:	bf 90       	pop	r11
    6620:	af 90       	pop	r10
    6622:	9f 90       	pop	r9
    6624:	8f 90       	pop	r8
    6626:	7f 90       	pop	r7
    6628:	6f 90       	pop	r6
    662a:	5f 90       	pop	r5
    662c:	4f 90       	pop	r4
    662e:	3f 90       	pop	r3
    6630:	2f 90       	pop	r2
    6632:	08 95       	ret

00006634 <limits_soft_check>:

// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
// NOTE: Used by jogging to limit travel within soft-limit volume.
void limits_soft_check(float *target)
{
    6634:	cf 93       	push	r28
    6636:	df 93       	push	r29
  if (system_check_travel_limits(target)) {
    6638:	0e 94 6b 3b 	call	0x76d6	; 0x76d6 <system_check_travel_limits>
    663c:	88 23       	and	r24, r24
    663e:	d1 f0       	breq	.+52     	; 0x6674 <limits_soft_check+0x40>
    sys.soft_limit = true;
    6640:	ee e1       	ldi	r30, 0x1E	; 30
    6642:	fc e0       	ldi	r31, 0x0C	; 12
    6644:	81 e0       	ldi	r24, 0x01	; 1
    6646:	83 83       	std	Z+3, r24	; 0x03
    // Force feed hold if cycle is active. All buffered blocks are guaranteed to be within
    // workspace volume so just come to a controlled stop so position is not lost. When complete
    // enter alarm mode.
    if (sys.state == STATE_CYCLE) {
    6648:	80 81       	ld	r24, Z
    664a:	88 30       	cpi	r24, 0x08	; 8
    664c:	61 f4       	brne	.+24     	; 0x6666 <limits_soft_check+0x32>
      system_set_exec_state_flag(EXEC_FEED_HOLD);
    664e:	0e 94 d0 3b 	call	0x77a0	; 0x77a0 <system_set_exec_state_flag>
      do {
        protocol_execute_realtime();
        if (sys.abort) { return; }
    6652:	ce e1       	ldi	r28, 0x1E	; 30
    6654:	dc e0       	ldi	r29, 0x0C	; 12
    // workspace volume so just come to a controlled stop so position is not lost. When complete
    // enter alarm mode.
    if (sys.state == STATE_CYCLE) {
      system_set_exec_state_flag(EXEC_FEED_HOLD);
      do {
        protocol_execute_realtime();
    6656:	0e 94 66 17 	call	0x2ecc	; 0x2ecc <protocol_execute_realtime>
        if (sys.abort) { return; }
    665a:	89 81       	ldd	r24, Y+1	; 0x01
    665c:	81 11       	cpse	r24, r1
    665e:	0a c0       	rjmp	.+20     	; 0x6674 <limits_soft_check+0x40>
      } while ( sys.state != STATE_IDLE );
    6660:	88 81       	ld	r24, Y
    6662:	81 11       	cpse	r24, r1
    6664:	f8 cf       	rjmp	.-16     	; 0x6656 <limits_soft_check+0x22>
    }
    mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
    6666:	0e 94 2f 07 	call	0xe5e	; 0xe5e <mc_reset>
    system_set_exec_alarm(EXEC_ALARM_SOFT_LIMIT); // Indicate soft limit critical event
    666a:	82 e0       	ldi	r24, 0x02	; 2
    666c:	0e 94 38 3e 	call	0x7c70	; 0x7c70 <system_set_exec_alarm>
    protocol_execute_realtime(); // Execute to enter critical event loop and system abort
    6670:	0e 94 66 17 	call	0x2ecc	; 0x2ecc <protocol_execute_realtime>
    return;
  }
}
    6674:	df 91       	pop	r29
    6676:	cf 91       	pop	r28
    6678:	08 95       	ret

0000667a <printString>:
      n /= 2;
  }

  for (; i > 0; i--)
      serial_write('0' + buf[i - 1]);
}
    667a:	cf 93       	push	r28
    667c:	df 93       	push	r29
    667e:	ec 01       	movw	r28, r24
    6680:	88 81       	ld	r24, Y
    6682:	88 23       	and	r24, r24
    6684:	31 f0       	breq	.+12     	; 0x6692 <printString+0x18>
    6686:	21 96       	adiw	r28, 0x01	; 1
    6688:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    668c:	89 91       	ld	r24, Y+
    668e:	81 11       	cpse	r24, r1
    6690:	fb cf       	rjmp	.-10     	; 0x6688 <printString+0xe>
    6692:	df 91       	pop	r29
    6694:	cf 91       	pop	r28
    6696:	08 95       	ret

00006698 <printPgmString>:
    6698:	cf 93       	push	r28
    669a:	df 93       	push	r29
    669c:	ec 01       	movw	r28, r24
    669e:	21 96       	adiw	r28, 0x01	; 1
    66a0:	fc 01       	movw	r30, r24
    66a2:	84 91       	lpm	r24, Z
    66a4:	88 23       	and	r24, r24
    66a6:	39 f0       	breq	.+14     	; 0x66b6 <printPgmString+0x1e>
    66a8:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    66ac:	fe 01       	movw	r30, r28
    66ae:	84 91       	lpm	r24, Z
    66b0:	21 96       	adiw	r28, 0x01	; 1
    66b2:	81 11       	cpse	r24, r1
    66b4:	f9 cf       	rjmp	.-14     	; 0x66a8 <printPgmString+0x10>
    66b6:	df 91       	pop	r29
    66b8:	cf 91       	pop	r28
    66ba:	08 95       	ret

000066bc <print_uint8_base10>:
    66bc:	cf 93       	push	r28
    66be:	df 93       	push	r29
    66c0:	84 36       	cpi	r24, 0x64	; 100
    66c2:	90 f0       	brcs	.+36     	; 0x66e8 <print_uint8_base10+0x2c>
    66c4:	9d ec       	ldi	r25, 0xCD	; 205
    66c6:	89 9f       	mul	r24, r25
    66c8:	91 2d       	mov	r25, r1
    66ca:	11 24       	eor	r1, r1
    66cc:	96 95       	lsr	r25
    66ce:	96 95       	lsr	r25
    66d0:	96 95       	lsr	r25
    66d2:	39 2f       	mov	r19, r25
    66d4:	33 0f       	add	r19, r19
    66d6:	23 2f       	mov	r18, r19
    66d8:	22 0f       	add	r18, r18
    66da:	22 0f       	add	r18, r18
    66dc:	23 0f       	add	r18, r19
    66de:	82 1b       	sub	r24, r18
    66e0:	d0 e3       	ldi	r29, 0x30	; 48
    66e2:	d8 0f       	add	r29, r24
    66e4:	89 2f       	mov	r24, r25
    66e6:	01 c0       	rjmp	.+2      	; 0x66ea <print_uint8_base10+0x2e>
    66e8:	d0 e0       	ldi	r29, 0x00	; 0
    66ea:	8a 30       	cpi	r24, 0x0A	; 10
    66ec:	f8 f0       	brcs	.+62     	; 0x672c <print_uint8_base10+0x70>
    66ee:	9d ec       	ldi	r25, 0xCD	; 205
    66f0:	89 9f       	mul	r24, r25
    66f2:	91 2d       	mov	r25, r1
    66f4:	11 24       	eor	r1, r1
    66f6:	96 95       	lsr	r25
    66f8:	96 95       	lsr	r25
    66fa:	96 95       	lsr	r25
    66fc:	39 2f       	mov	r19, r25
    66fe:	33 0f       	add	r19, r19
    6700:	23 2f       	mov	r18, r19
    6702:	22 0f       	add	r18, r18
    6704:	22 0f       	add	r18, r18
    6706:	23 0f       	add	r18, r19
    6708:	c8 2f       	mov	r28, r24
    670a:	c2 1b       	sub	r28, r18
    670c:	c0 5d       	subi	r28, 0xD0	; 208
    670e:	80 e3       	ldi	r24, 0x30	; 48
    6710:	89 0f       	add	r24, r25
    6712:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    6716:	cc 23       	and	r28, r28
    6718:	19 f0       	breq	.+6      	; 0x6720 <print_uint8_base10+0x64>
    671a:	8c 2f       	mov	r24, r28
    671c:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    6720:	dd 23       	and	r29, r29
    6722:	41 f0       	breq	.+16     	; 0x6734 <print_uint8_base10+0x78>
    6724:	8d 2f       	mov	r24, r29
    6726:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    672a:	04 c0       	rjmp	.+8      	; 0x6734 <print_uint8_base10+0x78>
    672c:	80 5d       	subi	r24, 0xD0	; 208
    672e:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    6732:	f6 cf       	rjmp	.-20     	; 0x6720 <print_uint8_base10+0x64>
    6734:	df 91       	pop	r29
    6736:	cf 91       	pop	r28
    6738:	08 95       	ret

0000673a <print_uint32_base10>:


void print_uint32_base10(uint32_t n)
{
    673a:	8f 92       	push	r8
    673c:	9f 92       	push	r9
    673e:	af 92       	push	r10
    6740:	bf 92       	push	r11
    6742:	ef 92       	push	r14
    6744:	ff 92       	push	r15
    6746:	1f 93       	push	r17
    6748:	cf 93       	push	r28
    674a:	df 93       	push	r29
    674c:	cd b7       	in	r28, 0x3d	; 61
    674e:	de b7       	in	r29, 0x3e	; 62
    6750:	2a 97       	sbiw	r28, 0x0a	; 10
    6752:	0f b6       	in	r0, 0x3f	; 63
    6754:	f8 94       	cli
    6756:	de bf       	out	0x3e, r29	; 62
    6758:	0f be       	out	0x3f, r0	; 63
    675a:	cd bf       	out	0x3d, r28	; 61
  if (n == 0) {
    675c:	61 15       	cp	r22, r1
    675e:	71 05       	cpc	r23, r1
    6760:	81 05       	cpc	r24, r1
    6762:	91 05       	cpc	r25, r1
    6764:	21 f4       	brne	.+8      	; 0x676e <print_uint32_base10+0x34>
    serial_write('0');
    6766:	80 e3       	ldi	r24, 0x30	; 48
    6768:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    676c:	2c c0       	rjmp	.+88     	; 0x67c6 <print_uint32_base10+0x8c>
    676e:	20 e0       	ldi	r18, 0x00	; 0

  unsigned char buf[10];
  uint8_t i = 0;

  while (n > 0) {
    buf[i++] = n % 10;
    6770:	0f 2e       	mov	r0, r31
    6772:	fa e0       	ldi	r31, 0x0A	; 10
    6774:	8f 2e       	mov	r8, r31
    6776:	91 2c       	mov	r9, r1
    6778:	a1 2c       	mov	r10, r1
    677a:	b1 2c       	mov	r11, r1
    677c:	f0 2d       	mov	r31, r0
    677e:	11 e0       	ldi	r17, 0x01	; 1
    6780:	12 0f       	add	r17, r18
    6782:	ee 24       	eor	r14, r14
    6784:	e3 94       	inc	r14
    6786:	f1 2c       	mov	r15, r1
    6788:	ec 0e       	add	r14, r28
    678a:	fd 1e       	adc	r15, r29
    678c:	e2 0e       	add	r14, r18
    678e:	f1 1c       	adc	r15, r1
    6790:	a5 01       	movw	r20, r10
    6792:	94 01       	movw	r18, r8
    6794:	0e 94 cb 42 	call	0x8596	; 0x8596 <__udivmodsi4>
    6798:	f7 01       	movw	r30, r14
    679a:	60 83       	st	Z, r22
    n /= 10;
    679c:	62 2f       	mov	r22, r18
    679e:	73 2f       	mov	r23, r19
    67a0:	84 2f       	mov	r24, r20
    67a2:	95 2f       	mov	r25, r21

  unsigned char buf[10];
  uint8_t i = 0;

  while (n > 0) {
    buf[i++] = n % 10;
    67a4:	21 2f       	mov	r18, r17
  }

  unsigned char buf[10];
  uint8_t i = 0;

  while (n > 0) {
    67a6:	61 15       	cp	r22, r1
    67a8:	71 05       	cpc	r23, r1
    67aa:	81 05       	cpc	r24, r1
    67ac:	91 05       	cpc	r25, r1
    67ae:	39 f7       	brne	.-50     	; 0x677e <print_uint32_base10+0x44>
    buf[i++] = n % 10;
    n /= 10;
  }

  for (; i > 0; i--)
    67b0:	11 23       	and	r17, r17
    67b2:	49 f0       	breq	.+18     	; 0x67c6 <print_uint32_base10+0x8c>
    serial_write('0' + buf[i-1]);
    67b4:	fe 01       	movw	r30, r28
    67b6:	e1 0f       	add	r30, r17
    67b8:	f1 1d       	adc	r31, r1
    67ba:	80 81       	ld	r24, Z
    67bc:	80 5d       	subi	r24, 0xD0	; 208
    67be:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
  while (n > 0) {
    buf[i++] = n % 10;
    n /= 10;
  }

  for (; i > 0; i--)
    67c2:	11 50       	subi	r17, 0x01	; 1
    67c4:	b9 f7       	brne	.-18     	; 0x67b4 <print_uint32_base10+0x7a>
    serial_write('0' + buf[i-1]);
}
    67c6:	2a 96       	adiw	r28, 0x0a	; 10
    67c8:	0f b6       	in	r0, 0x3f	; 63
    67ca:	f8 94       	cli
    67cc:	de bf       	out	0x3e, r29	; 62
    67ce:	0f be       	out	0x3f, r0	; 63
    67d0:	cd bf       	out	0x3d, r28	; 61
    67d2:	df 91       	pop	r29
    67d4:	cf 91       	pop	r28
    67d6:	1f 91       	pop	r17
    67d8:	ff 90       	pop	r15
    67da:	ef 90       	pop	r14
    67dc:	bf 90       	pop	r11
    67de:	af 90       	pop	r10
    67e0:	9f 90       	pop	r9
    67e2:	8f 90       	pop	r8
    67e4:	08 95       	ret

000067e6 <printInteger>:


void printInteger(long n)
{
    67e6:	cf 92       	push	r12
    67e8:	df 92       	push	r13
    67ea:	ef 92       	push	r14
    67ec:	ff 92       	push	r15
    67ee:	6b 01       	movw	r12, r22
    67f0:	7c 01       	movw	r14, r24
  if (n < 0) {
    67f2:	99 23       	and	r25, r25
    67f4:	64 f4       	brge	.+24     	; 0x680e <printInteger+0x28>
    serial_write('-');
    67f6:	8d e2       	ldi	r24, 0x2D	; 45
    67f8:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    print_uint32_base10(-n);
    67fc:	66 27       	eor	r22, r22
    67fe:	77 27       	eor	r23, r23
    6800:	cb 01       	movw	r24, r22
    6802:	6c 19       	sub	r22, r12
    6804:	7d 09       	sbc	r23, r13
    6806:	8e 09       	sbc	r24, r14
    6808:	9f 09       	sbc	r25, r15
    680a:	97 df       	rcall	.-210    	; 0x673a <print_uint32_base10>
    680c:	01 c0       	rjmp	.+2      	; 0x6810 <printInteger+0x2a>
  } else {
    print_uint32_base10(n);
    680e:	95 df       	rcall	.-214    	; 0x673a <print_uint32_base10>
    6810:	ff 90       	pop	r15
  }
}
    6812:	ef 90       	pop	r14
    6814:	df 90       	pop	r13
    6816:	cf 90       	pop	r12
    6818:	08 95       	ret

0000681a <printFloat>:
    681a:	8f 92       	push	r8
// more digits than a float. Number of decimal places, which are tracked by a counter,
// may be set by the user. The integer is then efficiently converted to a string.
// NOTE: AVR '%' and '/' integer operations are very efficient. Bitshifting speed-up
// techniques are actually just slightly slower. Found this out the hard way.
void printFloat(float n, uint8_t decimal_places)
{
    681c:	9f 92       	push	r9
    681e:	af 92       	push	r10
    6820:	bf 92       	push	r11
    6822:	cf 92       	push	r12
    6824:	df 92       	push	r13
    6826:	ef 92       	push	r14
    6828:	ff 92       	push	r15
    682a:	0f 93       	push	r16
    682c:	1f 93       	push	r17
    682e:	cf 93       	push	r28
    6830:	df 93       	push	r29
    6832:	cd b7       	in	r28, 0x3d	; 61
    6834:	de b7       	in	r29, 0x3e	; 62
    6836:	2d 97       	sbiw	r28, 0x0d	; 13
    6838:	0f b6       	in	r0, 0x3f	; 63
    683a:	f8 94       	cli
    683c:	de bf       	out	0x3e, r29	; 62
    683e:	0f be       	out	0x3f, r0	; 63
    6840:	cd bf       	out	0x3d, r28	; 61
    6842:	6b 01       	movw	r12, r22
    6844:	7c 01       	movw	r14, r24
    6846:	04 2f       	mov	r16, r20
  if (n < 0) {
    6848:	20 e0       	ldi	r18, 0x00	; 0
    684a:	30 e0       	ldi	r19, 0x00	; 0
    684c:	a9 01       	movw	r20, r18
    684e:	0e 94 a0 3f 	call	0x7f40	; 0x7f40 <__cmpsf2>
    6852:	88 23       	and	r24, r24
    6854:	3c f4       	brge	.+14     	; 0x6864 <printFloat+0x4a>
    serial_write('-');
    6856:	8d e2       	ldi	r24, 0x2D	; 45
    6858:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    n = -n;
    685c:	f7 fa       	bst	r15, 7
    685e:	f0 94       	com	r15
    6860:	f7 f8       	bld	r15, 7
    6862:	f0 94       	com	r15
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    6864:	02 30       	cpi	r16, 0x02	; 2
    6866:	88 f0       	brcs	.+34     	; 0x688a <printFloat+0x70>
    6868:	10 2f       	mov	r17, r16
    n *= 100;
    686a:	20 e0       	ldi	r18, 0x00	; 0
    686c:	30 e0       	ldi	r19, 0x00	; 0
    686e:	48 ec       	ldi	r20, 0xC8	; 200
    6870:	52 e4       	ldi	r21, 0x42	; 66
    6872:	c7 01       	movw	r24, r14
    6874:	b6 01       	movw	r22, r12
    6876:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    687a:	6b 01       	movw	r12, r22
    687c:	7c 01       	movw	r14, r24
    decimals -= 2;
    687e:	12 50       	subi	r17, 0x02	; 2
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    6880:	12 30       	cpi	r17, 0x02	; 2
    6882:	98 f7       	brcc	.-26     	; 0x686a <printFloat+0x50>
    6884:	80 2f       	mov	r24, r16
    6886:	81 70       	andi	r24, 0x01	; 1
    6888:	01 c0       	rjmp	.+2      	; 0x688c <printFloat+0x72>
  if (n < 0) {
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
    688a:	80 2f       	mov	r24, r16
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    n *= 100;
    decimals -= 2;
  }
  if (decimals) { n *= 10; }
    688c:	88 23       	and	r24, r24
    688e:	51 f0       	breq	.+20     	; 0x68a4 <printFloat+0x8a>
    6890:	20 e0       	ldi	r18, 0x00	; 0
    6892:	30 e0       	ldi	r19, 0x00	; 0
    6894:	40 e2       	ldi	r20, 0x20	; 32
    6896:	51 e4       	ldi	r21, 0x41	; 65
    6898:	c7 01       	movw	r24, r14
    689a:	b6 01       	movw	r22, r12
    689c:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    68a0:	6b 01       	movw	r12, r22
    68a2:	7c 01       	movw	r14, r24
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.

  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
  uint32_t a = (long)n;
    68a4:	20 e0       	ldi	r18, 0x00	; 0
    68a6:	30 e0       	ldi	r19, 0x00	; 0
    68a8:	40 e0       	ldi	r20, 0x00	; 0
    68aa:	5f e3       	ldi	r21, 0x3F	; 63
    68ac:	c7 01       	movw	r24, r14
    68ae:	b6 01       	movw	r22, r12
    68b0:	0e 94 c7 3e 	call	0x7d8e	; 0x7d8e <__addsf3>
    68b4:	0e 94 0f 40 	call	0x801e	; 0x801e <__fixsfsi>
  while(a > 0) {
    68b8:	61 15       	cp	r22, r1
    68ba:	71 05       	cpc	r23, r1
    68bc:	81 05       	cpc	r24, r1
    68be:	91 05       	cpc	r25, r1
    68c0:	19 f1       	breq	.+70     	; 0x6908 <printFloat+0xee>
    68c2:	20 e0       	ldi	r18, 0x00	; 0
    buf[i++] = (a % 10) + '0'; // Get digit
    68c4:	0f 2e       	mov	r0, r31
    68c6:	fa e0       	ldi	r31, 0x0A	; 10
    68c8:	8f 2e       	mov	r8, r31
    68ca:	91 2c       	mov	r9, r1
    68cc:	a1 2c       	mov	r10, r1
    68ce:	b1 2c       	mov	r11, r1
    68d0:	f0 2d       	mov	r31, r0
    68d2:	11 e0       	ldi	r17, 0x01	; 1
    68d4:	12 0f       	add	r17, r18
    68d6:	ee 24       	eor	r14, r14
    68d8:	e3 94       	inc	r14
    68da:	f1 2c       	mov	r15, r1
    68dc:	ec 0e       	add	r14, r28
    68de:	fd 1e       	adc	r15, r29
    68e0:	e2 0e       	add	r14, r18
    68e2:	f1 1c       	adc	r15, r1
    68e4:	a5 01       	movw	r20, r10
    68e6:	94 01       	movw	r18, r8
    68e8:	0e 94 cb 42 	call	0x8596	; 0x8596 <__udivmodsi4>
    68ec:	60 5d       	subi	r22, 0xD0	; 208
    68ee:	f7 01       	movw	r30, r14
    68f0:	60 83       	st	Z, r22
    a /= 10;
    68f2:	62 2f       	mov	r22, r18
    68f4:	73 2f       	mov	r23, r19
    68f6:	84 2f       	mov	r24, r20
    68f8:	95 2f       	mov	r25, r21
  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
  uint32_t a = (long)n;
  while(a > 0) {
    buf[i++] = (a % 10) + '0'; // Get digit
    68fa:	21 2f       	mov	r18, r17

  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
  uint32_t a = (long)n;
  while(a > 0) {
    68fc:	61 15       	cp	r22, r1
    68fe:	71 05       	cpc	r23, r1
    6900:	81 05       	cpc	r24, r1
    6902:	91 05       	cpc	r25, r1
    6904:	31 f7       	brne	.-52     	; 0x68d2 <printFloat+0xb8>
    6906:	01 c0       	rjmp	.+2      	; 0x690a <printFloat+0xf0>
  if (decimals) { n *= 10; }
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.

  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
    6908:	10 e0       	ldi	r17, 0x00	; 0
  uint32_t a = (long)n;
  while(a > 0) {
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) {
    690a:	10 17       	cp	r17, r16
    690c:	60 f4       	brcc	.+24     	; 0x6926 <printFloat+0x10c>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
    690e:	80 e3       	ldi	r24, 0x30	; 48
    6910:	e1 e0       	ldi	r30, 0x01	; 1
    6912:	f0 e0       	ldi	r31, 0x00	; 0
    6914:	ec 0f       	add	r30, r28
    6916:	fd 1f       	adc	r31, r29
    6918:	e1 0f       	add	r30, r17
    691a:	f1 1d       	adc	r31, r1
    691c:	80 83       	st	Z, r24
    691e:	1f 5f       	subi	r17, 0xFF	; 255
  uint32_t a = (long)n;
  while(a > 0) {
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) {
    6920:	01 13       	cpse	r16, r17
    6922:	f6 cf       	rjmp	.-20     	; 0x6910 <printFloat+0xf6>
    6924:	02 c0       	rjmp	.+4      	; 0x692a <printFloat+0x110>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
  }
  if (i == decimal_places) { // Fill in leading zero, if needed.
    6926:	01 13       	cpse	r16, r17
    6928:	07 c0       	rjmp	.+14     	; 0x6938 <printFloat+0x11e>
    buf[i++] = '0';
    692a:	11 e0       	ldi	r17, 0x01	; 1
    692c:	10 0f       	add	r17, r16
    692e:	80 e3       	ldi	r24, 0x30	; 48
    6930:	fe 01       	movw	r30, r28
    6932:	e0 0f       	add	r30, r16
    6934:	f1 1d       	adc	r31, r1
    6936:	81 83       	std	Z+1, r24	; 0x01
  }

  // Print the generated string.
  for (; i > 0; i--) {
    6938:	11 23       	and	r17, r17
    693a:	69 f0       	breq	.+26     	; 0x6956 <printFloat+0x13c>
    if (i == decimal_places) { serial_write('.'); } // Insert decimal point in right place.
    693c:	01 13       	cpse	r16, r17
    693e:	03 c0       	rjmp	.+6      	; 0x6946 <printFloat+0x12c>
    6940:	8e e2       	ldi	r24, 0x2E	; 46
    6942:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    serial_write(buf[i-1]);
    6946:	fe 01       	movw	r30, r28
    6948:	e1 0f       	add	r30, r17
    694a:	f1 1d       	adc	r31, r1
    694c:	80 81       	ld	r24, Z
    694e:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
  if (i == decimal_places) { // Fill in leading zero, if needed.
    buf[i++] = '0';
  }

  // Print the generated string.
  for (; i > 0; i--) {
    6952:	11 50       	subi	r17, 0x01	; 1
    6954:	99 f7       	brne	.-26     	; 0x693c <printFloat+0x122>
    if (i == decimal_places) { serial_write('.'); } // Insert decimal point in right place.
    serial_write(buf[i-1]);
  }
}
    6956:	2d 96       	adiw	r28, 0x0d	; 13
    6958:	0f b6       	in	r0, 0x3f	; 63
    695a:	f8 94       	cli
    695c:	de bf       	out	0x3e, r29	; 62
    695e:	0f be       	out	0x3f, r0	; 63
    6960:	cd bf       	out	0x3d, r28	; 61
    6962:	df 91       	pop	r29
    6964:	cf 91       	pop	r28
    6966:	1f 91       	pop	r17
    6968:	0f 91       	pop	r16
    696a:	ff 90       	pop	r15
    696c:	ef 90       	pop	r14
    696e:	df 90       	pop	r13
    6970:	cf 90       	pop	r12
    6972:	bf 90       	pop	r11
    6974:	af 90       	pop	r10
    6976:	9f 90       	pop	r9
    6978:	8f 90       	pop	r8
    697a:	08 95       	ret

0000697c <printFloat_CoordValue>:
// Floating value printing handlers for special variables types used in Grbl and are defined
// in the config.h.
//  - CoordValue: Handles all position or coordinate values in inches or mm reporting.
//  - RateValue: Handles feed rate and current velocity in inches or mm reporting.
void printFloat_CoordValue(float n) {
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
    697c:	20 91 15 0f 	lds	r18, 0x0F15	; 0x800f15 <settings+0x45>
    6980:	20 ff       	sbrs	r18, 0
    6982:	09 c0       	rjmp	.+18     	; 0x6996 <printFloat_CoordValue+0x1a>
    printFloat(n*INCH_PER_MM,N_DECIMAL_COORDVALUE_INCH);
    6984:	2b e8       	ldi	r18, 0x8B	; 139
    6986:	32 e4       	ldi	r19, 0x42	; 66
    6988:	41 e2       	ldi	r20, 0x21	; 33
    698a:	5d e3       	ldi	r21, 0x3D	; 61
    698c:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    6990:	44 e0       	ldi	r20, 0x04	; 4
    6992:	43 cf       	rjmp	.-378    	; 0x681a <printFloat>
    6994:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_COORDVALUE_MM);
    6996:	43 e0       	ldi	r20, 0x03	; 3
    6998:	40 cf       	rjmp	.-384    	; 0x681a <printFloat>
    699a:	08 95       	ret

0000699c <printFloat_RateValue>:
  }
}

void printFloat_RateValue(float n) {
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
    699c:	20 91 15 0f 	lds	r18, 0x0F15	; 0x800f15 <settings+0x45>
    69a0:	20 ff       	sbrs	r18, 0
    69a2:	09 c0       	rjmp	.+18     	; 0x69b6 <printFloat_RateValue+0x1a>
    printFloat(n*INCH_PER_MM,N_DECIMAL_RATEVALUE_INCH);
    69a4:	2b e8       	ldi	r18, 0x8B	; 139
    69a6:	32 e4       	ldi	r19, 0x42	; 66
    69a8:	41 e2       	ldi	r20, 0x21	; 33
    69aa:	5d e3       	ldi	r21, 0x3D	; 61
    69ac:	0e 94 de 41 	call	0x83bc	; 0x83bc <__mulsf3>
    69b0:	41 e0       	ldi	r20, 0x01	; 1
    69b2:	33 cf       	rjmp	.-410    	; 0x681a <printFloat>
    69b4:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_RATEVALUE_MM);
    69b6:	40 e0       	ldi	r20, 0x00	; 0
    69b8:	30 cf       	rjmp	.-416    	; 0x681a <printFloat>
    69ba:	08 95       	ret

000069bc <probe_configure_invert_mask>:
// Called by probe_init() and the mc_probe() routines. Sets up the probe pin invert mask to
// appropriately set the pin logic according to setting for normal-high/normal-low operation
// and the probing cycle modes for toward-workpiece/away-from-workpiece.
void probe_configure_invert_mask(uint8_t is_probe_away)
{
  probe_invert_mask = 0; // Initialize as zero.
    69bc:	10 92 25 0f 	sts	0x0F25, r1	; 0x800f25 <probe_invert_mask>
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_PROBE_PIN)) { probe_invert_mask ^= PROBE_MASK; }
    69c0:	90 91 15 0f 	lds	r25, 0x0F15	; 0x800f15 <settings+0x45>
    69c4:	99 23       	and	r25, r25
    69c6:	1c f0       	brlt	.+6      	; 0x69ce <probe_configure_invert_mask+0x12>
    69c8:	90 e8       	ldi	r25, 0x80	; 128
    69ca:	90 93 25 0f 	sts	0x0F25, r25	; 0x800f25 <probe_invert_mask>
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
    69ce:	88 23       	and	r24, r24
    69d0:	29 f0       	breq	.+10     	; 0x69dc <probe_configure_invert_mask+0x20>
    69d2:	80 91 25 0f 	lds	r24, 0x0F25	; 0x800f25 <probe_invert_mask>
    69d6:	80 58       	subi	r24, 0x80	; 128
    69d8:	80 93 25 0f 	sts	0x0F25, r24	; 0x800f25 <probe_invert_mask>
    69dc:	08 95       	ret

000069de <probe_init>:


// Probe pin initialization routine.
void probe_init()
{
  PROBE_DDR &= ~(PROBE_MASK); // Configure as input pins
    69de:	e7 e0       	ldi	r30, 0x07	; 7
    69e0:	f1 e0       	ldi	r31, 0x01	; 1
    69e2:	80 81       	ld	r24, Z
    69e4:	8f 77       	andi	r24, 0x7F	; 127
    69e6:	80 83       	st	Z, r24
  #ifdef DISABLE_PROBE_PIN_PULL_UP
    PROBE_PORT &= ~(PROBE_MASK); // Normal low operation. Requires external pull-down.
  #else
    PROBE_PORT |= PROBE_MASK;    // Enable internal pull-up resistors. Normal high operation.
    69e8:	e8 e0       	ldi	r30, 0x08	; 8
    69ea:	f1 e0       	ldi	r31, 0x01	; 1
    69ec:	80 81       	ld	r24, Z
    69ee:	80 68       	ori	r24, 0x80	; 128
    69f0:	80 83       	st	Z, r24
  #endif
  probe_configure_invert_mask(false); // Initialize invert mask.
    69f2:	80 e0       	ldi	r24, 0x00	; 0
    69f4:	e3 cf       	rjmp	.-58     	; 0x69bc <probe_configure_invert_mask>
    69f6:	08 95       	ret

000069f8 <probe_get_state>:
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
}


// Returns the probe pin state. Triggered = true. Called by gcode parser and probe state monitor.
uint8_t probe_get_state() { return((PROBE_PIN & PROBE_MASK) ^ probe_invert_mask); }
    69f8:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
    69fc:	80 78       	andi	r24, 0x80	; 128
    69fe:	90 91 25 0f 	lds	r25, 0x0F25	; 0x800f25 <probe_invert_mask>
    6a02:	89 27       	eor	r24, r25
    6a04:	08 95       	ret

00006a06 <probe_state_monitor>:
// Monitors probe pin state and records the system position when detected. Called by the
// stepper ISR per ISR tick.
// NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
void probe_state_monitor()
{
  if (probe_get_state()) {
    6a06:	f8 df       	rcall	.-16     	; 0x69f8 <probe_get_state>
    6a08:	88 23       	and	r24, r24
    6a0a:	81 f0       	breq	.+32     	; 0x6a2c <probe_state_monitor+0x26>
    sys_probe_state = PROBE_OFF;
    6a0c:	10 92 32 0c 	sts	0x0C32, r1	; 0x800c32 <sys_probe_state>
    memcpy(sys_probe_position, sys_position, sizeof(sys_position));
    6a10:	8c e0       	ldi	r24, 0x0C	; 12
    6a12:	e3 e4       	ldi	r30, 0x43	; 67
    6a14:	fc e0       	ldi	r31, 0x0C	; 12
    6a16:	a7 e3       	ldi	r26, 0x37	; 55
    6a18:	bc e0       	ldi	r27, 0x0C	; 12
    6a1a:	01 90       	ld	r0, Z+
    6a1c:	0d 92       	st	X+, r0
    6a1e:	8a 95       	dec	r24
    6a20:	e1 f7       	brne	.-8      	; 0x6a1a <probe_state_monitor+0x14>
    bit_true(sys_rt_exec_state, EXEC_MOTION_CANCEL);
    6a22:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    6a26:	80 64       	ori	r24, 0x40	; 64
    6a28:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <sys_rt_exec_state>
    6a2c:	08 95       	ret

00006a2e <report_util_line_feed>:
// and has been sent into protocol_execute_line() routine to be executed by Grbl.
void report_echo_line_received(char *line)
{
  printPgmString(PSTR("[echo: ")); printString(line);
  report_util_feedback_line_feed();
}
    6a2e:	89 e2       	ldi	r24, 0x29	; 41
    6a30:	95 e0       	ldi	r25, 0x05	; 5
    6a32:	32 ce       	rjmp	.-924    	; 0x6698 <printPgmString>
    6a34:	08 95       	ret

00006a36 <report_util_feedback_line_feed>:
    6a36:	8d e5       	ldi	r24, 0x5D	; 93
    6a38:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    6a3c:	f8 cf       	rjmp	.-16     	; 0x6a2e <report_util_line_feed>
    6a3e:	08 95       	ret

00006a40 <report_util_axis_values>:
    6a40:	0f 93       	push	r16
    6a42:	1f 93       	push	r17
    6a44:	cf 93       	push	r28
    6a46:	8c 01       	movw	r16, r24
    6a48:	c0 e0       	ldi	r28, 0x00	; 0
    6a4a:	f8 01       	movw	r30, r16
    6a4c:	61 91       	ld	r22, Z+
    6a4e:	71 91       	ld	r23, Z+
    6a50:	81 91       	ld	r24, Z+
    6a52:	91 91       	ld	r25, Z+
    6a54:	8f 01       	movw	r16, r30
    6a56:	92 df       	rcall	.-220    	; 0x697c <printFloat_CoordValue>
    6a58:	c2 30       	cpi	r28, 0x02	; 2
    6a5a:	18 f4       	brcc	.+6      	; 0x6a62 <report_util_axis_values+0x22>
    6a5c:	8c e2       	ldi	r24, 0x2C	; 44
    6a5e:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    6a62:	cf 5f       	subi	r28, 0xFF	; 255
    6a64:	c3 30       	cpi	r28, 0x03	; 3
    6a66:	89 f7       	brne	.-30     	; 0x6a4a <report_util_axis_values+0xa>
    6a68:	cf 91       	pop	r28
    6a6a:	1f 91       	pop	r17
    6a6c:	0f 91       	pop	r16
    6a6e:	08 95       	ret

00006a70 <report_util_setting_prefix>:
    6a70:	cf 93       	push	r28
    6a72:	c8 2f       	mov	r28, r24
    6a74:	84 e2       	ldi	r24, 0x24	; 36
    6a76:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    6a7a:	8c 2f       	mov	r24, r28
    6a7c:	1f de       	rcall	.-962    	; 0x66bc <print_uint8_base10>
    6a7e:	8d e3       	ldi	r24, 0x3D	; 61
    6a80:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    6a84:	cf 91       	pop	r28
    6a86:	08 95       	ret

00006a88 <report_util_uint8_setting>:
    6a88:	cf 93       	push	r28
    6a8a:	c6 2f       	mov	r28, r22
    6a8c:	f1 df       	rcall	.-30     	; 0x6a70 <report_util_setting_prefix>
    6a8e:	8c 2f       	mov	r24, r28
    6a90:	15 de       	rcall	.-982    	; 0x66bc <print_uint8_base10>
    6a92:	cd df       	rcall	.-102    	; 0x6a2e <report_util_line_feed>
    6a94:	cf 91       	pop	r28
    6a96:	08 95       	ret

00006a98 <report_util_float_setting>:
    6a98:	cf 92       	push	r12
    6a9a:	df 92       	push	r13
    6a9c:	ef 92       	push	r14
    6a9e:	ff 92       	push	r15
    6aa0:	cf 93       	push	r28
    6aa2:	6a 01       	movw	r12, r20
    6aa4:	7b 01       	movw	r14, r22
    6aa6:	c2 2f       	mov	r28, r18
    6aa8:	e3 df       	rcall	.-58     	; 0x6a70 <report_util_setting_prefix>
    6aaa:	4c 2f       	mov	r20, r28
    6aac:	c7 01       	movw	r24, r14
    6aae:	b6 01       	movw	r22, r12
    6ab0:	b4 de       	rcall	.-664    	; 0x681a <printFloat>
    6ab2:	bd df       	rcall	.-134    	; 0x6a2e <report_util_line_feed>
    6ab4:	cf 91       	pop	r28
    6ab6:	ff 90       	pop	r15
    6ab8:	ef 90       	pop	r14
    6aba:	df 90       	pop	r13
    6abc:	cf 90       	pop	r12
    6abe:	08 95       	ret

00006ac0 <report_status_message>:
    6ac0:	cf 93       	push	r28
    6ac2:	c8 2f       	mov	r28, r24
    6ac4:	81 11       	cpse	r24, r1
    6ac6:	04 c0       	rjmp	.+8      	; 0x6ad0 <report_status_message+0x10>
    6ac8:	83 e3       	ldi	r24, 0x33	; 51
    6aca:	95 e0       	ldi	r25, 0x05	; 5
    6acc:	e5 dd       	rcall	.-1078   	; 0x6698 <printPgmString>
    6ace:	06 c0       	rjmp	.+12     	; 0x6adc <report_status_message+0x1c>
    6ad0:	8c e2       	ldi	r24, 0x2C	; 44
    6ad2:	95 e0       	ldi	r25, 0x05	; 5
    6ad4:	e1 dd       	rcall	.-1086   	; 0x6698 <printPgmString>
    6ad6:	8c 2f       	mov	r24, r28
    6ad8:	f1 dd       	rcall	.-1054   	; 0x66bc <print_uint8_base10>
    6ada:	a9 df       	rcall	.-174    	; 0x6a2e <report_util_line_feed>
    6adc:	cf 91       	pop	r28
    6ade:	08 95       	ret

00006ae0 <report_alarm_message>:
    6ae0:	cf 93       	push	r28
    6ae2:	c8 2f       	mov	r28, r24
    6ae4:	82 e2       	ldi	r24, 0x22	; 34
    6ae6:	95 e0       	ldi	r25, 0x05	; 5
    6ae8:	d7 dd       	rcall	.-1106   	; 0x6698 <printPgmString>
    6aea:	8c 2f       	mov	r24, r28
    6aec:	e7 dd       	rcall	.-1074   	; 0x66bc <print_uint8_base10>
    6aee:	9f df       	rcall	.-194    	; 0x6a2e <report_util_line_feed>
    6af0:	84 ef       	ldi	r24, 0xF4	; 244
    6af2:	91 e0       	ldi	r25, 0x01	; 1
    6af4:	b7 d9       	rcall	.-3218   	; 0x5e64 <delay_ms>
    6af6:	cf 91       	pop	r28
    6af8:	08 95       	ret

00006afa <report_synchronization_state>:
    6afa:	cf 92       	push	r12
    6afc:	df 92       	push	r13
    6afe:	ef 92       	push	r14
    6b00:	ff 92       	push	r15
    6b02:	8d e1       	ldi	r24, 0x1D	; 29
    6b04:	95 e0       	ldi	r25, 0x05	; 5
    6b06:	c8 dd       	rcall	.-1136   	; 0x6698 <printPgmString>
    6b08:	60 91 55 0c 	lds	r22, 0x0C55	; 0x800c55 <sys_index_pulse_count>
    6b0c:	70 e0       	ldi	r23, 0x00	; 0
    6b0e:	80 e0       	ldi	r24, 0x00	; 0
    6b10:	90 e0       	ldi	r25, 0x00	; 0
    6b12:	13 de       	rcall	.-986    	; 0x673a <print_uint32_base10>
    6b14:	87 e1       	ldi	r24, 0x17	; 23
    6b16:	95 e0       	ldi	r25, 0x05	; 5
    6b18:	bf dd       	rcall	.-1154   	; 0x6698 <printPgmString>
    6b1a:	60 91 15 0c 	lds	r22, 0x0C15	; 0x800c15 <sys_synchronization_pulse_count>
    6b1e:	70 91 16 0c 	lds	r23, 0x0C16	; 0x800c16 <sys_synchronization_pulse_count+0x1>
    6b22:	80 91 17 0c 	lds	r24, 0x0C17	; 0x800c17 <sys_synchronization_pulse_count+0x2>
    6b26:	90 91 18 0c 	lds	r25, 0x0C18	; 0x800c18 <sys_synchronization_pulse_count+0x3>
    6b2a:	07 de       	rcall	.-1010   	; 0x673a <print_uint32_base10>
    6b2c:	81 e1       	ldi	r24, 0x11	; 17
    6b2e:	95 e0       	ldi	r25, 0x05	; 5
    6b30:	b3 dd       	rcall	.-1178   	; 0x6698 <printPgmString>
    6b32:	60 91 4f 0c 	lds	r22, 0x0C4F	; 0x800c4f <sys_sync_time>
    6b36:	70 91 50 0c 	lds	r23, 0x0C50	; 0x800c50 <sys_sync_time+0x1>
    6b3a:	80 91 51 0c 	lds	r24, 0x0C51	; 0x800c51 <sys_sync_time+0x2>
    6b3e:	90 91 52 0c 	lds	r25, 0x0C52	; 0x800c52 <sys_sync_time+0x3>
    6b42:	fb dd       	rcall	.-1034   	; 0x673a <print_uint32_base10>
    6b44:	8b e0       	ldi	r24, 0x0B	; 11
    6b46:	95 e0       	ldi	r25, 0x05	; 5
    6b48:	a7 dd       	rcall	.-1202   	; 0x6698 <printPgmString>
    6b4a:	60 91 1a 0c 	lds	r22, 0x0C1A	; 0x800c1a <sys_sync_time_passed>
    6b4e:	70 91 1b 0c 	lds	r23, 0x0C1B	; 0x800c1b <sys_sync_time_passed+0x1>
    6b52:	80 91 1c 0c 	lds	r24, 0x0C1C	; 0x800c1c <sys_sync_time_passed+0x2>
    6b56:	90 91 1d 0c 	lds	r25, 0x0C1D	; 0x800c1d <sys_sync_time_passed+0x3>
    6b5a:	ef dd       	rcall	.-1058   	; 0x673a <print_uint32_base10>
    6b5c:	c0 90 1a 0c 	lds	r12, 0x0C1A	; 0x800c1a <sys_sync_time_passed>
    6b60:	d0 90 1b 0c 	lds	r13, 0x0C1B	; 0x800c1b <sys_sync_time_passed+0x1>
    6b64:	e0 90 1c 0c 	lds	r14, 0x0C1C	; 0x800c1c <sys_sync_time_passed+0x2>
    6b68:	f0 90 1d 0c 	lds	r15, 0x0C1D	; 0x800c1d <sys_sync_time_passed+0x3>
    6b6c:	84 e0       	ldi	r24, 0x04	; 4
    6b6e:	95 e0       	ldi	r25, 0x05	; 5
    6b70:	93 dd       	rcall	.-1242   	; 0x6698 <printPgmString>
    6b72:	c7 01       	movw	r24, r14
    6b74:	b6 01       	movw	r22, r12
    6b76:	66 0f       	add	r22, r22
    6b78:	77 1f       	adc	r23, r23
    6b7a:	88 1f       	adc	r24, r24
    6b7c:	99 1f       	adc	r25, r25
    6b7e:	66 0f       	add	r22, r22
    6b80:	77 1f       	adc	r23, r23
    6b82:	88 1f       	adc	r24, r24
    6b84:	99 1f       	adc	r25, r25
    6b86:	0e 94 40 40 	call	0x8080	; 0x8080 <__floatunsisf>
    6b8a:	9b 01       	movw	r18, r22
    6b8c:	ac 01       	movw	r20, r24
    6b8e:	60 ec       	ldi	r22, 0xC0	; 192
    6b90:	71 ee       	ldi	r23, 0xE1	; 225
    6b92:	84 e6       	ldi	r24, 0x64	; 100
    6b94:	9c e4       	ldi	r25, 0x4C	; 76
    6b96:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <__divsf3>
    6b9a:	43 e0       	ldi	r20, 0x03	; 3
    6b9c:	3e de       	rcall	.-900    	; 0x681a <printFloat>
    6b9e:	47 df       	rcall	.-370    	; 0x6a2e <report_util_line_feed>
    6ba0:	ff 90       	pop	r15
    6ba2:	ef 90       	pop	r14
    6ba4:	df 90       	pop	r13
    6ba6:	cf 90       	pop	r12
    6ba8:	08 95       	ret

00006baa <report_feedback_message>:
    6baa:	cf 93       	push	r28
    6bac:	c8 2f       	mov	r28, r24
    6bae:	8e ef       	ldi	r24, 0xFE	; 254
    6bb0:	94 e0       	ldi	r25, 0x04	; 4
    6bb2:	72 dd       	rcall	.-1308   	; 0x6698 <printPgmString>
    6bb4:	8c 2f       	mov	r24, r28
    6bb6:	90 e0       	ldi	r25, 0x00	; 0
    6bb8:	fc 01       	movw	r30, r24
    6bba:	31 97       	sbiw	r30, 0x01	; 1
    6bbc:	eb 30       	cpi	r30, 0x0B	; 11
    6bbe:	f1 05       	cpc	r31, r1
    6bc0:	88 f5       	brcc	.+98     	; 0x6c24 <report_feedback_message+0x7a>
    6bc2:	88 27       	eor	r24, r24
    6bc4:	ec 5b       	subi	r30, 0xBC	; 188
    6bc6:	fe 4f       	sbci	r31, 0xFE	; 254
    6bc8:	8f 4f       	sbci	r24, 0xFF	; 255
    6bca:	0c 94 ed 42 	jmp	0x85da	; 0x85da <__tablejump2__>
    6bce:	8c ee       	ldi	r24, 0xEC	; 236
    6bd0:	94 e0       	ldi	r25, 0x04	; 4
    6bd2:	62 dd       	rcall	.-1340   	; 0x6698 <printPgmString>
    6bd4:	27 c0       	rjmp	.+78     	; 0x6c24 <report_feedback_message+0x7a>
    6bd6:	88 ed       	ldi	r24, 0xD8	; 216
    6bd8:	94 e0       	ldi	r25, 0x04	; 4
    6bda:	5e dd       	rcall	.-1348   	; 0x6698 <printPgmString>
    6bdc:	23 c0       	rjmp	.+70     	; 0x6c24 <report_feedback_message+0x7a>
    6bde:	86 ec       	ldi	r24, 0xC6	; 198
    6be0:	94 e0       	ldi	r25, 0x04	; 4
    6be2:	5a dd       	rcall	.-1356   	; 0x6698 <printPgmString>
    6be4:	1f c0       	rjmp	.+62     	; 0x6c24 <report_feedback_message+0x7a>
    6be6:	8e eb       	ldi	r24, 0xBE	; 190
    6be8:	94 e0       	ldi	r25, 0x04	; 4
    6bea:	56 dd       	rcall	.-1364   	; 0x6698 <printPgmString>
    6bec:	1b c0       	rjmp	.+54     	; 0x6c24 <report_feedback_message+0x7a>
    6bee:	85 eb       	ldi	r24, 0xB5	; 181
    6bf0:	94 e0       	ldi	r25, 0x04	; 4
    6bf2:	52 dd       	rcall	.-1372   	; 0x6698 <printPgmString>
    6bf4:	17 c0       	rjmp	.+46     	; 0x6c24 <report_feedback_message+0x7a>
    6bf6:	8a ea       	ldi	r24, 0xAA	; 170
    6bf8:	94 e0       	ldi	r25, 0x04	; 4
    6bfa:	4e dd       	rcall	.-1380   	; 0x6698 <printPgmString>
    6bfc:	13 c0       	rjmp	.+38     	; 0x6c24 <report_feedback_message+0x7a>
    6bfe:	8d e9       	ldi	r24, 0x9D	; 157
    6c00:	94 e0       	ldi	r25, 0x04	; 4
    6c02:	4a dd       	rcall	.-1388   	; 0x6698 <printPgmString>
    6c04:	0f c0       	rjmp	.+30     	; 0x6c24 <report_feedback_message+0x7a>
    6c06:	85 e9       	ldi	r24, 0x95	; 149
    6c08:	94 e0       	ldi	r25, 0x04	; 4
    6c0a:	46 dd       	rcall	.-1396   	; 0x6698 <printPgmString>
    6c0c:	0b c0       	rjmp	.+22     	; 0x6c24 <report_feedback_message+0x7a>
    6c0e:	82 e8       	ldi	r24, 0x82	; 130
    6c10:	94 e0       	ldi	r25, 0x04	; 4
    6c12:	42 dd       	rcall	.-1404   	; 0x6698 <printPgmString>
    6c14:	07 c0       	rjmp	.+14     	; 0x6c24 <report_feedback_message+0x7a>
    6c16:	80 e7       	ldi	r24, 0x70	; 112
    6c18:	94 e0       	ldi	r25, 0x04	; 4
    6c1a:	3e dd       	rcall	.-1412   	; 0x6698 <printPgmString>
    6c1c:	03 c0       	rjmp	.+6      	; 0x6c24 <report_feedback_message+0x7a>
    6c1e:	87 e6       	ldi	r24, 0x67	; 103
    6c20:	94 e0       	ldi	r25, 0x04	; 4
    6c22:	3a dd       	rcall	.-1420   	; 0x6698 <printPgmString>
    6c24:	08 df       	rcall	.-496    	; 0x6a36 <report_util_feedback_line_feed>
    6c26:	cf 91       	pop	r28
    6c28:	08 95       	ret

00006c2a <report_init_message>:
    6c2a:	8a e4       	ldi	r24, 0x4A	; 74
    6c2c:	94 e0       	ldi	r25, 0x04	; 4
    6c2e:	34 cd       	rjmp	.-1432   	; 0x6698 <printPgmString>
    6c30:	08 95       	ret

00006c32 <report_grbl_help>:
    6c32:	80 e0       	ldi	r24, 0x00	; 0
    6c34:	94 e0       	ldi	r25, 0x04	; 4
    6c36:	30 cd       	rjmp	.-1440   	; 0x6698 <printPgmString>
    6c38:	08 95       	ret

00006c3a <report_grbl_settings>:
    6c3a:	ef 92       	push	r14
    6c3c:	ff 92       	push	r15
    6c3e:	0f 93       	push	r16
    6c40:	1f 93       	push	r17
    6c42:	cf 93       	push	r28
    6c44:	df 93       	push	r29
    6c46:	00 ed       	ldi	r16, 0xD0	; 208
    6c48:	1e e0       	ldi	r17, 0x0E	; 14
    6c4a:	f8 01       	movw	r30, r16
    6c4c:	60 a9       	ldd	r22, Z+48	; 0x30
    6c4e:	70 e0       	ldi	r23, 0x00	; 0
    6c50:	80 e0       	ldi	r24, 0x00	; 0
    6c52:	1a df       	rcall	.-460    	; 0x6a88 <report_util_uint8_setting>
    6c54:	f8 01       	movw	r30, r16
    6c56:	63 a9       	ldd	r22, Z+51	; 0x33
    6c58:	70 e0       	ldi	r23, 0x00	; 0
    6c5a:	81 e0       	ldi	r24, 0x01	; 1
    6c5c:	15 df       	rcall	.-470    	; 0x6a88 <report_util_uint8_setting>
    6c5e:	f8 01       	movw	r30, r16
    6c60:	61 a9       	ldd	r22, Z+49	; 0x31
    6c62:	70 e0       	ldi	r23, 0x00	; 0
    6c64:	82 e0       	ldi	r24, 0x02	; 2
    6c66:	10 df       	rcall	.-480    	; 0x6a88 <report_util_uint8_setting>
    6c68:	f8 01       	movw	r30, r16
    6c6a:	62 a9       	ldd	r22, Z+50	; 0x32
    6c6c:	70 e0       	ldi	r23, 0x00	; 0
    6c6e:	83 e0       	ldi	r24, 0x03	; 3
    6c70:	0b df       	rcall	.-490    	; 0x6a88 <report_util_uint8_setting>
    6c72:	c5 e1       	ldi	r28, 0x15	; 21
    6c74:	df e0       	ldi	r29, 0x0F	; 15
    6c76:	68 81       	ld	r22, Y
    6c78:	62 fb       	bst	r22, 2
    6c7a:	66 27       	eor	r22, r22
    6c7c:	60 f9       	bld	r22, 0
    6c7e:	70 e0       	ldi	r23, 0x00	; 0
    6c80:	84 e0       	ldi	r24, 0x04	; 4
    6c82:	02 df       	rcall	.-508    	; 0x6a88 <report_util_uint8_setting>
    6c84:	68 81       	ld	r22, Y
    6c86:	66 fb       	bst	r22, 6
    6c88:	66 27       	eor	r22, r22
    6c8a:	60 f9       	bld	r22, 0
    6c8c:	70 e0       	ldi	r23, 0x00	; 0
    6c8e:	85 e0       	ldi	r24, 0x05	; 5
    6c90:	fb de       	rcall	.-522    	; 0x6a88 <report_util_uint8_setting>
    6c92:	88 81       	ld	r24, Y
    6c94:	08 2e       	mov	r0, r24
    6c96:	00 0c       	add	r0, r0
    6c98:	99 0b       	sbc	r25, r25
    6c9a:	69 2f       	mov	r22, r25
    6c9c:	66 1f       	adc	r22, r22
    6c9e:	66 27       	eor	r22, r22
    6ca0:	66 1f       	adc	r22, r22
    6ca2:	70 e0       	ldi	r23, 0x00	; 0
    6ca4:	86 e0       	ldi	r24, 0x06	; 6
    6ca6:	f0 de       	rcall	.-544    	; 0x6a88 <report_util_uint8_setting>
    6ca8:	f8 01       	movw	r30, r16
    6caa:	64 a9       	ldd	r22, Z+52	; 0x34
    6cac:	70 e0       	ldi	r23, 0x00	; 0
    6cae:	8a e0       	ldi	r24, 0x0A	; 10
    6cb0:	eb de       	rcall	.-554    	; 0x6a88 <report_util_uint8_setting>
    6cb2:	f8 01       	movw	r30, r16
    6cb4:	45 a9       	ldd	r20, Z+53	; 0x35
    6cb6:	56 a9       	ldd	r21, Z+54	; 0x36
    6cb8:	67 a9       	ldd	r22, Z+55	; 0x37
    6cba:	70 ad       	ldd	r23, Z+56	; 0x38
    6cbc:	23 e0       	ldi	r18, 0x03	; 3
    6cbe:	8b e0       	ldi	r24, 0x0B	; 11
    6cc0:	eb de       	rcall	.-554    	; 0x6a98 <report_util_float_setting>
    6cc2:	f8 01       	movw	r30, r16
    6cc4:	41 ad       	ldd	r20, Z+57	; 0x39
    6cc6:	52 ad       	ldd	r21, Z+58	; 0x3a
    6cc8:	63 ad       	ldd	r22, Z+59	; 0x3b
    6cca:	74 ad       	ldd	r23, Z+60	; 0x3c
    6ccc:	23 e0       	ldi	r18, 0x03	; 3
    6cce:	8c e0       	ldi	r24, 0x0C	; 12
    6cd0:	e3 de       	rcall	.-570    	; 0x6a98 <report_util_float_setting>
    6cd2:	68 81       	ld	r22, Y
    6cd4:	61 70       	andi	r22, 0x01	; 1
    6cd6:	70 e0       	ldi	r23, 0x00	; 0
    6cd8:	8d e0       	ldi	r24, 0x0D	; 13
    6cda:	d6 de       	rcall	.-596    	; 0x6a88 <report_util_uint8_setting>
    6cdc:	68 81       	ld	r22, Y
    6cde:	65 fb       	bst	r22, 5
    6ce0:	66 27       	eor	r22, r22
    6ce2:	60 f9       	bld	r22, 0
    6ce4:	70 e0       	ldi	r23, 0x00	; 0
    6ce6:	84 e1       	ldi	r24, 0x14	; 20
    6ce8:	cf de       	rcall	.-610    	; 0x6a88 <report_util_uint8_setting>
    6cea:	68 81       	ld	r22, Y
    6cec:	63 fb       	bst	r22, 3
    6cee:	66 27       	eor	r22, r22
    6cf0:	60 f9       	bld	r22, 0
    6cf2:	70 e0       	ldi	r23, 0x00	; 0
    6cf4:	85 e1       	ldi	r24, 0x15	; 21
    6cf6:	c8 de       	rcall	.-624    	; 0x6a88 <report_util_uint8_setting>
    6cf8:	68 81       	ld	r22, Y
    6cfa:	62 95       	swap	r22
    6cfc:	61 70       	andi	r22, 0x01	; 1
    6cfe:	70 e0       	ldi	r23, 0x00	; 0
    6d00:	86 e1       	ldi	r24, 0x16	; 22
    6d02:	c2 de       	rcall	.-636    	; 0x6a88 <report_util_uint8_setting>
    6d04:	60 91 16 0f 	lds	r22, 0x0F16	; 0x800f16 <settings+0x46>
    6d08:	70 e0       	ldi	r23, 0x00	; 0
    6d0a:	87 e1       	ldi	r24, 0x17	; 23
    6d0c:	bd de       	rcall	.-646    	; 0x6a88 <report_util_uint8_setting>
    6d0e:	40 91 17 0f 	lds	r20, 0x0F17	; 0x800f17 <settings+0x47>
    6d12:	50 91 18 0f 	lds	r21, 0x0F18	; 0x800f18 <settings+0x48>
    6d16:	60 91 19 0f 	lds	r22, 0x0F19	; 0x800f19 <settings+0x49>
    6d1a:	70 91 1a 0f 	lds	r23, 0x0F1A	; 0x800f1a <settings+0x4a>
    6d1e:	23 e0       	ldi	r18, 0x03	; 3
    6d20:	88 e1       	ldi	r24, 0x18	; 24
    6d22:	ba de       	rcall	.-652    	; 0x6a98 <report_util_float_setting>
    6d24:	40 91 1b 0f 	lds	r20, 0x0F1B	; 0x800f1b <settings+0x4b>
    6d28:	50 91 1c 0f 	lds	r21, 0x0F1C	; 0x800f1c <settings+0x4c>
    6d2c:	60 91 1d 0f 	lds	r22, 0x0F1D	; 0x800f1d <settings+0x4d>
    6d30:	70 91 1e 0f 	lds	r23, 0x0F1E	; 0x800f1e <settings+0x4e>
    6d34:	23 e0       	ldi	r18, 0x03	; 3
    6d36:	89 e1       	ldi	r24, 0x19	; 25
    6d38:	af de       	rcall	.-674    	; 0x6a98 <report_util_float_setting>
    6d3a:	60 91 1f 0f 	lds	r22, 0x0F1F	; 0x800f1f <settings+0x4f>
    6d3e:	70 91 20 0f 	lds	r23, 0x0F20	; 0x800f20 <settings+0x50>
    6d42:	8a e1       	ldi	r24, 0x1A	; 26
    6d44:	a1 de       	rcall	.-702    	; 0x6a88 <report_util_uint8_setting>
    6d46:	40 91 21 0f 	lds	r20, 0x0F21	; 0x800f21 <settings+0x51>
    6d4a:	50 91 22 0f 	lds	r21, 0x0F22	; 0x800f22 <settings+0x52>
    6d4e:	60 91 23 0f 	lds	r22, 0x0F23	; 0x800f23 <settings+0x53>
    6d52:	70 91 24 0f 	lds	r23, 0x0F24	; 0x800f24 <settings+0x54>
    6d56:	23 e0       	ldi	r18, 0x03	; 3
    6d58:	8b e1       	ldi	r24, 0x1B	; 27
    6d5a:	9e de       	rcall	.-708    	; 0x6a98 <report_util_float_setting>
    6d5c:	40 91 0d 0f 	lds	r20, 0x0F0D	; 0x800f0d <settings+0x3d>
    6d60:	50 91 0e 0f 	lds	r21, 0x0F0E	; 0x800f0e <settings+0x3e>
    6d64:	60 91 0f 0f 	lds	r22, 0x0F0F	; 0x800f0f <settings+0x3f>
    6d68:	70 91 10 0f 	lds	r23, 0x0F10	; 0x800f10 <settings+0x40>
    6d6c:	20 e0       	ldi	r18, 0x00	; 0
    6d6e:	8e e1       	ldi	r24, 0x1E	; 30
    6d70:	93 de       	rcall	.-730    	; 0x6a98 <report_util_float_setting>
    6d72:	40 91 11 0f 	lds	r20, 0x0F11	; 0x800f11 <settings+0x41>
    6d76:	50 91 12 0f 	lds	r21, 0x0F12	; 0x800f12 <settings+0x42>
    6d7a:	60 91 13 0f 	lds	r22, 0x0F13	; 0x800f13 <settings+0x43>
    6d7e:	70 91 14 0f 	lds	r23, 0x0F14	; 0x800f14 <settings+0x44>
    6d82:	20 e0       	ldi	r18, 0x00	; 0
    6d84:	8f e1       	ldi	r24, 0x1F	; 31
    6d86:	88 de       	rcall	.-752    	; 0x6a98 <report_util_float_setting>
    6d88:	68 81       	ld	r22, Y
    6d8a:	66 95       	lsr	r22
    6d8c:	61 70       	andi	r22, 0x01	; 1
    6d8e:	70 e0       	ldi	r23, 0x00	; 0
    6d90:	80 e2       	ldi	r24, 0x20	; 32
    6d92:	7a de       	rcall	.-780    	; 0x6a88 <report_util_uint8_setting>
    6d94:	0f 2e       	mov	r0, r31
    6d96:	f4 e6       	ldi	r31, 0x64	; 100
    6d98:	ff 2e       	mov	r15, r31
    6d9a:	f0 2d       	mov	r31, r0
    6d9c:	d0 e0       	ldi	r29, 0x00	; 0
    6d9e:	3f c0       	rjmp	.+126    	; 0x6e1e <report_grbl_settings+0x1e4>
    6da0:	d1 30       	cpi	r29, 0x01	; 1
    6da2:	79 f0       	breq	.+30     	; 0x6dc2 <report_grbl_settings+0x188>
    6da4:	28 f0       	brcs	.+10     	; 0x6db0 <report_grbl_settings+0x176>
    6da6:	d2 30       	cpi	r29, 0x02	; 2
    6da8:	a9 f0       	breq	.+42     	; 0x6dd4 <report_grbl_settings+0x19a>
    6daa:	d3 30       	cpi	r29, 0x03	; 3
    6dac:	21 f1       	breq	.+72     	; 0x6df6 <report_grbl_settings+0x1bc>
    6dae:	2c c0       	rjmp	.+88     	; 0x6e08 <report_grbl_settings+0x1ce>
    6db0:	f8 01       	movw	r30, r16
    6db2:	40 81       	ld	r20, Z
    6db4:	51 81       	ldd	r21, Z+1	; 0x01
    6db6:	62 81       	ldd	r22, Z+2	; 0x02
    6db8:	73 81       	ldd	r23, Z+3	; 0x03
    6dba:	23 e0       	ldi	r18, 0x03	; 3
    6dbc:	8c 2f       	mov	r24, r28
    6dbe:	6c de       	rcall	.-808    	; 0x6a98 <report_util_float_setting>
    6dc0:	23 c0       	rjmp	.+70     	; 0x6e08 <report_grbl_settings+0x1ce>
    6dc2:	f8 01       	movw	r30, r16
    6dc4:	44 85       	ldd	r20, Z+12	; 0x0c
    6dc6:	55 85       	ldd	r21, Z+13	; 0x0d
    6dc8:	66 85       	ldd	r22, Z+14	; 0x0e
    6dca:	77 85       	ldd	r23, Z+15	; 0x0f
    6dcc:	23 e0       	ldi	r18, 0x03	; 3
    6dce:	8c 2f       	mov	r24, r28
    6dd0:	63 de       	rcall	.-826    	; 0x6a98 <report_util_float_setting>
    6dd2:	1a c0       	rjmp	.+52     	; 0x6e08 <report_grbl_settings+0x1ce>
    6dd4:	20 e0       	ldi	r18, 0x00	; 0
    6dd6:	30 e0       	ldi	r19, 0x00	; 0
    6dd8:	41 e6       	ldi	r20, 0x61	; 97
    6dda:	55 e4       	ldi	r21, 0x45	; 69
    6ddc:	f8 01       	movw	r30, r16
    6dde:	60 8d       	ldd	r22, Z+24	; 0x18
    6de0:	71 8d       	ldd	r23, Z+25	; 0x19
    6de2:	82 8d       	ldd	r24, Z+26	; 0x1a
    6de4:	93 8d       	ldd	r25, Z+27	; 0x1b
    6de6:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <__divsf3>
    6dea:	ab 01       	movw	r20, r22
    6dec:	bc 01       	movw	r22, r24
    6dee:	23 e0       	ldi	r18, 0x03	; 3
    6df0:	8c 2f       	mov	r24, r28
    6df2:	52 de       	rcall	.-860    	; 0x6a98 <report_util_float_setting>
    6df4:	09 c0       	rjmp	.+18     	; 0x6e08 <report_grbl_settings+0x1ce>
    6df6:	f8 01       	movw	r30, r16
    6df8:	44 a1       	ldd	r20, Z+36	; 0x24
    6dfa:	55 a1       	ldd	r21, Z+37	; 0x25
    6dfc:	66 a1       	ldd	r22, Z+38	; 0x26
    6dfe:	77 a1       	ldd	r23, Z+39	; 0x27
    6e00:	70 58       	subi	r23, 0x80	; 128
    6e02:	23 e0       	ldi	r18, 0x03	; 3
    6e04:	8c 2f       	mov	r24, r28
    6e06:	48 de       	rcall	.-880    	; 0x6a98 <report_util_float_setting>
    6e08:	0c 5f       	subi	r16, 0xFC	; 252
    6e0a:	1f 4f       	sbci	r17, 0xFF	; 255
    6e0c:	cf 5f       	subi	r28, 0xFF	; 255
    6e0e:	ce 11       	cpse	r28, r14
    6e10:	c7 cf       	rjmp	.-114    	; 0x6da0 <report_grbl_settings+0x166>
    6e12:	fa e0       	ldi	r31, 0x0A	; 10
    6e14:	ff 0e       	add	r15, r31
    6e16:	df 5f       	subi	r29, 0xFF	; 255
    6e18:	8c e8       	ldi	r24, 0x8C	; 140
    6e1a:	f8 16       	cp	r15, r24
    6e1c:	49 f0       	breq	.+18     	; 0x6e30 <report_grbl_settings+0x1f6>
    6e1e:	00 ed       	ldi	r16, 0xD0	; 208
    6e20:	1e e0       	ldi	r17, 0x0E	; 14
    6e22:	0f 2e       	mov	r0, r31
    6e24:	f3 e0       	ldi	r31, 0x03	; 3
    6e26:	ef 2e       	mov	r14, r31
    6e28:	f0 2d       	mov	r31, r0
    6e2a:	ef 0c       	add	r14, r15
    6e2c:	cf 2d       	mov	r28, r15
    6e2e:	b8 cf       	rjmp	.-144    	; 0x6da0 <report_grbl_settings+0x166>
    6e30:	df 91       	pop	r29
    6e32:	cf 91       	pop	r28
    6e34:	1f 91       	pop	r17
    6e36:	0f 91       	pop	r16
    6e38:	ff 90       	pop	r15
    6e3a:	ef 90       	pop	r14
    6e3c:	08 95       	ret

00006e3e <report_probe_parameters>:
    6e3e:	cf 93       	push	r28
    6e40:	df 93       	push	r29
    6e42:	cd b7       	in	r28, 0x3d	; 61
    6e44:	de b7       	in	r29, 0x3e	; 62
    6e46:	2c 97       	sbiw	r28, 0x0c	; 12
    6e48:	0f b6       	in	r0, 0x3f	; 63
    6e4a:	f8 94       	cli
    6e4c:	de bf       	out	0x3e, r29	; 62
    6e4e:	0f be       	out	0x3f, r0	; 63
    6e50:	cd bf       	out	0x3d, r28	; 61
    6e52:	8a ef       	ldi	r24, 0xFA	; 250
    6e54:	93 e0       	ldi	r25, 0x03	; 3
    6e56:	20 dc       	rcall	.-1984   	; 0x6698 <printPgmString>
    6e58:	67 e3       	ldi	r22, 0x37	; 55
    6e5a:	7c e0       	ldi	r23, 0x0C	; 12
    6e5c:	ce 01       	movw	r24, r28
    6e5e:	01 96       	adiw	r24, 0x01	; 1
    6e60:	20 d4       	rcall	.+2112   	; 0x76a2 <system_convert_array_steps_to_mpos>
    6e62:	ce 01       	movw	r24, r28
    6e64:	01 96       	adiw	r24, 0x01	; 1
    6e66:	ec dd       	rcall	.-1064   	; 0x6a40 <report_util_axis_values>
    6e68:	8a e3       	ldi	r24, 0x3A	; 58
    6e6a:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    6e6e:	80 91 23 0c 	lds	r24, 0x0C23	; 0x800c23 <sys+0x5>
    6e72:	24 dc       	rcall	.-1976   	; 0x66bc <print_uint8_base10>
    6e74:	e0 dd       	rcall	.-1088   	; 0x6a36 <report_util_feedback_line_feed>
    6e76:	2c 96       	adiw	r28, 0x0c	; 12
    6e78:	0f b6       	in	r0, 0x3f	; 63
    6e7a:	f8 94       	cli
    6e7c:	de bf       	out	0x3e, r29	; 62
    6e7e:	0f be       	out	0x3f, r0	; 63
    6e80:	cd bf       	out	0x3d, r28	; 61
    6e82:	df 91       	pop	r29
    6e84:	cf 91       	pop	r28
    6e86:	08 95       	ret

00006e88 <report_ngc_parameters>:
    6e88:	0f 93       	push	r16
    6e8a:	1f 93       	push	r17
    6e8c:	cf 93       	push	r28
    6e8e:	df 93       	push	r29
    6e90:	cd b7       	in	r28, 0x3d	; 61
    6e92:	de b7       	in	r29, 0x3e	; 62
    6e94:	2c 97       	sbiw	r28, 0x0c	; 12
    6e96:	0f b6       	in	r0, 0x3f	; 63
    6e98:	f8 94       	cli
    6e9a:	de bf       	out	0x3e, r29	; 62
    6e9c:	0f be       	out	0x3f, r0	; 63
    6e9e:	cd bf       	out	0x3d, r28	; 61
    6ea0:	01 e0       	ldi	r16, 0x01	; 1
    6ea2:	01 c0       	rjmp	.+2      	; 0x6ea6 <report_ngc_parameters+0x1e>
    6ea4:	0f 5f       	subi	r16, 0xFF	; 255
    6ea6:	1f ef       	ldi	r17, 0xFF	; 255
    6ea8:	10 0f       	add	r17, r16
    6eaa:	be 01       	movw	r22, r28
    6eac:	6f 5f       	subi	r22, 0xFF	; 255
    6eae:	7f 4f       	sbci	r23, 0xFF	; 255
    6eb0:	81 2f       	mov	r24, r17
    6eb2:	0e 94 1c 26 	call	0x4c38	; 0x4c38 <settings_read_coord_data>
    6eb6:	81 11       	cpse	r24, r1
    6eb8:	03 c0       	rjmp	.+6      	; 0x6ec0 <report_ngc_parameters+0x38>
    6eba:	87 e0       	ldi	r24, 0x07	; 7
    6ebc:	01 de       	rcall	.-1022   	; 0x6ac0 <report_status_message>
    6ebe:	40 c0       	rjmp	.+128    	; 0x6f40 <report_ngc_parameters+0xb8>
    6ec0:	87 ef       	ldi	r24, 0xF7	; 247
    6ec2:	93 e0       	ldi	r25, 0x03	; 3
    6ec4:	e9 db       	rcall	.-2094   	; 0x6698 <printPgmString>
    6ec6:	16 30       	cpi	r17, 0x06	; 6
    6ec8:	19 f0       	breq	.+6      	; 0x6ed0 <report_ngc_parameters+0x48>
    6eca:	17 30       	cpi	r17, 0x07	; 7
    6ecc:	61 f0       	breq	.+24     	; 0x6ee6 <report_ngc_parameters+0x5e>
    6ece:	16 c0       	rjmp	.+44     	; 0x6efc <report_ngc_parameters+0x74>
    6ed0:	84 ef       	ldi	r24, 0xF4	; 244
    6ed2:	93 e0       	ldi	r25, 0x03	; 3
    6ed4:	e1 db       	rcall	.-2110   	; 0x6698 <printPgmString>
    6ed6:	8a e3       	ldi	r24, 0x3A	; 58
    6ed8:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    6edc:	ce 01       	movw	r24, r28
    6ede:	01 96       	adiw	r24, 0x01	; 1
    6ee0:	af dd       	rcall	.-1186   	; 0x6a40 <report_util_axis_values>
    6ee2:	a9 dd       	rcall	.-1198   	; 0x6a36 <report_util_feedback_line_feed>
    6ee4:	df cf       	rjmp	.-66     	; 0x6ea4 <report_ngc_parameters+0x1c>
    6ee6:	81 ef       	ldi	r24, 0xF1	; 241
    6ee8:	93 e0       	ldi	r25, 0x03	; 3
    6eea:	d6 db       	rcall	.-2132   	; 0x6698 <printPgmString>
    6eec:	8a e3       	ldi	r24, 0x3A	; 58
    6eee:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    6ef2:	ce 01       	movw	r24, r28
    6ef4:	01 96       	adiw	r24, 0x01	; 1
    6ef6:	a4 dd       	rcall	.-1208   	; 0x6a40 <report_util_axis_values>
    6ef8:	9e dd       	rcall	.-1220   	; 0x6a36 <report_util_feedback_line_feed>
    6efa:	0d c0       	rjmp	.+26     	; 0x6f16 <report_ngc_parameters+0x8e>
    6efc:	85 e3       	ldi	r24, 0x35	; 53
    6efe:	80 0f       	add	r24, r16
    6f00:	dd db       	rcall	.-2118   	; 0x66bc <print_uint8_base10>
    6f02:	8a e3       	ldi	r24, 0x3A	; 58
    6f04:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    6f08:	ce 01       	movw	r24, r28
    6f0a:	01 96       	adiw	r24, 0x01	; 1
    6f0c:	99 dd       	rcall	.-1230   	; 0x6a40 <report_util_axis_values>
    6f0e:	93 dd       	rcall	.-1242   	; 0x6a36 <report_util_feedback_line_feed>
    6f10:	08 30       	cpi	r16, 0x08	; 8
    6f12:	08 f4       	brcc	.+2      	; 0x6f16 <report_ngc_parameters+0x8e>
    6f14:	c7 cf       	rjmp	.-114    	; 0x6ea4 <report_ngc_parameters+0x1c>
    6f16:	8b ee       	ldi	r24, 0xEB	; 235
    6f18:	93 e0       	ldi	r25, 0x03	; 3
    6f1a:	be db       	rcall	.-2180   	; 0x6698 <printPgmString>
    6f1c:	86 e8       	ldi	r24, 0x86	; 134
    6f1e:	9c e0       	ldi	r25, 0x0C	; 12
    6f20:	8f dd       	rcall	.-1250   	; 0x6a40 <report_util_axis_values>
    6f22:	89 dd       	rcall	.-1262   	; 0x6a36 <report_util_feedback_line_feed>
    6f24:	85 ee       	ldi	r24, 0xE5	; 229
    6f26:	93 e0       	ldi	r25, 0x03	; 3
    6f28:	b7 db       	rcall	.-2194   	; 0x6698 <printPgmString>
    6f2a:	60 91 92 0c 	lds	r22, 0x0C92	; 0x800c92 <gc_state+0x3c>
    6f2e:	70 91 93 0c 	lds	r23, 0x0C93	; 0x800c93 <gc_state+0x3d>
    6f32:	80 91 94 0c 	lds	r24, 0x0C94	; 0x800c94 <gc_state+0x3e>
    6f36:	90 91 95 0c 	lds	r25, 0x0C95	; 0x800c95 <gc_state+0x3f>
    6f3a:	20 dd       	rcall	.-1472   	; 0x697c <printFloat_CoordValue>
    6f3c:	7c dd       	rcall	.-1288   	; 0x6a36 <report_util_feedback_line_feed>
    6f3e:	7f df       	rcall	.-258    	; 0x6e3e <report_probe_parameters>
    6f40:	2c 96       	adiw	r28, 0x0c	; 12
    6f42:	0f b6       	in	r0, 0x3f	; 63
    6f44:	f8 94       	cli
    6f46:	de bf       	out	0x3e, r29	; 62
    6f48:	0f be       	out	0x3f, r0	; 63
    6f4a:	cd bf       	out	0x3d, r28	; 61
    6f4c:	df 91       	pop	r29
    6f4e:	cf 91       	pop	r28
    6f50:	1f 91       	pop	r17
    6f52:	0f 91       	pop	r16
    6f54:	08 95       	ret

00006f56 <report_gcode_modes>:
    6f56:	cf 93       	push	r28
    6f58:	df 93       	push	r29
    6f5a:	8f ed       	ldi	r24, 0xDF	; 223
    6f5c:	93 e0       	ldi	r25, 0x03	; 3
    6f5e:	9c db       	rcall	.-2248   	; 0x6698 <printPgmString>
    6f60:	80 91 56 0c 	lds	r24, 0x0C56	; 0x800c56 <gc_state>
    6f64:	8c 38       	cpi	r24, 0x8C	; 140
    6f66:	40 f0       	brcs	.+16     	; 0x6f78 <report_gcode_modes+0x22>
    6f68:	8b ed       	ldi	r24, 0xDB	; 219
    6f6a:	93 e0       	ldi	r25, 0x03	; 3
    6f6c:	95 db       	rcall	.-2262   	; 0x6698 <printPgmString>
    6f6e:	80 91 56 0c 	lds	r24, 0x0C56	; 0x800c56 <gc_state>
    6f72:	8a 58       	subi	r24, 0x8A	; 138
    6f74:	a3 db       	rcall	.-2234   	; 0x66bc <print_uint8_base10>
    6f76:	01 c0       	rjmp	.+2      	; 0x6f7a <report_gcode_modes+0x24>
    6f78:	a1 db       	rcall	.-2238   	; 0x66bc <print_uint8_base10>
    6f7a:	8f ec       	ldi	r24, 0xCF	; 207
    6f7c:	93 e0       	ldi	r25, 0x03	; 3
    6f7e:	8c db       	rcall	.-2280   	; 0x6698 <printPgmString>
    6f80:	c6 e5       	ldi	r28, 0x56	; 86
    6f82:	dc e0       	ldi	r29, 0x0C	; 12
    6f84:	8e 81       	ldd	r24, Y+6	; 0x06
    6f86:	8a 5c       	subi	r24, 0xCA	; 202
    6f88:	99 db       	rcall	.-2254   	; 0x66bc <print_uint8_base10>
    6f8a:	8f ec       	ldi	r24, 0xCF	; 207
    6f8c:	93 e0       	ldi	r25, 0x03	; 3
    6f8e:	84 db       	rcall	.-2296   	; 0x6698 <printPgmString>
    6f90:	8c 81       	ldd	r24, Y+4	; 0x04
    6f92:	8f 5e       	subi	r24, 0xEF	; 239
    6f94:	93 db       	rcall	.-2266   	; 0x66bc <print_uint8_base10>
    6f96:	8f ec       	ldi	r24, 0xCF	; 207
    6f98:	93 e0       	ldi	r25, 0x03	; 3
    6f9a:	7e db       	rcall	.-2308   	; 0x6698 <printPgmString>
    6f9c:	9a 81       	ldd	r25, Y+2	; 0x02
    6f9e:	85 e1       	ldi	r24, 0x15	; 21
    6fa0:	89 1b       	sub	r24, r25
    6fa2:	8c db       	rcall	.-2280   	; 0x66bc <print_uint8_base10>
    6fa4:	8f ec       	ldi	r24, 0xCF	; 207
    6fa6:	93 e0       	ldi	r25, 0x03	; 3
    6fa8:	77 db       	rcall	.-2322   	; 0x6698 <printPgmString>
    6faa:	8b 81       	ldd	r24, Y+3	; 0x03
    6fac:	86 5a       	subi	r24, 0xA6	; 166
    6fae:	86 db       	rcall	.-2292   	; 0x66bc <print_uint8_base10>
    6fb0:	8f ec       	ldi	r24, 0xCF	; 207
    6fb2:	93 e0       	ldi	r25, 0x03	; 3
    6fb4:	71 db       	rcall	.-2334   	; 0x6698 <printPgmString>
    6fb6:	99 81       	ldd	r25, Y+1	; 0x01
    6fb8:	8e e5       	ldi	r24, 0x5E	; 94
    6fba:	89 1b       	sub	r24, r25
    6fbc:	7f db       	rcall	.-2306   	; 0x66bc <print_uint8_base10>
    6fbe:	8f 81       	ldd	r24, Y+7	; 0x07
    6fc0:	88 23       	and	r24, r24
    6fc2:	89 f0       	breq	.+34     	; 0x6fe6 <report_gcode_modes+0x90>
    6fc4:	8c ec       	ldi	r24, 0xCC	; 204
    6fc6:	93 e0       	ldi	r25, 0x03	; 3
    6fc8:	67 db       	rcall	.-2354   	; 0x6698 <printPgmString>
    6fca:	80 91 5d 0c 	lds	r24, 0x0C5D	; 0x800c5d <gc_state+0x7>
    6fce:	83 30       	cpi	r24, 0x03	; 3
    6fd0:	29 f0       	breq	.+10     	; 0x6fdc <report_gcode_modes+0x86>
    6fd2:	8e 31       	cpi	r24, 0x1E	; 30
    6fd4:	39 f0       	breq	.+14     	; 0x6fe4 <report_gcode_modes+0x8e>
    6fd6:	82 30       	cpi	r24, 0x02	; 2
    6fd8:	31 f4       	brne	.+12     	; 0x6fe6 <report_gcode_modes+0x90>
    6fda:	04 c0       	rjmp	.+8      	; 0x6fe4 <report_gcode_modes+0x8e>
    6fdc:	80 e3       	ldi	r24, 0x30	; 48
    6fde:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    6fe2:	01 c0       	rjmp	.+2      	; 0x6fe6 <report_gcode_modes+0x90>
    6fe4:	6b db       	rcall	.-2346   	; 0x66bc <print_uint8_base10>
    6fe6:	8c ec       	ldi	r24, 0xCC	; 204
    6fe8:	93 e0       	ldi	r25, 0x03	; 3
    6fea:	56 db       	rcall	.-2388   	; 0x6698 <printPgmString>
    6fec:	80 91 5f 0c 	lds	r24, 0x0C5F	; 0x800c5f <gc_state+0x9>
    6ff0:	80 31       	cpi	r24, 0x10	; 16
    6ff2:	29 f0       	breq	.+10     	; 0x6ffe <report_gcode_modes+0xa8>
    6ff4:	80 32       	cpi	r24, 0x20	; 32
    6ff6:	39 f0       	breq	.+14     	; 0x7006 <report_gcode_modes+0xb0>
    6ff8:	81 11       	cpse	r24, r1
    6ffa:	0c c0       	rjmp	.+24     	; 0x7014 <report_gcode_modes+0xbe>
    6ffc:	08 c0       	rjmp	.+16     	; 0x700e <report_gcode_modes+0xb8>
    6ffe:	83 e3       	ldi	r24, 0x33	; 51
    7000:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    7004:	07 c0       	rjmp	.+14     	; 0x7014 <report_gcode_modes+0xbe>
    7006:	84 e3       	ldi	r24, 0x34	; 52
    7008:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    700c:	03 c0       	rjmp	.+6      	; 0x7014 <report_gcode_modes+0xbe>
    700e:	85 e3       	ldi	r24, 0x35	; 53
    7010:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    7014:	8c ec       	ldi	r24, 0xCC	; 204
    7016:	93 e0       	ldi	r25, 0x03	; 3
    7018:	3f db       	rcall	.-2434   	; 0x6698 <printPgmString>
    701a:	80 91 5e 0c 	lds	r24, 0x0C5E	; 0x800c5e <gc_state+0x8>
    701e:	88 23       	and	r24, r24
    7020:	61 f0       	breq	.+24     	; 0x703a <report_gcode_modes+0xe4>
    7022:	1c f4       	brge	.+6      	; 0x702a <report_gcode_modes+0xd4>
    7024:	87 e3       	ldi	r24, 0x37	; 55
    7026:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    702a:	80 91 5e 0c 	lds	r24, 0x0C5E	; 0x800c5e <gc_state+0x8>
    702e:	86 ff       	sbrs	r24, 6
    7030:	07 c0       	rjmp	.+14     	; 0x7040 <report_gcode_modes+0xea>
    7032:	88 e3       	ldi	r24, 0x38	; 56
    7034:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    7038:	03 c0       	rjmp	.+6      	; 0x7040 <report_gcode_modes+0xea>
    703a:	89 e3       	ldi	r24, 0x39	; 57
    703c:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    7040:	88 ed       	ldi	r24, 0xD8	; 216
    7042:	93 e0       	ldi	r25, 0x03	; 3
    7044:	29 db       	rcall	.-2478   	; 0x6698 <printPgmString>
    7046:	c6 e5       	ldi	r28, 0x56	; 86
    7048:	dc e0       	ldi	r29, 0x0C	; 12
    704a:	8b 89       	ldd	r24, Y+19	; 0x13
    704c:	37 db       	rcall	.-2450   	; 0x66bc <print_uint8_base10>
    704e:	85 ed       	ldi	r24, 0xD5	; 213
    7050:	93 e0       	ldi	r25, 0x03	; 3
    7052:	22 db       	rcall	.-2492   	; 0x6698 <printPgmString>
    7054:	6f 85       	ldd	r22, Y+15	; 0x0f
    7056:	78 89       	ldd	r23, Y+16	; 0x10
    7058:	89 89       	ldd	r24, Y+17	; 0x11
    705a:	9a 89       	ldd	r25, Y+18	; 0x12
    705c:	9f dc       	rcall	.-1730   	; 0x699c <printFloat_RateValue>
    705e:	82 ed       	ldi	r24, 0xD2	; 210
    7060:	93 e0       	ldi	r25, 0x03	; 3
    7062:	1a db       	rcall	.-2508   	; 0x6698 <printPgmString>
    7064:	6b 85       	ldd	r22, Y+11	; 0x0b
    7066:	7c 85       	ldd	r23, Y+12	; 0x0c
    7068:	8d 85       	ldd	r24, Y+13	; 0x0d
    706a:	9e 85       	ldd	r25, Y+14	; 0x0e
    706c:	40 e0       	ldi	r20, 0x00	; 0
    706e:	d5 db       	rcall	.-2134   	; 0x681a <printFloat>
    7070:	e2 dc       	rcall	.-1596   	; 0x6a36 <report_util_feedback_line_feed>
    7072:	df 91       	pop	r29
    7074:	cf 91       	pop	r28
    7076:	08 95       	ret

00007078 <report_startup_line>:
    7078:	1f 93       	push	r17
    707a:	cf 93       	push	r28
    707c:	df 93       	push	r29
    707e:	18 2f       	mov	r17, r24
    7080:	eb 01       	movw	r28, r22
    7082:	89 ec       	ldi	r24, 0xC9	; 201
    7084:	93 e0       	ldi	r25, 0x03	; 3
    7086:	08 db       	rcall	.-2544   	; 0x6698 <printPgmString>
    7088:	81 2f       	mov	r24, r17
    708a:	18 db       	rcall	.-2512   	; 0x66bc <print_uint8_base10>
    708c:	8d e3       	ldi	r24, 0x3D	; 61
    708e:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    7092:	ce 01       	movw	r24, r28
    7094:	f2 da       	rcall	.-2588   	; 0x667a <printString>
    7096:	cb dc       	rcall	.-1642   	; 0x6a2e <report_util_line_feed>
    7098:	df 91       	pop	r29
    709a:	cf 91       	pop	r28
    709c:	1f 91       	pop	r17
    709e:	08 95       	ret

000070a0 <report_execute_startup_message>:
    70a0:	0f 93       	push	r16
    70a2:	1f 93       	push	r17
    70a4:	cf 93       	push	r28
    70a6:	8c 01       	movw	r16, r24
    70a8:	c6 2f       	mov	r28, r22
    70aa:	8e e3       	ldi	r24, 0x3E	; 62
    70ac:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    70b0:	c8 01       	movw	r24, r16
    70b2:	e3 da       	rcall	.-2618   	; 0x667a <printString>
    70b4:	8a e3       	ldi	r24, 0x3A	; 58
    70b6:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    70ba:	8c 2f       	mov	r24, r28
    70bc:	01 dd       	rcall	.-1534   	; 0x6ac0 <report_status_message>
    70be:	cf 91       	pop	r28
    70c0:	1f 91       	pop	r17
    70c2:	0f 91       	pop	r16
    70c4:	08 95       	ret

000070c6 <report_build_info>:
    70c6:	cf 93       	push	r28
    70c8:	df 93       	push	r29
    70ca:	ec 01       	movw	r28, r24
    70cc:	80 eb       	ldi	r24, 0xB0	; 176
    70ce:	93 e0       	ldi	r25, 0x03	; 3
    70d0:	e3 da       	rcall	.-2618   	; 0x6698 <printPgmString>
    70d2:	ce 01       	movw	r24, r28
    70d4:	d2 da       	rcall	.-2652   	; 0x667a <printString>
    70d6:	af dc       	rcall	.-1698   	; 0x6a36 <report_util_feedback_line_feed>
    70d8:	8a ea       	ldi	r24, 0xAA	; 170
    70da:	93 e0       	ldi	r25, 0x03	; 3
    70dc:	dd da       	rcall	.-2630   	; 0x6698 <printPgmString>
    70de:	86 e5       	ldi	r24, 0x56	; 86
    70e0:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    70e4:	8e e4       	ldi	r24, 0x4E	; 78
    70e6:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    70ea:	8d e4       	ldi	r24, 0x4D	; 77
    70ec:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    70f0:	8b e2       	ldi	r24, 0x2B	; 43
    70f2:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    70f6:	88 e4       	ldi	r24, 0x48	; 72
    70f8:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    70fc:	83 e5       	ldi	r24, 0x53	; 83
    70fe:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    7102:	8c e4       	ldi	r24, 0x4C	; 76
    7104:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    7108:	8c e2       	ldi	r24, 0x2C	; 44
    710a:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    710e:	83 e2       	ldi	r24, 0x23	; 35
    7110:	d5 da       	rcall	.-2646   	; 0x66bc <print_uint8_base10>
    7112:	8c e2       	ldi	r24, 0x2C	; 44
    7114:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    7118:	8f ef       	ldi	r24, 0xFF	; 255
    711a:	d0 da       	rcall	.-2656   	; 0x66bc <print_uint8_base10>
    711c:	8c dc       	rcall	.-1768   	; 0x6a36 <report_util_feedback_line_feed>
    711e:	df 91       	pop	r29
    7120:	cf 91       	pop	r28
    7122:	08 95       	ret

00007124 <report_realtime_status>:
 // and the actual location of the CNC machine. Users may change the following function to their
 // specific needs, but the desired real-time data report must be as short as possible. This is
 // requires as it minimizes the computational overhead and allows grbl to keep running smoothly,
 // especially during g-code programs with fast, short line segments and high frequency reports (5-20Hz).
void report_realtime_status()
{
    7124:	4f 92       	push	r4
    7126:	5f 92       	push	r5
    7128:	6f 92       	push	r6
    712a:	7f 92       	push	r7
    712c:	8f 92       	push	r8
    712e:	9f 92       	push	r9
    7130:	af 92       	push	r10
    7132:	bf 92       	push	r11
    7134:	cf 92       	push	r12
    7136:	df 92       	push	r13
    7138:	ef 92       	push	r14
    713a:	ff 92       	push	r15
    713c:	0f 93       	push	r16
    713e:	1f 93       	push	r17
    7140:	cf 93       	push	r28
    7142:	df 93       	push	r29
    7144:	cd b7       	in	r28, 0x3d	; 61
    7146:	de b7       	in	r29, 0x3e	; 62
    7148:	a4 97       	sbiw	r28, 0x24	; 36
    714a:	0f b6       	in	r0, 0x3f	; 63
    714c:	f8 94       	cli
    714e:	de bf       	out	0x3e, r29	; 62
    7150:	0f be       	out	0x3f, r0	; 63
    7152:	cd bf       	out	0x3d, r28	; 61
  uint8_t idx;
  int32_t current_position[N_AXIS]; // Copy current state of the system position variable
  memcpy(current_position,sys_position,sizeof(sys_position));
    7154:	8c e0       	ldi	r24, 0x0C	; 12
    7156:	e3 e4       	ldi	r30, 0x43	; 67
    7158:	fc e0       	ldi	r31, 0x0C	; 12
    715a:	de 01       	movw	r26, r28
    715c:	11 96       	adiw	r26, 0x01	; 1
    715e:	01 90       	ld	r0, Z+
    7160:	0d 92       	st	X+, r0
    7162:	8a 95       	dec	r24
    7164:	e1 f7       	brne	.-8      	; 0x715e <report_realtime_status+0x3a>
  float print_position[N_AXIS];
  system_convert_array_steps_to_mpos(print_position,current_position);
    7166:	be 01       	movw	r22, r28
    7168:	6f 5f       	subi	r22, 0xFF	; 255
    716a:	7f 4f       	sbci	r23, 0xFF	; 255
    716c:	ce 01       	movw	r24, r28
    716e:	0d 96       	adiw	r24, 0x0d	; 13
    7170:	98 d2       	rcall	.+1328   	; 0x76a2 <system_convert_array_steps_to_mpos>

  // Report current machine state and sub-states
  serial_write('<');
    7172:	8c e3       	ldi	r24, 0x3C	; 60
    7174:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
  switch (sys.state) {
    7178:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    717c:	88 30       	cpi	r24, 0x08	; 8
    717e:	c9 f0       	breq	.+50     	; 0x71b2 <report_realtime_status+0x8e>
    7180:	40 f4       	brcc	.+16     	; 0x7192 <report_realtime_status+0x6e>
    7182:	81 30       	cpi	r24, 0x01	; 1
    7184:	a9 f1       	breq	.+106    	; 0x71f0 <report_realtime_status+0xcc>
    7186:	88 f0       	brcs	.+34     	; 0x71aa <report_realtime_status+0x86>
    7188:	82 30       	cpi	r24, 0x02	; 2
    718a:	b1 f1       	breq	.+108    	; 0x71f8 <report_realtime_status+0xd4>
    718c:	84 30       	cpi	r24, 0x04	; 4
    718e:	61 f1       	breq	.+88     	; 0x71e8 <report_realtime_status+0xc4>
    7190:	55 c0       	rjmp	.+170    	; 0x723c <report_realtime_status+0x118>
    7192:	80 32       	cpi	r24, 0x20	; 32
    7194:	29 f1       	breq	.+74     	; 0x71e0 <report_realtime_status+0xbc>
    7196:	18 f4       	brcc	.+6      	; 0x719e <report_realtime_status+0x7a>
    7198:	80 31       	cpi	r24, 0x10	; 16
    719a:	79 f0       	breq	.+30     	; 0x71ba <report_realtime_status+0x96>
    719c:	4f c0       	rjmp	.+158    	; 0x723c <report_realtime_status+0x118>
    719e:	80 34       	cpi	r24, 0x40	; 64
    71a0:	79 f1       	breq	.+94     	; 0x7200 <report_realtime_status+0xdc>
    71a2:	80 38       	cpi	r24, 0x80	; 128
    71a4:	09 f4       	brne	.+2      	; 0x71a8 <report_realtime_status+0x84>
    71a6:	47 c0       	rjmp	.+142    	; 0x7236 <report_realtime_status+0x112>
    71a8:	49 c0       	rjmp	.+146    	; 0x723c <report_realtime_status+0x118>
    case STATE_IDLE: printPgmString(PSTR("Idle")); break;
    71aa:	85 ea       	ldi	r24, 0xA5	; 165
    71ac:	93 e0       	ldi	r25, 0x03	; 3
    71ae:	74 da       	rcall	.-2840   	; 0x6698 <printPgmString>
    71b0:	45 c0       	rjmp	.+138    	; 0x723c <report_realtime_status+0x118>
    case STATE_CYCLE: printPgmString(PSTR("Run")); break;
    71b2:	81 ea       	ldi	r24, 0xA1	; 161
    71b4:	93 e0       	ldi	r25, 0x03	; 3
    71b6:	70 da       	rcall	.-2848   	; 0x6698 <printPgmString>
    71b8:	41 c0       	rjmp	.+130    	; 0x723c <report_realtime_status+0x118>
    case STATE_HOLD:
      if (!(sys.suspend & SUSPEND_JOG_CANCEL)) {
    71ba:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    71be:	88 23       	and	r24, r24
        printPgmString(PSTR("Hold:"));
    71c0:	7c f0       	brlt	.+30     	; 0x71e0 <report_realtime_status+0xbc>
    71c2:	8b e9       	ldi	r24, 0x9B	; 155
    71c4:	93 e0       	ldi	r25, 0x03	; 3
    71c6:	68 da       	rcall	.-2864   	; 0x6698 <printPgmString>
        if (sys.suspend & SUSPEND_HOLD_COMPLETE) { serial_write('0'); } // Ready to resume
    71c8:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    71cc:	80 ff       	sbrs	r24, 0
    71ce:	04 c0       	rjmp	.+8      	; 0x71d8 <report_realtime_status+0xb4>
    71d0:	80 e3       	ldi	r24, 0x30	; 48
    71d2:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    71d6:	32 c0       	rjmp	.+100    	; 0x723c <report_realtime_status+0x118>
        else { serial_write('1'); } // Actively holding
    71d8:	81 e3       	ldi	r24, 0x31	; 49
    71da:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
        break;
      } // Continues to print jog state during jog cancel.
    case STATE_JOG: printPgmString(PSTR("Jog")); break;
    71de:	2e c0       	rjmp	.+92     	; 0x723c <report_realtime_status+0x118>
    71e0:	87 e9       	ldi	r24, 0x97	; 151
    71e2:	93 e0       	ldi	r25, 0x03	; 3
    71e4:	59 da       	rcall	.-2894   	; 0x6698 <printPgmString>
    case STATE_HOMING: printPgmString(PSTR("Home")); break;
    71e6:	2a c0       	rjmp	.+84     	; 0x723c <report_realtime_status+0x118>
    71e8:	82 e9       	ldi	r24, 0x92	; 146
    71ea:	93 e0       	ldi	r25, 0x03	; 3
    71ec:	55 da       	rcall	.-2902   	; 0x6698 <printPgmString>
    case STATE_ALARM: printPgmString(PSTR("Alarm")); break;
    71ee:	26 c0       	rjmp	.+76     	; 0x723c <report_realtime_status+0x118>
    71f0:	8c e8       	ldi	r24, 0x8C	; 140
    71f2:	93 e0       	ldi	r25, 0x03	; 3
    71f4:	51 da       	rcall	.-2910   	; 0x6698 <printPgmString>
    case STATE_CHECK_MODE: printPgmString(PSTR("Check")); break;
    71f6:	22 c0       	rjmp	.+68     	; 0x723c <report_realtime_status+0x118>
    71f8:	86 e8       	ldi	r24, 0x86	; 134
    71fa:	93 e0       	ldi	r25, 0x03	; 3
    71fc:	4d da       	rcall	.-2918   	; 0x6698 <printPgmString>
    71fe:	1e c0       	rjmp	.+60     	; 0x723c <report_realtime_status+0x118>
    case STATE_SAFETY_DOOR:
      printPgmString(PSTR("Door:"));
    7200:	80 e8       	ldi	r24, 0x80	; 128
    7202:	93 e0       	ldi	r25, 0x03	; 3
    7204:	49 da       	rcall	.-2926   	; 0x6698 <printPgmString>
    7206:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
      if (sys.suspend & SUSPEND_INITIATE_RESTORE) {
    720a:	83 ff       	sbrs	r24, 3
    720c:	04 c0       	rjmp	.+8      	; 0x7216 <report_realtime_status+0xf2>
    720e:	83 e3       	ldi	r24, 0x33	; 51
        serial_write('3'); // Restoring
    7210:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    7214:	13 c0       	rjmp	.+38     	; 0x723c <report_realtime_status+0x118>
    7216:	82 ff       	sbrs	r24, 2
      } else {
        if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
    7218:	0a c0       	rjmp	.+20     	; 0x722e <report_realtime_status+0x10a>
    721a:	85 ff       	sbrs	r24, 5
          if (sys.suspend & SUSPEND_SAFETY_DOOR_AJAR) {
    721c:	04 c0       	rjmp	.+8      	; 0x7226 <report_realtime_status+0x102>
    721e:	81 e3       	ldi	r24, 0x31	; 49
            serial_write('1'); // Door ajar
    7220:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    7224:	0b c0       	rjmp	.+22     	; 0x723c <report_realtime_status+0x118>
    7226:	80 e3       	ldi	r24, 0x30	; 48
          } else {
            serial_write('0');
    7228:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    722c:	07 c0       	rjmp	.+14     	; 0x723c <report_realtime_status+0x118>
          } // Door closed and ready to resume
        } else {
          serial_write('2'); // Retracting
    722e:	82 e3       	ldi	r24, 0x32	; 50
    7230:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    7234:	03 c0       	rjmp	.+6      	; 0x723c <report_realtime_status+0x118>
        }
      }
      break;
    case STATE_SLEEP: printPgmString(PSTR("Sleep")); break;
    7236:	8a e7       	ldi	r24, 0x7A	; 122
    7238:	93 e0       	ldi	r25, 0x03	; 3
    723a:	2e da       	rcall	.-2980   	; 0x6698 <printPgmString>
    723c:	80 91 04 0f 	lds	r24, 0x0F04	; 0x800f04 <settings+0x34>
    7240:	28 2f       	mov	r18, r24
  }

  float wco[N_AXIS];
  if (bit_isfalse(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE) ||
    7242:	21 70       	andi	r18, 0x01	; 1
    7244:	e2 2e       	mov	r14, r18
    7246:	80 ff       	sbrs	r24, 0
    7248:	04 c0       	rjmp	.+8      	; 0x7252 <report_realtime_status+0x12e>
    724a:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <sys+0xc>
    724e:	81 11       	cpse	r24, r1
    7250:	52 c0       	rjmp	.+164    	; 0x72f6 <report_realtime_status+0x1d2>
    7252:	40 90 92 0c 	lds	r4, 0x0C92	; 0x800c92 <gc_state+0x3c>
      (sys.report_wco_counter == 0) ) {
    for (idx=0; idx< N_AXIS; idx++) {
      // Apply work coordinate offsets and tool length offset to current position.
      wco[idx] = gc_state.coord_system[idx]+gc_state.coord_offset[idx];
      if (idx == TOOL_LENGTH_OFFSET_AXIS) { wco[idx] += gc_state.tool_length_offset; }
    7256:	50 90 93 0c 	lds	r5, 0x0C93	; 0x800c93 <gc_state+0x3d>
    725a:	60 90 94 0c 	lds	r6, 0x0C94	; 0x800c94 <gc_state+0x3e>
    725e:	70 90 95 0c 	lds	r7, 0x0C95	; 0x800c95 <gc_state+0x3f>
    7262:	0f 2e       	mov	r0, r31
    7264:	fa e7       	ldi	r31, 0x7A	; 122
    7266:	cf 2e       	mov	r12, r31
    7268:	fc e0       	ldi	r31, 0x0C	; 12
    726a:	df 2e       	mov	r13, r31
    726c:	f0 2d       	mov	r31, r0
    726e:	8e 01       	movw	r16, r28
    7270:	07 5e       	subi	r16, 0xE7	; 231
    7272:	1f 4f       	sbci	r17, 0xFF	; 255
    7274:	5e 01       	movw	r10, r28
    7276:	8d e0       	ldi	r24, 0x0D	; 13
    7278:	a8 0e       	add	r10, r24
    727a:	b1 1c       	adc	r11, r1
    727c:	f1 2c       	mov	r15, r1
    727e:	f6 01       	movw	r30, r12
  float wco[N_AXIS];
  if (bit_isfalse(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE) ||
      (sys.report_wco_counter == 0) ) {
    for (idx=0; idx< N_AXIS; idx++) {
      // Apply work coordinate offsets and tool length offset to current position.
      wco[idx] = gc_state.coord_system[idx]+gc_state.coord_offset[idx];
    7280:	61 91       	ld	r22, Z+
    7282:	71 91       	ld	r23, Z+
    7284:	81 91       	ld	r24, Z+
    7286:	91 91       	ld	r25, Z+
    7288:	6f 01       	movw	r12, r30
    728a:	20 85       	ldd	r18, Z+8	; 0x08
    728c:	31 85       	ldd	r19, Z+9	; 0x09
    728e:	42 85       	ldd	r20, Z+10	; 0x0a
    7290:	53 85       	ldd	r21, Z+11	; 0x0b
    7292:	7d d5       	rcall	.+2810   	; 0x7d8e <__addsf3>
    7294:	48 01       	movw	r8, r16
    7296:	f8 01       	movw	r30, r16
    7298:	60 83       	st	Z, r22
    729a:	71 83       	std	Z+1, r23	; 0x01
    729c:	82 83       	std	Z+2, r24	; 0x02
    729e:	93 83       	std	Z+3, r25	; 0x03
      if (idx == TOOL_LENGTH_OFFSET_AXIS) { wco[idx] += gc_state.tool_length_offset; }
    72a0:	f2 e0       	ldi	r31, 0x02	; 2
    72a2:	ff 12       	cpse	r15, r31
    72a4:	0b c0       	rjmp	.+22     	; 0x72bc <report_realtime_status+0x198>
    72a6:	a3 01       	movw	r20, r6
    72a8:	92 01       	movw	r18, r4
    72aa:	71 d5       	rcall	.+2786   	; 0x7d8e <__addsf3>
    72ac:	f8 01       	movw	r30, r16
    72ae:	60 83       	st	Z, r22
    72b0:	71 83       	std	Z+1, r23	; 0x01
    72b2:	82 83       	std	Z+2, r24	; 0x02
    72b4:	93 83       	std	Z+3, r25	; 0x03
    72b6:	e1 10       	cpse	r14, r1
      if (bit_isfalse(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE)) {
    72b8:	1e c0       	rjmp	.+60     	; 0x72f6 <report_realtime_status+0x1d2>
    72ba:	02 c0       	rjmp	.+4      	; 0x72c0 <report_realtime_status+0x19c>
    72bc:	e1 10       	cpse	r14, r1
    72be:	10 c0       	rjmp	.+32     	; 0x72e0 <report_realtime_status+0x1bc>
        print_position[idx] -= wco[idx];
    72c0:	f4 01       	movw	r30, r8
    72c2:	20 81       	ld	r18, Z
    72c4:	31 81       	ldd	r19, Z+1	; 0x01
    72c6:	42 81       	ldd	r20, Z+2	; 0x02
    72c8:	53 81       	ldd	r21, Z+3	; 0x03
    72ca:	f5 01       	movw	r30, r10
    72cc:	60 81       	ld	r22, Z
    72ce:	71 81       	ldd	r23, Z+1	; 0x01
    72d0:	82 81       	ldd	r24, Z+2	; 0x02
    72d2:	93 81       	ldd	r25, Z+3	; 0x03
    72d4:	5b d5       	rcall	.+2742   	; 0x7d8c <__subsf3>
    72d6:	f5 01       	movw	r30, r10
    72d8:	60 83       	st	Z, r22
    72da:	71 83       	std	Z+1, r23	; 0x01
    72dc:	82 83       	std	Z+2, r24	; 0x02
    72de:	93 83       	std	Z+3, r25	; 0x03
    72e0:	f3 94       	inc	r15
  }

  float wco[N_AXIS];
  if (bit_isfalse(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE) ||
      (sys.report_wco_counter == 0) ) {
    for (idx=0; idx< N_AXIS; idx++) {
    72e2:	0c 5f       	subi	r16, 0xFC	; 252
    72e4:	1f 4f       	sbci	r17, 0xFF	; 255
    72e6:	f4 e0       	ldi	r31, 0x04	; 4
    72e8:	af 0e       	add	r10, r31
    72ea:	b1 1c       	adc	r11, r1
    72ec:	23 e0       	ldi	r18, 0x03	; 3
    72ee:	f2 12       	cpse	r15, r18
      }
    }
  }

  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE)) {
    72f0:	c6 cf       	rjmp	.-116    	; 0x727e <report_realtime_status+0x15a>
    72f2:	ee 20       	and	r14, r14
    printPgmString(PSTR("|MPos:"));
    72f4:	21 f0       	breq	.+8      	; 0x72fe <report_realtime_status+0x1da>
    72f6:	83 e7       	ldi	r24, 0x73	; 115
    72f8:	93 e0       	ldi	r25, 0x03	; 3
    72fa:	ce d9       	rcall	.-3172   	; 0x6698 <printPgmString>
  } else {
    printPgmString(PSTR("|WPos:"));
    72fc:	03 c0       	rjmp	.+6      	; 0x7304 <report_realtime_status+0x1e0>
    72fe:	8c e6       	ldi	r24, 0x6C	; 108
    7300:	93 e0       	ldi	r25, 0x03	; 3
  }
  report_util_axis_values(print_position);
    7302:	ca d9       	rcall	.-3180   	; 0x6698 <printPgmString>
    7304:	ce 01       	movw	r24, r28
    7306:	0d 96       	adiw	r24, 0x0d	; 13

  // Returns planner and serial read buffer states.
  #ifdef REPORT_FIELD_BUFFER_STATE
    if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_BUFFER_STATE)) {
    7308:	9b db       	rcall	.-2250   	; 0x6a40 <report_util_axis_values>
    730a:	80 91 04 0f 	lds	r24, 0x0F04	; 0x800f04 <settings+0x34>
    730e:	81 ff       	sbrs	r24, 1
      printPgmString(PSTR("|Bf:"));
    7310:	0c c0       	rjmp	.+24     	; 0x732a <report_realtime_status+0x206>
    7312:	87 e6       	ldi	r24, 0x67	; 103
    7314:	93 e0       	ldi	r25, 0x03	; 3
    7316:	c0 d9       	rcall	.-3200   	; 0x6698 <printPgmString>
      print_uint8_base10(plan_get_block_buffer_available());
    7318:	0e 94 1b 2e 	call	0x5c36	; 0x5c36 <plan_get_block_buffer_available>
    731c:	cf d9       	rcall	.-3170   	; 0x66bc <print_uint8_base10>
    731e:	8c e2       	ldi	r24, 0x2C	; 44
      serial_write(',');
    7320:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    7324:	0e 94 09 14 	call	0x2812	; 0x2812 <serial_get_rx_buffer_available>
      print_uint8_base10(serial_get_rx_buffer_available());
    7328:	c9 d9       	rcall	.-3182   	; 0x66bc <print_uint8_base10>
    732a:	0e 94 87 29 	call	0x530e	; 0x530e <plan_get_current_block>
  #endif

  #ifdef REPORT_FIELD_LINE_NUMBERS
    // Report current line number
    plan_block_t * cur_block = plan_get_current_block();
    if (cur_block != NULL) {
    732e:	00 97       	sbiw	r24, 0x00	; 0
      uint32_t ln = cur_block->line_number;
    7330:	81 f0       	breq	.+32     	; 0x7352 <report_realtime_status+0x22e>
    7332:	fc 01       	movw	r30, r24
    7334:	c2 88       	ldd	r12, Z+18	; 0x12
    7336:	d3 88       	ldd	r13, Z+19	; 0x13
      if (ln > 0) {
    7338:	e4 88       	ldd	r14, Z+20	; 0x14
    733a:	f5 88       	ldd	r15, Z+21	; 0x15
    733c:	c1 14       	cp	r12, r1
    733e:	d1 04       	cpc	r13, r1
    7340:	e1 04       	cpc	r14, r1
        printPgmString(PSTR("|Ln:"));
    7342:	f1 04       	cpc	r15, r1
    7344:	31 f0       	breq	.+12     	; 0x7352 <report_realtime_status+0x22e>
    7346:	82 e6       	ldi	r24, 0x62	; 98
    7348:	93 e0       	ldi	r25, 0x03	; 3
        printInteger(ln);
    734a:	a6 d9       	rcall	.-3252   	; 0x6698 <printPgmString>
    734c:	c7 01       	movw	r24, r14
    734e:	b6 01       	movw	r22, r12
    }
  #endif

  // Report realtime feed speed
  #ifdef REPORT_FIELD_CURRENT_FEED_SPEED
    printPgmString(PSTR("|FS:"));
    7350:	4a da       	rcall	.-2924   	; 0x67e6 <printInteger>
    7352:	8d e5       	ldi	r24, 0x5D	; 93
    7354:	93 e0       	ldi	r25, 0x03	; 3
    printFloat_RateValue(st_get_realtime_rate());
    7356:	a0 d9       	rcall	.-3264   	; 0x6698 <printPgmString>
    7358:	0e 94 97 24 	call	0x492e	; 0x492e <st_get_realtime_rate>
    735c:	1f db       	rcall	.-2498   	; 0x699c <printFloat_RateValue>
    serial_write(',');
    735e:	8c e2       	ldi	r24, 0x2C	; 44
    7360:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    printFloat(sys.spindle_speed,N_DECIMAL_RPMVALUE);
    7364:	60 91 2c 0c 	lds	r22, 0x0C2C	; 0x800c2c <sys+0xe>
    7368:	70 91 2d 0c 	lds	r23, 0x0C2D	; 0x800c2d <sys+0xf>
    736c:	80 91 2e 0c 	lds	r24, 0x0C2E	; 0x800c2e <sys+0x10>
    7370:	90 91 2f 0c 	lds	r25, 0x0C2F	; 0x800c2f <sys+0x11>
    7374:	40 e0       	ldi	r20, 0x00	; 0
    7376:	51 da       	rcall	.-2910   	; 0x681a <printFloat>
  #endif

  #ifdef REPORT_FIELD_PIN_STATE
    uint8_t lim_pin_state = limits_get_state();
    7378:	0e 94 67 30 	call	0x60ce	; 0x60ce <limits_get_state>
    737c:	08 2f       	mov	r16, r24
    uint8_t ctrl_pin_state = system_control_get_state();
    737e:	ea d0       	rcall	.+468    	; 0x7554 <system_control_get_state>
    7380:	18 2f       	mov	r17, r24
    7382:	3a db       	rcall	.-2444   	; 0x69f8 <probe_get_state>
    uint8_t prb_pin_state = probe_get_state();
    7384:	f8 2e       	mov	r15, r24
    7386:	80 2f       	mov	r24, r16
    7388:	81 2b       	or	r24, r17
    if (lim_pin_state | ctrl_pin_state | prb_pin_state) {
    738a:	8f 29       	or	r24, r15
    738c:	79 f1       	breq	.+94     	; 0x73ec <report_realtime_status+0x2c8>
    738e:	88 e5       	ldi	r24, 0x58	; 88
    7390:	93 e0       	ldi	r25, 0x03	; 3
      printPgmString(PSTR("|Pn:"));
    7392:	82 d9       	rcall	.-3324   	; 0x6698 <printPgmString>
    7394:	ff 20       	and	r15, r15
    7396:	19 f0       	breq	.+6      	; 0x739e <report_realtime_status+0x27a>
    7398:	80 e5       	ldi	r24, 0x50	; 80
      if (prb_pin_state) { serial_write('P'); }
    739a:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    739e:	00 23       	and	r16, r16
    73a0:	79 f0       	breq	.+30     	; 0x73c0 <report_realtime_status+0x29c>
    73a2:	00 ff       	sbrs	r16, 0
      if (lim_pin_state) {
    73a4:	03 c0       	rjmp	.+6      	; 0x73ac <report_realtime_status+0x288>
    73a6:	88 e5       	ldi	r24, 0x58	; 88
        if (bit_istrue(lim_pin_state,bit(X_AXIS))) { serial_write('X'); }
    73a8:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    73ac:	01 ff       	sbrs	r16, 1
    73ae:	03 c0       	rjmp	.+6      	; 0x73b6 <report_realtime_status+0x292>
    73b0:	89 e5       	ldi	r24, 0x59	; 89
        if (bit_istrue(lim_pin_state,bit(Y_AXIS))) { serial_write('Y'); }
    73b2:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    73b6:	02 ff       	sbrs	r16, 2
    73b8:	03 c0       	rjmp	.+6      	; 0x73c0 <report_realtime_status+0x29c>
    73ba:	8a e5       	ldi	r24, 0x5A	; 90
        if (bit_istrue(lim_pin_state,bit(Z_AXIS))) { serial_write('Z'); }
    73bc:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    73c0:	11 23       	and	r17, r17
    73c2:	a1 f0       	breq	.+40     	; 0x73ec <report_realtime_status+0x2c8>
    73c4:	10 ff       	sbrs	r17, 0
      }
      if (ctrl_pin_state) {
    73c6:	03 c0       	rjmp	.+6      	; 0x73ce <report_realtime_status+0x2aa>
    73c8:	84 e4       	ldi	r24, 0x44	; 68
        if (bit_istrue(ctrl_pin_state,CONTROL_PIN_INDEX_SAFETY_DOOR)) { serial_write('D'); }
    73ca:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    73ce:	11 ff       	sbrs	r17, 1
    73d0:	03 c0       	rjmp	.+6      	; 0x73d8 <report_realtime_status+0x2b4>
    73d2:	82 e5       	ldi	r24, 0x52	; 82
        if (bit_istrue(ctrl_pin_state,CONTROL_PIN_INDEX_RESET)) { serial_write('R'); }
    73d4:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    73d8:	12 ff       	sbrs	r17, 2
    73da:	03 c0       	rjmp	.+6      	; 0x73e2 <report_realtime_status+0x2be>
    73dc:	88 e4       	ldi	r24, 0x48	; 72
        if (bit_istrue(ctrl_pin_state,CONTROL_PIN_INDEX_FEED_HOLD)) { serial_write('H'); }
    73de:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    73e2:	13 ff       	sbrs	r17, 3
    73e4:	03 c0       	rjmp	.+6      	; 0x73ec <report_realtime_status+0x2c8>
    73e6:	83 e5       	ldi	r24, 0x53	; 83
        if (bit_istrue(ctrl_pin_state,CONTROL_PIN_INDEX_CYCLE_START)) { serial_write('S'); }
    73e8:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    73ec:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <sys+0xc>
    73f0:	88 23       	and	r24, r24
      }
    }
  #endif

  #ifdef REPORT_FIELD_WORK_COORD_OFFSET
    if (sys.report_wco_counter > 0) { sys.report_wco_counter--; }
    73f2:	21 f0       	breq	.+8      	; 0x73fc <report_realtime_status+0x2d8>
    73f4:	81 50       	subi	r24, 0x01	; 1
    73f6:	80 93 2a 0c 	sts	0x0C2A, r24	; 0x800c2a <sys+0xc>
    73fa:	18 c0       	rjmp	.+48     	; 0x742c <report_realtime_status+0x308>
    73fc:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    else {
      if (sys.state & (STATE_HOMING | STATE_CYCLE | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)) {
    7400:	8c 77       	andi	r24, 0x7C	; 124
    7402:	21 f0       	breq	.+8      	; 0x740c <report_realtime_status+0x2e8>
    7404:	8d e1       	ldi	r24, 0x1D	; 29
        sys.report_wco_counter = (REPORT_WCO_REFRESH_BUSY_COUNT-1); // Reset counter for slow refresh
    7406:	80 93 2a 0c 	sts	0x0C2A, r24	; 0x800c2a <sys+0xc>
    740a:	03 c0       	rjmp	.+6      	; 0x7412 <report_realtime_status+0x2ee>
    740c:	89 e0       	ldi	r24, 0x09	; 9
      } else { sys.report_wco_counter = (REPORT_WCO_REFRESH_IDLE_COUNT-1); }
    740e:	80 93 2a 0c 	sts	0x0C2A, r24	; 0x800c2a <sys+0xc>
    7412:	80 91 29 0c 	lds	r24, 0x0C29	; 0x800c29 <sys+0xb>
      if (sys.report_ovr_counter == 0) { sys.report_ovr_counter = 1; } // Set override on next report.
    7416:	81 11       	cpse	r24, r1
    7418:	03 c0       	rjmp	.+6      	; 0x7420 <report_realtime_status+0x2fc>
    741a:	81 e0       	ldi	r24, 0x01	; 1
    741c:	80 93 29 0c 	sts	0x0C29, r24	; 0x800c29 <sys+0xb>
    7420:	82 e5       	ldi	r24, 0x52	; 82
      printPgmString(PSTR("|WCO:"));
    7422:	93 e0       	ldi	r25, 0x03	; 3
    7424:	39 d9       	rcall	.-3470   	; 0x6698 <printPgmString>
    7426:	ce 01       	movw	r24, r28
      report_util_axis_values(wco);
    7428:	49 96       	adiw	r24, 0x19	; 25
    742a:	0a db       	rcall	.-2540   	; 0x6a40 <report_util_axis_values>
    742c:	80 91 29 0c 	lds	r24, 0x0C29	; 0x800c29 <sys+0xb>
    }
  #endif

  #ifdef REPORT_FIELD_OVERRIDES
    if (sys.report_ovr_counter > 0) { sys.report_ovr_counter--; }
    7430:	88 23       	and	r24, r24
    7432:	21 f0       	breq	.+8      	; 0x743c <report_realtime_status+0x318>
    7434:	81 50       	subi	r24, 0x01	; 1
    7436:	80 93 29 0c 	sts	0x0C29, r24	; 0x800c29 <sys+0xb>
    743a:	3b c0       	rjmp	.+118    	; 0x74b2 <report_realtime_status+0x38e>
    else {
      if (sys.state & (STATE_HOMING | STATE_CYCLE | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)) {
    743c:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    7440:	8c 77       	andi	r24, 0x7C	; 124
        sys.report_ovr_counter = (REPORT_OVR_REFRESH_BUSY_COUNT-1); // Reset counter for slow refresh
    7442:	21 f0       	breq	.+8      	; 0x744c <report_realtime_status+0x328>
    7444:	83 e1       	ldi	r24, 0x13	; 19
    7446:	80 93 29 0c 	sts	0x0C29, r24	; 0x800c29 <sys+0xb>
      } else { sys.report_ovr_counter = (REPORT_OVR_REFRESH_IDLE_COUNT-1); }
    744a:	03 c0       	rjmp	.+6      	; 0x7452 <report_realtime_status+0x32e>
    744c:	89 e0       	ldi	r24, 0x09	; 9
    744e:	80 93 29 0c 	sts	0x0C29, r24	; 0x800c29 <sys+0xb>
      printPgmString(PSTR("|Ov:"));
    7452:	8d e4       	ldi	r24, 0x4D	; 77
    7454:	93 e0       	ldi	r25, 0x03	; 3
    7456:	20 d9       	rcall	.-3520   	; 0x6698 <printPgmString>
      print_uint8_base10(sys.f_override);
    7458:	0e e1       	ldi	r16, 0x1E	; 30
    745a:	1c e0       	ldi	r17, 0x0C	; 12
    745c:	f8 01       	movw	r30, r16
    745e:	87 81       	ldd	r24, Z+7	; 0x07
    7460:	2d d9       	rcall	.-3494   	; 0x66bc <print_uint8_base10>
    7462:	8c e2       	ldi	r24, 0x2C	; 44
      serial_write(',');
    7464:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    7468:	f8 01       	movw	r30, r16
      print_uint8_base10(sys.r_override);
    746a:	80 85       	ldd	r24, Z+8	; 0x08
    746c:	27 d9       	rcall	.-3506   	; 0x66bc <print_uint8_base10>
    746e:	8c e2       	ldi	r24, 0x2C	; 44
    7470:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
      serial_write(',');
    7474:	f8 01       	movw	r30, r16
    7476:	81 85       	ldd	r24, Z+9	; 0x09
      print_uint8_base10(sys.spindle_speed_ovr);
    7478:	21 d9       	rcall	.-3518   	; 0x66bc <print_uint8_base10>
    747a:	0e 94 74 12 	call	0x24e8	; 0x24e8 <spindle_get_state>

      uint8_t sp_state = spindle_get_state();
    747e:	08 2f       	mov	r16, r24
    7480:	0e 94 be 13 	call	0x277c	; 0x277c <coolant_get_state>
      uint8_t cl_state = coolant_get_state();
    7484:	18 2f       	mov	r17, r24
    7486:	01 11       	cpse	r16, r1
    7488:	2e c0       	rjmp	.+92     	; 0x74e6 <report_realtime_status+0x3c2>
      if (sp_state || cl_state) {
    748a:	81 11       	cpse	r24, r1
    748c:	32 c0       	rjmp	.+100    	; 0x74f2 <report_realtime_status+0x3ce>
    748e:	11 c0       	rjmp	.+34     	; 0x74b2 <report_realtime_status+0x38e>
        printPgmString(PSTR("|A:"));
        if (sp_state) { // != SPINDLE_STATE_DISABLE
          if (sp_state == SPINDLE_STATE_CW) { serial_write('S'); } // CW
    7490:	83 e5       	ldi	r24, 0x53	; 83
    7492:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
    7496:	03 c0       	rjmp	.+6      	; 0x749e <report_realtime_status+0x37a>
          else { serial_write('C'); } // CCW
    7498:	83 e4       	ldi	r24, 0x43	; 67
    749a:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
        }
        if (cl_state & COOLANT_STATE_FLOOD) { serial_write('F'); }
    749e:	16 ff       	sbrs	r17, 6
    74a0:	03 c0       	rjmp	.+6      	; 0x74a8 <report_realtime_status+0x384>
    74a2:	86 e4       	ldi	r24, 0x46	; 70
    74a4:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
        if (cl_state & COOLANT_STATE_MIST) { serial_write('M'); }
    74a8:	11 23       	and	r17, r17
    74aa:	1c f4       	brge	.+6      	; 0x74b2 <report_realtime_status+0x38e>
    74ac:	8d e4       	ldi	r24, 0x4D	; 77
      }  
    }
  #endif
  
  #ifdef LATHE
      printPgmString(PSTR("|Sp:"));
    74ae:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
      print_uint32_base10(sys_synchronization_pulse_count);
    74b2:	84 e4       	ldi	r24, 0x44	; 68
    74b4:	93 e0       	ldi	r25, 0x03	; 3
    74b6:	f0 d8       	rcall	.-3616   	; 0x6698 <printPgmString>
    74b8:	60 91 15 0c 	lds	r22, 0x0C15	; 0x800c15 <sys_synchronization_pulse_count>
    74bc:	70 91 16 0c 	lds	r23, 0x0C16	; 0x800c16 <sys_synchronization_pulse_count+0x1>
    74c0:	80 91 17 0c 	lds	r24, 0x0C17	; 0x800c17 <sys_synchronization_pulse_count+0x2>
    74c4:	90 91 18 0c 	lds	r25, 0x0C18	; 0x800c18 <sys_synchronization_pulse_count+0x3>
      printPgmString(PSTR("|Si:"));
    74c8:	38 d9       	rcall	.-3472   	; 0x673a <print_uint32_base10>
    74ca:	8f e3       	ldi	r24, 0x3F	; 63
    74cc:	93 e0       	ldi	r25, 0x03	; 3
      print_uint32_base10(sys_index_pulse_count);
    74ce:	e4 d8       	rcall	.-3640   	; 0x6698 <printPgmString>
    74d0:	60 91 55 0c 	lds	r22, 0x0C55	; 0x800c55 <sys_index_pulse_count>
    74d4:	70 e0       	ldi	r23, 0x00	; 0
    74d6:	80 e0       	ldi	r24, 0x00	; 0
    74d8:	90 e0       	ldi	r25, 0x00	; 0
    74da:	2f d9       	rcall	.-3490   	; 0x673a <print_uint32_base10>
  #endif

  serial_write('>');
    74dc:	8e e3       	ldi	r24, 0x3E	; 62
    74de:	0e 94 26 14 	call	0x284c	; 0x284c <serial_write>
  report_util_line_feed();
    74e2:	a5 da       	rcall	.-2742   	; 0x6a2e <report_util_line_feed>
    74e4:	0a c0       	rjmp	.+20     	; 0x74fa <report_realtime_status+0x3d6>
}
    74e6:	89 e4       	ldi	r24, 0x49	; 73
      print_uint8_base10(sys.spindle_speed_ovr);

      uint8_t sp_state = spindle_get_state();
      uint8_t cl_state = coolant_get_state();
      if (sp_state || cl_state) {
        printPgmString(PSTR("|A:"));
    74e8:	93 e0       	ldi	r25, 0x03	; 3
    74ea:	d6 d8       	rcall	.-3668   	; 0x6698 <printPgmString>
    74ec:	01 30       	cpi	r16, 0x01	; 1
    74ee:	a1 f6       	brne	.-88     	; 0x7498 <report_realtime_status+0x374>
        if (sp_state) { // != SPINDLE_STATE_DISABLE
          if (sp_state == SPINDLE_STATE_CW) { serial_write('S'); } // CW
    74f0:	cf cf       	rjmp	.-98     	; 0x7490 <report_realtime_status+0x36c>
    74f2:	89 e4       	ldi	r24, 0x49	; 73
    74f4:	93 e0       	ldi	r25, 0x03	; 3
      print_uint8_base10(sys.spindle_speed_ovr);

      uint8_t sp_state = spindle_get_state();
      uint8_t cl_state = coolant_get_state();
      if (sp_state || cl_state) {
        printPgmString(PSTR("|A:"));
    74f6:	d0 d8       	rcall	.-3680   	; 0x6698 <printPgmString>
    74f8:	d2 cf       	rjmp	.-92     	; 0x749e <report_realtime_status+0x37a>
    74fa:	a4 96       	adiw	r28, 0x24	; 36
    74fc:	0f b6       	in	r0, 0x3f	; 63
    74fe:	f8 94       	cli
      print_uint32_base10(sys_index_pulse_count);
  #endif

  serial_write('>');
  report_util_line_feed();
}
    7500:	de bf       	out	0x3e, r29	; 62
    7502:	0f be       	out	0x3f, r0	; 63
    7504:	cd bf       	out	0x3d, r28	; 61
    7506:	df 91       	pop	r29
    7508:	cf 91       	pop	r28
    750a:	1f 91       	pop	r17
    750c:	0f 91       	pop	r16
    750e:	ff 90       	pop	r15
    7510:	ef 90       	pop	r14
    7512:	df 90       	pop	r13
    7514:	cf 90       	pop	r12
    7516:	bf 90       	pop	r11
    7518:	af 90       	pop	r10
    751a:	9f 90       	pop	r9
    751c:	8f 90       	pop	r8
    751e:	7f 90       	pop	r7
    7520:	6f 90       	pop	r6
    7522:	5f 90       	pop	r5
    7524:	4f 90       	pop	r4
    7526:	08 95       	ret

00007528 <report_realtime_debug>:
    7528:	08 95       	ret

0000752a <system_init>:
#include "grbl.h"


void system_init()
{
  CONTROL_DDR &= ~(CONTROL_MASK); // Configure as input pins
    752a:	e7 e0       	ldi	r30, 0x07	; 7
    752c:	f1 e0       	ldi	r31, 0x01	; 1
    752e:	80 81       	ld	r24, Z
    7530:	80 77       	andi	r24, 0x70	; 112
    7532:	80 83       	st	Z, r24
  #ifdef DISABLE_CONTROL_PIN_PULL_UP
    CONTROL_PORT &= ~(CONTROL_MASK); // Normal low operation. Requires external pull-down.
  #else
    CONTROL_PORT |= CONTROL_MASK;   // Enable internal pull-up resistors. Normal high operation.
    7534:	e8 e0       	ldi	r30, 0x08	; 8
    7536:	f1 e0       	ldi	r31, 0x01	; 1
    7538:	80 81       	ld	r24, Z
    753a:	8f 68       	ori	r24, 0x8F	; 143
    753c:	80 83       	st	Z, r24
  #endif
  CONTROL_PCMSK |= CONTROL_MASK;  // Enable specific pins of the Pin Change Interrupt
    753e:	ed e6       	ldi	r30, 0x6D	; 109
    7540:	f0 e0       	ldi	r31, 0x00	; 0
    7542:	80 81       	ld	r24, Z
    7544:	8f 68       	ori	r24, 0x8F	; 143
    7546:	80 83       	st	Z, r24
  PCICR |= (1 << CONTROL_INT);   // Enable Pin Change Interrupt
    7548:	e8 e6       	ldi	r30, 0x68	; 104
    754a:	f0 e0       	ldi	r31, 0x00	; 0
    754c:	80 81       	ld	r24, Z
    754e:	84 60       	ori	r24, 0x04	; 4
    7550:	80 83       	st	Z, r24
    7552:	08 95       	ret

00007554 <system_control_get_state>:
// triggered is 1 and not triggered is 0. Invert mask is applied. Bitfield organization is
// defined by the CONTROL_PIN_INDEX in the header file.
uint8_t system_control_get_state()
{
  uint8_t control_state = 0;
  uint8_t pin = (CONTROL_PIN & CONTROL_MASK);
    7554:	20 91 06 01 	lds	r18, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
    7558:	32 2f       	mov	r19, r18
    755a:	3f 78       	andi	r19, 0x8F	; 143
  #ifdef INVERT_CONTROL_PIN_MASK
    pin ^= INVERT_CONTROL_PIN_MASK;
  #endif
  if (pin) {
    755c:	79 f0       	breq	.+30     	; 0x757c <system_control_get_state+0x28>
// Returns control pin state as a uint8 bitfield. Each bit indicates the input pin state, where
// triggered is 1 and not triggered is 0. Invert mask is applied. Bitfield organization is
// defined by the CONTROL_PIN_INDEX in the header file.
uint8_t system_control_get_state()
{
  uint8_t control_state = 0;
    755e:	23 fb       	bst	r18, 3
    7560:	88 27       	eor	r24, r24
    7562:	80 f9       	bld	r24, 0
    7564:	91 e0       	ldi	r25, 0x01	; 1
    7566:	89 27       	eor	r24, r25
  #ifdef INVERT_CONTROL_PIN_MASK
    pin ^= INVERT_CONTROL_PIN_MASK;
  #endif
  if (pin) {
    if (bit_isfalse(pin,(1<<CONTROL_SAFETY_DOOR_BIT))) { control_state |= CONTROL_PIN_INDEX_SAFETY_DOOR; }
    if (bit_isfalse(pin,(1<<CONTROL_RESET_BIT))) { control_state |= CONTROL_PIN_INDEX_RESET; }
    7568:	20 ff       	sbrs	r18, 0
    756a:	82 60       	ori	r24, 0x02	; 2
    if (bit_isfalse(pin,(1<<CONTROL_FEED_HOLD_BIT))) { control_state |= CONTROL_PIN_INDEX_FEED_HOLD; }
    756c:	21 ff       	sbrs	r18, 1
    756e:	84 60       	ori	r24, 0x04	; 4
    if (bit_isfalse(pin,(1<<CONTROL_CYCLE_START_BIT))) { control_state |= CONTROL_PIN_INDEX_CYCLE_START; }
    7570:	22 ff       	sbrs	r18, 2
    7572:	88 60       	ori	r24, 0x08	; 8
    if (bit_isfalse(pin,(1<<CONTROL_SPINDLE_SYNC_BIT))) { control_state |= CONTROL_PIN_INDEX_SPINDLE_SYNC; }
    7574:	33 23       	and	r19, r19
    7576:	1c f0       	brlt	.+6      	; 0x757e <system_control_get_state+0x2a>
    7578:	80 61       	ori	r24, 0x10	; 16
    757a:	08 95       	ret
// Returns control pin state as a uint8 bitfield. Each bit indicates the input pin state, where
// triggered is 1 and not triggered is 0. Invert mask is applied. Bitfield organization is
// defined by the CONTROL_PIN_INDEX in the header file.
uint8_t system_control_get_state()
{
  uint8_t control_state = 0;
    757c:	80 e0       	ldi	r24, 0x00	; 0
    if (bit_isfalse(pin,(1<<CONTROL_FEED_HOLD_BIT))) { control_state |= CONTROL_PIN_INDEX_FEED_HOLD; }
    if (bit_isfalse(pin,(1<<CONTROL_CYCLE_START_BIT))) { control_state |= CONTROL_PIN_INDEX_CYCLE_START; }
    if (bit_isfalse(pin,(1<<CONTROL_SPINDLE_SYNC_BIT))) { control_state |= CONTROL_PIN_INDEX_SPINDLE_SYNC; }
  }
  return(control_state);
}
    757e:	08 95       	ret

00007580 <__vector_11>:
// Pin change interrupt for pin-out commands, i.e. cycle start, feed hold, and reset. Sets
// only the realtime command execute variable to have the main program execute these when
// its ready. This works exactly like the character-based realtime commands when picked off
// directly from the incoming serial data stream.
ISR(CONTROL_INT_vect)
{
    7580:	1f 92       	push	r1
    7582:	0f 92       	push	r0
    7584:	0f b6       	in	r0, 0x3f	; 63
    7586:	0f 92       	push	r0
    7588:	11 24       	eor	r1, r1
    758a:	0b b6       	in	r0, 0x3b	; 59
    758c:	0f 92       	push	r0
    758e:	2f 93       	push	r18
    7590:	3f 93       	push	r19
    7592:	4f 93       	push	r20
    7594:	5f 93       	push	r21
    7596:	6f 93       	push	r22
    7598:	7f 93       	push	r23
    759a:	8f 93       	push	r24
    759c:	9f 93       	push	r25
    759e:	af 93       	push	r26
    75a0:	bf 93       	push	r27
    75a2:	ef 93       	push	r30
    75a4:	ff 93       	push	r31
  uint8_t pin = system_control_get_state();
    75a6:	d6 df       	rcall	.-84     	; 0x7554 <system_control_get_state>
  if (pin) {
    75a8:	88 23       	and	r24, r24
    75aa:	21 f1       	breq	.+72     	; 0x75f4 <__vector_11+0x74>
    if (bit_istrue(pin,CONTROL_PIN_INDEX_RESET)) {
    75ac:	81 ff       	sbrs	r24, 1
    75ae:	03 c0       	rjmp	.+6      	; 0x75b6 <__vector_11+0x36>
      mc_reset();
    75b0:	0e 94 2f 07 	call	0xe5e	; 0xe5e <mc_reset>
    75b4:	1f c0       	rjmp	.+62     	; 0x75f4 <__vector_11+0x74>
    } else if (bit_istrue(pin,CONTROL_PIN_INDEX_CYCLE_START)) {
    75b6:	83 ff       	sbrs	r24, 3
    75b8:	06 c0       	rjmp	.+12     	; 0x75c6 <__vector_11+0x46>
      bit_true(sys_rt_exec_state, EXEC_CYCLE_START);
    75ba:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    75be:	82 60       	ori	r24, 0x02	; 2
    75c0:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <sys_rt_exec_state>
    75c4:	17 c0       	rjmp	.+46     	; 0x75f4 <__vector_11+0x74>
    } else if (bit_istrue(pin,CONTROL_PIN_INDEX_FEED_HOLD)) {
    75c6:	82 ff       	sbrs	r24, 2
    75c8:	06 c0       	rjmp	.+12     	; 0x75d6 <__vector_11+0x56>
      bit_true(sys_rt_exec_state, EXEC_FEED_HOLD); 
    75ca:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    75ce:	88 60       	ori	r24, 0x08	; 8
    75d0:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <sys_rt_exec_state>
    75d4:	0f c0       	rjmp	.+30     	; 0x75f4 <__vector_11+0x74>
    } else if (bit_istrue(pin,CONTROL_PIN_INDEX_SAFETY_DOOR)) {
    75d6:	80 ff       	sbrs	r24, 0
    75d8:	06 c0       	rjmp	.+12     	; 0x75e6 <__vector_11+0x66>
      bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
    75da:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    75de:	80 62       	ori	r24, 0x20	; 32
    75e0:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <sys_rt_exec_state>
    75e4:	07 c0       	rjmp	.+14     	; 0x75f4 <__vector_11+0x74>
	} else if (bit_istrue(pin,CONTROL_PIN_INDEX_SPINDLE_SYNC)) {
    75e6:	84 ff       	sbrs	r24, 4
    75e8:	05 c0       	rjmp	.+10     	; 0x75f4 <__vector_11+0x74>
	 bit_true(sys_sync_state, EXEC_SPINDLE_SYNC);   } 
    75ea:	80 91 14 0c 	lds	r24, 0x0C14	; 0x800c14 <sys_sync_state>
    75ee:	82 60       	ori	r24, 0x02	; 2
    75f0:	80 93 14 0c 	sts	0x0C14, r24	; 0x800c14 <sys_sync_state>
  }
}
    75f4:	ff 91       	pop	r31
    75f6:	ef 91       	pop	r30
    75f8:	bf 91       	pop	r27
    75fa:	af 91       	pop	r26
    75fc:	9f 91       	pop	r25
    75fe:	8f 91       	pop	r24
    7600:	7f 91       	pop	r23
    7602:	6f 91       	pop	r22
    7604:	5f 91       	pop	r21
    7606:	4f 91       	pop	r20
    7608:	3f 91       	pop	r19
    760a:	2f 91       	pop	r18
    760c:	0f 90       	pop	r0
    760e:	0b be       	out	0x3b, r0	; 59
    7610:	0f 90       	pop	r0
    7612:	0f be       	out	0x3f, r0	; 63
    7614:	0f 90       	pop	r0
    7616:	1f 90       	pop	r1
    7618:	18 95       	reti

0000761a <system_check_safety_door_ajar>:


// Returns if safety door is ajar(T) or closed(F), based on pin state.
uint8_t system_check_safety_door_ajar()
{
    return(system_control_get_state() & CONTROL_PIN_INDEX_SAFETY_DOOR);
    761a:	9c df       	rcall	.-200    	; 0x7554 <system_control_get_state>
}
    761c:	81 70       	andi	r24, 0x01	; 1
    761e:	08 95       	ret

00007620 <system_execute_startup>:


// Executes user startup script, if stored.
void system_execute_startup(char *line)
{
    7620:	0f 93       	push	r16
    7622:	1f 93       	push	r17
    7624:	cf 93       	push	r28
    7626:	8c 01       	movw	r16, r24
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    7628:	c0 e0       	ldi	r28, 0x00	; 0
    if (!(settings_read_startup_line(n, line))) {
    762a:	b8 01       	movw	r22, r16
    762c:	8c 2f       	mov	r24, r28
    762e:	0e 94 eb 25 	call	0x4bd6	; 0x4bd6 <settings_read_startup_line>
    7632:	81 11       	cpse	r24, r1
    7634:	06 c0       	rjmp	.+12     	; 0x7642 <system_execute_startup+0x22>
      line[0] = 0;
    7636:	f8 01       	movw	r30, r16
    7638:	10 82       	st	Z, r1
      report_execute_startup_message(line,STATUS_SETTING_READ_FAIL);
    763a:	67 e0       	ldi	r22, 0x07	; 7
    763c:	c8 01       	movw	r24, r16
    763e:	30 dd       	rcall	.-1440   	; 0x70a0 <report_execute_startup_message>
    7640:	0a c0       	rjmp	.+20     	; 0x7656 <system_execute_startup+0x36>
    } else {
      if (line[0] != 0) {
    7642:	f8 01       	movw	r30, r16
    7644:	80 81       	ld	r24, Z
    7646:	88 23       	and	r24, r24
    7648:	31 f0       	breq	.+12     	; 0x7656 <system_execute_startup+0x36>
        uint8_t status_code = gc_execute_line(line);
    764a:	c8 01       	movw	r24, r16
    764c:	0e 94 6c 07 	call	0xed8	; 0xed8 <gc_execute_line>
        report_execute_startup_message(line,status_code);
    7650:	68 2f       	mov	r22, r24
    7652:	c8 01       	movw	r24, r16
    7654:	25 dd       	rcall	.-1462   	; 0x70a0 <report_execute_startup_message>

// Executes user startup script, if stored.
void system_execute_startup(char *line)
{
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    7656:	cf 5f       	subi	r28, 0xFF	; 255
    7658:	c2 30       	cpi	r28, 0x02	; 2
    765a:	39 f7       	brne	.-50     	; 0x762a <system_execute_startup+0xa>
        uint8_t status_code = gc_execute_line(line);
        report_execute_startup_message(line,status_code);
      }
    }
  }
}
    765c:	cf 91       	pop	r28
    765e:	1f 91       	pop	r17
    7660:	0f 91       	pop	r16
    7662:	08 95       	ret

00007664 <system_flag_wco_change>:


void system_flag_wco_change()
{
  #ifdef FORCE_BUFFER_SYNC_DURING_WCO_CHANGE
    protocol_buffer_synchronize();
    7664:	0e 94 2e 19 	call	0x325c	; 0x325c <protocol_buffer_synchronize>
  #endif
  sys.report_wco_counter = 0;
    7668:	10 92 2a 0c 	sts	0x0C2A, r1	; 0x800c2a <sys+0xc>
    766c:	08 95       	ret

0000766e <system_convert_axis_steps_to_mpos>:

// Returns machine position of axis 'idx'. Must be sent a 'step' array.
// NOTE: If motor steps and machine position are not in the same coordinate frame, this function
//   serves as a central place to compute the transformation.
float system_convert_axis_steps_to_mpos(int32_t *steps, uint8_t idx)
{
    766e:	cf 93       	push	r28
    7670:	df 93       	push	r29
      pos = (float)system_convert_corexy_to_y_axis_steps(steps) / settings.steps_per_mm[idx];
    } else {
      pos = steps[idx]/settings.steps_per_mm[idx];
    }
  #else
    pos = steps[idx]/settings.steps_per_mm[idx];
    7672:	c6 2f       	mov	r28, r22
    7674:	d0 e0       	ldi	r29, 0x00	; 0
    7676:	cc 0f       	add	r28, r28
    7678:	dd 1f       	adc	r29, r29
    767a:	cc 0f       	add	r28, r28
    767c:	dd 1f       	adc	r29, r29
    767e:	8c 0f       	add	r24, r28
    7680:	9d 1f       	adc	r25, r29
  #endif
  return(pos);
    7682:	fc 01       	movw	r30, r24
    7684:	60 81       	ld	r22, Z
    7686:	71 81       	ldd	r23, Z+1	; 0x01
    7688:	82 81       	ldd	r24, Z+2	; 0x02
    768a:	93 81       	ldd	r25, Z+3	; 0x03
    768c:	fb d4       	rcall	.+2550   	; 0x8084 <__floatsisf>
      pos = (float)system_convert_corexy_to_y_axis_steps(steps) / settings.steps_per_mm[idx];
    } else {
      pos = steps[idx]/settings.steps_per_mm[idx];
    }
  #else
    pos = steps[idx]/settings.steps_per_mm[idx];
    768e:	c0 53       	subi	r28, 0x30	; 48
    7690:	d1 4f       	sbci	r29, 0xF1	; 241
  #endif
  return(pos);
    7692:	28 81       	ld	r18, Y
    7694:	39 81       	ldd	r19, Y+1	; 0x01
    7696:	4a 81       	ldd	r20, Y+2	; 0x02
    7698:	5b 81       	ldd	r21, Y+3	; 0x03
    769a:	59 d4       	rcall	.+2226   	; 0x7f4e <__divsf3>
}
    769c:	df 91       	pop	r29
    769e:	cf 91       	pop	r28
    76a0:	08 95       	ret

000076a2 <system_convert_array_steps_to_mpos>:


void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
    76a2:	ef 92       	push	r14
    76a4:	ff 92       	push	r15
    76a6:	0f 93       	push	r16
    76a8:	1f 93       	push	r17
    76aa:	cf 93       	push	r28
    76ac:	7b 01       	movw	r14, r22
    76ae:	8c 01       	movw	r16, r24
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    76b0:	c0 e0       	ldi	r28, 0x00	; 0
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
    76b2:	6c 2f       	mov	r22, r28
    76b4:	c7 01       	movw	r24, r14
    76b6:	db df       	rcall	.-74     	; 0x766e <system_convert_axis_steps_to_mpos>
    76b8:	f8 01       	movw	r30, r16
    76ba:	61 93       	st	Z+, r22
    76bc:	71 93       	st	Z+, r23
    76be:	81 93       	st	Z+, r24
    76c0:	91 93       	st	Z+, r25
    76c2:	8f 01       	movw	r16, r30


void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    76c4:	cf 5f       	subi	r28, 0xFF	; 255
    76c6:	c3 30       	cpi	r28, 0x03	; 3
    76c8:	a1 f7       	brne	.-24     	; 0x76b2 <system_convert_array_steps_to_mpos+0x10>
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
  }
  return;
}
    76ca:	cf 91       	pop	r28
    76cc:	1f 91       	pop	r17
    76ce:	0f 91       	pop	r16
    76d0:	ff 90       	pop	r15
    76d2:	ef 90       	pop	r14
    76d4:	08 95       	ret

000076d6 <system_check_travel_limits>:
#endif


// Checks and reports if target array exceeds machine travel limits.
uint8_t system_check_travel_limits(float *target)
{
    76d6:	cf 92       	push	r12
    76d8:	df 92       	push	r13
    76da:	ef 92       	push	r14
    76dc:	ff 92       	push	r15
    76de:	cf 93       	push	r28
    76e0:	df 93       	push	r29
    76e2:	ec 01       	movw	r28, r24
      } else {
        if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { return(true); }
      }
    #else
      // NOTE: max_travel is stored as negative
      if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { return(true); }
    76e4:	c8 80       	ld	r12, Y
    76e6:	d9 80       	ldd	r13, Y+1	; 0x01
    76e8:	ea 80       	ldd	r14, Y+2	; 0x02
    76ea:	fb 80       	ldd	r15, Y+3	; 0x03
    76ec:	20 e0       	ldi	r18, 0x00	; 0
    76ee:	30 e0       	ldi	r19, 0x00	; 0
    76f0:	a9 01       	movw	r20, r18
    76f2:	c7 01       	movw	r24, r14
    76f4:	b6 01       	movw	r22, r12
    76f6:	27 d6       	rcall	.+3150   	; 0x8346 <__gesf2>
    76f8:	18 16       	cp	r1, r24
    76fa:	0c f4       	brge	.+2      	; 0x76fe <system_check_travel_limits+0x28>
    76fc:	41 c0       	rjmp	.+130    	; 0x7780 <system_check_travel_limits+0xaa>
    76fe:	20 91 f4 0e 	lds	r18, 0x0EF4	; 0x800ef4 <settings+0x24>
    7702:	30 91 f5 0e 	lds	r19, 0x0EF5	; 0x800ef5 <settings+0x25>
    7706:	40 91 f6 0e 	lds	r20, 0x0EF6	; 0x800ef6 <settings+0x26>
    770a:	50 91 f7 0e 	lds	r21, 0x0EF7	; 0x800ef7 <settings+0x27>
    770e:	c7 01       	movw	r24, r14
    7710:	b6 01       	movw	r22, r12
    7712:	16 d4       	rcall	.+2092   	; 0x7f40 <__cmpsf2>
    7714:	88 23       	and	r24, r24
    7716:	b4 f1       	brlt	.+108    	; 0x7784 <system_check_travel_limits+0xae>
    7718:	cc 80       	ldd	r12, Y+4	; 0x04
    771a:	dd 80       	ldd	r13, Y+5	; 0x05
    771c:	ee 80       	ldd	r14, Y+6	; 0x06
    771e:	ff 80       	ldd	r15, Y+7	; 0x07
    7720:	20 e0       	ldi	r18, 0x00	; 0
    7722:	30 e0       	ldi	r19, 0x00	; 0
    7724:	a9 01       	movw	r20, r18
    7726:	c7 01       	movw	r24, r14
    7728:	b6 01       	movw	r22, r12
    772a:	0d d6       	rcall	.+3098   	; 0x8346 <__gesf2>
    772c:	18 16       	cp	r1, r24
    772e:	64 f1       	brlt	.+88     	; 0x7788 <system_check_travel_limits+0xb2>
    7730:	20 91 f8 0e 	lds	r18, 0x0EF8	; 0x800ef8 <settings+0x28>
    7734:	30 91 f9 0e 	lds	r19, 0x0EF9	; 0x800ef9 <settings+0x29>
    7738:	40 91 fa 0e 	lds	r20, 0x0EFA	; 0x800efa <settings+0x2a>
    773c:	50 91 fb 0e 	lds	r21, 0x0EFB	; 0x800efb <settings+0x2b>
    7740:	c7 01       	movw	r24, r14
    7742:	b6 01       	movw	r22, r12
    7744:	fd d3       	rcall	.+2042   	; 0x7f40 <__cmpsf2>
    7746:	88 23       	and	r24, r24
    7748:	0c f1       	brlt	.+66     	; 0x778c <system_check_travel_limits+0xb6>
    774a:	c8 84       	ldd	r12, Y+8	; 0x08
    774c:	d9 84       	ldd	r13, Y+9	; 0x09
    774e:	ea 84       	ldd	r14, Y+10	; 0x0a
    7750:	fb 84       	ldd	r15, Y+11	; 0x0b
    7752:	20 e0       	ldi	r18, 0x00	; 0
    7754:	30 e0       	ldi	r19, 0x00	; 0
    7756:	a9 01       	movw	r20, r18
    7758:	c7 01       	movw	r24, r14
    775a:	b6 01       	movw	r22, r12
    775c:	f4 d5       	rcall	.+3048   	; 0x8346 <__gesf2>
    775e:	18 16       	cp	r1, r24
    7760:	bc f0       	brlt	.+46     	; 0x7790 <system_check_travel_limits+0xba>
    7762:	20 91 fc 0e 	lds	r18, 0x0EFC	; 0x800efc <settings+0x2c>
    7766:	30 91 fd 0e 	lds	r19, 0x0EFD	; 0x800efd <settings+0x2d>
    776a:	40 91 fe 0e 	lds	r20, 0x0EFE	; 0x800efe <settings+0x2e>
    776e:	50 91 ff 0e 	lds	r21, 0x0EFF	; 0x800eff <settings+0x2f>
    7772:	c7 01       	movw	r24, r14
    7774:	b6 01       	movw	r22, r12
    7776:	e4 d3       	rcall	.+1992   	; 0x7f40 <__cmpsf2>
    7778:	88 1f       	adc	r24, r24
    777a:	88 27       	eor	r24, r24
    777c:	88 1f       	adc	r24, r24
    777e:	09 c0       	rjmp	.+18     	; 0x7792 <system_check_travel_limits+0xbc>
    7780:	81 e0       	ldi	r24, 0x01	; 1
    7782:	07 c0       	rjmp	.+14     	; 0x7792 <system_check_travel_limits+0xbc>
    7784:	81 e0       	ldi	r24, 0x01	; 1
    7786:	05 c0       	rjmp	.+10     	; 0x7792 <system_check_travel_limits+0xbc>
    7788:	81 e0       	ldi	r24, 0x01	; 1
    778a:	03 c0       	rjmp	.+6      	; 0x7792 <system_check_travel_limits+0xbc>
    778c:	81 e0       	ldi	r24, 0x01	; 1
    778e:	01 c0       	rjmp	.+2      	; 0x7792 <system_check_travel_limits+0xbc>
    7790:	81 e0       	ldi	r24, 0x01	; 1
    #endif
  }
  return(false);
}
    7792:	df 91       	pop	r29
    7794:	cf 91       	pop	r28
    7796:	ff 90       	pop	r15
    7798:	ef 90       	pop	r14
    779a:	df 90       	pop	r13
    779c:	cf 90       	pop	r12
    779e:	08 95       	ret

000077a0 <system_set_exec_state_flag>:


// Special handlers for setting and clearing Grbl's real-time execution flags.
void system_set_exec_state_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    77a0:	9f b7       	in	r25, 0x3f	; 63
  cli();
    77a2:	f8 94       	cli
  sys_rt_exec_state |= (mask);
    77a4:	20 91 31 0c 	lds	r18, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    77a8:	82 2b       	or	r24, r18
    77aa:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <sys_rt_exec_state>
  SREG = sreg;
    77ae:	9f bf       	out	0x3f, r25	; 63
    77b0:	08 95       	ret

000077b2 <system_execute_line>:
// next line during a cycle, so for switches like block delete, the switch only effects
// the lines that are processed afterward, not necessarily real-time during a cycle,
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line)
{
    77b2:	8f 92       	push	r8
    77b4:	9f 92       	push	r9
    77b6:	af 92       	push	r10
    77b8:	bf 92       	push	r11
    77ba:	cf 92       	push	r12
    77bc:	df 92       	push	r13
    77be:	ef 92       	push	r14
    77c0:	ff 92       	push	r15
    77c2:	0f 93       	push	r16
    77c4:	1f 93       	push	r17
    77c6:	cf 93       	push	r28
    77c8:	df 93       	push	r29
    77ca:	cd b7       	in	r28, 0x3d	; 61
    77cc:	de b7       	in	r29, 0x3e	; 62
    77ce:	29 97       	sbiw	r28, 0x09	; 9
    77d0:	0f b6       	in	r0, 0x3f	; 63
    77d2:	f8 94       	cli
    77d4:	de bf       	out	0x3e, r29	; 62
    77d6:	0f be       	out	0x3f, r0	; 63
    77d8:	cd bf       	out	0x3d, r28	; 61
    77da:	8c 01       	movw	r16, r24
  uint8_t char_counter = 1;
    77dc:	81 e0       	ldi	r24, 0x01	; 1
    77de:	89 83       	std	Y+1, r24	; 0x01
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    77e0:	f8 01       	movw	r30, r16
    77e2:	81 81       	ldd	r24, Z+1	; 0x01
    77e4:	83 34       	cpi	r24, 0x43	; 67
    77e6:	09 f1       	breq	.+66     	; 0x782a <system_execute_line+0x78>
    77e8:	30 f4       	brcc	.+12     	; 0x77f6 <system_execute_line+0x44>
    77ea:	88 23       	and	r24, r24
    77ec:	61 f0       	breq	.+24     	; 0x7806 <system_execute_line+0x54>
    77ee:	84 32       	cpi	r24, 0x24	; 36
    77f0:	09 f0       	breq	.+2      	; 0x77f4 <system_execute_line+0x42>
    77f2:	56 c0       	rjmp	.+172    	; 0x78a0 <system_execute_line+0xee>
    77f4:	1a c0       	rjmp	.+52     	; 0x782a <system_execute_line+0x78>
    77f6:	8a 34       	cpi	r24, 0x4A	; 74
    77f8:	49 f0       	breq	.+18     	; 0x780c <system_execute_line+0x5a>
    77fa:	88 35       	cpi	r24, 0x58	; 88
    77fc:	b1 f0       	breq	.+44     	; 0x782a <system_execute_line+0x78>
    77fe:	87 34       	cpi	r24, 0x47	; 71
    7800:	09 f0       	breq	.+2      	; 0x7804 <system_execute_line+0x52>
    7802:	4e c0       	rjmp	.+156    	; 0x78a0 <system_execute_line+0xee>
    7804:	12 c0       	rjmp	.+36     	; 0x782a <system_execute_line+0x78>
    case 0 : report_grbl_help(); break;
    7806:	15 da       	rcall	.-3030   	; 0x6c32 <report_grbl_help>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7808:	f1 2c       	mov	r15, r1
{
  uint8_t char_counter = 1;
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    780a:	14 c2       	rjmp	.+1064   	; 0x7c34 <system_execute_line+0x482>
    case 'J' : // Jogging
      // Execute only if in IDLE or JOG states.
      if (sys.state != STATE_IDLE && sys.state != STATE_JOG) { return(STATUS_IDLE_ERROR); }
    780c:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    7810:	8f 7d       	andi	r24, 0xDF	; 223
    7812:	09 f0       	breq	.+2      	; 0x7816 <system_execute_line+0x64>
    7814:	85 c1       	rjmp	.+778    	; 0x7b20 <system_execute_line+0x36e>
      if(line[2] != '=') { return(STATUS_INVALID_STATEMENT); }
    7816:	f8 01       	movw	r30, r16
    7818:	82 81       	ldd	r24, Z+2	; 0x02
    781a:	8d 33       	cpi	r24, 0x3D	; 61
    781c:	09 f0       	breq	.+2      	; 0x7820 <system_execute_line+0x6e>
    781e:	84 c1       	rjmp	.+776    	; 0x7b28 <system_execute_line+0x376>
      return(gc_execute_line(line)); // NOTE: $J= is ignored inside g-code parser and used to detect jog motions.
    7820:	c8 01       	movw	r24, r16
    7822:	0e 94 6c 07 	call	0xed8	; 0xed8 <gc_execute_line>
    7826:	f8 2e       	mov	r15, r24
    7828:	05 c2       	rjmp	.+1034   	; 0x7c34 <system_execute_line+0x482>
      break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    782a:	f8 01       	movw	r30, r16
    782c:	92 81       	ldd	r25, Z+2	; 0x02
    782e:	91 11       	cpse	r25, r1
    7830:	80 c1       	rjmp	.+768    	; 0x7b32 <system_execute_line+0x380>
      switch( line[1] ) {
    7832:	83 34       	cpi	r24, 0x43	; 67
    7834:	a1 f0       	breq	.+40     	; 0x785e <system_execute_line+0xac>
    7836:	18 f4       	brcc	.+6      	; 0x783e <system_execute_line+0x8c>
    7838:	84 32       	cpi	r24, 0x24	; 36
    783a:	31 f0       	breq	.+12     	; 0x7848 <system_execute_line+0x96>
    783c:	7f c1       	rjmp	.+766    	; 0x7b3c <system_execute_line+0x38a>
    783e:	87 34       	cpi	r24, 0x47	; 71
    7840:	59 f0       	breq	.+22     	; 0x7858 <system_execute_line+0xa6>
    7842:	88 35       	cpi	r24, 0x58	; 88
    7844:	f9 f0       	breq	.+62     	; 0x7884 <system_execute_line+0xd2>
    7846:	7a c1       	rjmp	.+756    	; 0x7b3c <system_execute_line+0x38a>
    7848:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    784c:	88 71       	andi	r24, 0x18	; 24
    784e:	f8 2e       	mov	r15, r24
        case '$' : // Prints Grbl settings
          if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    7850:	09 f0       	breq	.+2      	; 0x7854 <system_execute_line+0xa2>
          else { report_grbl_settings(); }
    7852:	76 c1       	rjmp	.+748    	; 0x7b40 <system_execute_line+0x38e>
          break;
    7854:	f2 d9       	rcall	.-3100   	; 0x6c3a <report_grbl_settings>
        case 'G' : // Prints gcode parser state
          // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
          report_gcode_modes();
    7856:	ee c1       	rjmp	.+988    	; 0x7c34 <system_execute_line+0x482>
    7858:	7e db       	rcall	.-2308   	; 0x6f56 <report_gcode_modes>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    785a:	f1 2c       	mov	r15, r1
          else { report_grbl_settings(); }
          break;
        case 'G' : // Prints gcode parser state
          // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
          report_gcode_modes();
          break;
    785c:	eb c1       	rjmp	.+982    	; 0x7c34 <system_execute_line+0x482>
        case 'C' : // Set check g-code mode [IDLE/CHECK]
          // Perform reset when toggling off. Check g-code mode should only work if Grbl
          // is idle and ready, regardless of alarm locks. This is mainly to keep things
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) {
    785e:	f0 90 1e 0c 	lds	r15, 0x0C1E	; 0x800c1e <sys>
    7862:	f2 e0       	ldi	r31, 0x02	; 2
    7864:	ff 12       	cpse	r15, r31
    7866:	06 c0       	rjmp	.+12     	; 0x7874 <system_execute_line+0xc2>
            mc_reset();
    7868:	0e 94 2f 07 	call	0xe5e	; 0xe5e <mc_reset>
            report_feedback_message(MESSAGE_DISABLED);
    786c:	85 e0       	ldi	r24, 0x05	; 5
    786e:	9d d9       	rcall	.-3270   	; 0x6baa <report_feedback_message>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7870:	f1 2c       	mov	r15, r1
    7872:	e0 c1       	rjmp	.+960    	; 0x7c34 <system_execute_line+0x482>
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) {
            mc_reset();
            report_feedback_message(MESSAGE_DISABLED);
          } else {
            if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    7874:	f1 10       	cpse	r15, r1
    7876:	68 c1       	rjmp	.+720    	; 0x7b48 <system_execute_line+0x396>
            sys.state = STATE_CHECK_MODE;
    7878:	82 e0       	ldi	r24, 0x02	; 2
    787a:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
            report_feedback_message(MESSAGE_ENABLED);
    787e:	84 e0       	ldi	r24, 0x04	; 4
    7880:	94 d9       	rcall	.-3288   	; 0x6baa <report_feedback_message>
    7882:	d8 c1       	rjmp	.+944    	; 0x7c34 <system_execute_line+0x482>
          }
          break;
        case 'X' : // Disable alarm lock [ALARM]
          if (sys.state == STATE_ALARM) {
    7884:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    7888:	81 30       	cpi	r24, 0x01	; 1
    788a:	09 f0       	breq	.+2      	; 0x788e <system_execute_line+0xdc>
            // Block if safety door is ajar.
            if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); }
    788c:	61 c1       	rjmp	.+706    	; 0x7b50 <system_execute_line+0x39e>
    788e:	c5 de       	rcall	.-630    	; 0x761a <system_check_safety_door_ajar>
    7890:	f8 2e       	mov	r15, r24
    7892:	81 11       	cpse	r24, r1
            report_feedback_message(MESSAGE_ALARM_UNLOCK);
    7894:	5f c1       	rjmp	.+702    	; 0x7b54 <system_execute_line+0x3a2>
    7896:	83 e0       	ldi	r24, 0x03	; 3
    7898:	88 d9       	rcall	.-3312   	; 0x6baa <report_feedback_message>
            sys.state = STATE_IDLE;
    789a:	10 92 1e 0c 	sts	0x0C1E, r1	; 0x800c1e <sys>
    789e:	ca c1       	rjmp	.+916    	; 0x7c34 <system_execute_line+0x482>
          break;
      }
      break;
    default :
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    78a0:	90 91 1e 0c 	lds	r25, 0x0C1E	; 0x800c1e <sys>
    78a4:	92 30       	cpi	r25, 0x02	; 2
    78a6:	08 f0       	brcs	.+2      	; 0x78aa <system_execute_line+0xf8>
    78a8:	5a c1       	rjmp	.+692    	; 0x7b5e <system_execute_line+0x3ac>
      switch( line[1] ) {
    78aa:	89 34       	cpi	r24, 0x49	; 73
    78ac:	09 f4       	brne	.+2      	; 0x78b0 <system_execute_line+0xfe>
    78ae:	5e c0       	rjmp	.+188    	; 0x796c <system_execute_line+0x1ba>
    78b0:	28 f4       	brcc	.+10     	; 0x78bc <system_execute_line+0x10a>
    78b2:	83 32       	cpi	r24, 0x23	; 35
    78b4:	69 f0       	breq	.+26     	; 0x78d0 <system_execute_line+0x11e>
    78b6:	88 34       	cpi	r24, 0x48	; 72
    78b8:	91 f0       	breq	.+36     	; 0x78de <system_execute_line+0x12c>
    78ba:	c2 c0       	rjmp	.+388    	; 0x7a40 <system_execute_line+0x28e>
    78bc:	82 35       	cpi	r24, 0x52	; 82
    78be:	09 f4       	brne	.+2      	; 0x78c2 <system_execute_line+0x110>
    78c0:	77 c0       	rjmp	.+238    	; 0x79b0 <system_execute_line+0x1fe>
    78c2:	83 35       	cpi	r24, 0x53	; 83
    78c4:	09 f4       	brne	.+2      	; 0x78c8 <system_execute_line+0x116>
    78c6:	42 c0       	rjmp	.+132    	; 0x794c <system_execute_line+0x19a>
    78c8:	8e 34       	cpi	r24, 0x4E	; 78
    78ca:	09 f0       	breq	.+2      	; 0x78ce <system_execute_line+0x11c>
    78cc:	b9 c0       	rjmp	.+370    	; 0x7a40 <system_execute_line+0x28e>
    78ce:	9a c0       	rjmp	.+308    	; 0x7a04 <system_execute_line+0x252>
        case '#' : // Print Grbl NGC parameters
          if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    78d0:	f8 01       	movw	r30, r16
    78d2:	82 81       	ldd	r24, Z+2	; 0x02
    78d4:	81 11       	cpse	r24, r1
          else { report_ngc_parameters(); }
    78d6:	47 c1       	rjmp	.+654    	; 0x7b66 <system_execute_line+0x3b4>
    78d8:	d7 da       	rcall	.-2642   	; 0x6e88 <report_ngc_parameters>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    78da:	f1 2c       	mov	r15, r1
        case '#' : // Print Grbl NGC parameters
          if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
          else { report_ngc_parameters(); }
          break;
        case 'H' : // Perform homing cycle [IDLE/ALARM]
          if (bit_isfalse(settings.flags,BITFLAG_HOMING_ENABLE)) {return(STATUS_SETTING_DISABLED); }
    78dc:	ab c1       	rjmp	.+854    	; 0x7c34 <system_execute_line+0x482>
    78de:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    78e2:	84 ff       	sbrs	r24, 4
          if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); } // Block if safety door is ajar.
    78e4:	45 c1       	rjmp	.+650    	; 0x7b70 <system_execute_line+0x3be>
    78e6:	99 de       	rcall	.-718    	; 0x761a <system_check_safety_door_ajar>
    78e8:	e8 2e       	mov	r14, r24
    78ea:	81 11       	cpse	r24, r1
    78ec:	46 c1       	rjmp	.+652    	; 0x7b7a <system_execute_line+0x3c8>
          sys.state = STATE_HOMING; // Set system state variable
    78ee:	84 e0       	ldi	r24, 0x04	; 4
    78f0:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
          if (line[2] == 0) {
    78f4:	f8 01       	movw	r30, r16
    78f6:	82 81       	ldd	r24, Z+2	; 0x02
    78f8:	81 11       	cpse	r24, r1
    78fa:	03 c0       	rjmp	.+6      	; 0x7902 <system_execute_line+0x150>
            mc_homing_cycle(HOMING_CYCLE_ALL);
    78fc:	0e 94 9d 06 	call	0xd3a	; 0xd3a <mc_homing_cycle>
    7900:	16 c0       	rjmp	.+44     	; 0x792e <system_execute_line+0x17c>
          #ifdef HOMING_SINGLE_AXIS_COMMANDS
            } else if (line[3] == 0) {
    7902:	f8 01       	movw	r30, r16
    7904:	93 81       	ldd	r25, Z+3	; 0x03
    7906:	91 11       	cpse	r25, r1
    7908:	3d c1       	rjmp	.+634    	; 0x7b84 <system_execute_line+0x3d2>
              switch (line[2]) {
    790a:	89 35       	cpi	r24, 0x59	; 89
    790c:	49 f0       	breq	.+18     	; 0x7920 <system_execute_line+0x16e>
    790e:	8a 35       	cpi	r24, 0x5A	; 90
    7910:	59 f0       	breq	.+22     	; 0x7928 <system_execute_line+0x176>
    7912:	88 35       	cpi	r24, 0x58	; 88
    7914:	09 f0       	breq	.+2      	; 0x7918 <system_execute_line+0x166>
    7916:	3b c1       	rjmp	.+630    	; 0x7b8e <system_execute_line+0x3dc>
                case 'X': mc_homing_cycle(HOMING_CYCLE_X); break;
    7918:	81 e0       	ldi	r24, 0x01	; 1
    791a:	0e 94 9d 06 	call	0xd3a	; 0xd3a <mc_homing_cycle>
    791e:	07 c0       	rjmp	.+14     	; 0x792e <system_execute_line+0x17c>
                case 'Y': mc_homing_cycle(HOMING_CYCLE_Y); break;
    7920:	82 e0       	ldi	r24, 0x02	; 2
    7922:	0e 94 9d 06 	call	0xd3a	; 0xd3a <mc_homing_cycle>
    7926:	03 c0       	rjmp	.+6      	; 0x792e <system_execute_line+0x17c>
                case 'Z': mc_homing_cycle(HOMING_CYCLE_Z); break;
    7928:	84 e0       	ldi	r24, 0x04	; 4
    792a:	0e 94 9d 06 	call	0xd3a	; 0xd3a <mc_homing_cycle>
                default: return(STATUS_INVALID_STATEMENT);
              }
          #endif
          } else { return(STATUS_INVALID_STATEMENT); }
          if (!sys.abort) {  // Execute startup scripts after successful homing.
    792e:	f0 90 1f 0c 	lds	r15, 0x0C1F	; 0x800c1f <sys+0x1>
    7932:	f1 10       	cpse	r15, r1
    7934:	31 c1       	rjmp	.+610    	; 0x7b98 <system_execute_line+0x3e6>
            sys.state = STATE_IDLE; // Set to IDLE when complete.
    7936:	10 92 1e 0c 	sts	0x0C1E, r1	; 0x800c1e <sys>
            st_go_idle(); // Set steppers to the settings idle state before returning.
    793a:	0e 94 59 19 	call	0x32b2	; 0x32b2 <st_go_idle>
            if (line[2] == 0) { system_execute_startup(line); }
    793e:	f8 01       	movw	r30, r16
    7940:	82 81       	ldd	r24, Z+2	; 0x02
    7942:	81 11       	cpse	r24, r1
    7944:	77 c1       	rjmp	.+750    	; 0x7c34 <system_execute_line+0x482>
    7946:	c8 01       	movw	r24, r16
    7948:	6b de       	rcall	.-810    	; 0x7620 <system_execute_startup>
    794a:	74 c1       	rjmp	.+744    	; 0x7c34 <system_execute_line+0x482>
          }
          break;
        case 'S' : // Puts Grbl to sleep [IDLE/ALARM]
          if ((line[2] != 'L') || (line[3] != 'P') || (line[4] != 0)) { return(STATUS_INVALID_STATEMENT); }
    794c:	f8 01       	movw	r30, r16
    794e:	82 81       	ldd	r24, Z+2	; 0x02
    7950:	8c 34       	cpi	r24, 0x4C	; 76
    7952:	09 f0       	breq	.+2      	; 0x7956 <system_execute_line+0x1a4>
    7954:	23 c1       	rjmp	.+582    	; 0x7b9c <system_execute_line+0x3ea>
    7956:	83 81       	ldd	r24, Z+3	; 0x03
    7958:	80 35       	cpi	r24, 0x50	; 80
    795a:	09 f0       	breq	.+2      	; 0x795e <system_execute_line+0x1ac>
    795c:	24 c1       	rjmp	.+584    	; 0x7ba6 <system_execute_line+0x3f4>
    795e:	84 81       	ldd	r24, Z+4	; 0x04
    7960:	81 11       	cpse	r24, r1
          system_set_exec_state_flag(EXEC_SLEEP); // Set to execute sleep mode immediately
    7962:	26 c1       	rjmp	.+588    	; 0x7bb0 <system_execute_line+0x3fe>
    7964:	80 e8       	ldi	r24, 0x80	; 128
    7966:	1c df       	rcall	.-456    	; 0x77a0 <system_set_exec_state_flag>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7968:	f1 2c       	mov	r15, r1
          }
          break;
        case 'S' : // Puts Grbl to sleep [IDLE/ALARM]
          if ((line[2] != 'L') || (line[3] != 'P') || (line[4] != 0)) { return(STATUS_INVALID_STATEMENT); }
          system_set_exec_state_flag(EXEC_SLEEP); // Set to execute sleep mode immediately
          break;
    796a:	64 c1       	rjmp	.+712    	; 0x7c34 <system_execute_line+0x482>
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) {
    796c:	82 e0       	ldi	r24, 0x02	; 2
    796e:	89 83       	std	Y+1, r24	; 0x01
    7970:	f8 01       	movw	r30, r16
    7972:	82 81       	ldd	r24, Z+2	; 0x02
    7974:	81 11       	cpse	r24, r1
            settings_read_build_info(line);
    7976:	07 c0       	rjmp	.+14     	; 0x7986 <system_execute_line+0x1d4>
    7978:	c8 01       	movw	r24, r16
    797a:	0e 94 09 26 	call	0x4c12	; 0x4c12 <settings_read_build_info>
            report_build_info(line);
    797e:	c8 01       	movw	r24, r16
    7980:	a2 db       	rcall	.-2236   	; 0x70c6 <report_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7982:	f1 2c       	mov	r15, r1
    7984:	57 c1       	rjmp	.+686    	; 0x7c34 <system_execute_line+0x482>
          if ( line[++char_counter] == 0 ) {
            settings_read_build_info(line);
            report_build_info(line);
          #ifdef ENABLE_BUILD_INFO_WRITE_COMMAND
            } else { // Store startup line [IDLE/ALARM]
              if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    7986:	8d 33       	cpi	r24, 0x3D	; 61
    7988:	09 f0       	breq	.+2      	; 0x798c <system_execute_line+0x1da>
    798a:	17 c1       	rjmp	.+558    	; 0x7bba <system_execute_line+0x408>
    798c:	83 e0       	ldi	r24, 0x03	; 3
              helper_var = char_counter; // Set helper variable as counter to start of user info line.
              do {
                line[char_counter-helper_var] = line[char_counter];
    798e:	f8 01       	movw	r30, r16
    7990:	e8 0f       	add	r30, r24
    7992:	f1 1d       	adc	r31, r1
    7994:	90 81       	ld	r25, Z
    7996:	df 01       	movw	r26, r30
    7998:	13 97       	sbiw	r26, 0x03	; 3
    799a:	9c 93       	st	X, r25
              } while (line[char_counter++] != 0);
    799c:	8f 5f       	subi	r24, 0xFF	; 255
    799e:	90 81       	ld	r25, Z
    79a0:	91 11       	cpse	r25, r1
    79a2:	f5 cf       	rjmp	.-22     	; 0x798e <system_execute_line+0x1dc>
    79a4:	89 83       	std	Y+1, r24	; 0x01
              settings_store_build_info(line);
    79a6:	c8 01       	movw	r24, r16
    79a8:	0e 94 72 25 	call	0x4ae4	; 0x4ae4 <settings_store_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    79ac:	f1 2c       	mov	r15, r1
    79ae:	42 c1       	rjmp	.+644    	; 0x7c34 <system_execute_line+0x482>
              settings_store_build_info(line);
          #endif
          }
          break;
        case 'R' : // Restore defaults [IDLE/ALARM]
          if ((line[2] != 'S') || (line[3] != 'T') || (line[4] != '=') || (line[6] != 0)) { return(STATUS_INVALID_STATEMENT); }
    79b0:	f8 01       	movw	r30, r16
    79b2:	82 81       	ldd	r24, Z+2	; 0x02
    79b4:	83 35       	cpi	r24, 0x53	; 83
    79b6:	09 f0       	breq	.+2      	; 0x79ba <system_execute_line+0x208>
    79b8:	05 c1       	rjmp	.+522    	; 0x7bc4 <system_execute_line+0x412>
    79ba:	83 81       	ldd	r24, Z+3	; 0x03
    79bc:	84 35       	cpi	r24, 0x54	; 84
    79be:	09 f0       	breq	.+2      	; 0x79c2 <system_execute_line+0x210>
    79c0:	06 c1       	rjmp	.+524    	; 0x7bce <system_execute_line+0x41c>
    79c2:	84 81       	ldd	r24, Z+4	; 0x04
    79c4:	8d 33       	cpi	r24, 0x3D	; 61
    79c6:	09 f0       	breq	.+2      	; 0x79ca <system_execute_line+0x218>
    79c8:	07 c1       	rjmp	.+526    	; 0x7bd8 <system_execute_line+0x426>
    79ca:	86 81       	ldd	r24, Z+6	; 0x06
    79cc:	81 11       	cpse	r24, r1
    79ce:	09 c1       	rjmp	.+530    	; 0x7be2 <system_execute_line+0x430>
          switch (line[5]) {
    79d0:	85 81       	ldd	r24, Z+5	; 0x05
    79d2:	84 32       	cpi	r24, 0x24	; 36
    79d4:	31 f0       	breq	.+12     	; 0x79e2 <system_execute_line+0x230>
    79d6:	8a 32       	cpi	r24, 0x2A	; 42
    79d8:	61 f0       	breq	.+24     	; 0x79f2 <system_execute_line+0x240>
    79da:	83 32       	cpi	r24, 0x23	; 35
    79dc:	09 f0       	breq	.+2      	; 0x79e0 <system_execute_line+0x22e>
    79de:	06 c1       	rjmp	.+524    	; 0x7bec <system_execute_line+0x43a>
    79e0:	04 c0       	rjmp	.+8      	; 0x79ea <system_execute_line+0x238>
            #ifdef ENABLE_RESTORE_EEPROM_DEFAULT_SETTINGS
              case '$': settings_restore(SETTINGS_RESTORE_DEFAULTS); break;
    79e2:	81 e0       	ldi	r24, 0x01	; 1
    79e4:	0e 94 99 25 	call	0x4b32	; 0x4b32 <settings_restore>
            #endif
            #ifdef ENABLE_RESTORE_EEPROM_CLEAR_PARAMETERS
              case '#': settings_restore(SETTINGS_RESTORE_PARAMETERS); break;
    79e8:	07 c0       	rjmp	.+14     	; 0x79f8 <system_execute_line+0x246>
    79ea:	82 e0       	ldi	r24, 0x02	; 2
    79ec:	0e 94 99 25 	call	0x4b32	; 0x4b32 <settings_restore>
            #endif
            #ifdef ENABLE_RESTORE_EEPROM_WIPE_ALL
              case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
    79f0:	03 c0       	rjmp	.+6      	; 0x79f8 <system_execute_line+0x246>
    79f2:	8f ef       	ldi	r24, 0xFF	; 255
    79f4:	0e 94 99 25 	call	0x4b32	; 0x4b32 <settings_restore>
            #endif
            default: return(STATUS_INVALID_STATEMENT);
          }
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
    79f8:	89 e0       	ldi	r24, 0x09	; 9
    79fa:	d7 d8       	rcall	.-3666   	; 0x6baa <report_feedback_message>
          mc_reset(); // Force reset to ensure settings are initialized correctly.
    79fc:	0e 94 2f 07 	call	0xe5e	; 0xe5e <mc_reset>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7a00:	f1 2c       	mov	r15, r1
            #endif
            default: return(STATUS_INVALID_STATEMENT);
          }
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
          mc_reset(); // Force reset to ensure settings are initialized correctly.
          break;
    7a02:	18 c1       	rjmp	.+560    	; 0x7c34 <system_execute_line+0x482>
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
    7a04:	82 e0       	ldi	r24, 0x02	; 2
    7a06:	89 83       	std	Y+1, r24	; 0x01
    7a08:	f8 01       	movw	r30, r16
    7a0a:	82 81       	ldd	r24, Z+2	; 0x02
    7a0c:	81 11       	cpse	r24, r1
    7a0e:	13 c0       	rjmp	.+38     	; 0x7a36 <system_execute_line+0x284>
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
              if (!(settings_read_startup_line(helper_var, line))) {
    7a10:	f1 2c       	mov	r15, r1
    7a12:	b8 01       	movw	r22, r16
    7a14:	8f 2d       	mov	r24, r15
    7a16:	0e 94 eb 25 	call	0x4bd6	; 0x4bd6 <settings_read_startup_line>
                report_status_message(STATUS_SETTING_READ_FAIL);
    7a1a:	81 11       	cpse	r24, r1
    7a1c:	03 c0       	rjmp	.+6      	; 0x7a24 <system_execute_line+0x272>
    7a1e:	87 e0       	ldi	r24, 0x07	; 7
    7a20:	4f d8       	rcall	.-3938   	; 0x6ac0 <report_status_message>
              } else {
                report_startup_line(helper_var,line);
    7a22:	03 c0       	rjmp	.+6      	; 0x7a2a <system_execute_line+0x278>
    7a24:	b8 01       	movw	r22, r16
    7a26:	8f 2d       	mov	r24, r15
    7a28:	27 db       	rcall	.-2482   	; 0x7078 <report_startup_line>
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
          mc_reset(); // Force reset to ensure settings are initialized correctly.
          break;
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
    7a2a:	f3 94       	inc	r15
    7a2c:	f2 e0       	ldi	r31, 0x02	; 2
    7a2e:	ff 12       	cpse	r15, r31
    7a30:	f0 cf       	rjmp	.-32     	; 0x7a12 <system_execute_line+0x260>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7a32:	f1 2c       	mov	r15, r1
    7a34:	ff c0       	rjmp	.+510    	; 0x7c34 <system_execute_line+0x482>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    7a36:	91 11       	cpse	r25, r1
    7a38:	de c0       	rjmp	.+444    	; 0x7bf6 <system_execute_line+0x444>
            helper_var = true;  // Set helper_var to flag storing method.
    7a3a:	ff 24       	eor	r15, r15
    7a3c:	f3 94       	inc	r15
    7a3e:	01 c0       	rjmp	.+2      	; 0x7a42 <system_execute_line+0x290>
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line)
{
  uint8_t char_counter = 1;
  uint8_t helper_var = 0; // Helper variable
    7a40:	f1 2c       	mov	r15, r1
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
            helper_var = true;  // Set helper_var to flag storing method.
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    7a42:	ae 01       	movw	r20, r28
    7a44:	4e 5f       	subi	r20, 0xFE	; 254
    7a46:	5f 4f       	sbci	r21, 0xFF	; 255
    7a48:	be 01       	movw	r22, r28
    7a4a:	6f 5f       	subi	r22, 0xFF	; 255
    7a4c:	7f 4f       	sbci	r23, 0xFF	; 255
    7a4e:	c8 01       	movw	r24, r16
    7a50:	0e 94 2f 2e 	call	0x5c5e	; 0x5c5e <read_float>
    7a54:	88 23       	and	r24, r24
    7a56:	09 f4       	brne	.+2      	; 0x7a5a <system_execute_line+0x2a8>
    7a58:	d2 c0       	rjmp	.+420    	; 0x7bfe <system_execute_line+0x44c>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    7a5a:	89 81       	ldd	r24, Y+1	; 0x01
    7a5c:	41 e0       	ldi	r20, 0x01	; 1
    7a5e:	48 0f       	add	r20, r24
    7a60:	49 83       	std	Y+1, r20	; 0x01
    7a62:	f8 01       	movw	r30, r16
    7a64:	e8 0f       	add	r30, r24
    7a66:	f1 1d       	adc	r31, r1
    7a68:	80 81       	ld	r24, Z
    7a6a:	8d 33       	cpi	r24, 0x3D	; 61
    7a6c:	09 f0       	breq	.+2      	; 0x7a70 <system_execute_line+0x2be>
    7a6e:	cb c0       	rjmp	.+406    	; 0x7c06 <system_execute_line+0x454>
          if (helper_var) { // Store startup line
    7a70:	ff 20       	and	r15, r15
    7a72:	39 f1       	breq	.+78     	; 0x7ac2 <system_execute_line+0x310>
    7a74:	24 2f       	mov	r18, r20
            // Prepare sending gcode block to gcode parser by shifting all characters
            helper_var = char_counter; // Set helper variable as counter to start of gcode block
            do {
              line[char_counter-helper_var] = line[char_counter];
    7a76:	50 e0       	ldi	r21, 0x00	; 0
    7a78:	82 2f       	mov	r24, r18
    7a7a:	90 e0       	ldi	r25, 0x00	; 0
    7a7c:	d8 01       	movw	r26, r16
    7a7e:	a8 0f       	add	r26, r24
    7a80:	b9 1f       	adc	r27, r25
    7a82:	3c 91       	ld	r19, X
    7a84:	84 1b       	sub	r24, r20
    7a86:	95 0b       	sbc	r25, r21
    7a88:	f8 01       	movw	r30, r16
    7a8a:	e8 0f       	add	r30, r24
    7a8c:	f9 1f       	adc	r31, r25
    7a8e:	30 83       	st	Z, r19
            } while (line[char_counter++] != 0);
    7a90:	2f 5f       	subi	r18, 0xFF	; 255
    7a92:	8c 91       	ld	r24, X
    7a94:	81 11       	cpse	r24, r1
    7a96:	f0 cf       	rjmp	.-32     	; 0x7a78 <system_execute_line+0x2c6>
    7a98:	29 83       	std	Y+1, r18	; 0x01
            if (char_counter > EEPROM_LINE_SIZE) { return(STATUS_LINE_LENGTH_EXCEEDED); }
    7a9a:	21 35       	cpi	r18, 0x51	; 81
    7a9c:	08 f0       	brcs	.+2      	; 0x7aa0 <system_execute_line+0x2ee>
    7a9e:	b8 c0       	rjmp	.+368    	; 0x7c10 <system_execute_line+0x45e>
            // Execute gcode block to ensure block is valid.
            helper_var = gc_execute_line(line); // Set helper_var to returned status code.
    7aa0:	c8 01       	movw	r24, r16
    7aa2:	0e 94 6c 07 	call	0xed8	; 0xed8 <gc_execute_line>
            if (helper_var) { return(helper_var); }
    7aa6:	f8 2e       	mov	r15, r24
            else {
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
    7aa8:	81 11       	cpse	r24, r1
    7aaa:	c4 c0       	rjmp	.+392    	; 0x7c34 <system_execute_line+0x482>
    7aac:	6a 81       	ldd	r22, Y+2	; 0x02
    7aae:	7b 81       	ldd	r23, Y+3	; 0x03
    7ab0:	8c 81       	ldd	r24, Y+4	; 0x04
    7ab2:	9d 81       	ldd	r25, Y+5	; 0x05
              settings_store_startup_line(helper_var,line);
    7ab4:	51 d5       	rcall	.+2722   	; 0x8558 <trunc>
    7ab6:	b8 d2       	rcall	.+1392   	; 0x8028 <__fixunssfsi>
    7ab8:	86 2f       	mov	r24, r22
    7aba:	b8 01       	movw	r22, r16
    7abc:	0e 94 5b 25 	call	0x4ab6	; 0x4ab6 <settings_store_startup_line>
    7ac0:	b9 c0       	rjmp	.+370    	; 0x7c34 <system_execute_line+0x482>
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    7ac2:	ae 01       	movw	r20, r28
    7ac4:	4a 5f       	subi	r20, 0xFA	; 250
    7ac6:	5f 4f       	sbci	r21, 0xFF	; 255
    7ac8:	be 01       	movw	r22, r28
    7aca:	6f 5f       	subi	r22, 0xFF	; 255
    7acc:	7f 4f       	sbci	r23, 0xFF	; 255
    7ace:	c8 01       	movw	r24, r16
    7ad0:	0e 94 2f 2e 	call	0x5c5e	; 0x5c5e <read_float>
    7ad4:	88 23       	and	r24, r24
    7ad6:	09 f4       	brne	.+2      	; 0x7ada <system_execute_line+0x328>
    7ad8:	a0 c0       	rjmp	.+320    	; 0x7c1a <system_execute_line+0x468>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    7ada:	89 81       	ldd	r24, Y+1	; 0x01
    7adc:	f8 01       	movw	r30, r16
    7ade:	e8 0f       	add	r30, r24
    7ae0:	f1 1d       	adc	r31, r1
    7ae2:	80 81       	ld	r24, Z
    7ae4:	81 11       	cpse	r24, r1
    7ae6:	9d c0       	rjmp	.+314    	; 0x7c22 <system_execute_line+0x470>
    7ae8:	ca 80       	ldd	r12, Y+2	; 0x02
    7aea:	db 80       	ldd	r13, Y+3	; 0x03
    7aec:	ec 80       	ldd	r14, Y+4	; 0x04
    7aee:	fd 80       	ldd	r15, Y+5	; 0x05
    7af0:	20 e0       	ldi	r18, 0x00	; 0
    7af2:	30 e0       	ldi	r19, 0x00	; 0
    7af4:	4f e7       	ldi	r20, 0x7F	; 127
    7af6:	53 e4       	ldi	r21, 0x43	; 67
    7af8:	c7 01       	movw	r24, r14
    7afa:	b6 01       	movw	r22, r12
    7afc:	24 d4       	rcall	.+2120   	; 0x8346 <__gesf2>
    7afe:	18 16       	cp	r1, r24
    7b00:	0c f4       	brge	.+2      	; 0x7b04 <system_execute_line+0x352>
            return(settings_store_global_setting((uint8_t)parameter, value));
    7b02:	94 c0       	rjmp	.+296    	; 0x7c2c <system_execute_line+0x47a>
    7b04:	8e 80       	ldd	r8, Y+6	; 0x06
    7b06:	9f 80       	ldd	r9, Y+7	; 0x07
    7b08:	a8 84       	ldd	r10, Y+8	; 0x08
    7b0a:	b9 84       	ldd	r11, Y+9	; 0x09
    7b0c:	c7 01       	movw	r24, r14
    7b0e:	b6 01       	movw	r22, r12
    7b10:	8b d2       	rcall	.+1302   	; 0x8028 <__fixunssfsi>
    7b12:	86 2f       	mov	r24, r22
    7b14:	b5 01       	movw	r22, r10
    7b16:	a4 01       	movw	r20, r8
    7b18:	0e 94 4f 26 	call	0x4c9e	; 0x4c9e <settings_store_global_setting>
    7b1c:	f8 2e       	mov	r15, r24
    7b1e:	8a c0       	rjmp	.+276    	; 0x7c34 <system_execute_line+0x482>
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    case 'J' : // Jogging
      // Execute only if in IDLE or JOG states.
      if (sys.state != STATE_IDLE && sys.state != STATE_JOG) { return(STATUS_IDLE_ERROR); }
    7b20:	68 94       	set
    7b22:	ff 24       	eor	r15, r15
    7b24:	f3 f8       	bld	r15, 3
    7b26:	86 c0       	rjmp	.+268    	; 0x7c34 <system_execute_line+0x482>
      if(line[2] != '=') { return(STATUS_INVALID_STATEMENT); }
    7b28:	0f 2e       	mov	r0, r31
    7b2a:	f3 e0       	ldi	r31, 0x03	; 3
    7b2c:	ff 2e       	mov	r15, r31
    7b2e:	f0 2d       	mov	r31, r0
    7b30:	81 c0       	rjmp	.+258    	; 0x7c34 <system_execute_line+0x482>
      return(gc_execute_line(line)); // NOTE: $J= is ignored inside g-code parser and used to detect jog motions.
      break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7b32:	0f 2e       	mov	r0, r31
    7b34:	f3 e0       	ldi	r31, 0x03	; 3
    7b36:	ff 2e       	mov	r15, r31
    7b38:	f0 2d       	mov	r31, r0
    7b3a:	7c c0       	rjmp	.+248    	; 0x7c34 <system_execute_line+0x482>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7b3c:	f1 2c       	mov	r15, r1
    7b3e:	7a c0       	rjmp	.+244    	; 0x7c34 <system_execute_line+0x482>
      break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
      switch( line[1] ) {
        case '$' : // Prints Grbl settings
          if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    7b40:	68 94       	set
    7b42:	ff 24       	eor	r15, r15
    7b44:	f3 f8       	bld	r15, 3
    7b46:	76 c0       	rjmp	.+236    	; 0x7c34 <system_execute_line+0x482>
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) {
            mc_reset();
            report_feedback_message(MESSAGE_DISABLED);
          } else {
            if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    7b48:	68 94       	set
    7b4a:	ff 24       	eor	r15, r15
    7b4c:	f3 f8       	bld	r15, 3
    7b4e:	72 c0       	rjmp	.+228    	; 0x7c34 <system_execute_line+0x482>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7b50:	f1 2c       	mov	r15, r1
    7b52:	70 c0       	rjmp	.+224    	; 0x7c34 <system_execute_line+0x482>
          }
          break;
        case 'X' : // Disable alarm lock [ALARM]
          if (sys.state == STATE_ALARM) {
            // Block if safety door is ajar.
            if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); }
    7b54:	0f 2e       	mov	r0, r31
    7b56:	fd e0       	ldi	r31, 0x0D	; 13
    7b58:	ff 2e       	mov	r15, r31
    7b5a:	f0 2d       	mov	r31, r0
    7b5c:	6b c0       	rjmp	.+214    	; 0x7c34 <system_execute_line+0x482>
          break;
      }
      break;
    default :
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    7b5e:	68 94       	set
    7b60:	ff 24       	eor	r15, r15
    7b62:	f3 f8       	bld	r15, 3
    7b64:	67 c0       	rjmp	.+206    	; 0x7c34 <system_execute_line+0x482>
      switch( line[1] ) {
        case '#' : // Print Grbl NGC parameters
          if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7b66:	0f 2e       	mov	r0, r31
    7b68:	f3 e0       	ldi	r31, 0x03	; 3
    7b6a:	ff 2e       	mov	r15, r31
    7b6c:	f0 2d       	mov	r31, r0
    7b6e:	62 c0       	rjmp	.+196    	; 0x7c34 <system_execute_line+0x482>
          else { report_ngc_parameters(); }
          break;
        case 'H' : // Perform homing cycle [IDLE/ALARM]
          if (bit_isfalse(settings.flags,BITFLAG_HOMING_ENABLE)) {return(STATUS_SETTING_DISABLED); }
    7b70:	0f 2e       	mov	r0, r31
    7b72:	f5 e0       	ldi	r31, 0x05	; 5
    7b74:	ff 2e       	mov	r15, r31
    7b76:	f0 2d       	mov	r31, r0
    7b78:	5d c0       	rjmp	.+186    	; 0x7c34 <system_execute_line+0x482>
          if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); } // Block if safety door is ajar.
    7b7a:	0f 2e       	mov	r0, r31
    7b7c:	fd e0       	ldi	r31, 0x0D	; 13
    7b7e:	ff 2e       	mov	r15, r31
    7b80:	f0 2d       	mov	r31, r0
    7b82:	58 c0       	rjmp	.+176    	; 0x7c34 <system_execute_line+0x482>
                case 'Y': mc_homing_cycle(HOMING_CYCLE_Y); break;
                case 'Z': mc_homing_cycle(HOMING_CYCLE_Z); break;
                default: return(STATUS_INVALID_STATEMENT);
              }
          #endif
          } else { return(STATUS_INVALID_STATEMENT); }
    7b84:	0f 2e       	mov	r0, r31
    7b86:	f3 e0       	ldi	r31, 0x03	; 3
    7b88:	ff 2e       	mov	r15, r31
    7b8a:	f0 2d       	mov	r31, r0
    7b8c:	53 c0       	rjmp	.+166    	; 0x7c34 <system_execute_line+0x482>
            } else if (line[3] == 0) {
              switch (line[2]) {
                case 'X': mc_homing_cycle(HOMING_CYCLE_X); break;
                case 'Y': mc_homing_cycle(HOMING_CYCLE_Y); break;
                case 'Z': mc_homing_cycle(HOMING_CYCLE_Z); break;
                default: return(STATUS_INVALID_STATEMENT);
    7b8e:	0f 2e       	mov	r0, r31
    7b90:	f3 e0       	ldi	r31, 0x03	; 3
    7b92:	ff 2e       	mov	r15, r31
    7b94:	f0 2d       	mov	r31, r0
    7b96:	4e c0       	rjmp	.+156    	; 0x7c34 <system_execute_line+0x482>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7b98:	fe 2c       	mov	r15, r14
    7b9a:	4c c0       	rjmp	.+152    	; 0x7c34 <system_execute_line+0x482>
            st_go_idle(); // Set steppers to the settings idle state before returning.
            if (line[2] == 0) { system_execute_startup(line); }
          }
          break;
        case 'S' : // Puts Grbl to sleep [IDLE/ALARM]
          if ((line[2] != 'L') || (line[3] != 'P') || (line[4] != 0)) { return(STATUS_INVALID_STATEMENT); }
    7b9c:	0f 2e       	mov	r0, r31
    7b9e:	f3 e0       	ldi	r31, 0x03	; 3
    7ba0:	ff 2e       	mov	r15, r31
    7ba2:	f0 2d       	mov	r31, r0
    7ba4:	47 c0       	rjmp	.+142    	; 0x7c34 <system_execute_line+0x482>
    7ba6:	0f 2e       	mov	r0, r31
    7ba8:	f3 e0       	ldi	r31, 0x03	; 3
    7baa:	ff 2e       	mov	r15, r31
    7bac:	f0 2d       	mov	r31, r0
    7bae:	42 c0       	rjmp	.+132    	; 0x7c34 <system_execute_line+0x482>
    7bb0:	0f 2e       	mov	r0, r31
    7bb2:	f3 e0       	ldi	r31, 0x03	; 3
    7bb4:	ff 2e       	mov	r15, r31
    7bb6:	f0 2d       	mov	r31, r0
    7bb8:	3d c0       	rjmp	.+122    	; 0x7c34 <system_execute_line+0x482>
          if ( line[++char_counter] == 0 ) {
            settings_read_build_info(line);
            report_build_info(line);
          #ifdef ENABLE_BUILD_INFO_WRITE_COMMAND
            } else { // Store startup line [IDLE/ALARM]
              if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    7bba:	0f 2e       	mov	r0, r31
    7bbc:	f3 e0       	ldi	r31, 0x03	; 3
    7bbe:	ff 2e       	mov	r15, r31
    7bc0:	f0 2d       	mov	r31, r0
    7bc2:	38 c0       	rjmp	.+112    	; 0x7c34 <system_execute_line+0x482>
              settings_store_build_info(line);
          #endif
          }
          break;
        case 'R' : // Restore defaults [IDLE/ALARM]
          if ((line[2] != 'S') || (line[3] != 'T') || (line[4] != '=') || (line[6] != 0)) { return(STATUS_INVALID_STATEMENT); }
    7bc4:	0f 2e       	mov	r0, r31
    7bc6:	f3 e0       	ldi	r31, 0x03	; 3
    7bc8:	ff 2e       	mov	r15, r31
    7bca:	f0 2d       	mov	r31, r0
    7bcc:	33 c0       	rjmp	.+102    	; 0x7c34 <system_execute_line+0x482>
    7bce:	0f 2e       	mov	r0, r31
    7bd0:	f3 e0       	ldi	r31, 0x03	; 3
    7bd2:	ff 2e       	mov	r15, r31
    7bd4:	f0 2d       	mov	r31, r0
    7bd6:	2e c0       	rjmp	.+92     	; 0x7c34 <system_execute_line+0x482>
    7bd8:	0f 2e       	mov	r0, r31
    7bda:	f3 e0       	ldi	r31, 0x03	; 3
    7bdc:	ff 2e       	mov	r15, r31
    7bde:	f0 2d       	mov	r31, r0
    7be0:	29 c0       	rjmp	.+82     	; 0x7c34 <system_execute_line+0x482>
    7be2:	0f 2e       	mov	r0, r31
    7be4:	f3 e0       	ldi	r31, 0x03	; 3
    7be6:	ff 2e       	mov	r15, r31
    7be8:	f0 2d       	mov	r31, r0
    7bea:	24 c0       	rjmp	.+72     	; 0x7c34 <system_execute_line+0x482>
              case '#': settings_restore(SETTINGS_RESTORE_PARAMETERS); break;
            #endif
            #ifdef ENABLE_RESTORE_EEPROM_WIPE_ALL
              case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
            #endif
            default: return(STATUS_INVALID_STATEMENT);
    7bec:	0f 2e       	mov	r0, r31
    7bee:	f3 e0       	ldi	r31, 0x03	; 3
    7bf0:	ff 2e       	mov	r15, r31
    7bf2:	f0 2d       	mov	r31, r0
    7bf4:	1f c0       	rjmp	.+62     	; 0x7c34 <system_execute_line+0x482>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    7bf6:	68 94       	set
    7bf8:	ff 24       	eor	r15, r15
    7bfa:	f3 f8       	bld	r15, 3
    7bfc:	1b c0       	rjmp	.+54     	; 0x7c34 <system_execute_line+0x482>
            helper_var = true;  // Set helper_var to flag storing method.
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    7bfe:	68 94       	set
    7c00:	ff 24       	eor	r15, r15
    7c02:	f1 f8       	bld	r15, 1
    7c04:	17 c0       	rjmp	.+46     	; 0x7c34 <system_execute_line+0x482>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    7c06:	0f 2e       	mov	r0, r31
    7c08:	f3 e0       	ldi	r31, 0x03	; 3
    7c0a:	ff 2e       	mov	r15, r31
    7c0c:	f0 2d       	mov	r31, r0
    7c0e:	12 c0       	rjmp	.+36     	; 0x7c34 <system_execute_line+0x482>
            // Prepare sending gcode block to gcode parser by shifting all characters
            helper_var = char_counter; // Set helper variable as counter to start of gcode block
            do {
              line[char_counter-helper_var] = line[char_counter];
            } while (line[char_counter++] != 0);
            if (char_counter > EEPROM_LINE_SIZE) { return(STATUS_LINE_LENGTH_EXCEEDED); }
    7c10:	0f 2e       	mov	r0, r31
    7c12:	fe e0       	ldi	r31, 0x0E	; 14
    7c14:	ff 2e       	mov	r15, r31
    7c16:	f0 2d       	mov	r31, r0
    7c18:	0d c0       	rjmp	.+26     	; 0x7c34 <system_execute_line+0x482>
            else {
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
              settings_store_startup_line(helper_var,line);
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    7c1a:	68 94       	set
    7c1c:	ff 24       	eor	r15, r15
    7c1e:	f1 f8       	bld	r15, 1
    7c20:	09 c0       	rjmp	.+18     	; 0x7c34 <system_execute_line+0x482>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    7c22:	0f 2e       	mov	r0, r31
    7c24:	f3 e0       	ldi	r31, 0x03	; 3
    7c26:	ff 2e       	mov	r15, r31
    7c28:	f0 2d       	mov	r31, r0
    7c2a:	04 c0       	rjmp	.+8      	; 0x7c34 <system_execute_line+0x482>
    7c2c:	0f 2e       	mov	r0, r31
    7c2e:	f3 e0       	ldi	r31, 0x03	; 3
    7c30:	ff 2e       	mov	r15, r31
    7c32:	f0 2d       	mov	r31, r0
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
}
    7c34:	8f 2d       	mov	r24, r15
    7c36:	29 96       	adiw	r28, 0x09	; 9
    7c38:	0f b6       	in	r0, 0x3f	; 63
    7c3a:	f8 94       	cli
    7c3c:	de bf       	out	0x3e, r29	; 62
    7c3e:	0f be       	out	0x3f, r0	; 63
    7c40:	cd bf       	out	0x3d, r28	; 61
    7c42:	df 91       	pop	r29
    7c44:	cf 91       	pop	r28
    7c46:	1f 91       	pop	r17
    7c48:	0f 91       	pop	r16
    7c4a:	ff 90       	pop	r15
    7c4c:	ef 90       	pop	r14
    7c4e:	df 90       	pop	r13
    7c50:	cf 90       	pop	r12
    7c52:	bf 90       	pop	r11
    7c54:	af 90       	pop	r10
    7c56:	9f 90       	pop	r9
    7c58:	8f 90       	pop	r8
    7c5a:	08 95       	ret

00007c5c <system_clear_exec_state_flag>:
  sys_rt_exec_state |= (mask);
  SREG = sreg;
}

void system_clear_exec_state_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    7c5c:	2f b7       	in	r18, 0x3f	; 63
  cli();
    7c5e:	f8 94       	cli
  sys_rt_exec_state &= ~(mask);
    7c60:	90 91 31 0c 	lds	r25, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    7c64:	80 95       	com	r24
    7c66:	89 23       	and	r24, r25
    7c68:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <sys_rt_exec_state>
  SREG = sreg;
    7c6c:	2f bf       	out	0x3f, r18	; 63
    7c6e:	08 95       	ret

00007c70 <system_set_exec_alarm>:
}

void system_set_exec_alarm(uint8_t code) {
  uint8_t sreg = SREG;
    7c70:	9f b7       	in	r25, 0x3f	; 63
  cli();
    7c72:	f8 94       	cli
  sys_rt_exec_alarm = code;
    7c74:	80 93 53 0c 	sts	0x0C53, r24	; 0x800c53 <sys_rt_exec_alarm>
  SREG = sreg;
    7c78:	9f bf       	out	0x3f, r25	; 63
    7c7a:	08 95       	ret

00007c7c <system_clear_exec_alarm>:
}

void system_clear_exec_alarm() {
  uint8_t sreg = SREG;
    7c7c:	8f b7       	in	r24, 0x3f	; 63
  cli();
    7c7e:	f8 94       	cli
  sys_rt_exec_alarm = 0;
    7c80:	10 92 53 0c 	sts	0x0C53, r1	; 0x800c53 <sys_rt_exec_alarm>
  SREG = sreg;
    7c84:	8f bf       	out	0x3f, r24	; 63
    7c86:	08 95       	ret

00007c88 <system_set_exec_motion_override_flag>:
}

void system_set_exec_motion_override_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    7c88:	9f b7       	in	r25, 0x3f	; 63
  cli();
    7c8a:	f8 94       	cli
  sys_rt_exec_motion_override |= (mask);
    7c8c:	20 91 19 0c 	lds	r18, 0x0C19	; 0x800c19 <sys_rt_exec_motion_override>
    7c90:	82 2b       	or	r24, r18
    7c92:	80 93 19 0c 	sts	0x0C19, r24	; 0x800c19 <sys_rt_exec_motion_override>
  SREG = sreg;
    7c96:	9f bf       	out	0x3f, r25	; 63
    7c98:	08 95       	ret

00007c9a <system_set_exec_accessory_override_flag>:
}

void system_set_exec_accessory_override_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    7c9a:	9f b7       	in	r25, 0x3f	; 63
  cli();
    7c9c:	f8 94       	cli
  sys_rt_exec_accessory_override |= (mask);
    7c9e:	20 91 30 0c 	lds	r18, 0x0C30	; 0x800c30 <sys_rt_exec_accessory_override>
    7ca2:	82 2b       	or	r24, r18
    7ca4:	80 93 30 0c 	sts	0x0C30, r24	; 0x800c30 <sys_rt_exec_accessory_override>
  SREG = sreg;
    7ca8:	9f bf       	out	0x3f, r25	; 63
    7caa:	08 95       	ret

00007cac <system_clear_exec_motion_overrides>:
}

void system_clear_exec_motion_overrides() {
  uint8_t sreg = SREG;
    7cac:	8f b7       	in	r24, 0x3f	; 63
  cli();
    7cae:	f8 94       	cli
  sys_rt_exec_motion_override = 0;
    7cb0:	10 92 19 0c 	sts	0x0C19, r1	; 0x800c19 <sys_rt_exec_motion_override>
  SREG = sreg;
    7cb4:	8f bf       	out	0x3f, r24	; 63
    7cb6:	08 95       	ret

00007cb8 <system_clear_exec_accessory_overrides>:
}

void system_clear_exec_accessory_overrides() {
  uint8_t sreg = SREG;
    7cb8:	8f b7       	in	r24, 0x3f	; 63
  cli();
    7cba:	f8 94       	cli
  sys_rt_exec_accessory_override = 0;
    7cbc:	10 92 30 0c 	sts	0x0C30, r1	; 0x800c30 <sys_rt_exec_accessory_override>
  SREG = sreg;
    7cc0:	8f bf       	out	0x3f, r24	; 63
    7cc2:	08 95       	ret

00007cc4 <sleep_init>:
// Initialization routine for sleep timer.
void sleep_init()
{
  // Configure Timer 3: Sleep Counter Overflow Interrupt
  // NOTE: By using an overflow interrupt, the timer is automatically reloaded upon overflow.
  TCCR3B = 0; // Normal operation. Overflow.
    7cc4:	e1 e9       	ldi	r30, 0x91	; 145
    7cc6:	f0 e0       	ldi	r31, 0x00	; 0
    7cc8:	10 82       	st	Z, r1
  TCCR3A = 0;
    7cca:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
  TCCR3B = (TCCR3B & ~((1<<CS32) | (1<<CS31))) | (1<<CS30); // Stop timer
    7cce:	80 81       	ld	r24, Z
    7cd0:	88 7f       	andi	r24, 0xF8	; 248
    7cd2:	81 60       	ori	r24, 0x01	; 1
    7cd4:	80 83       	st	Z, r24
  // TCCR3B |= (1<<CS32); // Enable timer with 1/256 prescaler. ~4.4min max with uint8 and 1.05sec/tick
  // TCCR3B |= (1<<CS31); // Enable timer with 1/8 prescaler. ~8.3sec max with uint8 and 32.7msec/tick
  TCCR3B |= (1<<CS31)|(1<<CS30); // Enable timer with 1/64 prescaler. ~66.8sec max with uint8 and 0.262sec/tick
    7cd6:	80 81       	ld	r24, Z
    7cd8:	83 60       	ori	r24, 0x03	; 3
    7cda:	80 83       	st	Z, r24
  TIMSK3 |= (1<<TOIE3); // Enable timer3 overflow interrupt
} 


// Disable sleep timer.
static void sleep_disable() {  TIMSK3 &= ~(1<<TOIE3); } // Disable timer overflow interrupt
    7cdc:	e1 e7       	ldi	r30, 0x71	; 113
    7cde:	f0 e0       	ldi	r31, 0x00	; 0
    7ce0:	80 81       	ld	r24, Z
    7ce2:	8e 7f       	andi	r24, 0xFE	; 254
    7ce4:	80 83       	st	Z, r24
    7ce6:	08 95       	ret

00007ce8 <__vector_35>:
  sleep_disable();
}


// Increment sleep counter with each timer overflow.
ISR(TIMER3_OVF_vect) { sleep_counter++; }
    7ce8:	1f 92       	push	r1
    7cea:	0f 92       	push	r0
    7cec:	0f b6       	in	r0, 0x3f	; 63
    7cee:	0f 92       	push	r0
    7cf0:	11 24       	eor	r1, r1
    7cf2:	8f 93       	push	r24
    7cf4:	80 91 26 0f 	lds	r24, 0x0F26	; 0x800f26 <sleep_counter>
    7cf8:	8f 5f       	subi	r24, 0xFF	; 255
    7cfa:	80 93 26 0f 	sts	0x0F26, r24	; 0x800f26 <sleep_counter>
    7cfe:	8f 91       	pop	r24
    7d00:	0f 90       	pop	r0
    7d02:	0f be       	out	0x3f, r0	; 63
    7d04:	0f 90       	pop	r0
    7d06:	1f 90       	pop	r1
    7d08:	18 95       	reti

00007d0a <jog_execute>:
#include "grbl.h"


// Sets up valid jog motion received from g-code parser, checks for soft-limits, and executes the jog.
uint8_t jog_execute(plan_line_data_t *pl_data, parser_block_t *gc_block)
{
    7d0a:	0f 93       	push	r16
    7d0c:	1f 93       	push	r17
    7d0e:	cf 93       	push	r28
    7d10:	df 93       	push	r29
    7d12:	ec 01       	movw	r28, r24
    7d14:	8b 01       	movw	r16, r22
  // Initialize planner data struct for jogging motions.
  // NOTE: Spindle and coolant are allowed to fully function with overrides during a jog.
  pl_data->feed_rate = gc_block->values.f;
    7d16:	fb 01       	movw	r30, r22
    7d18:	84 85       	ldd	r24, Z+12	; 0x0c
    7d1a:	95 85       	ldd	r25, Z+13	; 0x0d
    7d1c:	a6 85       	ldd	r26, Z+14	; 0x0e
    7d1e:	b7 85       	ldd	r27, Z+15	; 0x0f
    7d20:	88 83       	st	Y, r24
    7d22:	99 83       	std	Y+1, r25	; 0x01
    7d24:	aa 83       	std	Y+2, r26	; 0x02
    7d26:	bb 83       	std	Y+3, r27	; 0x03
  pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
    7d28:	8c 85       	ldd	r24, Y+12	; 0x0c
    7d2a:	84 60       	ori	r24, 0x04	; 4
    7d2c:	8c 87       	std	Y+12, r24	; 0x0c
  pl_data->line_number = gc_block->values.n;
    7d2e:	85 8d       	ldd	r24, Z+29	; 0x1d
    7d30:	96 8d       	ldd	r25, Z+30	; 0x1e
    7d32:	a7 8d       	ldd	r26, Z+31	; 0x1f
    7d34:	b0 a1       	ldd	r27, Z+32	; 0x20
    7d36:	88 87       	std	Y+8, r24	; 0x08
    7d38:	99 87       	std	Y+9, r25	; 0x09
    7d3a:	aa 87       	std	Y+10, r26	; 0x0a
    7d3c:	bb 87       	std	Y+11, r27	; 0x0b

  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
    7d3e:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    7d42:	85 ff       	sbrs	r24, 5
    7d44:	05 c0       	rjmp	.+10     	; 0x7d50 <jog_execute+0x46>
    if (system_check_travel_limits(gc_block->values.xyz)) { return(STATUS_TRAVEL_EXCEEDED); }
    7d46:	cb 01       	movw	r24, r22
    7d48:	8e 96       	adiw	r24, 0x2e	; 46
    7d4a:	c5 dc       	rcall	.-1654   	; 0x76d6 <system_check_travel_limits>
    7d4c:	81 11       	cpse	r24, r1
    7d4e:	15 c0       	rjmp	.+42     	; 0x7d7a <jog_execute+0x70>
  }

  // Valid jog command. Plan, set state, and execute.
  mc_line(gc_block->values.xyz,pl_data);
    7d50:	be 01       	movw	r22, r28
    7d52:	c8 01       	movw	r24, r16
    7d54:	8e 96       	adiw	r24, 0x2e	; 46
    7d56:	0e 94 67 03 	call	0x6ce	; 0x6ce <mc_line>
  if (sys.state == STATE_IDLE) {
    7d5a:	c0 91 1e 0c 	lds	r28, 0x0C1E	; 0x800c1e <sys>
    7d5e:	c1 11       	cpse	r28, r1
    7d60:	0e c0       	rjmp	.+28     	; 0x7d7e <jog_execute+0x74>
    if (plan_get_current_block() != NULL) { // Check if there is a block to execute.
    7d62:	0e 94 87 29 	call	0x530e	; 0x530e <plan_get_current_block>
    7d66:	89 2b       	or	r24, r25
    7d68:	59 f0       	breq	.+22     	; 0x7d80 <jog_execute+0x76>
      sys.state = STATE_JOG;
    7d6a:	80 e2       	ldi	r24, 0x20	; 32
    7d6c:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
      st_prep_buffer();
    7d70:	0e 94 4e 1c 	call	0x389c	; 0x389c <st_prep_buffer>
      st_wake_up();  // NOTE: Manual start. No state machine required.
    7d74:	0e 94 41 19 	call	0x3282	; 0x3282 <st_wake_up>
    7d78:	03 c0       	rjmp	.+6      	; 0x7d80 <jog_execute+0x76>
  pl_data->feed_rate = gc_block->values.f;
  pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
  pl_data->line_number = gc_block->values.n;

  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
    if (system_check_travel_limits(gc_block->values.xyz)) { return(STATUS_TRAVEL_EXCEEDED); }
    7d7a:	cf e0       	ldi	r28, 0x0F	; 15
    7d7c:	01 c0       	rjmp	.+2      	; 0x7d80 <jog_execute+0x76>
      st_prep_buffer();
      st_wake_up();  // NOTE: Manual start. No state machine required.
    }
  }

  return(STATUS_OK);
    7d7e:	c0 e0       	ldi	r28, 0x00	; 0
}
    7d80:	8c 2f       	mov	r24, r28
    7d82:	df 91       	pop	r29
    7d84:	cf 91       	pop	r28
    7d86:	1f 91       	pop	r17
    7d88:	0f 91       	pop	r16
    7d8a:	08 95       	ret

00007d8c <__subsf3>:
    7d8c:	50 58       	subi	r21, 0x80	; 128

00007d8e <__addsf3>:
    7d8e:	bb 27       	eor	r27, r27
    7d90:	aa 27       	eor	r26, r26
    7d92:	0e d0       	rcall	.+28     	; 0x7db0 <__addsf3x>
    7d94:	76 c2       	rjmp	.+1260   	; 0x8282 <__fp_round>
    7d96:	3f d2       	rcall	.+1150   	; 0x8216 <__fp_pscA>
    7d98:	30 f0       	brcs	.+12     	; 0x7da6 <__addsf3+0x18>
    7d9a:	44 d2       	rcall	.+1160   	; 0x8224 <__fp_pscB>
    7d9c:	20 f0       	brcs	.+8      	; 0x7da6 <__addsf3+0x18>
    7d9e:	31 f4       	brne	.+12     	; 0x7dac <__addsf3+0x1e>
    7da0:	9f 3f       	cpi	r25, 0xFF	; 255
    7da2:	11 f4       	brne	.+4      	; 0x7da8 <__addsf3+0x1a>
    7da4:	1e f4       	brtc	.+6      	; 0x7dac <__addsf3+0x1e>
    7da6:	0f c2       	rjmp	.+1054   	; 0x81c6 <__fp_nan>
    7da8:	0e f4       	brtc	.+2      	; 0x7dac <__addsf3+0x1e>
    7daa:	e0 95       	com	r30
    7dac:	e7 fb       	bst	r30, 7
    7dae:	dc c1       	rjmp	.+952    	; 0x8168 <__fp_inf>

00007db0 <__addsf3x>:
    7db0:	e9 2f       	mov	r30, r25
    7db2:	89 d2       	rcall	.+1298   	; 0x82c6 <__fp_split3>
    7db4:	80 f3       	brcs	.-32     	; 0x7d96 <__addsf3+0x8>
    7db6:	ba 17       	cp	r27, r26
    7db8:	62 07       	cpc	r22, r18
    7dba:	73 07       	cpc	r23, r19
    7dbc:	84 07       	cpc	r24, r20
    7dbe:	95 07       	cpc	r25, r21
    7dc0:	18 f0       	brcs	.+6      	; 0x7dc8 <__addsf3x+0x18>
    7dc2:	71 f4       	brne	.+28     	; 0x7de0 <__addsf3x+0x30>
    7dc4:	9e f5       	brtc	.+102    	; 0x7e2c <__addsf3x+0x7c>
    7dc6:	b8 c2       	rjmp	.+1392   	; 0x8338 <__fp_zero>
    7dc8:	0e f4       	brtc	.+2      	; 0x7dcc <__addsf3x+0x1c>
    7dca:	e0 95       	com	r30
    7dcc:	0b 2e       	mov	r0, r27
    7dce:	ba 2f       	mov	r27, r26
    7dd0:	a0 2d       	mov	r26, r0
    7dd2:	0b 01       	movw	r0, r22
    7dd4:	b9 01       	movw	r22, r18
    7dd6:	90 01       	movw	r18, r0
    7dd8:	0c 01       	movw	r0, r24
    7dda:	ca 01       	movw	r24, r20
    7ddc:	a0 01       	movw	r20, r0
    7dde:	11 24       	eor	r1, r1
    7de0:	ff 27       	eor	r31, r31
    7de2:	59 1b       	sub	r21, r25
    7de4:	99 f0       	breq	.+38     	; 0x7e0c <__addsf3x+0x5c>
    7de6:	59 3f       	cpi	r21, 0xF9	; 249
    7de8:	50 f4       	brcc	.+20     	; 0x7dfe <__addsf3x+0x4e>
    7dea:	50 3e       	cpi	r21, 0xE0	; 224
    7dec:	68 f1       	brcs	.+90     	; 0x7e48 <__addsf3x+0x98>
    7dee:	1a 16       	cp	r1, r26
    7df0:	f0 40       	sbci	r31, 0x00	; 0
    7df2:	a2 2f       	mov	r26, r18
    7df4:	23 2f       	mov	r18, r19
    7df6:	34 2f       	mov	r19, r20
    7df8:	44 27       	eor	r20, r20
    7dfa:	58 5f       	subi	r21, 0xF8	; 248
    7dfc:	f3 cf       	rjmp	.-26     	; 0x7de4 <__addsf3x+0x34>
    7dfe:	46 95       	lsr	r20
    7e00:	37 95       	ror	r19
    7e02:	27 95       	ror	r18
    7e04:	a7 95       	ror	r26
    7e06:	f0 40       	sbci	r31, 0x00	; 0
    7e08:	53 95       	inc	r21
    7e0a:	c9 f7       	brne	.-14     	; 0x7dfe <__addsf3x+0x4e>
    7e0c:	7e f4       	brtc	.+30     	; 0x7e2c <__addsf3x+0x7c>
    7e0e:	1f 16       	cp	r1, r31
    7e10:	ba 0b       	sbc	r27, r26
    7e12:	62 0b       	sbc	r22, r18
    7e14:	73 0b       	sbc	r23, r19
    7e16:	84 0b       	sbc	r24, r20
    7e18:	ba f0       	brmi	.+46     	; 0x7e48 <__addsf3x+0x98>
    7e1a:	91 50       	subi	r25, 0x01	; 1
    7e1c:	a1 f0       	breq	.+40     	; 0x7e46 <__addsf3x+0x96>
    7e1e:	ff 0f       	add	r31, r31
    7e20:	bb 1f       	adc	r27, r27
    7e22:	66 1f       	adc	r22, r22
    7e24:	77 1f       	adc	r23, r23
    7e26:	88 1f       	adc	r24, r24
    7e28:	c2 f7       	brpl	.-16     	; 0x7e1a <__addsf3x+0x6a>
    7e2a:	0e c0       	rjmp	.+28     	; 0x7e48 <__addsf3x+0x98>
    7e2c:	ba 0f       	add	r27, r26
    7e2e:	62 1f       	adc	r22, r18
    7e30:	73 1f       	adc	r23, r19
    7e32:	84 1f       	adc	r24, r20
    7e34:	48 f4       	brcc	.+18     	; 0x7e48 <__addsf3x+0x98>
    7e36:	87 95       	ror	r24
    7e38:	77 95       	ror	r23
    7e3a:	67 95       	ror	r22
    7e3c:	b7 95       	ror	r27
    7e3e:	f7 95       	ror	r31
    7e40:	9e 3f       	cpi	r25, 0xFE	; 254
    7e42:	08 f0       	brcs	.+2      	; 0x7e46 <__addsf3x+0x96>
    7e44:	b3 cf       	rjmp	.-154    	; 0x7dac <__addsf3+0x1e>
    7e46:	93 95       	inc	r25
    7e48:	88 0f       	add	r24, r24
    7e4a:	08 f0       	brcs	.+2      	; 0x7e4e <__addsf3x+0x9e>
    7e4c:	99 27       	eor	r25, r25
    7e4e:	ee 0f       	add	r30, r30
    7e50:	97 95       	ror	r25
    7e52:	87 95       	ror	r24
    7e54:	08 95       	ret
    7e56:	df d1       	rcall	.+958    	; 0x8216 <__fp_pscA>
    7e58:	58 f0       	brcs	.+22     	; 0x7e70 <__addsf3x+0xc0>
    7e5a:	80 e8       	ldi	r24, 0x80	; 128
    7e5c:	91 e0       	ldi	r25, 0x01	; 1
    7e5e:	09 f4       	brne	.+2      	; 0x7e62 <__addsf3x+0xb2>
    7e60:	9e ef       	ldi	r25, 0xFE	; 254
    7e62:	e0 d1       	rcall	.+960    	; 0x8224 <__fp_pscB>
    7e64:	28 f0       	brcs	.+10     	; 0x7e70 <__addsf3x+0xc0>
    7e66:	40 e8       	ldi	r20, 0x80	; 128
    7e68:	51 e0       	ldi	r21, 0x01	; 1
    7e6a:	59 f4       	brne	.+22     	; 0x7e82 <atan2+0xe>
    7e6c:	5e ef       	ldi	r21, 0xFE	; 254
    7e6e:	09 c0       	rjmp	.+18     	; 0x7e82 <atan2+0xe>
    7e70:	aa c1       	rjmp	.+852    	; 0x81c6 <__fp_nan>
    7e72:	62 c2       	rjmp	.+1220   	; 0x8338 <__fp_zero>

00007e74 <atan2>:
    7e74:	e9 2f       	mov	r30, r25
    7e76:	e0 78       	andi	r30, 0x80	; 128
    7e78:	26 d2       	rcall	.+1100   	; 0x82c6 <__fp_split3>
    7e7a:	68 f3       	brcs	.-38     	; 0x7e56 <__addsf3x+0xa6>
    7e7c:	09 2e       	mov	r0, r25
    7e7e:	05 2a       	or	r0, r21
    7e80:	c1 f3       	breq	.-16     	; 0x7e72 <__addsf3x+0xc2>
    7e82:	26 17       	cp	r18, r22
    7e84:	37 07       	cpc	r19, r23
    7e86:	48 07       	cpc	r20, r24
    7e88:	59 07       	cpc	r21, r25
    7e8a:	38 f0       	brcs	.+14     	; 0x7e9a <atan2+0x26>
    7e8c:	0e 2e       	mov	r0, r30
    7e8e:	07 f8       	bld	r0, 7
    7e90:	e0 25       	eor	r30, r0
    7e92:	69 f0       	breq	.+26     	; 0x7eae <atan2+0x3a>
    7e94:	e0 25       	eor	r30, r0
    7e96:	e0 64       	ori	r30, 0x40	; 64
    7e98:	0a c0       	rjmp	.+20     	; 0x7eae <atan2+0x3a>
    7e9a:	ef 63       	ori	r30, 0x3F	; 63
    7e9c:	07 f8       	bld	r0, 7
    7e9e:	00 94       	com	r0
    7ea0:	07 fa       	bst	r0, 7
    7ea2:	db 01       	movw	r26, r22
    7ea4:	b9 01       	movw	r22, r18
    7ea6:	9d 01       	movw	r18, r26
    7ea8:	dc 01       	movw	r26, r24
    7eaa:	ca 01       	movw	r24, r20
    7eac:	ad 01       	movw	r20, r26
    7eae:	ef 93       	push	r30
    7eb0:	5d d0       	rcall	.+186    	; 0x7f6c <__divsf3_pse>
    7eb2:	e7 d1       	rcall	.+974    	; 0x8282 <__fp_round>
    7eb4:	0a d0       	rcall	.+20     	; 0x7eca <atan>
    7eb6:	5f 91       	pop	r21
    7eb8:	55 23       	and	r21, r21
    7eba:	31 f0       	breq	.+12     	; 0x7ec8 <atan2+0x54>
    7ebc:	2b ed       	ldi	r18, 0xDB	; 219
    7ebe:	3f e0       	ldi	r19, 0x0F	; 15
    7ec0:	49 e4       	ldi	r20, 0x49	; 73
    7ec2:	50 fd       	sbrc	r21, 0
    7ec4:	49 ec       	ldi	r20, 0xC9	; 201
    7ec6:	63 cf       	rjmp	.-314    	; 0x7d8e <__addsf3>
    7ec8:	08 95       	ret

00007eca <atan>:
    7eca:	df 93       	push	r29
    7ecc:	dd 27       	eor	r29, r29
    7ece:	b9 2f       	mov	r27, r25
    7ed0:	bf 77       	andi	r27, 0x7F	; 127
    7ed2:	40 e8       	ldi	r20, 0x80	; 128
    7ed4:	5f e3       	ldi	r21, 0x3F	; 63
    7ed6:	16 16       	cp	r1, r22
    7ed8:	17 06       	cpc	r1, r23
    7eda:	48 07       	cpc	r20, r24
    7edc:	5b 07       	cpc	r21, r27
    7ede:	10 f4       	brcc	.+4      	; 0x7ee4 <atan+0x1a>
    7ee0:	d9 2f       	mov	r29, r25
    7ee2:	35 d2       	rcall	.+1130   	; 0x834e <inverse>
    7ee4:	9f 93       	push	r25
    7ee6:	8f 93       	push	r24
    7ee8:	7f 93       	push	r23
    7eea:	6f 93       	push	r22
    7eec:	32 d3       	rcall	.+1636   	; 0x8552 <square>
    7eee:	ee e9       	ldi	r30, 0x9E	; 158
    7ef0:	f2 e0       	ldi	r31, 0x02	; 2
    7ef2:	6c d1       	rcall	.+728    	; 0x81cc <__fp_powser>
    7ef4:	c6 d1       	rcall	.+908    	; 0x8282 <__fp_round>
    7ef6:	2f 91       	pop	r18
    7ef8:	3f 91       	pop	r19
    7efa:	4f 91       	pop	r20
    7efc:	5f 91       	pop	r21
    7efe:	6a d2       	rcall	.+1236   	; 0x83d4 <__mulsf3x>
    7f00:	dd 23       	and	r29, r29
    7f02:	49 f0       	breq	.+18     	; 0x7f16 <atan+0x4c>
    7f04:	90 58       	subi	r25, 0x80	; 128
    7f06:	a2 ea       	ldi	r26, 0xA2	; 162
    7f08:	2a ed       	ldi	r18, 0xDA	; 218
    7f0a:	3f e0       	ldi	r19, 0x0F	; 15
    7f0c:	49 ec       	ldi	r20, 0xC9	; 201
    7f0e:	5f e3       	ldi	r21, 0x3F	; 63
    7f10:	d0 78       	andi	r29, 0x80	; 128
    7f12:	5d 27       	eor	r21, r29
    7f14:	4d df       	rcall	.-358    	; 0x7db0 <__addsf3x>
    7f16:	df 91       	pop	r29
    7f18:	b4 c1       	rjmp	.+872    	; 0x8282 <__fp_round>

00007f1a <ceil>:
    7f1a:	f7 d1       	rcall	.+1006   	; 0x830a <__fp_trunc>
    7f1c:	80 f0       	brcs	.+32     	; 0x7f3e <ceil+0x24>
    7f1e:	9f 37       	cpi	r25, 0x7F	; 127
    7f20:	40 f4       	brcc	.+16     	; 0x7f32 <ceil+0x18>
    7f22:	91 11       	cpse	r25, r1
    7f24:	0e f4       	brtc	.+2      	; 0x7f28 <ceil+0xe>
    7f26:	09 c2       	rjmp	.+1042   	; 0x833a <__fp_szero>
    7f28:	60 e0       	ldi	r22, 0x00	; 0
    7f2a:	70 e0       	ldi	r23, 0x00	; 0
    7f2c:	80 e8       	ldi	r24, 0x80	; 128
    7f2e:	9f e3       	ldi	r25, 0x3F	; 63
    7f30:	08 95       	ret
    7f32:	26 f0       	brts	.+8      	; 0x7f3c <ceil+0x22>
    7f34:	1b 16       	cp	r1, r27
    7f36:	61 1d       	adc	r22, r1
    7f38:	71 1d       	adc	r23, r1
    7f3a:	81 1d       	adc	r24, r1
    7f3c:	1b c1       	rjmp	.+566    	; 0x8174 <__fp_mintl>
    7f3e:	35 c1       	rjmp	.+618    	; 0x81aa <__fp_mpack>

00007f40 <__cmpsf2>:
    7f40:	ef d0       	rcall	.+478    	; 0x8120 <__fp_cmp>
    7f42:	08 f4       	brcc	.+2      	; 0x7f46 <__cmpsf2+0x6>
    7f44:	81 e0       	ldi	r24, 0x01	; 1
    7f46:	08 95       	ret

00007f48 <cos>:
    7f48:	75 d1       	rcall	.+746    	; 0x8234 <__fp_rempio2>
    7f4a:	e3 95       	inc	r30
    7f4c:	ab c1       	rjmp	.+854    	; 0x82a4 <__fp_sinus>

00007f4e <__divsf3>:
    7f4e:	0c d0       	rcall	.+24     	; 0x7f68 <__divsf3x>
    7f50:	98 c1       	rjmp	.+816    	; 0x8282 <__fp_round>
    7f52:	68 d1       	rcall	.+720    	; 0x8224 <__fp_pscB>
    7f54:	40 f0       	brcs	.+16     	; 0x7f66 <__divsf3+0x18>
    7f56:	5f d1       	rcall	.+702    	; 0x8216 <__fp_pscA>
    7f58:	30 f0       	brcs	.+12     	; 0x7f66 <__divsf3+0x18>
    7f5a:	21 f4       	brne	.+8      	; 0x7f64 <__divsf3+0x16>
    7f5c:	5f 3f       	cpi	r21, 0xFF	; 255
    7f5e:	19 f0       	breq	.+6      	; 0x7f66 <__divsf3+0x18>
    7f60:	03 c1       	rjmp	.+518    	; 0x8168 <__fp_inf>
    7f62:	51 11       	cpse	r21, r1
    7f64:	ea c1       	rjmp	.+980    	; 0x833a <__fp_szero>
    7f66:	2f c1       	rjmp	.+606    	; 0x81c6 <__fp_nan>

00007f68 <__divsf3x>:
    7f68:	ae d1       	rcall	.+860    	; 0x82c6 <__fp_split3>
    7f6a:	98 f3       	brcs	.-26     	; 0x7f52 <__divsf3+0x4>

00007f6c <__divsf3_pse>:
    7f6c:	99 23       	and	r25, r25
    7f6e:	c9 f3       	breq	.-14     	; 0x7f62 <__divsf3+0x14>
    7f70:	55 23       	and	r21, r21
    7f72:	b1 f3       	breq	.-20     	; 0x7f60 <__divsf3+0x12>
    7f74:	95 1b       	sub	r25, r21
    7f76:	55 0b       	sbc	r21, r21
    7f78:	bb 27       	eor	r27, r27
    7f7a:	aa 27       	eor	r26, r26
    7f7c:	62 17       	cp	r22, r18
    7f7e:	73 07       	cpc	r23, r19
    7f80:	84 07       	cpc	r24, r20
    7f82:	38 f0       	brcs	.+14     	; 0x7f92 <__divsf3_pse+0x26>
    7f84:	9f 5f       	subi	r25, 0xFF	; 255
    7f86:	5f 4f       	sbci	r21, 0xFF	; 255
    7f88:	22 0f       	add	r18, r18
    7f8a:	33 1f       	adc	r19, r19
    7f8c:	44 1f       	adc	r20, r20
    7f8e:	aa 1f       	adc	r26, r26
    7f90:	a9 f3       	breq	.-22     	; 0x7f7c <__divsf3_pse+0x10>
    7f92:	33 d0       	rcall	.+102    	; 0x7ffa <__divsf3_pse+0x8e>
    7f94:	0e 2e       	mov	r0, r30
    7f96:	3a f0       	brmi	.+14     	; 0x7fa6 <__divsf3_pse+0x3a>
    7f98:	e0 e8       	ldi	r30, 0x80	; 128
    7f9a:	30 d0       	rcall	.+96     	; 0x7ffc <__divsf3_pse+0x90>
    7f9c:	91 50       	subi	r25, 0x01	; 1
    7f9e:	50 40       	sbci	r21, 0x00	; 0
    7fa0:	e6 95       	lsr	r30
    7fa2:	00 1c       	adc	r0, r0
    7fa4:	ca f7       	brpl	.-14     	; 0x7f98 <__divsf3_pse+0x2c>
    7fa6:	29 d0       	rcall	.+82     	; 0x7ffa <__divsf3_pse+0x8e>
    7fa8:	fe 2f       	mov	r31, r30
    7faa:	27 d0       	rcall	.+78     	; 0x7ffa <__divsf3_pse+0x8e>
    7fac:	66 0f       	add	r22, r22
    7fae:	77 1f       	adc	r23, r23
    7fb0:	88 1f       	adc	r24, r24
    7fb2:	bb 1f       	adc	r27, r27
    7fb4:	26 17       	cp	r18, r22
    7fb6:	37 07       	cpc	r19, r23
    7fb8:	48 07       	cpc	r20, r24
    7fba:	ab 07       	cpc	r26, r27
    7fbc:	b0 e8       	ldi	r27, 0x80	; 128
    7fbe:	09 f0       	breq	.+2      	; 0x7fc2 <__divsf3_pse+0x56>
    7fc0:	bb 0b       	sbc	r27, r27
    7fc2:	80 2d       	mov	r24, r0
    7fc4:	bf 01       	movw	r22, r30
    7fc6:	ff 27       	eor	r31, r31
    7fc8:	93 58       	subi	r25, 0x83	; 131
    7fca:	5f 4f       	sbci	r21, 0xFF	; 255
    7fcc:	2a f0       	brmi	.+10     	; 0x7fd8 <__divsf3_pse+0x6c>
    7fce:	9e 3f       	cpi	r25, 0xFE	; 254
    7fd0:	51 05       	cpc	r21, r1
    7fd2:	68 f0       	brcs	.+26     	; 0x7fee <__divsf3_pse+0x82>
    7fd4:	c9 c0       	rjmp	.+402    	; 0x8168 <__fp_inf>
    7fd6:	b1 c1       	rjmp	.+866    	; 0x833a <__fp_szero>
    7fd8:	5f 3f       	cpi	r21, 0xFF	; 255
    7fda:	ec f3       	brlt	.-6      	; 0x7fd6 <__divsf3_pse+0x6a>
    7fdc:	98 3e       	cpi	r25, 0xE8	; 232
    7fde:	dc f3       	brlt	.-10     	; 0x7fd6 <__divsf3_pse+0x6a>
    7fe0:	86 95       	lsr	r24
    7fe2:	77 95       	ror	r23
    7fe4:	67 95       	ror	r22
    7fe6:	b7 95       	ror	r27
    7fe8:	f7 95       	ror	r31
    7fea:	9f 5f       	subi	r25, 0xFF	; 255
    7fec:	c9 f7       	brne	.-14     	; 0x7fe0 <__divsf3_pse+0x74>
    7fee:	88 0f       	add	r24, r24
    7ff0:	91 1d       	adc	r25, r1
    7ff2:	96 95       	lsr	r25
    7ff4:	87 95       	ror	r24
    7ff6:	97 f9       	bld	r25, 7
    7ff8:	08 95       	ret
    7ffa:	e1 e0       	ldi	r30, 0x01	; 1
    7ffc:	66 0f       	add	r22, r22
    7ffe:	77 1f       	adc	r23, r23
    8000:	88 1f       	adc	r24, r24
    8002:	bb 1f       	adc	r27, r27
    8004:	62 17       	cp	r22, r18
    8006:	73 07       	cpc	r23, r19
    8008:	84 07       	cpc	r24, r20
    800a:	ba 07       	cpc	r27, r26
    800c:	20 f0       	brcs	.+8      	; 0x8016 <__divsf3_pse+0xaa>
    800e:	62 1b       	sub	r22, r18
    8010:	73 0b       	sbc	r23, r19
    8012:	84 0b       	sbc	r24, r20
    8014:	ba 0b       	sbc	r27, r26
    8016:	ee 1f       	adc	r30, r30
    8018:	88 f7       	brcc	.-30     	; 0x7ffc <__divsf3_pse+0x90>
    801a:	e0 95       	com	r30
    801c:	08 95       	ret

0000801e <__fixsfsi>:
    801e:	04 d0       	rcall	.+8      	; 0x8028 <__fixunssfsi>
    8020:	68 94       	set
    8022:	b1 11       	cpse	r27, r1
    8024:	8a c1       	rjmp	.+788    	; 0x833a <__fp_szero>
    8026:	08 95       	ret

00008028 <__fixunssfsi>:
    8028:	56 d1       	rcall	.+684    	; 0x82d6 <__fp_splitA>
    802a:	88 f0       	brcs	.+34     	; 0x804e <__fixunssfsi+0x26>
    802c:	9f 57       	subi	r25, 0x7F	; 127
    802e:	90 f0       	brcs	.+36     	; 0x8054 <__fixunssfsi+0x2c>
    8030:	b9 2f       	mov	r27, r25
    8032:	99 27       	eor	r25, r25
    8034:	b7 51       	subi	r27, 0x17	; 23
    8036:	a0 f0       	brcs	.+40     	; 0x8060 <__fixunssfsi+0x38>
    8038:	d1 f0       	breq	.+52     	; 0x806e <__fixunssfsi+0x46>
    803a:	66 0f       	add	r22, r22
    803c:	77 1f       	adc	r23, r23
    803e:	88 1f       	adc	r24, r24
    8040:	99 1f       	adc	r25, r25
    8042:	1a f0       	brmi	.+6      	; 0x804a <__fixunssfsi+0x22>
    8044:	ba 95       	dec	r27
    8046:	c9 f7       	brne	.-14     	; 0x803a <__fixunssfsi+0x12>
    8048:	12 c0       	rjmp	.+36     	; 0x806e <__fixunssfsi+0x46>
    804a:	b1 30       	cpi	r27, 0x01	; 1
    804c:	81 f0       	breq	.+32     	; 0x806e <__fixunssfsi+0x46>
    804e:	74 d1       	rcall	.+744    	; 0x8338 <__fp_zero>
    8050:	b1 e0       	ldi	r27, 0x01	; 1
    8052:	08 95       	ret
    8054:	71 c1       	rjmp	.+738    	; 0x8338 <__fp_zero>
    8056:	67 2f       	mov	r22, r23
    8058:	78 2f       	mov	r23, r24
    805a:	88 27       	eor	r24, r24
    805c:	b8 5f       	subi	r27, 0xF8	; 248
    805e:	39 f0       	breq	.+14     	; 0x806e <__fixunssfsi+0x46>
    8060:	b9 3f       	cpi	r27, 0xF9	; 249
    8062:	cc f3       	brlt	.-14     	; 0x8056 <__fixunssfsi+0x2e>
    8064:	86 95       	lsr	r24
    8066:	77 95       	ror	r23
    8068:	67 95       	ror	r22
    806a:	b3 95       	inc	r27
    806c:	d9 f7       	brne	.-10     	; 0x8064 <__fixunssfsi+0x3c>
    806e:	3e f4       	brtc	.+14     	; 0x807e <__fixunssfsi+0x56>
    8070:	90 95       	com	r25
    8072:	80 95       	com	r24
    8074:	70 95       	com	r23
    8076:	61 95       	neg	r22
    8078:	7f 4f       	sbci	r23, 0xFF	; 255
    807a:	8f 4f       	sbci	r24, 0xFF	; 255
    807c:	9f 4f       	sbci	r25, 0xFF	; 255
    807e:	08 95       	ret

00008080 <__floatunsisf>:
    8080:	e8 94       	clt
    8082:	09 c0       	rjmp	.+18     	; 0x8096 <__floatsisf+0x12>

00008084 <__floatsisf>:
    8084:	97 fb       	bst	r25, 7
    8086:	3e f4       	brtc	.+14     	; 0x8096 <__floatsisf+0x12>
    8088:	90 95       	com	r25
    808a:	80 95       	com	r24
    808c:	70 95       	com	r23
    808e:	61 95       	neg	r22
    8090:	7f 4f       	sbci	r23, 0xFF	; 255
    8092:	8f 4f       	sbci	r24, 0xFF	; 255
    8094:	9f 4f       	sbci	r25, 0xFF	; 255
    8096:	99 23       	and	r25, r25
    8098:	a9 f0       	breq	.+42     	; 0x80c4 <__floatsisf+0x40>
    809a:	f9 2f       	mov	r31, r25
    809c:	96 e9       	ldi	r25, 0x96	; 150
    809e:	bb 27       	eor	r27, r27
    80a0:	93 95       	inc	r25
    80a2:	f6 95       	lsr	r31
    80a4:	87 95       	ror	r24
    80a6:	77 95       	ror	r23
    80a8:	67 95       	ror	r22
    80aa:	b7 95       	ror	r27
    80ac:	f1 11       	cpse	r31, r1
    80ae:	f8 cf       	rjmp	.-16     	; 0x80a0 <__floatsisf+0x1c>
    80b0:	fa f4       	brpl	.+62     	; 0x80f0 <__floatsisf+0x6c>
    80b2:	bb 0f       	add	r27, r27
    80b4:	11 f4       	brne	.+4      	; 0x80ba <__floatsisf+0x36>
    80b6:	60 ff       	sbrs	r22, 0
    80b8:	1b c0       	rjmp	.+54     	; 0x80f0 <__floatsisf+0x6c>
    80ba:	6f 5f       	subi	r22, 0xFF	; 255
    80bc:	7f 4f       	sbci	r23, 0xFF	; 255
    80be:	8f 4f       	sbci	r24, 0xFF	; 255
    80c0:	9f 4f       	sbci	r25, 0xFF	; 255
    80c2:	16 c0       	rjmp	.+44     	; 0x80f0 <__floatsisf+0x6c>
    80c4:	88 23       	and	r24, r24
    80c6:	11 f0       	breq	.+4      	; 0x80cc <__floatsisf+0x48>
    80c8:	96 e9       	ldi	r25, 0x96	; 150
    80ca:	11 c0       	rjmp	.+34     	; 0x80ee <__floatsisf+0x6a>
    80cc:	77 23       	and	r23, r23
    80ce:	21 f0       	breq	.+8      	; 0x80d8 <__floatsisf+0x54>
    80d0:	9e e8       	ldi	r25, 0x8E	; 142
    80d2:	87 2f       	mov	r24, r23
    80d4:	76 2f       	mov	r23, r22
    80d6:	05 c0       	rjmp	.+10     	; 0x80e2 <__floatsisf+0x5e>
    80d8:	66 23       	and	r22, r22
    80da:	71 f0       	breq	.+28     	; 0x80f8 <__floatsisf+0x74>
    80dc:	96 e8       	ldi	r25, 0x86	; 134
    80de:	86 2f       	mov	r24, r22
    80e0:	70 e0       	ldi	r23, 0x00	; 0
    80e2:	60 e0       	ldi	r22, 0x00	; 0
    80e4:	2a f0       	brmi	.+10     	; 0x80f0 <__floatsisf+0x6c>
    80e6:	9a 95       	dec	r25
    80e8:	66 0f       	add	r22, r22
    80ea:	77 1f       	adc	r23, r23
    80ec:	88 1f       	adc	r24, r24
    80ee:	da f7       	brpl	.-10     	; 0x80e6 <__floatsisf+0x62>
    80f0:	88 0f       	add	r24, r24
    80f2:	96 95       	lsr	r25
    80f4:	87 95       	ror	r24
    80f6:	97 f9       	bld	r25, 7
    80f8:	08 95       	ret

000080fa <floor>:
    80fa:	07 d1       	rcall	.+526    	; 0x830a <__fp_trunc>
    80fc:	80 f0       	brcs	.+32     	; 0x811e <floor+0x24>
    80fe:	9f 37       	cpi	r25, 0x7F	; 127
    8100:	40 f4       	brcc	.+16     	; 0x8112 <floor+0x18>
    8102:	91 11       	cpse	r25, r1
    8104:	0e f0       	brts	.+2      	; 0x8108 <floor+0xe>
    8106:	19 c1       	rjmp	.+562    	; 0x833a <__fp_szero>
    8108:	60 e0       	ldi	r22, 0x00	; 0
    810a:	70 e0       	ldi	r23, 0x00	; 0
    810c:	80 e8       	ldi	r24, 0x80	; 128
    810e:	9f eb       	ldi	r25, 0xBF	; 191
    8110:	08 95       	ret
    8112:	26 f4       	brtc	.+8      	; 0x811c <floor+0x22>
    8114:	1b 16       	cp	r1, r27
    8116:	61 1d       	adc	r22, r1
    8118:	71 1d       	adc	r23, r1
    811a:	81 1d       	adc	r24, r1
    811c:	2b c0       	rjmp	.+86     	; 0x8174 <__fp_mintl>
    811e:	45 c0       	rjmp	.+138    	; 0x81aa <__fp_mpack>

00008120 <__fp_cmp>:
    8120:	99 0f       	add	r25, r25
    8122:	00 08       	sbc	r0, r0
    8124:	55 0f       	add	r21, r21
    8126:	aa 0b       	sbc	r26, r26
    8128:	e0 e8       	ldi	r30, 0x80	; 128
    812a:	fe ef       	ldi	r31, 0xFE	; 254
    812c:	16 16       	cp	r1, r22
    812e:	17 06       	cpc	r1, r23
    8130:	e8 07       	cpc	r30, r24
    8132:	f9 07       	cpc	r31, r25
    8134:	c0 f0       	brcs	.+48     	; 0x8166 <__fp_cmp+0x46>
    8136:	12 16       	cp	r1, r18
    8138:	13 06       	cpc	r1, r19
    813a:	e4 07       	cpc	r30, r20
    813c:	f5 07       	cpc	r31, r21
    813e:	98 f0       	brcs	.+38     	; 0x8166 <__fp_cmp+0x46>
    8140:	62 1b       	sub	r22, r18
    8142:	73 0b       	sbc	r23, r19
    8144:	84 0b       	sbc	r24, r20
    8146:	95 0b       	sbc	r25, r21
    8148:	39 f4       	brne	.+14     	; 0x8158 <__fp_cmp+0x38>
    814a:	0a 26       	eor	r0, r26
    814c:	61 f0       	breq	.+24     	; 0x8166 <__fp_cmp+0x46>
    814e:	23 2b       	or	r18, r19
    8150:	24 2b       	or	r18, r20
    8152:	25 2b       	or	r18, r21
    8154:	21 f4       	brne	.+8      	; 0x815e <__fp_cmp+0x3e>
    8156:	08 95       	ret
    8158:	0a 26       	eor	r0, r26
    815a:	09 f4       	brne	.+2      	; 0x815e <__fp_cmp+0x3e>
    815c:	a1 40       	sbci	r26, 0x01	; 1
    815e:	a6 95       	lsr	r26
    8160:	8f ef       	ldi	r24, 0xFF	; 255
    8162:	81 1d       	adc	r24, r1
    8164:	81 1d       	adc	r24, r1
    8166:	08 95       	ret

00008168 <__fp_inf>:
    8168:	97 f9       	bld	r25, 7
    816a:	9f 67       	ori	r25, 0x7F	; 127
    816c:	80 e8       	ldi	r24, 0x80	; 128
    816e:	70 e0       	ldi	r23, 0x00	; 0
    8170:	60 e0       	ldi	r22, 0x00	; 0
    8172:	08 95       	ret

00008174 <__fp_mintl>:
    8174:	88 23       	and	r24, r24
    8176:	71 f4       	brne	.+28     	; 0x8194 <__fp_mintl+0x20>
    8178:	77 23       	and	r23, r23
    817a:	21 f0       	breq	.+8      	; 0x8184 <__fp_mintl+0x10>
    817c:	98 50       	subi	r25, 0x08	; 8
    817e:	87 2b       	or	r24, r23
    8180:	76 2f       	mov	r23, r22
    8182:	07 c0       	rjmp	.+14     	; 0x8192 <__fp_mintl+0x1e>
    8184:	66 23       	and	r22, r22
    8186:	11 f4       	brne	.+4      	; 0x818c <__fp_mintl+0x18>
    8188:	99 27       	eor	r25, r25
    818a:	0d c0       	rjmp	.+26     	; 0x81a6 <__fp_mintl+0x32>
    818c:	90 51       	subi	r25, 0x10	; 16
    818e:	86 2b       	or	r24, r22
    8190:	70 e0       	ldi	r23, 0x00	; 0
    8192:	60 e0       	ldi	r22, 0x00	; 0
    8194:	2a f0       	brmi	.+10     	; 0x81a0 <__fp_mintl+0x2c>
    8196:	9a 95       	dec	r25
    8198:	66 0f       	add	r22, r22
    819a:	77 1f       	adc	r23, r23
    819c:	88 1f       	adc	r24, r24
    819e:	da f7       	brpl	.-10     	; 0x8196 <__fp_mintl+0x22>
    81a0:	88 0f       	add	r24, r24
    81a2:	96 95       	lsr	r25
    81a4:	87 95       	ror	r24
    81a6:	97 f9       	bld	r25, 7
    81a8:	08 95       	ret

000081aa <__fp_mpack>:
    81aa:	9f 3f       	cpi	r25, 0xFF	; 255
    81ac:	31 f0       	breq	.+12     	; 0x81ba <__fp_mpack_finite+0xc>

000081ae <__fp_mpack_finite>:
    81ae:	91 50       	subi	r25, 0x01	; 1
    81b0:	20 f4       	brcc	.+8      	; 0x81ba <__fp_mpack_finite+0xc>
    81b2:	87 95       	ror	r24
    81b4:	77 95       	ror	r23
    81b6:	67 95       	ror	r22
    81b8:	b7 95       	ror	r27
    81ba:	88 0f       	add	r24, r24
    81bc:	91 1d       	adc	r25, r1
    81be:	96 95       	lsr	r25
    81c0:	87 95       	ror	r24
    81c2:	97 f9       	bld	r25, 7
    81c4:	08 95       	ret

000081c6 <__fp_nan>:
    81c6:	9f ef       	ldi	r25, 0xFF	; 255
    81c8:	80 ec       	ldi	r24, 0xC0	; 192
    81ca:	08 95       	ret

000081cc <__fp_powser>:
    81cc:	df 93       	push	r29
    81ce:	cf 93       	push	r28
    81d0:	1f 93       	push	r17
    81d2:	0f 93       	push	r16
    81d4:	ff 92       	push	r15
    81d6:	ef 92       	push	r14
    81d8:	df 92       	push	r13
    81da:	7b 01       	movw	r14, r22
    81dc:	8c 01       	movw	r16, r24
    81de:	68 94       	set
    81e0:	05 c0       	rjmp	.+10     	; 0x81ec <__fp_powser+0x20>
    81e2:	da 2e       	mov	r13, r26
    81e4:	ef 01       	movw	r28, r30
    81e6:	f6 d0       	rcall	.+492    	; 0x83d4 <__mulsf3x>
    81e8:	fe 01       	movw	r30, r28
    81ea:	e8 94       	clt
    81ec:	a5 91       	lpm	r26, Z+
    81ee:	25 91       	lpm	r18, Z+
    81f0:	35 91       	lpm	r19, Z+
    81f2:	45 91       	lpm	r20, Z+
    81f4:	55 91       	lpm	r21, Z+
    81f6:	ae f3       	brts	.-22     	; 0x81e2 <__fp_powser+0x16>
    81f8:	ef 01       	movw	r28, r30
    81fa:	da dd       	rcall	.-1100   	; 0x7db0 <__addsf3x>
    81fc:	fe 01       	movw	r30, r28
    81fe:	97 01       	movw	r18, r14
    8200:	a8 01       	movw	r20, r16
    8202:	da 94       	dec	r13
    8204:	79 f7       	brne	.-34     	; 0x81e4 <__fp_powser+0x18>
    8206:	df 90       	pop	r13
    8208:	ef 90       	pop	r14
    820a:	ff 90       	pop	r15
    820c:	0f 91       	pop	r16
    820e:	1f 91       	pop	r17
    8210:	cf 91       	pop	r28
    8212:	df 91       	pop	r29
    8214:	08 95       	ret

00008216 <__fp_pscA>:
    8216:	00 24       	eor	r0, r0
    8218:	0a 94       	dec	r0
    821a:	16 16       	cp	r1, r22
    821c:	17 06       	cpc	r1, r23
    821e:	18 06       	cpc	r1, r24
    8220:	09 06       	cpc	r0, r25
    8222:	08 95       	ret

00008224 <__fp_pscB>:
    8224:	00 24       	eor	r0, r0
    8226:	0a 94       	dec	r0
    8228:	12 16       	cp	r1, r18
    822a:	13 06       	cpc	r1, r19
    822c:	14 06       	cpc	r1, r20
    822e:	05 06       	cpc	r0, r21
    8230:	08 95       	ret
    8232:	c9 cf       	rjmp	.-110    	; 0x81c6 <__fp_nan>

00008234 <__fp_rempio2>:
    8234:	50 d0       	rcall	.+160    	; 0x82d6 <__fp_splitA>
    8236:	e8 f3       	brcs	.-6      	; 0x8232 <__fp_pscB+0xe>
    8238:	e8 94       	clt
    823a:	e0 e0       	ldi	r30, 0x00	; 0
    823c:	bb 27       	eor	r27, r27
    823e:	9f 57       	subi	r25, 0x7F	; 127
    8240:	f0 f0       	brcs	.+60     	; 0x827e <__fp_rempio2+0x4a>
    8242:	2a ed       	ldi	r18, 0xDA	; 218
    8244:	3f e0       	ldi	r19, 0x0F	; 15
    8246:	49 ec       	ldi	r20, 0xC9	; 201
    8248:	06 c0       	rjmp	.+12     	; 0x8256 <__fp_rempio2+0x22>
    824a:	ee 0f       	add	r30, r30
    824c:	bb 0f       	add	r27, r27
    824e:	66 1f       	adc	r22, r22
    8250:	77 1f       	adc	r23, r23
    8252:	88 1f       	adc	r24, r24
    8254:	28 f0       	brcs	.+10     	; 0x8260 <__fp_rempio2+0x2c>
    8256:	b2 3a       	cpi	r27, 0xA2	; 162
    8258:	62 07       	cpc	r22, r18
    825a:	73 07       	cpc	r23, r19
    825c:	84 07       	cpc	r24, r20
    825e:	28 f0       	brcs	.+10     	; 0x826a <__fp_rempio2+0x36>
    8260:	b2 5a       	subi	r27, 0xA2	; 162
    8262:	62 0b       	sbc	r22, r18
    8264:	73 0b       	sbc	r23, r19
    8266:	84 0b       	sbc	r24, r20
    8268:	e3 95       	inc	r30
    826a:	9a 95       	dec	r25
    826c:	72 f7       	brpl	.-36     	; 0x824a <__fp_rempio2+0x16>
    826e:	80 38       	cpi	r24, 0x80	; 128
    8270:	30 f4       	brcc	.+12     	; 0x827e <__fp_rempio2+0x4a>
    8272:	9a 95       	dec	r25
    8274:	bb 0f       	add	r27, r27
    8276:	66 1f       	adc	r22, r22
    8278:	77 1f       	adc	r23, r23
    827a:	88 1f       	adc	r24, r24
    827c:	d2 f7       	brpl	.-12     	; 0x8272 <__fp_rempio2+0x3e>
    827e:	90 48       	sbci	r25, 0x80	; 128
    8280:	96 cf       	rjmp	.-212    	; 0x81ae <__fp_mpack_finite>

00008282 <__fp_round>:
    8282:	09 2e       	mov	r0, r25
    8284:	03 94       	inc	r0
    8286:	00 0c       	add	r0, r0
    8288:	11 f4       	brne	.+4      	; 0x828e <__fp_round+0xc>
    828a:	88 23       	and	r24, r24
    828c:	52 f0       	brmi	.+20     	; 0x82a2 <__fp_round+0x20>
    828e:	bb 0f       	add	r27, r27
    8290:	40 f4       	brcc	.+16     	; 0x82a2 <__fp_round+0x20>
    8292:	bf 2b       	or	r27, r31
    8294:	11 f4       	brne	.+4      	; 0x829a <__fp_round+0x18>
    8296:	60 ff       	sbrs	r22, 0
    8298:	04 c0       	rjmp	.+8      	; 0x82a2 <__fp_round+0x20>
    829a:	6f 5f       	subi	r22, 0xFF	; 255
    829c:	7f 4f       	sbci	r23, 0xFF	; 255
    829e:	8f 4f       	sbci	r24, 0xFF	; 255
    82a0:	9f 4f       	sbci	r25, 0xFF	; 255
    82a2:	08 95       	ret

000082a4 <__fp_sinus>:
    82a4:	ef 93       	push	r30
    82a6:	e0 ff       	sbrs	r30, 0
    82a8:	06 c0       	rjmp	.+12     	; 0x82b6 <__fp_sinus+0x12>
    82aa:	a2 ea       	ldi	r26, 0xA2	; 162
    82ac:	2a ed       	ldi	r18, 0xDA	; 218
    82ae:	3f e0       	ldi	r19, 0x0F	; 15
    82b0:	49 ec       	ldi	r20, 0xC9	; 201
    82b2:	5f eb       	ldi	r21, 0xBF	; 191
    82b4:	7d dd       	rcall	.-1286   	; 0x7db0 <__addsf3x>
    82b6:	e5 df       	rcall	.-54     	; 0x8282 <__fp_round>
    82b8:	0f 90       	pop	r0
    82ba:	03 94       	inc	r0
    82bc:	01 fc       	sbrc	r0, 1
    82be:	90 58       	subi	r25, 0x80	; 128
    82c0:	eb ec       	ldi	r30, 0xCB	; 203
    82c2:	f2 e0       	ldi	r31, 0x02	; 2
    82c4:	57 c1       	rjmp	.+686    	; 0x8574 <__fp_powsodd>

000082c6 <__fp_split3>:
    82c6:	57 fd       	sbrc	r21, 7
    82c8:	90 58       	subi	r25, 0x80	; 128
    82ca:	44 0f       	add	r20, r20
    82cc:	55 1f       	adc	r21, r21
    82ce:	59 f0       	breq	.+22     	; 0x82e6 <__fp_splitA+0x10>
    82d0:	5f 3f       	cpi	r21, 0xFF	; 255
    82d2:	71 f0       	breq	.+28     	; 0x82f0 <__fp_splitA+0x1a>
    82d4:	47 95       	ror	r20

000082d6 <__fp_splitA>:
    82d6:	88 0f       	add	r24, r24
    82d8:	97 fb       	bst	r25, 7
    82da:	99 1f       	adc	r25, r25
    82dc:	61 f0       	breq	.+24     	; 0x82f6 <__fp_splitA+0x20>
    82de:	9f 3f       	cpi	r25, 0xFF	; 255
    82e0:	79 f0       	breq	.+30     	; 0x8300 <__fp_splitA+0x2a>
    82e2:	87 95       	ror	r24
    82e4:	08 95       	ret
    82e6:	12 16       	cp	r1, r18
    82e8:	13 06       	cpc	r1, r19
    82ea:	14 06       	cpc	r1, r20
    82ec:	55 1f       	adc	r21, r21
    82ee:	f2 cf       	rjmp	.-28     	; 0x82d4 <__fp_split3+0xe>
    82f0:	46 95       	lsr	r20
    82f2:	f1 df       	rcall	.-30     	; 0x82d6 <__fp_splitA>
    82f4:	08 c0       	rjmp	.+16     	; 0x8306 <__fp_splitA+0x30>
    82f6:	16 16       	cp	r1, r22
    82f8:	17 06       	cpc	r1, r23
    82fa:	18 06       	cpc	r1, r24
    82fc:	99 1f       	adc	r25, r25
    82fe:	f1 cf       	rjmp	.-30     	; 0x82e2 <__fp_splitA+0xc>
    8300:	86 95       	lsr	r24
    8302:	71 05       	cpc	r23, r1
    8304:	61 05       	cpc	r22, r1
    8306:	08 94       	sec
    8308:	08 95       	ret

0000830a <__fp_trunc>:
    830a:	e5 df       	rcall	.-54     	; 0x82d6 <__fp_splitA>
    830c:	a0 f0       	brcs	.+40     	; 0x8336 <__fp_trunc+0x2c>
    830e:	be e7       	ldi	r27, 0x7E	; 126
    8310:	b9 17       	cp	r27, r25
    8312:	88 f4       	brcc	.+34     	; 0x8336 <__fp_trunc+0x2c>
    8314:	bb 27       	eor	r27, r27
    8316:	9f 38       	cpi	r25, 0x8F	; 143
    8318:	60 f4       	brcc	.+24     	; 0x8332 <__fp_trunc+0x28>
    831a:	16 16       	cp	r1, r22
    831c:	b1 1d       	adc	r27, r1
    831e:	67 2f       	mov	r22, r23
    8320:	78 2f       	mov	r23, r24
    8322:	88 27       	eor	r24, r24
    8324:	98 5f       	subi	r25, 0xF8	; 248
    8326:	f7 cf       	rjmp	.-18     	; 0x8316 <__fp_trunc+0xc>
    8328:	86 95       	lsr	r24
    832a:	77 95       	ror	r23
    832c:	67 95       	ror	r22
    832e:	b1 1d       	adc	r27, r1
    8330:	93 95       	inc	r25
    8332:	96 39       	cpi	r25, 0x96	; 150
    8334:	c8 f3       	brcs	.-14     	; 0x8328 <__fp_trunc+0x1e>
    8336:	08 95       	ret

00008338 <__fp_zero>:
    8338:	e8 94       	clt

0000833a <__fp_szero>:
    833a:	bb 27       	eor	r27, r27
    833c:	66 27       	eor	r22, r22
    833e:	77 27       	eor	r23, r23
    8340:	cb 01       	movw	r24, r22
    8342:	97 f9       	bld	r25, 7
    8344:	08 95       	ret

00008346 <__gesf2>:
    8346:	ec de       	rcall	.-552    	; 0x8120 <__fp_cmp>
    8348:	08 f4       	brcc	.+2      	; 0x834c <__gesf2+0x6>
    834a:	8f ef       	ldi	r24, 0xFF	; 255
    834c:	08 95       	ret

0000834e <inverse>:
    834e:	9b 01       	movw	r18, r22
    8350:	ac 01       	movw	r20, r24
    8352:	60 e0       	ldi	r22, 0x00	; 0
    8354:	70 e0       	ldi	r23, 0x00	; 0
    8356:	80 e8       	ldi	r24, 0x80	; 128
    8358:	9f e3       	ldi	r25, 0x3F	; 63
    835a:	f9 cd       	rjmp	.-1038   	; 0x7f4e <__divsf3>

0000835c <lround>:
    835c:	bc df       	rcall	.-136    	; 0x82d6 <__fp_splitA>
    835e:	58 f1       	brcs	.+86     	; 0x83b6 <lround+0x5a>
    8360:	9e 57       	subi	r25, 0x7E	; 126
    8362:	58 f1       	brcs	.+86     	; 0x83ba <lround+0x5e>
    8364:	98 51       	subi	r25, 0x18	; 24
    8366:	a0 f0       	brcs	.+40     	; 0x8390 <lround+0x34>
    8368:	e9 f0       	breq	.+58     	; 0x83a4 <lround+0x48>
    836a:	98 30       	cpi	r25, 0x08	; 8
    836c:	20 f5       	brcc	.+72     	; 0x83b6 <lround+0x5a>
    836e:	09 2e       	mov	r0, r25
    8370:	99 27       	eor	r25, r25
    8372:	66 0f       	add	r22, r22
    8374:	77 1f       	adc	r23, r23
    8376:	88 1f       	adc	r24, r24
    8378:	99 1f       	adc	r25, r25
    837a:	0a 94       	dec	r0
    837c:	d1 f7       	brne	.-12     	; 0x8372 <lround+0x16>
    837e:	12 c0       	rjmp	.+36     	; 0x83a4 <lround+0x48>
    8380:	06 2e       	mov	r0, r22
    8382:	67 2f       	mov	r22, r23
    8384:	78 2f       	mov	r23, r24
    8386:	88 27       	eor	r24, r24
    8388:	98 5f       	subi	r25, 0xF8	; 248
    838a:	11 f4       	brne	.+4      	; 0x8390 <lround+0x34>
    838c:	00 0c       	add	r0, r0
    838e:	07 c0       	rjmp	.+14     	; 0x839e <lround+0x42>
    8390:	99 3f       	cpi	r25, 0xF9	; 249
    8392:	b4 f3       	brlt	.-20     	; 0x8380 <lround+0x24>
    8394:	86 95       	lsr	r24
    8396:	77 95       	ror	r23
    8398:	67 95       	ror	r22
    839a:	93 95       	inc	r25
    839c:	d9 f7       	brne	.-10     	; 0x8394 <lround+0x38>
    839e:	61 1d       	adc	r22, r1
    83a0:	71 1d       	adc	r23, r1
    83a2:	81 1d       	adc	r24, r1
    83a4:	3e f4       	brtc	.+14     	; 0x83b4 <lround+0x58>
    83a6:	90 95       	com	r25
    83a8:	80 95       	com	r24
    83aa:	70 95       	com	r23
    83ac:	61 95       	neg	r22
    83ae:	7f 4f       	sbci	r23, 0xFF	; 255
    83b0:	8f 4f       	sbci	r24, 0xFF	; 255
    83b2:	9f 4f       	sbci	r25, 0xFF	; 255
    83b4:	08 95       	ret
    83b6:	68 94       	set
    83b8:	c0 cf       	rjmp	.-128    	; 0x833a <__fp_szero>
    83ba:	be cf       	rjmp	.-132    	; 0x8338 <__fp_zero>

000083bc <__mulsf3>:
    83bc:	0b d0       	rcall	.+22     	; 0x83d4 <__mulsf3x>
    83be:	61 cf       	rjmp	.-318    	; 0x8282 <__fp_round>
    83c0:	2a df       	rcall	.-428    	; 0x8216 <__fp_pscA>
    83c2:	28 f0       	brcs	.+10     	; 0x83ce <__mulsf3+0x12>
    83c4:	2f df       	rcall	.-418    	; 0x8224 <__fp_pscB>
    83c6:	18 f0       	brcs	.+6      	; 0x83ce <__mulsf3+0x12>
    83c8:	95 23       	and	r25, r21
    83ca:	09 f0       	breq	.+2      	; 0x83ce <__mulsf3+0x12>
    83cc:	cd ce       	rjmp	.-614    	; 0x8168 <__fp_inf>
    83ce:	fb ce       	rjmp	.-522    	; 0x81c6 <__fp_nan>
    83d0:	11 24       	eor	r1, r1
    83d2:	b3 cf       	rjmp	.-154    	; 0x833a <__fp_szero>

000083d4 <__mulsf3x>:
    83d4:	78 df       	rcall	.-272    	; 0x82c6 <__fp_split3>
    83d6:	a0 f3       	brcs	.-24     	; 0x83c0 <__mulsf3+0x4>

000083d8 <__mulsf3_pse>:
    83d8:	95 9f       	mul	r25, r21
    83da:	d1 f3       	breq	.-12     	; 0x83d0 <__mulsf3+0x14>
    83dc:	95 0f       	add	r25, r21
    83de:	50 e0       	ldi	r21, 0x00	; 0
    83e0:	55 1f       	adc	r21, r21
    83e2:	62 9f       	mul	r22, r18
    83e4:	f0 01       	movw	r30, r0
    83e6:	72 9f       	mul	r23, r18
    83e8:	bb 27       	eor	r27, r27
    83ea:	f0 0d       	add	r31, r0
    83ec:	b1 1d       	adc	r27, r1
    83ee:	63 9f       	mul	r22, r19
    83f0:	aa 27       	eor	r26, r26
    83f2:	f0 0d       	add	r31, r0
    83f4:	b1 1d       	adc	r27, r1
    83f6:	aa 1f       	adc	r26, r26
    83f8:	64 9f       	mul	r22, r20
    83fa:	66 27       	eor	r22, r22
    83fc:	b0 0d       	add	r27, r0
    83fe:	a1 1d       	adc	r26, r1
    8400:	66 1f       	adc	r22, r22
    8402:	82 9f       	mul	r24, r18
    8404:	22 27       	eor	r18, r18
    8406:	b0 0d       	add	r27, r0
    8408:	a1 1d       	adc	r26, r1
    840a:	62 1f       	adc	r22, r18
    840c:	73 9f       	mul	r23, r19
    840e:	b0 0d       	add	r27, r0
    8410:	a1 1d       	adc	r26, r1
    8412:	62 1f       	adc	r22, r18
    8414:	83 9f       	mul	r24, r19
    8416:	a0 0d       	add	r26, r0
    8418:	61 1d       	adc	r22, r1
    841a:	22 1f       	adc	r18, r18
    841c:	74 9f       	mul	r23, r20
    841e:	33 27       	eor	r19, r19
    8420:	a0 0d       	add	r26, r0
    8422:	61 1d       	adc	r22, r1
    8424:	23 1f       	adc	r18, r19
    8426:	84 9f       	mul	r24, r20
    8428:	60 0d       	add	r22, r0
    842a:	21 1d       	adc	r18, r1
    842c:	82 2f       	mov	r24, r18
    842e:	76 2f       	mov	r23, r22
    8430:	6a 2f       	mov	r22, r26
    8432:	11 24       	eor	r1, r1
    8434:	9f 57       	subi	r25, 0x7F	; 127
    8436:	50 40       	sbci	r21, 0x00	; 0
    8438:	8a f0       	brmi	.+34     	; 0x845c <__mulsf3_pse+0x84>
    843a:	e1 f0       	breq	.+56     	; 0x8474 <__mulsf3_pse+0x9c>
    843c:	88 23       	and	r24, r24
    843e:	4a f0       	brmi	.+18     	; 0x8452 <__mulsf3_pse+0x7a>
    8440:	ee 0f       	add	r30, r30
    8442:	ff 1f       	adc	r31, r31
    8444:	bb 1f       	adc	r27, r27
    8446:	66 1f       	adc	r22, r22
    8448:	77 1f       	adc	r23, r23
    844a:	88 1f       	adc	r24, r24
    844c:	91 50       	subi	r25, 0x01	; 1
    844e:	50 40       	sbci	r21, 0x00	; 0
    8450:	a9 f7       	brne	.-22     	; 0x843c <__mulsf3_pse+0x64>
    8452:	9e 3f       	cpi	r25, 0xFE	; 254
    8454:	51 05       	cpc	r21, r1
    8456:	70 f0       	brcs	.+28     	; 0x8474 <__mulsf3_pse+0x9c>
    8458:	87 ce       	rjmp	.-754    	; 0x8168 <__fp_inf>
    845a:	6f cf       	rjmp	.-290    	; 0x833a <__fp_szero>
    845c:	5f 3f       	cpi	r21, 0xFF	; 255
    845e:	ec f3       	brlt	.-6      	; 0x845a <__mulsf3_pse+0x82>
    8460:	98 3e       	cpi	r25, 0xE8	; 232
    8462:	dc f3       	brlt	.-10     	; 0x845a <__mulsf3_pse+0x82>
    8464:	86 95       	lsr	r24
    8466:	77 95       	ror	r23
    8468:	67 95       	ror	r22
    846a:	b7 95       	ror	r27
    846c:	f7 95       	ror	r31
    846e:	e7 95       	ror	r30
    8470:	9f 5f       	subi	r25, 0xFF	; 255
    8472:	c1 f7       	brne	.-16     	; 0x8464 <__mulsf3_pse+0x8c>
    8474:	fe 2b       	or	r31, r30
    8476:	88 0f       	add	r24, r24
    8478:	91 1d       	adc	r25, r1
    847a:	96 95       	lsr	r25
    847c:	87 95       	ror	r24
    847e:	97 f9       	bld	r25, 7
    8480:	08 95       	ret

00008482 <round>:
    8482:	29 df       	rcall	.-430    	; 0x82d6 <__fp_splitA>
    8484:	e0 f0       	brcs	.+56     	; 0x84be <round+0x3c>
    8486:	9e 37       	cpi	r25, 0x7E	; 126
    8488:	d8 f0       	brcs	.+54     	; 0x84c0 <round+0x3e>
    848a:	96 39       	cpi	r25, 0x96	; 150
    848c:	b8 f4       	brcc	.+46     	; 0x84bc <round+0x3a>
    848e:	9e 38       	cpi	r25, 0x8E	; 142
    8490:	48 f4       	brcc	.+18     	; 0x84a4 <round+0x22>
    8492:	67 2f       	mov	r22, r23
    8494:	78 2f       	mov	r23, r24
    8496:	88 27       	eor	r24, r24
    8498:	98 5f       	subi	r25, 0xF8	; 248
    849a:	f9 cf       	rjmp	.-14     	; 0x848e <round+0xc>
    849c:	86 95       	lsr	r24
    849e:	77 95       	ror	r23
    84a0:	67 95       	ror	r22
    84a2:	93 95       	inc	r25
    84a4:	95 39       	cpi	r25, 0x95	; 149
    84a6:	d0 f3       	brcs	.-12     	; 0x849c <round+0x1a>
    84a8:	b6 2f       	mov	r27, r22
    84aa:	b1 70       	andi	r27, 0x01	; 1
    84ac:	6b 0f       	add	r22, r27
    84ae:	71 1d       	adc	r23, r1
    84b0:	81 1d       	adc	r24, r1
    84b2:	20 f4       	brcc	.+8      	; 0x84bc <round+0x3a>
    84b4:	87 95       	ror	r24
    84b6:	77 95       	ror	r23
    84b8:	67 95       	ror	r22
    84ba:	93 95       	inc	r25
    84bc:	5b ce       	rjmp	.-842    	; 0x8174 <__fp_mintl>
    84be:	75 ce       	rjmp	.-790    	; 0x81aa <__fp_mpack>
    84c0:	3c cf       	rjmp	.-392    	; 0x833a <__fp_szero>

000084c2 <sin>:
    84c2:	9f 93       	push	r25
    84c4:	b7 de       	rcall	.-658    	; 0x8234 <__fp_rempio2>
    84c6:	0f 90       	pop	r0
    84c8:	07 fc       	sbrc	r0, 7
    84ca:	ee 5f       	subi	r30, 0xFE	; 254
    84cc:	eb ce       	rjmp	.-554    	; 0x82a4 <__fp_sinus>
    84ce:	11 f4       	brne	.+4      	; 0x84d4 <sin+0x12>
    84d0:	0e f4       	brtc	.+2      	; 0x84d4 <sin+0x12>
    84d2:	79 ce       	rjmp	.-782    	; 0x81c6 <__fp_nan>
    84d4:	6a ce       	rjmp	.-812    	; 0x81aa <__fp_mpack>

000084d6 <sqrt>:
    84d6:	ff de       	rcall	.-514    	; 0x82d6 <__fp_splitA>
    84d8:	d0 f3       	brcs	.-12     	; 0x84ce <sin+0xc>
    84da:	99 23       	and	r25, r25
    84dc:	d9 f3       	breq	.-10     	; 0x84d4 <sin+0x12>
    84de:	ce f3       	brts	.-14     	; 0x84d2 <sin+0x10>
    84e0:	9f 57       	subi	r25, 0x7F	; 127
    84e2:	55 0b       	sbc	r21, r21
    84e4:	87 ff       	sbrs	r24, 7
    84e6:	3f d0       	rcall	.+126    	; 0x8566 <__fp_norm2>
    84e8:	00 24       	eor	r0, r0
    84ea:	a0 e6       	ldi	r26, 0x60	; 96
    84ec:	40 ea       	ldi	r20, 0xA0	; 160
    84ee:	90 01       	movw	r18, r0
    84f0:	80 58       	subi	r24, 0x80	; 128
    84f2:	56 95       	lsr	r21
    84f4:	97 95       	ror	r25
    84f6:	28 f4       	brcc	.+10     	; 0x8502 <sqrt+0x2c>
    84f8:	80 5c       	subi	r24, 0xC0	; 192
    84fa:	66 0f       	add	r22, r22
    84fc:	77 1f       	adc	r23, r23
    84fe:	88 1f       	adc	r24, r24
    8500:	20 f0       	brcs	.+8      	; 0x850a <sqrt+0x34>
    8502:	26 17       	cp	r18, r22
    8504:	37 07       	cpc	r19, r23
    8506:	48 07       	cpc	r20, r24
    8508:	30 f4       	brcc	.+12     	; 0x8516 <sqrt+0x40>
    850a:	62 1b       	sub	r22, r18
    850c:	73 0b       	sbc	r23, r19
    850e:	84 0b       	sbc	r24, r20
    8510:	20 29       	or	r18, r0
    8512:	31 29       	or	r19, r1
    8514:	4a 2b       	or	r20, r26
    8516:	a6 95       	lsr	r26
    8518:	17 94       	ror	r1
    851a:	07 94       	ror	r0
    851c:	20 25       	eor	r18, r0
    851e:	31 25       	eor	r19, r1
    8520:	4a 27       	eor	r20, r26
    8522:	58 f7       	brcc	.-42     	; 0x84fa <sqrt+0x24>
    8524:	66 0f       	add	r22, r22
    8526:	77 1f       	adc	r23, r23
    8528:	88 1f       	adc	r24, r24
    852a:	20 f0       	brcs	.+8      	; 0x8534 <sqrt+0x5e>
    852c:	26 17       	cp	r18, r22
    852e:	37 07       	cpc	r19, r23
    8530:	48 07       	cpc	r20, r24
    8532:	30 f4       	brcc	.+12     	; 0x8540 <sqrt+0x6a>
    8534:	62 0b       	sbc	r22, r18
    8536:	73 0b       	sbc	r23, r19
    8538:	84 0b       	sbc	r24, r20
    853a:	20 0d       	add	r18, r0
    853c:	31 1d       	adc	r19, r1
    853e:	41 1d       	adc	r20, r1
    8540:	a0 95       	com	r26
    8542:	81 f7       	brne	.-32     	; 0x8524 <sqrt+0x4e>
    8544:	b9 01       	movw	r22, r18
    8546:	84 2f       	mov	r24, r20
    8548:	91 58       	subi	r25, 0x81	; 129
    854a:	88 0f       	add	r24, r24
    854c:	96 95       	lsr	r25
    854e:	87 95       	ror	r24
    8550:	08 95       	ret

00008552 <square>:
    8552:	9b 01       	movw	r18, r22
    8554:	ac 01       	movw	r20, r24
    8556:	32 cf       	rjmp	.-412    	; 0x83bc <__mulsf3>

00008558 <trunc>:
    8558:	d8 de       	rcall	.-592    	; 0x830a <__fp_trunc>
    855a:	20 f0       	brcs	.+8      	; 0x8564 <trunc+0xc>
    855c:	9f 37       	cpi	r25, 0x7F	; 127
    855e:	08 f4       	brcc	.+2      	; 0x8562 <trunc+0xa>
    8560:	ec ce       	rjmp	.-552    	; 0x833a <__fp_szero>
    8562:	08 ce       	rjmp	.-1008   	; 0x8174 <__fp_mintl>
    8564:	22 ce       	rjmp	.-956    	; 0x81aa <__fp_mpack>

00008566 <__fp_norm2>:
    8566:	91 50       	subi	r25, 0x01	; 1
    8568:	50 40       	sbci	r21, 0x00	; 0
    856a:	66 0f       	add	r22, r22
    856c:	77 1f       	adc	r23, r23
    856e:	88 1f       	adc	r24, r24
    8570:	d2 f7       	brpl	.-12     	; 0x8566 <__fp_norm2>
    8572:	08 95       	ret

00008574 <__fp_powsodd>:
    8574:	9f 93       	push	r25
    8576:	8f 93       	push	r24
    8578:	7f 93       	push	r23
    857a:	6f 93       	push	r22
    857c:	ff 93       	push	r31
    857e:	ef 93       	push	r30
    8580:	9b 01       	movw	r18, r22
    8582:	ac 01       	movw	r20, r24
    8584:	1b df       	rcall	.-458    	; 0x83bc <__mulsf3>
    8586:	ef 91       	pop	r30
    8588:	ff 91       	pop	r31
    858a:	20 de       	rcall	.-960    	; 0x81cc <__fp_powser>
    858c:	2f 91       	pop	r18
    858e:	3f 91       	pop	r19
    8590:	4f 91       	pop	r20
    8592:	5f 91       	pop	r21
    8594:	13 cf       	rjmp	.-474    	; 0x83bc <__mulsf3>

00008596 <__udivmodsi4>:
    8596:	a1 e2       	ldi	r26, 0x21	; 33
    8598:	1a 2e       	mov	r1, r26
    859a:	aa 1b       	sub	r26, r26
    859c:	bb 1b       	sub	r27, r27
    859e:	fd 01       	movw	r30, r26
    85a0:	0d c0       	rjmp	.+26     	; 0x85bc <__udivmodsi4_ep>

000085a2 <__udivmodsi4_loop>:
    85a2:	aa 1f       	adc	r26, r26
    85a4:	bb 1f       	adc	r27, r27
    85a6:	ee 1f       	adc	r30, r30
    85a8:	ff 1f       	adc	r31, r31
    85aa:	a2 17       	cp	r26, r18
    85ac:	b3 07       	cpc	r27, r19
    85ae:	e4 07       	cpc	r30, r20
    85b0:	f5 07       	cpc	r31, r21
    85b2:	20 f0       	brcs	.+8      	; 0x85bc <__udivmodsi4_ep>
    85b4:	a2 1b       	sub	r26, r18
    85b6:	b3 0b       	sbc	r27, r19
    85b8:	e4 0b       	sbc	r30, r20
    85ba:	f5 0b       	sbc	r31, r21

000085bc <__udivmodsi4_ep>:
    85bc:	66 1f       	adc	r22, r22
    85be:	77 1f       	adc	r23, r23
    85c0:	88 1f       	adc	r24, r24
    85c2:	99 1f       	adc	r25, r25
    85c4:	1a 94       	dec	r1
    85c6:	69 f7       	brne	.-38     	; 0x85a2 <__udivmodsi4_loop>
    85c8:	60 95       	com	r22
    85ca:	70 95       	com	r23
    85cc:	80 95       	com	r24
    85ce:	90 95       	com	r25
    85d0:	9b 01       	movw	r18, r22
    85d2:	ac 01       	movw	r20, r24
    85d4:	bd 01       	movw	r22, r26
    85d6:	cf 01       	movw	r24, r30
    85d8:	08 95       	ret

000085da <__tablejump2__>:
    85da:	ee 0f       	add	r30, r30
    85dc:	ff 1f       	adc	r31, r31
    85de:	88 1f       	adc	r24, r24
    85e0:	8b bf       	out	0x3b, r24	; 59
    85e2:	07 90       	elpm	r0, Z+
    85e4:	f6 91       	elpm	r31, Z
    85e6:	e0 2d       	mov	r30, r0
    85e8:	19 94       	eijmp

000085ea <__umulhisi3>:
    85ea:	a2 9f       	mul	r26, r18
    85ec:	b0 01       	movw	r22, r0
    85ee:	b3 9f       	mul	r27, r19
    85f0:	c0 01       	movw	r24, r0
    85f2:	a3 9f       	mul	r26, r19
    85f4:	70 0d       	add	r23, r0
    85f6:	81 1d       	adc	r24, r1
    85f8:	11 24       	eor	r1, r1
    85fa:	91 1d       	adc	r25, r1
    85fc:	b2 9f       	mul	r27, r18
    85fe:	70 0d       	add	r23, r0
    8600:	81 1d       	adc	r24, r1
    8602:	11 24       	eor	r1, r1
    8604:	91 1d       	adc	r25, r1
    8606:	08 95       	ret

00008608 <memcmp>:
    8608:	fb 01       	movw	r30, r22
    860a:	dc 01       	movw	r26, r24
    860c:	04 c0       	rjmp	.+8      	; 0x8616 <memcmp+0xe>
    860e:	8d 91       	ld	r24, X+
    8610:	01 90       	ld	r0, Z+
    8612:	80 19       	sub	r24, r0
    8614:	21 f4       	brne	.+8      	; 0x861e <memcmp+0x16>
    8616:	41 50       	subi	r20, 0x01	; 1
    8618:	50 40       	sbci	r21, 0x00	; 0
    861a:	c8 f7       	brcc	.-14     	; 0x860e <memcmp+0x6>
    861c:	88 1b       	sub	r24, r24
    861e:	99 0b       	sbc	r25, r25
    8620:	08 95       	ret

00008622 <_exit>:
    8622:	f8 94       	cli

00008624 <__stop_program>:
    8624:	ff cf       	rjmp	.-2      	; 0x8624 <__stop_program>

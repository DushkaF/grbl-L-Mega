
GRBL-L-Mega.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800200  00800200  0000862c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000085b8  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000d27  00800200  00800200  0000862c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000862c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000865c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006c8  00000000  00000000  0000869c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000aff5  00000000  00000000  00008d64  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002c74  00000000  00000000  00013d59  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000636e  00000000  00000000  000169cd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001680  00000000  00000000  0001cd3c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000021d0  00000000  00000000  0001e3bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000704b  00000000  00000000  0002058c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000006d0  00000000  00000000  000275d7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	95 c2       	rjmp	.+1322   	; 0x52c <__ctors_end>
       2:	00 00       	nop
       4:	a6 c2       	rjmp	.+1356   	; 0x552 <__bad_interrupt>
       6:	00 00       	nop
       8:	a4 c2       	rjmp	.+1352   	; 0x552 <__bad_interrupt>
       a:	00 00       	nop
       c:	a2 c2       	rjmp	.+1348   	; 0x552 <__bad_interrupt>
       e:	00 00       	nop
      10:	a0 c2       	rjmp	.+1344   	; 0x552 <__bad_interrupt>
      12:	00 00       	nop
      14:	9e c2       	rjmp	.+1340   	; 0x552 <__bad_interrupt>
      16:	00 00       	nop
      18:	9c c2       	rjmp	.+1336   	; 0x552 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	9a c2       	rjmp	.+1332   	; 0x552 <__bad_interrupt>
      1e:	00 00       	nop
      20:	98 c2       	rjmp	.+1328   	; 0x552 <__bad_interrupt>
      22:	00 00       	nop
      24:	0c 94 a8 30 	jmp	0x6150	; 0x6150 <__vector_9>
      28:	94 c2       	rjmp	.+1320   	; 0x552 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	0c 94 89 3a 	jmp	0x7512	; 0x7512 <__vector_11>
      30:	0c 94 c5 30 	jmp	0x618a	; 0x618a <__vector_12>
      34:	8e c2       	rjmp	.+1308   	; 0x552 <__bad_interrupt>
      36:	00 00       	nop
      38:	8c c2       	rjmp	.+1304   	; 0x552 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	8a c2       	rjmp	.+1300   	; 0x552 <__bad_interrupt>
      3e:	00 00       	nop
      40:	88 c2       	rjmp	.+1296   	; 0x552 <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 85 19 	jmp	0x330a	; 0x330a <__vector_17>
      48:	84 c2       	rjmp	.+1288   	; 0x552 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	82 c2       	rjmp	.+1284   	; 0x552 <__bad_interrupt>
      4e:	00 00       	nop
      50:	80 c2       	rjmp	.+1280   	; 0x552 <__bad_interrupt>
      52:	00 00       	nop
      54:	7e c2       	rjmp	.+1276   	; 0x552 <__bad_interrupt>
      56:	00 00       	nop
      58:	7c c2       	rjmp	.+1272   	; 0x552 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0c 94 83 1b 	jmp	0x3706	; 0x3706 <__vector_23>
      60:	78 c2       	rjmp	.+1264   	; 0x552 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 6f 14 	jmp	0x28de	; 0x28de <__vector_25>
      68:	0c 94 33 14 	jmp	0x2866	; 0x2866 <__vector_26>
      6c:	72 c2       	rjmp	.+1252   	; 0x552 <__bad_interrupt>
      6e:	00 00       	nop
      70:	70 c2       	rjmp	.+1248   	; 0x552 <__bad_interrupt>
      72:	00 00       	nop
      74:	6e c2       	rjmp	.+1244   	; 0x552 <__bad_interrupt>
      76:	00 00       	nop
      78:	6c c2       	rjmp	.+1240   	; 0x552 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	6a c2       	rjmp	.+1236   	; 0x552 <__bad_interrupt>
      7e:	00 00       	nop
      80:	68 c2       	rjmp	.+1232   	; 0x552 <__bad_interrupt>
      82:	00 00       	nop
      84:	66 c2       	rjmp	.+1228   	; 0x552 <__bad_interrupt>
      86:	00 00       	nop
      88:	64 c2       	rjmp	.+1224   	; 0x552 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	0c 94 3d 3e 	jmp	0x7c7a	; 0x7c7a <__vector_35>
      90:	60 c2       	rjmp	.+1216   	; 0x552 <__bad_interrupt>
      92:	00 00       	nop
      94:	5e c2       	rjmp	.+1212   	; 0x552 <__bad_interrupt>
      96:	00 00       	nop
      98:	5c c2       	rjmp	.+1208   	; 0x552 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	5a c2       	rjmp	.+1204   	; 0x552 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	58 c2       	rjmp	.+1200   	; 0x552 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	56 c2       	rjmp	.+1196   	; 0x552 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	54 c2       	rjmp	.+1192   	; 0x552 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	52 c2       	rjmp	.+1188   	; 0x552 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	50 c2       	rjmp	.+1184   	; 0x552 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	4e c2       	rjmp	.+1180   	; 0x552 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	4c c2       	rjmp	.+1176   	; 0x552 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	4a c2       	rjmp	.+1172   	; 0x552 <__bad_interrupt>
      be:	00 00       	nop
      c0:	48 c2       	rjmp	.+1168   	; 0x552 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	46 c2       	rjmp	.+1164   	; 0x552 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	45 c2       	rjmp	.+1162   	; 0x554 <__vector_50>
      ca:	00 00       	nop
      cc:	42 c2       	rjmp	.+1156   	; 0x552 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	40 c2       	rjmp	.+1152   	; 0x552 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	3e c2       	rjmp	.+1148   	; 0x552 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	3c c2       	rjmp	.+1144   	; 0x552 <__bad_interrupt>
      da:	00 00       	nop
      dc:	3a c2       	rjmp	.+1140   	; 0x552 <__bad_interrupt>
      de:	00 00       	nop
      e0:	38 c2       	rjmp	.+1136   	; 0x552 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	25 08       	sbc	r2, r5
      e6:	25 08       	sbc	r2, r5
      e8:	25 08       	sbc	r2, r5
      ea:	25 08       	sbc	r2, r5
      ec:	06 08       	sbc	r0, r6
      ee:	9d 11       	cpse	r25, r13
      f0:	9d 11       	cpse	r25, r13
      f2:	9d 11       	cpse	r25, r13
      f4:	9d 11       	cpse	r25, r13
      f6:	9d 11       	cpse	r25, r13
      f8:	fa 07       	cpc	r31, r26
      fa:	9d 11       	cpse	r25, r13
      fc:	9d 11       	cpse	r25, r13
      fe:	9d 11       	cpse	r25, r13
     100:	9d 11       	cpse	r25, r13
     102:	9d 11       	cpse	r25, r13
     104:	9d 11       	cpse	r25, r13
     106:	4f 08       	sbc	r4, r15
     108:	4f 08       	sbc	r4, r15
     10a:	4f 08       	sbc	r4, r15
     10c:	70 08       	sbc	r7, r0
     10e:	70 08       	sbc	r7, r0
     110:	9d 11       	cpse	r25, r13
     112:	9d 11       	cpse	r25, r13
     114:	9d 11       	cpse	r25, r13
     116:	9d 11       	cpse	r25, r13
     118:	9d 11       	cpse	r25, r13
     11a:	9d 11       	cpse	r25, r13
     11c:	fa 07       	cpc	r31, r26
     11e:	9d 11       	cpse	r25, r13
     120:	fa 07       	cpc	r31, r26
     122:	9d 11       	cpse	r25, r13
     124:	9d 11       	cpse	r25, r13
     126:	9d 11       	cpse	r25, r13
     128:	9d 11       	cpse	r25, r13
     12a:	9d 11       	cpse	r25, r13
     12c:	9d 11       	cpse	r25, r13
     12e:	9d 11       	cpse	r25, r13
     130:	25 08       	sbc	r2, r5
     132:	9d 11       	cpse	r25, r13
     134:	9b 08       	sbc	r9, r11
     136:	9d 11       	cpse	r25, r13
     138:	9d 11       	cpse	r25, r13
     13a:	76 08       	sbc	r7, r6
     13c:	9d 11       	cpse	r25, r13
     13e:	9d 11       	cpse	r25, r13
     140:	9d 11       	cpse	r25, r13
     142:	9d 11       	cpse	r25, r13
     144:	9d 11       	cpse	r25, r13
     146:	76 08       	sbc	r7, r6
     148:	9d 11       	cpse	r25, r13
     14a:	9d 11       	cpse	r25, r13
     14c:	9d 11       	cpse	r25, r13
     14e:	06 08       	sbc	r0, r6
     150:	8f 08       	sbc	r8, r15
     152:	8f 08       	sbc	r8, r15
     154:	8f 08       	sbc	r8, r15
     156:	8f 08       	sbc	r8, r15
     158:	8f 08       	sbc	r8, r15
     15a:	8f 08       	sbc	r8, r15
     15c:	9d 11       	cpse	r25, r13
     15e:	95 08       	sbc	r9, r5
     160:	9d 11       	cpse	r25, r13
     162:	9d 11       	cpse	r25, r13
     164:	9d 11       	cpse	r25, r13
     166:	9d 11       	cpse	r25, r13
     168:	9d 11       	cpse	r25, r13
     16a:	9d 11       	cpse	r25, r13
     16c:	9d 11       	cpse	r25, r13
     16e:	9d 11       	cpse	r25, r13
     170:	9d 11       	cpse	r25, r13
     172:	9d 11       	cpse	r25, r13
     174:	9d 11       	cpse	r25, r13
     176:	9d 11       	cpse	r25, r13
     178:	9d 11       	cpse	r25, r13
     17a:	9d 11       	cpse	r25, r13
     17c:	9d 11       	cpse	r25, r13
     17e:	9d 11       	cpse	r25, r13
     180:	9d 11       	cpse	r25, r13
     182:	9d 11       	cpse	r25, r13
     184:	2b 08       	sbc	r2, r11
     186:	9d 11       	cpse	r25, r13
     188:	9d 11       	cpse	r25, r13
     18a:	9d 11       	cpse	r25, r13
     18c:	9d 11       	cpse	r25, r13
     18e:	9d 11       	cpse	r25, r13
     190:	9d 11       	cpse	r25, r13
     192:	9d 11       	cpse	r25, r13
     194:	9d 11       	cpse	r25, r13
     196:	9d 11       	cpse	r25, r13
     198:	55 08       	sbc	r5, r5
     19a:	55 08       	sbc	r5, r5
     19c:	fa 07       	cpc	r31, r26
     19e:	6a 08       	sbc	r6, r10
     1a0:	6a 08       	sbc	r6, r10
     1a2:	c6 08       	sbc	r12, r6
     1a4:	c6 08       	sbc	r12, r6
     1a6:	c6 08       	sbc	r12, r6
     1a8:	d5 08       	sbc	r13, r5
     1aa:	d5 08       	sbc	r13, r5
     1ac:	d5 08       	sbc	r13, r5
     1ae:	b7 11       	cpse	r27, r7
     1b0:	ec 08       	sbc	r14, r12
     1b2:	ec 08       	sbc	r14, r12
     1b4:	ec 08       	sbc	r14, r12
     1b6:	b7 11       	cpse	r27, r7
     1b8:	b7 11       	cpse	r27, r7
     1ba:	b7 11       	cpse	r27, r7
     1bc:	b7 11       	cpse	r27, r7
     1be:	b7 11       	cpse	r27, r7
     1c0:	b7 11       	cpse	r27, r7
     1c2:	b7 11       	cpse	r27, r7
     1c4:	b7 11       	cpse	r27, r7
     1c6:	b7 11       	cpse	r27, r7
     1c8:	b7 11       	cpse	r27, r7
     1ca:	b7 11       	cpse	r27, r7
     1cc:	b7 11       	cpse	r27, r7
     1ce:	b7 11       	cpse	r27, r7
     1d0:	b7 11       	cpse	r27, r7
     1d2:	b7 11       	cpse	r27, r7
     1d4:	b7 11       	cpse	r27, r7
     1d6:	b7 11       	cpse	r27, r7
     1d8:	b7 11       	cpse	r27, r7
     1da:	b7 11       	cpse	r27, r7
     1dc:	b7 11       	cpse	r27, r7
     1de:	c6 08       	sbc	r12, r6
     1e0:	2c 09       	sbc	r18, r12
     1e2:	bb 11       	cpse	r27, r11
     1e4:	bb 11       	cpse	r27, r11
     1e6:	36 09       	sbc	r19, r6
     1e8:	43 09       	sbc	r20, r3
     1ea:	50 09       	sbc	r21, r0
     1ec:	5d 09       	sbc	r21, r13
     1ee:	bb 11       	cpse	r27, r11
     1f0:	61 09       	sbc	r22, r1
     1f2:	bb 11       	cpse	r27, r11
     1f4:	6f 09       	sbc	r22, r15
     1f6:	bb 11       	cpse	r27, r11
     1f8:	79 09       	sbc	r23, r9
     1fa:	83 09       	sbc	r24, r3
     1fc:	8d 09       	sbc	r24, r13
     1fe:	bb 11       	cpse	r27, r11
     200:	bb 11       	cpse	r27, r11
     202:	bb 11       	cpse	r27, r11
     204:	9d 09       	sbc	r25, r13
     206:	aa 09       	sbc	r26, r10
     208:	b7 09       	sbc	r27, r7
     20a:	b0 14       	cp	r11, r0
     20c:	b4 14       	cp	r11, r4
     20e:	bc 14       	cp	r11, r12
     210:	13 15       	cp	r17, r3
     212:	13 15       	cp	r17, r3
     214:	13 15       	cp	r17, r3
     216:	13 15       	cp	r17, r3
     218:	13 15       	cp	r17, r3
     21a:	13 15       	cp	r17, r3
     21c:	13 15       	cp	r17, r3
     21e:	13 15       	cp	r17, r3
     220:	13 15       	cp	r17, r3
     222:	c5 14       	cp	r12, r5
     224:	c9 14       	cp	r12, r9
     226:	cd 14       	cp	r12, r13
     228:	d1 14       	cp	r13, r1
     22a:	d5 14       	cp	r13, r5
     22c:	d9 14       	cp	r13, r9
     22e:	dd 14       	cp	r13, r13
     230:	e1 14       	cp	r14, r1
     232:	13 15       	cp	r17, r3
     234:	e5 14       	cp	r14, r5
     236:	e9 14       	cp	r14, r9
     238:	ed 14       	cp	r14, r13
     23a:	f1 14       	cp	r15, r1
     23c:	f5 14       	cp	r15, r5
     23e:	f9 14       	cp	r15, r9
     240:	13 15       	cp	r17, r3
     242:	fd 14       	cp	r15, r13
     244:	01 15       	cp	r16, r1
     246:	89 26       	eor	r8, r25
     248:	8f 26       	eor	r8, r31
     24a:	92 26       	eor	r9, r18
     24c:	97 26       	eor	r9, r23
     24e:	9c 26       	eor	r9, r28
     250:	aa 26       	eor	r10, r26
     252:	b8 26       	eor	r11, r24
     254:	6b 27       	eor	r22, r27
     256:	6b 27       	eor	r22, r27
     258:	6b 27       	eor	r22, r27
     25a:	c9 26       	eor	r12, r25
     25c:	cc 26       	eor	r12, r28
     25e:	d5 26       	eor	r13, r21
     260:	de 26       	eor	r13, r30
     262:	6b 27       	eor	r22, r27
     264:	6b 27       	eor	r22, r27
     266:	6b 27       	eor	r22, r27
     268:	6b 27       	eor	r22, r27
     26a:	6b 27       	eor	r22, r27
     26c:	6b 27       	eor	r22, r27
     26e:	ee 26       	eor	r14, r30
     270:	fe 26       	eor	r15, r30
     272:	0e 27       	eor	r16, r30
     274:	1c 27       	eor	r17, r28
     276:	1f 27       	eor	r17, r31
     278:	28 27       	eor	r18, r24
     27a:	31 27       	eor	r19, r17
     27c:	38 27       	eor	r19, r24
     27e:	6b 27       	eor	r22, r27
     280:	6b 27       	eor	r22, r27
     282:	41 27       	eor	r20, r17
     284:	4c 27       	eor	r20, r28
     286:	57 27       	eor	r21, r23
     288:	b0 35       	cpi	r27, 0x50	; 80
     28a:	b4 35       	cpi	r27, 0x54	; 84
     28c:	b8 35       	cpi	r27, 0x58	; 88
     28e:	bc 35       	cpi	r27, 0x5C	; 92
     290:	c0 35       	cpi	r28, 0x50	; 80
     292:	c4 35       	cpi	r28, 0x54	; 84
     294:	c8 35       	cpi	r28, 0x58	; 88
     296:	cc 35       	cpi	r28, 0x5C	; 92
     298:	d0 35       	cpi	r29, 0x50	; 80
     29a:	d4 35       	cpi	r29, 0x54	; 84
     29c:	d8 35       	cpi	r29, 0x58	; 88
     29e:	08 4a       	sbci	r16, 0xA8	; 168
     2a0:	d7 3b       	cpi	r29, 0xB7	; 183
     2a2:	3b ce       	rjmp	.-906    	; 0xffffff1a <__eeprom_end+0xff7eff1a>
     2a4:	01 6e       	ori	r16, 0xE1	; 225
     2a6:	84 bc       	out	0x24, r8	; 36
     2a8:	bf fd       	.word	0xfdbf	; ????
     2aa:	c1 2f       	mov	r28, r17
     2ac:	3d 6c       	ori	r19, 0xCD	; 205
     2ae:	74 31       	cpi	r23, 0x14	; 20
     2b0:	9a bd       	out	0x2a, r25	; 42
     2b2:	56 83       	std	Z+6, r21	; 0x06
     2b4:	3d da       	rcall	.-2950   	; 0xfffff730 <__eeprom_end+0xff7ef730>
     2b6:	3d 00       	.word	0x003d	; ????
     2b8:	c7 7f       	andi	r28, 0xF7	; 247
     2ba:	11 be       	out	0x31, r1	; 49
     2bc:	d9 e4       	ldi	r29, 0x49	; 73
     2be:	bb 4c       	sbci	r27, 0xCB	; 203
     2c0:	3e 91       	ld	r19, -X
     2c2:	6b aa       	std	Y+51, r6	; 0x33
     2c4:	aa be       	out	0x3a, r10	; 58
     2c6:	00 00       	nop
     2c8:	00 80       	ld	r0, Z
     2ca:	3f 05       	cpc	r19, r15
     2cc:	a8 4c       	sbci	r26, 0xC8	; 200
     2ce:	cd b2       	in	r12, 0x1d	; 29
     2d0:	d4 4e       	sbci	r29, 0xE4	; 228
     2d2:	b9 38       	cpi	r27, 0x89	; 137
     2d4:	36 a9       	ldd	r19, Z+54	; 0x36
     2d6:	02 0c       	add	r0, r2
     2d8:	50 b9       	out	0x00, r21	; 0
     2da:	91 86       	std	Z+9, r9	; 0x09
     2dc:	88 08       	sbc	r8, r8
     2de:	3c a6       	std	Y+44, r3	; 0x2c
     2e0:	aa aa       	std	Y+50, r10	; 0x32
     2e2:	2a be       	out	0x3a, r2	; 58
     2e4:	00 00       	nop
     2e6:	00 80       	ld	r0, Z
     2e8:	3f 00       	.word	0x003f	; ????

000002ea <__trampolines_end>:
     2ea:	00 00       	nop
     2ec:	7a 43       	sbci	r23, 0x3A	; 58
     2ee:	00 00       	nop
     2f0:	7a 43       	sbci	r23, 0x3A	; 58
     2f2:	00 00       	nop
     2f4:	7a 43       	sbci	r23, 0x3A	; 58
     2f6:	00 00       	nop
     2f8:	fa 43       	sbci	r31, 0x3A	; 58
     2fa:	00 00       	nop
     2fc:	fa 43       	sbci	r31, 0x3A	; 58
     2fe:	00 00       	nop
     300:	fa 43       	sbci	r31, 0x3A	; 58
     302:	00 a0       	ldd	r0, Z+32	; 0x20
     304:	0c 47       	sbci	r16, 0x7C	; 124
     306:	00 a0       	ldd	r0, Z+32	; 0x20
     308:	0c 47       	sbci	r16, 0x7C	; 124
     30a:	00 a0       	ldd	r0, Z+32	; 0x20
     30c:	0c 47       	sbci	r16, 0x7C	; 124
     30e:	00 00       	nop
     310:	48 c3       	rjmp	.+1680   	; 0x9a2 <mc_arc+0x26a>
     312:	00 00       	nop
     314:	48 c3       	rjmp	.+1680   	; 0x9a6 <mc_arc+0x26e>
     316:	00 00       	nop
     318:	48 c3       	rjmp	.+1680   	; 0x9aa <mc_arc+0x272>
     31a:	0a 00       	.word	0x000a	; ????
     31c:	00 19       	sub	r16, r0
     31e:	01 0a       	sbc	r0, r17
     320:	d7 23       	and	r29, r23
     322:	3c 6f       	ori	r19, 0xFC	; 252
     324:	12 03       	mulsu	r17, r18
     326:	3b 00       	.word	0x003b	; ????
     328:	00 7a       	andi	r16, 0xA0	; 160
     32a:	44 00       	.word	0x0044	; ????
     32c:	00 00       	nop
     32e:	00 00       	nop
     330:	00 00       	nop
     332:	00 c8       	rjmp	.-4096   	; 0xfffff334 <__eeprom_end+0xff7ef334>
     334:	41 00       	.word	0x0041	; ????
     336:	00 fa       	bst	r0, 0
     338:	43 fa       	bst	r4, 3
     33a:	00 00       	nop
     33c:	00 80       	ld	r0, Z
     33e:	3f 7c       	Address 0x0000033e is out of bounds.
.word	0xffff	; ????

0000033f <__c.2805>:
     33f:	7c 53 69 3a 00                                      |Si:.

00000344 <__c.2803>:
     344:	7c 53 70 3a 00                                      |Sp:.

00000349 <__c.2801>:
     349:	7c 41 3a 00                                         |A:.

0000034d <__c.2797>:
     34d:	7c 4f 76 3a 00                                      |Ov:.

00000352 <__c.2795>:
     352:	7c 57 43 4f 3a 00                                   |WCO:.

00000358 <__c.2793>:
     358:	7c 50 6e 3a 00                                      |Pn:.

0000035d <__c.2788>:
     35d:	7c 46 53 3a 00                                      |FS:.

00000362 <__c.2786>:
     362:	7c 4c 6e 3a 00                                      |Ln:.

00000367 <__c.2782>:
     367:	7c 42 66 3a 00                                      |Bf:.

0000036c <__c.2780>:
     36c:	7c 57 50 6f 73 3a 00                                |WPos:.

00000373 <__c.2778>:
     373:	7c 4d 50 6f 73 3a 00                                |MPos:.

0000037a <__c.2772>:
     37a:	53 6c 65 65 70 00                                   Sleep.

00000380 <__c.2769>:
     380:	44 6f 6f 72 3a 00                                   Door:.

00000386 <__c.2766>:
     386:	43 68 65 63 6b 00                                   Check.

0000038c <__c.2763>:
     38c:	41 6c 61 72 6d 00                                   Alarm.

00000392 <__c.2760>:
     392:	48 6f 6d 65 00                                      Home.

00000397 <__c.2757>:
     397:	4a 6f 67 00                                         Jog.

0000039b <__c.2754>:
     39b:	48 6f 6c 64 3a 00                                   Hold:.

000003a1 <__c.2751>:
     3a1:	52 75 6e 00                                         Run.

000003a5 <__c.2747>:
     3a5:	49 64 6c 65 00                                      Idle.

000003aa <__c.2734>:
     3aa:	5b 4f 50 54 3a 00                                   [OPT:.

000003b0 <__c.2732>:
     3b0:	5b 56 45 52 3a 31 2e 31 67 2e 32 30 31 38 30 38     [VER:1.1g.201808
     3c0:	31 33 2e 4d 65 67 61 3a 00                          13.Mega:.

000003c9 <__c.2723>:
     3c9:	24 4e 00                                            $N.

000003cc <__c.2569>:
     3cc:	20 4d 00                                             M.

000003cf <__c.2565>:
     3cf:	20 47 00                                             G.

000003d2 <__c.2717>:
     3d2:	20 53 00                                             S.

000003d5 <__c.2715>:
     3d5:	20 46 00                                             F.

000003d8 <__c.2713>:
     3d8:	20 54 00                                             T.

000003db <__c.2703>:
     3db:	33 38 2e 00                                         38..

000003df <__c.2701>:
     3df:	5b 47 43 3a 47 00                                   [GC:G.

000003e5 <__c.2697>:
     3e5:	5b 54 4c 4f 3a 00                                   [TLO:.

000003eb <__c.2695>:
     3eb:	5b 47 39 32 3a 00                                   [G92:.

000003f1 <__c.2689>:
     3f1:	33 30 00                                            30.

000003f4 <__c.2685>:
     3f4:	32 38 00                                            28.

000003f7 <__c.2682>:
     3f7:	5b 47 00                                            [G.

000003fa <__c.2675>:
     3fa:	5b 50 52 42 3a 00                                   [PRB:.

00000400 <__c.2655>:
     400:	5b 48 4c 50 3a 24 24 20 24 23 20 24 47 20 24 49     [HLP:$$ $# $G $I
     410:	20 24 4e 20 24 78 3d 76 61 6c 20 24 4e 78 3d 6c      $N $x=val $Nx=l
     420:	69 6e 65 20 24 4a 3d 6c 69 6e 65 20 24 53 4c 50     ine $J=line $SLP
     430:	20 24 43 20 24 58 20 24 48 20 7e 20 21 20 3f 20      $C $X $H ~ ! ? 
     440:	63 74 72 6c 2d 78 5d 0d 0a 00                       ctrl-x]...

0000044a <__c.2651>:
     44a:	0d 0a 47 72 62 6c 20 31 2e 31 67 20 5b 27 24 27     ..Grbl 1.1g ['$'
     45a:	20 66 6f 72 20 68 65 6c 70 5d 0d 0a 00               for help]...

00000467 <__c.2647>:
     467:	53 6c 65 65 70 69 6e 67 00                          Sleeping.

00000470 <__c.2644>:
     470:	52 65 73 74 6f 72 69 6e 67 20 73 70 69 6e 64 6c     Restoring spindl
     480:	65 00                                               e.

00000482 <__c.2641>:
     482:	52 65 73 74 6f 72 69 6e 67 20 64 65 66 61 75 6c     Restoring defaul
     492:	74 73 00                                            ts.

00000495 <__c.2638>:
     495:	50 67 6d 20 45 6e 64 00                             Pgm End.

0000049d <__c.2635>:
     49d:	43 68 65 63 6b 20 4c 69 6d 69 74 73 00              Check Limits.

000004aa <__c.2632>:
     4aa:	43 68 65 63 6b 20 44 6f 6f 72 00                    Check Door.

000004b5 <__c.2629>:
     4b5:	44 69 73 61 62 6c 65 64 00                          Disabled.

000004be <__c.2626>:
     4be:	45 6e 61 62 6c 65 64 00                             Enabled.

000004c6 <__c.2623>:
     4c6:	43 61 75 74 69 6f 6e 3a 20 55 6e 6c 6f 63 6b 65     Caution: Unlocke
     4d6:	64 00                                               d.

000004d8 <__c.2620>:
     4d8:	27 24 48 27 7c 27 24 58 27 20 74 6f 20 75 6e 6c     '$H'|'$X' to unl
     4e8:	6f 63 6b 00                                         ock.

000004ec <__c.2616>:
     4ec:	52 65 73 65 74 20 74 6f 20 63 6f 6e 74 69 6e 75     Reset to continu
     4fc:	65 00                                               e.

000004fe <__c.2613>:
     4fe:	5b 4d 53 47 3a 00                                   [MSG:.

00000504 <__c.2608>:
     504:	7c 53 70 3a 20 00                                   |Sp: .

0000050a <__c.2606>:
     50a:	7c 53 73 3a 20 00                                   |Ss: .

00000510 <__c.2604>:
     510:	53 69 3a 20 00                                      Si: .

00000515 <__c.2600>:
     515:	41 4c 41 52 4d 3a 00                                ALARM:.

0000051c <__c.2559>:
     51c:	0d 0a 00                                            ...

0000051f <__c.2595>:
     51f:	65 72 72 6f 72 3a 00                                error:.

00000526 <__c.2591>:
     526:	6f 6b 0d 0a 00 00                                   ok....

0000052c <__ctors_end>:
     52c:	11 24       	eor	r1, r1
     52e:	1f be       	out	0x3f, r1	; 63
     530:	cf ef       	ldi	r28, 0xFF	; 255
     532:	d1 e2       	ldi	r29, 0x21	; 33
     534:	de bf       	out	0x3e, r29	; 62
     536:	cd bf       	out	0x3d, r28	; 61
     538:	00 e0       	ldi	r16, 0x00	; 0
     53a:	0c bf       	out	0x3c, r16	; 60

0000053c <__do_clear_bss>:
     53c:	2f e0       	ldi	r18, 0x0F	; 15
     53e:	a0 e0       	ldi	r26, 0x00	; 0
     540:	b2 e0       	ldi	r27, 0x02	; 2
     542:	01 c0       	rjmp	.+2      	; 0x546 <.do_clear_bss_start>

00000544 <.do_clear_bss_loop>:
     544:	1d 92       	st	X+, r1

00000546 <.do_clear_bss_start>:
     546:	a7 32       	cpi	r26, 0x27	; 39
     548:	b2 07       	cpc	r27, r18
     54a:	e1 f7       	brne	.-8      	; 0x544 <.do_clear_bss_loop>
     54c:	57 d0       	rcall	.+174    	; 0x5fc <main>
     54e:	0c 94 da 42 	jmp	0x85b4	; 0x85b4 <_exit>

00000552 <__bad_interrupt>:
     552:	56 cd       	rjmp	.-1364   	; 0x0 <__vectors>

00000554 <__vector_50>:
#include "timekeeper.h"

uint32_t overflows;

// overflow interrupt for timekeeper - counts timer ticks beyond 16 bits
ISR(TIMER5_OVF_vect) {
     554:	1f 92       	push	r1
     556:	0f 92       	push	r0
     558:	0f b6       	in	r0, 0x3f	; 63
     55a:	0f 92       	push	r0
     55c:	11 24       	eor	r1, r1
     55e:	8f 93       	push	r24
     560:	9f 93       	push	r25
     562:	af 93       	push	r26
     564:	bf 93       	push	r27
	overflows++;
     566:	80 91 10 0c 	lds	r24, 0x0C10	; 0x800c10 <overflows>
     56a:	90 91 11 0c 	lds	r25, 0x0C11	; 0x800c11 <overflows+0x1>
     56e:	a0 91 12 0c 	lds	r26, 0x0C12	; 0x800c12 <overflows+0x2>
     572:	b0 91 13 0c 	lds	r27, 0x0C13	; 0x800c13 <overflows+0x3>
     576:	01 96       	adiw	r24, 0x01	; 1
     578:	a1 1d       	adc	r26, r1
     57a:	b1 1d       	adc	r27, r1
     57c:	80 93 10 0c 	sts	0x0C10, r24	; 0x800c10 <overflows>
     580:	90 93 11 0c 	sts	0x0C11, r25	; 0x800c11 <overflows+0x1>
     584:	a0 93 12 0c 	sts	0x0C12, r26	; 0x800c12 <overflows+0x2>
     588:	b0 93 13 0c 	sts	0x0C13, r27	; 0x800c13 <overflows+0x3>
}
     58c:	bf 91       	pop	r27
     58e:	af 91       	pop	r26
     590:	9f 91       	pop	r25
     592:	8f 91       	pop	r24
     594:	0f 90       	pop	r0
     596:	0f be       	out	0x3f, r0	; 63
     598:	0f 90       	pop	r0
     59a:	1f 90       	pop	r1
     59c:	18 95       	reti

0000059e <timekeeper_init>:

void timekeeper_init() {
  // Configure Timer 5: system timer interrupt
  //TCCR5B &= ~(1<<WGM13); // waveform generation = 0100 = CTC
  //TCCR5B |=  (1<<WGM12);
  TCCR5A =0; // timer outputs disconnected, no waveform generation.
     59e:	e0 e2       	ldi	r30, 0x20	; 32
     5a0:	f1 e0       	ldi	r31, 0x01	; 1
     5a2:	10 82       	st	Z, r1
  TCCR5A &= ~((1<<COM5A1) | (1<<COM5A0) | (1<<COM5B1) | (1<<COM5B0)); // Disconnect OC1 output
     5a4:	80 81       	ld	r24, Z
     5a6:	8f 70       	andi	r24, 0x0F	; 15
     5a8:	80 83       	st	Z, r24
  TCCR5B |=  (1<<CS11) | (1<<CS10); // pre-scaler: 1/64 (4 microseconds per tick @ 16MHz)
     5aa:	e1 e2       	ldi	r30, 0x21	; 33
     5ac:	f1 e0       	ldi	r31, 0x01	; 1
     5ae:	80 81       	ld	r24, Z
     5b0:	83 60       	ori	r24, 0x03	; 3
     5b2:	80 83       	st	Z, r24
  TIMSK5 |=  (1<<TOIE5); // enable overflow interrupt  
     5b4:	e3 e7       	ldi	r30, 0x73	; 115
     5b6:	f0 e0       	ldi	r31, 0x00	; 0
     5b8:	80 81       	ld	r24, Z
     5ba:	81 60       	ori	r24, 0x01	; 1
     5bc:	80 83       	st	Z, r24
  overflows = 0;
     5be:	10 92 10 0c 	sts	0x0C10, r1	; 0x800c10 <overflows>
     5c2:	10 92 11 0c 	sts	0x0C11, r1	; 0x800c11 <overflows+0x1>
     5c6:	10 92 12 0c 	sts	0x0C12, r1	; 0x800c12 <overflows+0x2>
     5ca:	10 92 13 0c 	sts	0x0C13, r1	; 0x800c13 <overflows+0x3>
     5ce:	08 95       	ret

000005d0 <get_timer_ticks>:
	// each timer tick are 4 microseconds
	return (get_timer_ticks()/(uint32_t)250);
}

uint32_t get_timer_ticks(){
	uint32_t ticks = TCNT5;
     5d0:	20 91 24 01 	lds	r18, 0x0124	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
     5d4:	30 91 25 01 	lds	r19, 0x0125	; 0x800125 <__TEXT_REGION_LENGTH__+0x700125>
	return ticks+((overflows)<<16) ;
     5d8:	80 91 10 0c 	lds	r24, 0x0C10	; 0x800c10 <overflows>
     5dc:	90 91 11 0c 	lds	r25, 0x0C11	; 0x800c11 <overflows+0x1>
     5e0:	a0 91 12 0c 	lds	r26, 0x0C12	; 0x800c12 <overflows+0x2>
     5e4:	b0 91 13 0c 	lds	r27, 0x0C13	; 0x800c13 <overflows+0x3>
     5e8:	dc 01       	movw	r26, r24
     5ea:	99 27       	eor	r25, r25
     5ec:	88 27       	eor	r24, r24
     5ee:	bc 01       	movw	r22, r24
     5f0:	cd 01       	movw	r24, r26
     5f2:	62 0f       	add	r22, r18
     5f4:	73 1f       	adc	r23, r19
     5f6:	81 1d       	adc	r24, r1
     5f8:	91 1d       	adc	r25, r1
}
     5fa:	08 95       	ret

000005fc <main>:


int main(void)
{
  // Initialize system upon power-up.
  serial_init();   // Setup serial baud rate and interrupts
     5fc:	0e 94 0a 14 	call	0x2814	; 0x2814 <serial_init>
  settings_init(); // Load Grbl settings from EEPROM
     600:	0e 94 c6 27 	call	0x4f8c	; 0x4f8c <settings_init>
  stepper_init();  // Configure stepper pins and interrupt timers
     604:	0e 94 0a 1c 	call	0x3814	; 0x3814 <stepper_init>
  system_init();   // Configure pinout pins and pin-change interrupt
     608:	0e 94 5e 3a 	call	0x74bc	; 0x74bc <system_init>

  memset(sys_position,0,sizeof(sys_position)); // Clear machine position.
     60c:	8c e0       	ldi	r24, 0x0C	; 12
     60e:	e3 e4       	ldi	r30, 0x43	; 67
     610:	fc e0       	ldi	r31, 0x0C	; 12
     612:	df 01       	movw	r26, r30
     614:	1d 92       	st	X+, r1
     616:	8a 95       	dec	r24
     618:	e9 f7       	brne	.-6      	; 0x614 <main+0x18>
  sei(); // Enable interrupts
     61a:	78 94       	sei
  // Initialize system state.
  #ifdef FORCE_INITIALIZATION_ALARM
    // Force Grbl into an ALARM state upon a power-cycle or hard reset.
    sys.state = STATE_ALARM;
  #else
    sys.state = STATE_IDLE;
     61c:	10 92 1e 0c 	sts	0x0C1E, r1	; 0x800c1e <sys>
  // Grbl initialization loop upon power-up or a system abort. For the latter, all processes
  // will return to this loop to be cleanly re-initialized.
  for(;;) {

    // Reset system variables.
    uint8_t prior_state = sys.state;
     620:	ce e1       	ldi	r28, 0x1E	; 30
     622:	dc e0       	ldi	r29, 0x0C	; 12
    memset(&sys, 0, sizeof(system_t)); // Clear system struct variable.
     624:	0f 2e       	mov	r0, r31
     626:	f2 e1       	ldi	r31, 0x12	; 18
     628:	df 2e       	mov	r13, r31
     62a:	f0 2d       	mov	r31, r0
    sys.state = prior_state;
    sys.f_override = DEFAULT_FEED_OVERRIDE;  // Set to 100%
     62c:	14 e6       	ldi	r17, 0x64	; 100
    sys.r_override = DEFAULT_RAPID_OVERRIDE; // Set to 100%
    sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE; // Set to 100%
		memset(sys_probe_position,0,sizeof(sys_probe_position)); // Clear probe position.
     62e:	0f 2e       	mov	r0, r31
     630:	f7 e3       	ldi	r31, 0x37	; 55
     632:	ef 2e       	mov	r14, r31
     634:	fc e0       	ldi	r31, 0x0C	; 12
     636:	ff 2e       	mov	r15, r31
     638:	f0 2d       	mov	r31, r0
     63a:	0c e0       	ldi	r16, 0x0C	; 12
  // Grbl initialization loop upon power-up or a system abort. For the latter, all processes
  // will return to this loop to be cleanly re-initialized.
  for(;;) {

    // Reset system variables.
    uint8_t prior_state = sys.state;
     63c:	88 81       	ld	r24, Y
    memset(&sys, 0, sizeof(system_t)); // Clear system struct variable.
     63e:	fe 01       	movw	r30, r28
     640:	9d 2d       	mov	r25, r13
     642:	11 92       	st	Z+, r1
     644:	9a 95       	dec	r25
     646:	e9 f7       	brne	.-6      	; 0x642 <main+0x46>
    sys.state = prior_state;
     648:	88 83       	st	Y, r24
    sys.f_override = DEFAULT_FEED_OVERRIDE;  // Set to 100%
     64a:	1f 83       	std	Y+7, r17	; 0x07
    sys.r_override = DEFAULT_RAPID_OVERRIDE; // Set to 100%
     64c:	18 87       	std	Y+8, r17	; 0x08
    sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE; // Set to 100%
     64e:	19 87       	std	Y+9, r17	; 0x09
		memset(sys_probe_position,0,sizeof(sys_probe_position)); // Clear probe position.
     650:	d7 01       	movw	r26, r14
     652:	e0 2f       	mov	r30, r16
     654:	1d 92       	st	X+, r1
     656:	ea 95       	dec	r30
     658:	e9 f7       	brne	.-6      	; 0x654 <main+0x58>
    sys_probe_state = 0;
     65a:	10 92 32 0c 	sts	0x0C32, r1	; 0x800c32 <sys_probe_state>
    sys_rt_exec_state = 0;
     65e:	10 92 31 0c 	sts	0x0C31, r1	; 0x800c31 <sys_rt_exec_state>
    sys_rt_exec_alarm = 0;
     662:	10 92 53 0c 	sts	0x0C53, r1	; 0x800c53 <sys_rt_exec_alarm>
    sys_rt_exec_motion_override = 0;
     666:	10 92 19 0c 	sts	0x0C19, r1	; 0x800c19 <sys_rt_exec_motion_override>
    sys_rt_exec_accessory_override = 0;
     66a:	10 92 30 0c 	sts	0x0C30, r1	; 0x800c30 <sys_rt_exec_accessory_override>
	
	sys_index_pulse_count=0;
     66e:	10 92 55 0c 	sts	0x0C55, r1	; 0x800c55 <sys_index_pulse_count>
	sys_synchronization_pulse_count=0;
     672:	10 92 15 0c 	sts	0x0C15, r1	; 0x800c15 <sys_synchronization_pulse_count>
     676:	10 92 16 0c 	sts	0x0C16, r1	; 0x800c16 <sys_synchronization_pulse_count+0x1>
     67a:	10 92 17 0c 	sts	0x0C17, r1	; 0x800c17 <sys_synchronization_pulse_count+0x2>
     67e:	10 92 18 0c 	sts	0x0C18, r1	; 0x800c18 <sys_synchronization_pulse_count+0x3>

    // Reset Grbl primary systems.
    serial_reset_read_buffer(); // Clear serial read buffer
     682:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <serial_reset_read_buffer>
    gc_init(); // Set g-code parser to default state
     686:	03 d4       	rcall	.+2054   	; 0xe8e <gc_init>
    spindle_init();
     688:	0e 94 85 12 	call	0x250a	; 0x250a <spindle_init>
	timekeeper_init();
     68c:	88 df       	rcall	.-240    	; 0x59e <timekeeper_init>
    coolant_init();
     68e:	0e 94 c7 13 	call	0x278e	; 0x278e <coolant_init>
    limits_init();
     692:	0e 94 44 30 	call	0x6088	; 0x6088 <limits_init>
    probe_init();
     696:	0e 94 ed 34 	call	0x69da	; 0x69da <probe_init>
    sleep_init();
     69a:	0e 94 2b 3e 	call	0x7c56	; 0x7c56 <sleep_init>
    plan_reset(); // Clear block buffer and planner variables
     69e:	0e 94 5f 29 	call	0x52be	; 0x52be <plan_reset>
    st_reset(); // Clear stepper subsystem variables.
     6a2:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <st_reset>

    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
     6a6:	0e 94 07 2e 	call	0x5c0e	; 0x5c0e <plan_sync_position>
    gc_sync_position();
     6aa:	03 d4       	rcall	.+2054   	; 0xeb2 <gc_sync_position>

    // Print welcome message. Indicates an initialization has occured at power-up or with a reset.
    report_init_message();
     6ac:	0e 94 de 35 	call	0x6bbc	; 0x6bbc <report_init_message>

    // Start Grbl main loop. Processes program inputs and executes them.
    protocol_main_loop();
     6b0:	0e 94 79 18 	call	0x30f2	; 0x30f2 <protocol_main_loop>
     6b4:	c3 cf       	rjmp	.-122    	; 0x63c <main+0x40>

000006b6 <mc_line>:
// NOTE: This is the primary gateway to the grbl planner. All line motions, including arc line
// segments, must pass through this routine before being passed to the planner. The seperation of
// mc_line and plan_buffer_line is done primarily to place non-planner-type functions from being
// in the planner and to let backlash compensation or canned cycle integration simple and direct.
void mc_line(float *target, plan_line_data_t *pl_data)
{
     6b6:	ef 92       	push	r14
     6b8:	ff 92       	push	r15
     6ba:	0f 93       	push	r16
     6bc:	1f 93       	push	r17
     6be:	cf 93       	push	r28
     6c0:	df 93       	push	r29
     6c2:	8c 01       	movw	r16, r24
     6c4:	7b 01       	movw	r14, r22
  // If enabled, check for soft limit violations. Placed here all line motions are picked up
  // from everywhere in Grbl.
  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
     6c6:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
     6ca:	85 ff       	sbrs	r24, 5
     6cc:	07 c0       	rjmp	.+14     	; 0x6dc <mc_line+0x26>
    // NOTE: Block jog state. Jogging is a special case and soft limits are handled independently.
    if (sys.state != STATE_JOG) { limits_soft_check(target); }
     6ce:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
     6d2:	80 32       	cpi	r24, 0x20	; 32
     6d4:	39 f0       	breq	.+14     	; 0x6e4 <mc_line+0x2e>
     6d6:	c8 01       	movw	r24, r16
     6d8:	0e 94 18 33 	call	0x6630	; 0x6630 <limits_soft_check>
  }

  // If in check gcode mode, prevent motion by blocking planner. Soft limits still work.
  if (sys.state == STATE_CHECK_MODE) { return; }
     6dc:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
     6e0:	82 30       	cpi	r24, 0x02	; 2
     6e2:	19 f1       	breq	.+70     	; 0x72a <mc_line+0x74>

  // If the buffer is full: good! That means we are well ahead of the robot.
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
    if (sys.abort) { return; } // Bail, if system abort.
     6e4:	ce e1       	ldi	r28, 0x1E	; 30
     6e6:	dc e0       	ldi	r29, 0x0C	; 12
  // parser and planner are separate from the system machine positions, this is doable.

  // If the buffer is full: good! That means we are well ahead of the robot.
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
     6e8:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail, if system abort.
     6ec:	89 81       	ldd	r24, Y+1	; 0x01
     6ee:	81 11       	cpse	r24, r1
     6f0:	1c c0       	rjmp	.+56     	; 0x72a <mc_line+0x74>
    if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffer is full.
     6f2:	0e 94 ae 29 	call	0x535c	; 0x535c <plan_check_full_buffer>
     6f6:	88 23       	and	r24, r24
     6f8:	19 f0       	breq	.+6      	; 0x700 <mc_line+0x4a>
     6fa:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <protocol_auto_cycle_start>
    else { break; }
  } while (1);
     6fe:	f4 cf       	rjmp	.-24     	; 0x6e8 <mc_line+0x32>

  // Plan and queue motion into planner buffer
  if (plan_buffer_line(target, pl_data) == PLAN_EMPTY_BLOCK) {
     700:	b7 01       	movw	r22, r14
     702:	c8 01       	movw	r24, r16
     704:	0e 94 ec 2a 	call	0x55d8	; 0x55d8 <plan_buffer_line>
     708:	81 11       	cpse	r24, r1
     70a:	0f c0       	rjmp	.+30     	; 0x72a <mc_line+0x74>
    if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
     70c:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
     710:	81 ff       	sbrs	r24, 1
     712:	0b c0       	rjmp	.+22     	; 0x72a <mc_line+0x74>
      // Correctly set spindle state, if there is a coincident position passed. Forces a buffer
      // sync while in M3 laser mode only.
      if (pl_data->condition & PL_COND_FLAG_SPINDLE_CW) {
     714:	f7 01       	movw	r30, r14
     716:	84 85       	ldd	r24, Z+12	; 0x0c
     718:	84 ff       	sbrs	r24, 4
     71a:	07 c0       	rjmp	.+14     	; 0x72a <mc_line+0x74>
        spindle_sync(PL_COND_FLAG_SPINDLE_CW, pl_data->spindle_speed);
     71c:	44 81       	ldd	r20, Z+4	; 0x04
     71e:	55 81       	ldd	r21, Z+5	; 0x05
     720:	66 81       	ldd	r22, Z+6	; 0x06
     722:	77 81       	ldd	r23, Z+7	; 0x07
     724:	80 e1       	ldi	r24, 0x10	; 16
     726:	0e 94 9b 13 	call	0x2736	; 0x2736 <spindle_sync>
      }
    }
  }
}
     72a:	df 91       	pop	r29
     72c:	cf 91       	pop	r28
     72e:	1f 91       	pop	r17
     730:	0f 91       	pop	r16
     732:	ff 90       	pop	r15
     734:	ef 90       	pop	r14
     736:	08 95       	ret

00000738 <mc_arc>:
// The arc is approximated by generating a huge number of tiny, linear segments. The chordal tolerance
// of each segment is configured in settings.arc_tolerance, which is defined to be the maximum normal
// distance from segment to the circle when the end points both lie on the circle.
void mc_arc(float *target, plan_line_data_t *pl_data, float *position, float *offset, float radius,
  uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc)
{
     738:	2f 92       	push	r2
     73a:	3f 92       	push	r3
     73c:	4f 92       	push	r4
     73e:	5f 92       	push	r5
     740:	6f 92       	push	r6
     742:	7f 92       	push	r7
     744:	8f 92       	push	r8
     746:	9f 92       	push	r9
     748:	af 92       	push	r10
     74a:	bf 92       	push	r11
     74c:	cf 92       	push	r12
     74e:	df 92       	push	r13
     750:	ef 92       	push	r14
     752:	ff 92       	push	r15
     754:	0f 93       	push	r16
     756:	1f 93       	push	r17
     758:	cf 93       	push	r28
     75a:	df 93       	push	r29
     75c:	cd b7       	in	r28, 0x3d	; 61
     75e:	de b7       	in	r29, 0x3e	; 62
     760:	e2 97       	sbiw	r28, 0x32	; 50
     762:	0f b6       	in	r0, 0x3f	; 63
     764:	f8 94       	cli
     766:	de bf       	out	0x3e, r29	; 62
     768:	0f be       	out	0x3f, r0	; 63
     76a:	cd bf       	out	0x3d, r28	; 61
     76c:	9a ab       	std	Y+50, r25	; 0x32
     76e:	89 ab       	std	Y+49, r24	; 0x31
     770:	78 8b       	std	Y+16, r23	; 0x10
     772:	6f 87       	std	Y+15, r22	; 0x0f
     774:	5e 87       	std	Y+14, r21	; 0x0e
     776:	4d 87       	std	Y+13, r20	; 0x0d
     778:	39 01       	movw	r6, r18
     77a:	ed 82       	std	Y+5, r14	; 0x05
     77c:	fe 82       	std	Y+6, r15	; 0x06
     77e:	0f 83       	std	Y+7, r16	; 0x07
     780:	18 87       	std	Y+8, r17	; 0x08
     782:	89 8a       	std	Y+17, r8	; 0x11
  float center_axis0 = position[axis_0] + offset[axis_0];
     784:	d1 2c       	mov	r13, r1
     786:	cc 0c       	add	r12, r12
     788:	dd 1c       	adc	r13, r13
     78a:	cc 0c       	add	r12, r12
     78c:	dd 1c       	adc	r13, r13
     78e:	ca 01       	movw	r24, r20
     790:	8c 0d       	add	r24, r12
     792:	9d 1d       	adc	r25, r13
     794:	9e 8b       	std	Y+22, r25	; 0x16
     796:	8d 8b       	std	Y+21, r24	; 0x15
     798:	d9 01       	movw	r26, r18
     79a:	ac 0d       	add	r26, r12
     79c:	bd 1d       	adc	r27, r13
     79e:	be a7       	std	Y+46, r27	; 0x2e
     7a0:	ad a7       	std	Y+45, r26	; 0x2d
     7a2:	2d 90       	ld	r2, X+
     7a4:	3d 90       	ld	r3, X+
     7a6:	4d 90       	ld	r4, X+
     7a8:	5c 90       	ld	r5, X
     7aa:	fc 01       	movw	r30, r24
     7ac:	20 81       	ld	r18, Z
     7ae:	31 81       	ldd	r19, Z+1	; 0x01
     7b0:	42 81       	ldd	r20, Z+2	; 0x02
     7b2:	53 81       	ldd	r21, Z+3	; 0x03
     7b4:	c2 01       	movw	r24, r4
     7b6:	b1 01       	movw	r22, r2
     7b8:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
     7bc:	6f 8b       	std	Y+23, r22	; 0x17
     7be:	78 8f       	std	Y+24, r23	; 0x18
     7c0:	89 8f       	std	Y+25, r24	; 0x19
     7c2:	9a 8f       	std	Y+26, r25	; 0x1a
  float center_axis1 = position[axis_1] + offset[axis_1];
     7c4:	0a 2d       	mov	r16, r10
     7c6:	10 e0       	ldi	r17, 0x00	; 0
     7c8:	00 0f       	add	r16, r16
     7ca:	11 1f       	adc	r17, r17
     7cc:	00 0f       	add	r16, r16
     7ce:	11 1f       	adc	r17, r17
     7d0:	8d 85       	ldd	r24, Y+13	; 0x0d
     7d2:	9e 85       	ldd	r25, Y+14	; 0x0e
     7d4:	80 0f       	add	r24, r16
     7d6:	91 1f       	adc	r25, r17
     7d8:	9c 8f       	std	Y+28, r25	; 0x1c
     7da:	8b 8f       	std	Y+27, r24	; 0x1b
     7dc:	d3 01       	movw	r26, r6
     7de:	a0 0f       	add	r26, r16
     7e0:	b1 1f       	adc	r27, r17
     7e2:	b8 ab       	std	Y+48, r27	; 0x30
     7e4:	af a7       	std	Y+47, r26	; 0x2f
     7e6:	8d 90       	ld	r8, X+
     7e8:	9d 90       	ld	r9, X+
     7ea:	ad 90       	ld	r10, X+
     7ec:	bc 90       	ld	r11, X
     7ee:	fc 01       	movw	r30, r24
     7f0:	20 81       	ld	r18, Z
     7f2:	31 81       	ldd	r19, Z+1	; 0x01
     7f4:	42 81       	ldd	r20, Z+2	; 0x02
     7f6:	53 81       	ldd	r21, Z+3	; 0x03
     7f8:	c5 01       	movw	r24, r10
     7fa:	b4 01       	movw	r22, r8
     7fc:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
     800:	6d 8f       	std	Y+29, r22	; 0x1d
     802:	7e 8f       	std	Y+30, r23	; 0x1e
     804:	8f 8f       	std	Y+31, r24	; 0x1f
     806:	98 a3       	std	Y+32, r25	; 0x20
  float r_axis0 = -offset[axis_0];  // Radius vector from center to current location
     808:	d2 01       	movw	r26, r4
     80a:	c1 01       	movw	r24, r2
     80c:	b0 58       	subi	r27, 0x80	; 128
     80e:	89 83       	std	Y+1, r24	; 0x01
     810:	9a 83       	std	Y+2, r25	; 0x02
     812:	ab 83       	std	Y+3, r26	; 0x03
     814:	bc 83       	std	Y+4, r27	; 0x04
  float r_axis1 = -offset[axis_1];
     816:	d5 01       	movw	r26, r10
     818:	c4 01       	movw	r24, r8
     81a:	b0 58       	subi	r27, 0x80	; 128
     81c:	89 87       	std	Y+9, r24	; 0x09
     81e:	9a 87       	std	Y+10, r25	; 0x0a
     820:	ab 87       	std	Y+11, r26	; 0x0b
     822:	bc 87       	std	Y+12, r27	; 0x0c
  float rt_axis0 = target[axis_0] - center_axis0;
     824:	e9 a9       	ldd	r30, Y+49	; 0x31
     826:	fa a9       	ldd	r31, Y+50	; 0x32
     828:	ec 0d       	add	r30, r12
     82a:	fd 1d       	adc	r31, r13
     82c:	2f 89       	ldd	r18, Y+23	; 0x17
     82e:	38 8d       	ldd	r19, Y+24	; 0x18
     830:	49 8d       	ldd	r20, Y+25	; 0x19
     832:	5a 8d       	ldd	r21, Y+26	; 0x1a
     834:	60 81       	ld	r22, Z
     836:	71 81       	ldd	r23, Z+1	; 0x01
     838:	82 81       	ldd	r24, Z+2	; 0x02
     83a:	93 81       	ldd	r25, Z+3	; 0x03
     83c:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
     840:	6b 01       	movw	r12, r22
     842:	7c 01       	movw	r14, r24
  float rt_axis1 = target[axis_1] - center_axis1;
     844:	e9 a9       	ldd	r30, Y+49	; 0x31
     846:	fa a9       	ldd	r31, Y+50	; 0x32
     848:	e0 0f       	add	r30, r16
     84a:	f1 1f       	adc	r31, r17
     84c:	2d 8d       	ldd	r18, Y+29	; 0x1d
     84e:	3e 8d       	ldd	r19, Y+30	; 0x1e
     850:	4f 8d       	ldd	r20, Y+31	; 0x1f
     852:	58 a1       	ldd	r21, Y+32	; 0x20
     854:	60 81       	ld	r22, Z
     856:	71 81       	ldd	r23, Z+1	; 0x01
     858:	82 81       	ldd	r24, Z+2	; 0x02
     85a:	93 81       	ldd	r25, Z+3	; 0x03
     85c:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
     860:	4b 01       	movw	r8, r22
     862:	5c 01       	movw	r10, r24

  // CCW angle between position and target from circle center. Only one atan2() trig computation required.
  float angular_travel = atan2(r_axis0*rt_axis1-r_axis1*rt_axis0, r_axis0*rt_axis0+r_axis1*rt_axis1);
     864:	a7 01       	movw	r20, r14
     866:	96 01       	movw	r18, r12
     868:	69 81       	ldd	r22, Y+1	; 0x01
     86a:	7a 81       	ldd	r23, Y+2	; 0x02
     86c:	8b 81       	ldd	r24, Y+3	; 0x03
     86e:	9c 81       	ldd	r25, Y+4	; 0x04
     870:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     874:	2b 01       	movw	r4, r22
     876:	3c 01       	movw	r6, r24
     878:	a5 01       	movw	r20, r10
     87a:	94 01       	movw	r18, r8
     87c:	69 85       	ldd	r22, Y+9	; 0x09
     87e:	7a 85       	ldd	r23, Y+10	; 0x0a
     880:	8b 85       	ldd	r24, Y+11	; 0x0b
     882:	9c 85       	ldd	r25, Y+12	; 0x0c
     884:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     888:	9b 01       	movw	r18, r22
     88a:	ac 01       	movw	r20, r24
     88c:	c3 01       	movw	r24, r6
     88e:	b2 01       	movw	r22, r4
     890:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
     894:	2b 01       	movw	r4, r22
     896:	3c 01       	movw	r6, r24
     898:	a5 01       	movw	r20, r10
     89a:	94 01       	movw	r18, r8
     89c:	69 81       	ldd	r22, Y+1	; 0x01
     89e:	7a 81       	ldd	r23, Y+2	; 0x02
     8a0:	8b 81       	ldd	r24, Y+3	; 0x03
     8a2:	9c 81       	ldd	r25, Y+4	; 0x04
     8a4:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     8a8:	4b 01       	movw	r8, r22
     8aa:	5c 01       	movw	r10, r24
     8ac:	a7 01       	movw	r20, r14
     8ae:	96 01       	movw	r18, r12
     8b0:	69 85       	ldd	r22, Y+9	; 0x09
     8b2:	7a 85       	ldd	r23, Y+10	; 0x0a
     8b4:	8b 85       	ldd	r24, Y+11	; 0x0b
     8b6:	9c 85       	ldd	r25, Y+12	; 0x0c
     8b8:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     8bc:	9b 01       	movw	r18, r22
     8be:	ac 01       	movw	r20, r24
     8c0:	c5 01       	movw	r24, r10
     8c2:	b4 01       	movw	r22, r8
     8c4:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
     8c8:	a3 01       	movw	r20, r6
     8ca:	92 01       	movw	r18, r4
     8cc:	0e 94 03 3f 	call	0x7e06	; 0x7e06 <atan2>
     8d0:	4b 01       	movw	r8, r22
     8d2:	5c 01       	movw	r10, r24
  if (is_clockwise_arc) { // Correct atan2 output per direction
     8d4:	29 96       	adiw	r28, 0x09	; 9
     8d6:	8f ad       	ldd	r24, Y+63	; 0x3f
     8d8:	29 97       	sbiw	r28, 0x09	; 9
     8da:	88 23       	and	r24, r24
     8dc:	a9 f0       	breq	.+42     	; 0x908 <mc_arc+0x1d0>
    if (angular_travel >= -ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel -= 2*M_PI; }
     8de:	2d eb       	ldi	r18, 0xBD	; 189
     8e0:	37 e3       	ldi	r19, 0x37	; 55
     8e2:	46 e0       	ldi	r20, 0x06	; 6
     8e4:	55 eb       	ldi	r21, 0xB5	; 181
     8e6:	c5 01       	movw	r24, r10
     8e8:	b4 01       	movw	r22, r8
     8ea:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
     8ee:	88 23       	and	r24, r24
     8f0:	fc f0       	brlt	.+62     	; 0x930 <mc_arc+0x1f8>
     8f2:	2b ed       	ldi	r18, 0xDB	; 219
     8f4:	3f e0       	ldi	r19, 0x0F	; 15
     8f6:	49 ec       	ldi	r20, 0xC9	; 201
     8f8:	50 e4       	ldi	r21, 0x40	; 64
     8fa:	c5 01       	movw	r24, r10
     8fc:	b4 01       	movw	r22, r8
     8fe:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
     902:	4b 01       	movw	r8, r22
     904:	5c 01       	movw	r10, r24
     906:	14 c0       	rjmp	.+40     	; 0x930 <mc_arc+0x1f8>
  } else {
    if (angular_travel <= ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel += 2*M_PI; }
     908:	2d eb       	ldi	r18, 0xBD	; 189
     90a:	37 e3       	ldi	r19, 0x37	; 55
     90c:	46 e0       	ldi	r20, 0x06	; 6
     90e:	55 e3       	ldi	r21, 0x35	; 53
     910:	c5 01       	movw	r24, r10
     912:	b4 01       	movw	r22, r8
     914:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
     918:	18 16       	cp	r1, r24
     91a:	54 f0       	brlt	.+20     	; 0x930 <mc_arc+0x1f8>
     91c:	2b ed       	ldi	r18, 0xDB	; 219
     91e:	3f e0       	ldi	r19, 0x0F	; 15
     920:	49 ec       	ldi	r20, 0xC9	; 201
     922:	50 e4       	ldi	r21, 0x40	; 64
     924:	c5 01       	movw	r24, r10
     926:	b4 01       	movw	r22, r8
     928:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
     92c:	4b 01       	movw	r8, r22
     92e:	5c 01       	movw	r10, r24
  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
     930:	c0 90 09 0f 	lds	r12, 0x0F09	; 0x800f09 <settings+0x39>
     934:	d0 90 0a 0f 	lds	r13, 0x0F0A	; 0x800f0a <settings+0x3a>
     938:	e0 90 0b 0f 	lds	r14, 0x0F0B	; 0x800f0b <settings+0x3b>
     93c:	f0 90 0c 0f 	lds	r15, 0x0F0C	; 0x800f0c <settings+0x3c>
     940:	2d 81       	ldd	r18, Y+5	; 0x05
     942:	3e 81       	ldd	r19, Y+6	; 0x06
     944:	4f 81       	ldd	r20, Y+7	; 0x07
     946:	58 85       	ldd	r21, Y+8	; 0x08
     948:	ca 01       	movw	r24, r20
     94a:	b9 01       	movw	r22, r18
     94c:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
     950:	2b 01       	movw	r4, r22
     952:	3c 01       	movw	r6, r24
     954:	a7 01       	movw	r20, r14
     956:	96 01       	movw	r18, r12
     958:	c3 01       	movw	r24, r6
     95a:	b2 01       	movw	r22, r4
     95c:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
     960:	a7 01       	movw	r20, r14
     962:	96 01       	movw	r18, r12
     964:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     968:	0e 94 34 42 	call	0x8468	; 0x8468 <sqrt>
     96c:	6b 01       	movw	r12, r22
     96e:	7c 01       	movw	r14, r24

  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
     970:	20 e0       	ldi	r18, 0x00	; 0
     972:	30 e0       	ldi	r19, 0x00	; 0
     974:	40 e0       	ldi	r20, 0x00	; 0
     976:	5f e3       	ldi	r21, 0x3F	; 63
     978:	c5 01       	movw	r24, r10
     97a:	b4 01       	movw	r22, r8
     97c:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     980:	2d 81       	ldd	r18, Y+5	; 0x05
     982:	3e 81       	ldd	r19, Y+6	; 0x06
     984:	4f 81       	ldd	r20, Y+7	; 0x07
     986:	58 85       	ldd	r21, Y+8	; 0x08
     988:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     98c:	9f 77       	andi	r25, 0x7F	; 127
     98e:	a7 01       	movw	r20, r14
     990:	96 01       	movw	r18, r12
     992:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <__divsf3>
     996:	0e 94 46 40 	call	0x808c	; 0x808c <floor>
     99a:	0e 94 dd 3f 	call	0x7fba	; 0x7fba <__fixunssfsi>
     99e:	6b 01       	movw	r12, r22
     9a0:	7c 01       	movw	r14, r24
     9a2:	3b 01       	movw	r6, r22
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );

  if (segments) {
     9a4:	61 15       	cp	r22, r1
     9a6:	71 05       	cpc	r23, r1
     9a8:	09 f4       	brne	.+2      	; 0x9ac <mc_arc+0x274>
     9aa:	87 c1       	rjmp	.+782    	; 0xcba <mc_arc+0x582>
    // Multiply inverse feed_rate to compensate for the fact that this movement is approximated
    // by a number of discrete segments. The inverse feed_rate should be correct for the sum of
    // all segments.
    if (pl_data->condition & PL_COND_FLAG_INVERSE_TIME) { 
     9ac:	af 85       	ldd	r26, Y+15	; 0x0f
     9ae:	b8 89       	ldd	r27, Y+16	; 0x10
     9b0:	1c 96       	adiw	r26, 0x0c	; 12
     9b2:	1c 91       	ld	r17, X
     9b4:	13 ff       	sbrs	r17, 3
     9b6:	18 c0       	rjmp	.+48     	; 0x9e8 <mc_arc+0x2b0>
      pl_data->feed_rate *= segments; 
     9b8:	80 e0       	ldi	r24, 0x00	; 0
     9ba:	90 e0       	ldi	r25, 0x00	; 0
     9bc:	0e 94 09 40 	call	0x8012	; 0x8012 <__floatunsisf>
     9c0:	9b 01       	movw	r18, r22
     9c2:	ac 01       	movw	r20, r24
     9c4:	ef 85       	ldd	r30, Y+15	; 0x0f
     9c6:	f8 89       	ldd	r31, Y+16	; 0x10
     9c8:	60 81       	ld	r22, Z
     9ca:	71 81       	ldd	r23, Z+1	; 0x01
     9cc:	82 81       	ldd	r24, Z+2	; 0x02
     9ce:	93 81       	ldd	r25, Z+3	; 0x03
     9d0:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     9d4:	af 85       	ldd	r26, Y+15	; 0x0f
     9d6:	b8 89       	ldd	r27, Y+16	; 0x10
     9d8:	6d 93       	st	X+, r22
     9da:	7d 93       	st	X+, r23
     9dc:	8d 93       	st	X+, r24
     9de:	9c 93       	st	X, r25
     9e0:	13 97       	sbiw	r26, 0x03	; 3
      bit_false(pl_data->condition,PL_COND_FLAG_INVERSE_TIME); // Force as feed absolute mode over arc segments.
     9e2:	17 7f       	andi	r17, 0xF7	; 247
     9e4:	1c 96       	adiw	r26, 0x0c	; 12
     9e6:	1c 93       	st	X, r17
    }
    
    float theta_per_segment = angular_travel/segments;
     9e8:	b6 01       	movw	r22, r12
     9ea:	80 e0       	ldi	r24, 0x00	; 0
     9ec:	90 e0       	ldi	r25, 0x00	; 0
     9ee:	0e 94 09 40 	call	0x8012	; 0x8012 <__floatunsisf>
     9f2:	6b 01       	movw	r12, r22
     9f4:	7c 01       	movw	r14, r24
     9f6:	9b 01       	movw	r18, r22
     9f8:	ac 01       	movw	r20, r24
     9fa:	c5 01       	movw	r24, r10
     9fc:	b4 01       	movw	r22, r8
     9fe:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <__divsf3>
     a02:	69 a7       	std	Y+41, r22	; 0x29
     a04:	7a a7       	std	Y+42, r23	; 0x2a
     a06:	8b a7       	std	Y+43, r24	; 0x2b
     a08:	9c a7       	std	Y+44, r25	; 0x2c
    float linear_per_segment = (target[axis_linear] - position[axis_linear])/segments;
     a0a:	b9 89       	ldd	r27, Y+17	; 0x11
     a0c:	8b 2e       	mov	r8, r27
     a0e:	91 2c       	mov	r9, r1
     a10:	88 0c       	add	r8, r8
     a12:	99 1c       	adc	r9, r9
     a14:	88 0c       	add	r8, r8
     a16:	99 1c       	adc	r9, r9
     a18:	4d 84       	ldd	r4, Y+13	; 0x0d
     a1a:	5e 84       	ldd	r5, Y+14	; 0x0e
     a1c:	48 0c       	add	r4, r8
     a1e:	59 1c       	adc	r5, r9
     a20:	e9 a9       	ldd	r30, Y+49	; 0x31
     a22:	fa a9       	ldd	r31, Y+50	; 0x32
     a24:	e8 0d       	add	r30, r8
     a26:	f9 1d       	adc	r31, r9
     a28:	d2 01       	movw	r26, r4
     a2a:	2d 91       	ld	r18, X+
     a2c:	3d 91       	ld	r19, X+
     a2e:	4d 91       	ld	r20, X+
     a30:	5c 91       	ld	r21, X
     a32:	60 81       	ld	r22, Z
     a34:	71 81       	ldd	r23, Z+1	; 0x01
     a36:	82 81       	ldd	r24, Z+2	; 0x02
     a38:	93 81       	ldd	r25, Z+3	; 0x03
     a3a:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
     a3e:	a7 01       	movw	r20, r14
     a40:	96 01       	movw	r18, r12
     a42:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <__divsf3>
     a46:	69 8b       	std	Y+17, r22	; 0x11
     a48:	7a 8b       	std	Y+18, r23	; 0x12
     a4a:	8b 8b       	std	Y+19, r24	; 0x13
     a4c:	9c 8b       	std	Y+20, r25	; 0x14
       without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
       a correction, the planner should have caught up to the lag caused by the initial mc_arc overhead.
       This is important when there are successive arc motions.
    */
    // Computes: cos_T = 1 - theta_per_segment^2/2, sin_T = theta_per_segment - theta_per_segment^3/6) in ~52usec
    float cos_T = 2.0 - theta_per_segment*theta_per_segment;
     a4e:	29 a5       	ldd	r18, Y+41	; 0x29
     a50:	3a a5       	ldd	r19, Y+42	; 0x2a
     a52:	4b a5       	ldd	r20, Y+43	; 0x2b
     a54:	5c a5       	ldd	r21, Y+44	; 0x2c
     a56:	ca 01       	movw	r24, r20
     a58:	b9 01       	movw	r22, r18
     a5a:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     a5e:	9b 01       	movw	r18, r22
     a60:	ac 01       	movw	r20, r24
     a62:	60 e0       	ldi	r22, 0x00	; 0
     a64:	70 e0       	ldi	r23, 0x00	; 0
     a66:	80 e0       	ldi	r24, 0x00	; 0
     a68:	90 e4       	ldi	r25, 0x40	; 64
     a6a:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
     a6e:	6b 01       	movw	r12, r22
     a70:	7c 01       	movw	r14, r24
    float sin_T = theta_per_segment*0.16666667*(cos_T + 4.0);
     a72:	2b ea       	ldi	r18, 0xAB	; 171
     a74:	3a ea       	ldi	r19, 0xAA	; 170
     a76:	4a e2       	ldi	r20, 0x2A	; 42
     a78:	5e e3       	ldi	r21, 0x3E	; 62
     a7a:	69 a5       	ldd	r22, Y+41	; 0x29
     a7c:	7a a5       	ldd	r23, Y+42	; 0x2a
     a7e:	8b a5       	ldd	r24, Y+43	; 0x2b
     a80:	9c a5       	ldd	r25, Y+44	; 0x2c
     a82:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     a86:	4b 01       	movw	r8, r22
     a88:	5c 01       	movw	r10, r24
     a8a:	20 e0       	ldi	r18, 0x00	; 0
     a8c:	30 e0       	ldi	r19, 0x00	; 0
     a8e:	40 e8       	ldi	r20, 0x80	; 128
     a90:	50 e4       	ldi	r21, 0x40	; 64
     a92:	c7 01       	movw	r24, r14
     a94:	b6 01       	movw	r22, r12
     a96:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
     a9a:	9b 01       	movw	r18, r22
     a9c:	ac 01       	movw	r20, r24
     a9e:	c5 01       	movw	r24, r10
     aa0:	b4 01       	movw	r22, r8
     aa2:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     aa6:	69 a3       	std	Y+33, r22	; 0x21
     aa8:	7a a3       	std	Y+34, r23	; 0x22
     aaa:	8b a3       	std	Y+35, r24	; 0x23
     aac:	9c a3       	std	Y+36, r25	; 0x24
    cos_T *= 0.5;
     aae:	20 e0       	ldi	r18, 0x00	; 0
     ab0:	30 e0       	ldi	r19, 0x00	; 0
     ab2:	40 e0       	ldi	r20, 0x00	; 0
     ab4:	5f e3       	ldi	r21, 0x3F	; 63
     ab6:	c7 01       	movw	r24, r14
     ab8:	b6 01       	movw	r22, r12
     aba:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     abe:	6d a3       	std	Y+37, r22	; 0x25
     ac0:	7e a3       	std	Y+38, r23	; 0x26
     ac2:	8f a3       	std	Y+39, r24	; 0x27
     ac4:	98 a7       	std	Y+40, r25	; 0x28
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;

    for (i = 1; i<segments; i++) { // Increment (segments-1).
     ac6:	b2 e0       	ldi	r27, 0x02	; 2
     ac8:	6b 16       	cp	r6, r27
     aca:	71 04       	cpc	r7, r1
     acc:	08 f4       	brcc	.+2      	; 0xad0 <mc_arc+0x398>
     ace:	f5 c0       	rjmp	.+490    	; 0xcba <mc_arc+0x582>
     ad0:	10 e0       	ldi	r17, 0x00	; 0
     ad2:	22 24       	eor	r2, r2
     ad4:	23 94       	inc	r2
     ad6:	31 2c       	mov	r3, r1
      position[axis_linear] += linear_per_segment;

      mc_line(position, pl_data);

      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
     ad8:	c9 84       	ldd	r12, Y+9	; 0x09
     ada:	da 84       	ldd	r13, Y+10	; 0x0a
     adc:	eb 84       	ldd	r14, Y+11	; 0x0b
     ade:	fc 84       	ldd	r15, Y+12	; 0x0c
    uint16_t i;
    uint8_t count = 0;

    for (i = 1; i<segments; i++) { // Increment (segments-1).

      if (count < N_ARC_CORRECTION) {
     ae0:	1c 30       	cpi	r17, 0x0C	; 12
     ae2:	08 f0       	brcs	.+2      	; 0xae6 <mc_arc+0x3ae>
     ae4:	44 c0       	rjmp	.+136    	; 0xb6e <mc_arc+0x436>
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
     ae6:	a7 01       	movw	r20, r14
     ae8:	96 01       	movw	r18, r12
     aea:	6d a1       	ldd	r22, Y+37	; 0x25
     aec:	7e a1       	ldd	r23, Y+38	; 0x26
     aee:	8f a1       	ldd	r24, Y+39	; 0x27
     af0:	98 a5       	ldd	r25, Y+40	; 0x28
     af2:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     af6:	4b 01       	movw	r8, r22
     af8:	5c 01       	movw	r10, r24
     afa:	29 81       	ldd	r18, Y+1	; 0x01
     afc:	3a 81       	ldd	r19, Y+2	; 0x02
     afe:	4b 81       	ldd	r20, Y+3	; 0x03
     b00:	5c 81       	ldd	r21, Y+4	; 0x04
     b02:	69 a1       	ldd	r22, Y+33	; 0x21
     b04:	7a a1       	ldd	r23, Y+34	; 0x22
     b06:	8b a1       	ldd	r24, Y+35	; 0x23
     b08:	9c a1       	ldd	r25, Y+36	; 0x24
     b0a:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     b0e:	a5 01       	movw	r20, r10
     b10:	94 01       	movw	r18, r8
     b12:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
     b16:	96 2e       	mov	r9, r22
     b18:	a7 2e       	mov	r10, r23
     b1a:	b8 2e       	mov	r11, r24
     b1c:	09 2f       	mov	r16, r25
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
     b1e:	29 81       	ldd	r18, Y+1	; 0x01
     b20:	3a 81       	ldd	r19, Y+2	; 0x02
     b22:	4b 81       	ldd	r20, Y+3	; 0x03
     b24:	5c 81       	ldd	r21, Y+4	; 0x04
     b26:	6d a1       	ldd	r22, Y+37	; 0x25
     b28:	7e a1       	ldd	r23, Y+38	; 0x26
     b2a:	8f a1       	ldd	r24, Y+39	; 0x27
     b2c:	98 a5       	ldd	r25, Y+40	; 0x28
     b2e:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     b32:	69 83       	std	Y+1, r22	; 0x01
     b34:	7a 83       	std	Y+2, r23	; 0x02
     b36:	8b 83       	std	Y+3, r24	; 0x03
     b38:	9c 83       	std	Y+4, r25	; 0x04
     b3a:	a7 01       	movw	r20, r14
     b3c:	96 01       	movw	r18, r12
     b3e:	69 a1       	ldd	r22, Y+33	; 0x21
     b40:	7a a1       	ldd	r23, Y+34	; 0x22
     b42:	8b a1       	ldd	r24, Y+35	; 0x23
     b44:	9c a1       	ldd	r25, Y+36	; 0x24
     b46:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     b4a:	9b 01       	movw	r18, r22
     b4c:	ac 01       	movw	r20, r24
     b4e:	69 81       	ldd	r22, Y+1	; 0x01
     b50:	7a 81       	ldd	r23, Y+2	; 0x02
     b52:	8b 81       	ldd	r24, Y+3	; 0x03
     b54:	9c 81       	ldd	r25, Y+4	; 0x04
     b56:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
     b5a:	69 83       	std	Y+1, r22	; 0x01
     b5c:	7a 83       	std	Y+2, r23	; 0x02
     b5e:	8b 83       	std	Y+3, r24	; 0x03
     b60:	9c 83       	std	Y+4, r25	; 0x04
        r_axis1 = r_axisi;
        count++;
     b62:	1f 5f       	subi	r17, 0xFF	; 255

      if (count < N_ARC_CORRECTION) {
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
        r_axis1 = r_axisi;
     b64:	c9 2c       	mov	r12, r9
     b66:	da 2c       	mov	r13, r10
     b68:	eb 2c       	mov	r14, r11
     b6a:	f0 2e       	mov	r15, r16
     b6c:	66 c0       	rjmp	.+204    	; 0xc3a <mc_arc+0x502>
        count++;
      } else {
        // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments. ~375 usec
        // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
        cos_Ti = cos(i*theta_per_segment);
     b6e:	b1 01       	movw	r22, r2
     b70:	80 e0       	ldi	r24, 0x00	; 0
     b72:	90 e0       	ldi	r25, 0x00	; 0
     b74:	0e 94 09 40 	call	0x8012	; 0x8012 <__floatunsisf>
     b78:	29 a5       	ldd	r18, Y+41	; 0x29
     b7a:	3a a5       	ldd	r19, Y+42	; 0x2a
     b7c:	4b a5       	ldd	r20, Y+43	; 0x2b
     b7e:	5c a5       	ldd	r21, Y+44	; 0x2c
     b80:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     b84:	6b 01       	movw	r12, r22
     b86:	7c 01       	movw	r14, r24
     b88:	0e 94 6d 3f 	call	0x7eda	; 0x7eda <cos>
     b8c:	6d 83       	std	Y+5, r22	; 0x05
     b8e:	7e 83       	std	Y+6, r23	; 0x06
     b90:	8f 83       	std	Y+7, r24	; 0x07
     b92:	98 87       	std	Y+8, r25	; 0x08
        sin_Ti = sin(i*theta_per_segment);
     b94:	c7 01       	movw	r24, r14
     b96:	b6 01       	movw	r22, r12
     b98:	0e 94 2a 42 	call	0x8454	; 0x8454 <sin>
     b9c:	69 87       	std	Y+9, r22	; 0x09
     b9e:	7a 87       	std	Y+10, r23	; 0x0a
     ba0:	8b 87       	std	Y+11, r24	; 0x0b
     ba2:	9c 87       	std	Y+12, r25	; 0x0c
        r_axis0 = -offset[axis_0]*cos_Ti + offset[axis_1]*sin_Ti;
     ba4:	ed a5       	ldd	r30, Y+45	; 0x2d
     ba6:	fe a5       	ldd	r31, Y+46	; 0x2e
     ba8:	c0 80       	ld	r12, Z
     baa:	d1 80       	ldd	r13, Z+1	; 0x01
     bac:	e2 80       	ldd	r14, Z+2	; 0x02
     bae:	f3 80       	ldd	r15, Z+3	; 0x03
     bb0:	f7 fa       	bst	r15, 7
     bb2:	f0 94       	com	r15
     bb4:	f7 f8       	bld	r15, 7
     bb6:	f0 94       	com	r15
     bb8:	af a5       	ldd	r26, Y+47	; 0x2f
     bba:	b8 a9       	ldd	r27, Y+48	; 0x30
     bbc:	8d 90       	ld	r8, X+
     bbe:	9d 90       	ld	r9, X+
     bc0:	ad 90       	ld	r10, X+
     bc2:	bc 90       	ld	r11, X
     bc4:	a7 01       	movw	r20, r14
     bc6:	96 01       	movw	r18, r12
     bc8:	6d 81       	ldd	r22, Y+5	; 0x05
     bca:	7e 81       	ldd	r23, Y+6	; 0x06
     bcc:	8f 81       	ldd	r24, Y+7	; 0x07
     bce:	98 85       	ldd	r25, Y+8	; 0x08
     bd0:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     bd4:	69 83       	std	Y+1, r22	; 0x01
     bd6:	7a 83       	std	Y+2, r23	; 0x02
     bd8:	8b 83       	std	Y+3, r24	; 0x03
     bda:	9c 83       	std	Y+4, r25	; 0x04
     bdc:	a5 01       	movw	r20, r10
     bde:	94 01       	movw	r18, r8
     be0:	69 85       	ldd	r22, Y+9	; 0x09
     be2:	7a 85       	ldd	r23, Y+10	; 0x0a
     be4:	8b 85       	ldd	r24, Y+11	; 0x0b
     be6:	9c 85       	ldd	r25, Y+12	; 0x0c
     be8:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     bec:	9b 01       	movw	r18, r22
     bee:	ac 01       	movw	r20, r24
     bf0:	69 81       	ldd	r22, Y+1	; 0x01
     bf2:	7a 81       	ldd	r23, Y+2	; 0x02
     bf4:	8b 81       	ldd	r24, Y+3	; 0x03
     bf6:	9c 81       	ldd	r25, Y+4	; 0x04
     bf8:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
     bfc:	69 83       	std	Y+1, r22	; 0x01
     bfe:	7a 83       	std	Y+2, r23	; 0x02
     c00:	8b 83       	std	Y+3, r24	; 0x03
     c02:	9c 83       	std	Y+4, r25	; 0x04
        r_axis1 = -offset[axis_0]*sin_Ti - offset[axis_1]*cos_Ti;
     c04:	a7 01       	movw	r20, r14
     c06:	96 01       	movw	r18, r12
     c08:	69 85       	ldd	r22, Y+9	; 0x09
     c0a:	7a 85       	ldd	r23, Y+10	; 0x0a
     c0c:	8b 85       	ldd	r24, Y+11	; 0x0b
     c0e:	9c 85       	ldd	r25, Y+12	; 0x0c
     c10:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     c14:	6b 01       	movw	r12, r22
     c16:	7c 01       	movw	r14, r24
     c18:	a5 01       	movw	r20, r10
     c1a:	94 01       	movw	r18, r8
     c1c:	6d 81       	ldd	r22, Y+5	; 0x05
     c1e:	7e 81       	ldd	r23, Y+6	; 0x06
     c20:	8f 81       	ldd	r24, Y+7	; 0x07
     c22:	98 85       	ldd	r25, Y+8	; 0x08
     c24:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     c28:	9b 01       	movw	r18, r22
     c2a:	ac 01       	movw	r20, r24
     c2c:	c7 01       	movw	r24, r14
     c2e:	b6 01       	movw	r22, r12
     c30:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
     c34:	6b 01       	movw	r12, r22
     c36:	7c 01       	movw	r14, r24
        count = 0;
     c38:	10 e0       	ldi	r17, 0x00	; 0
      }

      // Update arc_target location
      position[axis_0] = center_axis0 + r_axis0;
     c3a:	2f 89       	ldd	r18, Y+23	; 0x17
     c3c:	38 8d       	ldd	r19, Y+24	; 0x18
     c3e:	49 8d       	ldd	r20, Y+25	; 0x19
     c40:	5a 8d       	ldd	r21, Y+26	; 0x1a
     c42:	69 81       	ldd	r22, Y+1	; 0x01
     c44:	7a 81       	ldd	r23, Y+2	; 0x02
     c46:	8b 81       	ldd	r24, Y+3	; 0x03
     c48:	9c 81       	ldd	r25, Y+4	; 0x04
     c4a:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
     c4e:	ed 89       	ldd	r30, Y+21	; 0x15
     c50:	fe 89       	ldd	r31, Y+22	; 0x16
     c52:	60 83       	st	Z, r22
     c54:	71 83       	std	Z+1, r23	; 0x01
     c56:	82 83       	std	Z+2, r24	; 0x02
     c58:	93 83       	std	Z+3, r25	; 0x03
      position[axis_1] = center_axis1 + r_axis1;
     c5a:	2d 8d       	ldd	r18, Y+29	; 0x1d
     c5c:	3e 8d       	ldd	r19, Y+30	; 0x1e
     c5e:	4f 8d       	ldd	r20, Y+31	; 0x1f
     c60:	58 a1       	ldd	r21, Y+32	; 0x20
     c62:	c7 01       	movw	r24, r14
     c64:	b6 01       	movw	r22, r12
     c66:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
     c6a:	ab 8d       	ldd	r26, Y+27	; 0x1b
     c6c:	bc 8d       	ldd	r27, Y+28	; 0x1c
     c6e:	6d 93       	st	X+, r22
     c70:	7d 93       	st	X+, r23
     c72:	8d 93       	st	X+, r24
     c74:	9c 93       	st	X, r25
     c76:	13 97       	sbiw	r26, 0x03	; 3
      position[axis_linear] += linear_per_segment;
     c78:	29 89       	ldd	r18, Y+17	; 0x11
     c7a:	3a 89       	ldd	r19, Y+18	; 0x12
     c7c:	4b 89       	ldd	r20, Y+19	; 0x13
     c7e:	5c 89       	ldd	r21, Y+20	; 0x14
     c80:	f2 01       	movw	r30, r4
     c82:	60 81       	ld	r22, Z
     c84:	71 81       	ldd	r23, Z+1	; 0x01
     c86:	82 81       	ldd	r24, Z+2	; 0x02
     c88:	93 81       	ldd	r25, Z+3	; 0x03
     c8a:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
     c8e:	d2 01       	movw	r26, r4
     c90:	6d 93       	st	X+, r22
     c92:	7d 93       	st	X+, r23
     c94:	8d 93       	st	X+, r24
     c96:	9c 93       	st	X, r25
     c98:	13 97       	sbiw	r26, 0x03	; 3

      mc_line(position, pl_data);
     c9a:	6f 85       	ldd	r22, Y+15	; 0x0f
     c9c:	78 89       	ldd	r23, Y+16	; 0x10
     c9e:	8d 85       	ldd	r24, Y+13	; 0x0d
     ca0:	9e 85       	ldd	r25, Y+14	; 0x0e
     ca2:	09 dd       	rcall	.-1518   	; 0x6b6 <mc_line>

      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
     ca4:	80 91 1f 0c 	lds	r24, 0x0C1F	; 0x800c1f <sys+0x1>
     ca8:	81 11       	cpse	r24, r1
     caa:	0c c0       	rjmp	.+24     	; 0xcc4 <mc_arc+0x58c>
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;

    for (i = 1; i<segments; i++) { // Increment (segments-1).
     cac:	bf ef       	ldi	r27, 0xFF	; 255
     cae:	2b 1a       	sub	r2, r27
     cb0:	3b 0a       	sbc	r3, r27
     cb2:	62 14       	cp	r6, r2
     cb4:	73 04       	cpc	r7, r3
     cb6:	09 f0       	breq	.+2      	; 0xcba <mc_arc+0x582>
     cb8:	13 cf       	rjmp	.-474    	; 0xae0 <mc_arc+0x3a8>
      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
    }
  }
  // Ensure last segment arrives at target location.
  mc_line(target, pl_data);
     cba:	6f 85       	ldd	r22, Y+15	; 0x0f
     cbc:	78 89       	ldd	r23, Y+16	; 0x10
     cbe:	89 a9       	ldd	r24, Y+49	; 0x31
     cc0:	9a a9       	ldd	r25, Y+50	; 0x32
     cc2:	f9 dc       	rcall	.-1550   	; 0x6b6 <mc_line>
}
     cc4:	e2 96       	adiw	r28, 0x32	; 50
     cc6:	0f b6       	in	r0, 0x3f	; 63
     cc8:	f8 94       	cli
     cca:	de bf       	out	0x3e, r29	; 62
     ccc:	0f be       	out	0x3f, r0	; 63
     cce:	cd bf       	out	0x3d, r28	; 61
     cd0:	df 91       	pop	r29
     cd2:	cf 91       	pop	r28
     cd4:	1f 91       	pop	r17
     cd6:	0f 91       	pop	r16
     cd8:	ff 90       	pop	r15
     cda:	ef 90       	pop	r14
     cdc:	df 90       	pop	r13
     cde:	cf 90       	pop	r12
     ce0:	bf 90       	pop	r11
     ce2:	af 90       	pop	r10
     ce4:	9f 90       	pop	r9
     ce6:	8f 90       	pop	r8
     ce8:	7f 90       	pop	r7
     cea:	6f 90       	pop	r6
     cec:	5f 90       	pop	r5
     cee:	4f 90       	pop	r4
     cf0:	3f 90       	pop	r3
     cf2:	2f 90       	pop	r2
     cf4:	08 95       	ret

00000cf6 <mc_dwell>:


// Execute dwell in seconds.
void mc_dwell(float seconds)
{
     cf6:	cf 92       	push	r12
     cf8:	df 92       	push	r13
     cfa:	ef 92       	push	r14
     cfc:	ff 92       	push	r15
  if (sys.state == STATE_CHECK_MODE) { return; }
     cfe:	20 91 1e 0c 	lds	r18, 0x0C1E	; 0x800c1e <sys>
     d02:	22 30       	cpi	r18, 0x02	; 2
     d04:	49 f0       	breq	.+18     	; 0xd18 <mc_dwell+0x22>
     d06:	6b 01       	movw	r12, r22
     d08:	7c 01       	movw	r14, r24
  protocol_buffer_synchronize();
     d0a:	0e 94 2c 19 	call	0x3258	; 0x3258 <protocol_buffer_synchronize>
  delay_sec(seconds, DELAY_MODE_DWELL);
     d0e:	40 e0       	ldi	r20, 0x00	; 0
     d10:	c7 01       	movw	r24, r14
     d12:	b6 01       	movw	r22, r12
     d14:	0e 94 f3 2e 	call	0x5de6	; 0x5de6 <delay_sec>
}
     d18:	ff 90       	pop	r15
     d1a:	ef 90       	pop	r14
     d1c:	df 90       	pop	r13
     d1e:	cf 90       	pop	r12
     d20:	08 95       	ret

00000d22 <mc_homing_cycle>:

// Perform homing cycle to locate and set machine zero. Only '$H' executes this command.
// NOTE: There should be no motions in the buffer and Grbl must be in an idle state before
// executing the homing cycle. This prevents incorrect buffered plans after homing.
void mc_homing_cycle(uint8_t cycle_mask)
{
     d22:	cf 93       	push	r28
     d24:	c8 2f       	mov	r28, r24
      system_set_exec_alarm(EXEC_ALARM_HARD_LIMIT);
      return;
    }
  #endif

  limits_disable(); // Disable hard limits pin change register for cycle duration
     d26:	0e 94 39 30 	call	0x6072	; 0x6072 <limits_disable>

  // -------------------------------------------------------------------------------------
  // Perform homing routine. NOTE: Special motion case. Only system reset works.
  
  #ifdef HOMING_SINGLE_AXIS_COMMANDS
    if (cycle_mask) { limits_go_home(cycle_mask); } // Perform homing cycle based on mask.
     d2a:	cc 23       	and	r28, r28
     d2c:	21 f0       	breq	.+8      	; 0xd36 <mc_homing_cycle+0x14>
     d2e:	8c 2f       	mov	r24, r28
     d30:	0e 94 00 31 	call	0x6200	; 0x6200 <limits_go_home>
     d34:	06 c0       	rjmp	.+12     	; 0xd42 <mc_homing_cycle+0x20>
    else
  #endif
  {
    // Search to engage all axes limit switches at faster homing seek rate.
    limits_go_home(HOMING_CYCLE_0);  // Homing cycle 0
     d36:	81 e0       	ldi	r24, 0x01	; 1
     d38:	0e 94 00 31 	call	0x6200	; 0x6200 <limits_go_home>
    #ifdef HOMING_CYCLE_1
      limits_go_home(HOMING_CYCLE_1);  // Homing cycle 1
     d3c:	84 e0       	ldi	r24, 0x04	; 4
     d3e:	0e 94 00 31 	call	0x6200	; 0x6200 <limits_go_home>
    #ifdef HOMING_CYCLE_2
      limits_go_home(HOMING_CYCLE_2);  // Homing cycle 2
    #endif
  }

  protocol_execute_realtime(); // Check for reset and set system abort.
     d42:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <protocol_execute_realtime>
  if (sys.abort) { return; } // Did not complete. Alarm state set by mc_alarm.
     d46:	80 91 1f 0c 	lds	r24, 0x0C1F	; 0x800c1f <sys+0x1>
     d4a:	81 11       	cpse	r24, r1
     d4c:	05 c0       	rjmp	.+10     	; 0xd58 <mc_homing_cycle+0x36>

  // Homing cycle complete! Setup system for normal operation.
  // -------------------------------------------------------------------------------------

  // Sync gcode parser and planner positions to homed position.
  gc_sync_position();
     d4e:	b1 d0       	rcall	.+354    	; 0xeb2 <gc_sync_position>
  plan_sync_position();
     d50:	0e 94 07 2e 	call	0x5c0e	; 0x5c0e <plan_sync_position>

  // If hard limits feature enabled, re-enable hard limits pin change register after homing cycle.
  limits_init();
     d54:	0e 94 44 30 	call	0x6088	; 0x6088 <limits_init>
}
     d58:	cf 91       	pop	r28
     d5a:	08 95       	ret

00000d5c <mc_probe_cycle>:


// Perform tool length probe cycle. Requires probe switch.
// NOTE: Upon probe failure, the program will be stopped and placed into ALARM state.
uint8_t mc_probe_cycle(float *target, plan_line_data_t *pl_data, uint8_t parser_flags)
{
     d5c:	df 92       	push	r13
     d5e:	ef 92       	push	r14
     d60:	ff 92       	push	r15
     d62:	0f 93       	push	r16
     d64:	1f 93       	push	r17
     d66:	cf 93       	push	r28
     d68:	df 93       	push	r29
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return(GC_PROBE_CHECK_MODE); }
     d6a:	20 91 1e 0c 	lds	r18, 0x0C1E	; 0x800c1e <sys>
     d6e:	22 30       	cpi	r18, 0x02	; 2
     d70:	09 f4       	brne	.+2      	; 0xd74 <mc_probe_cycle+0x18>
     d72:	5c c0       	rjmp	.+184    	; 0xe2c <mc_probe_cycle+0xd0>
     d74:	d4 2e       	mov	r13, r20
     d76:	7b 01       	movw	r14, r22
     d78:	8c 01       	movw	r16, r24

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
     d7a:	0e 94 2c 19 	call	0x3258	; 0x3258 <protocol_buffer_synchronize>
  if (sys.abort) { return(GC_PROBE_ABORT); } // Return if system reset has been issued.
     d7e:	80 91 1f 0c 	lds	r24, 0x0C1F	; 0x800c1f <sys+0x1>
     d82:	81 11       	cpse	r24, r1
     d84:	55 c0       	rjmp	.+170    	; 0xe30 <mc_probe_cycle+0xd4>

  // Initialize probing control variables
  uint8_t is_probe_away = bit_istrue(parser_flags,GC_PARSER_PROBE_IS_AWAY);
  uint8_t is_no_error = bit_istrue(parser_flags,GC_PARSER_PROBE_IS_NO_ERROR);
  sys.probe_succeeded = false; // Re-initialize probe history before beginning cycle.
     d86:	10 92 23 0c 	sts	0x0C23, r1	; 0x800c23 <sys+0x5>
  probe_configure_invert_mask(is_probe_away);
     d8a:	d3 fa       	bst	r13, 3
     d8c:	88 27       	eor	r24, r24
     d8e:	80 f9       	bld	r24, 0
     d90:	0e 94 dc 34 	call	0x69b8	; 0x69b8 <probe_configure_invert_mask>

  // After syncing, check if probe is already triggered. If so, halt and issue alarm.
  // NOTE: This probe initialization error applies to all probing cycles.
  if ( probe_get_state() ) { // Check probe pin state.
     d94:	0e 94 fa 34 	call	0x69f4	; 0x69f4 <probe_get_state>
     d98:	88 23       	and	r24, r24
     d9a:	51 f0       	breq	.+20     	; 0xdb0 <mc_probe_cycle+0x54>
    system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_INITIAL);
     d9c:	84 e0       	ldi	r24, 0x04	; 4
     d9e:	0e 94 01 3e 	call	0x7c02	; 0x7c02 <system_set_exec_alarm>
    protocol_execute_realtime();
     da2:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <protocol_execute_realtime>
    probe_configure_invert_mask(false); // Re-initialize invert mask before returning.
     da6:	80 e0       	ldi	r24, 0x00	; 0
     da8:	0e 94 dc 34 	call	0x69b8	; 0x69b8 <probe_configure_invert_mask>
    return(GC_PROBE_FAIL_INIT); // Nothing else to do but bail.
     dac:	82 e0       	ldi	r24, 0x02	; 2
     dae:	43 c0       	rjmp	.+134    	; 0xe36 <mc_probe_cycle+0xda>
  }

  // Setup and queue probing motion. Auto cycle-start should not start the cycle.
  mc_line(target, pl_data);
     db0:	b7 01       	movw	r22, r14
     db2:	c8 01       	movw	r24, r16
     db4:	80 dc       	rcall	.-1792   	; 0x6b6 <mc_line>

  // Activate the probing state monitor in the stepper module.
  sys_probe_state = PROBE_ACTIVE;
     db6:	81 e0       	ldi	r24, 0x01	; 1
     db8:	80 93 32 0c 	sts	0x0C32, r24	; 0x800c32 <sys_probe_state>

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
     dbc:	82 e0       	ldi	r24, 0x02	; 2
     dbe:	0e 94 99 3b 	call	0x7732	; 0x7732 <system_set_exec_state_flag>
  do {
    protocol_execute_realtime();
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
     dc2:	ce e1       	ldi	r28, 0x1E	; 30
     dc4:	dc e0       	ldi	r29, 0x0C	; 12
  sys_probe_state = PROBE_ACTIVE;

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
  do {
    protocol_execute_realtime();
     dc6:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <protocol_execute_realtime>
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
     dca:	89 81       	ldd	r24, Y+1	; 0x01
     dcc:	81 11       	cpse	r24, r1
     dce:	32 c0       	rjmp	.+100    	; 0xe34 <mc_probe_cycle+0xd8>
  } while (sys.state != STATE_IDLE);
     dd0:	88 81       	ld	r24, Y
     dd2:	81 11       	cpse	r24, r1
     dd4:	f8 cf       	rjmp	.-16     	; 0xdc6 <mc_probe_cycle+0x6a>

  // Probing cycle complete!

  // Set state variables and error out, if the probe failed and cycle with error is enabled.
  if (sys_probe_state == PROBE_ACTIVE) {
     dd6:	80 91 32 0c 	lds	r24, 0x0C32	; 0x800c32 <sys_probe_state>
     dda:	81 30       	cpi	r24, 0x01	; 1
     ddc:	81 f4       	brne	.+32     	; 0xdfe <mc_probe_cycle+0xa2>
    if (is_no_error) { memcpy(sys_probe_position, sys_position, sizeof(sys_position)); }
     dde:	d4 fe       	sbrs	r13, 4
     de0:	0a c0       	rjmp	.+20     	; 0xdf6 <mc_probe_cycle+0x9a>
     de2:	8c e0       	ldi	r24, 0x0C	; 12
     de4:	e3 e4       	ldi	r30, 0x43	; 67
     de6:	fc e0       	ldi	r31, 0x0C	; 12
     de8:	a7 e3       	ldi	r26, 0x37	; 55
     dea:	bc e0       	ldi	r27, 0x0C	; 12
     dec:	01 90       	ld	r0, Z+
     dee:	0d 92       	st	X+, r0
     df0:	8a 95       	dec	r24
     df2:	e1 f7       	brne	.-8      	; 0xdec <mc_probe_cycle+0x90>
     df4:	07 c0       	rjmp	.+14     	; 0xe04 <mc_probe_cycle+0xa8>
    else { system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_CONTACT); }
     df6:	85 e0       	ldi	r24, 0x05	; 5
     df8:	0e 94 01 3e 	call	0x7c02	; 0x7c02 <system_set_exec_alarm>
     dfc:	03 c0       	rjmp	.+6      	; 0xe04 <mc_probe_cycle+0xa8>
  } else {
    sys.probe_succeeded = true; // Indicate to system the probing cycle completed successfully.
     dfe:	81 e0       	ldi	r24, 0x01	; 1
     e00:	80 93 23 0c 	sts	0x0C23, r24	; 0x800c23 <sys+0x5>
  }
  sys_probe_state = PROBE_OFF; // Ensure probe state monitor is disabled.
     e04:	10 92 32 0c 	sts	0x0C32, r1	; 0x800c32 <sys_probe_state>
  probe_configure_invert_mask(false); // Re-initialize invert mask.
     e08:	80 e0       	ldi	r24, 0x00	; 0
     e0a:	0e 94 dc 34 	call	0x69b8	; 0x69b8 <probe_configure_invert_mask>
  protocol_execute_realtime();   // Check and execute run-time commands
     e0e:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <protocol_execute_realtime>

  // Reset the stepper and planner buffers to remove the remainder of the probe motion.
  st_reset(); // Reset step segment buffer.
     e12:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <st_reset>
  plan_reset(); // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
     e16:	0e 94 5f 29 	call	0x52be	; 0x52be <plan_reset>
  plan_sync_position(); // Sync planner position to current machine position.
     e1a:	0e 94 07 2e 	call	0x5c0e	; 0x5c0e <plan_sync_position>
// Perform tool length probe cycle. Requires probe switch.
// NOTE: Upon probe failure, the program will be stopped and placed into ALARM state.
uint8_t mc_probe_cycle(float *target, plan_line_data_t *pl_data, uint8_t parser_flags)
{
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return(GC_PROBE_CHECK_MODE); }
     e1e:	81 e0       	ldi	r24, 0x01	; 1
     e20:	90 91 23 0c 	lds	r25, 0x0C23	; 0x800c23 <sys+0x5>
     e24:	91 11       	cpse	r25, r1
     e26:	07 c0       	rjmp	.+14     	; 0xe36 <mc_probe_cycle+0xda>
     e28:	80 e0       	ldi	r24, 0x00	; 0
     e2a:	05 c0       	rjmp	.+10     	; 0xe36 <mc_probe_cycle+0xda>
     e2c:	80 e0       	ldi	r24, 0x00	; 0
     e2e:	03 c0       	rjmp	.+6      	; 0xe36 <mc_probe_cycle+0xda>

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
  if (sys.abort) { return(GC_PROBE_ABORT); } // Return if system reset has been issued.
     e30:	82 e0       	ldi	r24, 0x02	; 2
     e32:	01 c0       	rjmp	.+2      	; 0xe36 <mc_probe_cycle+0xda>

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
  do {
    protocol_execute_realtime();
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
     e34:	82 e0       	ldi	r24, 0x02	; 2
    report_probe_parameters();
  #endif

  if (sys.probe_succeeded) { return(GC_PROBE_FOUND); } // Successful probe cycle.
  else { return(GC_PROBE_FAIL_END); } // Failed to trigger probe within travel. With or without error.
}
     e36:	df 91       	pop	r29
     e38:	cf 91       	pop	r28
     e3a:	1f 91       	pop	r17
     e3c:	0f 91       	pop	r16
     e3e:	ff 90       	pop	r15
     e40:	ef 90       	pop	r14
     e42:	df 90       	pop	r13
     e44:	08 95       	ret

00000e46 <mc_reset>:
// lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
// realtime abort command and hard limits. So, keep to a minimum.
void mc_reset()
{
  // Only this function can set the system reset. Helps prevent multiple kill calls.
  if (bit_isfalse(sys_rt_exec_state, EXEC_RESET)) {
     e46:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
     e4a:	84 fd       	sbrc	r24, 4
     e4c:	1f c0       	rjmp	.+62     	; 0xe8c <mc_reset+0x46>
    system_set_exec_state_flag(EXEC_RESET);
     e4e:	80 e1       	ldi	r24, 0x10	; 16
     e50:	0e 94 99 3b 	call	0x7732	; 0x7732 <system_set_exec_state_flag>

    // Kill spindle and coolant.
    spindle_stop();
     e54:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <spindle_stop>
    coolant_stop();
     e58:	0e 94 be 13 	call	0x277c	; 0x277c <coolant_stop>

    // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
    // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
    // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
    // violated, by which, all bets are off.
    if ((sys.state & (STATE_CYCLE | STATE_HOMING | STATE_JOG)) ||
     e5c:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
     e60:	98 2f       	mov	r25, r24
     e62:	9c 72       	andi	r25, 0x2C	; 44
     e64:	21 f4       	brne	.+8      	; 0xe6e <mc_reset+0x28>
     e66:	90 91 22 0c 	lds	r25, 0x0C22	; 0x800c22 <sys+0x4>
     e6a:	96 70       	andi	r25, 0x06	; 6
     e6c:	79 f0       	breq	.+30     	; 0xe8c <mc_reset+0x46>
    		(sys.step_control & (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION))) {
      if (sys.state == STATE_HOMING) { 
     e6e:	84 30       	cpi	r24, 0x04	; 4
     e70:	41 f4       	brne	.+16     	; 0xe82 <mc_reset+0x3c>
        if (!sys_rt_exec_alarm) {system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_RESET); }
     e72:	80 91 53 0c 	lds	r24, 0x0C53	; 0x800c53 <sys_rt_exec_alarm>
     e76:	81 11       	cpse	r24, r1
     e78:	07 c0       	rjmp	.+14     	; 0xe88 <mc_reset+0x42>
     e7a:	86 e0       	ldi	r24, 0x06	; 6
     e7c:	0e 94 01 3e 	call	0x7c02	; 0x7c02 <system_set_exec_alarm>
     e80:	03 c0       	rjmp	.+6      	; 0xe88 <mc_reset+0x42>
      } else { system_set_exec_alarm(EXEC_ALARM_ABORT_CYCLE); }
     e82:	83 e0       	ldi	r24, 0x03	; 3
     e84:	0e 94 01 3e 	call	0x7c02	; 0x7c02 <system_set_exec_alarm>
      st_go_idle(); // Force kill steppers. Position has likely been lost.
     e88:	0c 94 57 19 	jmp	0x32ae	; 0x32ae <st_go_idle>
     e8c:	08 95       	ret

00000e8e <gc_init>:
#define FAIL(status) return(status);


void gc_init()
{
  memset(&gc_state, 0, sizeof(parser_state_t));
     e8e:	80 e4       	ldi	r24, 0x40	; 64
     e90:	e6 e5       	ldi	r30, 0x56	; 86
     e92:	fc e0       	ldi	r31, 0x0C	; 12
     e94:	df 01       	movw	r26, r30
     e96:	1d 92       	st	X+, r1
     e98:	8a 95       	dec	r24
     e9a:	e9 f7       	brne	.-6      	; 0xe96 <gc_init+0x8>

  // Load default G54 coordinate system.
  if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) {
     e9c:	6a e7       	ldi	r22, 0x7A	; 122
     e9e:	7c e0       	ldi	r23, 0x0C	; 12
     ea0:	80 e0       	ldi	r24, 0x00	; 0
     ea2:	0e 94 1a 26 	call	0x4c34	; 0x4c34 <settings_read_coord_data>
     ea6:	81 11       	cpse	r24, r1
     ea8:	03 c0       	rjmp	.+6      	; 0xeb0 <gc_init+0x22>
    report_status_message(STATUS_SETTING_READ_FAIL);
     eaa:	87 e0       	ldi	r24, 0x07	; 7
     eac:	0c 94 5e 35 	jmp	0x6abc	; 0x6abc <report_status_message>
     eb0:	08 95       	ret

00000eb2 <gc_sync_position>:

// Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
// limit pull-off routines.
void gc_sync_position()
{
  system_convert_array_steps_to_mpos(gc_state.position,sys_position);
     eb2:	63 e4       	ldi	r22, 0x43	; 67
     eb4:	7c e0       	ldi	r23, 0x0C	; 12
     eb6:	8e e6       	ldi	r24, 0x6E	; 110
     eb8:	9c e0       	ldi	r25, 0x0C	; 12
     eba:	0c 94 1a 3b 	jmp	0x7634	; 0x7634 <system_convert_array_steps_to_mpos>
     ebe:	08 95       	ret

00000ec0 <gc_execute_line>:
// characters and signed floating point values (no whitespace). Comments and block delete
// characters have been removed. In this function, all units and positions are converted and
// exported to grbl's internal functions in terms of (mm, mm/min) and absolute machine
// coordinates, respectively.
uint8_t gc_execute_line(char *line)
{
     ec0:	2f 92       	push	r2
     ec2:	3f 92       	push	r3
     ec4:	4f 92       	push	r4
     ec6:	5f 92       	push	r5
     ec8:	6f 92       	push	r6
     eca:	7f 92       	push	r7
     ecc:	8f 92       	push	r8
     ece:	9f 92       	push	r9
     ed0:	af 92       	push	r10
     ed2:	bf 92       	push	r11
     ed4:	cf 92       	push	r12
     ed6:	df 92       	push	r13
     ed8:	ef 92       	push	r14
     eda:	ff 92       	push	r15
     edc:	0f 93       	push	r16
     ede:	1f 93       	push	r17
     ee0:	cf 93       	push	r28
     ee2:	df 93       	push	r29
     ee4:	cd b7       	in	r28, 0x3d	; 61
     ee6:	de b7       	in	r29, 0x3e	; 62
     ee8:	e1 97       	sbiw	r28, 0x31	; 49
     eea:	0f b6       	in	r0, 0x3f	; 63
     eec:	f8 94       	cli
     eee:	de bf       	out	0x3e, r29	; 62
     ef0:	0f be       	out	0x3f, r0	; 63
     ef2:	cd bf       	out	0x3d, r28	; 61
     ef4:	8c 01       	movw	r16, r24
     updates these modes and commands as the block line is parser and will only be used and
     executed after successful error-checking. The parser block struct also contains a block
     values struct, word tracking variables, and a non-modal commands tracker for the new
     block. This struct contains all of the necessary information to execute the block. */

  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
     ef6:	8a e3       	ldi	r24, 0x3A	; 58
     ef8:	e6 e9       	ldi	r30, 0x96	; 150
     efa:	fc e0       	ldi	r31, 0x0C	; 12
     efc:	df 01       	movw	r26, r30
     efe:	1d 92       	st	X+, r1
     f00:	8a 95       	dec	r24
     f02:	e9 f7       	brne	.-6      	; 0xefe <gc_execute_line+0x3e>
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
     f04:	8b e0       	ldi	r24, 0x0B	; 11
     f06:	e6 e5       	ldi	r30, 0x56	; 86
     f08:	fc e0       	ldi	r31, 0x0C	; 12
     f0a:	a7 e9       	ldi	r26, 0x97	; 151
     f0c:	bc e0       	ldi	r27, 0x0C	; 12
     f0e:	01 90       	ld	r0, Z+
     f10:	0d 92       	st	X+, r0
     f12:	8a 95       	dec	r24
     f14:	e1 f7       	brne	.-8      	; 0xf0e <gc_execute_line+0x4e>
  uint16_t command_words = 0; // Tracks G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Tracks value words.
  uint8_t gc_parser_flags = GC_PARSER_NONE;

  // Determine if the line is a jogging motion or a normal g-code block.
  if (line[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
     f16:	f8 01       	movw	r30, r16
     f18:	80 81       	ld	r24, Z
     f1a:	84 32       	cpi	r24, 0x24	; 36
     f1c:	11 f0       	breq	.+4      	; 0xf22 <gc_execute_line+0x62>
     f1e:	0c 94 07 12 	jmp	0x240e	; 0x240e <__stack+0x20f>
    // Set G1 and G94 enforced modes to ensure accurate error checks.
    gc_parser_flags |= GC_PARSER_JOG_MOTION;
    gc_block.modal.motion = MOTION_MODE_LINEAR;
     f22:	e6 e9       	ldi	r30, 0x96	; 150
     f24:	fc e0       	ldi	r31, 0x0C	; 12
     f26:	81 e0       	ldi	r24, 0x01	; 1
     f28:	81 83       	std	Z+1, r24	; 0x01
    gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
     f2a:	12 82       	std	Z+2, r1	; 0x02
  uint8_t char_counter;
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
     f2c:	83 e0       	ldi	r24, 0x03	; 3
     f2e:	89 83       	std	Y+1, r24	; 0x01
  uint8_t gc_parser_flags = GC_PARSER_NONE;

  // Determine if the line is a jogging motion or a normal g-code block.
  if (line[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
    // Set G1 and G94 enforced modes to ensure accurate error checks.
    gc_parser_flags |= GC_PARSER_JOG_MOTION;
     f30:	f1 e0       	ldi	r31, 0x01	; 1
     f32:	fc a3       	std	Y+36, r31	; 0x24
						if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
						gc_block.values.t = int_value;
						break;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
     f34:	21 2c       	mov	r2, r1
     f36:	31 2c       	mov	r3, r1
     f38:	e1 2c       	mov	r14, r1
     f3a:	f1 2c       	mov	r15, r1
     f3c:	1b a2       	std	Y+35, r1	; 0x23
     f3e:	19 a2       	std	Y+33, r1	; 0x21
     f40:	1a a2       	std	Y+34, r1	; 0x22
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
     f42:	cc 24       	eor	r12, r12
     f44:	c3 94       	inc	r12
     f46:	d1 2c       	mov	r13, r1

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
     f48:	0f 2e       	mov	r0, r31
     f4a:	f1 e6       	ldi	r31, 0x61	; 97
     f4c:	8f 2e       	mov	r8, r31
     f4e:	f3 e0       	ldi	r31, 0x03	; 3
     f50:	9f 2e       	mov	r9, r31
     f52:	f0 2d       	mov	r31, r0
     f54:	18 a3       	std	Y+32, r17	; 0x20
     f56:	0f 8f       	std	Y+31, r16	; 0x1f
     f58:	37 c2       	rjmp	.+1134   	; 0x13c8 <gc_execute_line+0x508>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.

    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
     f5a:	9f eb       	ldi	r25, 0xBF	; 191
     f5c:	91 0f       	add	r25, r17
     f5e:	9a 31       	cpi	r25, 0x1A	; 26
     f60:	10 f0       	brcs	.+4      	; 0xf66 <gc_execute_line+0xa6>
     f62:	0c 94 99 11 	jmp	0x2332	; 0x2332 <__stack+0x133>
    char_counter++;
     f66:	8f 5f       	subi	r24, 0xFF	; 255
     f68:	89 83       	std	Y+1, r24	; 0x01
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
     f6a:	ae 01       	movw	r20, r28
     f6c:	4e 5f       	subi	r20, 0xFE	; 254
     f6e:	5f 4f       	sbci	r21, 0xFF	; 255
     f70:	be 01       	movw	r22, r28
     f72:	6f 5f       	subi	r22, 0xFF	; 255
     f74:	7f 4f       	sbci	r23, 0xFF	; 255
     f76:	8f 8d       	ldd	r24, Y+31	; 0x1f
     f78:	98 a1       	ldd	r25, Y+32	; 0x20
     f7a:	0e 94 2d 2e 	call	0x5c5a	; 0x5c5a <read_float>
     f7e:	88 23       	and	r24, r24
     f80:	11 f4       	brne	.+4      	; 0xf86 <gc_execute_line+0xc6>
     f82:	0c 94 9b 11 	jmp	0x2336	; 0x2336 <__stack+0x137>
    // accurate than the NIST gcode requirement of x10 when used for commands, but not quite
    // accurate enough for value words that require integers to within 0.0001. This should be
    // a good enough comprimise and catch most all non-integer errors. To make it compliant,
    // we would simply need to change the mantissa to int16, but this add compiled flash space.
    // Maybe update this later.
    int_value = trunc(value);
     f86:	4a 80       	ldd	r4, Y+2	; 0x02
     f88:	5b 80       	ldd	r5, Y+3	; 0x03
     f8a:	6c 80       	ldd	r6, Y+4	; 0x04
     f8c:	7d 80       	ldd	r7, Y+5	; 0x05
     f8e:	c3 01       	movw	r24, r6
     f90:	b2 01       	movw	r22, r4
     f92:	0e 94 75 42 	call	0x84ea	; 0x84ea <trunc>
     f96:	0e 94 dd 3f 	call	0x7fba	; 0x7fba <__fixunssfsi>
     f9a:	a6 2e       	mov	r10, r22
    mantissa =  round(100*(value - int_value)); // Compute mantissa for Gxx.x commands.
     f9c:	70 e0       	ldi	r23, 0x00	; 0
     f9e:	80 e0       	ldi	r24, 0x00	; 0
     fa0:	90 e0       	ldi	r25, 0x00	; 0
     fa2:	0e 94 0b 40 	call	0x8016	; 0x8016 <__floatsisf>
     fa6:	9b 01       	movw	r18, r22
     fa8:	ac 01       	movw	r20, r24
     faa:	c3 01       	movw	r24, r6
     fac:	b2 01       	movw	r22, r4
     fae:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
     fb2:	20 e0       	ldi	r18, 0x00	; 0
     fb4:	30 e0       	ldi	r19, 0x00	; 0
     fb6:	48 ec       	ldi	r20, 0xC8	; 200
     fb8:	52 e4       	ldi	r21, 0x42	; 66
     fba:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
     fbe:	0e 94 0a 42 	call	0x8414	; 0x8414 <round>
     fc2:	0e 94 dd 3f 	call	0x7fba	; 0x7fba <__fixunssfsi>
     fc6:	86 2f       	mov	r24, r22
     fc8:	97 2f       	mov	r25, r23
     fca:	9c 01       	movw	r18, r24
    // NOTE: Rounding must be used to catch small floating point errors.

    // Check if the g-code word is supported or errors due to modal group violations or has
    // been repeated in the g-code block. If ok, update the command or record its value.
    switch(letter) {
     fcc:	17 34       	cpi	r17, 0x47	; 71
     fce:	21 f0       	breq	.+8      	; 0xfd8 <gc_execute_line+0x118>
     fd0:	1d 34       	cpi	r17, 0x4D	; 77
     fd2:	09 f4       	brne	.+2      	; 0xfd6 <gc_execute_line+0x116>
     fd4:	c9 c0       	rjmp	.+402    	; 0x1168 <gc_execute_line+0x2a8>
     fd6:	30 c1       	rjmp	.+608    	; 0x1238 <gc_execute_line+0x378>
      /* 'G' and 'M' Command Words: Parse commands and check for modal group violations.
         NOTE: Modal group numbers are defined in Table 4 of NIST RS274-NGC v3, pg.20 */

      case 'G':
        // Determine 'G' command and its modal group
        switch(int_value) {
     fd8:	8a 2d       	mov	r24, r10
     fda:	90 e0       	ldi	r25, 0x00	; 0
     fdc:	8f 35       	cpi	r24, 0x5F	; 95
     fde:	91 05       	cpc	r25, r1
     fe0:	10 f0       	brcs	.+4      	; 0xfe6 <gc_execute_line+0x126>
     fe2:	0c 94 9d 11 	jmp	0x233a	; 0x233a <__stack+0x13b>
     fe6:	fc 01       	movw	r30, r24
     fe8:	88 27       	eor	r24, r24
     fea:	ee 58       	subi	r30, 0x8E	; 142
     fec:	ff 4f       	sbci	r31, 0xFF	; 255
     fee:	8f 4f       	sbci	r24, 0xFF	; 255
     ff0:	0c 94 b6 42 	jmp	0x856c	; 0x856c <__tablejump2__>
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
     ff4:	21 15       	cp	r18, r1
     ff6:	31 05       	cpc	r19, r1
     ff8:	11 f0       	breq	.+4      	; 0xffe <gc_execute_line+0x13e>
     ffa:	0c 94 0b 12 	jmp	0x2416	; 0x2416 <__stack+0x217>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
     ffe:	4a a1       	ldd	r20, Y+34	; 0x22
    1000:	44 23       	and	r20, r20
    1002:	11 f4       	brne	.+4      	; 0x1008 <gc_execute_line+0x148>
    1004:	0c 94 13 12 	jmp	0x2426	; 0x2426 <__stack+0x227>
    1008:	0c 94 9f 11 	jmp	0x233e	; 0x233e <__stack+0x13f>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
    100c:	a6 e9       	ldi	r26, 0x96	; 150
    100e:	bc e0       	ldi	r27, 0x0C	; 12
    1010:	ac 92       	st	X, r10
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
    1012:	bc e1       	ldi	r27, 0x1C	; 28
    1014:	ab 16       	cp	r10, r27
    1016:	31 f0       	breq	.+12     	; 0x1024 <gc_execute_line+0x164>
    1018:	ee e1       	ldi	r30, 0x1E	; 30
    101a:	ae 16       	cp	r10, r30
    101c:	19 f0       	breq	.+6      	; 0x1024 <gc_execute_line+0x164>
    101e:	fc e5       	ldi	r31, 0x5C	; 92
    1020:	af 12       	cpse	r10, r31
    1022:	8b c0       	rjmp	.+278    	; 0x113a <gc_execute_line+0x27a>
              if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
    1024:	21 15       	cp	r18, r1
    1026:	31 05       	cpc	r19, r1
    1028:	51 f0       	breq	.+20     	; 0x103e <gc_execute_line+0x17e>
    102a:	2a 30       	cpi	r18, 0x0A	; 10
    102c:	31 05       	cpc	r19, r1
    102e:	39 f0       	breq	.+14     	; 0x103e <gc_execute_line+0x17e>
    1030:	0c 94 a1 11 	jmp	0x2342	; 0x2342 <__stack+0x143>
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
    1034:	21 e0       	ldi	r18, 0x01	; 1
    1036:	2a a3       	std	Y+34, r18	; 0x22
    1038:	02 c0       	rjmp	.+4      	; 0x103e <gc_execute_line+0x17e>
    103a:	31 e0       	ldi	r19, 0x01	; 1
    103c:	3a a3       	std	Y+34, r19	; 0x22
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
              if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
              gc_block.non_modal_command += mantissa;
    103e:	6a 0d       	add	r22, r10
    1040:	a6 e9       	ldi	r26, 0x96	; 150
    1042:	bc e0       	ldi	r27, 0x0C	; 12
    1044:	6c 93       	st	X, r22
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
    1046:	80 e0       	ldi	r24, 0x00	; 0
    1048:	7f c0       	rjmp	.+254    	; 0x1148 <gc_execute_line+0x288>
            }                
            break;
          case 0: case 1: case 2: case 3: case 38:
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    104a:	ba a1       	ldd	r27, Y+34	; 0x22
    104c:	b1 11       	cpse	r27, r1
    104e:	0c 94 a3 11 	jmp	0x2346	; 0x2346 <__stack+0x147>
            axis_command = AXIS_COMMAND_MOTION_MODE;
    1052:	e2 e0       	ldi	r30, 0x02	; 2
    1054:	ea a3       	std	Y+34, r30	; 0x22
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
            gc_block.modal.motion = int_value;
    1056:	a0 92 97 0c 	sts	0x0C97, r10	; 0x800c97 <gc_block+0x1>
            if (int_value == 38){
    105a:	f6 e2       	ldi	r31, 0x26	; 38
    105c:	af 12       	cpse	r10, r31
    105e:	6f c0       	rjmp	.+222    	; 0x113e <gc_execute_line+0x27e>
              if (!((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))) {
    1060:	24 31       	cpi	r18, 0x14	; 20
    1062:	31 05       	cpc	r19, r1
    1064:	59 f0       	breq	.+22     	; 0x107c <gc_execute_line+0x1bc>
    1066:	2e 31       	cpi	r18, 0x1E	; 30
    1068:	31 05       	cpc	r19, r1
    106a:	41 f0       	breq	.+16     	; 0x107c <gc_execute_line+0x1bc>
    106c:	28 32       	cpi	r18, 0x28	; 40
    106e:	31 05       	cpc	r19, r1
    1070:	29 f0       	breq	.+10     	; 0x107c <gc_execute_line+0x1bc>
    1072:	22 33       	cpi	r18, 0x32	; 50
    1074:	31 05       	cpc	r19, r1
    1076:	11 f0       	breq	.+4      	; 0x107c <gc_execute_line+0x1bc>
    1078:	0c 94 a5 11 	jmp	0x234a	; 0x234a <__stack+0x14b>
                FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
              }
              gc_block.modal.motion += (mantissa/10)+100;
    107c:	26 2f       	mov	r18, r22
    107e:	37 2f       	mov	r19, r23
    1080:	ad ec       	ldi	r26, 0xCD	; 205
    1082:	bc ec       	ldi	r27, 0xCC	; 204
    1084:	0e 94 be 42 	call	0x857c	; 0x857c <__umulhisi3>
    1088:	96 95       	lsr	r25
    108a:	87 95       	ror	r24
    108c:	96 95       	lsr	r25
    108e:	87 95       	ror	r24
    1090:	96 95       	lsr	r25
    1092:	87 95       	ror	r24
    1094:	86 57       	subi	r24, 0x76	; 118
    1096:	80 93 97 0c 	sts	0x0C97, r24	; 0x800c97 <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE;
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
    109a:	81 e0       	ldi	r24, 0x01	; 1
    109c:	55 c0       	rjmp	.+170    	; 0x1148 <gc_execute_line+0x288>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
            }  
            break;
          case 17: case 18: case 19:
            word_bit = MODAL_GROUP_G2;
            gc_block.modal.plane_select = int_value - 17;
    109e:	6f ee       	ldi	r22, 0xEF	; 239
    10a0:	6a 0d       	add	r22, r10
    10a2:	60 93 9b 0c 	sts	0x0C9B, r22	; 0x800c9b <gc_block+0x5>
              gc_block.modal.motion += (mantissa/10)+100;
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
            }  
            break;
          case 17: case 18: case 19:
            word_bit = MODAL_GROUP_G2;
    10a6:	82 e0       	ldi	r24, 0x02	; 2
            gc_block.modal.plane_select = int_value - 17;
            break;
    10a8:	4b c0       	rjmp	.+150    	; 0x1140 <gc_execute_line+0x280>
          case 90: case 91:
            if (mantissa == 0) {
    10aa:	21 15       	cp	r18, r1
    10ac:	31 05       	cpc	r19, r1
    10ae:	31 f4       	brne	.+12     	; 0x10bc <gc_execute_line+0x1fc>
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
    10b0:	66 ea       	ldi	r22, 0xA6	; 166
    10b2:	6a 0d       	add	r22, r10
    10b4:	60 93 9a 0c 	sts	0x0C9A, r22	; 0x800c9a <gc_block+0x4>
            word_bit = MODAL_GROUP_G2;
            gc_block.modal.plane_select = int_value - 17;
            break;
          case 90: case 91:
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
    10b8:	83 e0       	ldi	r24, 0x03	; 3
    10ba:	46 c0       	rjmp	.+140    	; 0x1148 <gc_execute_line+0x288>
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
    10bc:	2a 30       	cpi	r18, 0x0A	; 10
    10be:	31 05       	cpc	r19, r1
    10c0:	11 f0       	breq	.+4      	; 0x10c6 <gc_execute_line+0x206>
    10c2:	0c 94 a7 11 	jmp	0x234e	; 0x234e <__stack+0x14f>
    10c6:	2a e5       	ldi	r18, 0x5A	; 90
    10c8:	a2 16       	cp	r10, r18
    10ca:	11 f4       	brne	.+4      	; 0x10d0 <gc_execute_line+0x210>
    10cc:	0c 94 a9 11 	jmp	0x2352	; 0x2352 <__stack+0x153>
          case 90: case 91:
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
    10d0:	84 e0       	ldi	r24, 0x04	; 4
    10d2:	3a c0       	rjmp	.+116    	; 0x1148 <gc_execute_line+0x288>
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
            gc_block.modal.feed_rate = 94 - int_value;
    10d4:	8e e5       	ldi	r24, 0x5E	; 94
    10d6:	8a 19       	sub	r24, r10
    10d8:	80 93 98 0c 	sts	0x0C98, r24	; 0x800c98 <gc_block+0x2>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
    10dc:	85 e0       	ldi	r24, 0x05	; 5
            gc_block.modal.feed_rate = 94 - int_value;
            break;
    10de:	30 c0       	rjmp	.+96     	; 0x1140 <gc_execute_line+0x280>
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
            gc_block.modal.units = 21 - int_value;
    10e0:	85 e1       	ldi	r24, 0x15	; 21
    10e2:	8a 19       	sub	r24, r10
    10e4:	80 93 99 0c 	sts	0x0C99, r24	; 0x800c99 <gc_block+0x3>
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
            gc_block.modal.feed_rate = 94 - int_value;
            break;
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
    10e8:	86 e0       	ldi	r24, 0x06	; 6
            gc_block.modal.units = 21 - int_value;
            break;
    10ea:	2a c0       	rjmp	.+84     	; 0x1140 <gc_execute_line+0x280>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
    10ec:	4a a1       	ldd	r20, Y+34	; 0x22
    10ee:	41 11       	cpse	r20, r1
    10f0:	0c 94 ab 11 	jmp	0x2356	; 0x2356 <__stack+0x157>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
    10f4:	81 e3       	ldi	r24, 0x31	; 49
    10f6:	a8 12       	cpse	r10, r24
    10f8:	06 c0       	rjmp	.+12     	; 0x1106 <gc_execute_line+0x246>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
    10fa:	10 92 9c 0c 	sts	0x0C9C, r1	; 0x800c9c <gc_block+0x6>
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
    10fe:	88 e0       	ldi	r24, 0x08	; 8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
    1100:	93 e0       	ldi	r25, 0x03	; 3
    1102:	9a a3       	std	Y+34, r25	; 0x22
    1104:	21 c0       	rjmp	.+66     	; 0x1148 <gc_execute_line+0x288>
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
            } else if (mantissa == 10) { // G43.1
    1106:	2a 30       	cpi	r18, 0x0A	; 10
    1108:	31 05       	cpc	r19, r1
    110a:	11 f0       	breq	.+4      	; 0x1110 <gc_execute_line+0x250>
    110c:	0c 94 ad 11 	jmp	0x235a	; 0x235a <__stack+0x15b>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
    1110:	a1 e0       	ldi	r26, 0x01	; 1
    1112:	a0 93 9c 0c 	sts	0x0C9C, r26	; 0x800c9c <gc_block+0x6>
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
    1116:	88 e0       	ldi	r24, 0x08	; 8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
    1118:	b3 e0       	ldi	r27, 0x03	; 3
    111a:	ba a3       	std	Y+34, r27	; 0x22
    111c:	15 c0       	rjmp	.+42     	; 0x1148 <gc_execute_line+0x288>
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59:
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
    111e:	6a ec       	ldi	r22, 0xCA	; 202
    1120:	6a 0d       	add	r22, r10
    1122:	60 93 9d 0c 	sts	0x0C9D, r22	; 0x800c9d <gc_block+0x7>
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59:
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
    1126:	89 e0       	ldi	r24, 0x09	; 9
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
            break;
    1128:	0b c0       	rjmp	.+22     	; 0x1140 <gc_execute_line+0x280>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
    112a:	23 2b       	or	r18, r19
    112c:	11 f0       	breq	.+4      	; 0x1132 <gc_execute_line+0x272>
    112e:	0c 94 af 11 	jmp	0x235e	; 0x235e <__stack+0x15f>
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
    1132:	8a e0       	ldi	r24, 0x0A	; 10
    1134:	09 c0       	rjmp	.+18     	; 0x1148 <gc_execute_line+0x288>
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
            gc_block.modal.units = 21 - int_value;
            break;
          case 40:
            word_bit = MODAL_GROUP_G7;
    1136:	87 e0       	ldi	r24, 0x07	; 7
    1138:	03 c0       	rjmp	.+6      	; 0x1140 <gc_execute_line+0x280>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
    113a:	80 e0       	ldi	r24, 0x00	; 0
    113c:	01 c0       	rjmp	.+2      	; 0x1140 <gc_execute_line+0x280>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE;
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
    113e:	81 e0       	ldi	r24, 0x01	; 1
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    1140:	23 2b       	or	r18, r19
    1142:	11 f0       	breq	.+4      	; 0x1148 <gc_execute_line+0x288>
    1144:	0c 94 b1 11 	jmp	0x2362	; 0x2362 <__stack+0x163>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1148:	f6 01       	movw	r30, r12
    114a:	02 c0       	rjmp	.+4      	; 0x1150 <gc_execute_line+0x290>
    114c:	ee 0f       	add	r30, r30
    114e:	ff 1f       	adc	r31, r31
    1150:	8a 95       	dec	r24
    1152:	e2 f7       	brpl	.-8      	; 0x114c <gc_execute_line+0x28c>
    1154:	97 01       	movw	r18, r14
    1156:	2e 23       	and	r18, r30
    1158:	3f 23       	and	r19, r31
    115a:	23 2b       	or	r18, r19
    115c:	11 f0       	breq	.+4      	; 0x1162 <gc_execute_line+0x2a2>
    115e:	0c 94 b3 11 	jmp	0x2366	; 0x2366 <__stack+0x167>
        command_words |= bit(word_bit);
    1162:	ee 2a       	or	r14, r30
    1164:	ff 2a       	or	r15, r31
        break;
    1166:	30 c1       	rjmp	.+608    	; 0x13c8 <gc_execute_line+0x508>

      case 'M':

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    1168:	23 2b       	or	r18, r19
    116a:	11 f0       	breq	.+4      	; 0x1170 <gc_execute_line+0x2b0>
    116c:	0c 94 b5 11 	jmp	0x236a	; 0x236a <__stack+0x16b>
        switch(int_value) {
    1170:	8a 2d       	mov	r24, r10
    1172:	90 e0       	ldi	r25, 0x00	; 0
    1174:	8f 31       	cpi	r24, 0x1F	; 31
    1176:	91 05       	cpc	r25, r1
    1178:	10 f0       	brcs	.+4      	; 0x117e <gc_execute_line+0x2be>
    117a:	0c 94 b7 11 	jmp	0x236e	; 0x236e <__stack+0x16f>
    117e:	fc 01       	movw	r30, r24
    1180:	88 27       	eor	r24, r24
    1182:	ef 52       	subi	r30, 0x2F	; 47
    1184:	ff 4f       	sbci	r31, 0xFF	; 255
    1186:	8f 4f       	sbci	r24, 0xFF	; 255
    1188:	0c 94 b6 42 	jmp	0x856c	; 0x856c <__tablejump2__>
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
            switch(int_value) {
    118c:	aa 20       	and	r10, r10
    118e:	21 f0       	breq	.+8      	; 0x1198 <gc_execute_line+0x2d8>
    1190:	f1 e0       	ldi	r31, 0x01	; 1
    1192:	af 16       	cp	r10, r31
    1194:	e1 f1       	breq	.+120    	; 0x120e <gc_execute_line+0x34e>
    1196:	05 c0       	rjmp	.+10     	; 0x11a2 <gc_execute_line+0x2e2>
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
    1198:	23 e0       	ldi	r18, 0x03	; 3
    119a:	20 93 9e 0c 	sts	0x0C9E, r18	; 0x800c9e <gc_block+0x8>

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
    119e:	8b e0       	ldi	r24, 0x0B	; 11
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
    11a0:	3b c0       	rjmp	.+118    	; 0x1218 <gc_execute_line+0x358>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
    11a2:	a0 92 9e 0c 	sts	0x0C9E, r10	; 0x800c9e <gc_block+0x8>

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
    11a6:	8b e0       	ldi	r24, 0x0B	; 11
    11a8:	37 c0       	rjmp	.+110    	; 0x1218 <gc_execute_line+0x358>
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
            switch(int_value) {
    11aa:	34 e0       	ldi	r19, 0x04	; 4
    11ac:	a3 16       	cp	r10, r19
    11ae:	59 f0       	breq	.+22     	; 0x11c6 <gc_execute_line+0x306>
    11b0:	45 e0       	ldi	r20, 0x05	; 5
    11b2:	a4 16       	cp	r10, r20
    11b4:	69 f0       	breq	.+26     	; 0x11d0 <gc_execute_line+0x310>
    11b6:	83 e0       	ldi	r24, 0x03	; 3
    11b8:	a8 12       	cpse	r10, r24
    11ba:	2b c0       	rjmp	.+86     	; 0x1212 <gc_execute_line+0x352>
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    11bc:	80 e1       	ldi	r24, 0x10	; 16
    11be:	80 93 a0 0c 	sts	0x0CA0, r24	; 0x800ca0 <gc_block+0xa>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
    11c2:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    11c4:	29 c0       	rjmp	.+82     	; 0x1218 <gc_execute_line+0x358>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    11c6:	80 e2       	ldi	r24, 0x20	; 32
    11c8:	80 93 a0 0c 	sts	0x0CA0, r24	; 0x800ca0 <gc_block+0xa>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
    11cc:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    11ce:	24 c0       	rjmp	.+72     	; 0x1218 <gc_execute_line+0x358>
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    11d0:	10 92 a0 0c 	sts	0x0CA0, r1	; 0x800ca0 <gc_block+0xa>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
    11d4:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    11d6:	20 c0       	rjmp	.+64     	; 0x1218 <gc_execute_line+0x358>
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
            switch(int_value) {      
    11d8:	98 e0       	ldi	r25, 0x08	; 8
    11da:	a9 16       	cp	r10, r25
    11dc:	69 f0       	breq	.+26     	; 0x11f8 <gc_execute_line+0x338>
    11de:	a9 e0       	ldi	r26, 0x09	; 9
    11e0:	aa 16       	cp	r10, r26
    11e2:	89 f0       	breq	.+34     	; 0x1206 <gc_execute_line+0x346>
    11e4:	b7 e0       	ldi	r27, 0x07	; 7
    11e6:	ab 12       	cpse	r10, r27
    11e8:	16 c0       	rjmp	.+44     	; 0x1216 <gc_execute_line+0x356>
              case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
    11ea:	80 91 9f 0c 	lds	r24, 0x0C9F	; 0x800c9f <gc_block+0x9>
    11ee:	80 68       	ori	r24, 0x80	; 128
    11f0:	80 93 9f 0c 	sts	0x0C9F, r24	; 0x800c9f <gc_block+0x9>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    11f4:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {      
              case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
    11f6:	10 c0       	rjmp	.+32     	; 0x1218 <gc_execute_line+0x358>
              case 8: gc_block.modal.coolant |= COOLANT_FLOOD_ENABLE; break;
    11f8:	80 91 9f 0c 	lds	r24, 0x0C9F	; 0x800c9f <gc_block+0x9>
    11fc:	80 64       	ori	r24, 0x40	; 64
    11fe:	80 93 9f 0c 	sts	0x0C9F, r24	; 0x800c9f <gc_block+0x9>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1202:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {      
              case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
              case 8: gc_block.modal.coolant |= COOLANT_FLOOD_ENABLE; break;
    1204:	09 c0       	rjmp	.+18     	; 0x1218 <gc_execute_line+0x358>
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break; // M9 disables both M7 and M8.
    1206:	10 92 9f 0c 	sts	0x0C9F, r1	; 0x800c9f <gc_block+0x9>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    120a:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {      
              case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
              case 8: gc_block.modal.coolant |= COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break; // M9 disables both M7 and M8.
    120c:	05 c0       	rjmp	.+10     	; 0x1218 <gc_execute_line+0x358>

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
    120e:	8b e0       	ldi	r24, 0x0B	; 11
    1210:	03 c0       	rjmp	.+6      	; 0x1218 <gc_execute_line+0x358>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
    1212:	8c e0       	ldi	r24, 0x0C	; 12
    1214:	01 c0       	rjmp	.+2      	; 0x1218 <gc_execute_line+0x358>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1216:	8d e0       	ldi	r24, 0x0D	; 13
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
        }

        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1218:	f6 01       	movw	r30, r12
    121a:	02 c0       	rjmp	.+4      	; 0x1220 <gc_execute_line+0x360>
    121c:	ee 0f       	add	r30, r30
    121e:	ff 1f       	adc	r31, r31
    1220:	8a 95       	dec	r24
    1222:	e2 f7       	brpl	.-8      	; 0x121c <gc_execute_line+0x35c>
    1224:	97 01       	movw	r18, r14
    1226:	2e 23       	and	r18, r30
    1228:	3f 23       	and	r19, r31
    122a:	23 2b       	or	r18, r19
    122c:	11 f0       	breq	.+4      	; 0x1232 <gc_execute_line+0x372>
    122e:	0c 94 b9 11 	jmp	0x2372	; 0x2372 <__stack+0x173>
        command_words |= bit(word_bit);
    1232:	ee 2a       	or	r14, r30
    1234:	ff 2a       	or	r15, r31
        break;
    1236:	c8 c0       	rjmp	.+400    	; 0x13c8 <gc_execute_line+0x508>
      default:

        /* Non-Command Words: This initial parsing phase only checks for repeats of the remaining
           legal g-code words and stores their value. Error-checking is performed later since some
           words (I,J,K,L,P,R) have multiple connotations and/or depend on the issued commands. */
        switch(letter){
    1238:	81 2f       	mov	r24, r17
    123a:	90 e0       	ldi	r25, 0x00	; 0
    123c:	fc 01       	movw	r30, r24
    123e:	e6 54       	subi	r30, 0x46	; 70
    1240:	f1 09       	sbc	r31, r1
    1242:	e5 31       	cpi	r30, 0x15	; 21
    1244:	f1 05       	cpc	r31, r1
    1246:	10 f0       	brcs	.+4      	; 0x124c <gc_execute_line+0x38c>
    1248:	0c 94 bb 11 	jmp	0x2376	; 0x2376 <__stack+0x177>
    124c:	88 27       	eor	r24, r24
    124e:	e0 51       	subi	r30, 0x10	; 16
    1250:	ff 4f       	sbci	r31, 0xFF	; 255
    1252:	8f 4f       	sbci	r24, 0xFF	; 255
    1254:	0c 94 b6 42 	jmp	0x856c	; 0x856c <__tablejump2__>
          // case 'A': // Not supported
          // case 'B': // Not supported
          // case 'C': // Not supported
          // case 'D': // Not supported
          case 'F': word_bit = WORD_F; gc_block.values.f = value; break;
    1258:	40 92 a2 0c 	sts	0x0CA2, r4	; 0x800ca2 <gc_block+0xc>
    125c:	50 92 a3 0c 	sts	0x0CA3, r5	; 0x800ca3 <gc_block+0xd>
    1260:	60 92 a4 0c 	sts	0x0CA4, r6	; 0x800ca4 <gc_block+0xe>
    1264:	70 92 a5 0c 	sts	0x0CA5, r7	; 0x800ca5 <gc_block+0xf>
    1268:	80 e0       	ldi	r24, 0x00	; 0
    126a:	8d c0       	rjmp	.+282    	; 0x1386 <gc_execute_line+0x4c6>
          // case 'H': // Not supported
          case 'I': word_bit = WORD_I; gc_block.values.ijk[X_AXIS] = value; ijk_words |= (1<<X_AXIS); break;
    126c:	40 92 a6 0c 	sts	0x0CA6, r4	; 0x800ca6 <gc_block+0x10>
    1270:	50 92 a7 0c 	sts	0x0CA7, r5	; 0x800ca7 <gc_block+0x11>
    1274:	60 92 a8 0c 	sts	0x0CA8, r6	; 0x800ca8 <gc_block+0x12>
    1278:	70 92 a9 0c 	sts	0x0CA9, r7	; 0x800ca9 <gc_block+0x13>
    127c:	fb a1       	ldd	r31, Y+35	; 0x23
    127e:	f1 60       	ori	r31, 0x01	; 1
    1280:	fb a3       	std	Y+35, r31	; 0x23
    1282:	81 e0       	ldi	r24, 0x01	; 1
    1284:	80 c0       	rjmp	.+256    	; 0x1386 <gc_execute_line+0x4c6>
          case 'J': word_bit = WORD_J; gc_block.values.ijk[Y_AXIS] = value; ijk_words |= (1<<Y_AXIS); break;
    1286:	40 92 aa 0c 	sts	0x0CAA, r4	; 0x800caa <gc_block+0x14>
    128a:	50 92 ab 0c 	sts	0x0CAB, r5	; 0x800cab <gc_block+0x15>
    128e:	60 92 ac 0c 	sts	0x0CAC, r6	; 0x800cac <gc_block+0x16>
    1292:	70 92 ad 0c 	sts	0x0CAD, r7	; 0x800cad <gc_block+0x17>
    1296:	2b a1       	ldd	r18, Y+35	; 0x23
    1298:	22 60       	ori	r18, 0x02	; 2
    129a:	2b a3       	std	Y+35, r18	; 0x23
    129c:	82 e0       	ldi	r24, 0x02	; 2
    129e:	73 c0       	rjmp	.+230    	; 0x1386 <gc_execute_line+0x4c6>
          case 'K': word_bit = WORD_K; gc_block.values.ijk[Z_AXIS] = value; ijk_words |= (1<<Z_AXIS); break;
    12a0:	40 92 ae 0c 	sts	0x0CAE, r4	; 0x800cae <gc_block+0x18>
    12a4:	50 92 af 0c 	sts	0x0CAF, r5	; 0x800caf <gc_block+0x19>
    12a8:	60 92 b0 0c 	sts	0x0CB0, r6	; 0x800cb0 <gc_block+0x1a>
    12ac:	70 92 b1 0c 	sts	0x0CB1, r7	; 0x800cb1 <gc_block+0x1b>
    12b0:	3b a1       	ldd	r19, Y+35	; 0x23
    12b2:	34 60       	ori	r19, 0x04	; 4
    12b4:	3b a3       	std	Y+35, r19	; 0x23
    12b6:	83 e0       	ldi	r24, 0x03	; 3
    12b8:	66 c0       	rjmp	.+204    	; 0x1386 <gc_execute_line+0x4c6>
          case 'L': word_bit = WORD_L; gc_block.values.l = int_value; break;
    12ba:	a0 92 b2 0c 	sts	0x0CB2, r10	; 0x800cb2 <gc_block+0x1c>
    12be:	84 e0       	ldi	r24, 0x04	; 4
    12c0:	62 c0       	rjmp	.+196    	; 0x1386 <gc_execute_line+0x4c6>
          case 'N': word_bit = WORD_N; gc_block.values.n = trunc(value); break;
    12c2:	c3 01       	movw	r24, r6
    12c4:	b2 01       	movw	r22, r4
    12c6:	0e 94 d8 3f 	call	0x7fb0	; 0x7fb0 <__fixsfsi>
    12ca:	60 93 b3 0c 	sts	0x0CB3, r22	; 0x800cb3 <gc_block+0x1d>
    12ce:	70 93 b4 0c 	sts	0x0CB4, r23	; 0x800cb4 <gc_block+0x1e>
    12d2:	80 93 b5 0c 	sts	0x0CB5, r24	; 0x800cb5 <gc_block+0x1f>
    12d6:	90 93 b6 0c 	sts	0x0CB6, r25	; 0x800cb6 <gc_block+0x20>
    12da:	85 e0       	ldi	r24, 0x05	; 5
    12dc:	54 c0       	rjmp	.+168    	; 0x1386 <gc_execute_line+0x4c6>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
    12de:	40 92 b7 0c 	sts	0x0CB7, r4	; 0x800cb7 <gc_block+0x21>
    12e2:	50 92 b8 0c 	sts	0x0CB8, r5	; 0x800cb8 <gc_block+0x22>
    12e6:	60 92 b9 0c 	sts	0x0CB9, r6	; 0x800cb9 <gc_block+0x23>
    12ea:	70 92 ba 0c 	sts	0x0CBA, r7	; 0x800cba <gc_block+0x24>
    12ee:	86 e0       	ldi	r24, 0x06	; 6
    12f0:	4a c0       	rjmp	.+148    	; 0x1386 <gc_execute_line+0x4c6>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
    12f2:	40 92 bb 0c 	sts	0x0CBB, r4	; 0x800cbb <gc_block+0x25>
    12f6:	50 92 bc 0c 	sts	0x0CBC, r5	; 0x800cbc <gc_block+0x26>
    12fa:	60 92 bd 0c 	sts	0x0CBD, r6	; 0x800cbd <gc_block+0x27>
    12fe:	70 92 be 0c 	sts	0x0CBE, r7	; 0x800cbe <gc_block+0x28>
    1302:	87 e0       	ldi	r24, 0x07	; 7
    1304:	40 c0       	rjmp	.+128    	; 0x1386 <gc_execute_line+0x4c6>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
    1306:	40 92 bf 0c 	sts	0x0CBF, r4	; 0x800cbf <gc_block+0x29>
    130a:	50 92 c0 0c 	sts	0x0CC0, r5	; 0x800cc0 <gc_block+0x2a>
    130e:	60 92 c1 0c 	sts	0x0CC1, r6	; 0x800cc1 <gc_block+0x2b>
    1312:	70 92 c2 0c 	sts	0x0CC2, r7	; 0x800cc2 <gc_block+0x2c>
    1316:	88 e0       	ldi	r24, 0x08	; 8
    1318:	36 c0       	rjmp	.+108    	; 0x1386 <gc_execute_line+0x4c6>
          case 'T': word_bit = WORD_T; 
						if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
    131a:	20 e0       	ldi	r18, 0x00	; 0
    131c:	30 e0       	ldi	r19, 0x00	; 0
    131e:	4f e7       	ldi	r20, 0x7F	; 127
    1320:	53 e4       	ldi	r21, 0x43	; 67
    1322:	c3 01       	movw	r24, r6
    1324:	b2 01       	movw	r22, r4
    1326:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    132a:	18 16       	cp	r1, r24
    132c:	14 f4       	brge	.+4      	; 0x1332 <gc_execute_line+0x472>
    132e:	0c 94 bd 11 	jmp	0x237a	; 0x237a <__stack+0x17b>
						gc_block.values.t = int_value;
    1332:	a0 92 c3 0c 	sts	0x0CC3, r10	; 0x800cc3 <gc_block+0x2d>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; 
    1336:	89 e0       	ldi	r24, 0x09	; 9
						if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
						gc_block.values.t = int_value;
						break;
    1338:	26 c0       	rjmp	.+76     	; 0x1386 <gc_execute_line+0x4c6>
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
    133a:	40 92 c4 0c 	sts	0x0CC4, r4	; 0x800cc4 <gc_block+0x2e>
    133e:	50 92 c5 0c 	sts	0x0CC5, r5	; 0x800cc5 <gc_block+0x2f>
    1342:	60 92 c6 0c 	sts	0x0CC6, r6	; 0x800cc6 <gc_block+0x30>
    1346:	70 92 c7 0c 	sts	0x0CC7, r7	; 0x800cc7 <gc_block+0x31>
    134a:	49 a1       	ldd	r20, Y+33	; 0x21
    134c:	41 60       	ori	r20, 0x01	; 1
    134e:	49 a3       	std	Y+33, r20	; 0x21
    1350:	8a e0       	ldi	r24, 0x0A	; 10
    1352:	19 c0       	rjmp	.+50     	; 0x1386 <gc_execute_line+0x4c6>
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
    1354:	40 92 c8 0c 	sts	0x0CC8, r4	; 0x800cc8 <gc_block+0x32>
    1358:	50 92 c9 0c 	sts	0x0CC9, r5	; 0x800cc9 <gc_block+0x33>
    135c:	60 92 ca 0c 	sts	0x0CCA, r6	; 0x800cca <gc_block+0x34>
    1360:	70 92 cb 0c 	sts	0x0CCB, r7	; 0x800ccb <gc_block+0x35>
    1364:	89 a1       	ldd	r24, Y+33	; 0x21
    1366:	82 60       	ori	r24, 0x02	; 2
    1368:	89 a3       	std	Y+33, r24	; 0x21
    136a:	8b e0       	ldi	r24, 0x0B	; 11
    136c:	0c c0       	rjmp	.+24     	; 0x1386 <gc_execute_line+0x4c6>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
    136e:	40 92 cc 0c 	sts	0x0CCC, r4	; 0x800ccc <gc_block+0x36>
    1372:	50 92 cd 0c 	sts	0x0CCD, r5	; 0x800ccd <gc_block+0x37>
    1376:	60 92 ce 0c 	sts	0x0CCE, r6	; 0x800cce <gc_block+0x38>
    137a:	70 92 cf 0c 	sts	0x0CCF, r7	; 0x800ccf <gc_block+0x39>
    137e:	99 a1       	ldd	r25, Y+33	; 0x21
    1380:	94 60       	ori	r25, 0x04	; 4
    1382:	99 a3       	std	Y+33, r25	; 0x21
    1384:	8c e0       	ldi	r24, 0x0C	; 12
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        }

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    1386:	56 01       	movw	r10, r12
    1388:	08 2e       	mov	r0, r24
    138a:	02 c0       	rjmp	.+4      	; 0x1390 <gc_execute_line+0x4d0>
    138c:	aa 0c       	add	r10, r10
    138e:	bb 1c       	adc	r11, r11
    1390:	0a 94       	dec	r0
    1392:	e2 f7       	brpl	.-8      	; 0x138c <gc_execute_line+0x4cc>
    1394:	91 01       	movw	r18, r2
    1396:	2a 21       	and	r18, r10
    1398:	3b 21       	and	r19, r11
    139a:	23 2b       	or	r18, r19
    139c:	09 f0       	breq	.+2      	; 0x13a0 <gc_execute_line+0x4e0>
    139e:	ef c7       	rjmp	.+4062   	; 0x237e <__stack+0x17f>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
    13a0:	d4 01       	movw	r26, r8
    13a2:	02 c0       	rjmp	.+4      	; 0x13a8 <gc_execute_line+0x4e8>
    13a4:	b5 95       	asr	r27
    13a6:	a7 95       	ror	r26
    13a8:	8a 95       	dec	r24
    13aa:	e2 f7       	brpl	.-8      	; 0x13a4 <gc_execute_line+0x4e4>
    13ac:	a0 ff       	sbrs	r26, 0
    13ae:	0a c0       	rjmp	.+20     	; 0x13c4 <gc_execute_line+0x504>
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    13b0:	20 e0       	ldi	r18, 0x00	; 0
    13b2:	30 e0       	ldi	r19, 0x00	; 0
    13b4:	a9 01       	movw	r20, r18
    13b6:	c3 01       	movw	r24, r6
    13b8:	b2 01       	movw	r22, r4
    13ba:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    13be:	88 23       	and	r24, r24
    13c0:	0c f4       	brge	.+2      	; 0x13c4 <gc_execute_line+0x504>
    13c2:	df c7       	rjmp	.+4030   	; 0x2382 <__stack+0x183>
        }
        value_words |= bit(word_bit); // Flag to indicate parameter assigned.
    13c4:	2a 28       	or	r2, r10
    13c6:	3b 28       	or	r3, r11
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
  else { char_counter = 0; }

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    13c8:	89 81       	ldd	r24, Y+1	; 0x01
    13ca:	ef 8d       	ldd	r30, Y+31	; 0x1f
    13cc:	f8 a1       	ldd	r31, Y+32	; 0x20
    13ce:	e8 0f       	add	r30, r24
    13d0:	f1 1d       	adc	r31, r1
    13d2:	10 81       	ld	r17, Z
    13d4:	11 11       	cpse	r17, r1
    13d6:	c1 cd       	rjmp	.-1150   	; 0xf5a <gc_execute_line+0x9a>

  // [0. Non-specific/common error-checks and miscellaneous setup]:

  // Determine implicit axis command conditions. Axis words have been passed, but no explicit axis
  // command has been sent. If so, set axis command to current motion mode.
  if (axis_words) {
    13d8:	b9 a1       	ldd	r27, Y+33	; 0x21
    13da:	bb 23       	and	r27, r27
    13dc:	29 f0       	breq	.+10     	; 0x13e8 <gc_execute_line+0x528>
    if (!axis_command) { axis_command = AXIS_COMMAND_MOTION_MODE; } // Assign implicit motion-mode
    13de:	ea a1       	ldd	r30, Y+34	; 0x22
    13e0:	e1 11       	cpse	r30, r1
    13e2:	02 c0       	rjmp	.+4      	; 0x13e8 <gc_execute_line+0x528>
    13e4:	f2 e0       	ldi	r31, 0x02	; 2
    13e6:	fa a3       	std	Y+34, r31	; 0x22
  }

  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    13e8:	25 fe       	sbrs	r2, 5
    13ea:	0e c0       	rjmp	.+28     	; 0x1408 <gc_execute_line+0x548>
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    13ec:	80 91 b3 0c 	lds	r24, 0x0CB3	; 0x800cb3 <gc_block+0x1d>
    13f0:	90 91 b4 0c 	lds	r25, 0x0CB4	; 0x800cb4 <gc_block+0x1e>
    13f4:	a0 91 b5 0c 	lds	r26, 0x0CB5	; 0x800cb5 <gc_block+0x1f>
    13f8:	b0 91 b6 0c 	lds	r27, 0x0CB6	; 0x800cb6 <gc_block+0x20>
    13fc:	81 38       	cpi	r24, 0x81	; 129
    13fe:	96 49       	sbci	r25, 0x96	; 150
    1400:	a8 49       	sbci	r26, 0x98	; 152
    1402:	b1 05       	cpc	r27, r1
    1404:	0c f0       	brlt	.+2      	; 0x1408 <gc_execute_line+0x548>
    1406:	bf c7       	rjmp	.+3966   	; 0x2386 <__stack+0x187>
  // [1. Comments ]: MSG's NOT SUPPORTED. Comment handling performed by protocol.

  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  // NOTE: For jogging, ignore prior feed rate mode. Enforce G94 and check for required F word.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    1408:	3c a1       	ldd	r19, Y+36	; 0x24
    140a:	33 23       	and	r19, r19
    140c:	e1 f0       	breq	.+56     	; 0x1446 <gc_execute_line+0x586>
    if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); }
    140e:	20 fe       	sbrs	r2, 0
    1410:	bc c7       	rjmp	.+3960   	; 0x238a <__stack+0x18b>
    if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    1412:	80 91 99 0c 	lds	r24, 0x0C99	; 0x800c99 <gc_block+0x3>
    1416:	81 30       	cpi	r24, 0x01	; 1
    1418:	09 f0       	breq	.+2      	; 0x141c <gc_execute_line+0x55c>
    141a:	54 c0       	rjmp	.+168    	; 0x14c4 <gc_execute_line+0x604>
    141c:	06 e9       	ldi	r16, 0x96	; 150
    141e:	1c e0       	ldi	r17, 0x0C	; 12
    1420:	23 e3       	ldi	r18, 0x33	; 51
    1422:	33 e3       	ldi	r19, 0x33	; 51
    1424:	4b ec       	ldi	r20, 0xCB	; 203
    1426:	51 e4       	ldi	r21, 0x41	; 65
    1428:	d8 01       	movw	r26, r16
    142a:	1c 96       	adiw	r26, 0x0c	; 12
    142c:	6d 91       	ld	r22, X+
    142e:	7d 91       	ld	r23, X+
    1430:	8d 91       	ld	r24, X+
    1432:	9c 91       	ld	r25, X
    1434:	1f 97       	sbiw	r26, 0x0f	; 15
    1436:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    143a:	f8 01       	movw	r30, r16
    143c:	64 87       	std	Z+12, r22	; 0x0c
    143e:	75 87       	std	Z+13, r23	; 0x0d
    1440:	86 87       	std	Z+14, r24	; 0x0e
    1442:	97 87       	std	Z+15, r25	; 0x0f
    1444:	3f c0       	rjmp	.+126    	; 0x14c4 <gc_execute_line+0x604>
  } else {
    if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    1446:	80 91 98 0c 	lds	r24, 0x0C98	; 0x800c98 <gc_block+0x2>
    144a:	81 30       	cpi	r24, 0x01	; 1
    144c:	61 f4       	brne	.+24     	; 0x1466 <gc_execute_line+0x5a6>
      // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
      if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    144e:	fa a1       	ldd	r31, Y+34	; 0x22
    1450:	f2 30       	cpi	r31, 0x02	; 2
    1452:	c1 f5       	brne	.+112    	; 0x14c4 <gc_execute_line+0x604>
        if ((gc_block.modal.motion != MOTION_MODE_NONE) && (gc_block.modal.motion != MOTION_MODE_SEEK)) {
    1454:	80 91 97 0c 	lds	r24, 0x0C97	; 0x800c97 <gc_block+0x1>
    1458:	80 35       	cpi	r24, 0x50	; 80
    145a:	a1 f1       	breq	.+104    	; 0x14c4 <gc_execute_line+0x604>
    145c:	88 23       	and	r24, r24
    145e:	91 f1       	breq	.+100    	; 0x14c4 <gc_execute_line+0x604>
          if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    1460:	20 fe       	sbrs	r2, 0
    1462:	95 c7       	rjmp	.+3882   	; 0x238e <__stack+0x18f>
    1464:	2f c0       	rjmp	.+94     	; 0x14c4 <gc_execute_line+0x604>
      // value in the block. If no F word is passed with a motion command that requires a feed rate, this will error
      // out in the motion modes error-checking. However, if no F word is passed with NO motion command that requires
      // a feed rate, we simply move on and the state feed rate value gets updated to zero and remains undefined.
    } else { // = G94
      // - In units per mm mode: If F word passed, ensure value is in mm/min, otherwise push last state value.
      if (gc_state.modal.feed_rate == FEED_RATE_MODE_UNITS_PER_MIN) { // Last state is also G94
    1466:	80 91 57 0c 	lds	r24, 0x0C57	; 0x800c57 <gc_state+0x1>
    146a:	81 11       	cpse	r24, r1
    146c:	2b c0       	rjmp	.+86     	; 0x14c4 <gc_execute_line+0x604>
        if (bit_istrue(value_words,bit(WORD_F))) {
    146e:	20 fe       	sbrs	r2, 0
    1470:	19 c0       	rjmp	.+50     	; 0x14a4 <gc_execute_line+0x5e4>
          if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    1472:	80 91 99 0c 	lds	r24, 0x0C99	; 0x800c99 <gc_block+0x3>
    1476:	81 30       	cpi	r24, 0x01	; 1
    1478:	29 f5       	brne	.+74     	; 0x14c4 <gc_execute_line+0x604>
    147a:	06 e9       	ldi	r16, 0x96	; 150
    147c:	1c e0       	ldi	r17, 0x0C	; 12
    147e:	23 e3       	ldi	r18, 0x33	; 51
    1480:	33 e3       	ldi	r19, 0x33	; 51
    1482:	4b ec       	ldi	r20, 0xCB	; 203
    1484:	51 e4       	ldi	r21, 0x41	; 65
    1486:	d8 01       	movw	r26, r16
    1488:	1c 96       	adiw	r26, 0x0c	; 12
    148a:	6d 91       	ld	r22, X+
    148c:	7d 91       	ld	r23, X+
    148e:	8d 91       	ld	r24, X+
    1490:	9c 91       	ld	r25, X
    1492:	1f 97       	sbiw	r26, 0x0f	; 15
    1494:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    1498:	f8 01       	movw	r30, r16
    149a:	64 87       	std	Z+12, r22	; 0x0c
    149c:	75 87       	std	Z+13, r23	; 0x0d
    149e:	86 87       	std	Z+14, r24	; 0x0e
    14a0:	97 87       	std	Z+15, r25	; 0x0f
    14a2:	10 c0       	rjmp	.+32     	; 0x14c4 <gc_execute_line+0x604>
        } else {
          gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
    14a4:	80 91 65 0c 	lds	r24, 0x0C65	; 0x800c65 <gc_state+0xf>
    14a8:	90 91 66 0c 	lds	r25, 0x0C66	; 0x800c66 <gc_state+0x10>
    14ac:	a0 91 67 0c 	lds	r26, 0x0C67	; 0x800c67 <gc_state+0x11>
    14b0:	b0 91 68 0c 	lds	r27, 0x0C68	; 0x800c68 <gc_state+0x12>
    14b4:	80 93 a2 0c 	sts	0x0CA2, r24	; 0x800ca2 <gc_block+0xc>
    14b8:	90 93 a3 0c 	sts	0x0CA3, r25	; 0x800ca3 <gc_block+0xd>
    14bc:	a0 93 a4 0c 	sts	0x0CA4, r26	; 0x800ca4 <gc_block+0xe>
    14c0:	b0 93 a5 0c 	sts	0x0CA5, r27	; 0x800ca5 <gc_block+0xf>
    }
  }
  // bit_false(value_words,bit(WORD_F)); // NOTE: Single-meaning value word. Set at end of error-checking.

  // [4. Set spindle speed ]: S is negative (done.)
  if (bit_isfalse(value_words,bit(WORD_S))) { gc_block.values.s = gc_state.spindle_speed; }
    14c4:	30 fc       	sbrc	r3, 0
    14c6:	10 c0       	rjmp	.+32     	; 0x14e8 <gc_execute_line+0x628>
    14c8:	80 91 61 0c 	lds	r24, 0x0C61	; 0x800c61 <gc_state+0xb>
    14cc:	90 91 62 0c 	lds	r25, 0x0C62	; 0x800c62 <gc_state+0xc>
    14d0:	a0 91 63 0c 	lds	r26, 0x0C63	; 0x800c63 <gc_state+0xd>
    14d4:	b0 91 64 0c 	lds	r27, 0x0C64	; 0x800c64 <gc_state+0xe>
    14d8:	80 93 bf 0c 	sts	0x0CBF, r24	; 0x800cbf <gc_block+0x29>
    14dc:	90 93 c0 0c 	sts	0x0CC0, r25	; 0x800cc0 <gc_block+0x2a>
    14e0:	a0 93 c1 0c 	sts	0x0CC1, r26	; 0x800cc1 <gc_block+0x2b>
    14e4:	b0 93 c2 0c 	sts	0x0CC2, r27	; 0x800cc2 <gc_block+0x2c>
      }
    }
  #endif

  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    14e8:	80 91 96 0c 	lds	r24, 0x0C96	; 0x800c96 <gc_block>
    14ec:	84 30       	cpi	r24, 0x04	; 4
    14ee:	21 f4       	brne	.+8      	; 0x14f8 <gc_execute_line+0x638>
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    14f0:	26 fe       	sbrs	r2, 6
    14f2:	4f c7       	rjmp	.+3742   	; 0x2392 <__stack+0x193>
    bit_false(value_words,bit(WORD_P));
    14f4:	e8 94       	clt
    14f6:	26 f8       	bld	r2, 6
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    14f8:	80 91 9b 0c 	lds	r24, 0x0C9B	; 0x800c9b <gc_block+0x5>
    14fc:	88 23       	and	r24, r24
    14fe:	49 f0       	breq	.+18     	; 0x1512 <gc_execute_line+0x652>
    1500:	81 30       	cpi	r24, 0x01	; 1
    1502:	09 f4       	brne	.+2      	; 0x1506 <gc_execute_line+0x646>
    1504:	98 c7       	rjmp	.+3888   	; 0x2436 <__stack+0x237>
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
      axis_linear = X_AXIS;
    1506:	1f a6       	std	Y+47, r1	; 0x2f
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
    1508:	f2 e0       	ldi	r31, 0x02	; 2
    150a:	fe a3       	std	Y+38, r31	; 0x26
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
    150c:	21 e0       	ldi	r18, 0x01	; 1
    150e:	2d a3       	std	Y+37, r18	; 0x25
    1510:	97 c7       	rjmp	.+3886   	; 0x2440 <__stack+0x241>
  }

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    1512:	80 91 99 0c 	lds	r24, 0x0C99	; 0x800c99 <gc_block+0x3>
    1516:	81 30       	cpi	r24, 0x01	; 1
    1518:	a1 f5       	brne	.+104    	; 0x1582 <gc_execute_line+0x6c2>
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    151a:	32 e0       	ldi	r19, 0x02	; 2
    151c:	3f a7       	std	Y+47, r19	; 0x2f

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    151e:	41 e0       	ldi	r20, 0x01	; 1
    1520:	4e a3       	std	Y+38, r20	; 0x26
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    1522:	1d a2       	std	Y+37, r1	; 0x25
    1524:	0f 2e       	mov	r0, r31
    1526:	f6 e9       	ldi	r31, 0x96	; 150
    1528:	af 2e       	mov	r10, r31
    152a:	fc e0       	ldi	r31, 0x0C	; 12
    152c:	bf 2e       	mov	r11, r31
    152e:	f0 2d       	mov	r31, r0
    1530:	00 e0       	ldi	r16, 0x00	; 0
    1532:	10 e0       	ldi	r17, 0x00	; 0
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
      if (bit_istrue(axis_words,bit(idx)) ) {
    1534:	89 a1       	ldd	r24, Y+33	; 0x21
    1536:	c8 2e       	mov	r12, r24
    1538:	d1 2c       	mov	r13, r1
    153a:	c6 01       	movw	r24, r12
    153c:	00 2e       	mov	r0, r16
    153e:	02 c0       	rjmp	.+4      	; 0x1544 <gc_execute_line+0x684>
    1540:	95 95       	asr	r25
    1542:	87 95       	ror	r24
    1544:	0a 94       	dec	r0
    1546:	e2 f7       	brpl	.-8      	; 0x1540 <gc_execute_line+0x680>
    1548:	80 ff       	sbrs	r24, 0
    154a:	12 c0       	rjmp	.+36     	; 0x1570 <gc_execute_line+0x6b0>
        gc_block.values.xyz[idx] *= MM_PER_INCH;
    154c:	23 e3       	ldi	r18, 0x33	; 51
    154e:	33 e3       	ldi	r19, 0x33	; 51
    1550:	4b ec       	ldi	r20, 0xCB	; 203
    1552:	51 e4       	ldi	r21, 0x41	; 65
    1554:	d5 01       	movw	r26, r10
    1556:	9e 96       	adiw	r26, 0x2e	; 46
    1558:	6d 91       	ld	r22, X+
    155a:	7d 91       	ld	r23, X+
    155c:	8d 91       	ld	r24, X+
    155e:	9c 91       	ld	r25, X
    1560:	d1 97       	sbiw	r26, 0x31	; 49
    1562:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    1566:	f5 01       	movw	r30, r10
    1568:	66 a7       	std	Z+46, r22	; 0x2e
    156a:	77 a7       	std	Z+47, r23	; 0x2f
    156c:	80 ab       	std	Z+48, r24	; 0x30
    156e:	91 ab       	std	Z+49, r25	; 0x31
    1570:	0f 5f       	subi	r16, 0xFF	; 255
    1572:	1f 4f       	sbci	r17, 0xFF	; 255
    1574:	f4 e0       	ldi	r31, 0x04	; 4
    1576:	af 0e       	add	r10, r31
    1578:	b1 1c       	adc	r11, r1

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    157a:	03 30       	cpi	r16, 0x03	; 3
    157c:	11 05       	cpc	r17, r1
    157e:	e9 f6       	brne	.-70     	; 0x153a <gc_execute_line+0x67a>
    1580:	05 c0       	rjmp	.+10     	; 0x158c <gc_execute_line+0x6cc>
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    1582:	22 e0       	ldi	r18, 0x02	; 2
    1584:	2f a7       	std	Y+47, r18	; 0x2f

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    1586:	31 e0       	ldi	r19, 0x01	; 1
    1588:	3e a3       	std	Y+38, r19	; 0x26
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    158a:	1d a2       	std	Y+37, r1	; 0x25
  // [14. Cutter length compensation ]: G43 NOT SUPPORTED, but G43.1 and G49 are.
  // [G43.1 Errors]: Motion command in same line.
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    158c:	4a a1       	ldd	r20, Y+34	; 0x22
    158e:	43 30       	cpi	r20, 0x03	; 3
    1590:	41 f4       	brne	.+16     	; 0x15a2 <gc_execute_line+0x6e2>
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
    1592:	80 91 9c 0c 	lds	r24, 0x0C9C	; 0x800c9c <gc_block+0x6>
    1596:	81 30       	cpi	r24, 0x01	; 1
    1598:	21 f4       	brne	.+8      	; 0x15a2 <gc_execute_line+0x6e2>
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    159a:	89 a1       	ldd	r24, Y+33	; 0x21
    159c:	84 30       	cpi	r24, 0x04	; 4
    159e:	09 f0       	breq	.+2      	; 0x15a2 <gc_execute_line+0x6e2>
    15a0:	fa c6       	rjmp	.+3572   	; 0x2396 <__stack+0x197>
  // TODO: An EEPROM read of the coordinate data may require a buffer sync when the cycle
  // is active. The read pauses the processor temporarily and may cause a rare crash. For
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  float block_coord_system[N_AXIS];
  memcpy(block_coord_system,gc_state.coord_system,sizeof(gc_state.coord_system));
    15a2:	8c e0       	ldi	r24, 0x0C	; 12
    15a4:	ea e7       	ldi	r30, 0x7A	; 122
    15a6:	fc e0       	ldi	r31, 0x0C	; 12
    15a8:	de 01       	movw	r26, r28
    15aa:	16 96       	adiw	r26, 0x06	; 6
    15ac:	01 90       	ld	r0, Z+
    15ae:	0d 92       	st	X+, r0
    15b0:	8a 95       	dec	r24
    15b2:	e1 f7       	brne	.-8      	; 0x15ac <gc_execute_line+0x6ec>
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    15b4:	f1 fe       	sbrs	r15, 1
    15b6:	11 c0       	rjmp	.+34     	; 0x15da <gc_execute_line+0x71a>
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    15b8:	80 91 9d 0c 	lds	r24, 0x0C9D	; 0x800c9d <gc_block+0x7>
    15bc:	87 30       	cpi	r24, 0x07	; 7
    15be:	08 f0       	brcs	.+2      	; 0x15c2 <gc_execute_line+0x702>
    15c0:	ec c6       	rjmp	.+3544   	; 0x239a <__stack+0x19b>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    15c2:	90 91 5c 0c 	lds	r25, 0x0C5C	; 0x800c5c <gc_state+0x6>
    15c6:	89 17       	cp	r24, r25
    15c8:	41 f0       	breq	.+16     	; 0x15da <gc_execute_line+0x71a>
      if (!(settings_read_coord_data(gc_block.modal.coord_select,block_coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    15ca:	be 01       	movw	r22, r28
    15cc:	6a 5f       	subi	r22, 0xFA	; 250
    15ce:	7f 4f       	sbci	r23, 0xFF	; 255
    15d0:	0e 94 1a 26 	call	0x4c34	; 0x4c34 <settings_read_coord_data>
    15d4:	88 23       	and	r24, r24
    15d6:	09 f4       	brne	.+2      	; 0x15da <gc_execute_line+0x71a>
    15d8:	e2 c6       	rjmp	.+3524   	; 0x239e <__stack+0x19f>
  // [19. Remaining non-modal actions ]: Check go to predefined position, set G10, or set axis offsets.
  // NOTE: We need to separate the non-modal commands that are axis word-using (G10/G28/G30/G92), as these
  // commands all treat axis words differently. G10 as absolute offsets or computes current position as
  // the axis value, G92 similarly to G10 L20, and G28/30 as an intermediate target position that observes
  // all the current coordinate system and G92 offsets.
  switch (gc_block.non_modal_command) {
    15da:	b0 90 96 0c 	lds	r11, 0x0C96	; 0x800c96 <gc_block>
    15de:	9a e0       	ldi	r25, 0x0A	; 10
    15e0:	b9 16       	cp	r11, r25
    15e2:	29 f0       	breq	.+10     	; 0x15ee <gc_execute_line+0x72e>
    15e4:	ac e5       	ldi	r26, 0x5C	; 92
    15e6:	ba 16       	cp	r11, r26
    15e8:	09 f4       	brne	.+2      	; 0x15ec <gc_execute_line+0x72c>
    15ea:	9a c0       	rjmp	.+308    	; 0x1720 <gc_execute_line+0x860>
    15ec:	0e c1       	rjmp	.+540    	; 0x180a <gc_execute_line+0x94a>
    case NON_MODAL_SET_COORDINATE_DATA:
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    15ee:	b9 a1       	ldd	r27, Y+33	; 0x21
    15f0:	bb 23       	and	r27, r27
    15f2:	09 f4       	brne	.+2      	; 0x15f6 <gc_execute_line+0x736>
    15f4:	d6 c6       	rjmp	.+3500   	; 0x23a2 <__stack+0x1a3>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    15f6:	c1 01       	movw	r24, r2
    15f8:	80 75       	andi	r24, 0x50	; 80
    15fa:	99 27       	eor	r25, r25
    15fc:	89 2b       	or	r24, r25
    15fe:	09 f4       	brne	.+2      	; 0x1602 <gc_execute_line+0x742>
    1600:	d2 c6       	rjmp	.+3492   	; 0x23a6 <__stack+0x1a7>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
    1602:	60 91 b7 0c 	lds	r22, 0x0CB7	; 0x800cb7 <gc_block+0x21>
    1606:	70 91 b8 0c 	lds	r23, 0x0CB8	; 0x800cb8 <gc_block+0x22>
    160a:	80 91 b9 0c 	lds	r24, 0x0CB9	; 0x800cb9 <gc_block+0x23>
    160e:	90 91 ba 0c 	lds	r25, 0x0CBA	; 0x800cba <gc_block+0x24>
    1612:	0e 94 75 42 	call	0x84ea	; 0x84ea <trunc>
    1616:	0e 94 dd 3f 	call	0x7fba	; 0x7fba <__fixunssfsi>
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    161a:	67 30       	cpi	r22, 0x07	; 7
    161c:	08 f0       	brcs	.+2      	; 0x1620 <gc_execute_line+0x760>
    161e:	c5 c6       	rjmp	.+3466   	; 0x23aa <__stack+0x1ab>
      if (gc_block.values.l != 20) {
    1620:	80 91 b2 0c 	lds	r24, 0x0CB2	; 0x800cb2 <gc_block+0x1c>
    1624:	84 31       	cpi	r24, 0x14	; 20
    1626:	29 f0       	breq	.+10     	; 0x1632 <gc_execute_line+0x772>
        if (gc_block.values.l == 2) {
    1628:	82 30       	cpi	r24, 0x02	; 2
    162a:	09 f0       	breq	.+2      	; 0x162e <gc_execute_line+0x76e>
    162c:	c0 c6       	rjmp	.+3456   	; 0x23ae <__stack+0x1af>
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    162e:	27 fc       	sbrc	r2, 7
    1630:	c0 c6       	rjmp	.+3456   	; 0x23b2 <__stack+0x1b3>
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
      }
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
    1632:	ef ea       	ldi	r30, 0xAF	; 175
    1634:	2e 22       	and	r2, r30

      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
    1636:	66 23       	and	r22, r22
    1638:	19 f0       	breq	.+6      	; 0x1640 <gc_execute_line+0x780>
    163a:	61 50       	subi	r22, 0x01	; 1
    163c:	6f 8f       	std	Y+31, r22	; 0x1f
    163e:	03 c0       	rjmp	.+6      	; 0x1646 <gc_execute_line+0x786>
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
    1640:	f0 91 9d 0c 	lds	r31, 0x0C9D	; 0x800c9d <gc_block+0x7>
    1644:	ff 8f       	std	Y+31, r31	; 0x1f
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    1646:	66 ea       	ldi	r22, 0xA6	; 166
    1648:	7c e0       	ldi	r23, 0x0C	; 12
    164a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    164c:	0e 94 1a 26 	call	0x4c34	; 0x4c34 <settings_read_coord_data>
    1650:	88 23       	and	r24, r24
    1652:	09 f4       	brne	.+2      	; 0x1656 <gc_execute_line+0x796>
    1654:	b0 c6       	rjmp	.+3424   	; 0x23b6 <__stack+0x1b7>

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
          if (gc_block.values.l == 20) {
    1656:	20 91 b2 0c 	lds	r18, 0x0CB2	; 0x800cb2 <gc_block+0x1c>
    165a:	2f a3       	std	Y+39, r18	; 0x27
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            // WPos = MPos - WCS - G92 - TLO  ->  WCS = MPos - G92 - TLO - WPos
            gc_block.values.ijk[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.ijk[idx] -= gc_state.tool_length_offset; }
    165c:	40 90 92 0c 	lds	r4, 0x0C92	; 0x800c92 <gc_state+0x3c>
    1660:	50 90 93 0c 	lds	r5, 0x0C93	; 0x800c93 <gc_state+0x3d>
    1664:	60 90 94 0c 	lds	r6, 0x0C94	; 0x800c94 <gc_state+0x3e>
    1668:	70 90 95 0c 	lds	r7, 0x0C95	; 0x800c95 <gc_state+0x3f>
    166c:	06 e9       	ldi	r16, 0x96	; 150
    166e:	1c e0       	ldi	r17, 0x0C	; 12
    1670:	0f 2e       	mov	r0, r31
    1672:	f6 e5       	ldi	r31, 0x56	; 86
    1674:	cf 2e       	mov	r12, r31
    1676:	fc e0       	ldi	r31, 0x0C	; 12
    1678:	df 2e       	mov	r13, r31
    167a:	f0 2d       	mov	r31, r0
    167c:	a1 2c       	mov	r10, r1
    167e:	b1 2c       	mov	r11, r1
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
    1680:	39 a1       	ldd	r19, Y+33	; 0x21
    1682:	83 2e       	mov	r8, r19
    1684:	91 2c       	mov	r9, r1
    1686:	c4 01       	movw	r24, r8
    1688:	0a 2c       	mov	r0, r10
    168a:	02 c0       	rjmp	.+4      	; 0x1690 <gc_execute_line+0x7d0>
    168c:	95 95       	asr	r25
    168e:	87 95       	ror	r24
    1690:	0a 94       	dec	r0
    1692:	e2 f7       	brpl	.-8      	; 0x168c <gc_execute_line+0x7cc>
    1694:	80 ff       	sbrs	r24, 0
    1696:	36 c0       	rjmp	.+108    	; 0x1704 <gc_execute_line+0x844>
          if (gc_block.values.l == 20) {
    1698:	4f a1       	ldd	r20, Y+39	; 0x27
    169a:	44 31       	cpi	r20, 0x14	; 20
    169c:	51 f5       	brne	.+84     	; 0x16f2 <gc_execute_line+0x832>
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            // WPos = MPos - WCS - G92 - TLO  ->  WCS = MPos - G92 - TLO - WPos
            gc_block.values.ijk[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
    169e:	d6 01       	movw	r26, r12
    16a0:	d0 96       	adiw	r26, 0x30	; 48
    16a2:	2d 91       	ld	r18, X+
    16a4:	3d 91       	ld	r19, X+
    16a6:	4d 91       	ld	r20, X+
    16a8:	5c 91       	ld	r21, X
    16aa:	d3 97       	sbiw	r26, 0x33	; 51
    16ac:	58 96       	adiw	r26, 0x18	; 24
    16ae:	6d 91       	ld	r22, X+
    16b0:	7d 91       	ld	r23, X+
    16b2:	8d 91       	ld	r24, X+
    16b4:	9c 91       	ld	r25, X
    16b6:	5b 97       	sbiw	r26, 0x1b	; 27
    16b8:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    16bc:	f8 01       	movw	r30, r16
    16be:	26 a5       	ldd	r18, Z+46	; 0x2e
    16c0:	37 a5       	ldd	r19, Z+47	; 0x2f
    16c2:	40 a9       	ldd	r20, Z+48	; 0x30
    16c4:	51 a9       	ldd	r21, Z+49	; 0x31
    16c6:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    16ca:	d8 01       	movw	r26, r16
    16cc:	50 96       	adiw	r26, 0x10	; 16
    16ce:	6d 93       	st	X+, r22
    16d0:	7d 93       	st	X+, r23
    16d2:	8d 93       	st	X+, r24
    16d4:	9c 93       	st	X, r25
    16d6:	53 97       	sbiw	r26, 0x13	; 19
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.ijk[idx] -= gc_state.tool_length_offset; }
    16d8:	b2 e0       	ldi	r27, 0x02	; 2
    16da:	ab 12       	cpse	r10, r27
    16dc:	13 c0       	rjmp	.+38     	; 0x1704 <gc_execute_line+0x844>
    16de:	a3 01       	movw	r20, r6
    16e0:	92 01       	movw	r18, r4
    16e2:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    16e6:	f8 01       	movw	r30, r16
    16e8:	60 8b       	std	Z+16, r22	; 0x10
    16ea:	71 8b       	std	Z+17, r23	; 0x11
    16ec:	82 8b       	std	Z+18, r24	; 0x12
    16ee:	93 8b       	std	Z+19, r25	; 0x13
    16f0:	09 c0       	rjmp	.+18     	; 0x1704 <gc_execute_line+0x844>
          } else {
            // L2: Update coordinate system axis to programmed value.
            gc_block.values.ijk[idx] = gc_block.values.xyz[idx];
    16f2:	f8 01       	movw	r30, r16
    16f4:	86 a5       	ldd	r24, Z+46	; 0x2e
    16f6:	97 a5       	ldd	r25, Z+47	; 0x2f
    16f8:	a0 a9       	ldd	r26, Z+48	; 0x30
    16fa:	b1 a9       	ldd	r27, Z+49	; 0x31
    16fc:	80 8b       	std	Z+16, r24	; 0x10
    16fe:	91 8b       	std	Z+17, r25	; 0x11
    1700:	a2 8b       	std	Z+18, r26	; 0x12
    1702:	b3 8b       	std	Z+19, r27	; 0x13
    1704:	ff ef       	ldi	r31, 0xFF	; 255
    1706:	af 1a       	sub	r10, r31
    1708:	bf 0a       	sbc	r11, r31
    170a:	0c 5f       	subi	r16, 0xFC	; 252
    170c:	1f 4f       	sbci	r17, 0xFF	; 255
    170e:	24 e0       	ldi	r18, 0x04	; 4
    1710:	c2 0e       	add	r12, r18
    1712:	d1 1c       	adc	r13, r1
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    1714:	33 e0       	ldi	r19, 0x03	; 3
    1716:	a3 16       	cp	r10, r19
    1718:	b1 04       	cpc	r11, r1
    171a:	09 f0       	breq	.+2      	; 0x171e <gc_execute_line+0x85e>
    171c:	b4 cf       	rjmp	.-152    	; 0x1686 <gc_execute_line+0x7c6>
    171e:	a2 c6       	rjmp	.+3396   	; 0x2464 <__stack+0x265>
        } // Else, keep current stored value.
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1720:	49 a1       	ldd	r20, Y+33	; 0x21
    1722:	44 23       	and	r20, r20
    1724:	09 f4       	brne	.+2      	; 0x1728 <gc_execute_line+0x868>
    1726:	49 c6       	rjmp	.+3218   	; 0x23ba <__stack+0x1bb>
    1728:	0f 2e       	mov	r0, r31
    172a:	f6 e5       	ldi	r31, 0x56	; 86
    172c:	af 2e       	mov	r10, r31
    172e:	fc e0       	ldi	r31, 0x0C	; 12
    1730:	bf 2e       	mov	r11, r31
    1732:	f0 2d       	mov	r31, r0
    1734:	4e 01       	movw	r8, r28
    1736:	86 e0       	ldi	r24, 0x06	; 6
    1738:	88 0e       	add	r8, r24
    173a:	91 1c       	adc	r9, r1
    173c:	06 e9       	ldi	r16, 0x96	; 150
    173e:	1c e0       	ldi	r17, 0x0C	; 12
    1740:	c1 2c       	mov	r12, r1
    1742:	d1 2c       	mov	r13, r1

      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
    1744:	64 2e       	mov	r6, r20
    1746:	71 2c       	mov	r7, r1
    1748:	c3 01       	movw	r24, r6
    174a:	0c 2c       	mov	r0, r12
    174c:	02 c0       	rjmp	.+4      	; 0x1752 <gc_execute_line+0x892>
    174e:	95 95       	asr	r25
    1750:	87 95       	ror	r24
    1752:	0a 94       	dec	r0
    1754:	e2 f7       	brpl	.-8      	; 0x174e <gc_execute_line+0x88e>
    1756:	80 ff       	sbrs	r24, 0
    1758:	3c c0       	rjmp	.+120    	; 0x17d2 <gc_execute_line+0x912>
          // WPos = MPos - WCS - G92 - TLO  ->  G92 = MPos - WCS - TLO - WPos
          gc_block.values.xyz[idx] = gc_state.position[idx]-block_coord_system[idx]-gc_block.values.xyz[idx];
    175a:	d4 01       	movw	r26, r8
    175c:	2d 91       	ld	r18, X+
    175e:	3d 91       	ld	r19, X+
    1760:	4d 91       	ld	r20, X+
    1762:	5c 91       	ld	r21, X
    1764:	f5 01       	movw	r30, r10
    1766:	60 8d       	ldd	r22, Z+24	; 0x18
    1768:	71 8d       	ldd	r23, Z+25	; 0x19
    176a:	82 8d       	ldd	r24, Z+26	; 0x1a
    176c:	93 8d       	ldd	r25, Z+27	; 0x1b
    176e:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    1772:	d8 01       	movw	r26, r16
    1774:	9e 96       	adiw	r26, 0x2e	; 46
    1776:	2d 91       	ld	r18, X+
    1778:	3d 91       	ld	r19, X+
    177a:	4d 91       	ld	r20, X+
    177c:	5c 91       	ld	r21, X
    177e:	d1 97       	sbiw	r26, 0x31	; 49
    1780:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    1784:	f8 01       	movw	r30, r16
    1786:	66 a7       	std	Z+46, r22	; 0x2e
    1788:	77 a7       	std	Z+47, r23	; 0x2f
    178a:	80 ab       	std	Z+48, r24	; 0x30
    178c:	91 ab       	std	Z+49, r25	; 0x31
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
    178e:	f2 e0       	ldi	r31, 0x02	; 2
    1790:	cf 12       	cpse	r12, r31
    1792:	29 c0       	rjmp	.+82     	; 0x17e6 <gc_execute_line+0x926>
    1794:	86 01       	movw	r16, r12
    1796:	00 0f       	add	r16, r16
    1798:	11 1f       	adc	r17, r17
    179a:	00 0f       	add	r16, r16
    179c:	11 1f       	adc	r17, r17
    179e:	0a 56       	subi	r16, 0x6A	; 106
    17a0:	13 4f       	sbci	r17, 0xF3	; 243
    17a2:	20 91 92 0c 	lds	r18, 0x0C92	; 0x800c92 <gc_state+0x3c>
    17a6:	30 91 93 0c 	lds	r19, 0x0C93	; 0x800c93 <gc_state+0x3d>
    17aa:	40 91 94 0c 	lds	r20, 0x0C94	; 0x800c94 <gc_state+0x3e>
    17ae:	50 91 95 0c 	lds	r21, 0x0C95	; 0x800c95 <gc_state+0x3f>
    17b2:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    17b6:	d8 01       	movw	r26, r16
    17b8:	9e 96       	adiw	r26, 0x2e	; 46
    17ba:	6d 93       	st	X+, r22
    17bc:	7d 93       	st	X+, r23
    17be:	8d 93       	st	X+, r24
    17c0:	9c 93       	st	X, r25
    17c2:	d1 97       	sbiw	r26, 0x31	; 49
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    17c4:	10 91 97 0c 	lds	r17, 0x0C97	; 0x800c97 <gc_block+0x1>
    17c8:	10 35       	cpi	r17, 0x50	; 80
    17ca:	09 f4       	brne	.+2      	; 0x17ce <gc_execute_line+0x90e>
    17cc:	f8 c5       	rjmp	.+3056   	; 0x23be <__stack+0x1bf>
    17ce:	1f 8e       	std	Y+31, r1	; 0x1f
    17d0:	f8 c0       	rjmp	.+496    	; 0x19c2 <gc_execute_line+0xb02>
        if (bit_istrue(axis_words,bit(idx)) ) {
          // WPos = MPos - WCS - G92 - TLO  ->  G92 = MPos - WCS - TLO - WPos
          gc_block.values.xyz[idx] = gc_state.position[idx]-block_coord_system[idx]-gc_block.values.xyz[idx];
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
        } else {
          gc_block.values.xyz[idx] = gc_state.coord_offset[idx];
    17d2:	f5 01       	movw	r30, r10
    17d4:	80 a9       	ldd	r24, Z+48	; 0x30
    17d6:	91 a9       	ldd	r25, Z+49	; 0x31
    17d8:	a2 a9       	ldd	r26, Z+50	; 0x32
    17da:	b3 a9       	ldd	r27, Z+51	; 0x33
    17dc:	f8 01       	movw	r30, r16
    17de:	86 a7       	std	Z+46, r24	; 0x2e
    17e0:	97 a7       	std	Z+47, r25	; 0x2f
    17e2:	a0 ab       	std	Z+48, r26	; 0x30
    17e4:	b1 ab       	std	Z+49, r27	; 0x31
    17e6:	ff ef       	ldi	r31, 0xFF	; 255
    17e8:	cf 1a       	sub	r12, r31
    17ea:	df 0a       	sbc	r13, r31
    17ec:	24 e0       	ldi	r18, 0x04	; 4
    17ee:	a2 0e       	add	r10, r18
    17f0:	b1 1c       	adc	r11, r1
    17f2:	34 e0       	ldi	r19, 0x04	; 4
    17f4:	83 0e       	add	r8, r19
    17f6:	91 1c       	adc	r9, r1
    17f8:	0c 5f       	subi	r16, 0xFC	; 252
    17fa:	1f 4f       	sbci	r17, 0xFF	; 255
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]

      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    17fc:	43 e0       	ldi	r20, 0x03	; 3
    17fe:	c4 16       	cp	r12, r20
    1800:	d1 04       	cpc	r13, r1
    1802:	09 f0       	breq	.+2      	; 0x1806 <gc_execute_line+0x946>
    1804:	a1 cf       	rjmp	.-190    	; 0x1748 <gc_execute_line+0x888>
  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes

  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    1806:	1f 8e       	std	Y+31, r1	; 0x1f
    1808:	2d c6       	rjmp	.+3162   	; 0x2464 <__stack+0x265>

      // At this point, the rest of the explicit axis commands treat the axis values as the traditional
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
    180a:	8a a1       	ldd	r24, Y+34	; 0x22
    180c:	83 30       	cpi	r24, 0x03	; 3
    180e:	09 f4       	brne	.+2      	; 0x1812 <gc_execute_line+0x952>
    1810:	90 c0       	rjmp	.+288    	; 0x1932 <gc_execute_line+0xa72>
        if (axis_words) {
    1812:	99 a1       	ldd	r25, Y+33	; 0x21
    1814:	99 23       	and	r25, r25
    1816:	09 f4       	brne	.+2      	; 0x181a <gc_execute_line+0x95a>
    1818:	8c c0       	rjmp	.+280    	; 0x1932 <gc_execute_line+0xa72>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    181a:	a0 90 9a 0c 	lds	r10, 0x0C9A	; 0x800c9a <gc_block+0x4>
    181e:	0f 2e       	mov	r0, r31
    1820:	f6 e5       	ldi	r31, 0x56	; 86
    1822:	cf 2e       	mov	r12, r31
    1824:	fc e0       	ldi	r31, 0x0C	; 12
    1826:	df 2e       	mov	r13, r31
    1828:	f0 2d       	mov	r31, r0
    182a:	06 e9       	ldi	r16, 0x96	; 150
    182c:	1c e0       	ldi	r17, 0x0C	; 12
    182e:	3e 01       	movw	r6, r28
    1830:	a6 e0       	ldi	r26, 0x06	; 6
    1832:	6a 0e       	add	r6, r26
    1834:	71 1c       	adc	r7, r1
    1836:	81 2c       	mov	r8, r1
    1838:	91 2c       	mov	r9, r1
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
            if ( bit_isfalse(axis_words,bit(idx)) ) {
    183a:	49 2e       	mov	r4, r25
    183c:	51 2c       	mov	r5, r1
    183e:	98 a2       	std	Y+32, r9	; 0x20
    1840:	8f 8e       	std	Y+31, r8	; 0x1f
    1842:	c2 01       	movw	r24, r4
    1844:	08 2c       	mov	r0, r8
    1846:	02 c0       	rjmp	.+4      	; 0x184c <gc_execute_line+0x98c>
    1848:	95 95       	asr	r25
    184a:	87 95       	ror	r24
    184c:	0a 94       	dec	r0
    184e:	e2 f7       	brpl	.-8      	; 0x1848 <gc_execute_line+0x988>
    1850:	80 fd       	sbrc	r24, 0
    1852:	0b c0       	rjmp	.+22     	; 0x186a <gc_execute_line+0x9aa>
              gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
    1854:	f6 01       	movw	r30, r12
    1856:	80 8d       	ldd	r24, Z+24	; 0x18
    1858:	91 8d       	ldd	r25, Z+25	; 0x19
    185a:	a2 8d       	ldd	r26, Z+26	; 0x1a
    185c:	b3 8d       	ldd	r27, Z+27	; 0x1b
    185e:	f8 01       	movw	r30, r16
    1860:	86 a7       	std	Z+46, r24	; 0x2e
    1862:	97 a7       	std	Z+47, r25	; 0x2f
    1864:	a0 ab       	std	Z+48, r26	; 0x30
    1866:	b1 ab       	std	Z+49, r27	; 0x31
    1868:	54 c0       	rjmp	.+168    	; 0x1912 <gc_execute_line+0xa52>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
    186a:	f5 e3       	ldi	r31, 0x35	; 53
    186c:	bf 16       	cp	r11, r31
    186e:	09 f4       	brne	.+2      	; 0x1872 <gc_execute_line+0x9b2>
    1870:	50 c0       	rjmp	.+160    	; 0x1912 <gc_execute_line+0xa52>
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    1872:	a1 10       	cpse	r10, r1
    1874:	3b c0       	rjmp	.+118    	; 0x18ec <gc_execute_line+0xa2c>
                  gc_block.values.xyz[idx] += block_coord_system[idx] + gc_state.coord_offset[idx];
    1876:	d6 01       	movw	r26, r12
    1878:	d0 96       	adiw	r26, 0x30	; 48
    187a:	2d 91       	ld	r18, X+
    187c:	3d 91       	ld	r19, X+
    187e:	4d 91       	ld	r20, X+
    1880:	5c 91       	ld	r21, X
    1882:	d3 97       	sbiw	r26, 0x33	; 51
    1884:	f3 01       	movw	r30, r6
    1886:	60 81       	ld	r22, Z
    1888:	71 81       	ldd	r23, Z+1	; 0x01
    188a:	82 81       	ldd	r24, Z+2	; 0x02
    188c:	93 81       	ldd	r25, Z+3	; 0x03
    188e:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    1892:	d8 01       	movw	r26, r16
    1894:	9e 96       	adiw	r26, 0x2e	; 46
    1896:	2d 91       	ld	r18, X+
    1898:	3d 91       	ld	r19, X+
    189a:	4d 91       	ld	r20, X+
    189c:	5c 91       	ld	r21, X
    189e:	d1 97       	sbiw	r26, 0x31	; 49
    18a0:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    18a4:	9b 01       	movw	r18, r22
    18a6:	ac 01       	movw	r20, r24
    18a8:	f8 01       	movw	r30, r16
    18aa:	66 a7       	std	Z+46, r22	; 0x2e
    18ac:	77 a7       	std	Z+47, r23	; 0x2f
    18ae:	80 ab       	std	Z+48, r24	; 0x30
    18b0:	91 ab       	std	Z+49, r25	; 0x31
                  if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_length_offset; }
    18b2:	f2 e0       	ldi	r31, 0x02	; 2
    18b4:	8f 12       	cpse	r8, r31
    18b6:	2d c0       	rjmp	.+90     	; 0x1912 <gc_execute_line+0xa52>
    18b8:	0f 8d       	ldd	r16, Y+31	; 0x1f
    18ba:	18 a1       	ldd	r17, Y+32	; 0x20
    18bc:	00 0f       	add	r16, r16
    18be:	11 1f       	adc	r17, r17
    18c0:	00 0f       	add	r16, r16
    18c2:	11 1f       	adc	r17, r17
    18c4:	0a 56       	subi	r16, 0x6A	; 106
    18c6:	13 4f       	sbci	r17, 0xF3	; 243
    18c8:	60 91 92 0c 	lds	r22, 0x0C92	; 0x800c92 <gc_state+0x3c>
    18cc:	70 91 93 0c 	lds	r23, 0x0C93	; 0x800c93 <gc_state+0x3d>
    18d0:	80 91 94 0c 	lds	r24, 0x0C94	; 0x800c94 <gc_state+0x3e>
    18d4:	90 91 95 0c 	lds	r25, 0x0C95	; 0x800c95 <gc_state+0x3f>
    18d8:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    18dc:	d8 01       	movw	r26, r16
    18de:	9e 96       	adiw	r26, 0x2e	; 46
    18e0:	6d 93       	st	X+, r22
    18e2:	7d 93       	st	X+, r23
    18e4:	8d 93       	st	X+, r24
    18e6:	9c 93       	st	X, r25
    18e8:	d1 97       	sbiw	r26, 0x31	; 49
    18ea:	23 c0       	rjmp	.+70     	; 0x1932 <gc_execute_line+0xa72>
                } else {  // Incremental mode
                  gc_block.values.xyz[idx] += gc_state.position[idx];
    18ec:	f6 01       	movw	r30, r12
    18ee:	20 8d       	ldd	r18, Z+24	; 0x18
    18f0:	31 8d       	ldd	r19, Z+25	; 0x19
    18f2:	42 8d       	ldd	r20, Z+26	; 0x1a
    18f4:	53 8d       	ldd	r21, Z+27	; 0x1b
    18f6:	d8 01       	movw	r26, r16
    18f8:	9e 96       	adiw	r26, 0x2e	; 46
    18fa:	6d 91       	ld	r22, X+
    18fc:	7d 91       	ld	r23, X+
    18fe:	8d 91       	ld	r24, X+
    1900:	9c 91       	ld	r25, X
    1902:	d1 97       	sbiw	r26, 0x31	; 49
    1904:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    1908:	f8 01       	movw	r30, r16
    190a:	66 a7       	std	Z+46, r22	; 0x2e
    190c:	77 a7       	std	Z+47, r23	; 0x2f
    190e:	80 ab       	std	Z+48, r24	; 0x30
    1910:	91 ab       	std	Z+49, r25	; 0x31
    1912:	ff ef       	ldi	r31, 0xFF	; 255
    1914:	8f 1a       	sub	r8, r31
    1916:	9f 0a       	sbc	r9, r31
    1918:	24 e0       	ldi	r18, 0x04	; 4
    191a:	c2 0e       	add	r12, r18
    191c:	d1 1c       	adc	r13, r1
    191e:	0c 5f       	subi	r16, 0xFC	; 252
    1920:	1f 4f       	sbci	r17, 0xFF	; 255
    1922:	34 e0       	ldi	r19, 0x04	; 4
    1924:	63 0e       	add	r6, r19
    1926:	71 1c       	adc	r7, r1
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    1928:	43 e0       	ldi	r20, 0x03	; 3
    192a:	84 16       	cp	r8, r20
    192c:	91 04       	cpc	r9, r1
    192e:	09 f0       	breq	.+2      	; 0x1932 <gc_execute_line+0xa72>
    1930:	86 cf       	rjmp	.-244    	; 0x183e <gc_execute_line+0x97e>
          }
        }
      }

      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {
    1932:	8e e1       	ldi	r24, 0x1E	; 30
    1934:	b8 16       	cp	r11, r24
    1936:	31 f0       	breq	.+12     	; 0x1944 <gc_execute_line+0xa84>
    1938:	95 e3       	ldi	r25, 0x35	; 53
    193a:	b9 16       	cp	r11, r25
    193c:	99 f1       	breq	.+102    	; 0x19a4 <gc_execute_line+0xae4>
    193e:	ac e1       	ldi	r26, 0x1C	; 28
    1940:	ba 12       	cpse	r11, r26
    1942:	35 c0       	rjmp	.+106    	; 0x19ae <gc_execute_line+0xaee>
        case NON_MODAL_GO_HOME_0: // G28
        case NON_MODAL_GO_HOME_1: // G30
          // [G28/30 Errors]: Cutter compensation is enabled.
          // Retreive G28/30 go-home position data (in machine coordinates) from EEPROM
          // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
    1944:	bc e1       	ldi	r27, 0x1C	; 28
    1946:	bb 12       	cpse	r11, r27
    1948:	09 c0       	rjmp	.+18     	; 0x195c <gc_execute_line+0xa9c>
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    194a:	66 ea       	ldi	r22, 0xA6	; 166
    194c:	7c e0       	ldi	r23, 0x0C	; 12
    194e:	86 e0       	ldi	r24, 0x06	; 6
    1950:	0e 94 1a 26 	call	0x4c34	; 0x4c34 <settings_read_coord_data>
    1954:	88 23       	and	r24, r24
    1956:	09 f4       	brne	.+2      	; 0x195a <gc_execute_line+0xa9a>
    1958:	34 c5       	rjmp	.+2664   	; 0x23c2 <__stack+0x1c3>
    195a:	78 c5       	rjmp	.+2800   	; 0x244c <__stack+0x24d>
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    195c:	66 ea       	ldi	r22, 0xA6	; 166
    195e:	7c e0       	ldi	r23, 0x0C	; 12
    1960:	87 e0       	ldi	r24, 0x07	; 7
    1962:	0e 94 1a 26 	call	0x4c34	; 0x4c34 <settings_read_coord_data>
    1966:	88 23       	and	r24, r24
    1968:	09 f4       	brne	.+2      	; 0x196c <gc_execute_line+0xaac>
    196a:	2d c5       	rjmp	.+2650   	; 0x23c6 <__stack+0x1c7>
    196c:	6f c5       	rjmp	.+2782   	; 0x244c <__stack+0x24d>
          }
          if (axis_words) {
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
    196e:	a9 01       	movw	r20, r18
    1970:	08 2e       	mov	r0, r24
    1972:	02 c0       	rjmp	.+4      	; 0x1978 <gc_execute_line+0xab8>
    1974:	55 95       	asr	r21
    1976:	47 95       	ror	r20
    1978:	0a 94       	dec	r0
    197a:	e2 f7       	brpl	.-8      	; 0x1974 <gc_execute_line+0xab4>
    197c:	40 fd       	sbrc	r20, 0
    197e:	0a c0       	rjmp	.+20     	; 0x1994 <gc_execute_line+0xad4>
    1980:	58 96       	adiw	r26, 0x18	; 24
    1982:	4d 91       	ld	r20, X+
    1984:	5d 91       	ld	r21, X+
    1986:	6d 91       	ld	r22, X+
    1988:	7c 91       	ld	r23, X
    198a:	5b 97       	sbiw	r26, 0x1b	; 27
    198c:	40 8b       	std	Z+16, r20	; 0x10
    198e:	51 8b       	std	Z+17, r21	; 0x11
    1990:	62 8b       	std	Z+18, r22	; 0x12
    1992:	73 8b       	std	Z+19, r23	; 0x13
    1994:	01 96       	adiw	r24, 0x01	; 1
    1996:	14 96       	adiw	r26, 0x04	; 4
    1998:	34 96       	adiw	r30, 0x04	; 4
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
          }
          if (axis_words) {
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
    199a:	83 30       	cpi	r24, 0x03	; 3
    199c:	91 05       	cpc	r25, r1
    199e:	39 f7       	brne	.-50     	; 0x196e <gc_execute_line+0xaae>
  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes

  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    19a0:	1f 8e       	std	Y+31, r1	; 0x1f
    19a2:	60 c5       	rjmp	.+2752   	; 0x2464 <__stack+0x265>
          // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
    19a4:	80 91 97 0c 	lds	r24, 0x0C97	; 0x800c97 <gc_block+0x1>
    19a8:	82 30       	cpi	r24, 0x02	; 2
    19aa:	08 f0       	brcs	.+2      	; 0x19ae <gc_execute_line+0xaee>
    19ac:	0e c5       	rjmp	.+2588   	; 0x23ca <__stack+0x1cb>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    19ae:	10 91 97 0c 	lds	r17, 0x0C97	; 0x800c97 <gc_block+0x1>
    19b2:	10 35       	cpi	r17, 0x50	; 80
    19b4:	29 f4       	brne	.+10     	; 0x19c0 <gc_execute_line+0xb00>
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    19b6:	e9 a1       	ldd	r30, Y+33	; 0x21
    19b8:	e1 11       	cpse	r30, r1
    19ba:	09 c5       	rjmp	.+2578   	; 0x23ce <__stack+0x1cf>
    19bc:	1f 8e       	std	Y+31, r1	; 0x1f
    19be:	46 c2       	rjmp	.+1164   	; 0x1e4c <gc_execute_line+0xf8c>
    19c0:	1f 8e       	std	Y+31, r1	; 0x1f

  // Check remaining motion modes, if axis word are implicit (exist and not used by G10/28/30/92), or
  // was explicitly commanded in the g-code block.
  } else if ( axis_command == AXIS_COMMAND_MOTION_MODE ) {
    19c2:	fa a1       	ldd	r31, Y+34	; 0x22
    19c4:	f2 30       	cpi	r31, 0x02	; 2
    19c6:	09 f0       	breq	.+2      	; 0x19ca <gc_execute_line+0xb0a>
    19c8:	41 c2       	rjmp	.+1154   	; 0x1e4c <gc_execute_line+0xf8c>

    if (gc_block.modal.motion == MOTION_MODE_SEEK) {
    19ca:	11 11       	cpse	r17, r1
    19cc:	05 c0       	rjmp	.+10     	; 0x19d8 <gc_execute_line+0xb18>
      // [G0 Errors]: Axis letter not configured or without real value (done.)
      // Axis words are optional. If missing, set axis command flag to ignore execution.
      if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    19ce:	29 a1       	ldd	r18, Y+33	; 0x21
    19d0:	21 11       	cpse	r18, r1
    19d2:	3c c2       	rjmp	.+1144   	; 0x1e4c <gc_execute_line+0xf8c>
    19d4:	1a a2       	std	Y+34, r1	; 0x22
    19d6:	3a c2       	rjmp	.+1140   	; 0x1e4c <gc_execute_line+0xf8c>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    19d8:	20 e0       	ldi	r18, 0x00	; 0
    19da:	30 e0       	ldi	r19, 0x00	; 0
    19dc:	a9 01       	movw	r20, r18
    19de:	60 91 a2 0c 	lds	r22, 0x0CA2	; 0x800ca2 <gc_block+0xc>
    19e2:	70 91 a3 0c 	lds	r23, 0x0CA3	; 0x800ca3 <gc_block+0xd>
    19e6:	80 91 a4 0c 	lds	r24, 0x0CA4	; 0x800ca4 <gc_block+0xe>
    19ea:	90 91 a5 0c 	lds	r25, 0x0CA5	; 0x800ca5 <gc_block+0xf>
    19ee:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    19f2:	88 23       	and	r24, r24
    19f4:	09 f4       	brne	.+2      	; 0x19f8 <gc_execute_line+0xb38>
    19f6:	ed c4       	rjmp	.+2522   	; 0x23d2 <__stack+0x1d3>

      switch (gc_block.modal.motion) {
    19f8:	1c 38       	cpi	r17, 0x8C	; 140
    19fa:	09 f4       	brne	.+2      	; 0x19fe <gc_execute_line+0xb3e>
    19fc:	0f c2       	rjmp	.+1054   	; 0x1e1c <gc_execute_line+0xf5c>
    19fe:	40 f4       	brcc	.+16     	; 0x1a10 <gc_execute_line+0xb50>
    1a00:	12 30       	cpi	r17, 0x02	; 2
    1a02:	a1 f0       	breq	.+40     	; 0x1a2c <gc_execute_line+0xb6c>
    1a04:	13 30       	cpi	r17, 0x03	; 3
    1a06:	a9 f0       	breq	.+42     	; 0x1a32 <gc_execute_line+0xb72>
    1a08:	11 30       	cpi	r17, 0x01	; 1
    1a0a:	09 f0       	breq	.+2      	; 0x1a0e <gc_execute_line+0xb4e>
    1a0c:	1f c2       	rjmp	.+1086   	; 0x1e4c <gc_execute_line+0xf8c>
    1a0e:	09 c0       	rjmp	.+18     	; 0x1a22 <gc_execute_line+0xb62>
    1a10:	1e 38       	cpi	r17, 0x8E	; 142
    1a12:	09 f4       	brne	.+2      	; 0x1a16 <gc_execute_line+0xb56>
    1a14:	03 c2       	rjmp	.+1030   	; 0x1e1c <gc_execute_line+0xf5c>
    1a16:	08 f4       	brcc	.+2      	; 0x1a1a <gc_execute_line+0xb5a>
    1a18:	fe c1       	rjmp	.+1020   	; 0x1e16 <gc_execute_line+0xf56>
    1a1a:	1f 38       	cpi	r17, 0x8F	; 143
    1a1c:	09 f4       	brne	.+2      	; 0x1a20 <gc_execute_line+0xb60>
    1a1e:	fb c1       	rjmp	.+1014   	; 0x1e16 <gc_execute_line+0xf56>
    1a20:	15 c2       	rjmp	.+1066   	; 0x1e4c <gc_execute_line+0xf8c>
        case MOTION_MODE_LINEAR:
          // [G1 Errors]: Feed rate undefined. Axis letter not configured or without real value.
          // Axis words are optional. If missing, set axis command flag to ignore execution.
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    1a22:	39 a1       	ldd	r19, Y+33	; 0x21
    1a24:	31 11       	cpse	r19, r1
    1a26:	12 c2       	rjmp	.+1060   	; 0x1e4c <gc_execute_line+0xf8c>
    1a28:	1a a2       	std	Y+34, r1	; 0x22
    1a2a:	10 c2       	rjmp	.+1056   	; 0x1e4c <gc_execute_line+0xf8c>
          break;
        case MOTION_MODE_CW_ARC: 
          gc_parser_flags |= GC_PARSER_ARC_IS_CLOCKWISE; // No break intentional.
    1a2c:	4c a1       	ldd	r20, Y+36	; 0x24
    1a2e:	44 60       	ori	r20, 0x04	; 4
    1a30:	4c a3       	std	Y+36, r20	; 0x24
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.

          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1a32:	89 a1       	ldd	r24, Y+33	; 0x21
    1a34:	88 23       	and	r24, r24
    1a36:	09 f4       	brne	.+2      	; 0x1a3a <gc_execute_line+0xb7a>
    1a38:	ce c4       	rjmp	.+2460   	; 0x23d6 <__stack+0x1d7>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    1a3a:	bd a1       	ldd	r27, Y+37	; 0x25
    1a3c:	ab 2f       	mov	r26, r27
    1a3e:	b0 e0       	ldi	r27, 0x00	; 0
    1a40:	b9 ab       	std	Y+49, r27	; 0x31
    1a42:	a8 ab       	std	Y+48, r26	; 0x30
    1a44:	ee a1       	ldd	r30, Y+38	; 0x26
    1a46:	ce 2e       	mov	r12, r30
    1a48:	d1 2c       	mov	r13, r1
    1a4a:	81 e0       	ldi	r24, 0x01	; 1
    1a4c:	90 e0       	ldi	r25, 0x00	; 0
    1a4e:	8c 01       	movw	r16, r24
    1a50:	0d a0       	ldd	r0, Y+37	; 0x25
    1a52:	02 c0       	rjmp	.+4      	; 0x1a58 <gc_execute_line+0xb98>
    1a54:	00 0f       	add	r16, r16
    1a56:	11 1f       	adc	r17, r17
    1a58:	0a 94       	dec	r0
    1a5a:	e2 f7       	brpl	.-8      	; 0x1a54 <gc_execute_line+0xb94>
    1a5c:	02 c0       	rjmp	.+4      	; 0x1a62 <gc_execute_line+0xba2>
    1a5e:	88 0f       	add	r24, r24
    1a60:	99 1f       	adc	r25, r25
    1a62:	ea 95       	dec	r30
    1a64:	e2 f7       	brpl	.-8      	; 0x1a5e <gc_execute_line+0xb9e>
    1a66:	08 2b       	or	r16, r24
    1a68:	19 2b       	or	r17, r25
    1a6a:	f9 a1       	ldd	r31, Y+33	; 0x21
    1a6c:	8f 2f       	mov	r24, r31
    1a6e:	90 e0       	ldi	r25, 0x00	; 0
    1a70:	80 23       	and	r24, r16
    1a72:	91 23       	and	r25, r17
    1a74:	89 2b       	or	r24, r25
    1a76:	09 f4       	brne	.+2      	; 0x1a7a <gc_execute_line+0xbba>
    1a78:	b0 c4       	rjmp	.+2400   	; 0x23da <__stack+0x1db>

          // Calculate the change in position along each selected axis
          float x,y;
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
    1a7a:	fd 01       	movw	r30, r26
    1a7c:	ee 0f       	add	r30, r30
    1a7e:	ff 1f       	adc	r31, r31
    1a80:	ee 0f       	add	r30, r30
    1a82:	ff 1f       	adc	r31, r31
    1a84:	ea 56       	subi	r30, 0x6A	; 106
    1a86:	f3 4f       	sbci	r31, 0xF3	; 243
    1a88:	aa 0f       	add	r26, r26
    1a8a:	bb 1f       	adc	r27, r27
    1a8c:	aa 0f       	add	r26, r26
    1a8e:	bb 1f       	adc	r27, r27
    1a90:	a2 59       	subi	r26, 0x92	; 146
    1a92:	b3 4f       	sbci	r27, 0xF3	; 243
    1a94:	2d 91       	ld	r18, X+
    1a96:	3d 91       	ld	r19, X+
    1a98:	4d 91       	ld	r20, X+
    1a9a:	5c 91       	ld	r21, X
    1a9c:	66 a5       	ldd	r22, Z+46	; 0x2e
    1a9e:	77 a5       	ldd	r23, Z+47	; 0x2f
    1aa0:	80 a9       	ldd	r24, Z+48	; 0x30
    1aa2:	91 a9       	ldd	r25, Z+49	; 0x31
    1aa4:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    1aa8:	6f a3       	std	Y+39, r22	; 0x27
    1aaa:	78 a7       	std	Y+40, r23	; 0x28
    1aac:	89 a7       	std	Y+41, r24	; 0x29
    1aae:	9a a7       	std	Y+42, r25	; 0x2a
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target
    1ab0:	f6 01       	movw	r30, r12
    1ab2:	ee 0f       	add	r30, r30
    1ab4:	ff 1f       	adc	r31, r31
    1ab6:	ee 0f       	add	r30, r30
    1ab8:	ff 1f       	adc	r31, r31
    1aba:	ea 56       	subi	r30, 0x6A	; 106
    1abc:	f3 4f       	sbci	r31, 0xF3	; 243
    1abe:	d6 01       	movw	r26, r12
    1ac0:	aa 0f       	add	r26, r26
    1ac2:	bb 1f       	adc	r27, r27
    1ac4:	aa 0f       	add	r26, r26
    1ac6:	bb 1f       	adc	r27, r27
    1ac8:	a2 59       	subi	r26, 0x92	; 146
    1aca:	b3 4f       	sbci	r27, 0xF3	; 243
    1acc:	2d 91       	ld	r18, X+
    1ace:	3d 91       	ld	r19, X+
    1ad0:	4d 91       	ld	r20, X+
    1ad2:	5c 91       	ld	r21, X
    1ad4:	66 a5       	ldd	r22, Z+46	; 0x2e
    1ad6:	77 a5       	ldd	r23, Z+47	; 0x2f
    1ad8:	80 a9       	ldd	r24, Z+48	; 0x30
    1ada:	91 a9       	ldd	r25, Z+49	; 0x31
    1adc:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    1ae0:	6b a7       	std	Y+43, r22	; 0x2b
    1ae2:	7c a7       	std	Y+44, r23	; 0x2c
    1ae4:	8d a7       	std	Y+45, r24	; 0x2d
    1ae6:	9e a7       	std	Y+46, r25	; 0x2e

          if (value_words & bit(WORD_R)) { // Arc Radius Mode
    1ae8:	27 fe       	sbrs	r2, 7
    1aea:	ea c0       	rjmp	.+468    	; 0x1cc0 <gc_execute_line+0xe00>
            bit_false(value_words,bit(WORD_R));
    1aec:	e8 94       	clt
    1aee:	27 f8       	bld	r2, 7
            if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    1af0:	4c e0       	ldi	r20, 0x0C	; 12
    1af2:	50 e0       	ldi	r21, 0x00	; 0
    1af4:	64 ec       	ldi	r22, 0xC4	; 196
    1af6:	7c e0       	ldi	r23, 0x0C	; 12
    1af8:	8e e6       	ldi	r24, 0x6E	; 110
    1afa:	9c e0       	ldi	r25, 0x0C	; 12
    1afc:	0e 94 cd 42 	call	0x859a	; 0x859a <memcmp>
    1b00:	89 2b       	or	r24, r25
    1b02:	09 f4       	brne	.+2      	; 0x1b06 <gc_execute_line+0xc46>
    1b04:	6c c4       	rjmp	.+2264   	; 0x23de <__stack+0x1df>

            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
    1b06:	80 91 99 0c 	lds	r24, 0x0C99	; 0x800c99 <gc_block+0x3>
    1b0a:	81 30       	cpi	r24, 0x01	; 1
    1b0c:	a1 f4       	brne	.+40     	; 0x1b36 <gc_execute_line+0xc76>
    1b0e:	06 e9       	ldi	r16, 0x96	; 150
    1b10:	1c e0       	ldi	r17, 0x0C	; 12
    1b12:	23 e3       	ldi	r18, 0x33	; 51
    1b14:	33 e3       	ldi	r19, 0x33	; 51
    1b16:	4b ec       	ldi	r20, 0xCB	; 203
    1b18:	51 e4       	ldi	r21, 0x41	; 65
    1b1a:	d8 01       	movw	r26, r16
    1b1c:	95 96       	adiw	r26, 0x25	; 37
    1b1e:	6d 91       	ld	r22, X+
    1b20:	7d 91       	ld	r23, X+
    1b22:	8d 91       	ld	r24, X+
    1b24:	9c 91       	ld	r25, X
    1b26:	98 97       	sbiw	r26, 0x28	; 40
    1b28:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    1b2c:	f8 01       	movw	r30, r16
    1b2e:	65 a3       	std	Z+37, r22	; 0x25
    1b30:	76 a3       	std	Z+38, r23	; 0x26
    1b32:	87 a3       	std	Z+39, r24	; 0x27
    1b34:	90 a7       	std	Z+40, r25	; 0x28
                j = (y + (x * h_x2_div_d))/2
            */

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;
    1b36:	80 90 bb 0c 	lds	r8, 0x0CBB	; 0x800cbb <gc_block+0x25>
    1b3a:	90 90 bc 0c 	lds	r9, 0x0CBC	; 0x800cbc <gc_block+0x26>
    1b3e:	a0 90 bd 0c 	lds	r10, 0x0CBD	; 0x800cbd <gc_block+0x27>
    1b42:	b0 90 be 0c 	lds	r11, 0x0CBE	; 0x800cbe <gc_block+0x28>
    1b46:	20 e0       	ldi	r18, 0x00	; 0
    1b48:	30 e0       	ldi	r19, 0x00	; 0
    1b4a:	40 e8       	ldi	r20, 0x80	; 128
    1b4c:	50 e4       	ldi	r21, 0x40	; 64
    1b4e:	c5 01       	movw	r24, r10
    1b50:	b4 01       	movw	r22, r8
    1b52:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    1b56:	a5 01       	movw	r20, r10
    1b58:	94 01       	movw	r18, r8
    1b5a:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    1b5e:	4b 01       	movw	r8, r22
    1b60:	5c 01       	movw	r10, r24
    1b62:	2f a1       	ldd	r18, Y+39	; 0x27
    1b64:	38 a5       	ldd	r19, Y+40	; 0x28
    1b66:	49 a5       	ldd	r20, Y+41	; 0x29
    1b68:	5a a5       	ldd	r21, Y+42	; 0x2a
    1b6a:	ca 01       	movw	r24, r20
    1b6c:	b9 01       	movw	r22, r18
    1b6e:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    1b72:	9b 01       	movw	r18, r22
    1b74:	ac 01       	movw	r20, r24
    1b76:	c5 01       	movw	r24, r10
    1b78:	b4 01       	movw	r22, r8
    1b7a:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    1b7e:	4b 01       	movw	r8, r22
    1b80:	5c 01       	movw	r10, r24
    1b82:	2b a5       	ldd	r18, Y+43	; 0x2b
    1b84:	3c a5       	ldd	r19, Y+44	; 0x2c
    1b86:	4d a5       	ldd	r20, Y+45	; 0x2d
    1b88:	5e a5       	ldd	r21, Y+46	; 0x2e
    1b8a:	ca 01       	movw	r24, r20
    1b8c:	b9 01       	movw	r22, r18
    1b8e:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    1b92:	9b 01       	movw	r18, r22
    1b94:	ac 01       	movw	r20, r24
    1b96:	c5 01       	movw	r24, r10
    1b98:	b4 01       	movw	r22, r8
    1b9a:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    1b9e:	4b 01       	movw	r8, r22
    1ba0:	5c 01       	movw	r10, r24

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    1ba2:	20 e0       	ldi	r18, 0x00	; 0
    1ba4:	30 e0       	ldi	r19, 0x00	; 0
    1ba6:	a9 01       	movw	r20, r18
    1ba8:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    1bac:	88 23       	and	r24, r24
    1bae:	0c f4       	brge	.+2      	; 0x1bb2 <gc_execute_line+0xcf2>
    1bb0:	18 c4       	rjmp	.+2096   	; 0x23e2 <__stack+0x1e3>

            // Finish computing h_x2_div_d.
            h_x2_div_d = -sqrt(h_x2_div_d)/hypot_f(x,y); // == -(h * 2 / d)
    1bb2:	c5 01       	movw	r24, r10
    1bb4:	b4 01       	movw	r22, r8
    1bb6:	0e 94 34 42 	call	0x8468	; 0x8468 <sqrt>
    1bba:	4b 01       	movw	r8, r22
    1bbc:	5c 01       	movw	r10, r24
    1bbe:	2b a5       	ldd	r18, Y+43	; 0x2b
    1bc0:	3c a5       	ldd	r19, Y+44	; 0x2c
    1bc2:	4d a5       	ldd	r20, Y+45	; 0x2d
    1bc4:	5e a5       	ldd	r21, Y+46	; 0x2e
    1bc6:	6f a1       	ldd	r22, Y+39	; 0x27
    1bc8:	78 a5       	ldd	r23, Y+40	; 0x28
    1bca:	89 a5       	ldd	r24, Y+41	; 0x29
    1bcc:	9a a5       	ldd	r25, Y+42	; 0x2a
    1bce:	0e 94 3b 2f 	call	0x5e76	; 0x5e76 <hypot_f>
    1bd2:	9b 01       	movw	r18, r22
    1bd4:	ac 01       	movw	r20, r24
    1bd6:	c5 01       	movw	r24, r10
    1bd8:	b4 01       	movw	r22, r8
    1bda:	90 58       	subi	r25, 0x80	; 128
    1bdc:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <__divsf3>
    1be0:	4b 01       	movw	r8, r22
    1be2:	5c 01       	movw	r10, r24
            // Invert the sign of h_x2_div_d if the circle is counter clockwise (see sketch below)
            if (gc_block.modal.motion == MOTION_MODE_CCW_ARC) { h_x2_div_d = -h_x2_div_d; }
    1be4:	80 91 97 0c 	lds	r24, 0x0C97	; 0x800c97 <gc_block+0x1>
    1be8:	83 30       	cpi	r24, 0x03	; 3
    1bea:	21 f4       	brne	.+8      	; 0x1bf4 <gc_execute_line+0xd34>
    1bec:	b7 fa       	bst	r11, 7
    1bee:	b0 94       	com	r11
    1bf0:	b7 f8       	bld	r11, 7
    1bf2:	b0 94       	com	r11
            */
            // Negative R is g-code-alese for "I want a circle with more than 180 degrees of travel" (go figure!),
            // even though it is advised against ever generating such circles in a single line of g-code. By
            // inverting the sign of h_x2_div_d the center of the circles is placed on the opposite side of the line of
            // travel and thus we get the unadvisably long arcs as prescribed.
            if (gc_block.values.r < 0) {
    1bf4:	40 90 bb 0c 	lds	r4, 0x0CBB	; 0x800cbb <gc_block+0x25>
    1bf8:	50 90 bc 0c 	lds	r5, 0x0CBC	; 0x800cbc <gc_block+0x26>
    1bfc:	60 90 bd 0c 	lds	r6, 0x0CBD	; 0x800cbd <gc_block+0x27>
    1c00:	70 90 be 0c 	lds	r7, 0x0CBE	; 0x800cbe <gc_block+0x28>
    1c04:	20 e0       	ldi	r18, 0x00	; 0
    1c06:	30 e0       	ldi	r19, 0x00	; 0
    1c08:	a9 01       	movw	r20, r18
    1c0a:	c3 01       	movw	r24, r6
    1c0c:	b2 01       	movw	r22, r4
    1c0e:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    1c12:	88 23       	and	r24, r24
    1c14:	84 f4       	brge	.+32     	; 0x1c36 <gc_execute_line+0xd76>
                h_x2_div_d = -h_x2_div_d;
    1c16:	b7 fa       	bst	r11, 7
    1c18:	b0 94       	com	r11
    1c1a:	b7 f8       	bld	r11, 7
    1c1c:	b0 94       	com	r11
                gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
    1c1e:	77 fa       	bst	r7, 7
    1c20:	70 94       	com	r7
    1c22:	77 f8       	bld	r7, 7
    1c24:	70 94       	com	r7
    1c26:	40 92 bb 0c 	sts	0x0CBB, r4	; 0x800cbb <gc_block+0x25>
    1c2a:	50 92 bc 0c 	sts	0x0CBC, r5	; 0x800cbc <gc_block+0x26>
    1c2e:	60 92 bd 0c 	sts	0x0CBD, r6	; 0x800cbd <gc_block+0x27>
    1c32:	70 92 be 0c 	sts	0x0CBE, r7	; 0x800cbe <gc_block+0x28>
            }
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
    1c36:	08 a9       	ldd	r16, Y+48	; 0x30
    1c38:	19 a9       	ldd	r17, Y+49	; 0x31
    1c3a:	00 0f       	add	r16, r16
    1c3c:	11 1f       	adc	r17, r17
    1c3e:	00 0f       	add	r16, r16
    1c40:	11 1f       	adc	r17, r17
    1c42:	0a 55       	subi	r16, 0x5A	; 90
    1c44:	13 4f       	sbci	r17, 0xF3	; 243
    1c46:	2b a5       	ldd	r18, Y+43	; 0x2b
    1c48:	3c a5       	ldd	r19, Y+44	; 0x2c
    1c4a:	4d a5       	ldd	r20, Y+45	; 0x2d
    1c4c:	5e a5       	ldd	r21, Y+46	; 0x2e
    1c4e:	c5 01       	movw	r24, r10
    1c50:	b4 01       	movw	r22, r8
    1c52:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    1c56:	9b 01       	movw	r18, r22
    1c58:	ac 01       	movw	r20, r24
    1c5a:	6f a1       	ldd	r22, Y+39	; 0x27
    1c5c:	78 a5       	ldd	r23, Y+40	; 0x28
    1c5e:	89 a5       	ldd	r24, Y+41	; 0x29
    1c60:	9a a5       	ldd	r25, Y+42	; 0x2a
    1c62:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    1c66:	20 e0       	ldi	r18, 0x00	; 0
    1c68:	30 e0       	ldi	r19, 0x00	; 0
    1c6a:	40 e0       	ldi	r20, 0x00	; 0
    1c6c:	5f e3       	ldi	r21, 0x3F	; 63
    1c6e:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    1c72:	d8 01       	movw	r26, r16
    1c74:	6d 93       	st	X+, r22
    1c76:	7d 93       	st	X+, r23
    1c78:	8d 93       	st	X+, r24
    1c7a:	9c 93       	st	X, r25
    1c7c:	13 97       	sbiw	r26, 0x03	; 3
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
    1c7e:	86 01       	movw	r16, r12
    1c80:	00 0f       	add	r16, r16
    1c82:	11 1f       	adc	r17, r17
    1c84:	00 0f       	add	r16, r16
    1c86:	11 1f       	adc	r17, r17
    1c88:	0a 55       	subi	r16, 0x5A	; 90
    1c8a:	13 4f       	sbci	r17, 0xF3	; 243
    1c8c:	2f a1       	ldd	r18, Y+39	; 0x27
    1c8e:	38 a5       	ldd	r19, Y+40	; 0x28
    1c90:	49 a5       	ldd	r20, Y+41	; 0x29
    1c92:	5a a5       	ldd	r21, Y+42	; 0x2a
    1c94:	c5 01       	movw	r24, r10
    1c96:	b4 01       	movw	r22, r8
    1c98:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    1c9c:	2b a5       	ldd	r18, Y+43	; 0x2b
    1c9e:	3c a5       	ldd	r19, Y+44	; 0x2c
    1ca0:	4d a5       	ldd	r20, Y+45	; 0x2d
    1ca2:	5e a5       	ldd	r21, Y+46	; 0x2e
    1ca4:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    1ca8:	20 e0       	ldi	r18, 0x00	; 0
    1caa:	30 e0       	ldi	r19, 0x00	; 0
    1cac:	40 e0       	ldi	r20, 0x00	; 0
    1cae:	5f e3       	ldi	r21, 0x3F	; 63
    1cb0:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    1cb4:	f8 01       	movw	r30, r16
    1cb6:	60 83       	st	Z, r22
    1cb8:	71 83       	std	Z+1, r23	; 0x01
    1cba:	82 83       	std	Z+2, r24	; 0x02
    1cbc:	93 83       	std	Z+3, r25	; 0x03
    1cbe:	c6 c0       	rjmp	.+396    	; 0x1e4c <gc_execute_line+0xf8c>

          } else { // Arc Center Format Offset Mode
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    1cc0:	fb a1       	ldd	r31, Y+35	; 0x23
    1cc2:	8f 2e       	mov	r8, r31
    1cc4:	91 2c       	mov	r9, r1
    1cc6:	08 21       	and	r16, r8
    1cc8:	19 21       	and	r17, r9
    1cca:	01 2b       	or	r16, r17
    1ccc:	09 f4       	brne	.+2      	; 0x1cd0 <gc_execute_line+0xe10>
    1cce:	8b c3       	rjmp	.+1814   	; 0x23e6 <__stack+0x1e7>
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));
    1cd0:	21 ef       	ldi	r18, 0xF1	; 241
    1cd2:	22 22       	and	r2, r18

            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
    1cd4:	80 91 99 0c 	lds	r24, 0x0C99	; 0x800c99 <gc_block+0x3>
    1cd8:	81 30       	cpi	r24, 0x01	; 1
    1cda:	41 f5       	brne	.+80     	; 0x1d2c <gc_execute_line+0xe6c>
    1cdc:	06 e9       	ldi	r16, 0x96	; 150
    1cde:	1c e0       	ldi	r17, 0x0C	; 12
    1ce0:	a1 2c       	mov	r10, r1
    1ce2:	b1 2c       	mov	r11, r1
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
    1ce4:	c4 01       	movw	r24, r8
    1ce6:	0a 2c       	mov	r0, r10
    1ce8:	02 c0       	rjmp	.+4      	; 0x1cee <gc_execute_line+0xe2e>
    1cea:	95 95       	asr	r25
    1cec:	87 95       	ror	r24
    1cee:	0a 94       	dec	r0
    1cf0:	e2 f7       	brpl	.-8      	; 0x1cea <gc_execute_line+0xe2a>
    1cf2:	80 ff       	sbrs	r24, 0
    1cf4:	12 c0       	rjmp	.+36     	; 0x1d1a <gc_execute_line+0xe5a>
    1cf6:	23 e3       	ldi	r18, 0x33	; 51
    1cf8:	33 e3       	ldi	r19, 0x33	; 51
    1cfa:	4b ec       	ldi	r20, 0xCB	; 203
    1cfc:	51 e4       	ldi	r21, 0x41	; 65
    1cfe:	d8 01       	movw	r26, r16
    1d00:	50 96       	adiw	r26, 0x10	; 16
    1d02:	6d 91       	ld	r22, X+
    1d04:	7d 91       	ld	r23, X+
    1d06:	8d 91       	ld	r24, X+
    1d08:	9c 91       	ld	r25, X
    1d0a:	53 97       	sbiw	r26, 0x13	; 19
    1d0c:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    1d10:	f8 01       	movw	r30, r16
    1d12:	60 8b       	std	Z+16, r22	; 0x10
    1d14:	71 8b       	std	Z+17, r23	; 0x11
    1d16:	82 8b       	std	Z+18, r24	; 0x12
    1d18:	93 8b       	std	Z+19, r25	; 0x13
    1d1a:	ff ef       	ldi	r31, 0xFF	; 255
    1d1c:	af 1a       	sub	r10, r31
    1d1e:	bf 0a       	sbc	r11, r31
    1d20:	0c 5f       	subi	r16, 0xFC	; 252
    1d22:	1f 4f       	sbci	r17, 0xFF	; 255
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));

            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    1d24:	23 e0       	ldi	r18, 0x03	; 3
    1d26:	a2 16       	cp	r10, r18
    1d28:	b1 04       	cpc	r11, r1
    1d2a:	e1 f6       	brne	.-72     	; 0x1ce4 <gc_execute_line+0xe24>
              }
            }

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
    1d2c:	c6 01       	movw	r24, r12
    1d2e:	88 0f       	add	r24, r24
    1d30:	99 1f       	adc	r25, r25
    1d32:	88 0f       	add	r24, r24
    1d34:	99 1f       	adc	r25, r25
    1d36:	dc 01       	movw	r26, r24
    1d38:	aa 55       	subi	r26, 0x5A	; 90
    1d3a:	b3 4f       	sbci	r27, 0xF3	; 243
    1d3c:	6d 01       	movw	r12, r26
            float target_r = hypot_f(x,y);
    1d3e:	2d 91       	ld	r18, X+
    1d40:	3d 91       	ld	r19, X+
    1d42:	4d 91       	ld	r20, X+
    1d44:	5c 91       	ld	r21, X
    1d46:	6b a5       	ldd	r22, Y+43	; 0x2b
    1d48:	7c a5       	ldd	r23, Y+44	; 0x2c
    1d4a:	8d a5       	ldd	r24, Y+45	; 0x2d
    1d4c:	9e a5       	ldd	r25, Y+46	; 0x2e
    1d4e:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    1d52:	4b 01       	movw	r8, r22
    1d54:	5c 01       	movw	r10, r24
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
              }
            }

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
    1d56:	08 a9       	ldd	r16, Y+48	; 0x30
    1d58:	19 a9       	ldd	r17, Y+49	; 0x31
    1d5a:	00 0f       	add	r16, r16
    1d5c:	11 1f       	adc	r17, r17
    1d5e:	00 0f       	add	r16, r16
    1d60:	11 1f       	adc	r17, r17
    1d62:	0a 55       	subi	r16, 0x5A	; 90
    1d64:	13 4f       	sbci	r17, 0xF3	; 243
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
            float target_r = hypot_f(x,y);
    1d66:	f8 01       	movw	r30, r16
    1d68:	20 81       	ld	r18, Z
    1d6a:	31 81       	ldd	r19, Z+1	; 0x01
    1d6c:	42 81       	ldd	r20, Z+2	; 0x02
    1d6e:	53 81       	ldd	r21, Z+3	; 0x03
    1d70:	6f a1       	ldd	r22, Y+39	; 0x27
    1d72:	78 a5       	ldd	r23, Y+40	; 0x28
    1d74:	89 a5       	ldd	r24, Y+41	; 0x29
    1d76:	9a a5       	ldd	r25, Y+42	; 0x2a
    1d78:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    1d7c:	a5 01       	movw	r20, r10
    1d7e:	94 01       	movw	r18, r8
    1d80:	0e 94 3b 2f 	call	0x5e76	; 0x5e76 <hypot_f>
    1d84:	4b 01       	movw	r8, r22
    1d86:	5c 01       	movw	r10, r24

            // Compute arc radius for mc_arc. Defined from current location to center.
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]);
    1d88:	d6 01       	movw	r26, r12
    1d8a:	2d 91       	ld	r18, X+
    1d8c:	3d 91       	ld	r19, X+
    1d8e:	4d 91       	ld	r20, X+
    1d90:	5c 91       	ld	r21, X
    1d92:	f8 01       	movw	r30, r16
    1d94:	60 81       	ld	r22, Z
    1d96:	71 81       	ldd	r23, Z+1	; 0x01
    1d98:	82 81       	ldd	r24, Z+2	; 0x02
    1d9a:	93 81       	ldd	r25, Z+3	; 0x03
    1d9c:	0e 94 3b 2f 	call	0x5e76	; 0x5e76 <hypot_f>
    1da0:	2b 01       	movw	r4, r22
    1da2:	3c 01       	movw	r6, r24
    1da4:	60 93 bb 0c 	sts	0x0CBB, r22	; 0x800cbb <gc_block+0x25>
    1da8:	70 93 bc 0c 	sts	0x0CBC, r23	; 0x800cbc <gc_block+0x26>
    1dac:	80 93 bd 0c 	sts	0x0CBD, r24	; 0x800cbd <gc_block+0x27>
    1db0:	90 93 be 0c 	sts	0x0CBE, r25	; 0x800cbe <gc_block+0x28>

            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
    1db4:	9b 01       	movw	r18, r22
    1db6:	ac 01       	movw	r20, r24
    1db8:	c5 01       	movw	r24, r10
    1dba:	b4 01       	movw	r22, r8
    1dbc:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    1dc0:	4b 01       	movw	r8, r22
    1dc2:	5c 01       	movw	r10, r24
    1dc4:	e8 94       	clt
    1dc6:	b7 f8       	bld	r11, 7
            if (delta_r > 0.005) {
    1dc8:	2a e0       	ldi	r18, 0x0A	; 10
    1dca:	37 ed       	ldi	r19, 0xD7	; 215
    1dcc:	43 ea       	ldi	r20, 0xA3	; 163
    1dce:	5b e3       	ldi	r21, 0x3B	; 59
    1dd0:	c5 01       	movw	r24, r10
    1dd2:	b4 01       	movw	r22, r8
    1dd4:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    1dd8:	18 16       	cp	r1, r24
    1dda:	c4 f5       	brge	.+112    	; 0x1e4c <gc_execute_line+0xf8c>
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    1ddc:	20 e0       	ldi	r18, 0x00	; 0
    1dde:	30 e0       	ldi	r19, 0x00	; 0
    1de0:	40 e0       	ldi	r20, 0x00	; 0
    1de2:	5f e3       	ldi	r21, 0x3F	; 63
    1de4:	c5 01       	movw	r24, r10
    1de6:	b4 01       	movw	r22, r8
    1de8:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    1dec:	18 16       	cp	r1, r24
    1dee:	0c f4       	brge	.+2      	; 0x1df2 <gc_execute_line+0xf32>
    1df0:	fc c2       	rjmp	.+1528   	; 0x23ea <__stack+0x1eb>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    1df2:	2f e6       	ldi	r18, 0x6F	; 111
    1df4:	32 e1       	ldi	r19, 0x12	; 18
    1df6:	43 e8       	ldi	r20, 0x83	; 131
    1df8:	5a e3       	ldi	r21, 0x3A	; 58
    1dfa:	c3 01       	movw	r24, r6
    1dfc:	b2 01       	movw	r22, r4
    1dfe:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    1e02:	9b 01       	movw	r18, r22
    1e04:	ac 01       	movw	r20, r24
    1e06:	c5 01       	movw	r24, r10
    1e08:	b4 01       	movw	r22, r8
    1e0a:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    1e0e:	18 16       	cp	r1, r24
    1e10:	0c f4       	brge	.+2      	; 0x1e14 <gc_execute_line+0xf54>
    1e12:	ed c2       	rjmp	.+1498   	; 0x23ee <__stack+0x1ef>
    1e14:	1b c0       	rjmp	.+54     	; 0x1e4c <gc_execute_line+0xf8c>
            }
          }
          break;
        case MOTION_MODE_PROBE_TOWARD_NO_ERROR: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          gc_parser_flags |= GC_PARSER_PROBE_IS_NO_ERROR; // No break intentional.
    1e16:	fc a1       	ldd	r31, Y+36	; 0x24
    1e18:	f0 61       	ori	r31, 0x10	; 16
    1e1a:	fc a3       	std	Y+36, r31	; 0x24
        case MOTION_MODE_PROBE_TOWARD: case MOTION_MODE_PROBE_AWAY:
          if ((gc_block.modal.motion == MOTION_MODE_PROBE_AWAY) || 
    1e1c:	1e 58       	subi	r17, 0x8E	; 142
    1e1e:	12 30       	cpi	r17, 0x02	; 2
    1e20:	18 f4       	brcc	.+6      	; 0x1e28 <gc_execute_line+0xf68>
              (gc_block.modal.motion == MOTION_MODE_PROBE_AWAY_NO_ERROR)) { gc_parser_flags |= GC_PARSER_PROBE_IS_AWAY; }
    1e22:	2c a1       	ldd	r18, Y+36	; 0x24
    1e24:	28 60       	ori	r18, 0x08	; 8
    1e26:	2c a3       	std	Y+36, r18	; 0x24
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1e28:	39 a1       	ldd	r19, Y+33	; 0x21
    1e2a:	33 23       	and	r19, r19
    1e2c:	09 f4       	brne	.+2      	; 0x1e30 <gc_execute_line+0xf70>
    1e2e:	e1 c2       	rjmp	.+1474   	; 0x23f2 <__stack+0x1f3>
          if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    1e30:	4c e0       	ldi	r20, 0x0C	; 12
    1e32:	50 e0       	ldi	r21, 0x00	; 0
    1e34:	64 ec       	ldi	r22, 0xC4	; 196
    1e36:	7c e0       	ldi	r23, 0x0C	; 12
    1e38:	8e e6       	ldi	r24, 0x6E	; 110
    1e3a:	9c e0       	ldi	r25, 0x0C	; 12
    1e3c:	0e 94 cd 42 	call	0x859a	; 0x859a <memcmp>
    1e40:	89 2b       	or	r24, r25
    1e42:	09 f4       	brne	.+2      	; 0x1e46 <gc_execute_line+0xf86>
    1e44:	d8 c2       	rjmp	.+1456   	; 0x23f6 <__stack+0x1f7>
    1e46:	02 c0       	rjmp	.+4      	; 0x1e4c <gc_execute_line+0xf8c>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    1e48:	1f 8e       	std	Y+31, r1	; 0x1f
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
            }
          } else {
            axis_command = AXIS_COMMAND_NONE; // Set to none if no intermediate motion.
    1e4a:	1a a2       	std	Y+34, r1	; 0x22

  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    1e4c:	4c a1       	ldd	r20, Y+36	; 0x24
    1e4e:	41 70       	andi	r20, 0x01	; 1
    1e50:	d4 2e       	mov	r13, r20
    1e52:	8c a1       	ldd	r24, Y+36	; 0x24
    1e54:	80 ff       	sbrs	r24, 0
    1e56:	03 c0       	rjmp	.+6      	; 0x1e5e <gc_execute_line+0xf9e>
    // Jogging only uses the F feed rate and XYZ value words. N is valid, but S and T are invalid.
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)));
    1e58:	c1 01       	movw	r24, r2
    1e5a:	8e 7d       	andi	r24, 0xDE	; 222
    1e5c:	03 c0       	rjmp	.+6      	; 0x1e64 <gc_execute_line+0xfa4>
  } else {
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words.
    1e5e:	c1 01       	movw	r24, r2
    1e60:	8e 7d       	andi	r24, 0xDE	; 222
    1e62:	9c 7f       	andi	r25, 0xFC	; 252
  }
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words.
    1e64:	aa a1       	ldd	r26, Y+34	; 0x22
    1e66:	a1 11       	cpse	r26, r1
    1e68:	93 7e       	andi	r25, 0xE3	; 227
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    1e6a:	89 2b       	or	r24, r25
    1e6c:	09 f0       	breq	.+2      	; 0x1e70 <gc_execute_line+0xfb0>
    1e6e:	c5 c2       	rjmp	.+1418   	; 0x23fa <__stack+0x1fb>
  */

  // Initialize planner data struct for motion blocks.
  plan_line_data_t plan_data;
  plan_line_data_t *pl_data = &plan_data;
  memset(pl_data,0,sizeof(plan_line_data_t)); // Zero pl_data struct
    1e70:	fe 01       	movw	r30, r28
    1e72:	72 96       	adiw	r30, 0x12	; 18
    1e74:	8d e0       	ldi	r24, 0x0D	; 13
    1e76:	df 01       	movw	r26, r30
    1e78:	1d 92       	st	X+, r1
    1e7a:	8a 95       	dec	r24
    1e7c:	e9 f7       	brne	.-6      	; 0x1e78 <gc_execute_line+0xfb8>

  // Intercept jog commands and complete error checking for valid jog commands and execute.
  // NOTE: G-code parser state is not updated, except the position to ensure sequential jog
  // targets are computed correctly. The final parser position after a jog is updated in
  // protocol_execute_realtime() when jogging completes or is canceled.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    1e7e:	dd 20       	and	r13, r13
    1e80:	59 f1       	breq	.+86     	; 0x1ed8 <gc_execute_line+0x1018>
    // Only distance and unit modal commands and G53 absolute override command are allowed.
    // NOTE: Feed rate word and axis word checks have already been performed in STEP 3.
    if (command_words & ~(bit(MODAL_GROUP_G3) | bit(MODAL_GROUP_G6 | bit(MODAL_GROUP_G0))) ) { FAIL(STATUS_INVALID_JOG_COMMAND) };
    1e82:	b6 eb       	ldi	r27, 0xB6	; 182
    1e84:	eb 22       	and	r14, r27
    1e86:	ef 28       	or	r14, r15
    1e88:	09 f0       	breq	.+2      	; 0x1e8c <gc_execute_line+0xfcc>
    1e8a:	b9 c2       	rjmp	.+1394   	; 0x23fe <__stack+0x1ff>
    if (!(gc_block.non_modal_command == NON_MODAL_ABSOLUTE_OVERRIDE || gc_block.non_modal_command == NON_MODAL_NO_ACTION)) { FAIL(STATUS_INVALID_JOG_COMMAND); }
    1e8c:	80 91 96 0c 	lds	r24, 0x0C96	; 0x800c96 <gc_block>
    1e90:	85 33       	cpi	r24, 0x35	; 53
    1e92:	11 f0       	breq	.+4      	; 0x1e98 <gc_execute_line+0xfd8>
    1e94:	81 11       	cpse	r24, r1
    1e96:	b5 c2       	rjmp	.+1386   	; 0x2402 <__stack+0x203>

    // Initialize planner data to current spindle and coolant modal state.
    pl_data->spindle_speed = gc_state.spindle_speed;
    1e98:	e6 e5       	ldi	r30, 0x56	; 86
    1e9a:	fc e0       	ldi	r31, 0x0C	; 12
    1e9c:	83 85       	ldd	r24, Z+11	; 0x0b
    1e9e:	94 85       	ldd	r25, Z+12	; 0x0c
    1ea0:	a5 85       	ldd	r26, Z+13	; 0x0d
    1ea2:	b6 85       	ldd	r27, Z+14	; 0x0e
    1ea4:	8e 8b       	std	Y+22, r24	; 0x16
    1ea6:	9f 8b       	std	Y+23, r25	; 0x17
    1ea8:	a8 8f       	std	Y+24, r26	; 0x18
    1eaa:	b9 8f       	std	Y+25, r27	; 0x19
    plan_data.condition = (gc_state.modal.spindle | gc_state.modal.coolant);
    1eac:	91 85       	ldd	r25, Z+9	; 0x09
    1eae:	80 85       	ldd	r24, Z+8	; 0x08
    1eb0:	89 2b       	or	r24, r25
    1eb2:	8e 8f       	std	Y+30, r24	; 0x1e

    uint8_t status = jog_execute(&plan_data, &gc_block);
    1eb4:	66 e9       	ldi	r22, 0x96	; 150
    1eb6:	7c e0       	ldi	r23, 0x0C	; 12
    1eb8:	ce 01       	movw	r24, r28
    1eba:	42 96       	adiw	r24, 0x12	; 18
    1ebc:	0e 94 4e 3e 	call	0x7c9c	; 0x7c9c <jog_execute>
    if (status == STATUS_OK) { memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); }
    1ec0:	81 11       	cpse	r24, r1
    1ec2:	ed c2       	rjmp	.+1498   	; 0x249e <__stack+0x29f>
    1ec4:	9c e0       	ldi	r25, 0x0C	; 12
    1ec6:	e4 ec       	ldi	r30, 0xC4	; 196
    1ec8:	fc e0       	ldi	r31, 0x0C	; 12
    1eca:	ae e6       	ldi	r26, 0x6E	; 110
    1ecc:	bc e0       	ldi	r27, 0x0C	; 12
    1ece:	01 90       	ld	r0, Z+
    1ed0:	0d 92       	st	X+, r0
    1ed2:	9a 95       	dec	r25
    1ed4:	e1 f7       	brne	.-8      	; 0x1ece <gc_execute_line+0x100e>
    1ed6:	e3 c2       	rjmp	.+1478   	; 0x249e <__stack+0x29f>
    return(status);
  }
  
  // If in laser mode, setup laser power based on current and past parser conditions.
  if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    1ed8:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    1edc:	81 ff       	sbrs	r24, 1
    1ede:	26 c0       	rjmp	.+76     	; 0x1f2c <gc_execute_line+0x106c>
    if ( !((gc_block.modal.motion == MOTION_MODE_LINEAR) || (gc_block.modal.motion == MOTION_MODE_CW_ARC) 
    1ee0:	80 91 97 0c 	lds	r24, 0x0C97	; 0x800c97 <gc_block+0x1>
    1ee4:	81 50       	subi	r24, 0x01	; 1
    1ee6:	83 30       	cpi	r24, 0x03	; 3
    1ee8:	18 f0       	brcs	.+6      	; 0x1ef0 <gc_execute_line+0x1030>
        || (gc_block.modal.motion == MOTION_MODE_CCW_ARC)) ) {
      gc_parser_flags |= GC_PARSER_LASER_DISABLE;
    1eea:	ec a1       	ldd	r30, Y+36	; 0x24
    1eec:	e0 64       	ori	r30, 0x40	; 64
    1eee:	ec a3       	std	Y+36, r30	; 0x24
    }

    // Any motion mode with axis words is allowed to be passed from a spindle speed update. 
    // NOTE: G1 and G0 without axis words sets axis_command to none. G28/30 are intentionally omitted.
    // TODO: Check sync conditions for M3 enabled motions that don't enter the planner. (zero length).
    if (axis_words && (axis_command == AXIS_COMMAND_MOTION_MODE)) { 
    1ef0:	f9 a1       	ldd	r31, Y+33	; 0x21
    1ef2:	ff 23       	and	r31, r31
    1ef4:	39 f0       	breq	.+14     	; 0x1f04 <gc_execute_line+0x1044>
    1ef6:	2a a1       	ldd	r18, Y+34	; 0x22
    1ef8:	22 30       	cpi	r18, 0x02	; 2
    1efa:	21 f4       	brne	.+8      	; 0x1f04 <gc_execute_line+0x1044>
      gc_parser_flags |= GC_PARSER_LASER_ISMOTION; 
    1efc:	3c a1       	ldd	r19, Y+36	; 0x24
    1efe:	30 68       	ori	r19, 0x80	; 128
    1f00:	3c a3       	std	Y+36, r19	; 0x24
    1f02:	14 c0       	rjmp	.+40     	; 0x1f2c <gc_execute_line+0x106c>
    } else {
      // M3 constant power laser requires planner syncs to update the laser when changing between
      // a G1/2/3 motion mode state and vice versa when there is no motion in the line.
      if (gc_state.modal.spindle == SPINDLE_ENABLE_CW) {
    1f04:	80 91 5f 0c 	lds	r24, 0x0C5F	; 0x800c5f <gc_state+0x9>
    1f08:	80 31       	cpi	r24, 0x10	; 16
    1f0a:	81 f4       	brne	.+32     	; 0x1f2c <gc_execute_line+0x106c>
        if ((gc_state.modal.motion == MOTION_MODE_LINEAR) || (gc_state.modal.motion == MOTION_MODE_CW_ARC) 
    1f0c:	80 91 56 0c 	lds	r24, 0x0C56	; 0x800c56 <gc_state>
    1f10:	81 50       	subi	r24, 0x01	; 1
    1f12:	83 30       	cpi	r24, 0x03	; 3
    1f14:	30 f4       	brcc	.+12     	; 0x1f22 <gc_execute_line+0x1062>
            || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
          if (bit_istrue(gc_parser_flags,GC_PARSER_LASER_DISABLE)) { 
    1f16:	4c a1       	ldd	r20, Y+36	; 0x24
    1f18:	46 ff       	sbrs	r20, 6
    1f1a:	08 c0       	rjmp	.+16     	; 0x1f2c <gc_execute_line+0x106c>
            gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC; // Change from G1/2/3 motion mode.
    1f1c:	40 62       	ori	r20, 0x20	; 32
    1f1e:	4c a3       	std	Y+36, r20	; 0x24
    1f20:	05 c0       	rjmp	.+10     	; 0x1f2c <gc_execute_line+0x106c>
          }
        } else {
          // When changing to a G1 motion mode without axis words from a non-G1/2/3 motion mode.
          if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_DISABLE)) { 
    1f22:	8c a1       	ldd	r24, Y+36	; 0x24
    1f24:	86 fd       	sbrc	r24, 6
    1f26:	02 c0       	rjmp	.+4      	; 0x1f2c <gc_execute_line+0x106c>
            gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC;
    1f28:	80 62       	ori	r24, 0x20	; 32
    1f2a:	8c a3       	std	Y+36, r24	; 0x24
    }
  }

  // [0. Non-specific/common error-checks and miscellaneous setup]:
  // NOTE: If no line number is present, the value is zero.
  gc_state.line_number = gc_block.values.n;
    1f2c:	a6 e9       	ldi	r26, 0x96	; 150
    1f2e:	bc e0       	ldi	r27, 0x0C	; 12
    1f30:	5d 96       	adiw	r26, 0x1d	; 29
    1f32:	4d 91       	ld	r20, X+
    1f34:	5d 91       	ld	r21, X+
    1f36:	6d 91       	ld	r22, X+
    1f38:	7c 91       	ld	r23, X
    1f3a:	90 97       	sbiw	r26, 0x20	; 32
    1f3c:	e6 e5       	ldi	r30, 0x56	; 86
    1f3e:	fc e0       	ldi	r31, 0x0C	; 12
    1f40:	44 8b       	std	Z+20, r20	; 0x14
    1f42:	55 8b       	std	Z+21, r21	; 0x15
    1f44:	66 8b       	std	Z+22, r22	; 0x16
    1f46:	77 8b       	std	Z+23, r23	; 0x17
  pl_data->line_number = gc_state.line_number; // Record data for planner use.
    1f48:	4a 8f       	std	Y+26, r20	; 0x1a
    1f4a:	5b 8f       	std	Y+27, r21	; 0x1b
    1f4c:	6c 8f       	std	Y+28, r22	; 0x1c
    1f4e:	7d 8f       	std	Y+29, r23	; 0x1d

  // [1. Comments feedback ]:  NOT SUPPORTED

  // [2. Set feed rate mode ]:
  gc_state.modal.feed_rate = gc_block.modal.feed_rate;
    1f50:	12 96       	adiw	r26, 0x02	; 2
    1f52:	8c 91       	ld	r24, X
    1f54:	81 83       	std	Z+1, r24	; 0x01
  if (gc_state.modal.feed_rate) { pl_data->condition |= PL_COND_FLAG_INVERSE_TIME; } // Set condition flag for planner use.
    1f56:	88 23       	and	r24, r24
    1f58:	11 f0       	breq	.+4      	; 0x1f5e <gc_execute_line+0x109e>
    1f5a:	88 e0       	ldi	r24, 0x08	; 8
    1f5c:	8e 8f       	std	Y+30, r24	; 0x1e

  // [3. Set feed rate ]:
  gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
    1f5e:	a6 e9       	ldi	r26, 0x96	; 150
    1f60:	bc e0       	ldi	r27, 0x0C	; 12
    1f62:	1c 96       	adiw	r26, 0x0c	; 12
    1f64:	4d 91       	ld	r20, X+
    1f66:	5d 91       	ld	r21, X+
    1f68:	6d 91       	ld	r22, X+
    1f6a:	7c 91       	ld	r23, X
    1f6c:	1f 97       	sbiw	r26, 0x0f	; 15
    1f6e:	e6 e5       	ldi	r30, 0x56	; 86
    1f70:	fc e0       	ldi	r31, 0x0C	; 12
    1f72:	47 87       	std	Z+15, r20	; 0x0f
    1f74:	50 8b       	std	Z+16, r21	; 0x10
    1f76:	61 8b       	std	Z+17, r22	; 0x11
    1f78:	72 8b       	std	Z+18, r23	; 0x12
  pl_data->feed_rate = gc_state.feed_rate; // Record data for planner use.
    1f7a:	4a 8b       	std	Y+18, r20	; 0x12
    1f7c:	5b 8b       	std	Y+19, r21	; 0x13
    1f7e:	6c 8b       	std	Y+20, r22	; 0x14
    1f80:	7d 8b       	std	Y+21, r23	; 0x15

  // [4. Set spindle speed ]:
  if ((gc_state.spindle_speed != gc_block.values.s) || bit_istrue(gc_parser_flags,GC_PARSER_LASER_FORCE_SYNC)) {
    1f82:	99 96       	adiw	r26, 0x29	; 41
    1f84:	8d 90       	ld	r8, X+
    1f86:	9d 90       	ld	r9, X+
    1f88:	ad 90       	ld	r10, X+
    1f8a:	bc 90       	ld	r11, X
    1f8c:	9c 97       	sbiw	r26, 0x2c	; 44
    1f8e:	a5 01       	movw	r20, r10
    1f90:	94 01       	movw	r18, r8
    1f92:	63 85       	ldd	r22, Z+11	; 0x0b
    1f94:	74 85       	ldd	r23, Z+12	; 0x0c
    1f96:	85 85       	ldd	r24, Z+13	; 0x0d
    1f98:	96 85       	ldd	r25, Z+14	; 0x0e
    1f9a:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    1f9e:	81 11       	cpse	r24, r1
    1fa0:	03 c0       	rjmp	.+6      	; 0x1fa8 <gc_execute_line+0x10e8>
    1fa2:	9c a1       	ldd	r25, Y+36	; 0x24
    1fa4:	95 ff       	sbrs	r25, 5
    1fa6:	21 c0       	rjmp	.+66     	; 0x1fea <gc_execute_line+0x112a>
    if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
    1fa8:	80 91 5f 0c 	lds	r24, 0x0C5F	; 0x800c5f <gc_state+0x9>
    1fac:	88 23       	and	r24, r24
    1fae:	69 f0       	breq	.+26     	; 0x1fca <gc_execute_line+0x110a>
      if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_ISMOTION)) {
    1fb0:	ac a1       	ldd	r26, Y+36	; 0x24
    1fb2:	aa 23       	and	r26, r26
    1fb4:	54 f0       	brlt	.+20     	; 0x1fca <gc_execute_line+0x110a>
        if (bit_istrue(gc_parser_flags,GC_PARSER_LASER_DISABLE)) {
    1fb6:	a6 ff       	sbrs	r26, 6
    1fb8:	05 c0       	rjmp	.+10     	; 0x1fc4 <gc_execute_line+0x1104>
           spindle_sync(gc_state.modal.spindle, 0.0);
    1fba:	40 e0       	ldi	r20, 0x00	; 0
    1fbc:	50 e0       	ldi	r21, 0x00	; 0
    1fbe:	ba 01       	movw	r22, r20
    1fc0:	ba d3       	rcall	.+1908   	; 0x2736 <spindle_sync>
    1fc2:	03 c0       	rjmp	.+6      	; 0x1fca <gc_execute_line+0x110a>
        } else { spindle_sync(gc_state.modal.spindle, gc_block.values.s); }
    1fc4:	b5 01       	movw	r22, r10
    1fc6:	a4 01       	movw	r20, r8
    1fc8:	b6 d3       	rcall	.+1900   	; 0x2736 <spindle_sync>
      }
    }
    gc_state.spindle_speed = gc_block.values.s; // Update spindle speed state.
    1fca:	80 91 bf 0c 	lds	r24, 0x0CBF	; 0x800cbf <gc_block+0x29>
    1fce:	90 91 c0 0c 	lds	r25, 0x0CC0	; 0x800cc0 <gc_block+0x2a>
    1fd2:	a0 91 c1 0c 	lds	r26, 0x0CC1	; 0x800cc1 <gc_block+0x2b>
    1fd6:	b0 91 c2 0c 	lds	r27, 0x0CC2	; 0x800cc2 <gc_block+0x2c>
    1fda:	80 93 61 0c 	sts	0x0C61, r24	; 0x800c61 <gc_state+0xb>
    1fde:	90 93 62 0c 	sts	0x0C62, r25	; 0x800c62 <gc_state+0xc>
    1fe2:	a0 93 63 0c 	sts	0x0C63, r26	; 0x800c63 <gc_state+0xd>
    1fe6:	b0 93 64 0c 	sts	0x0C64, r27	; 0x800c64 <gc_state+0xe>
  }
  // NOTE: Pass zero spindle speed for all restricted laser motions.
  if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_DISABLE)) {
    1fea:	bc a1       	ldd	r27, Y+36	; 0x24
    1fec:	b6 fd       	sbrc	r27, 6
    1fee:	0c c0       	rjmp	.+24     	; 0x2008 <gc_execute_line+0x1148>
    pl_data->spindle_speed = gc_state.spindle_speed; // Record data for planner use. 
    1ff0:	80 91 61 0c 	lds	r24, 0x0C61	; 0x800c61 <gc_state+0xb>
    1ff4:	90 91 62 0c 	lds	r25, 0x0C62	; 0x800c62 <gc_state+0xc>
    1ff8:	a0 91 63 0c 	lds	r26, 0x0C63	; 0x800c63 <gc_state+0xd>
    1ffc:	b0 91 64 0c 	lds	r27, 0x0C64	; 0x800c64 <gc_state+0xe>
    2000:	8e 8b       	std	Y+22, r24	; 0x16
    2002:	9f 8b       	std	Y+23, r25	; 0x17
    2004:	a8 8f       	std	Y+24, r26	; 0x18
    2006:	b9 8f       	std	Y+25, r27	; 0x19
  } // else { pl_data->spindle_speed = 0.0; } // Initialized as zero already.
  
  // [5. Select tool ]: NOT SUPPORTED. Only tracks tool value.
  gc_state.tool = gc_block.values.t;
    2008:	e6 e5       	ldi	r30, 0x56	; 86
    200a:	fc e0       	ldi	r31, 0x0C	; 12
    200c:	a6 e9       	ldi	r26, 0x96	; 150
    200e:	bc e0       	ldi	r27, 0x0C	; 12
    2010:	9d 96       	adiw	r26, 0x2d	; 45
    2012:	8c 91       	ld	r24, X
    2014:	9d 97       	sbiw	r26, 0x2d	; 45
    2016:	83 8b       	std	Z+19, r24	; 0x13

  // [6. Change tool ]: NOT SUPPORTED

  // [7. Spindle control ]:
  if (gc_state.modal.spindle != gc_block.modal.spindle) {
    2018:	1a 96       	adiw	r26, 0x0a	; 10
    201a:	8c 91       	ld	r24, X
    201c:	91 85       	ldd	r25, Z+9	; 0x09
    201e:	98 17       	cp	r25, r24
    2020:	49 f0       	breq	.+18     	; 0x2034 <gc_execute_line+0x1174>
    // Update spindle control and apply spindle speed when enabling it in this block.
    // NOTE: All spindle state changes are synced, even in laser mode. Also, pl_data,
    // rather than gc_state, is used to manage laser state for non-laser motions.
    spindle_sync(gc_block.modal.spindle, pl_data->spindle_speed);
    2022:	4e 89       	ldd	r20, Y+22	; 0x16
    2024:	5f 89       	ldd	r21, Y+23	; 0x17
    2026:	68 8d       	ldd	r22, Y+24	; 0x18
    2028:	79 8d       	ldd	r23, Y+25	; 0x19
    202a:	85 d3       	rcall	.+1802   	; 0x2736 <spindle_sync>
    gc_state.modal.spindle = gc_block.modal.spindle;
    202c:	80 91 a0 0c 	lds	r24, 0x0CA0	; 0x800ca0 <gc_block+0xa>
    2030:	80 93 5f 0c 	sts	0x0C5F, r24	; 0x800c5f <gc_state+0x9>
  }
  pl_data->condition |= gc_state.modal.spindle; // Set condition flag for planner use.
    2034:	e6 e5       	ldi	r30, 0x56	; 86
    2036:	fc e0       	ldi	r31, 0x0C	; 12
    2038:	9e 8d       	ldd	r25, Y+30	; 0x1e
    203a:	81 85       	ldd	r24, Z+9	; 0x09
    203c:	89 2b       	or	r24, r25
    203e:	8e 8f       	std	Y+30, r24	; 0x1e

  // [8. Coolant control ]:
  if (gc_state.modal.coolant != gc_block.modal.coolant) {
    2040:	80 91 9f 0c 	lds	r24, 0x0C9F	; 0x800c9f <gc_block+0x9>
    2044:	90 85       	ldd	r25, Z+8	; 0x08
    2046:	98 17       	cp	r25, r24
    // NOTE: Coolant M-codes are modal. Only one command per line is allowed. But, multiple states
    // can exist at the same time, while coolant disable clears all states.
    coolant_sync(gc_block.modal.coolant);
    2048:	29 f0       	breq	.+10     	; 0x2054 <gc_execute_line+0x1194>
    204a:	cc d3       	rcall	.+1944   	; 0x27e4 <coolant_sync>
    gc_state.modal.coolant = gc_block.modal.coolant;
    204c:	80 91 9f 0c 	lds	r24, 0x0C9F	; 0x800c9f <gc_block+0x9>
    2050:	80 93 5e 0c 	sts	0x0C5E, r24	; 0x800c5e <gc_state+0x8>
  }
  pl_data->condition |= gc_state.modal.coolant; // Set condition flag for planner use.
    2054:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2056:	80 91 5e 0c 	lds	r24, 0x0C5E	; 0x800c5e <gc_state+0x8>
    205a:	89 2b       	or	r24, r25
    205c:	8e 8f       	std	Y+30, r24	; 0x1e
      mc_override_ctrl_update(gc_state.modal.override);
    }
  #endif

  // [10. Dwell ]:
  if (gc_block.non_modal_command == NON_MODAL_DWELL) { mc_dwell(gc_block.values.p); }
    205e:	80 91 96 0c 	lds	r24, 0x0C96	; 0x800c96 <gc_block>
    2062:	84 30       	cpi	r24, 0x04	; 4
    2064:	51 f4       	brne	.+20     	; 0x207a <gc_execute_line+0x11ba>
    2066:	60 91 b7 0c 	lds	r22, 0x0CB7	; 0x800cb7 <gc_block+0x21>
    206a:	70 91 b8 0c 	lds	r23, 0x0CB8	; 0x800cb8 <gc_block+0x22>
    206e:	80 91 b9 0c 	lds	r24, 0x0CB9	; 0x800cb9 <gc_block+0x23>
    2072:	90 91 ba 0c 	lds	r25, 0x0CBA	; 0x800cba <gc_block+0x24>
    2076:	0e 94 7b 06 	call	0xcf6	; 0xcf6 <mc_dwell>

  // [11. Set active plane ]:
  gc_state.modal.plane_select = gc_block.modal.plane_select;
    207a:	e6 e5       	ldi	r30, 0x56	; 86
    207c:	fc e0       	ldi	r31, 0x0C	; 12
    207e:	a6 e9       	ldi	r26, 0x96	; 150
    2080:	bc e0       	ldi	r27, 0x0C	; 12
    2082:	15 96       	adiw	r26, 0x05	; 5
    2084:	8c 91       	ld	r24, X
    2086:	15 97       	sbiw	r26, 0x05	; 5
    2088:	84 83       	std	Z+4, r24	; 0x04

  // [12. Set length units ]:
  gc_state.modal.units = gc_block.modal.units;
    208a:	13 96       	adiw	r26, 0x03	; 3
    208c:	8c 91       	ld	r24, X
    208e:	82 83       	std	Z+2, r24	; 0x02

  // [14. Cutter length compensation ]: G43.1 and G49 supported. G43 NOT SUPPORTED.
  // NOTE: If G43 were supported, its operation wouldn't be any different from G43.1 in terms
  // of execution. The error-checking step would simply load the offset value into the correct
  // axis of the block XYZ value array.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates a change.
    2090:	ea a1       	ldd	r30, Y+34	; 0x22
    2092:	e3 30       	cpi	r30, 0x03	; 3
    2094:	71 f5       	brne	.+92     	; 0x20f2 <gc_execute_line+0x1232>
    gc_state.modal.tool_length = gc_block.modal.tool_length;
    2096:	80 91 9c 0c 	lds	r24, 0x0C9C	; 0x800c9c <gc_block+0x6>
    209a:	80 93 5b 0c 	sts	0x0C5B, r24	; 0x800c5b <gc_state+0x5>
    if (gc_state.modal.tool_length == TOOL_LENGTH_OFFSET_CANCEL) { // G49
    209e:	81 11       	cpse	r24, r1
    20a0:	08 c0       	rjmp	.+16     	; 0x20b2 <gc_execute_line+0x11f2>
      gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] = 0.0;
    20a2:	10 92 cc 0c 	sts	0x0CCC, r1	; 0x800ccc <gc_block+0x36>
    20a6:	10 92 cd 0c 	sts	0x0CCD, r1	; 0x800ccd <gc_block+0x37>
    20aa:	10 92 ce 0c 	sts	0x0CCE, r1	; 0x800cce <gc_block+0x38>
    20ae:	10 92 cf 0c 	sts	0x0CCF, r1	; 0x800ccf <gc_block+0x39>
    } // else G43.1
    if ( gc_state.tool_length_offset != gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] ) {
    20b2:	80 90 cc 0c 	lds	r8, 0x0CCC	; 0x800ccc <gc_block+0x36>
    20b6:	90 90 cd 0c 	lds	r9, 0x0CCD	; 0x800ccd <gc_block+0x37>
    20ba:	a0 90 ce 0c 	lds	r10, 0x0CCE	; 0x800cce <gc_block+0x38>
    20be:	b0 90 cf 0c 	lds	r11, 0x0CCF	; 0x800ccf <gc_block+0x39>
    20c2:	a5 01       	movw	r20, r10
    20c4:	94 01       	movw	r18, r8
    20c6:	60 91 92 0c 	lds	r22, 0x0C92	; 0x800c92 <gc_state+0x3c>
    20ca:	70 91 93 0c 	lds	r23, 0x0C93	; 0x800c93 <gc_state+0x3d>
    20ce:	80 91 94 0c 	lds	r24, 0x0C94	; 0x800c94 <gc_state+0x3e>
    20d2:	90 91 95 0c 	lds	r25, 0x0C95	; 0x800c95 <gc_state+0x3f>
    20d6:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    20da:	88 23       	and	r24, r24
    20dc:	51 f0       	breq	.+20     	; 0x20f2 <gc_execute_line+0x1232>
      gc_state.tool_length_offset = gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS];
    20de:	80 92 92 0c 	sts	0x0C92, r8	; 0x800c92 <gc_state+0x3c>
    20e2:	90 92 93 0c 	sts	0x0C93, r9	; 0x800c93 <gc_state+0x3d>
    20e6:	a0 92 94 0c 	sts	0x0C94, r10	; 0x800c94 <gc_state+0x3e>
    20ea:	b0 92 95 0c 	sts	0x0C95, r11	; 0x800c95 <gc_state+0x3f>
      system_flag_wco_change();
    20ee:	0e 94 fb 3a 	call	0x75f6	; 0x75f6 <system_flag_wco_change>
    }
  }

  // [15. Coordinate system selection ]:
  if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    20f2:	80 91 9d 0c 	lds	r24, 0x0C9D	; 0x800c9d <gc_block+0x7>
    20f6:	90 91 5c 0c 	lds	r25, 0x0C5C	; 0x800c5c <gc_state+0x6>
    20fa:	98 17       	cp	r25, r24
    20fc:	69 f0       	breq	.+26     	; 0x2118 <gc_execute_line+0x1258>
    gc_state.modal.coord_select = gc_block.modal.coord_select;
    20fe:	80 93 5c 0c 	sts	0x0C5C, r24	; 0x800c5c <gc_state+0x6>
    memcpy(gc_state.coord_system,block_coord_system,N_AXIS*sizeof(float));
    2102:	8c e0       	ldi	r24, 0x0C	; 12
    2104:	fe 01       	movw	r30, r28
    2106:	36 96       	adiw	r30, 0x06	; 6
    2108:	aa e7       	ldi	r26, 0x7A	; 122
    210a:	bc e0       	ldi	r27, 0x0C	; 12
    210c:	01 90       	ld	r0, Z+
    210e:	0d 92       	st	X+, r0
    2110:	8a 95       	dec	r24
    2112:	e1 f7       	brne	.-8      	; 0x210c <gc_execute_line+0x124c>
    system_flag_wco_change();
    2114:	0e 94 fb 3a 	call	0x75f6	; 0x75f6 <system_flag_wco_change>

  // [16. Set path control mode ]: G61.1/G64 NOT SUPPORTED
  // gc_state.modal.control = gc_block.modal.control; // NOTE: Always default.

  // [17. Set distance mode ]:
  gc_state.modal.distance = gc_block.modal.distance;
    2118:	e6 e9       	ldi	r30, 0x96	; 150
    211a:	fc e0       	ldi	r31, 0x0C	; 12
    211c:	84 81       	ldd	r24, Z+4	; 0x04
    211e:	80 93 59 0c 	sts	0x0C59, r24	; 0x800c59 <gc_state+0x3>

  // [18. Set retract mode ]: NOT SUPPORTED

  // [19. Go to predefined position, Set G10, or Set axis offsets ]:
  switch(gc_block.non_modal_command) {
    2122:	80 81       	ld	r24, Z
    2124:	86 32       	cpi	r24, 0x26	; 38
    2126:	09 f4       	brne	.+2      	; 0x212a <gc_execute_line+0x126a>
    2128:	46 c0       	rjmp	.+140    	; 0x21b6 <gc_execute_line+0x12f6>
    212a:	38 f4       	brcc	.+14     	; 0x213a <gc_execute_line+0x127a>
    212c:	8c 31       	cpi	r24, 0x1C	; 28
    212e:	29 f1       	breq	.+74     	; 0x217a <gc_execute_line+0x12ba>
    2130:	8e 31       	cpi	r24, 0x1E	; 30
    2132:	19 f1       	breq	.+70     	; 0x217a <gc_execute_line+0x12ba>
    2134:	8a 30       	cpi	r24, 0x0A	; 10
    2136:	59 f0       	breq	.+22     	; 0x214e <gc_execute_line+0x128e>
    2138:	5f c0       	rjmp	.+190    	; 0x21f8 <gc_execute_line+0x1338>
    213a:	8c 35       	cpi	r24, 0x5C	; 92
    213c:	09 f4       	brne	.+2      	; 0x2140 <gc_execute_line+0x1280>
    213e:	47 c0       	rjmp	.+142    	; 0x21ce <gc_execute_line+0x130e>
    2140:	86 36       	cpi	r24, 0x66	; 102
    2142:	09 f4       	brne	.+2      	; 0x2146 <gc_execute_line+0x1286>
    2144:	50 c0       	rjmp	.+160    	; 0x21e6 <gc_execute_line+0x1326>
    2146:	88 32       	cpi	r24, 0x28	; 40
    2148:	09 f0       	breq	.+2      	; 0x214c <gc_execute_line+0x128c>
    214a:	56 c0       	rjmp	.+172    	; 0x21f8 <gc_execute_line+0x1338>
    214c:	3a c0       	rjmp	.+116    	; 0x21c2 <gc_execute_line+0x1302>
    case NON_MODAL_SET_COORDINATE_DATA:
      settings_write_coord_data(coord_select,gc_block.values.ijk);
    214e:	66 ea       	ldi	r22, 0xA6	; 166
    2150:	7c e0       	ldi	r23, 0x0C	; 12
    2152:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2154:	0e 94 77 25 	call	0x4aee	; 0x4aee <settings_write_coord_data>
      // Update system coordinate system if currently active.
      if (gc_state.modal.coord_select == coord_select) {
    2158:	80 91 5c 0c 	lds	r24, 0x0C5C	; 0x800c5c <gc_state+0x6>
    215c:	ff 8d       	ldd	r31, Y+31	; 0x1f
    215e:	8f 13       	cpse	r24, r31
    2160:	4b c0       	rjmp	.+150    	; 0x21f8 <gc_execute_line+0x1338>
        memcpy(gc_state.coord_system,gc_block.values.ijk,N_AXIS*sizeof(float));
    2162:	8c e0       	ldi	r24, 0x0C	; 12
    2164:	e6 ea       	ldi	r30, 0xA6	; 166
    2166:	fc e0       	ldi	r31, 0x0C	; 12
    2168:	aa e7       	ldi	r26, 0x7A	; 122
    216a:	bc e0       	ldi	r27, 0x0C	; 12
    216c:	01 90       	ld	r0, Z+
    216e:	0d 92       	st	X+, r0
    2170:	8a 95       	dec	r24
    2172:	e1 f7       	brne	.-8      	; 0x216c <gc_execute_line+0x12ac>
        system_flag_wco_change();
    2174:	0e 94 fb 3a 	call	0x75f6	; 0x75f6 <system_flag_wco_change>
    2178:	3f c0       	rjmp	.+126    	; 0x21f8 <gc_execute_line+0x1338>
      }
      break;
    case NON_MODAL_GO_HOME_0: case NON_MODAL_GO_HOME_1:
      // Move to intermediate position before going home. Obeys current coordinate system and offsets
      // and absolute and incremental modes.
      pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
    217a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    217c:	81 60       	ori	r24, 0x01	; 1
    217e:	8e 8f       	std	Y+30, r24	; 0x1e
      if (axis_command) { mc_line(gc_block.values.xyz, pl_data); }
    2180:	2a a1       	ldd	r18, Y+34	; 0x22
    2182:	22 23       	and	r18, r18
    2184:	39 f0       	breq	.+14     	; 0x2194 <gc_execute_line+0x12d4>
    2186:	be 01       	movw	r22, r28
    2188:	6e 5e       	subi	r22, 0xEE	; 238
    218a:	7f 4f       	sbci	r23, 0xFF	; 255
    218c:	84 ec       	ldi	r24, 0xC4	; 196
    218e:	9c e0       	ldi	r25, 0x0C	; 12
    2190:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <mc_line>
      mc_line(gc_block.values.ijk, pl_data);
    2194:	be 01       	movw	r22, r28
    2196:	6e 5e       	subi	r22, 0xEE	; 238
    2198:	7f 4f       	sbci	r23, 0xFF	; 255
    219a:	86 ea       	ldi	r24, 0xA6	; 166
    219c:	9c e0       	ldi	r25, 0x0C	; 12
    219e:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <mc_line>
      memcpy(gc_state.position, gc_block.values.ijk, N_AXIS*sizeof(float));
    21a2:	8c e0       	ldi	r24, 0x0C	; 12
    21a4:	e6 ea       	ldi	r30, 0xA6	; 166
    21a6:	fc e0       	ldi	r31, 0x0C	; 12
    21a8:	ae e6       	ldi	r26, 0x6E	; 110
    21aa:	bc e0       	ldi	r27, 0x0C	; 12
    21ac:	01 90       	ld	r0, Z+
    21ae:	0d 92       	st	X+, r0
    21b0:	8a 95       	dec	r24
    21b2:	e1 f7       	brne	.-8      	; 0x21ac <gc_execute_line+0x12ec>
      break;
    21b4:	21 c0       	rjmp	.+66     	; 0x21f8 <gc_execute_line+0x1338>
    case NON_MODAL_SET_HOME_0:
      settings_write_coord_data(SETTING_INDEX_G28,gc_state.position);
    21b6:	6e e6       	ldi	r22, 0x6E	; 110
    21b8:	7c e0       	ldi	r23, 0x0C	; 12
    21ba:	86 e0       	ldi	r24, 0x06	; 6
    21bc:	0e 94 77 25 	call	0x4aee	; 0x4aee <settings_write_coord_data>
      break;
    21c0:	1b c0       	rjmp	.+54     	; 0x21f8 <gc_execute_line+0x1338>
    case NON_MODAL_SET_HOME_1:
      settings_write_coord_data(SETTING_INDEX_G30,gc_state.position);
    21c2:	6e e6       	ldi	r22, 0x6E	; 110
    21c4:	7c e0       	ldi	r23, 0x0C	; 12
    21c6:	87 e0       	ldi	r24, 0x07	; 7
    21c8:	0e 94 77 25 	call	0x4aee	; 0x4aee <settings_write_coord_data>
      break;
    21cc:	15 c0       	rjmp	.+42     	; 0x21f8 <gc_execute_line+0x1338>
    case NON_MODAL_SET_COORDINATE_OFFSET:
      memcpy(gc_state.coord_offset,gc_block.values.xyz,sizeof(gc_block.values.xyz));
    21ce:	8c e0       	ldi	r24, 0x0C	; 12
    21d0:	e4 ec       	ldi	r30, 0xC4	; 196
    21d2:	fc e0       	ldi	r31, 0x0C	; 12
    21d4:	a6 e8       	ldi	r26, 0x86	; 134
    21d6:	bc e0       	ldi	r27, 0x0C	; 12
    21d8:	01 90       	ld	r0, Z+
    21da:	0d 92       	st	X+, r0
    21dc:	8a 95       	dec	r24
    21de:	e1 f7       	brne	.-8      	; 0x21d8 <gc_execute_line+0x1318>
      system_flag_wco_change();
    21e0:	0e 94 fb 3a 	call	0x75f6	; 0x75f6 <system_flag_wco_change>
      break;
    21e4:	09 c0       	rjmp	.+18     	; 0x21f8 <gc_execute_line+0x1338>
    case NON_MODAL_RESET_COORDINATE_OFFSET:
      clear_vector(gc_state.coord_offset); // Disable G92 offsets by zeroing offset vector.
    21e6:	8c e0       	ldi	r24, 0x0C	; 12
    21e8:	e6 e8       	ldi	r30, 0x86	; 134
    21ea:	fc e0       	ldi	r31, 0x0C	; 12
    21ec:	df 01       	movw	r26, r30
    21ee:	1d 92       	st	X+, r1
    21f0:	8a 95       	dec	r24
    21f2:	e9 f7       	brne	.-6      	; 0x21ee <gc_execute_line+0x132e>
      system_flag_wco_change();
    21f4:	0e 94 fb 3a 	call	0x75f6	; 0x75f6 <system_flag_wco_change>


  // [20. Motion modes ]:
  // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes.
  // Enter motion modes only if there are axis words or a motion mode command word in the block.
  gc_state.modal.motion = gc_block.modal.motion;
    21f8:	80 91 97 0c 	lds	r24, 0x0C97	; 0x800c97 <gc_block+0x1>
    21fc:	80 93 56 0c 	sts	0x0C56, r24	; 0x800c56 <gc_state>
  if (gc_state.modal.motion != MOTION_MODE_NONE) {
    2200:	80 35       	cpi	r24, 0x50	; 80
    2202:	09 f4       	brne	.+2      	; 0x2206 <__stack+0x7>
    2204:	56 c0       	rjmp	.+172    	; 0x22b2 <__stack+0xb3>
    if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    2206:	ba a1       	ldd	r27, Y+34	; 0x22
    2208:	b2 30       	cpi	r27, 0x02	; 2
    220a:	09 f0       	breq	.+2      	; 0x220e <__stack+0xf>
    220c:	52 c0       	rjmp	.+164    	; 0x22b2 <__stack+0xb3>
      uint8_t gc_update_pos = GC_UPDATE_POS_TARGET;
      if (gc_state.modal.motion == MOTION_MODE_LINEAR) {
    220e:	81 30       	cpi	r24, 0x01	; 1
    2210:	41 f4       	brne	.+16     	; 0x2222 <__stack+0x23>
        mc_line(gc_block.values.xyz, pl_data);
    2212:	be 01       	movw	r22, r28
    2214:	6e 5e       	subi	r22, 0xEE	; 238
    2216:	7f 4f       	sbci	r23, 0xFF	; 255
    2218:	84 ec       	ldi	r24, 0xC4	; 196
    221a:	9c e0       	ldi	r25, 0x0C	; 12
    221c:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <mc_line>
    2220:	3a c0       	rjmp	.+116    	; 0x2296 <__stack+0x97>
      } else if (gc_state.modal.motion == MOTION_MODE_SEEK) {
    2222:	81 11       	cpse	r24, r1
    2224:	0b c0       	rjmp	.+22     	; 0x223c <__stack+0x3d>
        pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
    2226:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2228:	81 60       	ori	r24, 0x01	; 1
    222a:	8e 8f       	std	Y+30, r24	; 0x1e
        mc_line(gc_block.values.xyz, pl_data);
    222c:	be 01       	movw	r22, r28
    222e:	6e 5e       	subi	r22, 0xEE	; 238
    2230:	7f 4f       	sbci	r23, 0xFF	; 255
    2232:	84 ec       	ldi	r24, 0xC4	; 196
    2234:	9c e0       	ldi	r25, 0x0C	; 12
    2236:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <mc_line>
    223a:	2d c0       	rjmp	.+90     	; 0x2296 <__stack+0x97>
      } else if ((gc_state.modal.motion == MOTION_MODE_CW_ARC) || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
    223c:	82 50       	subi	r24, 0x02	; 2
    223e:	82 30       	cpi	r24, 0x02	; 2
    2240:	e8 f4       	brcc	.+58     	; 0x227c <__stack+0x7d>
        mc_arc(gc_block.values.xyz, pl_data, gc_state.position, gc_block.values.ijk, gc_block.values.r,
    2242:	e0 90 bb 0c 	lds	r14, 0x0CBB	; 0x800cbb <gc_block+0x25>
    2246:	f0 90 bc 0c 	lds	r15, 0x0CBC	; 0x800cbc <gc_block+0x26>
    224a:	00 91 bd 0c 	lds	r16, 0x0CBD	; 0x800cbd <gc_block+0x27>
    224e:	10 91 be 0c 	lds	r17, 0x0CBE	; 0x800cbe <gc_block+0x28>
    2252:	ec a1       	ldd	r30, Y+36	; 0x24
    2254:	e2 fb       	bst	r30, 2
    2256:	88 27       	eor	r24, r24
    2258:	80 f9       	bld	r24, 0
    225a:	8f 93       	push	r24
    225c:	8f a4       	ldd	r8, Y+47	; 0x2f
    225e:	ae a0       	ldd	r10, Y+38	; 0x26
    2260:	cd a0       	ldd	r12, Y+37	; 0x25
    2262:	26 ea       	ldi	r18, 0xA6	; 166
    2264:	3c e0       	ldi	r19, 0x0C	; 12
    2266:	4e e6       	ldi	r20, 0x6E	; 110
    2268:	5c e0       	ldi	r21, 0x0C	; 12
    226a:	be 01       	movw	r22, r28
    226c:	6e 5e       	subi	r22, 0xEE	; 238
    226e:	7f 4f       	sbci	r23, 0xFF	; 255
    2270:	84 ec       	ldi	r24, 0xC4	; 196
    2272:	9c e0       	ldi	r25, 0x0C	; 12
    2274:	0e 94 9c 03 	call	0x738	; 0x738 <mc_arc>
    2278:	0f 90       	pop	r0
    227a:	0d c0       	rjmp	.+26     	; 0x2296 <__stack+0x97>
            axis_0, axis_1, axis_linear, bit_istrue(gc_parser_flags,GC_PARSER_ARC_IS_CLOCKWISE));
      } else {
        // NOTE: gc_block.values.xyz is returned from mc_probe_cycle with the updated position value. So
        // upon a successful probing cycle, the machine position and the returned value should be the same.
        #ifndef ALLOW_FEED_OVERRIDE_DURING_PROBE_CYCLES
          pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
    227c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    227e:	84 60       	ori	r24, 0x04	; 4
    2280:	8e 8f       	std	Y+30, r24	; 0x1e
        #endif
        gc_update_pos = mc_probe_cycle(gc_block.values.xyz, pl_data, gc_parser_flags);
    2282:	4c a1       	ldd	r20, Y+36	; 0x24
    2284:	be 01       	movw	r22, r28
    2286:	6e 5e       	subi	r22, 0xEE	; 238
    2288:	7f 4f       	sbci	r23, 0xFF	; 255
    228a:	84 ec       	ldi	r24, 0xC4	; 196
    228c:	9c e0       	ldi	r25, 0x0C	; 12
    228e:	0e 94 ae 06 	call	0xd5c	; 0xd5c <mc_probe_cycle>
      }  
     
      // As far as the parser is concerned, the position is now == target. In reality the
      // motion control system might still be processing the action and the real tool position
      // in any intermediate location.
      if (gc_update_pos == GC_UPDATE_POS_TARGET) {
    2292:	81 11       	cpse	r24, r1
    2294:	0a c0       	rjmp	.+20     	; 0x22aa <__stack+0xab>
        memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); // gc_state.position[] = gc_block.values.xyz[]
    2296:	8c e0       	ldi	r24, 0x0C	; 12
    2298:	e4 ec       	ldi	r30, 0xC4	; 196
    229a:	fc e0       	ldi	r31, 0x0C	; 12
    229c:	ae e6       	ldi	r26, 0x6E	; 110
    229e:	bc e0       	ldi	r27, 0x0C	; 12
    22a0:	01 90       	ld	r0, Z+
    22a2:	0d 92       	st	X+, r0
    22a4:	8a 95       	dec	r24
    22a6:	e1 f7       	brne	.-8      	; 0x22a0 <__stack+0xa1>
    22a8:	04 c0       	rjmp	.+8      	; 0x22b2 <__stack+0xb3>
      } else if (gc_update_pos == GC_UPDATE_POS_SYSTEM) {
    22aa:	81 30       	cpi	r24, 0x01	; 1
    22ac:	11 f4       	brne	.+4      	; 0x22b2 <__stack+0xb3>
        gc_sync_position(); // gc_state.position[] = sys_position
    22ae:	0e 94 59 07 	call	0xeb2	; 0xeb2 <gc_sync_position>
  }

  // [21. Program flow ]:
  // M0,M1,M2,M30: Perform non-running program flow actions. During a program pause, the buffer may
  // refill and can only be resumed by the cycle start run-time command.
  gc_state.modal.program_flow = gc_block.modal.program_flow;
    22b2:	80 91 9e 0c 	lds	r24, 0x0C9E	; 0x800c9e <gc_block+0x8>
    22b6:	80 93 5d 0c 	sts	0x0C5D, r24	; 0x800c5d <gc_state+0x7>
  if (gc_state.modal.program_flow) {
    22ba:	88 23       	and	r24, r24
    22bc:	09 f4       	brne	.+2      	; 0x22c0 <__stack+0xc1>
    protocol_buffer_synchronize(); // Sync and finish all remaining buffered motions before moving on.
    22be:	ef c0       	rjmp	.+478    	; 0x249e <__stack+0x29f>
    22c0:	cb d7       	rcall	.+3990   	; 0x3258 <protocol_buffer_synchronize>
    if (gc_state.modal.program_flow == PROGRAM_FLOW_PAUSED) {
    22c2:	80 91 5d 0c 	lds	r24, 0x0C5D	; 0x800c5d <gc_state+0x7>
    22c6:	83 30       	cpi	r24, 0x03	; 3
    22c8:	49 f4       	brne	.+18     	; 0x22dc <__stack+0xdd>
      if (sys.state != STATE_CHECK_MODE) {
    22ca:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    22ce:	82 30       	cpi	r24, 0x02	; 2
        system_set_exec_state_flag(EXEC_FEED_HOLD); // Use feed hold for program pause.
    22d0:	61 f1       	breq	.+88     	; 0x232a <__stack+0x12b>
    22d2:	88 e0       	ldi	r24, 0x08	; 8
    22d4:	0e 94 99 3b 	call	0x7732	; 0x7732 <system_set_exec_state_flag>
        protocol_execute_realtime(); // Execute suspend.
    22d8:	f7 d5       	rcall	.+3054   	; 0x2ec8 <protocol_execute_realtime>
    22da:	27 c0       	rjmp	.+78     	; 0x232a <__stack+0x12b>
    } else { // == PROGRAM_FLOW_COMPLETED
      // Upon program complete, only a subset of g-codes reset to certain defaults, according to
      // LinuxCNC's program end descriptions and testing. Only modal groups [G-code 1,2,3,5,7,12]
      // and [M-code 7,8,9] reset to [G1,G17,G90,G94,G40,G54,M5,M9,M48]. The remaining modal groups
      // [G-code 4,6,8,10,13,14,15] and [M-code 4,5,6] and the modal words [F,S,T,H] do not reset.
      gc_state.modal.motion = MOTION_MODE_LINEAR;
    22dc:	e6 e5       	ldi	r30, 0x56	; 86
    22de:	fc e0       	ldi	r31, 0x0C	; 12
    22e0:	81 e0       	ldi	r24, 0x01	; 1
    22e2:	80 83       	st	Z, r24
      gc_state.modal.plane_select = PLANE_SELECT_XY;
    22e4:	14 82       	std	Z+4, r1	; 0x04
      gc_state.modal.distance = DISTANCE_MODE_ABSOLUTE;
    22e6:	13 82       	std	Z+3, r1	; 0x03
      gc_state.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
    22e8:	11 82       	std	Z+1, r1	; 0x01
      // gc_state.modal.cutter_comp = CUTTER_COMP_DISABLE; // Not supported.
      gc_state.modal.coord_select = 0; // G54
    22ea:	16 82       	std	Z+6, r1	; 0x06
      gc_state.modal.spindle = SPINDLE_DISABLE;
    22ec:	11 86       	std	Z+9, r1	; 0x09
      gc_state.modal.coolant = COOLANT_DISABLE;
    22ee:	10 86       	std	Z+8, r1	; 0x08
          gc_state.modal.override = OVERRIDE_PARKING_MOTION;
        #endif
      #endif

      #ifdef RESTORE_OVERRIDES_AFTER_PROGRAM_END
        sys.f_override = DEFAULT_FEED_OVERRIDE;
    22f0:	ee e1       	ldi	r30, 0x1E	; 30
    22f2:	fc e0       	ldi	r31, 0x0C	; 12
    22f4:	84 e6       	ldi	r24, 0x64	; 100
    22f6:	87 83       	std	Z+7, r24	; 0x07
        sys.r_override = DEFAULT_RAPID_OVERRIDE;
    22f8:	80 87       	std	Z+8, r24	; 0x08
        sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE;
    22fa:	81 87       	std	Z+9, r24	; 0x09
      #endif

      // Execute coordinate change and spindle/coolant stop.
      if (sys.state != STATE_CHECK_MODE) {
    22fc:	80 81       	ld	r24, Z
    22fe:	82 30       	cpi	r24, 0x02	; 2
    2300:	89 f0       	breq	.+34     	; 0x2324 <__stack+0x125>
        if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    2302:	6a e7       	ldi	r22, 0x7A	; 122
    2304:	7c e0       	ldi	r23, 0x0C	; 12
    2306:	80 e0       	ldi	r24, 0x00	; 0
    2308:	0e 94 1a 26 	call	0x4c34	; 0x4c34 <settings_read_coord_data>
    230c:	88 23       	and	r24, r24
    230e:	09 f4       	brne	.+2      	; 0x2312 <__stack+0x113>
        system_flag_wco_change(); // Set to refresh immediately just in case something altered.
    2310:	7a c0       	rjmp	.+244    	; 0x2406 <__stack+0x207>
        spindle_set_state(SPINDLE_DISABLE,0.0);
    2312:	0e 94 fb 3a 	call	0x75f6	; 0x75f6 <system_flag_wco_change>
    2316:	40 e0       	ldi	r20, 0x00	; 0
    2318:	50 e0       	ldi	r21, 0x00	; 0
    231a:	ba 01       	movw	r22, r20
    231c:	80 e0       	ldi	r24, 0x00	; 0
        coolant_set_state(COOLANT_DISABLE);
    231e:	e1 d1       	rcall	.+962    	; 0x26e2 <spindle_set_state>
    2320:	80 e0       	ldi	r24, 0x00	; 0
    2322:	3f d2       	rcall	.+1150   	; 0x27a2 <coolant_set_state>
      }
      report_feedback_message(MESSAGE_PROGRAM_END);
    2324:	88 e0       	ldi	r24, 0x08	; 8
    2326:	0e 94 9e 35 	call	0x6b3c	; 0x6b3c <report_feedback_message>
    }
    gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; // Reset program flow.
    232a:	10 92 5d 0c 	sts	0x0C5D, r1	; 0x800c5d <gc_state+0x7>
  }

  // TODO: % to denote start of program.

  return(STATUS_OK);
    232e:	8d 2d       	mov	r24, r13
    2330:	b6 c0       	rjmp	.+364    	; 0x249e <__stack+0x29f>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.

    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
    2332:	81 e0       	ldi	r24, 0x01	; 1
    2334:	b4 c0       	rjmp	.+360    	; 0x249e <__stack+0x29f>
    char_counter++;
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
    2336:	82 e0       	ldi	r24, 0x02	; 2
    2338:	b2 c0       	rjmp	.+356    	; 0x249e <__stack+0x29f>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
    233a:	84 e1       	ldi	r24, 0x14	; 20
    233c:	b0 c0       	rjmp	.+352    	; 0x249e <__stack+0x29f>
        switch(int_value) {
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    233e:	88 e1       	ldi	r24, 0x18	; 24
    2340:	ae c0       	rjmp	.+348    	; 0x249e <__stack+0x29f>
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
              if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
    2342:	84 e1       	ldi	r24, 0x14	; 20
    2344:	ac c0       	rjmp	.+344    	; 0x249e <__stack+0x29f>
            }                
            break;
          case 0: case 1: case 2: case 3: case 38:
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    2346:	88 e1       	ldi	r24, 0x18	; 24
    2348:	aa c0       	rjmp	.+340    	; 0x249e <__stack+0x29f>
          case 80:
            word_bit = MODAL_GROUP_G1;
            gc_block.modal.motion = int_value;
            if (int_value == 38){
              if (!((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))) {
                FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
    234a:	84 e1       	ldi	r24, 0x14	; 20
    234c:	a8 c0       	rjmp	.+336    	; 0x249e <__stack+0x29f>
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
    234e:	84 e1       	ldi	r24, 0x14	; 20
    2350:	a6 c0       	rjmp	.+332    	; 0x249e <__stack+0x29f>
    2352:	84 e1       	ldi	r24, 0x14	; 20
    2354:	a4 c0       	rjmp	.+328    	; 0x249e <__stack+0x29f>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
    2356:	88 e1       	ldi	r24, 0x18	; 24
    2358:	a2 c0       	rjmp	.+324    	; 0x249e <__stack+0x29f>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
            } else if (mantissa == 10) { // G43.1
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
    235a:	84 e1       	ldi	r24, 0x14	; 20
    235c:	a0 c0       	rjmp	.+320    	; 0x249e <__stack+0x29f>
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
    235e:	84 e1       	ldi	r24, 0x14	; 20
    2360:	9e c0       	rjmp	.+316    	; 0x249e <__stack+0x29f>
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    2362:	87 e1       	ldi	r24, 0x17	; 23
    2364:	9c c0       	rjmp	.+312    	; 0x249e <__stack+0x29f>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    2366:	85 e1       	ldi	r24, 0x15	; 21
    2368:	9a c0       	rjmp	.+308    	; 0x249e <__stack+0x29f>
        break;

      case 'M':

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    236a:	87 e1       	ldi	r24, 0x17	; 23
    236c:	98 c0       	rjmp	.+304    	; 0x249e <__stack+0x29f>
            case 56:
              word_bit = MODAL_GROUP_M9;
              gc_block.modal.override = OVERRIDE_PARKING_MOTION;
              break;
          #endif
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
    236e:	84 e1       	ldi	r24, 0x14	; 20
    2370:	96 c0       	rjmp	.+300    	; 0x249e <__stack+0x29f>
        }

        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    2372:	85 e1       	ldi	r24, 0x15	; 21
    2374:	94 c0       	rjmp	.+296    	; 0x249e <__stack+0x29f>
						gc_block.values.t = int_value;
						break;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
    2376:	84 e1       	ldi	r24, 0x14	; 20
    2378:	92 c0       	rjmp	.+292    	; 0x249e <__stack+0x29f>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; 
						if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
    237a:	86 e2       	ldi	r24, 0x26	; 38
    237c:	90 c0       	rjmp	.+288    	; 0x249e <__stack+0x29f>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        }

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    237e:	89 e1       	ldi	r24, 0x19	; 25
    2380:	8e c0       	rjmp	.+284    	; 0x249e <__stack+0x29f>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    2382:	84 e0       	ldi	r24, 0x04	; 4
    2384:	8c c0       	rjmp	.+280    	; 0x249e <__stack+0x29f>
  }

  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    2386:	8b e1       	ldi	r24, 0x1B	; 27
    2388:	8a c0       	rjmp	.+276    	; 0x249e <__stack+0x29f>

  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  // NOTE: For jogging, ignore prior feed rate mode. Enforce G94 and check for required F word.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); }
    238a:	86 e1       	ldi	r24, 0x16	; 22
    238c:	88 c0       	rjmp	.+272    	; 0x249e <__stack+0x29f>
  } else {
    if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
      // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
      if (axis_command == AXIS_COMMAND_MOTION_MODE) {
        if ((gc_block.modal.motion != MOTION_MODE_NONE) && (gc_block.modal.motion != MOTION_MODE_SEEK)) {
          if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    238e:	86 e1       	ldi	r24, 0x16	; 22
    2390:	86 c0       	rjmp	.+268    	; 0x249e <__stack+0x29f>
    }
  #endif

  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    2392:	8c e1       	ldi	r24, 0x1C	; 28
    2394:	84 c0       	rjmp	.+264    	; 0x249e <__stack+0x29f>
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    2396:	85 e2       	ldi	r24, 0x25	; 37
    2398:	82 c0       	rjmp	.+260    	; 0x249e <__stack+0x29f>
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  float block_coord_system[N_AXIS];
  memcpy(block_coord_system,gc_state.coord_system,sizeof(gc_state.coord_system));
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    239a:	8d e1       	ldi	r24, 0x1D	; 29
    239c:	80 c0       	rjmp	.+256    	; 0x249e <__stack+0x29f>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
      if (!(settings_read_coord_data(gc_block.modal.coord_select,block_coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    239e:	87 e0       	ldi	r24, 0x07	; 7
    23a0:	7e c0       	rjmp	.+252    	; 0x249e <__stack+0x29f>
  switch (gc_block.non_modal_command) {
    case NON_MODAL_SET_COORDINATE_DATA:
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    23a2:	8a e1       	ldi	r24, 0x1A	; 26
    23a4:	7c c0       	rjmp	.+248    	; 0x249e <__stack+0x29f>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    23a6:	8c e1       	ldi	r24, 0x1C	; 28
    23a8:	7a c0       	rjmp	.+244    	; 0x249e <__stack+0x29f>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    23aa:	8d e1       	ldi	r24, 0x1D	; 29
    23ac:	78 c0       	rjmp	.+240    	; 0x249e <__stack+0x29f>
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
    23ae:	84 e1       	ldi	r24, 0x14	; 20
    23b0:	76 c0       	rjmp	.+236    	; 0x249e <__stack+0x29f>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    23b2:	84 e1       	ldi	r24, 0x14	; 20
    23b4:	74 c0       	rjmp	.+232    	; 0x249e <__stack+0x29f>
      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    23b6:	87 e0       	ldi	r24, 0x07	; 7
    23b8:	72 c0       	rjmp	.+228    	; 0x249e <__stack+0x29f>
        } // Else, keep current stored value.
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    23ba:	8a e1       	ldi	r24, 0x1A	; 26
    23bc:	70 c0       	rjmp	.+224    	; 0x249e <__stack+0x29f>

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    23be:	8f e1       	ldi	r24, 0x1F	; 31
    23c0:	6e c0       	rjmp	.+220    	; 0x249e <__stack+0x29f>
        case NON_MODAL_GO_HOME_1: // G30
          // [G28/30 Errors]: Cutter compensation is enabled.
          // Retreive G28/30 go-home position data (in machine coordinates) from EEPROM
          // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    23c2:	87 e0       	ldi	r24, 0x07	; 7
    23c4:	6c c0       	rjmp	.+216    	; 0x249e <__stack+0x29f>
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    23c6:	87 e0       	ldi	r24, 0x07	; 7
    23c8:	6a c0       	rjmp	.+212    	; 0x249e <__stack+0x29f>
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
            FAIL(STATUS_GCODE_G53_INVALID_MOTION_MODE); // [G53 G0/1 not active]
    23ca:	8e e1       	ldi	r24, 0x1E	; 30
    23cc:	68 c0       	rjmp	.+208    	; 0x249e <__stack+0x29f>

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    23ce:	8f e1       	ldi	r24, 0x1F	; 31
    23d0:	66 c0       	rjmp	.+204    	; 0x249e <__stack+0x29f>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    23d2:	86 e1       	ldi	r24, 0x16	; 22
    23d4:	64 c0       	rjmp	.+200    	; 0x249e <__stack+0x29f>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.

          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    23d6:	8a e1       	ldi	r24, 0x1A	; 26
    23d8:	62 c0       	rjmp	.+196    	; 0x249e <__stack+0x29f>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    23da:	80 e2       	ldi	r24, 0x20	; 32
    23dc:	60 c0       	rjmp	.+192    	; 0x249e <__stack+0x29f>
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target

          if (value_words & bit(WORD_R)) { // Arc Radius Mode
            bit_false(value_words,bit(WORD_R));
            if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    23de:	81 e2       	ldi	r24, 0x21	; 33
    23e0:	5e c0       	rjmp	.+188    	; 0x249e <__stack+0x29f>

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    23e2:	82 e2       	ldi	r24, 0x22	; 34
    23e4:	5c c0       	rjmp	.+184    	; 0x249e <__stack+0x29f>
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));

          } else { // Arc Center Format Offset Mode
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    23e6:	83 e2       	ldi	r24, 0x23	; 35
    23e8:	5a c0       	rjmp	.+180    	; 0x249e <__stack+0x29f>
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]);

            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
            if (delta_r > 0.005) {
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    23ea:	81 e2       	ldi	r24, 0x21	; 33
    23ec:	58 c0       	rjmp	.+176    	; 0x249e <__stack+0x29f>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    23ee:	81 e2       	ldi	r24, 0x21	; 33
    23f0:	56 c0       	rjmp	.+172    	; 0x249e <__stack+0x29f>
              (gc_block.modal.motion == MOTION_MODE_PROBE_AWAY_NO_ERROR)) { gc_parser_flags |= GC_PARSER_PROBE_IS_AWAY; }
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    23f2:	8a e1       	ldi	r24, 0x1A	; 26
    23f4:	54 c0       	rjmp	.+168    	; 0x249e <__stack+0x29f>
          if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    23f6:	81 e2       	ldi	r24, 0x21	; 33
    23f8:	52 c0       	rjmp	.+164    	; 0x249e <__stack+0x29f>
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)));
  } else {
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words.
  }
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words.
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    23fa:	84 e2       	ldi	r24, 0x24	; 36
    23fc:	50 c0       	rjmp	.+160    	; 0x249e <__stack+0x29f>
  // targets are computed correctly. The final parser position after a jog is updated in
  // protocol_execute_realtime() when jogging completes or is canceled.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    // Only distance and unit modal commands and G53 absolute override command are allowed.
    // NOTE: Feed rate word and axis word checks have already been performed in STEP 3.
    if (command_words & ~(bit(MODAL_GROUP_G3) | bit(MODAL_GROUP_G6 | bit(MODAL_GROUP_G0))) ) { FAIL(STATUS_INVALID_JOG_COMMAND) };
    23fe:	80 e1       	ldi	r24, 0x10	; 16
    2400:	4e c0       	rjmp	.+156    	; 0x249e <__stack+0x29f>
    if (!(gc_block.non_modal_command == NON_MODAL_ABSOLUTE_OVERRIDE || gc_block.non_modal_command == NON_MODAL_NO_ACTION)) { FAIL(STATUS_INVALID_JOG_COMMAND); }
    2402:	80 e1       	ldi	r24, 0x10	; 16
    2404:	4c c0       	rjmp	.+152    	; 0x249e <__stack+0x29f>
        sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE;
      #endif

      // Execute coordinate change and spindle/coolant stop.
      if (sys.state != STATE_CHECK_MODE) {
        if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    2406:	87 e0       	ldi	r24, 0x07	; 7
    2408:	4a c0       	rjmp	.+148    	; 0x249e <__stack+0x29f>

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    240a:	8f e1       	ldi	r24, 0x1F	; 31
    240c:	48 c0       	rjmp	.+144    	; 0x249e <__stack+0x29f>
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
  else { char_counter = 0; }
    240e:	19 82       	std	Y+1, r1	; 0x01
  uint8_t ijk_words = 0; // IJK tracking

  // Initialize command and value words and parser flags variables.
  uint16_t command_words = 0; // Tracks G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Tracks value words.
  uint8_t gc_parser_flags = GC_PARSER_NONE;
    2410:	1c a2       	std	Y+36, r1	; 0x24
    2412:	0c 94 9a 07 	jmp	0xf34	; 0xf34 <gc_execute_line+0x74>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
    2416:	a6 e9       	ldi	r26, 0x96	; 150
    2418:	bc e0       	ldi	r27, 0x0C	; 12
    241a:	ac 92       	st	X, r10
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
    241c:	bc e1       	ldi	r27, 0x1C	; 28
    241e:	ab 12       	cpse	r10, r27
    2420:	27 c0       	rjmp	.+78     	; 0x2470 <__stack+0x271>
    2422:	0c 94 15 08 	jmp	0x102a	; 0x102a <gc_execute_line+0x16a>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
    2426:	e6 e9       	ldi	r30, 0x96	; 150
    2428:	fc e0       	ldi	r31, 0x0C	; 12
    242a:	a0 82       	st	Z, r10
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
    242c:	fc e1       	ldi	r31, 0x1C	; 28
    242e:	af 12       	cpse	r10, r31
    2430:	25 c0       	rjmp	.+74     	; 0x247c <__stack+0x27d>
    2432:	0c 94 1a 08 	jmp	0x1034	; 0x1034 <gc_execute_line+0x174>
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
    2436:	21 e0       	ldi	r18, 0x01	; 1
    2438:	2f a7       	std	Y+47, r18	; 0x2f
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
    243a:	1e a2       	std	Y+38, r1	; 0x26
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
    243c:	32 e0       	ldi	r19, 0x02	; 2
    243e:	3d a3       	std	Y+37, r19	; 0x25
  }

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    2440:	80 91 99 0c 	lds	r24, 0x0C99	; 0x800c99 <gc_block+0x3>
    2444:	81 30       	cpi	r24, 0x01	; 1
    2446:	09 f0       	breq	.+2      	; 0x244a <__stack+0x24b>
    2448:	a1 c8       	rjmp	.-3774   	; 0x158c <gc_execute_line+0x6cc>
    244a:	6c c8       	rjmp	.-3880   	; 0x1524 <gc_execute_line+0x664>
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
          }
          if (axis_words) {
    244c:	49 a1       	ldd	r20, Y+33	; 0x21
    244e:	44 23       	and	r20, r20
    2450:	f1 f0       	breq	.+60     	; 0x248e <__stack+0x28f>
    2452:	a6 e5       	ldi	r26, 0x56	; 86
    2454:	bc e0       	ldi	r27, 0x0C	; 12
    2456:	e6 e9       	ldi	r30, 0x96	; 150
    2458:	fc e0       	ldi	r31, 0x0C	; 12
    245a:	80 e0       	ldi	r24, 0x00	; 0
    245c:	90 e0       	ldi	r25, 0x00	; 0
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
    245e:	24 2f       	mov	r18, r20
    2460:	30 e0       	ldi	r19, 0x00	; 0
    2462:	85 ca       	rjmp	.-2806   	; 0x196e <gc_execute_line+0xaae>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    2464:	10 91 97 0c 	lds	r17, 0x0C97	; 0x800c97 <gc_block+0x1>
    2468:	10 35       	cpi	r17, 0x50	; 80
    246a:	09 f0       	breq	.+2      	; 0x246e <__stack+0x26f>
    246c:	aa ca       	rjmp	.-2732   	; 0x19c2 <gc_execute_line+0xb02>
    246e:	cd cf       	rjmp	.-102    	; 0x240a <__stack+0x20b>
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
    2470:	8e e1       	ldi	r24, 0x1E	; 30
    2472:	a8 12       	cpse	r10, r24
    2474:	0c 94 0f 08 	jmp	0x101e	; 0x101e <gc_execute_line+0x15e>
    2478:	0c 94 15 08 	jmp	0x102a	; 0x102a <gc_execute_line+0x16a>
    247c:	9e e1       	ldi	r25, 0x1E	; 30
    247e:	a9 16       	cp	r10, r25
    2480:	11 f4       	brne	.+4      	; 0x2486 <__stack+0x287>
    2482:	0c 94 1d 08 	jmp	0x103a	; 0x103a <gc_execute_line+0x17a>
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
    2486:	a1 e0       	ldi	r26, 0x01	; 1
    2488:	aa a3       	std	Y+34, r26	; 0x22
    248a:	0c 94 0f 08 	jmp	0x101e	; 0x101e <gc_execute_line+0x15e>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    248e:	10 91 97 0c 	lds	r17, 0x0C97	; 0x800c97 <gc_block+0x1>
    2492:	10 35       	cpi	r17, 0x50	; 80
    2494:	09 f4       	brne	.+2      	; 0x2498 <__stack+0x299>
    2496:	d8 cc       	rjmp	.-1616   	; 0x1e48 <gc_execute_line+0xf88>
    2498:	1f 8e       	std	Y+31, r1	; 0x1f
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
            }
          } else {
            axis_command = AXIS_COMMAND_NONE; // Set to none if no intermediate motion.
    249a:	1a a2       	std	Y+34, r1	; 0x22
    249c:	92 ca       	rjmp	.-2780   	; 0x19c2 <gc_execute_line+0xb02>
  }

  // TODO: % to denote start of program.

  return(STATUS_OK);
}
    249e:	e1 96       	adiw	r28, 0x31	; 49
    24a0:	0f b6       	in	r0, 0x3f	; 63
    24a2:	f8 94       	cli
    24a4:	de bf       	out	0x3e, r29	; 62
    24a6:	0f be       	out	0x3f, r0	; 63
    24a8:	cd bf       	out	0x3d, r28	; 61
    24aa:	df 91       	pop	r29
    24ac:	cf 91       	pop	r28
    24ae:	1f 91       	pop	r17
    24b0:	0f 91       	pop	r16
    24b2:	ff 90       	pop	r15
    24b4:	ef 90       	pop	r14
    24b6:	df 90       	pop	r13
    24b8:	cf 90       	pop	r12
    24ba:	bf 90       	pop	r11
    24bc:	af 90       	pop	r10
    24be:	9f 90       	pop	r9
    24c0:	8f 90       	pop	r8
    24c2:	7f 90       	pop	r7
    24c4:	6f 90       	pop	r6
    24c6:	5f 90       	pop	r5
    24c8:	4f 90       	pop	r4
    24ca:	3f 90       	pop	r3
    24cc:	2f 90       	pop	r2
    24ce:	08 95       	ret

000024d0 <spindle_get_state>:
uint8_t spindle_get_state()
{
  #ifdef INVERT_SPINDLE_ENABLE_PIN
    if (bit_isfalse(SPINDLE_ENABLE_PORT,(1<<SPINDLE_ENABLE_BIT)) && (SPINDLE_TCCRA_REGISTER & (1<<SPINDLE_COMB_BIT))) {
  #else
    if (bit_istrue(SPINDLE_ENABLE_PORT,(1<<SPINDLE_ENABLE_BIT)) && (SPINDLE_TCCRA_REGISTER & (1<<SPINDLE_COMB_BIT))) {
    24d0:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    24d4:	89 2f       	mov	r24, r25
    24d6:	88 70       	andi	r24, 0x08	; 8
    24d8:	93 ff       	sbrs	r25, 3
    24da:	0b c0       	rjmp	.+22     	; 0x24f2 <spindle_get_state+0x22>
    24dc:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
    24e0:	89 2f       	mov	r24, r25
    24e2:	80 72       	andi	r24, 0x20	; 32
    24e4:	95 ff       	sbrs	r25, 5
    24e6:	05 c0       	rjmp	.+10     	; 0x24f2 <spindle_get_state+0x22>
  #endif
    if (SPINDLE_DIRECTION_PORT & (1<<SPINDLE_DIRECTION_BIT)) { return(SPINDLE_STATE_CCW); }
    24e8:	73 99       	sbic	0x0e, 3	; 14
    24ea:	02 c0       	rjmp	.+4      	; 0x24f0 <spindle_get_state+0x20>
    else { return(SPINDLE_STATE_CW); }
    24ec:	81 e0       	ldi	r24, 0x01	; 1
    24ee:	08 95       	ret
  #ifdef INVERT_SPINDLE_ENABLE_PIN
    if (bit_isfalse(SPINDLE_ENABLE_PORT,(1<<SPINDLE_ENABLE_BIT)) && (SPINDLE_TCCRA_REGISTER & (1<<SPINDLE_COMB_BIT))) {
  #else
    if (bit_istrue(SPINDLE_ENABLE_PORT,(1<<SPINDLE_ENABLE_BIT)) && (SPINDLE_TCCRA_REGISTER & (1<<SPINDLE_COMB_BIT))) {
  #endif
    if (SPINDLE_DIRECTION_PORT & (1<<SPINDLE_DIRECTION_BIT)) { return(SPINDLE_STATE_CCW); }
    24f0:	82 e0       	ldi	r24, 0x02	; 2
    else { return(SPINDLE_STATE_CW); }
  }
	return(SPINDLE_STATE_DISABLE);
}
    24f2:	08 95       	ret

000024f4 <spindle_stop>:
// Disables the spindle and sets PWM output to zero when PWM variable spindle speed is enabled.
// Called by various main program and ISR routines. Keep routine small, fast, and efficient.
// Called by spindle_init(), spindle_set_speed(), spindle_set_state(), and mc_reset().
void spindle_stop()
{
  SPINDLE_TCCRA_REGISTER &= ~(1<<SPINDLE_COMB_BIT); // Disable PWM. Output voltage is zero.
    24f4:	e0 ea       	ldi	r30, 0xA0	; 160
    24f6:	f0 e0       	ldi	r31, 0x00	; 0
    24f8:	80 81       	ld	r24, Z
    24fa:	8f 7d       	andi	r24, 0xDF	; 223
    24fc:	80 83       	st	Z, r24
  #ifdef INVERT_SPINDLE_ENABLE_PIN
    SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);  // Set pin to high
  #else
    SPINDLE_ENABLE_PORT &= ~(1<<SPINDLE_ENABLE_BIT); // Set pin to low
    24fe:	e2 e0       	ldi	r30, 0x02	; 2
    2500:	f1 e0       	ldi	r31, 0x01	; 1
    2502:	80 81       	ld	r24, Z
    2504:	87 7f       	andi	r24, 0xF7	; 247
    2506:	80 83       	st	Z, r24
    2508:	08 95       	ret

0000250a <spindle_init>:


void spindle_init()
{    
  // Configure variable spindle PWM and enable pin, if required.
  SPINDLE_PWM_DDR |= (1<<SPINDLE_PWM_BIT); // Configure as PWM output pin.
    250a:	e1 e0       	ldi	r30, 0x01	; 1
    250c:	f1 e0       	ldi	r31, 0x01	; 1
    250e:	80 81       	ld	r24, Z
    2510:	80 61       	ori	r24, 0x10	; 16
    2512:	80 83       	st	Z, r24
  SPINDLE_TCCRA_REGISTER = SPINDLE_TCCRA_INIT_MASK; // Configure PWM output compare timer
    2514:	83 e0       	ldi	r24, 0x03	; 3
    2516:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
  SPINDLE_TCCRB_REGISTER = SPINDLE_TCCRB_INIT_MASK;
    251a:	8a e1       	ldi	r24, 0x1A	; 26
    251c:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
  SPINDLE_OCRA_REGISTER = SPINDLE_OCRA_TOP_VALUE; // Set the top value for 16-bit fast PWM mode
    2520:	80 e0       	ldi	r24, 0x00	; 0
    2522:	94 e0       	ldi	r25, 0x04	; 4
    2524:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
    2528:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
  SPINDLE_ENABLE_DDR |= (1<<SPINDLE_ENABLE_BIT); // Configure as output pin.
    252c:	80 81       	ld	r24, Z
    252e:	88 60       	ori	r24, 0x08	; 8
    2530:	80 83       	st	Z, r24
  SPINDLE_DIRECTION_DDR |= (1<<SPINDLE_DIRECTION_BIT); // Configure as output pin.
    2532:	6b 9a       	sbi	0x0d, 3	; 13

  pwm_gradient = SPINDLE_PWM_RANGE/(settings.rpm_max-settings.rpm_min);
    2534:	20 91 11 0f 	lds	r18, 0x0F11	; 0x800f11 <settings+0x41>
    2538:	30 91 12 0f 	lds	r19, 0x0F12	; 0x800f12 <settings+0x42>
    253c:	40 91 13 0f 	lds	r20, 0x0F13	; 0x800f13 <settings+0x43>
    2540:	50 91 14 0f 	lds	r21, 0x0F14	; 0x800f14 <settings+0x44>
    2544:	60 91 0d 0f 	lds	r22, 0x0F0D	; 0x800f0d <settings+0x3d>
    2548:	70 91 0e 0f 	lds	r23, 0x0F0E	; 0x800f0e <settings+0x3e>
    254c:	80 91 0f 0f 	lds	r24, 0x0F0F	; 0x800f0f <settings+0x3f>
    2550:	90 91 10 0f 	lds	r25, 0x0F10	; 0x800f10 <settings+0x40>
    2554:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    2558:	9b 01       	movw	r18, r22
    255a:	ac 01       	movw	r20, r24
    255c:	60 e0       	ldi	r22, 0x00	; 0
    255e:	70 ec       	ldi	r23, 0xC0	; 192
    2560:	8f e7       	ldi	r24, 0x7F	; 127
    2562:	94 e4       	ldi	r25, 0x44	; 68
    2564:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <__divsf3>
    2568:	60 93 00 02 	sts	0x0200, r22	; 0x800200 <_edata>
    256c:	70 93 01 02 	sts	0x0201, r23	; 0x800201 <_edata+0x1>
    2570:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <_edata+0x2>
    2574:	90 93 03 02 	sts	0x0203, r25	; 0x800203 <_edata+0x3>
  spindle_stop();
    2578:	bd cf       	rjmp	.-134    	; 0x24f4 <spindle_stop>
    257a:	08 95       	ret

0000257c <spindle_set_speed>:

// Sets spindle speed PWM output and enable pin, if configured. Called by spindle_set_state()
// and stepper ISR. Keep routine small and efficient.
void spindle_set_speed(uint16_t pwm_value)
{
  SPINDLE_OCR_REGISTER = pwm_value; // Set PWM output level.
    257c:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
    2580:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
      #else
        SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
      #endif
    }
  #else
    if (pwm_value == SPINDLE_PWM_OFF_VALUE) {
    2584:	89 2b       	or	r24, r25
    2586:	31 f4       	brne	.+12     	; 0x2594 <spindle_set_speed+0x18>
      SPINDLE_TCCRA_REGISTER &= ~(1<<SPINDLE_COMB_BIT); // Disable PWM. Output voltage is zero.
    2588:	e0 ea       	ldi	r30, 0xA0	; 160
    258a:	f0 e0       	ldi	r31, 0x00	; 0
    258c:	80 81       	ld	r24, Z
    258e:	8f 7d       	andi	r24, 0xDF	; 223
    2590:	80 83       	st	Z, r24
    2592:	08 95       	ret
    } else {
      SPINDLE_TCCRA_REGISTER |= (1<<SPINDLE_COMB_BIT); // Ensure PWM output is enabled.
    2594:	e0 ea       	ldi	r30, 0xA0	; 160
    2596:	f0 e0       	ldi	r31, 0x00	; 0
    2598:	80 81       	ld	r24, Z
    259a:	80 62       	ori	r24, 0x20	; 32
    259c:	80 83       	st	Z, r24
    259e:	08 95       	ret

000025a0 <spindle_compute_pwm_value>:

#else 

  // Called by spindle_set_state() and step segment generator. Keep routine small and efficient.
  uint16_t spindle_compute_pwm_value(float rpm) // Mega2560 PWM register is 16-bit.
  {
    25a0:	4f 92       	push	r4
    25a2:	5f 92       	push	r5
    25a4:	6f 92       	push	r6
    25a6:	7f 92       	push	r7
    25a8:	8f 92       	push	r8
    25aa:	9f 92       	push	r9
    25ac:	af 92       	push	r10
    25ae:	bf 92       	push	r11
    25b0:	cf 92       	push	r12
    25b2:	df 92       	push	r13
    25b4:	ef 92       	push	r14
    25b6:	ff 92       	push	r15
    25b8:	2b 01       	movw	r4, r22
    25ba:	3c 01       	movw	r6, r24
	uint16_t pwm_value;
	rpm *= (0.010*sys.spindle_speed_ovr); // Scale by spindle speed override value.
	// Calculate PWM register value based on rpm max/min settings and programmed rpm.
	if ((settings.rpm_min >= settings.rpm_max) || (rpm >= settings.rpm_max)) {
    25bc:	80 90 11 0f 	lds	r8, 0x0F11	; 0x800f11 <settings+0x41>
    25c0:	90 90 12 0f 	lds	r9, 0x0F12	; 0x800f12 <settings+0x42>
    25c4:	a0 90 13 0f 	lds	r10, 0x0F13	; 0x800f13 <settings+0x43>
    25c8:	b0 90 14 0f 	lds	r11, 0x0F14	; 0x800f14 <settings+0x44>
    25cc:	c0 90 0d 0f 	lds	r12, 0x0F0D	; 0x800f0d <settings+0x3d>
    25d0:	d0 90 0e 0f 	lds	r13, 0x0F0E	; 0x800f0e <settings+0x3e>
    25d4:	e0 90 0f 0f 	lds	r14, 0x0F0F	; 0x800f0f <settings+0x3f>
    25d8:	f0 90 10 0f 	lds	r15, 0x0F10	; 0x800f10 <settings+0x40>
    25dc:	a7 01       	movw	r20, r14
    25de:	96 01       	movw	r18, r12
    25e0:	c5 01       	movw	r24, r10
    25e2:	b4 01       	movw	r22, r8
    25e4:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    25e8:	88 23       	and	r24, r24
    25ea:	cc f4       	brge	.+50     	; 0x261e <spindle_compute_pwm_value+0x7e>

  // Called by spindle_set_state() and step segment generator. Keep routine small and efficient.
  uint16_t spindle_compute_pwm_value(float rpm) // Mega2560 PWM register is 16-bit.
  {
	uint16_t pwm_value;
	rpm *= (0.010*sys.spindle_speed_ovr); // Scale by spindle speed override value.
    25ec:	60 91 27 0c 	lds	r22, 0x0C27	; 0x800c27 <sys+0x9>
    25f0:	70 e0       	ldi	r23, 0x00	; 0
    25f2:	80 e0       	ldi	r24, 0x00	; 0
    25f4:	90 e0       	ldi	r25, 0x00	; 0
    25f6:	0e 94 0b 40 	call	0x8016	; 0x8016 <__floatsisf>
    25fa:	2a e0       	ldi	r18, 0x0A	; 10
    25fc:	37 ed       	ldi	r19, 0xD7	; 215
    25fe:	43 e2       	ldi	r20, 0x23	; 35
    2600:	5c e3       	ldi	r21, 0x3C	; 60
    2602:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    2606:	a3 01       	movw	r20, r6
    2608:	92 01       	movw	r18, r4
    260a:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    260e:	2b 01       	movw	r4, r22
    2610:	3c 01       	movw	r6, r24
	// Calculate PWM register value based on rpm max/min settings and programmed rpm.
	if ((settings.rpm_min >= settings.rpm_max) || (rpm >= settings.rpm_max)) {
    2612:	a7 01       	movw	r20, r14
    2614:	96 01       	movw	r18, r12
    2616:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    261a:	88 23       	and	r24, r24
    261c:	5c f0       	brlt	.+22     	; 0x2634 <spindle_compute_pwm_value+0x94>
	  // No PWM range possible. Set simple on/off spindle control pin state.
	  sys.spindle_speed = settings.rpm_max;
    261e:	c0 92 2c 0c 	sts	0x0C2C, r12	; 0x800c2c <sys+0xe>
    2622:	d0 92 2d 0c 	sts	0x0C2D, r13	; 0x800c2d <sys+0xf>
    2626:	e0 92 2e 0c 	sts	0x0C2E, r14	; 0x800c2e <sys+0x10>
    262a:	f0 92 2f 0c 	sts	0x0C2F, r15	; 0x800c2f <sys+0x11>
	  pwm_value = SPINDLE_PWM_MAX_VALUE;
    262e:	80 e0       	ldi	r24, 0x00	; 0
    2630:	94 e0       	ldi	r25, 0x04	; 4
    2632:	4a c0       	rjmp	.+148    	; 0x26c8 <spindle_compute_pwm_value+0x128>
	} else if (rpm <= settings.rpm_min) {
    2634:	a5 01       	movw	r20, r10
    2636:	94 01       	movw	r18, r8
    2638:	c3 01       	movw	r24, r6
    263a:	b2 01       	movw	r22, r4
    263c:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    2640:	18 16       	cp	r1, r24
    2642:	fc f0       	brlt	.+62     	; 0x2682 <spindle_compute_pwm_value+0xe2>
	  if (rpm == 0.0) { // S0 disables spindle
    2644:	20 e0       	ldi	r18, 0x00	; 0
    2646:	30 e0       	ldi	r19, 0x00	; 0
    2648:	a9 01       	movw	r20, r18
    264a:	c3 01       	movw	r24, r6
    264c:	b2 01       	movw	r22, r4
    264e:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    2652:	81 11       	cpse	r24, r1
    2654:	0b c0       	rjmp	.+22     	; 0x266c <spindle_compute_pwm_value+0xcc>
		sys.spindle_speed = 0.0;
    2656:	10 92 2c 0c 	sts	0x0C2C, r1	; 0x800c2c <sys+0xe>
    265a:	10 92 2d 0c 	sts	0x0C2D, r1	; 0x800c2d <sys+0xf>
    265e:	10 92 2e 0c 	sts	0x0C2E, r1	; 0x800c2e <sys+0x10>
    2662:	10 92 2f 0c 	sts	0x0C2F, r1	; 0x800c2f <sys+0x11>
		pwm_value = SPINDLE_PWM_OFF_VALUE;
    2666:	80 e0       	ldi	r24, 0x00	; 0
    2668:	90 e0       	ldi	r25, 0x00	; 0
    266a:	2e c0       	rjmp	.+92     	; 0x26c8 <spindle_compute_pwm_value+0x128>
	  } else { // Set minimum PWM output
		sys.spindle_speed = settings.rpm_min;
    266c:	80 92 2c 0c 	sts	0x0C2C, r8	; 0x800c2c <sys+0xe>
    2670:	90 92 2d 0c 	sts	0x0C2D, r9	; 0x800c2d <sys+0xf>
    2674:	a0 92 2e 0c 	sts	0x0C2E, r10	; 0x800c2e <sys+0x10>
    2678:	b0 92 2f 0c 	sts	0x0C2F, r11	; 0x800c2f <sys+0x11>
		pwm_value = SPINDLE_PWM_MIN_VALUE;
    267c:	81 e0       	ldi	r24, 0x01	; 1
    267e:	90 e0       	ldi	r25, 0x00	; 0
    2680:	23 c0       	rjmp	.+70     	; 0x26c8 <spindle_compute_pwm_value+0x128>
	  }
	} else { 
	  // Compute intermediate PWM value with linear spindle speed model.
	  // NOTE: A nonlinear model could be installed here, if required, but keep it VERY light-weight.
	  sys.spindle_speed = rpm;
    2682:	40 92 2c 0c 	sts	0x0C2C, r4	; 0x800c2c <sys+0xe>
    2686:	50 92 2d 0c 	sts	0x0C2D, r5	; 0x800c2d <sys+0xf>
    268a:	60 92 2e 0c 	sts	0x0C2E, r6	; 0x800c2e <sys+0x10>
    268e:	70 92 2f 0c 	sts	0x0C2F, r7	; 0x800c2f <sys+0x11>
	  pwm_value = floor((rpm-settings.rpm_min)*pwm_gradient) + SPINDLE_PWM_MIN_VALUE;
    2692:	a5 01       	movw	r20, r10
    2694:	94 01       	movw	r18, r8
    2696:	c3 01       	movw	r24, r6
    2698:	b2 01       	movw	r22, r4
    269a:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    269e:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <_edata>
    26a2:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <_edata+0x1>
    26a6:	40 91 02 02 	lds	r20, 0x0202	; 0x800202 <_edata+0x2>
    26aa:	50 91 03 02 	lds	r21, 0x0203	; 0x800203 <_edata+0x3>
    26ae:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    26b2:	0e 94 46 40 	call	0x808c	; 0x808c <floor>
    26b6:	20 e0       	ldi	r18, 0x00	; 0
    26b8:	30 e0       	ldi	r19, 0x00	; 0
    26ba:	40 e8       	ldi	r20, 0x80	; 128
    26bc:	5f e3       	ldi	r21, 0x3F	; 63
    26be:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    26c2:	0e 94 dd 3f 	call	0x7fba	; 0x7fba <__fixunssfsi>
    26c6:	cb 01       	movw	r24, r22
	}
	return(pwm_value);
  }
    26c8:	ff 90       	pop	r15
    26ca:	ef 90       	pop	r14
    26cc:	df 90       	pop	r13
    26ce:	cf 90       	pop	r12
    26d0:	bf 90       	pop	r11
    26d2:	af 90       	pop	r10
    26d4:	9f 90       	pop	r9
    26d6:	8f 90       	pop	r8
    26d8:	7f 90       	pop	r7
    26da:	6f 90       	pop	r6
    26dc:	5f 90       	pop	r5
    26de:	4f 90       	pop	r4
    26e0:	08 95       	ret

000026e2 <spindle_set_state>:
// Immediately sets spindle running state with direction and spindle rpm via PWM, if enabled.
// Called by g-code parser spindle_sync(), parking retract and restore, g-code program end,
// sleep, and spindle stop override.
void spindle_set_state(uint8_t state, float rpm)
{
  if (sys.abort) { return; } // Block during abort.
    26e2:	90 91 1f 0c 	lds	r25, 0x0C1F	; 0x800c1f <sys+0x1>
    26e6:	91 11       	cpse	r25, r1
    26e8:	25 c0       	rjmp	.+74     	; 0x2734 <spindle_set_state+0x52>
  if (state == SPINDLE_DISABLE) { // Halt or set spindle direction and rpm.
    26ea:	81 11       	cpse	r24, r1
    26ec:	0a c0       	rjmp	.+20     	; 0x2702 <spindle_set_state+0x20>
  
    sys.spindle_speed = 0.0;
    26ee:	10 92 2c 0c 	sts	0x0C2C, r1	; 0x800c2c <sys+0xe>
    26f2:	10 92 2d 0c 	sts	0x0C2D, r1	; 0x800c2d <sys+0xf>
    26f6:	10 92 2e 0c 	sts	0x0C2E, r1	; 0x800c2e <sys+0x10>
    26fa:	10 92 2f 0c 	sts	0x0C2F, r1	; 0x800c2f <sys+0x11>
    spindle_stop();
    26fe:	fa de       	rcall	.-524    	; 0x24f4 <spindle_stop>
    2700:	17 c0       	rjmp	.+46     	; 0x2730 <spindle_set_state+0x4e>
  
  } else {
  
    if (state == SPINDLE_ENABLE_CW) {
    2702:	80 31       	cpi	r24, 0x10	; 16
    2704:	11 f4       	brne	.+4      	; 0x270a <spindle_set_state+0x28>
      SPINDLE_DIRECTION_PORT &= ~(1<<SPINDLE_DIRECTION_BIT);
    2706:	73 98       	cbi	0x0e, 3	; 14
    2708:	0a c0       	rjmp	.+20     	; 0x271e <spindle_set_state+0x3c>
    } else {
      SPINDLE_DIRECTION_PORT |= (1<<SPINDLE_DIRECTION_BIT);
    270a:	73 9a       	sbi	0x0e, 3	; 14
    }

    // NOTE: Assumes all calls to this function is when Grbl is not moving or must remain off.
    if (settings.flags & BITFLAG_LASER_MODE) { 
    270c:	90 91 15 0f 	lds	r25, 0x0F15	; 0x800f15 <settings+0x45>
    2710:	91 ff       	sbrs	r25, 1
    2712:	05 c0       	rjmp	.+10     	; 0x271e <spindle_set_state+0x3c>
      if (state == SPINDLE_ENABLE_CCW) { rpm = 0.0; } // TODO: May need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE);
    2714:	80 32       	cpi	r24, 0x20	; 32
    2716:	19 f4       	brne	.+6      	; 0x271e <spindle_set_state+0x3c>
    2718:	40 e0       	ldi	r20, 0x00	; 0
    271a:	50 e0       	ldi	r21, 0x00	; 0
    271c:	ba 01       	movw	r22, r20
    }
    spindle_set_speed(spindle_compute_pwm_value(rpm));
    271e:	cb 01       	movw	r24, r22
    2720:	ba 01       	movw	r22, r20
    2722:	3e df       	rcall	.-388    	; 0x25a0 <spindle_compute_pwm_value>
    2724:	2b df       	rcall	.-426    	; 0x257c <spindle_set_speed>

    #ifndef SPINDLE_ENABLE_OFF_WITH_ZERO_SPEED
      #ifdef INVERT_SPINDLE_ENABLE_PIN
        SPINDLE_ENABLE_PORT &= ~(1<<SPINDLE_ENABLE_BIT);
      #else
        SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
    2726:	e2 e0       	ldi	r30, 0x02	; 2
    2728:	f1 e0       	ldi	r31, 0x01	; 1
    272a:	80 81       	ld	r24, Z
    272c:	88 60       	ori	r24, 0x08	; 8
    272e:	80 83       	st	Z, r24
      #endif   
    #endif
  
  }
  
  sys.report_ovr_counter = 0; // Set to report change immediately
    2730:	10 92 29 0c 	sts	0x0C29, r1	; 0x800c29 <sys+0xb>
    2734:	08 95       	ret

00002736 <spindle_sync>:


// G-code parser entry-point for setting spindle state. Forces a planner buffer sync and bails 
// if an abort or check-mode is active.
void spindle_sync(uint8_t state, float rpm)
{
    2736:	cf 92       	push	r12
    2738:	df 92       	push	r13
    273a:	ef 92       	push	r14
    273c:	ff 92       	push	r15
    273e:	cf 93       	push	r28
  if (sys.state == STATE_CHECK_MODE) { return; }
    2740:	90 91 1e 0c 	lds	r25, 0x0C1E	; 0x800c1e <sys>
    2744:	92 30       	cpi	r25, 0x02	; 2
    2746:	41 f0       	breq	.+16     	; 0x2758 <spindle_sync+0x22>
    2748:	6a 01       	movw	r12, r20
    274a:	7b 01       	movw	r14, r22
    274c:	c8 2f       	mov	r28, r24
  protocol_buffer_synchronize(); // Empty planner buffer to ensure spindle is set when programmed.
    274e:	84 d5       	rcall	.+2824   	; 0x3258 <protocol_buffer_synchronize>
  spindle_set_state(state,rpm);
    2750:	b7 01       	movw	r22, r14
    2752:	a6 01       	movw	r20, r12
    2754:	8c 2f       	mov	r24, r28
    2756:	c5 df       	rcall	.-118    	; 0x26e2 <spindle_set_state>
}
    2758:	cf 91       	pop	r28
    275a:	ff 90       	pop	r15
    275c:	ef 90       	pop	r14
    275e:	df 90       	pop	r13
    2760:	cf 90       	pop	r12
    2762:	08 95       	ret

00002764 <coolant_get_state>:
{
  uint8_t cl_state = COOLANT_STATE_DISABLE;
  #ifdef INVERT_COOLANT_FLOOD_PIN
    if (bit_isfalse(COOLANT_FLOOD_PORT,(1 << COOLANT_FLOOD_BIT))) {
  #else
    if (bit_istrue(COOLANT_FLOOD_PORT,(1 << COOLANT_FLOOD_BIT))) {
    2764:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2768:	85 ff       	sbrs	r24, 5
    276a:	02 c0       	rjmp	.+4      	; 0x2770 <coolant_get_state+0xc>
  #endif
    cl_state |= COOLANT_STATE_FLOOD;
    276c:	80 e4       	ldi	r24, 0x40	; 64
    276e:	01 c0       	rjmp	.+2      	; 0x2772 <coolant_get_state+0xe>


// Returns current coolant output state. Overrides may alter it from programmed state.
uint8_t coolant_get_state()
{
  uint8_t cl_state = COOLANT_STATE_DISABLE;
    2770:	80 e0       	ldi	r24, 0x00	; 0
    cl_state |= COOLANT_STATE_FLOOD;
  }
  #ifdef INVERT_COOLANT_MIST_PIN
    if (bit_isfalse(COOLANT_MIST_PORT,(1 << COOLANT_MIST_BIT))) {
  #else
    if (bit_istrue(COOLANT_MIST_PORT,(1 << COOLANT_MIST_BIT))) {
    2772:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2776:	96 fd       	sbrc	r25, 6
  #endif
    cl_state |= COOLANT_STATE_MIST;
    2778:	80 68       	ori	r24, 0x80	; 128
  }
  return(cl_state);
}
    277a:	08 95       	ret

0000277c <coolant_stop>:
void coolant_stop()
{
  #ifdef INVERT_COOLANT_FLOOD_PIN
    COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
  #else
    COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    277c:	e2 e0       	ldi	r30, 0x02	; 2
    277e:	f1 e0       	ldi	r31, 0x01	; 1
    2780:	80 81       	ld	r24, Z
    2782:	8f 7d       	andi	r24, 0xDF	; 223
    2784:	80 83       	st	Z, r24
  #endif
  #ifdef INVERT_COOLANT_MIST_PIN
    COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
  #else
    COOLANT_MIST_PORT &= ~(1 << COOLANT_MIST_BIT);
    2786:	80 81       	ld	r24, Z
    2788:	8f 7b       	andi	r24, 0xBF	; 191
    278a:	80 83       	st	Z, r24
    278c:	08 95       	ret

0000278e <coolant_init>:
#include "grbl.h"


void coolant_init()
{
  COOLANT_FLOOD_DDR |= (1 << COOLANT_FLOOD_BIT); // Configure as output pin.
    278e:	e1 e0       	ldi	r30, 0x01	; 1
    2790:	f1 e0       	ldi	r31, 0x01	; 1
    2792:	80 81       	ld	r24, Z
    2794:	80 62       	ori	r24, 0x20	; 32
    2796:	80 83       	st	Z, r24
  COOLANT_MIST_DDR |= (1 << COOLANT_MIST_BIT); // Configure as output pin.
    2798:	80 81       	ld	r24, Z
    279a:	80 64       	ori	r24, 0x40	; 64
    279c:	80 83       	st	Z, r24
  coolant_stop();
    279e:	ee cf       	rjmp	.-36     	; 0x277c <coolant_stop>
    27a0:	08 95       	ret

000027a2 <coolant_set_state>:
// if enabled. Also sets a flag to report an update to a coolant state.
// Called by coolant toggle override, parking restore, parking retract, sleep mode, g-code
// parser program end, and g-code parser coolant_sync().
void coolant_set_state(uint8_t mode)
{
  if (sys.abort) { return; } // Block during abort.  
    27a2:	90 91 1f 0c 	lds	r25, 0x0C1F	; 0x800c1f <sys+0x1>
    27a6:	91 11       	cpse	r25, r1
    27a8:	1c c0       	rjmp	.+56     	; 0x27e2 <coolant_set_state+0x40>
  
  if (mode & COOLANT_FLOOD_ENABLE) {
    27aa:	86 ff       	sbrs	r24, 6
    27ac:	06 c0       	rjmp	.+12     	; 0x27ba <coolant_set_state+0x18>
    #ifdef INVERT_COOLANT_FLOOD_PIN
      COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    #else
      COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
    27ae:	e2 e0       	ldi	r30, 0x02	; 2
    27b0:	f1 e0       	ldi	r31, 0x01	; 1
    27b2:	90 81       	ld	r25, Z
    27b4:	90 62       	ori	r25, 0x20	; 32
    27b6:	90 83       	st	Z, r25
    27b8:	05 c0       	rjmp	.+10     	; 0x27c4 <coolant_set_state+0x22>
    #endif
	} else {
	  #ifdef INVERT_COOLANT_FLOOD_PIN
			COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
		#else
			COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    27ba:	e2 e0       	ldi	r30, 0x02	; 2
    27bc:	f1 e0       	ldi	r31, 0x01	; 1
    27be:	90 81       	ld	r25, Z
    27c0:	9f 7d       	andi	r25, 0xDF	; 223
    27c2:	90 83       	st	Z, r25
		#endif
	}
  
	if (mode & COOLANT_MIST_ENABLE) {
    27c4:	88 23       	and	r24, r24
    27c6:	34 f4       	brge	.+12     	; 0x27d4 <coolant_set_state+0x32>
		#ifdef INVERT_COOLANT_MIST_PIN
			COOLANT_MIST_PORT &= ~(1 << COOLANT_MIST_BIT);
		#else
			COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
    27c8:	e2 e0       	ldi	r30, 0x02	; 2
    27ca:	f1 e0       	ldi	r31, 0x01	; 1
    27cc:	80 81       	ld	r24, Z
    27ce:	80 64       	ori	r24, 0x40	; 64
    27d0:	80 83       	st	Z, r24
    27d2:	05 c0       	rjmp	.+10     	; 0x27de <coolant_set_state+0x3c>
		#endif
	} else {
		#ifdef INVERT_COOLANT_MIST_PIN
			COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
		#else
			COOLANT_MIST_PORT &= ~(1 << COOLANT_MIST_BIT);
    27d4:	e2 e0       	ldi	r30, 0x02	; 2
    27d6:	f1 e0       	ldi	r31, 0x01	; 1
    27d8:	80 81       	ld	r24, Z
    27da:	8f 7b       	andi	r24, 0xBF	; 191
    27dc:	80 83       	st	Z, r24
		#endif
	}
	
  sys.report_ovr_counter = 0; // Set to report change immediately
    27de:	10 92 29 0c 	sts	0x0C29, r1	; 0x800c29 <sys+0xb>
    27e2:	08 95       	ret

000027e4 <coolant_sync>:


// G-code parser entry-point for setting coolant state. Forces a planner buffer sync and bails 
// if an abort or check-mode is active.
void coolant_sync(uint8_t mode)
{
    27e4:	cf 93       	push	r28
  if (sys.state == STATE_CHECK_MODE) { return; }
    27e6:	90 91 1e 0c 	lds	r25, 0x0C1E	; 0x800c1e <sys>
    27ea:	92 30       	cpi	r25, 0x02	; 2
    27ec:	21 f0       	breq	.+8      	; 0x27f6 <coolant_sync+0x12>
    27ee:	c8 2f       	mov	r28, r24
  protocol_buffer_synchronize(); // Ensure coolant turns on when specified in program.
    27f0:	33 d5       	rcall	.+2662   	; 0x3258 <protocol_buffer_synchronize>
  coolant_set_state(mode);
    27f2:	8c 2f       	mov	r24, r28
    27f4:	d6 df       	rcall	.-84     	; 0x27a2 <coolant_set_state>
}
    27f6:	cf 91       	pop	r28
    27f8:	08 95       	ret

000027fa <serial_get_rx_buffer_available>:
uint8_t serial_get_tx_buffer_count()
{
  uint8_t ttail = serial_tx_buffer_tail; // Copy to limit multiple calls to volatile
  if (serial_tx_buffer_head >= ttail) { return(serial_tx_buffer_head-ttail); }
  return (TX_RING_BUFFER - (ttail-serial_tx_buffer_head));
}
    27fa:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <serial_rx_buffer_tail>
    27fe:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <serial_rx_buffer_head>
    2802:	98 17       	cp	r25, r24
    2804:	20 f0       	brcs	.+8      	; 0x280e <serial_get_rx_buffer_available+0x14>
    2806:	98 1b       	sub	r25, r24
    2808:	89 2f       	mov	r24, r25
    280a:	80 95       	com	r24
    280c:	08 95       	ret
    280e:	81 50       	subi	r24, 0x01	; 1
    2810:	89 1b       	sub	r24, r25
    2812:	08 95       	ret

00002814 <serial_init>:
  #if BAUD_RATE < 57600
    uint16_t UBRR0_value = ((F_CPU / (8L * BAUD_RATE)) - 1)/2 ;
    UCSR0A &= ~(1 << U2X0); // baud doubler off  - Only needed on Uno XXX
  #else
    uint16_t UBRR0_value = ((F_CPU / (4L * BAUD_RATE)) - 1)/2;
    UCSR0A |= (1 << U2X0);  // baud doubler on for high baud rates, i.e. 115200
    2814:	e0 ec       	ldi	r30, 0xC0	; 192
    2816:	f0 e0       	ldi	r31, 0x00	; 0
    2818:	80 81       	ld	r24, Z
    281a:	82 60       	ori	r24, 0x02	; 2
    281c:	80 83       	st	Z, r24
  #endif
  UBRR0H = UBRR0_value >> 8;
    281e:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
  UBRR0L = UBRR0_value;
    2822:	80 e1       	ldi	r24, 0x10	; 16
    2824:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>

  // enable rx, tx, and interrupt on complete reception of a byte
  UCSR0B |= (1<<RXEN0 | 1<<TXEN0 | 1<<RXCIE0);
    2828:	e1 ec       	ldi	r30, 0xC1	; 193
    282a:	f0 e0       	ldi	r31, 0x00	; 0
    282c:	80 81       	ld	r24, Z
    282e:	88 69       	ori	r24, 0x98	; 152
    2830:	80 83       	st	Z, r24
    2832:	08 95       	ret

00002834 <serial_write>:


// Writes one byte to the TX serial buffer. Called by main program.
void serial_write(uint8_t data) {
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
    2834:	e0 91 05 02 	lds	r30, 0x0205	; 0x800205 <serial_tx_buffer_head>
    2838:	21 e0       	ldi	r18, 0x01	; 1
    283a:	2e 0f       	add	r18, r30
  if (next_head == TX_RING_BUFFER) { next_head = 0; }

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) {
    283c:	04 c0       	rjmp	.+8      	; 0x2846 <serial_write+0x12>
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.
    if (sys_rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
    283e:	90 91 31 0c 	lds	r25, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    2842:	94 fd       	sbrc	r25, 4
    2844:	0f c0       	rjmp	.+30     	; 0x2864 <serial_write+0x30>
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
  if (next_head == TX_RING_BUFFER) { next_head = 0; }

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) {
    2846:	90 91 04 02 	lds	r25, 0x0204	; 0x800204 <serial_tx_buffer_tail>
    284a:	29 17       	cp	r18, r25
    284c:	c1 f3       	breq	.-16     	; 0x283e <serial_write+0xa>
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.
    if (sys_rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
  }

  // Store data and advance head
  serial_tx_buffer[serial_tx_buffer_head] = data;
    284e:	f0 e0       	ldi	r31, 0x00	; 0
    2850:	e0 53       	subi	r30, 0x30	; 48
    2852:	f3 4f       	sbci	r31, 0xF3	; 243
    2854:	80 83       	st	Z, r24
  serial_tx_buffer_head = next_head;
    2856:	20 93 05 02 	sts	0x0205, r18	; 0x800205 <serial_tx_buffer_head>

  // Enable Data Register Empty Interrupt to make sure tx-streaming is running
  UCSR0B |=  (1 << UDRIE0);
    285a:	e1 ec       	ldi	r30, 0xC1	; 193
    285c:	f0 e0       	ldi	r31, 0x00	; 0
    285e:	80 81       	ld	r24, Z
    2860:	80 62       	ori	r24, 0x20	; 32
    2862:	80 83       	st	Z, r24
    2864:	08 95       	ret

00002866 <__vector_26>:
}


// Data Register Empty Interrupt handler
ISR(SERIAL_UDRE)
{
    2866:	1f 92       	push	r1
    2868:	0f 92       	push	r0
    286a:	0f b6       	in	r0, 0x3f	; 63
    286c:	0f 92       	push	r0
    286e:	11 24       	eor	r1, r1
    2870:	0b b6       	in	r0, 0x3b	; 59
    2872:	0f 92       	push	r0
    2874:	8f 93       	push	r24
    2876:	9f 93       	push	r25
    2878:	ef 93       	push	r30
    287a:	ff 93       	push	r31
  uint8_t tail = serial_tx_buffer_tail; // Temporary serial_tx_buffer_tail (to optimize for volatile)
    287c:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <serial_tx_buffer_tail>

  // Send a byte from the buffer
  UDR0 = serial_tx_buffer[tail];
    2880:	e8 2f       	mov	r30, r24
    2882:	f0 e0       	ldi	r31, 0x00	; 0
    2884:	e0 53       	subi	r30, 0x30	; 48
    2886:	f3 4f       	sbci	r31, 0xF3	; 243
    2888:	90 81       	ld	r25, Z
    288a:	90 93 c6 00 	sts	0x00C6, r25	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>

  // Update tail position
  tail++;
    288e:	8f 5f       	subi	r24, 0xFF	; 255
  if (tail == TX_RING_BUFFER) { tail = 0; }

  serial_tx_buffer_tail = tail;
    2890:	80 93 04 02 	sts	0x0204, r24	; 0x800204 <serial_tx_buffer_tail>

  // Turn off Data Register Empty Interrupt to stop tx-streaming if this concludes the transfer
  if (tail == serial_tx_buffer_head) { UCSR0B &= ~(1 << UDRIE0); }
    2894:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <serial_tx_buffer_head>
    2898:	89 13       	cpse	r24, r25
    289a:	05 c0       	rjmp	.+10     	; 0x28a6 <__vector_26+0x40>
    289c:	e1 ec       	ldi	r30, 0xC1	; 193
    289e:	f0 e0       	ldi	r31, 0x00	; 0
    28a0:	80 81       	ld	r24, Z
    28a2:	8f 7d       	andi	r24, 0xDF	; 223
    28a4:	80 83       	st	Z, r24
}
    28a6:	ff 91       	pop	r31
    28a8:	ef 91       	pop	r30
    28aa:	9f 91       	pop	r25
    28ac:	8f 91       	pop	r24
    28ae:	0f 90       	pop	r0
    28b0:	0b be       	out	0x3b, r0	; 59
    28b2:	0f 90       	pop	r0
    28b4:	0f be       	out	0x3f, r0	; 63
    28b6:	0f 90       	pop	r0
    28b8:	1f 90       	pop	r1
    28ba:	18 95       	reti

000028bc <serial_read>:


// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
    28bc:	90 91 06 02 	lds	r25, 0x0206	; 0x800206 <serial_rx_buffer_tail>
  if (serial_rx_buffer_head == tail) {
    28c0:	80 91 07 02 	lds	r24, 0x0207	; 0x800207 <serial_rx_buffer_head>
    28c4:	98 17       	cp	r25, r24
    28c6:	49 f0       	breq	.+18     	; 0x28da <serial_read+0x1e>
    return SERIAL_NO_DATA;
  } else {
    uint8_t data = serial_rx_buffer[tail];
    28c8:	e9 2f       	mov	r30, r25
    28ca:	f0 e0       	ldi	r31, 0x00	; 0
    28cc:	e0 53       	subi	r30, 0x30	; 48
    28ce:	f2 4f       	sbci	r31, 0xF2	; 242
    28d0:	80 81       	ld	r24, Z

    tail++;
    28d2:	9f 5f       	subi	r25, 0xFF	; 255
    if (tail == RX_RING_BUFFER) { tail = 0; }
    serial_rx_buffer_tail = tail;
    28d4:	90 93 06 02 	sts	0x0206, r25	; 0x800206 <serial_rx_buffer_tail>

    return data;
    28d8:	08 95       	ret
// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
  if (serial_rx_buffer_head == tail) {
    return SERIAL_NO_DATA;
    28da:	8f ef       	ldi	r24, 0xFF	; 255
    if (tail == RX_RING_BUFFER) { tail = 0; }
    serial_rx_buffer_tail = tail;

    return data;
  }
}
    28dc:	08 95       	ret

000028de <__vector_25>:


ISR(SERIAL_RX)
{
    28de:	1f 92       	push	r1
    28e0:	0f 92       	push	r0
    28e2:	0f b6       	in	r0, 0x3f	; 63
    28e4:	0f 92       	push	r0
    28e6:	11 24       	eor	r1, r1
    28e8:	0b b6       	in	r0, 0x3b	; 59
    28ea:	0f 92       	push	r0
    28ec:	2f 93       	push	r18
    28ee:	3f 93       	push	r19
    28f0:	4f 93       	push	r20
    28f2:	5f 93       	push	r21
    28f4:	6f 93       	push	r22
    28f6:	7f 93       	push	r23
    28f8:	8f 93       	push	r24
    28fa:	9f 93       	push	r25
    28fc:	af 93       	push	r26
    28fe:	bf 93       	push	r27
    2900:	ef 93       	push	r30
    2902:	ff 93       	push	r31
  uint8_t data = UDR0;
    2904:	e0 91 c6 00 	lds	r30, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
  uint8_t next_head;

  // Pick off realtime command characters directly from the serial stream. These characters are
  // not passed into the main buffer, but these set system state flag bits for realtime execution.
  switch (data) {
    2908:	e1 32       	cpi	r30, 0x21	; 33
    290a:	a1 f0       	breq	.+40     	; 0x2934 <__vector_25+0x56>
    290c:	18 f4       	brcc	.+6      	; 0x2914 <__vector_25+0x36>
    290e:	e8 31       	cpi	r30, 0x18	; 24
    2910:	31 f0       	breq	.+12     	; 0x291e <__vector_25+0x40>
    2912:	14 c0       	rjmp	.+40     	; 0x293c <__vector_25+0x5e>
    2914:	ef 33       	cpi	r30, 0x3F	; 63
    2916:	31 f0       	breq	.+12     	; 0x2924 <__vector_25+0x46>
    2918:	ee 37       	cpi	r30, 0x7E	; 126
    291a:	41 f0       	breq	.+16     	; 0x292c <__vector_25+0x4e>
    291c:	0f c0       	rjmp	.+30     	; 0x293c <__vector_25+0x5e>
    case CMD_RESET:         mc_reset(); break; // Call motion control reset routine.
    291e:	0e 94 23 07 	call	0xe46	; 0xe46 <mc_reset>
    2922:	81 c0       	rjmp	.+258    	; 0x2a26 <__vector_25+0x148>
    case CMD_STATUS_REPORT: system_set_exec_state_flag(EXEC_STATUS_REPORT); break; // Set as true
    2924:	81 e0       	ldi	r24, 0x01	; 1
    2926:	0e 94 99 3b 	call	0x7732	; 0x7732 <system_set_exec_state_flag>
    292a:	7d c0       	rjmp	.+250    	; 0x2a26 <__vector_25+0x148>
    case CMD_CYCLE_START:   system_set_exec_state_flag(EXEC_CYCLE_START); break; // Set as true
    292c:	82 e0       	ldi	r24, 0x02	; 2
    292e:	0e 94 99 3b 	call	0x7732	; 0x7732 <system_set_exec_state_flag>
    2932:	79 c0       	rjmp	.+242    	; 0x2a26 <__vector_25+0x148>
    case CMD_FEED_HOLD:     system_set_exec_state_flag(EXEC_FEED_HOLD); break; // Set as true
    2934:	88 e0       	ldi	r24, 0x08	; 8
    2936:	0e 94 99 3b 	call	0x7732	; 0x7732 <system_set_exec_state_flag>
    293a:	75 c0       	rjmp	.+234    	; 0x2a26 <__vector_25+0x148>
    default :
      if (data > 0x7F) { // Real-time control characters are extended ACSII only.
    293c:	ee 23       	and	r30, r30
    293e:	0c f0       	brlt	.+2      	; 0x2942 <__vector_25+0x64>
    2940:	64 c0       	rjmp	.+200    	; 0x2a0a <__vector_25+0x12c>
        switch(data) {
    2942:	8e 2f       	mov	r24, r30
    2944:	90 e0       	ldi	r25, 0x00	; 0
    2946:	fc 01       	movw	r30, r24
    2948:	e4 58       	subi	r30, 0x84	; 132
    294a:	f1 09       	sbc	r31, r1
    294c:	ee 31       	cpi	r30, 0x1E	; 30
    294e:	f1 05       	cpc	r31, r1
    2950:	08 f0       	brcs	.+2      	; 0x2954 <__vector_25+0x76>
    2952:	69 c0       	rjmp	.+210    	; 0x2a26 <__vector_25+0x148>
    2954:	88 27       	eor	r24, r24
    2956:	eb 5f       	subi	r30, 0xFB	; 251
    2958:	fe 4f       	sbci	r31, 0xFE	; 254
    295a:	8f 4f       	sbci	r24, 0xFF	; 255
    295c:	0c 94 b6 42 	jmp	0x856c	; 0x856c <__tablejump2__>
          case CMD_SAFETY_DOOR:   system_set_exec_state_flag(EXEC_SAFETY_DOOR); break; // Set as true
    2960:	80 e2       	ldi	r24, 0x20	; 32
    2962:	0e 94 99 3b 	call	0x7732	; 0x7732 <system_set_exec_state_flag>
    2966:	5f c0       	rjmp	.+190    	; 0x2a26 <__vector_25+0x148>
          case CMD_JOG_CANCEL:   
            if (sys.state & STATE_JOG) { // Block all other states from invoking motion cancel.
    2968:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    296c:	85 ff       	sbrs	r24, 5
    296e:	5b c0       	rjmp	.+182    	; 0x2a26 <__vector_25+0x148>
              system_set_exec_state_flag(EXEC_MOTION_CANCEL); 
    2970:	80 e4       	ldi	r24, 0x40	; 64
    2972:	0e 94 99 3b 	call	0x7732	; 0x7732 <system_set_exec_state_flag>
    2976:	57 c0       	rjmp	.+174    	; 0x2a26 <__vector_25+0x148>
            }
            break; 
          #ifdef DEBUG
            case CMD_DEBUG_REPORT: {uint8_t sreg = SREG; cli(); bit_true(sys_rt_exec_debug,EXEC_DEBUG_REPORT); SREG = sreg;} break;
    2978:	9f b7       	in	r25, 0x3f	; 63
    297a:	f8 94       	cli
    297c:	80 91 54 0c 	lds	r24, 0x0C54	; 0x800c54 <sys_rt_exec_debug>
    2980:	81 60       	ori	r24, 0x01	; 1
    2982:	80 93 54 0c 	sts	0x0C54, r24	; 0x800c54 <sys_rt_exec_debug>
    2986:	9f bf       	out	0x3f, r25	; 63
    2988:	4e c0       	rjmp	.+156    	; 0x2a26 <__vector_25+0x148>
          #endif
          case CMD_FEED_OVR_RESET: system_set_exec_motion_override_flag(EXEC_FEED_OVR_RESET); break;
    298a:	81 e0       	ldi	r24, 0x01	; 1
    298c:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <system_set_exec_motion_override_flag>
    2990:	4a c0       	rjmp	.+148    	; 0x2a26 <__vector_25+0x148>
          case CMD_FEED_OVR_COARSE_PLUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_COARSE_PLUS); break;
    2992:	82 e0       	ldi	r24, 0x02	; 2
    2994:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <system_set_exec_motion_override_flag>
    2998:	46 c0       	rjmp	.+140    	; 0x2a26 <__vector_25+0x148>
          case CMD_FEED_OVR_COARSE_MINUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_COARSE_MINUS); break;
    299a:	84 e0       	ldi	r24, 0x04	; 4
    299c:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <system_set_exec_motion_override_flag>
    29a0:	42 c0       	rjmp	.+132    	; 0x2a26 <__vector_25+0x148>
          case CMD_FEED_OVR_FINE_PLUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_FINE_PLUS); break;
    29a2:	88 e0       	ldi	r24, 0x08	; 8
    29a4:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <system_set_exec_motion_override_flag>
    29a8:	3e c0       	rjmp	.+124    	; 0x2a26 <__vector_25+0x148>
          case CMD_FEED_OVR_FINE_MINUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_FINE_MINUS); break;
    29aa:	80 e1       	ldi	r24, 0x10	; 16
    29ac:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <system_set_exec_motion_override_flag>
    29b0:	3a c0       	rjmp	.+116    	; 0x2a26 <__vector_25+0x148>
          case CMD_RAPID_OVR_RESET: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_RESET); break;
    29b2:	80 e2       	ldi	r24, 0x20	; 32
    29b4:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <system_set_exec_motion_override_flag>
    29b8:	36 c0       	rjmp	.+108    	; 0x2a26 <__vector_25+0x148>
          case CMD_RAPID_OVR_MEDIUM: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_MEDIUM); break;
    29ba:	80 e4       	ldi	r24, 0x40	; 64
    29bc:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <system_set_exec_motion_override_flag>
    29c0:	32 c0       	rjmp	.+100    	; 0x2a26 <__vector_25+0x148>
          case CMD_RAPID_OVR_LOW: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_LOW); break;
    29c2:	80 e8       	ldi	r24, 0x80	; 128
    29c4:	0e 94 0d 3e 	call	0x7c1a	; 0x7c1a <system_set_exec_motion_override_flag>
    29c8:	2e c0       	rjmp	.+92     	; 0x2a26 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_RESET: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_RESET); break;
    29ca:	81 e0       	ldi	r24, 0x01	; 1
    29cc:	0e 94 16 3e 	call	0x7c2c	; 0x7c2c <system_set_exec_accessory_override_flag>
    29d0:	2a c0       	rjmp	.+84     	; 0x2a26 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_COARSE_PLUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_COARSE_PLUS); break;
    29d2:	82 e0       	ldi	r24, 0x02	; 2
    29d4:	0e 94 16 3e 	call	0x7c2c	; 0x7c2c <system_set_exec_accessory_override_flag>
    29d8:	26 c0       	rjmp	.+76     	; 0x2a26 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_COARSE_MINUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_COARSE_MINUS); break;
    29da:	84 e0       	ldi	r24, 0x04	; 4
    29dc:	0e 94 16 3e 	call	0x7c2c	; 0x7c2c <system_set_exec_accessory_override_flag>
    29e0:	22 c0       	rjmp	.+68     	; 0x2a26 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_FINE_PLUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_FINE_PLUS); break;
    29e2:	88 e0       	ldi	r24, 0x08	; 8
    29e4:	0e 94 16 3e 	call	0x7c2c	; 0x7c2c <system_set_exec_accessory_override_flag>
    29e8:	1e c0       	rjmp	.+60     	; 0x2a26 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_FINE_MINUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_FINE_MINUS); break;
    29ea:	80 e1       	ldi	r24, 0x10	; 16
    29ec:	0e 94 16 3e 	call	0x7c2c	; 0x7c2c <system_set_exec_accessory_override_flag>
    29f0:	1a c0       	rjmp	.+52     	; 0x2a26 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_STOP: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP); break;
    29f2:	80 e2       	ldi	r24, 0x20	; 32
    29f4:	0e 94 16 3e 	call	0x7c2c	; 0x7c2c <system_set_exec_accessory_override_flag>
    29f8:	16 c0       	rjmp	.+44     	; 0x2a26 <__vector_25+0x148>
          case CMD_COOLANT_FLOOD_OVR_TOGGLE: system_set_exec_accessory_override_flag(EXEC_COOLANT_FLOOD_OVR_TOGGLE); break;
    29fa:	80 e4       	ldi	r24, 0x40	; 64
    29fc:	0e 94 16 3e 	call	0x7c2c	; 0x7c2c <system_set_exec_accessory_override_flag>
    2a00:	12 c0       	rjmp	.+36     	; 0x2a26 <__vector_25+0x148>
          case CMD_COOLANT_MIST_OVR_TOGGLE: system_set_exec_accessory_override_flag(EXEC_COOLANT_MIST_OVR_TOGGLE); break;
    2a02:	80 e8       	ldi	r24, 0x80	; 128
    2a04:	0e 94 16 3e 	call	0x7c2c	; 0x7c2c <system_set_exec_accessory_override_flag>
    2a08:	0e c0       	rjmp	.+28     	; 0x2a26 <__vector_25+0x148>
        }
        // Throw away any unfound extended-ASCII character by not passing it to the serial buffer.
      } else { // Write character to buffer
        next_head = serial_rx_buffer_head + 1;
    2a0a:	a0 91 07 02 	lds	r26, 0x0207	; 0x800207 <serial_rx_buffer_head>
    2a0e:	81 e0       	ldi	r24, 0x01	; 1
    2a10:	8a 0f       	add	r24, r26
        if (next_head == RX_RING_BUFFER) { next_head = 0; }

        // Write data to buffer unless it is full.
        if (next_head != serial_rx_buffer_tail) {
    2a12:	90 91 06 02 	lds	r25, 0x0206	; 0x800206 <serial_rx_buffer_tail>
    2a16:	89 17       	cp	r24, r25
    2a18:	31 f0       	breq	.+12     	; 0x2a26 <__vector_25+0x148>
          serial_rx_buffer[serial_rx_buffer_head] = data;
    2a1a:	b0 e0       	ldi	r27, 0x00	; 0
    2a1c:	a0 53       	subi	r26, 0x30	; 48
    2a1e:	b2 4f       	sbci	r27, 0xF2	; 242
    2a20:	ec 93       	st	X, r30
          serial_rx_buffer_head = next_head;
    2a22:	80 93 07 02 	sts	0x0207, r24	; 0x800207 <serial_rx_buffer_head>
        }
      }
  }
}
    2a26:	ff 91       	pop	r31
    2a28:	ef 91       	pop	r30
    2a2a:	bf 91       	pop	r27
    2a2c:	af 91       	pop	r26
    2a2e:	9f 91       	pop	r25
    2a30:	8f 91       	pop	r24
    2a32:	7f 91       	pop	r23
    2a34:	6f 91       	pop	r22
    2a36:	5f 91       	pop	r21
    2a38:	4f 91       	pop	r20
    2a3a:	3f 91       	pop	r19
    2a3c:	2f 91       	pop	r18
    2a3e:	0f 90       	pop	r0
    2a40:	0b be       	out	0x3b, r0	; 59
    2a42:	0f 90       	pop	r0
    2a44:	0f be       	out	0x3f, r0	; 63
    2a46:	0f 90       	pop	r0
    2a48:	1f 90       	pop	r1
    2a4a:	18 95       	reti

00002a4c <serial_reset_read_buffer>:


void serial_reset_read_buffer()
{
  serial_rx_buffer_tail = serial_rx_buffer_head;
    2a4c:	80 91 07 02 	lds	r24, 0x0207	; 0x800207 <serial_rx_buffer_head>
    2a50:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <serial_rx_buffer_tail>
    2a54:	08 95       	ret

00002a56 <protocol_auto_cycle_start>:
// when one of these conditions exist respectively: There are no more blocks sent (i.e. streaming
// is finished, single commands), a command that needs to wait for the motions in the buffer to
// execute calls a buffer sync, or the planner buffer is full and ready to go.
void protocol_auto_cycle_start()
{
  if (plan_get_current_block() != NULL) { // Check if there are any blocks in the buffer.
    2a56:	0e 94 85 29 	call	0x530a	; 0x530a <plan_get_current_block>
    2a5a:	89 2b       	or	r24, r25
    2a5c:	19 f0       	breq	.+6      	; 0x2a64 <protocol_auto_cycle_start+0xe>
    system_set_exec_state_flag(EXEC_CYCLE_START); // If so, execute them!
    2a5e:	82 e0       	ldi	r24, 0x02	; 2
    2a60:	0c 94 99 3b 	jmp	0x7732	; 0x7732 <system_set_exec_state_flag>
    2a64:	08 95       	ret

00002a66 <protocol_exec_rt_system>:

// Executes run-time commands, when required. This function primarily operates as Grbl's state
// machine and controls the various real-time features Grbl has to offer.
// NOTE: Do not alter this unless you know exactly what you are doing!
void protocol_exec_rt_system()
{
    2a66:	cf 93       	push	r28
    2a68:	df 93       	push	r29
  uint8_t rt_exec; // Temp variable to avoid calling volatile multiple times.
  rt_exec = sys_rt_exec_alarm; // Copy volatile sys_rt_exec_alarm.
    2a6a:	c0 91 53 0c 	lds	r28, 0x0C53	; 0x800c53 <sys_rt_exec_alarm>
  if (rt_exec) { // Enter only if any bit flag is true
    2a6e:	cc 23       	and	r28, r28
    2a70:	a9 f0       	breq	.+42     	; 0x2a9c <protocol_exec_rt_system+0x36>
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
    2a72:	81 e0       	ldi	r24, 0x01	; 1
    2a74:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
    report_alarm_message(rt_exec);
    2a78:	8c 2f       	mov	r24, r28
    2a7a:	0e 94 6e 35 	call	0x6adc	; 0x6adc <report_alarm_message>
    // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
    if ((rt_exec == EXEC_ALARM_HARD_LIMIT) || (rt_exec == EXEC_ALARM_SOFT_LIMIT)) {
    2a7e:	c1 50       	subi	r28, 0x01	; 1
    2a80:	c2 30       	cpi	r28, 0x02	; 2
    2a82:	50 f4       	brcc	.+20     	; 0x2a98 <protocol_exec_rt_system+0x32>
      report_feedback_message(MESSAGE_CRITICAL_EVENT);
    2a84:	81 e0       	ldi	r24, 0x01	; 1
    2a86:	0e 94 9e 35 	call	0x6b3c	; 0x6b3c <report_feedback_message>
      system_clear_exec_state_flag(EXEC_RESET); // Disable any existing reset
    2a8a:	80 e1       	ldi	r24, 0x10	; 16
    2a8c:	0e 94 f7 3d 	call	0x7bee	; 0x7bee <system_clear_exec_state_flag>
        // Block everything, except reset and status reports, until user issues reset or power
        // cycles. Hard limits typically occur while unattended or not paying attention. Gives
        // the user and a GUI time to do what is needed before resetting, like killing the
        // incoming stream. The same could be said about soft limits. While the position is not
        // lost, continued streaming could cause a serious crash if by chance it gets executed.
      } while (bit_isfalse(sys_rt_exec_state,EXEC_RESET));
    2a90:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    2a94:	84 ff       	sbrs	r24, 4
    2a96:	fc cf       	rjmp	.-8      	; 0x2a90 <protocol_exec_rt_system+0x2a>
    }
    system_clear_exec_alarm(); // Clear alarm
    2a98:	0e 94 07 3e 	call	0x7c0e	; 0x7c0e <system_clear_exec_alarm>
  }

  rt_exec = sys_rt_exec_state; // Copy volatile sys_rt_exec_state.
    2a9c:	c0 91 31 0c 	lds	r28, 0x0C31	; 0x800c31 <sys_rt_exec_state>
  if (rt_exec) {
    2aa0:	cc 23       	and	r28, r28
    2aa2:	09 f4       	brne	.+2      	; 0x2aa6 <protocol_exec_rt_system+0x40>
    2aa4:	f4 c0       	rjmp	.+488    	; 0x2c8e <protocol_exec_rt_system+0x228>

    // Execute system abort.
    if (rt_exec & EXEC_RESET) {
    2aa6:	c4 ff       	sbrs	r28, 4
    2aa8:	04 c0       	rjmp	.+8      	; 0x2ab2 <protocol_exec_rt_system+0x4c>
      sys.abort = true;  // Only place this is set true.
    2aaa:	81 e0       	ldi	r24, 0x01	; 1
    2aac:	80 93 1f 0c 	sts	0x0C1F, r24	; 0x800c1f <sys+0x1>
      return; // Nothing else to do but exit.
    2ab0:	08 c2       	rjmp	.+1040   	; 0x2ec2 <protocol_exec_rt_system+0x45c>
    }

    // Execute and serial print status
    if (rt_exec & EXEC_STATUS_REPORT) {
    2ab2:	c0 ff       	sbrs	r28, 0
    2ab4:	05 c0       	rjmp	.+10     	; 0x2ac0 <protocol_exec_rt_system+0x5a>
      report_realtime_status();
    2ab6:	0e 94 5b 38 	call	0x70b6	; 0x70b6 <report_realtime_status>
      system_clear_exec_state_flag(EXEC_STATUS_REPORT);
    2aba:	81 e0       	ldi	r24, 0x01	; 1
    2abc:	0e 94 f7 3d 	call	0x7bee	; 0x7bee <system_clear_exec_state_flag>
    }

    // NOTE: Once hold is initiated, the system immediately enters a suspend state to block all
    // main program processes until either reset or resumed. This ensures a hold completes safely.
    if (rt_exec & (EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR | EXEC_SLEEP)) {
    2ac0:	8c 2f       	mov	r24, r28
    2ac2:	88 7e       	andi	r24, 0xE8	; 232
    2ac4:	09 f4       	brne	.+2      	; 0x2ac8 <protocol_exec_rt_system+0x62>
    2ac6:	63 c0       	rjmp	.+198    	; 0x2b8e <protocol_exec_rt_system+0x128>

      // State check for allowable states for hold methods.
      if (!(sys.state & (STATE_ALARM | STATE_CHECK_MODE))) {
    2ac8:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2acc:	98 2f       	mov	r25, r24
    2ace:	93 70       	andi	r25, 0x03	; 3
    2ad0:	09 f0       	breq	.+2      	; 0x2ad4 <protocol_exec_rt_system+0x6e>
    2ad2:	4c c0       	rjmp	.+152    	; 0x2b6c <protocol_exec_rt_system+0x106>
      
        // If in CYCLE or JOG states, immediately initiate a motion HOLD.
        if (sys.state & (STATE_CYCLE | STATE_JOG)) {
    2ad4:	88 72       	andi	r24, 0x28	; 40
    2ad6:	91 f0       	breq	.+36     	; 0x2afc <protocol_exec_rt_system+0x96>
          if (!(sys.suspend & (SUSPEND_MOTION_CANCEL | SUSPEND_JOG_CANCEL))) { // Block, if already holding.
    2ad8:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2adc:	80 7c       	andi	r24, 0xC0	; 192
    2ade:	71 f4       	brne	.+28     	; 0x2afc <protocol_exec_rt_system+0x96>
            st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
    2ae0:	bb d6       	rcall	.+3446   	; 0x3858 <st_update_plan_block_parameters>
            sys.step_control = STEP_CONTROL_EXECUTE_HOLD; // Initiate suspend state with active flag.
    2ae2:	ee e1       	ldi	r30, 0x1E	; 30
    2ae4:	fc e0       	ldi	r31, 0x0C	; 12
    2ae6:	82 e0       	ldi	r24, 0x02	; 2
    2ae8:	84 83       	std	Z+4, r24	; 0x04
            if (sys.state == STATE_JOG) { // Jog cancelled upon any hold event, except for sleeping.
    2aea:	80 81       	ld	r24, Z
    2aec:	80 32       	cpi	r24, 0x20	; 32
    2aee:	31 f4       	brne	.+12     	; 0x2afc <protocol_exec_rt_system+0x96>
              if (!(rt_exec & EXEC_SLEEP)) { sys.suspend |= SUSPEND_JOG_CANCEL; } 
    2af0:	cc 23       	and	r28, r28
    2af2:	bc f0       	brlt	.+46     	; 0x2b22 <protocol_exec_rt_system+0xbc>
    2af4:	92 81       	ldd	r25, Z+2	; 0x02
    2af6:	90 68       	ori	r25, 0x80	; 128
    2af8:	92 83       	std	Z+2, r25	; 0x02
    2afa:	13 c0       	rjmp	.+38     	; 0x2b22 <protocol_exec_rt_system+0xbc>
            }
          }
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend state and hold is complete.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_HOLD_COMPLETE; }
    2afc:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2b00:	81 11       	cpse	r24, r1
    2b02:	06 c0       	rjmp	.+12     	; 0x2b10 <protocol_exec_rt_system+0xaa>
    2b04:	91 e0       	ldi	r25, 0x01	; 1
    2b06:	90 93 20 0c 	sts	0x0C20, r25	; 0x800c20 <sys+0x2>

        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
    2b0a:	c6 fd       	sbrc	r28, 6
    2b0c:	05 c0       	rjmp	.+10     	; 0x2b18 <protocol_exec_rt_system+0xb2>
    2b0e:	d6 c1       	rjmp	.+940    	; 0x2ebc <protocol_exec_rt_system+0x456>
    2b10:	c6 ff       	sbrs	r28, 6
    2b12:	07 c0       	rjmp	.+14     	; 0x2b22 <protocol_exec_rt_system+0xbc>
          // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiated beforehand
          // to hold the CYCLE. Motion cancel is valid for a single planner block motion only, while jog cancel
          // will handle and clear multiple planner block motions.
          if (!(sys.state & STATE_JOG)) { sys.suspend |= SUSPEND_MOTION_CANCEL; } // NOTE: State is STATE_CYCLE.
    2b14:	85 fd       	sbrc	r24, 5
    2b16:	05 c0       	rjmp	.+10     	; 0x2b22 <protocol_exec_rt_system+0xbc>
    2b18:	ee e1       	ldi	r30, 0x1E	; 30
    2b1a:	fc e0       	ldi	r31, 0x0C	; 12
    2b1c:	92 81       	ldd	r25, Z+2	; 0x02
    2b1e:	90 64       	ori	r25, 0x40	; 64
    2b20:	92 83       	std	Z+2, r25	; 0x02
        }

        // Execute a feed hold with deceleration, if required. Then, suspend system.
        if (rt_exec & EXEC_FEED_HOLD) {
    2b22:	c3 ff       	sbrs	r28, 3
    2b24:	05 c0       	rjmp	.+10     	; 0x2b30 <protocol_exec_rt_system+0xca>
          // Block SAFETY_DOOR, JOG, and SLEEP states from changing to HOLD state.
          if (!(sys.state & (STATE_SAFETY_DOOR | STATE_JOG | STATE_SLEEP))) { sys.state = STATE_HOLD; }
    2b26:	80 7e       	andi	r24, 0xE0	; 224
    2b28:	19 f4       	brne	.+6      	; 0x2b30 <protocol_exec_rt_system+0xca>
    2b2a:	80 e1       	ldi	r24, 0x10	; 16
    2b2c:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
        }

        // Execute a safety door stop with a feed hold and disable spindle/coolant.
        // NOTE: Safety door differs from feed holds by stopping everything no matter state, disables powered
        // devices (spindle/coolant), and blocks resuming until switch is re-engaged.
        if (rt_exec & EXEC_SAFETY_DOOR) {
    2b30:	c5 ff       	sbrs	r28, 5
    2b32:	1c c0       	rjmp	.+56     	; 0x2b6c <protocol_exec_rt_system+0x106>
          report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR);
    2b34:	86 e0       	ldi	r24, 0x06	; 6
    2b36:	0e 94 9e 35 	call	0x6b3c	; 0x6b3c <report_feedback_message>
          // If jogging, block safety door methods until jog cancel is complete. Just flag that it happened.
          if (!(sys.suspend & SUSPEND_JOG_CANCEL)) {
    2b3a:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2b3e:	88 23       	and	r24, r24
    2b40:	84 f0       	brlt	.+32     	; 0x2b62 <protocol_exec_rt_system+0xfc>
            // Check if the safety re-opened during a restore parking motion only. Ignore if
            // already retracting, parked or in sleep state.
            if (sys.state == STATE_SAFETY_DOOR) {
    2b42:	90 91 1e 0c 	lds	r25, 0x0C1E	; 0x800c1e <sys>
    2b46:	90 34       	cpi	r25, 0x40	; 64
    2b48:	39 f4       	brne	.+14     	; 0x2b58 <protocol_exec_rt_system+0xf2>
              if (sys.suspend & SUSPEND_INITIATE_RESTORE) { // Actively restoring
    2b4a:	83 ff       	sbrs	r24, 3
    2b4c:	07 c0       	rjmp	.+14     	; 0x2b5c <protocol_exec_rt_system+0xf6>
                    sys.step_control = (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION);
                    sys.suspend &= ~(SUSPEND_HOLD_COMPLETE);
                  } // else NO_MOTION is active.
                #endif
                sys.suspend &= ~(SUSPEND_RETRACT_COMPLETE | SUSPEND_INITIATE_RESTORE | SUSPEND_RESTORE_COMPLETE);
                sys.suspend |= SUSPEND_RESTART_RETRACT;
    2b4e:	83 7e       	andi	r24, 0xE3	; 227
    2b50:	82 60       	ori	r24, 0x02	; 2
    2b52:	80 93 20 0c 	sts	0x0C20, r24	; 0x800c20 <sys+0x2>
    2b56:	02 c0       	rjmp	.+4      	; 0x2b5c <protocol_exec_rt_system+0xf6>
              }
            }
            if (sys.state != STATE_SLEEP) { sys.state = STATE_SAFETY_DOOR; }
    2b58:	90 38       	cpi	r25, 0x80	; 128
    2b5a:	19 f0       	breq	.+6      	; 0x2b62 <protocol_exec_rt_system+0xfc>
    2b5c:	80 e4       	ldi	r24, 0x40	; 64
    2b5e:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
          }
          // NOTE: This flag doesn't change when the door closes, unlike sys.state. Ensures any parking motions
          // are executed if the door switch closes and the state returns to HOLD.
          sys.suspend |= SUSPEND_SAFETY_DOOR_AJAR;
    2b62:	ee e1       	ldi	r30, 0x1E	; 30
    2b64:	fc e0       	ldi	r31, 0x0C	; 12
    2b66:	82 81       	ldd	r24, Z+2	; 0x02
    2b68:	80 62       	ori	r24, 0x20	; 32
    2b6a:	82 83       	std	Z+2, r24	; 0x02
        }
        
      }

      if (rt_exec & EXEC_SLEEP) {
    2b6c:	cc 23       	and	r28, r28
    2b6e:	64 f4       	brge	.+24     	; 0x2b88 <protocol_exec_rt_system+0x122>
        if (sys.state == STATE_ALARM) { sys.suspend |= (SUSPEND_RETRACT_COMPLETE|SUSPEND_HOLD_COMPLETE); }
    2b70:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2b74:	81 30       	cpi	r24, 0x01	; 1
    2b76:	29 f4       	brne	.+10     	; 0x2b82 <protocol_exec_rt_system+0x11c>
    2b78:	ee e1       	ldi	r30, 0x1E	; 30
    2b7a:	fc e0       	ldi	r31, 0x0C	; 12
    2b7c:	82 81       	ldd	r24, Z+2	; 0x02
    2b7e:	85 60       	ori	r24, 0x05	; 5
    2b80:	82 83       	std	Z+2, r24	; 0x02
        sys.state = STATE_SLEEP; 
    2b82:	80 e8       	ldi	r24, 0x80	; 128
    2b84:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
      }

      system_clear_exec_state_flag((EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR | EXEC_SLEEP));
    2b88:	88 ee       	ldi	r24, 0xE8	; 232
    2b8a:	0e 94 f7 3d 	call	0x7bee	; 0x7bee <system_clear_exec_state_flag>
    }

    // Execute a cycle start by starting the stepper interrupt to begin executing the blocks in queue.
    if (rt_exec & EXEC_CYCLE_START) {
    2b8e:	c1 ff       	sbrs	r28, 1
    2b90:	41 c0       	rjmp	.+130    	; 0x2c14 <protocol_exec_rt_system+0x1ae>
      // Block if called at same time as the hold commands: feed hold, motion cancel, and safety door.
      // Ensures auto-cycle-start doesn't resume a hold without an explicit user-input.
      if (!(rt_exec & (EXEC_FEED_HOLD | EXEC_MOTION_CANCEL | EXEC_SAFETY_DOOR))) {
    2b92:	8c 2f       	mov	r24, r28
    2b94:	88 76       	andi	r24, 0x68	; 104
    2b96:	d9 f5       	brne	.+118    	; 0x2c0e <protocol_exec_rt_system+0x1a8>
        // Resume door state when parking motion has retracted and door has been closed.
        if ((sys.state == STATE_SAFETY_DOOR) && !(sys.suspend & SUSPEND_SAFETY_DOOR_AJAR)) {
    2b98:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2b9c:	80 34       	cpi	r24, 0x40	; 64
    2b9e:	79 f4       	brne	.+30     	; 0x2bbe <protocol_exec_rt_system+0x158>
    2ba0:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2ba4:	85 fd       	sbrc	r24, 5
    2ba6:	33 c0       	rjmp	.+102    	; 0x2c0e <protocol_exec_rt_system+0x1a8>
          if (sys.suspend & SUSPEND_RESTORE_COMPLETE) {
    2ba8:	84 ff       	sbrs	r24, 4
    2baa:	03 c0       	rjmp	.+6      	; 0x2bb2 <protocol_exec_rt_system+0x14c>
            sys.state = STATE_IDLE; // Set to IDLE to immediately resume the cycle.
    2bac:	10 92 1e 0c 	sts	0x0C1E, r1	; 0x800c1e <sys>
    2bb0:	18 c0       	rjmp	.+48     	; 0x2be2 <protocol_exec_rt_system+0x17c>
          } else if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
    2bb2:	82 ff       	sbrs	r24, 2
    2bb4:	2c c0       	rjmp	.+88     	; 0x2c0e <protocol_exec_rt_system+0x1a8>
            // Flag to re-energize powered components and restore original position, if disabled by SAFETY_DOOR.
            // NOTE: For a safety door to resume, the switch must be closed, as indicated by HOLD state, and
            // the retraction execution is complete, which implies the initial feed hold is not active. To
            // restore normal operation, the restore procedures must be initiated by the following flag. Once,
            // they are complete, it will call CYCLE_START automatically to resume and exit the suspend.
            sys.suspend |= SUSPEND_INITIATE_RESTORE;
    2bb6:	88 60       	ori	r24, 0x08	; 8
    2bb8:	80 93 20 0c 	sts	0x0C20, r24	; 0x800c20 <sys+0x2>
    2bbc:	28 c0       	rjmp	.+80     	; 0x2c0e <protocol_exec_rt_system+0x1a8>
          }
        }
        // Cycle start only when IDLE or when a hold is complete and ready to resume.
        if ((sys.state == STATE_IDLE) || ((sys.state & STATE_HOLD) && (sys.suspend & SUSPEND_HOLD_COMPLETE))) {
    2bbe:	88 23       	and	r24, r24
    2bc0:	81 f0       	breq	.+32     	; 0x2be2 <protocol_exec_rt_system+0x17c>
    2bc2:	84 ff       	sbrs	r24, 4
    2bc4:	24 c0       	rjmp	.+72     	; 0x2c0e <protocol_exec_rt_system+0x1a8>
    2bc6:	90 91 20 0c 	lds	r25, 0x0C20	; 0x800c20 <sys+0x2>
    2bca:	90 ff       	sbrs	r25, 0
    2bcc:	20 c0       	rjmp	.+64     	; 0x2c0e <protocol_exec_rt_system+0x1a8>
          if (sys.state == STATE_HOLD && sys.spindle_stop_ovr) {
    2bce:	80 31       	cpi	r24, 0x10	; 16
    2bd0:	41 f4       	brne	.+16     	; 0x2be2 <protocol_exec_rt_system+0x17c>
    2bd2:	80 91 28 0c 	lds	r24, 0x0C28	; 0x800c28 <sys+0xa>
    2bd6:	88 23       	and	r24, r24
    2bd8:	21 f0       	breq	.+8      	; 0x2be2 <protocol_exec_rt_system+0x17c>
            sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE_CYCLE; // Set to restore in suspend routine and cycle start after.
    2bda:	88 60       	ori	r24, 0x08	; 8
    2bdc:	80 93 28 0c 	sts	0x0C28, r24	; 0x800c28 <sys+0xa>
    2be0:	16 c0       	rjmp	.+44     	; 0x2c0e <protocol_exec_rt_system+0x1a8>
          } else {
            // Start cycle only if queued motions exist in planner buffer and the motion is not canceled.
            sys.step_control = STEP_CONTROL_NORMAL_OP; // Restore step control to normal operation
    2be2:	10 92 22 0c 	sts	0x0C22, r1	; 0x800c22 <sys+0x4>
            if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
    2be6:	0e 94 85 29 	call	0x530a	; 0x530a <plan_get_current_block>
    2bea:	89 2b       	or	r24, r25
    2bec:	61 f0       	breq	.+24     	; 0x2c06 <protocol_exec_rt_system+0x1a0>
    2bee:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2bf2:	86 fd       	sbrc	r24, 6
    2bf4:	08 c0       	rjmp	.+16     	; 0x2c06 <protocol_exec_rt_system+0x1a0>
              sys.suspend = SUSPEND_DISABLE; // Break suspend state.
    2bf6:	ee e1       	ldi	r30, 0x1E	; 30
    2bf8:	fc e0       	ldi	r31, 0x0C	; 12
    2bfa:	12 82       	std	Z+2, r1	; 0x02
              sys.state = STATE_CYCLE;
    2bfc:	88 e0       	ldi	r24, 0x08	; 8
              st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
    2bfe:	80 83       	st	Z, r24
              st_wake_up();
    2c00:	4b d6       	rcall	.+3222   	; 0x3898 <st_prep_buffer>
    2c02:	3d d3       	rcall	.+1658   	; 0x327e <st_wake_up>
    2c04:	04 c0       	rjmp	.+8      	; 0x2c0e <protocol_exec_rt_system+0x1a8>
            } else { // Otherwise, do nothing. Set and resume IDLE state.
              sys.suspend = SUSPEND_DISABLE; // Break suspend state.
    2c06:	ee e1       	ldi	r30, 0x1E	; 30
    2c08:	fc e0       	ldi	r31, 0x0C	; 12
    2c0a:	12 82       	std	Z+2, r1	; 0x02
              sys.state = STATE_IDLE;
    2c0c:	10 82       	st	Z, r1
            }
          }
        }
      }
      system_clear_exec_state_flag(EXEC_CYCLE_START);
    2c0e:	82 e0       	ldi	r24, 0x02	; 2
    2c10:	0e 94 f7 3d 	call	0x7bee	; 0x7bee <system_clear_exec_state_flag>
    }

    if (rt_exec & EXEC_CYCLE_STOP) {
    2c14:	c2 ff       	sbrs	r28, 2
    2c16:	3b c0       	rjmp	.+118    	; 0x2c8e <protocol_exec_rt_system+0x228>
      // Reinitializes the cycle plan and stepper system after a feed hold for a resume. Called by
      // realtime command execution in the main program, ensuring that the planner re-plans safely.
      // NOTE: Bresenham algorithm variables are still maintained through both the planner and stepper
      // cycle reinitializations. The stepper path should continue exactly as if nothing has happened.
      // NOTE: EXEC_CYCLE_STOP is set by the stepper subsystem when a cycle or feed hold completes.
      if ((sys.state & (STATE_HOLD|STATE_SAFETY_DOOR|STATE_SLEEP)) && !(sys.soft_limit) && !(sys.suspend & SUSPEND_JOG_CANCEL)) {
    2c18:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2c1c:	80 7d       	andi	r24, 0xD0	; 208
    2c1e:	b9 f0       	breq	.+46     	; 0x2c4e <protocol_exec_rt_system+0x1e8>
    2c20:	80 91 21 0c 	lds	r24, 0x0C21	; 0x800c21 <sys+0x3>
    2c24:	81 11       	cpse	r24, r1
    2c26:	13 c0       	rjmp	.+38     	; 0x2c4e <protocol_exec_rt_system+0x1e8>
    2c28:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2c2c:	88 23       	and	r24, r24
    2c2e:	9c f0       	brlt	.+38     	; 0x2c56 <protocol_exec_rt_system+0x1f0>
        // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until user
        // has issued a resume command or reset.
        plan_cycle_reinitialize();
    2c30:	0e 94 25 2e 	call	0x5c4a	; 0x5c4a <plan_cycle_reinitialize>
        if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { sys.suspend |= SUSPEND_HOLD_COMPLETE; }
    2c34:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    2c38:	81 ff       	sbrs	r24, 1
    2c3a:	05 c0       	rjmp	.+10     	; 0x2c46 <protocol_exec_rt_system+0x1e0>
    2c3c:	ee e1       	ldi	r30, 0x1E	; 30
    2c3e:	fc e0       	ldi	r31, 0x0C	; 12
    2c40:	92 81       	ldd	r25, Z+2	; 0x02
    2c42:	91 60       	ori	r25, 0x01	; 1
    2c44:	92 83       	std	Z+2, r25	; 0x02
        bit_false(sys.step_control,(STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION));
    2c46:	89 7f       	andi	r24, 0xF9	; 249
    2c48:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <sys+0x4>
    2c4c:	1d c0       	rjmp	.+58     	; 0x2c88 <protocol_exec_rt_system+0x222>
      } else {
        // Motion complete. Includes CYCLE/JOG/HOMING states and jog cancel/motion cancel/soft limit events.
        // NOTE: Motion and jog cancel both immediately return to idle after the hold completes.
        if (sys.suspend & SUSPEND_JOG_CANCEL) {   // For jog cancel, flush buffers and sync positions.
    2c4e:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2c52:	88 23       	and	r24, r24
    2c54:	4c f4       	brge	.+18     	; 0x2c68 <protocol_exec_rt_system+0x202>
          sys.step_control = STEP_CONTROL_NORMAL_OP;
    2c56:	10 92 22 0c 	sts	0x0C22, r1	; 0x800c22 <sys+0x4>
          plan_reset();
    2c5a:	0e 94 5f 29 	call	0x52be	; 0x52be <plan_reset>
          st_reset();
    2c5e:	a9 d5       	rcall	.+2898   	; 0x37b2 <st_reset>
          gc_sync_position();
    2c60:	0e 94 59 07 	call	0xeb2	; 0xeb2 <gc_sync_position>
          plan_sync_position();
    2c64:	0e 94 07 2e 	call	0x5c0e	; 0x5c0e <plan_sync_position>
        }
        if (sys.suspend & SUSPEND_SAFETY_DOOR_AJAR) { // Only occurs when safety door opens during jog.
    2c68:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2c6c:	85 ff       	sbrs	r24, 5
    2c6e:	08 c0       	rjmp	.+16     	; 0x2c80 <protocol_exec_rt_system+0x21a>
          sys.suspend &= ~(SUSPEND_JOG_CANCEL);
          sys.suspend |= SUSPEND_HOLD_COMPLETE;
    2c70:	ee e1       	ldi	r30, 0x1E	; 30
    2c72:	fc e0       	ldi	r31, 0x0C	; 12
    2c74:	8f 77       	andi	r24, 0x7F	; 127
    2c76:	81 60       	ori	r24, 0x01	; 1
    2c78:	82 83       	std	Z+2, r24	; 0x02
          sys.state = STATE_SAFETY_DOOR;
    2c7a:	80 e4       	ldi	r24, 0x40	; 64
    2c7c:	80 83       	st	Z, r24
    2c7e:	04 c0       	rjmp	.+8      	; 0x2c88 <protocol_exec_rt_system+0x222>
        } else {
          sys.suspend = SUSPEND_DISABLE;
    2c80:	ee e1       	ldi	r30, 0x1E	; 30
    2c82:	fc e0       	ldi	r31, 0x0C	; 12
    2c84:	12 82       	std	Z+2, r1	; 0x02
          sys.state = STATE_IDLE;
    2c86:	10 82       	st	Z, r1
        }
      }
      system_clear_exec_state_flag(EXEC_CYCLE_STOP);
    2c88:	84 e0       	ldi	r24, 0x04	; 4
    2c8a:	0e 94 f7 3d 	call	0x7bee	; 0x7bee <system_clear_exec_state_flag>
    }
  }

  // Execute overrides.
  rt_exec = sys_rt_exec_motion_override; // Copy volatile sys_rt_exec_motion_override
    2c8e:	c0 91 19 0c 	lds	r28, 0x0C19	; 0x800c19 <sys_rt_exec_motion_override>
  if (rt_exec) {
    2c92:	cc 23       	and	r28, r28
    2c94:	81 f1       	breq	.+96     	; 0x2cf6 <protocol_exec_rt_system+0x290>
    system_clear_exec_motion_overrides(); // Clear all motion override flags.
    2c96:	0e 94 1f 3e 	call	0x7c3e	; 0x7c3e <system_clear_exec_motion_overrides>

    uint8_t new_f_override =  sys.f_override;
    2c9a:	20 91 25 0c 	lds	r18, 0x0C25	; 0x800c25 <sys+0x7>
    if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
    2c9e:	c0 ff       	sbrs	r28, 0
    2ca0:	02 c0       	rjmp	.+4      	; 0x2ca6 <protocol_exec_rt_system+0x240>
    2ca2:	84 e6       	ldi	r24, 0x64	; 100
    2ca4:	01 c0       	rjmp	.+2      	; 0x2ca8 <protocol_exec_rt_system+0x242>
  // Execute overrides.
  rt_exec = sys_rt_exec_motion_override; // Copy volatile sys_rt_exec_motion_override
  if (rt_exec) {
    system_clear_exec_motion_overrides(); // Clear all motion override flags.

    uint8_t new_f_override =  sys.f_override;
    2ca6:	82 2f       	mov	r24, r18
    if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
    if (rt_exec & EXEC_FEED_OVR_COARSE_PLUS) { new_f_override += FEED_OVERRIDE_COARSE_INCREMENT; }
    2ca8:	c1 fd       	sbrc	r28, 1
    2caa:	86 5f       	subi	r24, 0xF6	; 246
    if (rt_exec & EXEC_FEED_OVR_COARSE_MINUS) { new_f_override -= FEED_OVERRIDE_COARSE_INCREMENT; }
    2cac:	c2 fd       	sbrc	r28, 2
    2cae:	8a 50       	subi	r24, 0x0A	; 10
    if (rt_exec & EXEC_FEED_OVR_FINE_PLUS) { new_f_override += FEED_OVERRIDE_FINE_INCREMENT; }
    2cb0:	c3 fd       	sbrc	r28, 3
    2cb2:	8f 5f       	subi	r24, 0xFF	; 255
    if (rt_exec & EXEC_FEED_OVR_FINE_MINUS) { new_f_override -= FEED_OVERRIDE_FINE_INCREMENT; }
    2cb4:	c4 fd       	sbrc	r28, 4
    2cb6:	81 50       	subi	r24, 0x01	; 1
    new_f_override = min(new_f_override,MAX_FEED_RATE_OVERRIDE);
    2cb8:	89 3c       	cpi	r24, 0xC9	; 201
    2cba:	08 f0       	brcs	.+2      	; 0x2cbe <protocol_exec_rt_system+0x258>
    2cbc:	88 ec       	ldi	r24, 0xC8	; 200
    new_f_override = max(new_f_override,MIN_FEED_RATE_OVERRIDE);
    2cbe:	8a 30       	cpi	r24, 0x0A	; 10
    2cc0:	08 f4       	brcc	.+2      	; 0x2cc4 <protocol_exec_rt_system+0x25e>
    2cc2:	8a e0       	ldi	r24, 0x0A	; 10

    uint8_t new_r_override = sys.r_override;
    2cc4:	30 91 26 0c 	lds	r19, 0x0C26	; 0x800c26 <sys+0x8>
    if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
    2cc8:	c5 ff       	sbrs	r28, 5
    2cca:	02 c0       	rjmp	.+4      	; 0x2cd0 <protocol_exec_rt_system+0x26a>
    2ccc:	94 e6       	ldi	r25, 0x64	; 100
    2cce:	01 c0       	rjmp	.+2      	; 0x2cd2 <protocol_exec_rt_system+0x26c>
    if (rt_exec & EXEC_FEED_OVR_FINE_PLUS) { new_f_override += FEED_OVERRIDE_FINE_INCREMENT; }
    if (rt_exec & EXEC_FEED_OVR_FINE_MINUS) { new_f_override -= FEED_OVERRIDE_FINE_INCREMENT; }
    new_f_override = min(new_f_override,MAX_FEED_RATE_OVERRIDE);
    new_f_override = max(new_f_override,MIN_FEED_RATE_OVERRIDE);

    uint8_t new_r_override = sys.r_override;
    2cd0:	93 2f       	mov	r25, r19
    if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
    if (rt_exec & EXEC_RAPID_OVR_MEDIUM) { new_r_override = RAPID_OVERRIDE_MEDIUM; }
    2cd2:	c6 fd       	sbrc	r28, 6
    2cd4:	92 e3       	ldi	r25, 0x32	; 50
    if (rt_exec & EXEC_RAPID_OVR_LOW) { new_r_override = RAPID_OVERRIDE_LOW; }
    2cd6:	cc 23       	and	r28, r28
    2cd8:	0c f4       	brge	.+2      	; 0x2cdc <protocol_exec_rt_system+0x276>
    2cda:	99 e1       	ldi	r25, 0x19	; 25

    if ((new_f_override != sys.f_override) || (new_r_override != sys.r_override)) {
    2cdc:	28 13       	cpse	r18, r24
    2cde:	02 c0       	rjmp	.+4      	; 0x2ce4 <protocol_exec_rt_system+0x27e>
    2ce0:	93 17       	cp	r25, r19
    2ce2:	49 f0       	breq	.+18     	; 0x2cf6 <protocol_exec_rt_system+0x290>
      sys.f_override = new_f_override;
    2ce4:	ee e1       	ldi	r30, 0x1E	; 30
    2ce6:	fc e0       	ldi	r31, 0x0C	; 12
    2ce8:	87 83       	std	Z+7, r24	; 0x07
      sys.r_override = new_r_override;
    2cea:	90 87       	std	Z+8, r25	; 0x08
      sys.report_ovr_counter = 0; // Set to report change immediately
    2cec:	13 86       	std	Z+11, r1	; 0x0b
      plan_update_velocity_profile_parameters();
    2cee:	0e 94 33 2a 	call	0x5466	; 0x5466 <plan_update_velocity_profile_parameters>
      plan_cycle_reinitialize();
    2cf2:	0e 94 25 2e 	call	0x5c4a	; 0x5c4a <plan_cycle_reinitialize>
    }
  }

  rt_exec = sys_rt_exec_accessory_override;
    2cf6:	c0 91 30 0c 	lds	r28, 0x0C30	; 0x800c30 <sys_rt_exec_accessory_override>
  if (rt_exec) {
    2cfa:	cc 23       	and	r28, r28
    2cfc:	09 f4       	brne	.+2      	; 0x2d00 <protocol_exec_rt_system+0x29a>
    2cfe:	60 c0       	rjmp	.+192    	; 0x2dc0 <protocol_exec_rt_system+0x35a>
    system_clear_exec_accessory_overrides(); // Clear all accessory override flags.
    2d00:	0e 94 25 3e 	call	0x7c4a	; 0x7c4a <system_clear_exec_accessory_overrides>

    // NOTE: Unlike motion overrides, spindle overrides do not require a planner reinitialization.
    uint8_t last_s_override =  sys.spindle_speed_ovr;
    2d04:	90 91 27 0c 	lds	r25, 0x0C27	; 0x800c27 <sys+0x9>
    if (rt_exec & EXEC_SPINDLE_OVR_RESET) { last_s_override = DEFAULT_SPINDLE_SPEED_OVERRIDE; }
    2d08:	c0 ff       	sbrs	r28, 0
    2d0a:	02 c0       	rjmp	.+4      	; 0x2d10 <protocol_exec_rt_system+0x2aa>
    2d0c:	84 e6       	ldi	r24, 0x64	; 100
    2d0e:	01 c0       	rjmp	.+2      	; 0x2d12 <protocol_exec_rt_system+0x2ac>
  rt_exec = sys_rt_exec_accessory_override;
  if (rt_exec) {
    system_clear_exec_accessory_overrides(); // Clear all accessory override flags.

    // NOTE: Unlike motion overrides, spindle overrides do not require a planner reinitialization.
    uint8_t last_s_override =  sys.spindle_speed_ovr;
    2d10:	89 2f       	mov	r24, r25
    if (rt_exec & EXEC_SPINDLE_OVR_RESET) { last_s_override = DEFAULT_SPINDLE_SPEED_OVERRIDE; }
    if (rt_exec & EXEC_SPINDLE_OVR_COARSE_PLUS) { last_s_override += SPINDLE_OVERRIDE_COARSE_INCREMENT; }
    2d12:	c1 fd       	sbrc	r28, 1
    2d14:	86 5f       	subi	r24, 0xF6	; 246
    if (rt_exec & EXEC_SPINDLE_OVR_COARSE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_COARSE_INCREMENT; }
    2d16:	c2 fd       	sbrc	r28, 2
    2d18:	8a 50       	subi	r24, 0x0A	; 10
    if (rt_exec & EXEC_SPINDLE_OVR_FINE_PLUS) { last_s_override += SPINDLE_OVERRIDE_FINE_INCREMENT; }
    2d1a:	c3 fd       	sbrc	r28, 3
    2d1c:	8f 5f       	subi	r24, 0xFF	; 255
    if (rt_exec & EXEC_SPINDLE_OVR_FINE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_FINE_INCREMENT; }
    2d1e:	c4 fd       	sbrc	r28, 4
    2d20:	81 50       	subi	r24, 0x01	; 1
    last_s_override = min(last_s_override,MAX_SPINDLE_SPEED_OVERRIDE);
    2d22:	89 3c       	cpi	r24, 0xC9	; 201
    2d24:	08 f0       	brcs	.+2      	; 0x2d28 <protocol_exec_rt_system+0x2c2>
    2d26:	88 ec       	ldi	r24, 0xC8	; 200
    last_s_override = max(last_s_override,MIN_SPINDLE_SPEED_OVERRIDE);
    2d28:	8a 30       	cpi	r24, 0x0A	; 10
    2d2a:	08 f4       	brcc	.+2      	; 0x2d2e <protocol_exec_rt_system+0x2c8>
    2d2c:	8a e0       	ldi	r24, 0x0A	; 10

    if (last_s_override != sys.spindle_speed_ovr) {
    2d2e:	98 17       	cp	r25, r24
    2d30:	b1 f0       	breq	.+44     	; 0x2d5e <protocol_exec_rt_system+0x2f8>
      sys.spindle_speed_ovr = last_s_override;
    2d32:	ee e1       	ldi	r30, 0x1E	; 30
    2d34:	fc e0       	ldi	r31, 0x0C	; 12
    2d36:	81 87       	std	Z+9, r24	; 0x09
      // NOTE: Spindle speed overrides during HOLD state are taken care of by suspend function.
      if (sys.state == STATE_IDLE) { spindle_set_state(gc_state.modal.spindle, gc_state.spindle_speed); }
    2d38:	80 81       	ld	r24, Z
    2d3a:	81 11       	cpse	r24, r1
    2d3c:	09 c0       	rjmp	.+18     	; 0x2d50 <protocol_exec_rt_system+0x2ea>
    2d3e:	e6 e5       	ldi	r30, 0x56	; 86
    2d40:	fc e0       	ldi	r31, 0x0C	; 12
    2d42:	43 85       	ldd	r20, Z+11	; 0x0b
    2d44:	54 85       	ldd	r21, Z+12	; 0x0c
    2d46:	65 85       	ldd	r22, Z+13	; 0x0d
    2d48:	76 85       	ldd	r23, Z+14	; 0x0e
    2d4a:	81 85       	ldd	r24, Z+9	; 0x09
    2d4c:	ca dc       	rcall	.-1644   	; 0x26e2 <spindle_set_state>
    2d4e:	05 c0       	rjmp	.+10     	; 0x2d5a <protocol_exec_rt_system+0x2f4>
			else { bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM); }
    2d50:	ee e1       	ldi	r30, 0x1E	; 30
    2d52:	fc e0       	ldi	r31, 0x0C	; 12
    2d54:	84 81       	ldd	r24, Z+4	; 0x04
    2d56:	88 60       	ori	r24, 0x08	; 8
    2d58:	84 83       	std	Z+4, r24	; 0x04
      sys.report_ovr_counter = 0; // Set to report change immediately
    2d5a:	10 92 29 0c 	sts	0x0C29, r1	; 0x800c29 <sys+0xb>
    }

    if (rt_exec & EXEC_SPINDLE_OVR_STOP) {
    2d5e:	c5 ff       	sbrs	r28, 5
    2d60:	12 c0       	rjmp	.+36     	; 0x2d86 <protocol_exec_rt_system+0x320>
      // Spindle stop override allowed only while in HOLD state.
      // NOTE: Report counters are set in spindle_set_state() when spindle stop is executed.
      if (sys.state == STATE_HOLD) {
    2d62:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2d66:	80 31       	cpi	r24, 0x10	; 16
    2d68:	71 f4       	brne	.+28     	; 0x2d86 <protocol_exec_rt_system+0x320>
        if (!(sys.spindle_stop_ovr)) { sys.spindle_stop_ovr = SPINDLE_STOP_OVR_INITIATE; }
    2d6a:	80 91 28 0c 	lds	r24, 0x0C28	; 0x800c28 <sys+0xa>
    2d6e:	81 11       	cpse	r24, r1
    2d70:	04 c0       	rjmp	.+8      	; 0x2d7a <protocol_exec_rt_system+0x314>
    2d72:	82 e0       	ldi	r24, 0x02	; 2
    2d74:	80 93 28 0c 	sts	0x0C28, r24	; 0x800c28 <sys+0xa>
    2d78:	9c c0       	rjmp	.+312    	; 0x2eb2 <protocol_exec_rt_system+0x44c>
        else if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_ENABLED) { sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE; }
    2d7a:	80 ff       	sbrs	r24, 0
    2d7c:	9a c0       	rjmp	.+308    	; 0x2eb2 <protocol_exec_rt_system+0x44c>
    2d7e:	84 60       	ori	r24, 0x04	; 4
    2d80:	80 93 28 0c 	sts	0x0C28, r24	; 0x800c28 <sys+0xa>
    2d84:	96 c0       	rjmp	.+300    	; 0x2eb2 <protocol_exec_rt_system+0x44c>
    }

    // NOTE: Since coolant state always performs a planner sync whenever it changes, the current
    // run state can be determined by checking the parser state.
    // NOTE: Coolant overrides only operate during IDLE, CYCLE, HOLD, and JOG states. Ignored otherwise.																										
    if (rt_exec & (EXEC_COOLANT_FLOOD_OVR_TOGGLE | EXEC_COOLANT_MIST_OVR_TOGGLE)) {
    2d86:	8c 2f       	mov	r24, r28
    2d88:	80 7c       	andi	r24, 0xC0	; 192
    2d8a:	d1 f0       	breq	.+52     	; 0x2dc0 <protocol_exec_rt_system+0x35a>
      if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_JOG))) {
    2d8c:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2d90:	88 23       	and	r24, r24
    2d92:	11 f0       	breq	.+4      	; 0x2d98 <protocol_exec_rt_system+0x332>
    2d94:	88 73       	andi	r24, 0x38	; 56
    2d96:	a1 f0       	breq	.+40     	; 0x2dc0 <protocol_exec_rt_system+0x35a>
        uint8_t coolant_state = gc_state.modal.coolant;
    2d98:	d0 91 5e 0c 	lds	r29, 0x0C5E	; 0x800c5e <gc_state+0x8>
        if (rt_exec & EXEC_COOLANT_MIST_OVR_TOGGLE) {
    2d9c:	cc 23       	and	r28, r28
    2d9e:	2c f4       	brge	.+10     	; 0x2daa <protocol_exec_rt_system+0x344>
          if (coolant_state & COOLANT_MIST_ENABLE) { bit_false(coolant_state,COOLANT_MIST_ENABLE); }
    2da0:	dd 23       	and	r29, r29
    2da2:	14 f4       	brge	.+4      	; 0x2da8 <protocol_exec_rt_system+0x342>
    2da4:	df 77       	andi	r29, 0x7F	; 127
    2da6:	01 c0       	rjmp	.+2      	; 0x2daa <protocol_exec_rt_system+0x344>
          else { coolant_state |= COOLANT_MIST_ENABLE; }
    2da8:	d0 68       	ori	r29, 0x80	; 128
        }
        if (rt_exec & EXEC_COOLANT_FLOOD_OVR_TOGGLE) {
    2daa:	c6 ff       	sbrs	r28, 6
    2dac:	05 c0       	rjmp	.+10     	; 0x2db8 <protocol_exec_rt_system+0x352>
          if (coolant_state & COOLANT_FLOOD_ENABLE) { bit_false(coolant_state,COOLANT_FLOOD_ENABLE); }
    2dae:	d6 ff       	sbrs	r29, 6
    2db0:	02 c0       	rjmp	.+4      	; 0x2db6 <protocol_exec_rt_system+0x350>
    2db2:	df 7b       	andi	r29, 0xBF	; 191
          else { coolant_state |= COOLANT_FLOOD_ENABLE; }
    2db4:	01 c0       	rjmp	.+2      	; 0x2db8 <protocol_exec_rt_system+0x352>
        }
        coolant_set_state(coolant_state); // Report counter set in coolant_set_state().
    2db6:	d0 64       	ori	r29, 0x40	; 64
    2db8:	8d 2f       	mov	r24, r29
    2dba:	f3 dc       	rcall	.-1562   	; 0x27a2 <coolant_set_state>
        gc_state.modal.coolant = coolant_state;
    2dbc:	d0 93 5e 0c 	sts	0x0C5E, r29	; 0x800c5e <gc_state+0x8>
      }
    }
  }
  #ifdef LATHE		
  //processing spindle pulse and spindle synchronization pulse
   rt_exec = sys_sync_state;
    2dc0:	80 91 14 0c 	lds	r24, 0x0C14	; 0x800c14 <sys_sync_state>
   if (bit_istrue(rt_exec,EXEC_SPINDLE_SYNC)){
    2dc4:	81 ff       	sbrs	r24, 1
    2dc6:	19 c0       	rjmp	.+50     	; 0x2dfa <protocol_exec_rt_system+0x394>
	   sys_synchronization_pulse_count++;
    2dc8:	40 91 15 0c 	lds	r20, 0x0C15	; 0x800c15 <sys_synchronization_pulse_count>
    2dcc:	50 91 16 0c 	lds	r21, 0x0C16	; 0x800c16 <sys_synchronization_pulse_count+0x1>
    2dd0:	60 91 17 0c 	lds	r22, 0x0C17	; 0x800c17 <sys_synchronization_pulse_count+0x2>
    2dd4:	70 91 18 0c 	lds	r23, 0x0C18	; 0x800c18 <sys_synchronization_pulse_count+0x3>
    2dd8:	4f 5f       	subi	r20, 0xFF	; 255
    2dda:	5f 4f       	sbci	r21, 0xFF	; 255
    2ddc:	6f 4f       	sbci	r22, 0xFF	; 255
    2dde:	7f 4f       	sbci	r23, 0xFF	; 255
    2de0:	40 93 15 0c 	sts	0x0C15, r20	; 0x800c15 <sys_synchronization_pulse_count>
    2de4:	50 93 16 0c 	sts	0x0C16, r21	; 0x800c16 <sys_synchronization_pulse_count+0x1>
    2de8:	60 93 17 0c 	sts	0x0C17, r22	; 0x800c17 <sys_synchronization_pulse_count+0x2>
    2dec:	70 93 18 0c 	sts	0x0C18, r23	; 0x800c18 <sys_synchronization_pulse_count+0x3>
	   bit_false(sys_sync_state,EXEC_SPINDLE_SYNC);
    2df0:	90 91 14 0c 	lds	r25, 0x0C14	; 0x800c14 <sys_sync_state>
    2df4:	9d 7f       	andi	r25, 0xFD	; 253
    2df6:	90 93 14 0c 	sts	0x0C14, r25	; 0x800c14 <sys_sync_state>
	   //report_synchronization_state();
   }
   if (bit_istrue(rt_exec,EXEC_SPINDLE_INDEX)){
    2dfa:	80 ff       	sbrs	r24, 0
    2dfc:	4c c0       	rjmp	.+152    	; 0x2e96 <protocol_exec_rt_system+0x430>
	   sys_index_pulse_count++;
    2dfe:	80 91 55 0c 	lds	r24, 0x0C55	; 0x800c55 <sys_index_pulse_count>
    2e02:	8f 5f       	subi	r24, 0xFF	; 255
    2e04:	80 93 55 0c 	sts	0x0C55, r24	; 0x800c55 <sys_index_pulse_count>
	   sys_sync_time=get_timer_ticks();
    2e08:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <get_timer_ticks>
    2e0c:	60 93 4f 0c 	sts	0x0C4F, r22	; 0x800c4f <sys_sync_time>
    2e10:	70 93 50 0c 	sts	0x0C50, r23	; 0x800c50 <sys_sync_time+0x1>
    2e14:	80 93 51 0c 	sts	0x0C51, r24	; 0x800c51 <sys_sync_time+0x2>
    2e18:	90 93 52 0c 	sts	0x0C52, r25	; 0x800c52 <sys_sync_time+0x3>
	   bit_false(sys_sync_state,EXEC_SPINDLE_INDEX);
    2e1c:	80 91 14 0c 	lds	r24, 0x0C14	; 0x800c14 <sys_sync_state>
    2e20:	8e 7f       	andi	r24, 0xFE	; 254
    2e22:	80 93 14 0c 	sts	0x0C14, r24	; 0x800c14 <sys_sync_state>
	   sys_sync_time=get_timer_ticks();
    2e26:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <get_timer_ticks>
    2e2a:	60 93 4f 0c 	sts	0x0C4F, r22	; 0x800c4f <sys_sync_time>
    2e2e:	70 93 50 0c 	sts	0x0C50, r23	; 0x800c50 <sys_sync_time+0x1>
    2e32:	80 93 51 0c 	sts	0x0C51, r24	; 0x800c51 <sys_sync_time+0x2>
    2e36:	90 93 52 0c 	sts	0x0C52, r25	; 0x800c52 <sys_sync_time+0x3>
	   sys_sync_time_passed=sys_sync_Last_time-sys_sync_time;
    2e3a:	80 91 33 0c 	lds	r24, 0x0C33	; 0x800c33 <sys_sync_Last_time>
    2e3e:	90 91 34 0c 	lds	r25, 0x0C34	; 0x800c34 <sys_sync_Last_time+0x1>
    2e42:	a0 91 35 0c 	lds	r26, 0x0C35	; 0x800c35 <sys_sync_Last_time+0x2>
    2e46:	b0 91 36 0c 	lds	r27, 0x0C36	; 0x800c36 <sys_sync_Last_time+0x3>
    2e4a:	40 91 4f 0c 	lds	r20, 0x0C4F	; 0x800c4f <sys_sync_time>
    2e4e:	50 91 50 0c 	lds	r21, 0x0C50	; 0x800c50 <sys_sync_time+0x1>
    2e52:	60 91 51 0c 	lds	r22, 0x0C51	; 0x800c51 <sys_sync_time+0x2>
    2e56:	70 91 52 0c 	lds	r23, 0x0C52	; 0x800c52 <sys_sync_time+0x3>
    2e5a:	84 1b       	sub	r24, r20
    2e5c:	95 0b       	sbc	r25, r21
    2e5e:	a6 0b       	sbc	r26, r22
    2e60:	b7 0b       	sbc	r27, r23
    2e62:	80 93 1a 0c 	sts	0x0C1A, r24	; 0x800c1a <sys_sync_time_passed>
    2e66:	90 93 1b 0c 	sts	0x0C1B, r25	; 0x800c1b <sys_sync_time_passed+0x1>
    2e6a:	a0 93 1c 0c 	sts	0x0C1C, r26	; 0x800c1c <sys_sync_time_passed+0x2>
    2e6e:	b0 93 1d 0c 	sts	0x0C1D, r27	; 0x800c1d <sys_sync_time_passed+0x3>
	   sys_sync_Last_time=sys_sync_time;
    2e72:	80 91 4f 0c 	lds	r24, 0x0C4F	; 0x800c4f <sys_sync_time>
    2e76:	90 91 50 0c 	lds	r25, 0x0C50	; 0x800c50 <sys_sync_time+0x1>
    2e7a:	a0 91 51 0c 	lds	r26, 0x0C51	; 0x800c51 <sys_sync_time+0x2>
    2e7e:	b0 91 52 0c 	lds	r27, 0x0C52	; 0x800c52 <sys_sync_time+0x3>
    2e82:	80 93 33 0c 	sts	0x0C33, r24	; 0x800c33 <sys_sync_Last_time>
    2e86:	90 93 34 0c 	sts	0x0C34, r25	; 0x800c34 <sys_sync_Last_time+0x1>
    2e8a:	a0 93 35 0c 	sts	0x0C35, r26	; 0x800c35 <sys_sync_Last_time+0x2>
    2e8e:	b0 93 36 0c 	sts	0x0C36, r27	; 0x800c36 <sys_sync_Last_time+0x3>
	   report_synchronization_state();					//report on every index pulse
    2e92:	0e 94 7b 35 	call	0x6af6	; 0x6af6 <report_synchronization_state>
   }   
  #endif
  
  #ifdef DEBUG
    if (sys_rt_exec_debug) {
    2e96:	80 91 54 0c 	lds	r24, 0x0C54	; 0x800c54 <sys_rt_exec_debug>
    2e9a:	88 23       	and	r24, r24
    2e9c:	21 f0       	breq	.+8      	; 0x2ea6 <protocol_exec_rt_system+0x440>
      report_realtime_debug();
    2e9e:	0e 94 5d 3a 	call	0x74ba	; 0x74ba <report_realtime_debug>
      sys_rt_exec_debug = 0;
    2ea2:	10 92 54 0c 	sts	0x0C54, r1	; 0x800c54 <sys_rt_exec_debug>
    }
  #endif

  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_SAFETY_DOOR | STATE_HOMING | STATE_SLEEP| STATE_JOG)) {
    2ea6:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2eaa:	8c 7f       	andi	r24, 0xFC	; 252
    st_prep_buffer();
    2eac:	51 f0       	breq	.+20     	; 0x2ec2 <protocol_exec_rt_system+0x45c>
    2eae:	f4 d4       	rcall	.+2536   	; 0x3898 <st_prep_buffer>
    2eb0:	08 c0       	rjmp	.+16     	; 0x2ec2 <protocol_exec_rt_system+0x45c>
    }

    // NOTE: Since coolant state always performs a planner sync whenever it changes, the current
    // run state can be determined by checking the parser state.
    // NOTE: Coolant overrides only operate during IDLE, CYCLE, HOLD, and JOG states. Ignored otherwise.																										
    if (rt_exec & (EXEC_COOLANT_FLOOD_OVR_TOGGLE | EXEC_COOLANT_MIST_OVR_TOGGLE)) {
    2eb2:	8c 2f       	mov	r24, r28
    2eb4:	80 7c       	andi	r24, 0xC0	; 192
    2eb6:	09 f0       	breq	.+2      	; 0x2eba <protocol_exec_rt_system+0x454>
    2eb8:	6f cf       	rjmp	.-290    	; 0x2d98 <protocol_exec_rt_system+0x332>
    2eba:	82 cf       	rjmp	.-252    	; 0x2dc0 <protocol_exec_rt_system+0x35a>
          // will handle and clear multiple planner block motions.
          if (!(sys.state & STATE_JOG)) { sys.suspend |= SUSPEND_MOTION_CANCEL; } // NOTE: State is STATE_CYCLE.
        }

        // Execute a feed hold with deceleration, if required. Then, suspend system.
        if (rt_exec & EXEC_FEED_HOLD) {
    2ebc:	c3 fd       	sbrc	r28, 3
    2ebe:	35 ce       	rjmp	.-918    	; 0x2b2a <protocol_exec_rt_system+0xc4>
    2ec0:	37 ce       	rjmp	.-914    	; 0x2b30 <protocol_exec_rt_system+0xca>
  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_SAFETY_DOOR | STATE_HOMING | STATE_SLEEP| STATE_JOG)) {
    st_prep_buffer();
  }

}
    2ec2:	df 91       	pop	r29
    2ec4:	cf 91       	pop	r28
    2ec6:	08 95       	ret

00002ec8 <protocol_execute_realtime>:
// also provides a controlled way to execute certain tasks without having two or more instances of
// the same task, such as the planner recalculating the buffer upon a feedhold or overrides.
// NOTE: The sys_rt_exec_state variable flags are set by any process, step or serial interrupts, pinouts,
// limit switches, or the main program.
void protocol_execute_realtime()
{
    2ec8:	7f 92       	push	r7
    2eca:	8f 92       	push	r8
    2ecc:	9f 92       	push	r9
    2ece:	af 92       	push	r10
    2ed0:	bf 92       	push	r11
    2ed2:	cf 92       	push	r12
    2ed4:	df 92       	push	r13
    2ed6:	ef 92       	push	r14
    2ed8:	ff 92       	push	r15
    2eda:	0f 93       	push	r16
    2edc:	1f 93       	push	r17
    2ede:	cf 93       	push	r28
    2ee0:	df 93       	push	r29
  protocol_exec_rt_system();
    2ee2:	c1 dd       	rcall	.-1150   	; 0x2a66 <protocol_exec_rt_system>
  if (sys.suspend) { protocol_exec_rt_suspend(); }
    2ee4:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2ee8:	88 23       	and	r24, r24
    2eea:	09 f4       	brne	.+2      	; 0x2eee <protocol_execute_realtime+0x26>
    2eec:	f4 c0       	rjmp	.+488    	; 0x30d6 <protocol_execute_realtime+0x20e>
    memset(pl_data,0,sizeof(plan_line_data_t));
    pl_data->condition = (PL_COND_FLAG_SYSTEM_MOTION|PL_COND_FLAG_NO_FEED_OVERRIDE);
    pl_data->line_number = PARKING_MOTION_LINE_NUMBER;
  #endif

  plan_block_t *block = plan_get_current_block();
    2eee:	0e 94 85 29 	call	0x530a	; 0x530a <plan_get_current_block>
    2ef2:	ec 01       	movw	r28, r24
  uint8_t restore_condition;
  float restore_spindle_speed;
  if (block == NULL) {
    2ef4:	89 2b       	or	r24, r25
    2ef6:	51 f4       	brne	.+20     	; 0x2f0c <protocol_execute_realtime+0x44>
    restore_condition = (gc_state.modal.spindle | gc_state.modal.coolant);
    2ef8:	e6 e5       	ldi	r30, 0x56	; 86
    2efa:	fc e0       	ldi	r31, 0x0C	; 12
    2efc:	d1 84       	ldd	r13, Z+9	; 0x09
    2efe:	80 85       	ldd	r24, Z+8	; 0x08
    2f00:	d8 2a       	or	r13, r24
    restore_spindle_speed = gc_state.spindle_speed;
    2f02:	83 84       	ldd	r8, Z+11	; 0x0b
    2f04:	94 84       	ldd	r9, Z+12	; 0x0c
    2f06:	a5 84       	ldd	r10, Z+13	; 0x0d
    2f08:	b6 84       	ldd	r11, Z+14	; 0x0e
    2f0a:	0a c0       	rjmp	.+20     	; 0x2f20 <protocol_execute_realtime+0x58>
  } else {
    restore_condition = (block->condition & PL_COND_SPINDLE_MASK) | coolant_get_state();
    2f0c:	89 89       	ldd	r24, Y+17	; 0x11
    2f0e:	18 2f       	mov	r17, r24
    2f10:	10 73       	andi	r17, 0x30	; 48
    2f12:	28 dc       	rcall	.-1968   	; 0x2764 <coolant_get_state>
    2f14:	d8 2e       	mov	r13, r24
    2f16:	d1 2a       	or	r13, r17
    restore_spindle_speed = block->spindle_speed;
    2f18:	8a a8       	ldd	r8, Y+50	; 0x32
    2f1a:	9b a8       	ldd	r9, Y+51	; 0x33
    2f1c:	ac a8       	ldd	r10, Y+52	; 0x34
    2f1e:	bd a8       	ldd	r11, Y+53	; 0x35
  }
  #ifdef DISABLE_LASER_DURING_HOLD
    if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) { 
    2f20:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    2f24:	81 ff       	sbrs	r24, 1
    2f26:	03 c0       	rjmp	.+6      	; 0x2f2e <protocol_execute_realtime+0x66>
      system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP);
    2f28:	80 e2       	ldi	r24, 0x20	; 32
    2f2a:	0e 94 16 3e 	call	0x7c2c	; 0x7c2c <system_set_exec_accessory_override_flag>
    }
  #endif

  while (sys.suspend) {
    2f2e:	90 91 20 0c 	lds	r25, 0x0C20	; 0x800c20 <sys+0x2>
    2f32:	99 23       	and	r25, r25
    2f34:	09 f4       	brne	.+2      	; 0x2f38 <protocol_execute_realtime+0x70>
    2f36:	cf c0       	rjmp	.+414    	; 0x30d6 <protocol_execute_realtime+0x20e>

    if (sys.abort) { return; }
    2f38:	80 91 1f 0c 	lds	r24, 0x0C1F	; 0x800c1f <sys+0x1>
    2f3c:	81 11       	cpse	r24, r1
    2f3e:	cb c0       	rjmp	.+406    	; 0x30d6 <protocol_execute_realtime+0x20e>
    // Block until initial hold is complete and the machine has stopped motion.
    if (sys.suspend & SUSPEND_HOLD_COMPLETE) {

      // Parking manager. Handles de/re-energizing, switch state checks, and parking motions for 
      // the safety door and sleep states.
      if (sys.state & (STATE_SAFETY_DOOR | STATE_SLEEP)) {
    2f40:	ce e1       	ldi	r28, 0x1E	; 30
    2f42:	dc e0       	ldi	r29, 0x0C	; 12
          }
        } else {
          // Handles spindle state during hold. NOTE: Spindle speed overrides may be altered during hold state.
          // NOTE: STEP_CONTROL_UPDATE_SPINDLE_PWM is automatically reset upon resume in step generator.
          if (bit_istrue(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
            spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    2f44:	8d 2d       	mov	r24, r13
    2f46:	80 73       	andi	r24, 0x30	; 48
    2f48:	c8 2e       	mov	r12, r24
            } else {
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
            }
          // Handles restoring of spindle state
          } else if (sys.spindle_stop_ovr & (SPINDLE_STOP_OVR_RESTORE | SPINDLE_STOP_OVR_RESTORE_CYCLE)) {
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    2f4a:	06 e5       	ldi	r16, 0x56	; 86
    2f4c:	1c e0       	ldi	r17, 0x0C	; 12
              report_feedback_message(MESSAGE_SPINDLE_RESTORE);
              if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    2f4e:	0f 2e       	mov	r0, r31
    2f50:	f5 e1       	ldi	r31, 0x15	; 21
    2f52:	ef 2e       	mov	r14, r31
    2f54:	ff e0       	ldi	r31, 0x0F	; 15
    2f56:	ff 2e       	mov	r15, r31
    2f58:	f0 2d       	mov	r31, r0
        if (sys.spindle_stop_ovr) {
          // Handles beginning of spindle stop
          if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_INITIATE) {
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
              spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_ENABLED; // Set stop override state to enabled, if de-energized.
    2f5a:	77 24       	eor	r7, r7
    2f5c:	73 94       	inc	r7
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
                // NOTE: Laser mode will honor this delay. An exhaust system is often controlled by this pin.
                coolant_set_state((restore_condition & (PL_COND_FLAG_COOLANT_FLOOD | PL_COND_FLAG_COOLANT_MIST)));
    2f5e:	ed 2d       	mov	r30, r13
    2f60:	e0 7c       	andi	r30, 0xC0	; 192
    2f62:	de 2e       	mov	r13, r30
    2f64:	03 c0       	rjmp	.+6      	; 0x2f6c <protocol_execute_realtime+0xa4>
    }
  #endif

  while (sys.suspend) {

    if (sys.abort) { return; }
    2f66:	29 81       	ldd	r18, Y+1	; 0x01
    2f68:	21 11       	cpse	r18, r1
    2f6a:	b5 c0       	rjmp	.+362    	; 0x30d6 <protocol_execute_realtime+0x20e>

    // Block until initial hold is complete and the machine has stopped motion.
    if (sys.suspend & SUSPEND_HOLD_COMPLETE) {
    2f6c:	90 ff       	sbrs	r25, 0
    2f6e:	a7 c0       	rjmp	.+334    	; 0x30be <protocol_execute_realtime+0x1f6>

      // Parking manager. Handles de/re-energizing, switch state checks, and parking motions for 
      // the safety door and sleep states.
      if (sys.state & (STATE_SAFETY_DOOR | STATE_SLEEP)) {
    2f70:	28 81       	ld	r18, Y
    2f72:	32 2f       	mov	r19, r18
    2f74:	30 7c       	andi	r19, 0xC0	; 192
    2f76:	09 f4       	brne	.+2      	; 0x2f7a <protocol_execute_realtime+0xb2>
    2f78:	69 c0       	rjmp	.+210    	; 0x304c <protocol_execute_realtime+0x184>
      
        // Handles retraction motions and de-energizing.
        if (bit_isfalse(sys.suspend,SUSPEND_RETRACT_COMPLETE)) {
    2f7a:	92 fd       	sbrc	r25, 2
    2f7c:	0d c0       	rjmp	.+26     	; 0x2f98 <protocol_execute_realtime+0xd0>

          // Ensure any prior spindle stop override is disabled at start of safety door routine.
          sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED;
    2f7e:	1a 86       	std	Y+10, r1	; 0x0a

          #ifndef PARKING_ENABLE

            spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
    2f80:	40 e0       	ldi	r20, 0x00	; 0
    2f82:	50 e0       	ldi	r21, 0x00	; 0
    2f84:	ba 01       	movw	r22, r20
    2f86:	80 e0       	ldi	r24, 0x00	; 0
            coolant_set_state(COOLANT_DISABLE);     // De-energize
    2f88:	ac db       	rcall	.-2216   	; 0x26e2 <spindle_set_state>
    2f8a:	80 e0       	ldi	r24, 0x00	; 0
    2f8c:	0a dc       	rcall	.-2028   	; 0x27a2 <coolant_set_state>
            }

          #endif

          sys.suspend &= ~(SUSPEND_RESTART_RETRACT);
          sys.suspend |= SUSPEND_RETRACT_COMPLETE;
    2f8e:	8a 81       	ldd	r24, Y+2	; 0x02
    2f90:	8d 7f       	andi	r24, 0xFD	; 253
    2f92:	84 60       	ori	r24, 0x04	; 4
    2f94:	8a 83       	std	Y+2, r24	; 0x02
    2f96:	93 c0       	rjmp	.+294    	; 0x30be <protocol_execute_realtime+0x1f6>

        } else {

          
          if (sys.state == STATE_SLEEP) {
    2f98:	20 38       	cpi	r18, 0x80	; 128
    2f9a:	b1 f4       	brne	.+44     	; 0x2fc8 <protocol_execute_realtime+0x100>
            report_feedback_message(MESSAGE_SLEEP_MODE);
    2f9c:	8b e0       	ldi	r24, 0x0B	; 11
    2f9e:	0e 94 9e 35 	call	0x6b3c	; 0x6b3c <report_feedback_message>
            // Spindle and coolant should already be stopped, but do it again just to be sure.
            spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
    2fa2:	40 e0       	ldi	r20, 0x00	; 0
    2fa4:	50 e0       	ldi	r21, 0x00	; 0
    2fa6:	ba 01       	movw	r22, r20
            coolant_set_state(COOLANT_DISABLE); // De-energize
    2fa8:	80 e0       	ldi	r24, 0x00	; 0
    2faa:	9b db       	rcall	.-2250   	; 0x26e2 <spindle_set_state>
    2fac:	80 e0       	ldi	r24, 0x00	; 0
            st_go_idle(); // Disable steppers
    2fae:	f9 db       	rcall	.-2062   	; 0x27a2 <coolant_set_state>
            while (!(sys.abort)) { protocol_exec_rt_system(); } // Do nothing until reset.
    2fb0:	7e d1       	rcall	.+764    	; 0x32ae <st_go_idle>
    2fb2:	80 91 1f 0c 	lds	r24, 0x0C1F	; 0x800c1f <sys+0x1>
    2fb6:	81 11       	cpse	r24, r1
    2fb8:	8e c0       	rjmp	.+284    	; 0x30d6 <protocol_execute_realtime+0x20e>
    2fba:	ce e1       	ldi	r28, 0x1E	; 30
    2fbc:	dc e0       	ldi	r29, 0x0C	; 12
    2fbe:	53 dd       	rcall	.-1370   	; 0x2a66 <protocol_exec_rt_system>
    2fc0:	89 81       	ldd	r24, Y+1	; 0x01
    2fc2:	88 23       	and	r24, r24
    2fc4:	e1 f3       	breq	.-8      	; 0x2fbe <protocol_execute_realtime+0xf6>
    2fc6:	87 c0       	rjmp	.+270    	; 0x30d6 <protocol_execute_realtime+0x20e>
            return; // Abort received. Return to re-initialize.
          }    
          
          // Allows resuming from parking/safety door. Actively checks if safety door is closed and ready to resume.
          if (sys.state == STATE_SAFETY_DOOR) {
    2fc8:	20 34       	cpi	r18, 0x40	; 64
    2fca:	39 f4       	brne	.+14     	; 0x2fda <protocol_execute_realtime+0x112>
            if (!(system_check_safety_door_ajar())) {
    2fcc:	0e 94 d6 3a 	call	0x75ac	; 0x75ac <system_check_safety_door_ajar>
    2fd0:	81 11       	cpse	r24, r1
    2fd2:	03 c0       	rjmp	.+6      	; 0x2fda <protocol_execute_realtime+0x112>
              sys.suspend &= ~(SUSPEND_SAFETY_DOOR_AJAR); // Reset door ajar flag to denote ready to resume.
    2fd4:	8a 81       	ldd	r24, Y+2	; 0x02
    2fd6:	8f 7d       	andi	r24, 0xDF	; 223
    2fd8:	8a 83       	std	Y+2, r24	; 0x02
            }
          }

          // Handles parking restore and safety door resume.
          if (sys.suspend & SUSPEND_INITIATE_RESTORE) {
    2fda:	8a 81       	ldd	r24, Y+2	; 0x02
    2fdc:	83 ff       	sbrs	r24, 3
    2fde:	6f c0       	rjmp	.+222    	; 0x30be <protocol_execute_realtime+0x1f6>
                }
              }
            #endif

            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    2fe0:	f8 01       	movw	r30, r16
    2fe2:	91 85       	ldd	r25, Z+9	; 0x09
    2fe4:	99 23       	and	r25, r25
    2fe6:	c9 f0       	breq	.+50     	; 0x301a <protocol_execute_realtime+0x152>
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    2fe8:	81 fd       	sbrc	r24, 1
    2fea:	6e c0       	rjmp	.+220    	; 0x30c8 <protocol_execute_realtime+0x200>
                if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    2fec:	f7 01       	movw	r30, r14
    2fee:	80 81       	ld	r24, Z
    2ff0:	81 ff       	sbrs	r24, 1
    2ff2:	08 c0       	rjmp	.+16     	; 0x3004 <protocol_execute_realtime+0x13c>
                  // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                  bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    2ff4:	8c 81       	ldd	r24, Y+4	; 0x04
    2ff6:	88 60       	ori	r24, 0x08	; 8
    2ff8:	8c 83       	std	Y+4, r24	; 0x04
                  spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
                  delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
                }
              }
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
    2ffa:	f8 01       	movw	r30, r16
    2ffc:	80 85       	ldd	r24, Z+8	; 0x08
    2ffe:	81 11       	cpse	r24, r1
    3000:	13 c0       	rjmp	.+38     	; 0x3028 <protocol_execute_realtime+0x160>
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
                if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
                  // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                  bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
                } else {
                  spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    3002:	67 c0       	rjmp	.+206    	; 0x30d2 <protocol_execute_realtime+0x20a>
    3004:	b5 01       	movw	r22, r10
    3006:	a4 01       	movw	r20, r8
    3008:	8c 2d       	mov	r24, r12
    300a:	6b db       	rcall	.-2346   	; 0x26e2 <spindle_set_state>
                  delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
    300c:	47 2d       	mov	r20, r7
    300e:	60 e0       	ldi	r22, 0x00	; 0
    3010:	70 e0       	ldi	r23, 0x00	; 0
    3012:	80 e8       	ldi	r24, 0x80	; 128
    3014:	90 e4       	ldi	r25, 0x40	; 64
    3016:	0e 94 f3 2e 	call	0x5de6	; 0x5de6 <delay_sec>
                }
              }
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
    301a:	f8 01       	movw	r30, r16
    301c:	80 85       	ldd	r24, Z+8	; 0x08
    301e:	88 23       	and	r24, r24
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    3020:	61 f0       	breq	.+24     	; 0x303a <protocol_execute_realtime+0x172>
    3022:	8a 81       	ldd	r24, Y+2	; 0x02
    3024:	81 fd       	sbrc	r24, 1
                // NOTE: Laser mode will honor this delay. An exhaust system is often controlled by this pin.
                coolant_set_state((restore_condition & (PL_COND_FLAG_COOLANT_FLOOD | PL_COND_FLAG_COOLANT_MIST)));
    3026:	4b c0       	rjmp	.+150    	; 0x30be <protocol_execute_realtime+0x1f6>
    3028:	8d 2d       	mov	r24, r13
    302a:	bb db       	rcall	.-2186   	; 0x27a2 <coolant_set_state>
                delay_sec(SAFETY_DOOR_COOLANT_DELAY, DELAY_MODE_SYS_SUSPEND);
    302c:	47 2d       	mov	r20, r7
    302e:	60 e0       	ldi	r22, 0x00	; 0
    3030:	70 e0       	ldi	r23, 0x00	; 0
    3032:	80 e8       	ldi	r24, 0x80	; 128
    3034:	9f e3       	ldi	r25, 0x3F	; 63
    3036:	0e 94 f3 2e 	call	0x5de6	; 0x5de6 <delay_sec>
                  mc_parking_motion(restore_target, pl_data);
                }
              }
            #endif

            if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    303a:	8a 81       	ldd	r24, Y+2	; 0x02
    303c:	81 fd       	sbrc	r24, 1
    303e:	3f c0       	rjmp	.+126    	; 0x30be <protocol_execute_realtime+0x1f6>
              sys.suspend |= SUSPEND_RESTORE_COMPLETE;
    3040:	80 61       	ori	r24, 0x10	; 16
    3042:	8a 83       	std	Y+2, r24	; 0x02
              system_set_exec_state_flag(EXEC_CYCLE_START); // Set to resume program.
    3044:	82 e0       	ldi	r24, 0x02	; 2
    3046:	0e 94 99 3b 	call	0x7732	; 0x7732 <system_set_exec_state_flag>
    304a:	39 c0       	rjmp	.+114    	; 0x30be <protocol_execute_realtime+0x1f6>

      } else {

        // Feed hold manager. Controls spindle stop override states.
        // NOTE: Hold ensured as completed by condition check at the beginning of suspend routine.
        if (sys.spindle_stop_ovr) {
    304c:	9a 85       	ldd	r25, Y+10	; 0x0a
    304e:	99 23       	and	r25, r25
    3050:	61 f1       	breq	.+88     	; 0x30aa <protocol_execute_realtime+0x1e2>
          // Handles beginning of spindle stop
          if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_INITIATE) {
    3052:	91 ff       	sbrs	r25, 1
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    3054:	0d c0       	rjmp	.+26     	; 0x3070 <protocol_execute_realtime+0x1a8>
    3056:	f8 01       	movw	r30, r16
    3058:	81 85       	ldd	r24, Z+9	; 0x09
    305a:	88 23       	and	r24, r24
              spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
    305c:	39 f0       	breq	.+14     	; 0x306c <protocol_execute_realtime+0x1a4>
    305e:	40 e0       	ldi	r20, 0x00	; 0
    3060:	50 e0       	ldi	r21, 0x00	; 0
    3062:	ba 01       	movw	r22, r20
    3064:	80 e0       	ldi	r24, 0x00	; 0
    3066:	3d db       	rcall	.-2438   	; 0x26e2 <spindle_set_state>
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_ENABLED; // Set stop override state to enabled, if de-energized.
    3068:	7a 86       	std	Y+10, r7	; 0x0a
    306a:	29 c0       	rjmp	.+82     	; 0x30be <protocol_execute_realtime+0x1f6>
            } else {
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
    306c:	1a 86       	std	Y+10, r1	; 0x0a
    306e:	27 c0       	rjmp	.+78     	; 0x30be <protocol_execute_realtime+0x1f6>
            }
          // Handles restoring of spindle state
          } else if (sys.spindle_stop_ovr & (SPINDLE_STOP_OVR_RESTORE | SPINDLE_STOP_OVR_RESTORE_CYCLE)) {
    3070:	9c 70       	andi	r25, 0x0C	; 12
    3072:	29 f1       	breq	.+74     	; 0x30be <protocol_execute_realtime+0x1f6>
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    3074:	f8 01       	movw	r30, r16
    3076:	81 85       	ldd	r24, Z+9	; 0x09
    3078:	88 23       	and	r24, r24
    307a:	79 f0       	breq	.+30     	; 0x309a <protocol_execute_realtime+0x1d2>
              report_feedback_message(MESSAGE_SPINDLE_RESTORE);
    307c:	8a e0       	ldi	r24, 0x0A	; 10
    307e:	0e 94 9e 35 	call	0x6b3c	; 0x6b3c <report_feedback_message>
              if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    3082:	f7 01       	movw	r30, r14
    3084:	80 81       	ld	r24, Z
    3086:	81 ff       	sbrs	r24, 1
                // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    3088:	04 c0       	rjmp	.+8      	; 0x3092 <protocol_execute_realtime+0x1ca>
    308a:	8c 81       	ldd	r24, Y+4	; 0x04
    308c:	88 60       	ori	r24, 0x08	; 8
    308e:	8c 83       	std	Y+4, r24	; 0x04
              } else {
                spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    3090:	04 c0       	rjmp	.+8      	; 0x309a <protocol_execute_realtime+0x1d2>
    3092:	b5 01       	movw	r22, r10
    3094:	a4 01       	movw	r20, r8
    3096:	8c 2d       	mov	r24, r12
    3098:	24 db       	rcall	.-2488   	; 0x26e2 <spindle_set_state>
              }
            }
            if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_RESTORE_CYCLE) {
    309a:	8a 85       	ldd	r24, Y+10	; 0x0a
    309c:	83 ff       	sbrs	r24, 3
              system_set_exec_state_flag(EXEC_CYCLE_START);  // Set to resume program.
    309e:	03 c0       	rjmp	.+6      	; 0x30a6 <protocol_execute_realtime+0x1de>
    30a0:	82 e0       	ldi	r24, 0x02	; 2
    30a2:	0e 94 99 3b 	call	0x7732	; 0x7732 <system_set_exec_state_flag>
            sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
          }
        } else {
          // Handles spindle state during hold. NOTE: Spindle speed overrides may be altered during hold state.
          // NOTE: STEP_CONTROL_UPDATE_SPINDLE_PWM is automatically reset upon resume in step generator.
          if (bit_istrue(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
    30a6:	1a 86       	std	Y+10, r1	; 0x0a
    30a8:	0a c0       	rjmp	.+20     	; 0x30be <protocol_execute_realtime+0x1f6>
    30aa:	8c 81       	ldd	r24, Y+4	; 0x04
            spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    30ac:	83 ff       	sbrs	r24, 3
    30ae:	07 c0       	rjmp	.+14     	; 0x30be <protocol_execute_realtime+0x1f6>
    30b0:	b5 01       	movw	r22, r10
    30b2:	a4 01       	movw	r20, r8
    30b4:	8c 2d       	mov	r24, r12
            bit_false(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    30b6:	15 db       	rcall	.-2518   	; 0x26e2 <spindle_set_state>
    30b8:	8c 81       	ldd	r24, Y+4	; 0x04
    30ba:	87 7f       	andi	r24, 0xF7	; 247
      // Sleep is valid for both hold and door states, if the spindle or coolant are on or
      // set to be re-enabled.
      sleep_check();
    #endif

    protocol_exec_rt_system();
    30bc:	8c 83       	std	Y+4, r24	; 0x04
    30be:	d3 dc       	rcall	.-1626   	; 0x2a66 <protocol_exec_rt_system>
    if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) { 
      system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP);
    }
  #endif

  while (sys.suspend) {
    30c0:	9a 81       	ldd	r25, Y+2	; 0x02
    30c2:	91 11       	cpse	r25, r1
    30c4:	50 cf       	rjmp	.-352    	; 0x2f66 <protocol_execute_realtime+0x9e>
    30c6:	07 c0       	rjmp	.+14     	; 0x30d6 <protocol_execute_realtime+0x20e>
                  spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
                  delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
                }
              }
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
    30c8:	f8 01       	movw	r30, r16
    30ca:	80 85       	ldd	r24, Z+8	; 0x08
    30cc:	81 11       	cpse	r24, r1
    30ce:	f7 cf       	rjmp	.-18     	; 0x30be <protocol_execute_realtime+0x1f6>
    30d0:	b4 cf       	rjmp	.-152    	; 0x303a <protocol_execute_realtime+0x172>
                  mc_parking_motion(restore_target, pl_data);
                }
              }
            #endif

            if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    30d2:	8a 81       	ldd	r24, Y+2	; 0x02
    30d4:	b5 cf       	rjmp	.-150    	; 0x3040 <protocol_execute_realtime+0x178>
// limit switches, or the main program.
void protocol_execute_realtime()
{
  protocol_exec_rt_system();
  if (sys.suspend) { protocol_exec_rt_suspend(); }
}
    30d6:	df 91       	pop	r29
    30d8:	cf 91       	pop	r28
    30da:	1f 91       	pop	r17
    30dc:	0f 91       	pop	r16
    30de:	ff 90       	pop	r15
    30e0:	ef 90       	pop	r14
    30e2:	df 90       	pop	r13
    30e4:	cf 90       	pop	r12
    30e6:	bf 90       	pop	r11
    30e8:	af 90       	pop	r10
    30ea:	9f 90       	pop	r9
    30ec:	8f 90       	pop	r8
    30ee:	7f 90       	pop	r7
    30f0:	08 95       	ret

000030f2 <protocol_main_loop>:

/*
  GRBL PRIMARY LOOP:
*/
void protocol_main_loop()
{
    30f2:	df 92       	push	r13
    30f4:	ef 92       	push	r14
    30f6:	ff 92       	push	r15
    30f8:	0f 93       	push	r16
    30fa:	1f 93       	push	r17
    30fc:	cf 93       	push	r28
    30fe:	df 93       	push	r29
  // Perform some machine checks to make sure everything is good to go.
  #ifdef CHECK_LIMITS_AT_INIT
    if (bit_istrue(settings.flags, BITFLAG_HARD_LIMIT_ENABLE)) {
    3100:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    3104:	83 ff       	sbrs	r24, 3
    3106:	0a c0       	rjmp	.+20     	; 0x311c <protocol_main_loop+0x2a>
      if (limits_get_state()) {
    3108:	0e 94 65 30 	call	0x60ca	; 0x60ca <limits_get_state>
    310c:	88 23       	and	r24, r24
    310e:	31 f0       	breq	.+12     	; 0x311c <protocol_main_loop+0x2a>
        sys.state = STATE_ALARM; // Ensure alarm state is active.
    3110:	81 e0       	ldi	r24, 0x01	; 1
    3112:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
        report_feedback_message(MESSAGE_CHECK_LIMITS);
    3116:	87 e0       	ldi	r24, 0x07	; 7
    3118:	0e 94 9e 35 	call	0x6b3c	; 0x6b3c <report_feedback_message>
    }
  #endif
  // Check for and report alarm state after a reset, error, or an initial power up.
  // NOTE: Sleep mode disables the stepper drivers and position can't be guaranteed.
  // Re-initialize the sleep state as an ALARM mode to ensure user homes or acknowledges.
  if (sys.state & (STATE_ALARM | STATE_SLEEP)) {
    311c:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    3120:	81 78       	andi	r24, 0x81	; 129
    3122:	71 f0       	breq	.+28     	; 0x3140 <protocol_main_loop+0x4e>
    report_feedback_message(MESSAGE_ALARM_LOCK);
    3124:	82 e0       	ldi	r24, 0x02	; 2
    3126:	0e 94 9e 35 	call	0x6b3c	; 0x6b3c <report_feedback_message>
    sys.state = STATE_ALARM; // Ensure alarm state is set.
    312a:	81 e0       	ldi	r24, 0x01	; 1
    312c:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
          } else if (c == '(') {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            line_flags |= LINE_FLAG_COMMENT_PARENTHESES;
    3130:	f1 2c       	mov	r15, r1
    3132:	e1 2c       	mov	r14, r1
    // this indicates that g-code streaming has either filled the planner buffer or has
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();

    protocol_execute_realtime();  // Runtime command check point.
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    3134:	ce e1       	ldi	r28, 0x1E	; 30
    3136:	dc e0       	ldi	r29, 0x0C	; 12

        // Direct and execute one line of formatted input, and report status of execution.
        if (line_flags & LINE_FLAG_OVERFLOW) {
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
        } else if (line[0] == 0) {
    3138:	08 e0       	ldi	r16, 0x08	; 8
    313a:	12 e0       	ldi	r17, 0x02	; 2
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    313c:	d1 2c       	mov	r13, r1
    313e:	7b c0       	rjmp	.+246    	; 0x3236 <protocol_main_loop+0x144>
  if (sys.state & (STATE_ALARM | STATE_SLEEP)) {
    report_feedback_message(MESSAGE_ALARM_LOCK);
    sys.state = STATE_ALARM; // Ensure alarm state is set.
  } else {
    // Check if the safety door is open.
    sys.state = STATE_IDLE;
    3140:	10 92 1e 0c 	sts	0x0C1E, r1	; 0x800c1e <sys>
    if (system_check_safety_door_ajar()) {
    3144:	0e 94 d6 3a 	call	0x75ac	; 0x75ac <system_check_safety_door_ajar>
    3148:	88 23       	and	r24, r24
    314a:	31 f0       	breq	.+12     	; 0x3158 <protocol_main_loop+0x66>
      bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
    314c:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    3150:	80 62       	ori	r24, 0x20	; 32
    3152:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <sys_rt_exec_state>
      protocol_execute_realtime(); // Enter safety door mode. Should return as IDLE state.
    3156:	b8 de       	rcall	.-656    	; 0x2ec8 <protocol_execute_realtime>
    }
    // All systems go!
    system_execute_startup(line); // Execute startup script.
    3158:	88 e0       	ldi	r24, 0x08	; 8
    315a:	92 e0       	ldi	r25, 0x02	; 2
    315c:	0e 94 d9 3a 	call	0x75b2	; 0x75b2 <system_execute_startup>
    3160:	e7 cf       	rjmp	.-50     	; 0x3130 <protocol_main_loop+0x3e>
  for (;;) {

    // Process one line of incoming serial data, as the data becomes available. Performs an
    // initial filtering by removing spaces and comments and capitalizing all letters.
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
    3162:	8a 30       	cpi	r24, 0x0A	; 10
    3164:	11 f0       	breq	.+4      	; 0x316a <protocol_main_loop+0x78>
    3166:	8d 30       	cpi	r24, 0x0D	; 13

        protocol_execute_realtime(); // Runtime command check point.
    3168:	b1 f5       	brne	.+108    	; 0x31d6 <protocol_main_loop+0xe4>
    316a:	ae de       	rcall	.-676    	; 0x2ec8 <protocol_execute_realtime>
        if (sys.abort) { return; } // Bail to calling function upon system abort
    316c:	89 81       	ldd	r24, Y+1	; 0x01
    316e:	81 11       	cpse	r24, r1
    3170:	6b c0       	rjmp	.+214    	; 0x3248 <protocol_main_loop+0x156>

        line[char_counter] = 0; // Set string termination character.
    3172:	ef 2d       	mov	r30, r15
    3174:	f0 e0       	ldi	r31, 0x00	; 0
    3176:	e8 5f       	subi	r30, 0xF8	; 248
    3178:	fd 4f       	sbci	r31, 0xFD	; 253
    317a:	10 82       	st	Z, r1
        #ifdef REPORT_ECHO_LINE_RECEIVED
          report_echo_line_received(line);
        #endif

        // Direct and execute one line of formatted input, and report status of execution.
        if (line_flags & LINE_FLAG_OVERFLOW) {
    317c:	e0 fe       	sbrs	r14, 0
    317e:	06 c0       	rjmp	.+12     	; 0x318c <protocol_main_loop+0x9a>
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
    3180:	8b e0       	ldi	r24, 0x0B	; 11
    3182:	0e 94 5e 35 	call	0x6abc	; 0x6abc <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    3186:	fd 2c       	mov	r15, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    3188:	e1 2c       	mov	r14, r1
    318a:	55 c0       	rjmp	.+170    	; 0x3236 <protocol_main_loop+0x144>

        // Direct and execute one line of formatted input, and report status of execution.
        if (line_flags & LINE_FLAG_OVERFLOW) {
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
        } else if (line[0] == 0) {
    318c:	f8 01       	movw	r30, r16
    318e:	80 81       	ld	r24, Z
    3190:	81 11       	cpse	r24, r1
    3192:	06 c0       	rjmp	.+12     	; 0x31a0 <protocol_main_loop+0xae>
          // Empty or comment line. For syncing purposes.
          report_status_message(STATUS_OK);
    3194:	8d 2d       	mov	r24, r13
    3196:	0e 94 5e 35 	call	0x6abc	; 0x6abc <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    319a:	fd 2c       	mov	r15, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    319c:	e1 2c       	mov	r14, r1
    319e:	4b c0       	rjmp	.+150    	; 0x3236 <protocol_main_loop+0x144>
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
        } else if (line[0] == 0) {
          // Empty or comment line. For syncing purposes.
          report_status_message(STATUS_OK);
        } else if (line[0] == '$') {
    31a0:	84 32       	cpi	r24, 0x24	; 36
    31a2:	41 f4       	brne	.+16     	; 0x31b4 <protocol_main_loop+0xc2>
          // Grbl '$' system command
          report_status_message(system_execute_line(line));
    31a4:	c8 01       	movw	r24, r16
    31a6:	0e 94 a2 3b 	call	0x7744	; 0x7744 <system_execute_line>
    31aa:	0e 94 5e 35 	call	0x6abc	; 0x6abc <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    31ae:	fd 2c       	mov	r15, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    31b0:	e1 2c       	mov	r14, r1
    31b2:	41 c0       	rjmp	.+130    	; 0x3236 <protocol_main_loop+0x144>
          // Empty or comment line. For syncing purposes.
          report_status_message(STATUS_OK);
        } else if (line[0] == '$') {
          // Grbl '$' system command
          report_status_message(system_execute_line(line));
        } else if (sys.state & (STATE_ALARM | STATE_JOG)) {
    31b4:	88 81       	ld	r24, Y
    31b6:	81 72       	andi	r24, 0x21	; 33
    31b8:	31 f0       	breq	.+12     	; 0x31c6 <protocol_main_loop+0xd4>
          // Everything else is gcode. Block if in alarm or jog mode.
          report_status_message(STATUS_SYSTEM_GC_LOCK);
    31ba:	89 e0       	ldi	r24, 0x09	; 9
    31bc:	0e 94 5e 35 	call	0x6abc	; 0x6abc <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    31c0:	fd 2c       	mov	r15, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    31c2:	e1 2c       	mov	r14, r1
    31c4:	38 c0       	rjmp	.+112    	; 0x3236 <protocol_main_loop+0x144>
        } else if (sys.state & (STATE_ALARM | STATE_JOG)) {
          // Everything else is gcode. Block if in alarm or jog mode.
          report_status_message(STATUS_SYSTEM_GC_LOCK);
        } else {
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
    31c6:	c8 01       	movw	r24, r16
    31c8:	0e 94 60 07 	call	0xec0	; 0xec0 <gc_execute_line>
    31cc:	0e 94 5e 35 	call	0x6abc	; 0x6abc <report_status_message>
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    31d0:	fd 2c       	mov	r15, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    31d2:	e1 2c       	mov	r14, r1
    31d4:	30 c0       	rjmp	.+96     	; 0x3236 <protocol_main_loop+0x144>
        char_counter = 0;

      } else {

        if (line_flags) {
    31d6:	ee 20       	and	r14, r14
    31d8:	31 f0       	breq	.+12     	; 0x31e6 <protocol_main_loop+0xf4>
          // Throw away all (except EOL) comment characters and overflow characters.
          if (c == ')') {
    31da:	89 32       	cpi	r24, 0x29	; 41
    31dc:	61 f5       	brne	.+88     	; 0x3236 <protocol_main_loop+0x144>
            // End of '()' comment. Resume line allowed.
            if (line_flags & LINE_FLAG_COMMENT_PARENTHESES) { line_flags &= ~(LINE_FLAG_COMMENT_PARENTHESES); }
    31de:	fe 2d       	mov	r31, r14
    31e0:	fd 7f       	andi	r31, 0xFD	; 253
    31e2:	ef 2e       	mov	r14, r31
    31e4:	28 c0       	rjmp	.+80     	; 0x3236 <protocol_main_loop+0x144>
          }
        } else {
          if (c <= ' ') {
    31e6:	81 32       	cpi	r24, 0x21	; 33
    31e8:	30 f1       	brcs	.+76     	; 0x3236 <protocol_main_loop+0x144>
            // Throw away whitepace and control characters
          } else if (c == '/') {
    31ea:	8f 32       	cpi	r24, 0x2F	; 47
    31ec:	21 f1       	breq	.+72     	; 0x3236 <protocol_main_loop+0x144>
            // Block delete NOT SUPPORTED. Ignore character.
            // NOTE: If supported, would simply need to check the system if block delete is enabled.
          } else if (c == '(') {
    31ee:	88 32       	cpi	r24, 0x28	; 40
    31f0:	c1 f0       	breq	.+48     	; 0x3222 <protocol_main_loop+0x130>
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            line_flags |= LINE_FLAG_COMMENT_PARENTHESES;
          } else if (c == ';') {
    31f2:	8b 33       	cpi	r24, 0x3B	; 59
    31f4:	d1 f0       	breq	.+52     	; 0x322a <protocol_main_loop+0x138>
            // Program start-end percent sign NOT SUPPORTED.
            // NOTE: This maybe installed to tell Grbl when a program is running vs manual input,
            // where, during a program, the system auto-cycle start will continue to execute
            // everything until the next '%' sign. This will help fix resuming issues with certain
            // functions that empty the planner buffer to execute its task on-time.
          } else if (char_counter >= (LINE_BUFFER_SIZE-1)) {
    31f6:	9f ef       	ldi	r25, 0xFF	; 255
    31f8:	f9 16       	cp	r15, r25
    31fa:	d9 f0       	breq	.+54     	; 0x3232 <protocol_main_loop+0x140>
            // Detect line buffer overflow and set flag.
            line_flags |= LINE_FLAG_OVERFLOW;
          } else if (c >= 'a' && c <= 'z') { // Upcase lowercase
    31fc:	9f e9       	ldi	r25, 0x9F	; 159
    31fe:	98 0f       	add	r25, r24
    3200:	9a 31       	cpi	r25, 0x1A	; 26
    3202:	40 f4       	brcc	.+16     	; 0x3214 <protocol_main_loop+0x122>
            line[char_counter++] = c-'a'+'A';
    3204:	ef 2d       	mov	r30, r15
    3206:	f0 e0       	ldi	r31, 0x00	; 0
    3208:	e8 5f       	subi	r30, 0xF8	; 248
    320a:	fd 4f       	sbci	r31, 0xFD	; 253
    320c:	80 52       	subi	r24, 0x20	; 32
    320e:	80 83       	st	Z, r24
    3210:	f3 94       	inc	r15
    3212:	11 c0       	rjmp	.+34     	; 0x3236 <protocol_main_loop+0x144>
          } else {
            line[char_counter++] = c;
    3214:	ef 2d       	mov	r30, r15
    3216:	f0 e0       	ldi	r31, 0x00	; 0
    3218:	e8 5f       	subi	r30, 0xF8	; 248
    321a:	fd 4f       	sbci	r31, 0xFD	; 253
    321c:	80 83       	st	Z, r24
    321e:	f3 94       	inc	r15
    3220:	0a c0       	rjmp	.+20     	; 0x3236 <protocol_main_loop+0x144>
          } else if (c == '(') {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            line_flags |= LINE_FLAG_COMMENT_PARENTHESES;
    3222:	68 94       	set
    3224:	ee 24       	eor	r14, r14
    3226:	e1 f8       	bld	r14, 1
    3228:	06 c0       	rjmp	.+12     	; 0x3236 <protocol_main_loop+0x144>
          } else if (c == ';') {
            // NOTE: ';' comment to EOL is a LinuxCNC definition. Not NIST.
            line_flags |= LINE_FLAG_COMMENT_SEMICOLON;
    322a:	68 94       	set
    322c:	ee 24       	eor	r14, r14
    322e:	e2 f8       	bld	r14, 2
    3230:	02 c0       	rjmp	.+4      	; 0x3236 <protocol_main_loop+0x144>
            // where, during a program, the system auto-cycle start will continue to execute
            // everything until the next '%' sign. This will help fix resuming issues with certain
            // functions that empty the planner buffer to execute its task on-time.
          } else if (char_counter >= (LINE_BUFFER_SIZE-1)) {
            // Detect line buffer overflow and set flag.
            line_flags |= LINE_FLAG_OVERFLOW;
    3232:	ee 24       	eor	r14, r14
  uint8_t c;
  for (;;) {

    // Process one line of incoming serial data, as the data becomes available. Performs an
    // initial filtering by removing spaces and comments and capitalizing all letters.
    while((c = serial_read()) != SERIAL_NO_DATA) {
    3234:	e3 94       	inc	r14
    3236:	42 db       	rcall	.-2428   	; 0x28bc <serial_read>
    3238:	8f 3f       	cpi	r24, 0xFF	; 255
    }

    // If there are no more characters in the serial read buffer to be processed and executed,
    // this indicates that g-code streaming has either filled the planner buffer or has
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();
    323a:	09 f0       	breq	.+2      	; 0x323e <protocol_main_loop+0x14c>
    323c:	92 cf       	rjmp	.-220    	; 0x3162 <protocol_main_loop+0x70>

    protocol_execute_realtime();  // Runtime command check point.
    323e:	0b dc       	rcall	.-2026   	; 0x2a56 <protocol_auto_cycle_start>
    3240:	43 de       	rcall	.-890    	; 0x2ec8 <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    3242:	89 81       	ldd	r24, Y+1	; 0x01
    3244:	88 23       	and	r24, r24
    3246:	b9 f3       	breq	.-18     	; 0x3236 <protocol_main_loop+0x144>
      sleep_check();    
    #endif
  }

  return; /* Never reached */
}
    3248:	df 91       	pop	r29
    324a:	cf 91       	pop	r28
    324c:	1f 91       	pop	r17
    324e:	0f 91       	pop	r16
    3250:	ff 90       	pop	r15
    3252:	ef 90       	pop	r14
    3254:	df 90       	pop	r13
    3256:	08 95       	ret

00003258 <protocol_buffer_synchronize>:


// Block until all buffered steps are executed or in a cycle state. Works with feed hold
// during a synchronize call, if it should happen. Also, waits for clean cycle end.
void protocol_buffer_synchronize()
{
    3258:	cf 93       	push	r28
    325a:	df 93       	push	r29
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
    325c:	fc db       	rcall	.-2056   	; 0x2a56 <protocol_auto_cycle_start>
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    if (sys.abort) { return; } // Check for system abort
    325e:	ce e1       	ldi	r28, 0x1E	; 30
void protocol_buffer_synchronize()
{
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    3260:	dc e0       	ldi	r29, 0x0C	; 12
    3262:	32 de       	rcall	.-924    	; 0x2ec8 <protocol_execute_realtime>
    if (sys.abort) { return; } // Check for system abort
    3264:	89 81       	ldd	r24, Y+1	; 0x01
    3266:	81 11       	cpse	r24, r1
    3268:	07 c0       	rjmp	.+14     	; 0x3278 <protocol_buffer_synchronize+0x20>
  } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
    326a:	0e 94 85 29 	call	0x530a	; 0x530a <plan_get_current_block>
    326e:	89 2b       	or	r24, r25
    3270:	c1 f7       	brne	.-16     	; 0x3262 <protocol_buffer_synchronize+0xa>
    3272:	88 81       	ld	r24, Y
    3274:	88 30       	cpi	r24, 0x08	; 8
    3276:	a9 f3       	breq	.-22     	; 0x3262 <protocol_buffer_synchronize+0xa>
}
    3278:	df 91       	pop	r29
    327a:	cf 91       	pop	r28
    327c:	08 95       	ret

0000327e <st_wake_up>:
    // Initialize stepper output bits to ensure first ISR call does not step.
    for (idx = 0; idx < N_AXIS; idx++) {
      st.step_outbits[idx] = step_port_invert_mask[idx];
    }
  #else
    if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    327e:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    3282:	82 ff       	sbrs	r24, 2
    3284:	02 c0       	rjmp	.+4      	; 0x328a <st_wake_up+0xc>
    3286:	2f 9a       	sbi	0x05, 7	; 5
    3288:	01 c0       	rjmp	.+2      	; 0x328c <st_wake_up+0xe>
    else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    328a:	2f 98       	cbi	0x05, 7	; 5
    // Initialize stepper output bits to ensure first ISR call does not step.
    st.step_outbits = step_port_invert_mask;
    328c:	e3 e4       	ldi	r30, 0x43	; 67
    328e:	f3 e0       	ldi	r31, 0x03	; 3
    3290:	80 91 3f 03 	lds	r24, 0x033F	; 0x80033f <step_port_invert_mask>
    3294:	86 87       	std	Z+14, r24	; 0x0e
    st.step_pulse_time = -(((settings.pulse_microseconds+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND) >> 3);
    // Set delay between direction pin write and step command.
    OCR0A = -(((settings.pulse_microseconds)*TICKS_PER_MICROSECOND) >> 3);
  #else // Normal operation
    // Set step pulse time. Ad hoc computation from oscilloscope. Uses two's complement.
    st.step_pulse_time = -(((settings.pulse_microseconds-2)*TICKS_PER_MICROSECOND) >> 3);
    3296:	80 91 00 0f 	lds	r24, 0x0F00	; 0x800f00 <settings+0x30>
    329a:	88 0f       	add	r24, r24
    329c:	84 50       	subi	r24, 0x04	; 4
    329e:	81 95       	neg	r24
    32a0:	85 87       	std	Z+13, r24	; 0x0d
  #endif

  // Enable Stepper Driver Interrupt
  TIMSK1 |= (1<<OCIE1A);
    32a2:	ef e6       	ldi	r30, 0x6F	; 111
    32a4:	f0 e0       	ldi	r31, 0x00	; 0
    32a6:	80 81       	ld	r24, Z
    32a8:	82 60       	ori	r24, 0x02	; 2
    32aa:	80 83       	st	Z, r24
    32ac:	08 95       	ret

000032ae <st_go_idle>:

// Stepper shutdown
void st_go_idle()
{
  // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.
  TIMSK1 &= ~(1<<OCIE1A); // Disable Timer1 interrupt
    32ae:	ef e6       	ldi	r30, 0x6F	; 111
    32b0:	f0 e0       	ldi	r31, 0x00	; 0
    32b2:	80 81       	ld	r24, Z
    32b4:	8d 7f       	andi	r24, 0xFD	; 253
    32b6:	80 83       	st	Z, r24
  TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Reset clock to no prescaling.
    32b8:	e1 e8       	ldi	r30, 0x81	; 129
    32ba:	f0 e0       	ldi	r31, 0x00	; 0
    32bc:	80 81       	ld	r24, Z
    32be:	88 7f       	andi	r24, 0xF8	; 248
    32c0:	81 60       	ori	r24, 0x01	; 1
    32c2:	80 83       	st	Z, r24
  busy = false;
    32c4:	10 92 3d 03 	sts	0x033D, r1	; 0x80033d <busy>

  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
  if (((settings.stepper_idle_lock_time != 0xff) || sys_rt_exec_alarm || sys.state == STATE_SLEEP) && sys.state != STATE_HOMING) {
    32c8:	80 91 03 0f 	lds	r24, 0x0F03	; 0x800f03 <settings+0x33>
    32cc:	8f 3f       	cpi	r24, 0xFF	; 255
    32ce:	49 f4       	brne	.+18     	; 0x32e2 <st_go_idle+0x34>
    32d0:	90 91 53 0c 	lds	r25, 0x0C53	; 0x800c53 <sys_rt_exec_alarm>
    32d4:	91 11       	cpse	r25, r1
    32d6:	05 c0       	rjmp	.+10     	; 0x32e2 <st_go_idle+0x34>
    32d8:	90 91 1e 0c 	lds	r25, 0x0C1E	; 0x800c1e <sys>
    32dc:	90 38       	cpi	r25, 0x80	; 128
    32de:	81 f4       	brne	.+32     	; 0x3300 <st_go_idle+0x52>
    32e0:	04 c0       	rjmp	.+8      	; 0x32ea <st_go_idle+0x3c>
    32e2:	90 91 1e 0c 	lds	r25, 0x0C1E	; 0x800c1e <sys>
    32e6:	94 30       	cpi	r25, 0x04	; 4
    32e8:	59 f0       	breq	.+22     	; 0x3300 <st_go_idle+0x52>
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    32ea:	90 e0       	ldi	r25, 0x00	; 0
    32ec:	0e 94 30 2f 	call	0x5e60	; 0x5e60 <delay_ms>
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    32f0:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    32f4:	82 fd       	sbrc	r24, 2
    32f6:	02 c0       	rjmp	.+4      	; 0x32fc <st_go_idle+0x4e>
      STEPPER_DISABLE_PORT(0) &= ~(1 << STEPPER_DISABLE_BIT(0));
      STEPPER_DISABLE_PORT(1) &= ~(1 << STEPPER_DISABLE_BIT(1));
      STEPPER_DISABLE_PORT(2) &= ~(1 << STEPPER_DISABLE_BIT(2));
    }
  #else
    if (pin_state) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    32f8:	2f 9a       	sbi	0x05, 7	; 5
    32fa:	08 95       	ret
    else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    32fc:	2f 98       	cbi	0x05, 7	; 5
  #endif // Ramps Board
}
    32fe:	08 95       	ret
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    3300:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    3304:	82 ff       	sbrs	r24, 2
    3306:	fa cf       	rjmp	.-12     	; 0x32fc <st_go_idle+0x4e>
    3308:	f7 cf       	rjmp	.-18     	; 0x32f8 <st_go_idle+0x4a>

0000330a <__vector_17>:
*/
// TODO: Replace direct updating of the int32 position counters in the ISR somehow. Perhaps use smaller
// int8 variables and update position counters only when a segment completes. This can get complicated
// with probing and homing cycles that require true real-time positions.
ISR(TIMER1_COMPA_vect)
{
    330a:	1f 92       	push	r1
    330c:	0f 92       	push	r0
    330e:	0f b6       	in	r0, 0x3f	; 63
    3310:	0f 92       	push	r0
    3312:	11 24       	eor	r1, r1
    3314:	0b b6       	in	r0, 0x3b	; 59
    3316:	0f 92       	push	r0
    3318:	2f 93       	push	r18
    331a:	3f 93       	push	r19
    331c:	4f 93       	push	r20
    331e:	5f 93       	push	r21
    3320:	6f 93       	push	r22
    3322:	7f 93       	push	r23
    3324:	8f 93       	push	r24
    3326:	9f 93       	push	r25
    3328:	af 93       	push	r26
    332a:	bf 93       	push	r27
    332c:	cf 93       	push	r28
    332e:	df 93       	push	r29
    3330:	ef 93       	push	r30
    3332:	ff 93       	push	r31
  #ifdef DEFAULTS_RAMPS_BOARD
    int i;
  #endif // Ramps Board

  if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
    3334:	80 91 3d 03 	lds	r24, 0x033D	; 0x80033d <busy>
    3338:	81 11       	cpse	r24, r1
    333a:	d0 c1       	rjmp	.+928    	; 0x36dc <__vector_17+0x3d2>
  #ifdef DEFAULTS_RAMPS_BOARD
    DIRECTION_PORT(0) = (DIRECTION_PORT(0) & ~(1 << DIRECTION_BIT(0))) | st.dir_outbits[0];
    DIRECTION_PORT(1) = (DIRECTION_PORT(1) & ~(1 << DIRECTION_BIT(1))) | st.dir_outbits[1];
    DIRECTION_PORT(2) = (DIRECTION_PORT(2) & ~(1 << DIRECTION_BIT(2))) | st.dir_outbits[2];
  #else
    DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK);
    333c:	88 b1       	in	r24, 0x08	; 8
    333e:	e3 e4       	ldi	r30, 0x43	; 67
    3340:	f3 e0       	ldi	r31, 0x03	; 3
    3342:	97 85       	ldd	r25, Z+15	; 0x0f
    3344:	90 7e       	andi	r25, 0xE0	; 224
    3346:	8f 71       	andi	r24, 0x1F	; 31
    3348:	89 2b       	or	r24, r25
    334a:	88 b9       	out	0x08, r24	; 8
    #endif
  #else  
    #ifdef STEP_PULSE_DELAY
      st.step_bits = (STEP_PORT & ~STEP_MASK) | st.step_outbits; // Store out_bits to prevent overwriting.
    #else  // Normal operation
      STEP_PORT = (STEP_PORT & ~STEP_MASK) | st.step_outbits;
    334c:	82 b1       	in	r24, 0x02	; 2
    334e:	83 7e       	andi	r24, 0xE3	; 227
    3350:	96 85       	ldd	r25, Z+14	; 0x0e
    3352:	89 2b       	or	r24, r25
    3354:	82 b9       	out	0x02, r24	; 2
    #endif
  #endif // Ramps Board

  // Enable step pulse reset timer so that The Stepper Port Reset Interrupt can reset the signal after
  // exactly settings.pulse_microseconds microseconds, independent of the main Timer1 prescaler.
  TCNT0 = st.step_pulse_time; // Reload Timer0 counter
    3356:	85 85       	ldd	r24, Z+13	; 0x0d
    3358:	86 bd       	out	0x26, r24	; 38
  TCCR0B = (1<<CS01); // Begin Timer0. Full speed, 1/8 prescaler
    335a:	82 e0       	ldi	r24, 0x02	; 2
    335c:	85 bd       	out	0x25, r24	; 37

  busy = true;
    335e:	81 e0       	ldi	r24, 0x01	; 1
    3360:	80 93 3d 03 	sts	0x033D, r24	; 0x80033d <busy>
  sei(); // Re-enable interrupts to allow Stepper Port Reset Interrupt to fire on-time.
    3364:	78 94       	sei
         // NOTE: The remaining code in this ISR will finish before returning to main program.

  // If there is no step segment, attempt to pop one from the stepper buffer
  if (st.exec_segment == NULL) {
    3366:	81 a1       	ldd	r24, Z+33	; 0x21
    3368:	92 a1       	ldd	r25, Z+34	; 0x22
    336a:	89 2b       	or	r24, r25
    336c:	09 f0       	breq	.+2      	; 0x3370 <__vector_17+0x66>
    336e:	a9 c0       	rjmp	.+338    	; 0x34c2 <__vector_17+0x1b8>
    // Anything in the buffer? If so, load and initialize next step segment.
    if (segment_buffer_head != segment_buffer_tail) {
    3370:	80 91 42 03 	lds	r24, 0x0342	; 0x800342 <segment_buffer_tail>
    3374:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <segment_buffer_head>
    3378:	98 17       	cp	r25, r24
    337a:	09 f4       	brne	.+2      	; 0x337e <__vector_17+0x74>
    337c:	93 c0       	rjmp	.+294    	; 0x34a4 <__vector_17+0x19a>
      // Initialize new step segment and load number of steps to execute
      st.exec_segment = &segment_buffer[segment_buffer_tail];
    337e:	e0 91 42 03 	lds	r30, 0x0342	; 0x800342 <segment_buffer_tail>
    3382:	f0 e0       	ldi	r31, 0x00	; 0
    3384:	a3 e4       	ldi	r26, 0x43	; 67
    3386:	b3 e0       	ldi	r27, 0x03	; 3
    3388:	ee 0f       	add	r30, r30
    338a:	ff 1f       	adc	r31, r31
    338c:	ee 0f       	add	r30, r30
    338e:	ff 1f       	adc	r31, r31
    3390:	ee 0f       	add	r30, r30
    3392:	ff 1f       	adc	r31, r31
    3394:	ea 59       	subi	r30, 0x9A	; 154
    3396:	fc 4f       	sbci	r31, 0xFC	; 252
    3398:	92 96       	adiw	r26, 0x22	; 34
    339a:	fc 93       	st	X, r31
    339c:	ee 93       	st	-X, r30
    339e:	91 97       	sbiw	r26, 0x21	; 33
        // With AMASS is disabled, set timer prescaler for segments with slow step frequencies (< 250Hz).
        TCCR1B = (TCCR1B & ~(0x07<<CS10)) | (st.exec_segment->prescaler<<CS10);
      #endif

      // Initialize step segment timing per step and load number of steps to execute.
      OCR1A = st.exec_segment->cycles_per_tick;
    33a0:	82 81       	ldd	r24, Z+2	; 0x02
    33a2:	93 81       	ldd	r25, Z+3	; 0x03
    33a4:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    33a8:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
      st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
    33ac:	80 81       	ld	r24, Z
    33ae:	91 81       	ldd	r25, Z+1	; 0x01
    33b0:	5d 96       	adiw	r26, 0x1d	; 29
    33b2:	9c 93       	st	X, r25
    33b4:	8e 93       	st	-X, r24
    33b6:	5c 97       	sbiw	r26, 0x1c	; 28
      // If the new segment starts a new planner block, initialize stepper variables and counters.
      // NOTE: When the segment data index changes, this indicates a new planner block.
      if ( st.exec_block_index != st.exec_segment->st_block_index ) {
    33b8:	84 81       	ldd	r24, Z+4	; 0x04
    33ba:	5e 96       	adiw	r26, 0x1e	; 30
    33bc:	9c 91       	ld	r25, X
    33be:	5e 97       	sbiw	r26, 0x1e	; 30
    33c0:	98 17       	cp	r25, r24
    33c2:	49 f1       	breq	.+82     	; 0x3416 <__vector_17+0x10c>
        st.exec_block_index = st.exec_segment->st_block_index;
    33c4:	ed 01       	movw	r28, r26
    33c6:	8e 8f       	std	Y+30, r24	; 0x1e
        st.exec_block = &st_block_buffer[st.exec_block_index];
    33c8:	90 e0       	ldi	r25, 0x00	; 0
    33ca:	88 0f       	add	r24, r24
    33cc:	99 1f       	adc	r25, r25
    33ce:	dc 01       	movw	r26, r24
    33d0:	aa 0f       	add	r26, r26
    33d2:	bb 1f       	adc	r27, r27
    33d4:	aa 0f       	add	r26, r26
    33d6:	bb 1f       	adc	r27, r27
    33d8:	aa 0f       	add	r26, r26
    33da:	bb 1f       	adc	r27, r27
    33dc:	8a 0f       	add	r24, r26
    33de:	9b 1f       	adc	r25, r27
    33e0:	dc 01       	movw	r26, r24
    33e2:	aa 54       	subi	r26, 0x4A	; 74
    33e4:	bc 4f       	sbci	r27, 0xFC	; 252
    33e6:	b8 a3       	std	Y+32, r27	; 0x20
    33e8:	af 8f       	std	Y+31, r26	; 0x1f

        // Initialize Bresenham line and distance counters
        st.counter_x = st.counter_y = st.counter_z = (st.exec_block->step_event_count >> 1);
    33ea:	1c 96       	adiw	r26, 0x0c	; 12
    33ec:	8d 91       	ld	r24, X+
    33ee:	9d 91       	ld	r25, X+
    33f0:	0d 90       	ld	r0, X+
    33f2:	bc 91       	ld	r27, X
    33f4:	a0 2d       	mov	r26, r0
    33f6:	b6 95       	lsr	r27
    33f8:	a7 95       	ror	r26
    33fa:	97 95       	ror	r25
    33fc:	87 95       	ror	r24
    33fe:	88 87       	std	Y+8, r24	; 0x08
    3400:	99 87       	std	Y+9, r25	; 0x09
    3402:	aa 87       	std	Y+10, r26	; 0x0a
    3404:	bb 87       	std	Y+11, r27	; 0x0b
    3406:	8c 83       	std	Y+4, r24	; 0x04
    3408:	9d 83       	std	Y+5, r25	; 0x05
    340a:	ae 83       	std	Y+6, r26	; 0x06
    340c:	bf 83       	std	Y+7, r27	; 0x07
    340e:	88 83       	st	Y, r24
    3410:	99 83       	std	Y+1, r25	; 0x01
    3412:	aa 83       	std	Y+2, r26	; 0x02
    3414:	bb 83       	std	Y+3, r27	; 0x03
      }
      #ifdef DEFAULTS_RAMPS_BOARD
        for (i = 0; i < N_AXIS; i++)
          st.dir_outbits[i] = st.exec_block->direction_bits[i] ^ dir_port_invert_mask[i];
      #else
        st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask;
    3416:	a3 e4       	ldi	r26, 0x43	; 67
    3418:	b3 e0       	ldi	r27, 0x03	; 3
    341a:	5f 96       	adiw	r26, 0x1f	; 31
    341c:	cd 91       	ld	r28, X+
    341e:	dc 91       	ld	r29, X
    3420:	90 97       	sbiw	r26, 0x20	; 32
    3422:	98 89       	ldd	r25, Y+16	; 0x10
    3424:	80 91 3e 03 	lds	r24, 0x033E	; 0x80033e <dir_port_invert_mask>
    3428:	89 27       	eor	r24, r25
    342a:	1f 96       	adiw	r26, 0x0f	; 15
    342c:	8c 93       	st	X, r24
    342e:	1f 97       	sbiw	r26, 0x0f	; 15
      #endif // Ramps Board

      #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
        // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
        st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.exec_segment->amass_level;
    3430:	48 81       	ld	r20, Y
    3432:	59 81       	ldd	r21, Y+1	; 0x01
    3434:	6a 81       	ldd	r22, Y+2	; 0x02
    3436:	7b 81       	ldd	r23, Y+3	; 0x03
    3438:	05 80       	ldd	r0, Z+5	; 0x05
    343a:	04 c0       	rjmp	.+8      	; 0x3444 <__vector_17+0x13a>
    343c:	76 95       	lsr	r23
    343e:	67 95       	ror	r22
    3440:	57 95       	ror	r21
    3442:	47 95       	ror	r20
    3444:	0a 94       	dec	r0
    3446:	d2 f7       	brpl	.-12     	; 0x343c <__vector_17+0x132>
    3448:	50 96       	adiw	r26, 0x10	; 16
    344a:	4d 93       	st	X+, r20
    344c:	5d 93       	st	X+, r21
    344e:	6d 93       	st	X+, r22
    3450:	7c 93       	st	X, r23
    3452:	53 97       	sbiw	r26, 0x13	; 19
        st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.exec_segment->amass_level;
    3454:	4c 81       	ldd	r20, Y+4	; 0x04
    3456:	5d 81       	ldd	r21, Y+5	; 0x05
    3458:	6e 81       	ldd	r22, Y+6	; 0x06
    345a:	7f 81       	ldd	r23, Y+7	; 0x07
    345c:	05 80       	ldd	r0, Z+5	; 0x05
    345e:	04 c0       	rjmp	.+8      	; 0x3468 <__vector_17+0x15e>
    3460:	76 95       	lsr	r23
    3462:	67 95       	ror	r22
    3464:	57 95       	ror	r21
    3466:	47 95       	ror	r20
    3468:	0a 94       	dec	r0
    346a:	d2 f7       	brpl	.-12     	; 0x3460 <__vector_17+0x156>
    346c:	54 96       	adiw	r26, 0x14	; 20
    346e:	4d 93       	st	X+, r20
    3470:	5d 93       	st	X+, r21
    3472:	6d 93       	st	X+, r22
    3474:	7c 93       	st	X, r23
    3476:	57 97       	sbiw	r26, 0x17	; 23
        st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
    3478:	48 85       	ldd	r20, Y+8	; 0x08
    347a:	59 85       	ldd	r21, Y+9	; 0x09
    347c:	6a 85       	ldd	r22, Y+10	; 0x0a
    347e:	7b 85       	ldd	r23, Y+11	; 0x0b
    3480:	05 80       	ldd	r0, Z+5	; 0x05
    3482:	04 c0       	rjmp	.+8      	; 0x348c <__vector_17+0x182>
    3484:	76 95       	lsr	r23
    3486:	67 95       	ror	r22
    3488:	57 95       	ror	r21
    348a:	47 95       	ror	r20
    348c:	0a 94       	dec	r0
    348e:	d2 f7       	brpl	.-12     	; 0x3484 <__vector_17+0x17a>
    3490:	58 96       	adiw	r26, 0x18	; 24
    3492:	4d 93       	st	X+, r20
    3494:	5d 93       	st	X+, r21
    3496:	6d 93       	st	X+, r22
    3498:	7c 93       	st	X, r23
    349a:	5b 97       	sbiw	r26, 0x1b	; 27
      #endif

      // Set real-time spindle output as segment is loaded, just prior to the first step.
      spindle_set_speed(st.exec_segment->spindle_pwm);
    349c:	86 81       	ldd	r24, Z+6	; 0x06
    349e:	97 81       	ldd	r25, Z+7	; 0x07
    34a0:	6d d8       	rcall	.-3878   	; 0x257c <spindle_set_speed>
    34a2:	0f c0       	rjmp	.+30     	; 0x34c2 <__vector_17+0x1b8>

    } else {
      // Segment buffer empty. Shutdown.
      st_go_idle();
    34a4:	04 df       	rcall	.-504    	; 0x32ae <st_go_idle>
      // Ensure pwm is set properly upon completion of rate-controlled motion.
      if (st.exec_block->is_pwm_rate_adjusted) { spindle_set_speed(SPINDLE_PWM_OFF_VALUE); }
    34a6:	e0 91 62 03 	lds	r30, 0x0362	; 0x800362 <st+0x1f>
    34aa:	f0 91 63 03 	lds	r31, 0x0363	; 0x800363 <st+0x20>
    34ae:	81 89       	ldd	r24, Z+17	; 0x11
    34b0:	88 23       	and	r24, r24
    34b2:	19 f0       	breq	.+6      	; 0x34ba <__vector_17+0x1b0>
    34b4:	80 e0       	ldi	r24, 0x00	; 0
    34b6:	90 e0       	ldi	r25, 0x00	; 0
    34b8:	61 d8       	rcall	.-3902   	; 0x257c <spindle_set_speed>
      system_set_exec_state_flag(EXEC_CYCLE_STOP); // Flag main program for cycle end
    34ba:	84 e0       	ldi	r24, 0x04	; 4
    34bc:	0e 94 99 3b 	call	0x7732	; 0x7732 <system_set_exec_state_flag>
      return; // Nothing to do but exit.
    34c0:	0d c1       	rjmp	.+538    	; 0x36dc <__vector_17+0x3d2>
    }
  }


  // Check probing state.
  if (sys_probe_state == PROBE_ACTIVE) { probe_state_monitor(); }
    34c2:	80 91 32 0c 	lds	r24, 0x0C32	; 0x800c32 <sys_probe_state>
    34c6:	81 30       	cpi	r24, 0x01	; 1
    34c8:	11 f4       	brne	.+4      	; 0x34ce <__vector_17+0x1c4>
    34ca:	0e 94 01 35 	call	0x6a02	; 0x6a02 <probe_state_monitor>
  // Reset step out bits.
  #ifdef DEFAULTS_RAMPS_BOARD
    for (i = 0; i < N_AXIS; i++)
      st.step_outbits[i] = 0;
  #else
    st.step_outbits = 0;
    34ce:	e3 e4       	ldi	r30, 0x43	; 67
    34d0:	f3 e0       	ldi	r31, 0x03	; 3
    34d2:	16 86       	std	Z+14, r1	; 0x0e
  #endif // Ramps Board

  // Execute step displacement profile by Bresenham line algorithm
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_x += st.steps[X_AXIS];
    34d4:	40 81       	ld	r20, Z
    34d6:	51 81       	ldd	r21, Z+1	; 0x01
    34d8:	62 81       	ldd	r22, Z+2	; 0x02
    34da:	73 81       	ldd	r23, Z+3	; 0x03
    34dc:	80 89       	ldd	r24, Z+16	; 0x10
    34de:	91 89       	ldd	r25, Z+17	; 0x11
    34e0:	a2 89       	ldd	r26, Z+18	; 0x12
    34e2:	b3 89       	ldd	r27, Z+19	; 0x13
    34e4:	84 0f       	add	r24, r20
    34e6:	95 1f       	adc	r25, r21
    34e8:	a6 1f       	adc	r26, r22
    34ea:	b7 1f       	adc	r27, r23
    34ec:	80 83       	st	Z, r24
    34ee:	91 83       	std	Z+1, r25	; 0x01
    34f0:	a2 83       	std	Z+2, r26	; 0x02
    34f2:	b3 83       	std	Z+3, r27	; 0x03
      st.counter_x -= st.exec_block->step_event_count;
      if (st.exec_block->direction_bits[X_AXIS] & (1<<DIRECTION_BIT(X_AXIS))) { sys_position[X_AXIS]--; }
      else { sys_position[X_AXIS]++; }
    }
  #else
    if (st.counter_x > st.exec_block->step_event_count) {
    34f4:	07 8c       	ldd	r0, Z+31	; 0x1f
    34f6:	f0 a1       	ldd	r31, Z+32	; 0x20
    34f8:	e0 2d       	mov	r30, r0
    34fa:	44 85       	ldd	r20, Z+12	; 0x0c
    34fc:	55 85       	ldd	r21, Z+13	; 0x0d
    34fe:	66 85       	ldd	r22, Z+14	; 0x0e
    3500:	77 85       	ldd	r23, Z+15	; 0x0f
    3502:	48 17       	cp	r20, r24
    3504:	59 07       	cpc	r21, r25
    3506:	6a 07       	cpc	r22, r26
    3508:	7b 07       	cpc	r23, r27
    350a:	70 f5       	brcc	.+92     	; 0x3568 <__vector_17+0x25e>
      st.step_outbits |= (1<<X_STEP_BIT);
    350c:	c3 e4       	ldi	r28, 0x43	; 67
    350e:	d3 e0       	ldi	r29, 0x03	; 3
    3510:	24 e0       	ldi	r18, 0x04	; 4
    3512:	2e 87       	std	Y+14, r18	; 0x0e
      st.counter_x -= st.exec_block->step_event_count;
    3514:	44 85       	ldd	r20, Z+12	; 0x0c
    3516:	55 85       	ldd	r21, Z+13	; 0x0d
    3518:	66 85       	ldd	r22, Z+14	; 0x0e
    351a:	77 85       	ldd	r23, Z+15	; 0x0f
    351c:	84 1b       	sub	r24, r20
    351e:	95 0b       	sbc	r25, r21
    3520:	a6 0b       	sbc	r26, r22
    3522:	b7 0b       	sbc	r27, r23
    3524:	88 83       	st	Y, r24
    3526:	99 83       	std	Y+1, r25	; 0x01
    3528:	aa 83       	std	Y+2, r26	; 0x02
    352a:	bb 83       	std	Y+3, r27	; 0x03
      if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys_position[X_AXIS]--; }
    352c:	80 89       	ldd	r24, Z+16	; 0x10
    352e:	88 23       	and	r24, r24
    3530:	74 f4       	brge	.+28     	; 0x354e <__vector_17+0x244>
    3532:	c3 e4       	ldi	r28, 0x43	; 67
    3534:	dc e0       	ldi	r29, 0x0C	; 12
    3536:	88 81       	ld	r24, Y
    3538:	99 81       	ldd	r25, Y+1	; 0x01
    353a:	aa 81       	ldd	r26, Y+2	; 0x02
    353c:	bb 81       	ldd	r27, Y+3	; 0x03
    353e:	01 97       	sbiw	r24, 0x01	; 1
    3540:	a1 09       	sbc	r26, r1
    3542:	b1 09       	sbc	r27, r1
    3544:	88 83       	st	Y, r24
    3546:	99 83       	std	Y+1, r25	; 0x01
    3548:	aa 83       	std	Y+2, r26	; 0x02
    354a:	bb 83       	std	Y+3, r27	; 0x03
    354c:	0d c0       	rjmp	.+26     	; 0x3568 <__vector_17+0x25e>
      else { sys_position[X_AXIS]++; }
    354e:	c3 e4       	ldi	r28, 0x43	; 67
    3550:	dc e0       	ldi	r29, 0x0C	; 12
    3552:	88 81       	ld	r24, Y
    3554:	99 81       	ldd	r25, Y+1	; 0x01
    3556:	aa 81       	ldd	r26, Y+2	; 0x02
    3558:	bb 81       	ldd	r27, Y+3	; 0x03
    355a:	01 96       	adiw	r24, 0x01	; 1
    355c:	a1 1d       	adc	r26, r1
    355e:	b1 1d       	adc	r27, r1
    3560:	88 83       	st	Y, r24
    3562:	99 83       	std	Y+1, r25	; 0x01
    3564:	aa 83       	std	Y+2, r26	; 0x02
    3566:	bb 83       	std	Y+3, r27	; 0x03
    }
  #endif // Ramps Board

  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_y += st.steps[Y_AXIS];
    3568:	c3 e4       	ldi	r28, 0x43	; 67
    356a:	d3 e0       	ldi	r29, 0x03	; 3
    356c:	4c 81       	ldd	r20, Y+4	; 0x04
    356e:	5d 81       	ldd	r21, Y+5	; 0x05
    3570:	6e 81       	ldd	r22, Y+6	; 0x06
    3572:	7f 81       	ldd	r23, Y+7	; 0x07
    3574:	8c 89       	ldd	r24, Y+20	; 0x14
    3576:	9d 89       	ldd	r25, Y+21	; 0x15
    3578:	ae 89       	ldd	r26, Y+22	; 0x16
    357a:	bf 89       	ldd	r27, Y+23	; 0x17
    357c:	84 0f       	add	r24, r20
    357e:	95 1f       	adc	r25, r21
    3580:	a6 1f       	adc	r26, r22
    3582:	b7 1f       	adc	r27, r23
    3584:	8c 83       	std	Y+4, r24	; 0x04
    3586:	9d 83       	std	Y+5, r25	; 0x05
    3588:	ae 83       	std	Y+6, r26	; 0x06
    358a:	bf 83       	std	Y+7, r27	; 0x07
      st.counter_y -= st.exec_block->step_event_count;
      if (st.exec_block->direction_bits[Y_AXIS] & (1<<DIRECTION_BIT(Y_AXIS))) { sys_position[Y_AXIS]--; }
      else { sys_position[Y_AXIS]++; }
    }
  #else
    if (st.counter_y > st.exec_block->step_event_count) {
    358c:	44 85       	ldd	r20, Z+12	; 0x0c
    358e:	55 85       	ldd	r21, Z+13	; 0x0d
    3590:	66 85       	ldd	r22, Z+14	; 0x0e
    3592:	77 85       	ldd	r23, Z+15	; 0x0f
    3594:	48 17       	cp	r20, r24
    3596:	59 07       	cpc	r21, r25
    3598:	6a 07       	cpc	r22, r26
    359a:	7b 07       	cpc	r23, r27
    359c:	68 f5       	brcc	.+90     	; 0x35f8 <__vector_17+0x2ee>
      st.step_outbits |= (1<<Y_STEP_BIT);
    359e:	2e 85       	ldd	r18, Y+14	; 0x0e
    35a0:	28 60       	ori	r18, 0x08	; 8
    35a2:	2e 87       	std	Y+14, r18	; 0x0e
      st.counter_y -= st.exec_block->step_event_count;
    35a4:	44 85       	ldd	r20, Z+12	; 0x0c
    35a6:	55 85       	ldd	r21, Z+13	; 0x0d
    35a8:	66 85       	ldd	r22, Z+14	; 0x0e
    35aa:	77 85       	ldd	r23, Z+15	; 0x0f
    35ac:	84 1b       	sub	r24, r20
    35ae:	95 0b       	sbc	r25, r21
    35b0:	a6 0b       	sbc	r26, r22
    35b2:	b7 0b       	sbc	r27, r23
    35b4:	8c 83       	std	Y+4, r24	; 0x04
    35b6:	9d 83       	std	Y+5, r25	; 0x05
    35b8:	ae 83       	std	Y+6, r26	; 0x06
    35ba:	bf 83       	std	Y+7, r27	; 0x07
      if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys_position[Y_AXIS]--; }
    35bc:	80 89       	ldd	r24, Z+16	; 0x10
    35be:	86 ff       	sbrs	r24, 6
    35c0:	0e c0       	rjmp	.+28     	; 0x35de <__vector_17+0x2d4>
    35c2:	c3 e4       	ldi	r28, 0x43	; 67
    35c4:	dc e0       	ldi	r29, 0x0C	; 12
    35c6:	8c 81       	ldd	r24, Y+4	; 0x04
    35c8:	9d 81       	ldd	r25, Y+5	; 0x05
    35ca:	ae 81       	ldd	r26, Y+6	; 0x06
    35cc:	bf 81       	ldd	r27, Y+7	; 0x07
    35ce:	01 97       	sbiw	r24, 0x01	; 1
    35d0:	a1 09       	sbc	r26, r1
    35d2:	b1 09       	sbc	r27, r1
    35d4:	8c 83       	std	Y+4, r24	; 0x04
    35d6:	9d 83       	std	Y+5, r25	; 0x05
    35d8:	ae 83       	std	Y+6, r26	; 0x06
    35da:	bf 83       	std	Y+7, r27	; 0x07
    35dc:	0d c0       	rjmp	.+26     	; 0x35f8 <__vector_17+0x2ee>
      else { sys_position[Y_AXIS]++; }
    35de:	c3 e4       	ldi	r28, 0x43	; 67
    35e0:	dc e0       	ldi	r29, 0x0C	; 12
    35e2:	8c 81       	ldd	r24, Y+4	; 0x04
    35e4:	9d 81       	ldd	r25, Y+5	; 0x05
    35e6:	ae 81       	ldd	r26, Y+6	; 0x06
    35e8:	bf 81       	ldd	r27, Y+7	; 0x07
    35ea:	01 96       	adiw	r24, 0x01	; 1
    35ec:	a1 1d       	adc	r26, r1
    35ee:	b1 1d       	adc	r27, r1
    35f0:	8c 83       	std	Y+4, r24	; 0x04
    35f2:	9d 83       	std	Y+5, r25	; 0x05
    35f4:	ae 83       	std	Y+6, r26	; 0x06
    35f6:	bf 83       	std	Y+7, r27	; 0x07
    }
  #endif // Ramps Board
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_z += st.steps[Z_AXIS];
    35f8:	c3 e4       	ldi	r28, 0x43	; 67
    35fa:	d3 e0       	ldi	r29, 0x03	; 3
    35fc:	48 85       	ldd	r20, Y+8	; 0x08
    35fe:	59 85       	ldd	r21, Y+9	; 0x09
    3600:	6a 85       	ldd	r22, Y+10	; 0x0a
    3602:	7b 85       	ldd	r23, Y+11	; 0x0b
    3604:	88 8d       	ldd	r24, Y+24	; 0x18
    3606:	99 8d       	ldd	r25, Y+25	; 0x19
    3608:	aa 8d       	ldd	r26, Y+26	; 0x1a
    360a:	bb 8d       	ldd	r27, Y+27	; 0x1b
    360c:	84 0f       	add	r24, r20
    360e:	95 1f       	adc	r25, r21
    3610:	a6 1f       	adc	r26, r22
    3612:	b7 1f       	adc	r27, r23
    3614:	88 87       	std	Y+8, r24	; 0x08
    3616:	99 87       	std	Y+9, r25	; 0x09
    3618:	aa 87       	std	Y+10, r26	; 0x0a
    361a:	bb 87       	std	Y+11, r27	; 0x0b
      st.counter_z -= st.exec_block->step_event_count;
      if (st.exec_block->direction_bits[Z_AXIS] & (1<<DIRECTION_BIT(Z_AXIS))) { sys_position[Z_AXIS]--; }
      else { sys_position[Z_AXIS]++; }
    }
  #else
    if (st.counter_z > st.exec_block->step_event_count) {
    361c:	44 85       	ldd	r20, Z+12	; 0x0c
    361e:	55 85       	ldd	r21, Z+13	; 0x0d
    3620:	66 85       	ldd	r22, Z+14	; 0x0e
    3622:	77 85       	ldd	r23, Z+15	; 0x0f
    3624:	48 17       	cp	r20, r24
    3626:	59 07       	cpc	r21, r25
    3628:	6a 07       	cpc	r22, r26
    362a:	7b 07       	cpc	r23, r27
    362c:	68 f5       	brcc	.+90     	; 0x3688 <__vector_17+0x37e>
      st.step_outbits |= (1<<Z_STEP_BIT);
    362e:	2e 85       	ldd	r18, Y+14	; 0x0e
    3630:	20 61       	ori	r18, 0x10	; 16
    3632:	2e 87       	std	Y+14, r18	; 0x0e
      st.counter_z -= st.exec_block->step_event_count;
    3634:	44 85       	ldd	r20, Z+12	; 0x0c
    3636:	55 85       	ldd	r21, Z+13	; 0x0d
    3638:	66 85       	ldd	r22, Z+14	; 0x0e
    363a:	77 85       	ldd	r23, Z+15	; 0x0f
    363c:	84 1b       	sub	r24, r20
    363e:	95 0b       	sbc	r25, r21
    3640:	a6 0b       	sbc	r26, r22
    3642:	b7 0b       	sbc	r27, r23
    3644:	88 87       	std	Y+8, r24	; 0x08
    3646:	99 87       	std	Y+9, r25	; 0x09
    3648:	aa 87       	std	Y+10, r26	; 0x0a
    364a:	bb 87       	std	Y+11, r27	; 0x0b
      if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys_position[Z_AXIS]--; }
    364c:	80 89       	ldd	r24, Z+16	; 0x10
    364e:	85 ff       	sbrs	r24, 5
    3650:	0e c0       	rjmp	.+28     	; 0x366e <__vector_17+0x364>
    3652:	e3 e4       	ldi	r30, 0x43	; 67
    3654:	fc e0       	ldi	r31, 0x0C	; 12
    3656:	80 85       	ldd	r24, Z+8	; 0x08
    3658:	91 85       	ldd	r25, Z+9	; 0x09
    365a:	a2 85       	ldd	r26, Z+10	; 0x0a
    365c:	b3 85       	ldd	r27, Z+11	; 0x0b
    365e:	01 97       	sbiw	r24, 0x01	; 1
    3660:	a1 09       	sbc	r26, r1
    3662:	b1 09       	sbc	r27, r1
    3664:	80 87       	std	Z+8, r24	; 0x08
    3666:	91 87       	std	Z+9, r25	; 0x09
    3668:	a2 87       	std	Z+10, r26	; 0x0a
    366a:	b3 87       	std	Z+11, r27	; 0x0b
    366c:	0d c0       	rjmp	.+26     	; 0x3688 <__vector_17+0x37e>
      else { sys_position[Z_AXIS]++; }
    366e:	e3 e4       	ldi	r30, 0x43	; 67
    3670:	fc e0       	ldi	r31, 0x0C	; 12
    3672:	80 85       	ldd	r24, Z+8	; 0x08
    3674:	91 85       	ldd	r25, Z+9	; 0x09
    3676:	a2 85       	ldd	r26, Z+10	; 0x0a
    3678:	b3 85       	ldd	r27, Z+11	; 0x0b
    367a:	01 96       	adiw	r24, 0x01	; 1
    367c:	a1 1d       	adc	r26, r1
    367e:	b1 1d       	adc	r27, r1
    3680:	80 87       	std	Z+8, r24	; 0x08
    3682:	91 87       	std	Z+9, r25	; 0x09
    3684:	a2 87       	std	Z+10, r26	; 0x0a
    3686:	b3 87       	std	Z+11, r27	; 0x0b
  // During a homing cycle, lock out and prevent desired axes from moving.
  #ifdef DEFAULTS_RAMPS_BOARD
    for (i = 0; i < N_AXIS; i++)
    if (sys.state == STATE_HOMING) { st.step_outbits[i] &= sys.homing_axis_lock[i]; }
  #else
    if (sys.state == STATE_HOMING) { st.step_outbits &= sys.homing_axis_lock; }
    3688:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    368c:	84 30       	cpi	r24, 0x04	; 4
    368e:	39 f4       	brne	.+14     	; 0x369e <__vector_17+0x394>
    3690:	e3 e4       	ldi	r30, 0x43	; 67
    3692:	f3 e0       	ldi	r31, 0x03	; 3
    3694:	96 85       	ldd	r25, Z+14	; 0x0e
    3696:	80 91 24 0c 	lds	r24, 0x0C24	; 0x800c24 <sys+0x6>
    369a:	89 23       	and	r24, r25
    369c:	86 87       	std	Z+14, r24	; 0x0e
  #endif // Ramps Board
  st.step_count--; // Decrement step events count
    369e:	e3 e4       	ldi	r30, 0x43	; 67
    36a0:	f3 e0       	ldi	r31, 0x03	; 3
    36a2:	84 8d       	ldd	r24, Z+28	; 0x1c
    36a4:	95 8d       	ldd	r25, Z+29	; 0x1d
    36a6:	01 97       	sbiw	r24, 0x01	; 1
    36a8:	95 8f       	std	Z+29, r25	; 0x1d
    36aa:	84 8f       	std	Z+28, r24	; 0x1c
  if (st.step_count == 0) {
    36ac:	89 2b       	or	r24, r25
    36ae:	69 f4       	brne	.+26     	; 0x36ca <__vector_17+0x3c0>
    // Segment is complete. Discard current segment and advance segment indexing.
    st.exec_segment = NULL;
    36b0:	10 92 65 03 	sts	0x0365, r1	; 0x800365 <st+0x22>
    36b4:	10 92 64 03 	sts	0x0364, r1	; 0x800364 <st+0x21>
    if ( ++segment_buffer_tail == SEGMENT_BUFFER_SIZE) { segment_buffer_tail = 0; }
    36b8:	80 91 42 03 	lds	r24, 0x0342	; 0x800342 <segment_buffer_tail>
    36bc:	8f 5f       	subi	r24, 0xFF	; 255
    36be:	80 93 42 03 	sts	0x0342, r24	; 0x800342 <segment_buffer_tail>
    36c2:	8a 30       	cpi	r24, 0x0A	; 10
    36c4:	11 f4       	brne	.+4      	; 0x36ca <__vector_17+0x3c0>
    36c6:	10 92 42 03 	sts	0x0342, r1	; 0x800342 <segment_buffer_tail>
  }
  #ifdef DEFAULTS_RAMPS_BOARD
    for (i = 0; i < N_AXIS; i++)
      st.step_outbits[i] ^= step_port_invert_mask[i];  // Apply step port invert mask
  #else
    st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask
    36ca:	e3 e4       	ldi	r30, 0x43	; 67
    36cc:	f3 e0       	ldi	r31, 0x03	; 3
    36ce:	96 85       	ldd	r25, Z+14	; 0x0e
    36d0:	80 91 3f 03 	lds	r24, 0x033F	; 0x80033f <step_port_invert_mask>
    36d4:	89 27       	eor	r24, r25
    36d6:	86 87       	std	Z+14, r24	; 0x0e
  #endif // Ramps Board
  busy = false;
    36d8:	10 92 3d 03 	sts	0x033D, r1	; 0x80033d <busy>
}
    36dc:	ff 91       	pop	r31
    36de:	ef 91       	pop	r30
    36e0:	df 91       	pop	r29
    36e2:	cf 91       	pop	r28
    36e4:	bf 91       	pop	r27
    36e6:	af 91       	pop	r26
    36e8:	9f 91       	pop	r25
    36ea:	8f 91       	pop	r24
    36ec:	7f 91       	pop	r23
    36ee:	6f 91       	pop	r22
    36f0:	5f 91       	pop	r21
    36f2:	4f 91       	pop	r20
    36f4:	3f 91       	pop	r19
    36f6:	2f 91       	pop	r18
    36f8:	0f 90       	pop	r0
    36fa:	0b be       	out	0x3b, r0	; 59
    36fc:	0f 90       	pop	r0
    36fe:	0f be       	out	0x3f, r0	; 63
    3700:	0f 90       	pop	r0
    3702:	1f 90       	pop	r1
    3704:	18 95       	reti

00003706 <__vector_23>:
*/
// This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute
// a step. This ISR resets the motor port after a short period (settings.pulse_microseconds)
// completing one step cycle.
ISR(TIMER0_OVF_vect)
{
    3706:	1f 92       	push	r1
    3708:	0f 92       	push	r0
    370a:	0f b6       	in	r0, 0x3f	; 63
    370c:	0f 92       	push	r0
    370e:	11 24       	eor	r1, r1
    3710:	8f 93       	push	r24
    3712:	9f 93       	push	r25
  #ifdef DEFAULTS_RAMPS_BOARD
    STEP_PORT(0) = (STEP_PORT(0) & ~(1 << STEP_BIT(0))) | step_port_invert_mask[0];
    STEP_PORT(1) = (STEP_PORT(1) & ~(1 << STEP_BIT(1))) | step_port_invert_mask[1];
    STEP_PORT(2) = (STEP_PORT(2) & ~(1 << STEP_BIT(2))) | step_port_invert_mask[2];
  #else
    STEP_PORT = (STEP_PORT & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK);
    3714:	82 b1       	in	r24, 0x02	; 2
    3716:	90 91 3f 03 	lds	r25, 0x033F	; 0x80033f <step_port_invert_mask>
    371a:	9c 71       	andi	r25, 0x1C	; 28
    371c:	83 7e       	andi	r24, 0xE3	; 227
    371e:	89 2b       	or	r24, r25
    3720:	82 b9       	out	0x02, r24	; 2
  #endif // Ramps Board
  TCCR0B = 0; // Disable Timer0 to prevent re-entering this interrupt when it's not needed.
    3722:	15 bc       	out	0x25, r1	; 37
}
    3724:	9f 91       	pop	r25
    3726:	8f 91       	pop	r24
    3728:	0f 90       	pop	r0
    372a:	0f be       	out	0x3f, r0	; 63
    372c:	0f 90       	pop	r0
    372e:	1f 90       	pop	r1
    3730:	18 95       	reti

00003732 <st_generate_step_dir_invert_masks>:
#endif


// Generates the step and direction port invert masks used in the Stepper Interrupt Driver.
void st_generate_step_dir_invert_masks()
{
    3732:	ef 92       	push	r14
    3734:	ff 92       	push	r15
    3736:	0f 93       	push	r16
    3738:	1f 93       	push	r17
    373a:	cf 93       	push	r28
    373c:	df 93       	push	r29

      if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask[idx] = get_direction_pin_mask(idx); }
      else { dir_port_invert_mask[idx] = 0; }
    }
  #else
    step_port_invert_mask = 0;
    373e:	10 92 3f 03 	sts	0x033F, r1	; 0x80033f <step_port_invert_mask>
    dir_port_invert_mask = 0;
    3742:	10 92 3e 03 	sts	0x033E, r1	; 0x80033e <dir_port_invert_mask>
    3746:	c0 e0       	ldi	r28, 0x00	; 0
    3748:	d0 e0       	ldi	r29, 0x00	; 0
    for (idx=0; idx<N_AXIS; idx++) {
      if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    374a:	00 ed       	ldi	r16, 0xD0	; 208
    374c:	1e e0       	ldi	r17, 0x0E	; 14
    374e:	ec 2e       	mov	r14, r28
    3750:	fc 2e       	mov	r15, r28
    3752:	f8 01       	movw	r30, r16
    3754:	81 a9       	ldd	r24, Z+49	; 0x31
    3756:	90 e0       	ldi	r25, 0x00	; 0
    3758:	0c 2e       	mov	r0, r28
    375a:	02 c0       	rjmp	.+4      	; 0x3760 <st_generate_step_dir_invert_masks+0x2e>
    375c:	95 95       	asr	r25
    375e:	87 95       	ror	r24
    3760:	0a 94       	dec	r0
    3762:	e2 f7       	brpl	.-8      	; 0x375c <st_generate_step_dir_invert_masks+0x2a>
    3764:	80 ff       	sbrs	r24, 0
    3766:	08 c0       	rjmp	.+16     	; 0x3778 <st_generate_step_dir_invert_masks+0x46>
    3768:	8c 2f       	mov	r24, r28
    376a:	0e 94 d1 27 	call	0x4fa2	; 0x4fa2 <get_step_pin_mask>
    376e:	90 91 3f 03 	lds	r25, 0x033F	; 0x80033f <step_port_invert_mask>
    3772:	89 2b       	or	r24, r25
    3774:	80 93 3f 03 	sts	0x033F, r24	; 0x80033f <step_port_invert_mask>
      if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    3778:	f8 01       	movw	r30, r16
    377a:	82 a9       	ldd	r24, Z+50	; 0x32
    377c:	90 e0       	ldi	r25, 0x00	; 0
    377e:	02 c0       	rjmp	.+4      	; 0x3784 <st_generate_step_dir_invert_masks+0x52>
    3780:	95 95       	asr	r25
    3782:	87 95       	ror	r24
    3784:	fa 94       	dec	r15
    3786:	e2 f7       	brpl	.-8      	; 0x3780 <st_generate_step_dir_invert_masks+0x4e>
    3788:	80 ff       	sbrs	r24, 0
    378a:	08 c0       	rjmp	.+16     	; 0x379c <st_generate_step_dir_invert_masks+0x6a>
    378c:	8e 2d       	mov	r24, r14
    378e:	0e 94 db 27 	call	0x4fb6	; 0x4fb6 <get_direction_pin_mask>
    3792:	90 91 3e 03 	lds	r25, 0x033E	; 0x80033e <dir_port_invert_mask>
    3796:	89 2b       	or	r24, r25
    3798:	80 93 3e 03 	sts	0x033E, r24	; 0x80033e <dir_port_invert_mask>
    379c:	21 96       	adiw	r28, 0x01	; 1
      else { dir_port_invert_mask[idx] = 0; }
    }
  #else
    step_port_invert_mask = 0;
    dir_port_invert_mask = 0;
    for (idx=0; idx<N_AXIS; idx++) {
    379e:	c3 30       	cpi	r28, 0x03	; 3
    37a0:	d1 05       	cpc	r29, r1
    37a2:	a9 f6       	brne	.-86     	; 0x374e <st_generate_step_dir_invert_masks+0x1c>
      if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
      if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    }
  #endif // Ramps Board
}
    37a4:	df 91       	pop	r29
    37a6:	cf 91       	pop	r28
    37a8:	1f 91       	pop	r17
    37aa:	0f 91       	pop	r16
    37ac:	ff 90       	pop	r15
    37ae:	ef 90       	pop	r14
    37b0:	08 95       	ret

000037b2 <st_reset>:


// Reset and clear stepper subsystem variables
void st_reset()
{
    37b2:	cf 93       	push	r28
    37b4:	df 93       	push	r29
  #ifdef DEFAULTS_RAMPS_BOARD
    uint8_t idx;
  #endif // Ramps Board

  // Initialize stepper driver idle state.
  st_go_idle();
    37b6:	7b dd       	rcall	.-1290   	; 0x32ae <st_go_idle>

  // Initialize stepper algorithm variables.
  memset(&prep, 0, sizeof(st_prep_t));
    37b8:	81 e3       	ldi	r24, 0x31	; 49
    37ba:	e8 e0       	ldi	r30, 0x08	; 8
    37bc:	f3 e0       	ldi	r31, 0x03	; 3
    37be:	df 01       	movw	r26, r30
    37c0:	1d 92       	st	X+, r1
    37c2:	8a 95       	dec	r24
    37c4:	e9 f7       	brne	.-6      	; 0x37c0 <st_reset+0xe>
  memset(&st, 0, sizeof(stepper_t));
    37c6:	c3 e4       	ldi	r28, 0x43	; 67
    37c8:	d3 e0       	ldi	r29, 0x03	; 3
    37ca:	83 e2       	ldi	r24, 0x23	; 35
    37cc:	fe 01       	movw	r30, r28
    37ce:	11 92       	st	Z+, r1
    37d0:	8a 95       	dec	r24
    37d2:	e9 f7       	brne	.-6      	; 0x37ce <st_reset+0x1c>
  st.exec_segment = NULL;
  pl_block = NULL;  // Planner block pointer used by segment buffer
    37d4:	10 92 3c 03 	sts	0x033C, r1	; 0x80033c <pl_block+0x1>
    37d8:	10 92 3b 03 	sts	0x033B, r1	; 0x80033b <pl_block>
  segment_buffer_tail = 0;
    37dc:	10 92 42 03 	sts	0x0342, r1	; 0x800342 <segment_buffer_tail>
  segment_buffer_head = 0; // empty = tail
    37e0:	10 92 41 03 	sts	0x0341, r1	; 0x800341 <segment_buffer_head>
  segment_next_head = 1;
    37e4:	81 e0       	ldi	r24, 0x01	; 1
    37e6:	80 93 40 03 	sts	0x0340, r24	; 0x800340 <segment_next_head>
  busy = false;
    37ea:	10 92 3d 03 	sts	0x033D, r1	; 0x80033d <busy>

  st_generate_step_dir_invert_masks();
    37ee:	a1 df       	rcall	.-190    	; 0x3732 <st_generate_step_dir_invert_masks>
    DIRECTION_PORT(1) = (DIRECTION_PORT(1) & ~(1 << DIRECTION_BIT(1))) | dir_port_invert_mask[1];
  
    STEP_PORT(2) = (STEP_PORT(2) & ~(1 << STEP_BIT(2))) | step_port_invert_mask[2];
    DIRECTION_PORT(2) = (DIRECTION_PORT(2) & ~(1 << DIRECTION_BIT(2))) | dir_port_invert_mask[2];
  #else
    st.dir_outbits = dir_port_invert_mask; // Initialize direction bits to default.
    37f0:	80 91 3e 03 	lds	r24, 0x033E	; 0x80033e <dir_port_invert_mask>
    37f4:	8f 87       	std	Y+15, r24	; 0x0f

    // Initialize step and direction port pins.
    STEP_PORT = (STEP_PORT & ~STEP_MASK) | step_port_invert_mask;
    37f6:	82 b1       	in	r24, 0x02	; 2
    37f8:	83 7e       	andi	r24, 0xE3	; 227
    37fa:	90 91 3f 03 	lds	r25, 0x033F	; 0x80033f <step_port_invert_mask>
    37fe:	89 2b       	or	r24, r25
    3800:	82 b9       	out	0x02, r24	; 2
    DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | dir_port_invert_mask;
    3802:	88 b1       	in	r24, 0x08	; 8
    3804:	8f 71       	andi	r24, 0x1F	; 31
    3806:	90 91 3e 03 	lds	r25, 0x033E	; 0x80033e <dir_port_invert_mask>
    380a:	89 2b       	or	r24, r25
    380c:	88 b9       	out	0x08, r24	; 8
  #endif // Ramps Board
}
    380e:	df 91       	pop	r29
    3810:	cf 91       	pop	r28
    3812:	08 95       	ret

00003814 <stepper_init>:
  
    DIRECTION_DDR(0) |= 1<<DIRECTION_BIT(0);
    DIRECTION_DDR(1) |= 1<<DIRECTION_BIT(1);
    DIRECTION_DDR(2) |= 1<<DIRECTION_BIT(2);
  #else
    STEP_DDR |= STEP_MASK;
    3814:	81 b1       	in	r24, 0x01	; 1
    3816:	8c 61       	ori	r24, 0x1C	; 28
    3818:	81 b9       	out	0x01, r24	; 1
    STEPPERS_DISABLE_DDR |= 1<<STEPPERS_DISABLE_BIT;
    381a:	27 9a       	sbi	0x04, 7	; 4
    DIRECTION_DDR |= DIRECTION_MASK;
    381c:	87 b1       	in	r24, 0x07	; 7
    381e:	80 6e       	ori	r24, 0xE0	; 224
    3820:	87 b9       	out	0x07, r24	; 7
  #endif // Ramps Board

  // Configure Timer 1: Stepper Driver Interrupt
  TCCR1B &= ~(1<<WGM13); // waveform generation = 0100 = CTC
    3822:	e1 e8       	ldi	r30, 0x81	; 129
    3824:	f0 e0       	ldi	r31, 0x00	; 0
    3826:	80 81       	ld	r24, Z
    3828:	8f 7e       	andi	r24, 0xEF	; 239
    382a:	80 83       	st	Z, r24
  TCCR1B |=  (1<<WGM12);
    382c:	80 81       	ld	r24, Z
    382e:	88 60       	ori	r24, 0x08	; 8
    3830:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<WGM11) | (1<<WGM10));
    3832:	e0 e8       	ldi	r30, 0x80	; 128
    3834:	f0 e0       	ldi	r31, 0x00	; 0
    3836:	80 81       	ld	r24, Z
    3838:	8c 7f       	andi	r24, 0xFC	; 252
    383a:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<COM1A1) | (1<<COM1A0) | (1<<COM1B1) | (1<<COM1B0)); // Disconnect OC1 output
    383c:	80 81       	ld	r24, Z
    383e:	8f 70       	andi	r24, 0x0F	; 15
    3840:	80 83       	st	Z, r24
  // TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Set in st_go_idle().
  // TIMSK1 &= ~(1<<OCIE1A);  // Set in st_go_idle().

  // Configure Timer 0: Stepper Port Reset Interrupt
  TIMSK0 &= ~((1<<OCIE0B) | (1<<OCIE0A) | (1<<TOIE0)); // Disconnect OC0 outputs and OVF interrupt.
    3842:	ee e6       	ldi	r30, 0x6E	; 110
    3844:	f0 e0       	ldi	r31, 0x00	; 0
    3846:	80 81       	ld	r24, Z
    3848:	88 7f       	andi	r24, 0xF8	; 248
    384a:	80 83       	st	Z, r24
  TCCR0A = 0; // Normal operation
    384c:	14 bc       	out	0x24, r1	; 36
  TCCR0B = 0; // Disable Timer0 until needed
    384e:	15 bc       	out	0x25, r1	; 37
  TIMSK0 |= (1<<TOIE0); // Enable Timer0 overflow interrupt
    3850:	80 81       	ld	r24, Z
    3852:	81 60       	ori	r24, 0x01	; 1
    3854:	80 83       	st	Z, r24
    3856:	08 95       	ret

00003858 <st_update_plan_block_parameters>:
}


// Called by planner_recalculate() when the executing block is updated by the new plan.
void st_update_plan_block_parameters()
{
    3858:	cf 93       	push	r28
    385a:	df 93       	push	r29
  if (pl_block != NULL) { // Ignore if at start of a new block.
    385c:	c0 91 3b 03 	lds	r28, 0x033B	; 0x80033b <pl_block>
    3860:	d0 91 3c 03 	lds	r29, 0x033C	; 0x80033c <pl_block+0x1>
    3864:	20 97       	sbiw	r28, 0x00	; 0
    3866:	a9 f0       	breq	.+42     	; 0x3892 <st_update_plan_block_parameters+0x3a>
    prep.recalculate_flag |= PREP_FLAG_RECALCULATE;
    3868:	e8 e0       	ldi	r30, 0x08	; 8
    386a:	f3 e0       	ldi	r31, 0x03	; 3
    386c:	81 81       	ldd	r24, Z+1	; 0x01
    386e:	81 60       	ori	r24, 0x01	; 1
    3870:	81 83       	std	Z+1, r24	; 0x01
    pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
    3872:	67 89       	ldd	r22, Z+23	; 0x17
    3874:	70 8d       	ldd	r23, Z+24	; 0x18
    3876:	81 8d       	ldd	r24, Z+25	; 0x19
    3878:	92 8d       	ldd	r25, Z+26	; 0x1a
    387a:	9b 01       	movw	r18, r22
    387c:	ac 01       	movw	r20, r24
    387e:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    3882:	6e 8b       	std	Y+22, r22	; 0x16
    3884:	7f 8b       	std	Y+23, r23	; 0x17
    3886:	88 8f       	std	Y+24, r24	; 0x18
    3888:	99 8f       	std	Y+25, r25	; 0x19
    pl_block = NULL; // Flag st_prep_segment() to load and check active velocity profile.
    388a:	10 92 3c 03 	sts	0x033C, r1	; 0x80033c <pl_block+0x1>
    388e:	10 92 3b 03 	sts	0x033B, r1	; 0x80033b <pl_block>
  }
}
    3892:	df 91       	pop	r29
    3894:	cf 91       	pop	r28
    3896:	08 95       	ret

00003898 <st_prep_buffer>:
   longer than the time it takes the stepper algorithm to empty it before refilling it.
   Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer()
{
    3898:	2f 92       	push	r2
    389a:	3f 92       	push	r3
    389c:	4f 92       	push	r4
    389e:	5f 92       	push	r5
    38a0:	6f 92       	push	r6
    38a2:	7f 92       	push	r7
    38a4:	8f 92       	push	r8
    38a6:	9f 92       	push	r9
    38a8:	af 92       	push	r10
    38aa:	bf 92       	push	r11
    38ac:	cf 92       	push	r12
    38ae:	df 92       	push	r13
    38b0:	ef 92       	push	r14
    38b2:	ff 92       	push	r15
    38b4:	0f 93       	push	r16
    38b6:	1f 93       	push	r17
    38b8:	cf 93       	push	r28
    38ba:	df 93       	push	r29
    38bc:	cd b7       	in	r28, 0x3d	; 61
    38be:	de b7       	in	r29, 0x3e	; 62
    38c0:	ec 97       	sbiw	r28, 0x3c	; 60
    38c2:	0f b6       	in	r0, 0x3f	; 63
    38c4:	f8 94       	cli
    38c6:	de bf       	out	0x3e, r29	; 62
    38c8:	0f be       	out	0x3f, r0	; 63
    38ca:	cd bf       	out	0x3d, r28	; 61
  // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }
    38cc:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    38d0:	80 ff       	sbrs	r24, 0
    38d2:	02 c0       	rjmp	.+4      	; 0x38d8 <st_prep_buffer+0x40>
    38d4:	0c 94 7c 24 	jmp	0x48f8	; 0x48f8 <st_prep_buffer+0x1060>
      if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) { pl_block = plan_get_system_motion_block(); }
      else { pl_block = plan_get_current_block(); }
      if (pl_block == NULL) { return; } // No planner blocks. Exit.

      // Check if we need to only recompute the velocity profile or load a new block.
      if (prep.recalculate_flag & PREP_FLAG_RECALCULATE) {
    38d8:	0f 2e       	mov	r0, r31
    38da:	f8 e0       	ldi	r31, 0x08	; 8
    38dc:	6f 2e       	mov	r6, r31
    38de:	f3 e0       	ldi	r31, 0x03	; 3
    38e0:	7f 2e       	mov	r7, r31
    38e2:	f0 2d       	mov	r31, r0
          mm_var = mm_remaining - prep.maximum_speed*time_var;
          if (mm_var < prep.decelerate_after) { // End of cruise.
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
    38e4:	22 e0       	ldi	r18, 0x02	; 2
    38e6:	2a af       	std	Y+58, r18	; 0x3a
    38e8:	29 af       	std	Y+57, r18	; 0x39
    38ea:	cd c7       	rjmp	.+3994   	; 0x4886 <st_prep_buffer+0xfee>
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }

  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.

    // Determine if we need to load a new planner block or if the block needs to be recomputed.
    if (pl_block == NULL) {
    38ec:	80 91 3b 03 	lds	r24, 0x033B	; 0x80033b <pl_block>
    38f0:	90 91 3c 03 	lds	r25, 0x033C	; 0x80033c <pl_block+0x1>
    38f4:	89 2b       	or	r24, r25
    38f6:	09 f0       	breq	.+2      	; 0x38fa <st_prep_buffer+0x62>
    38f8:	11 c3       	rjmp	.+1570   	; 0x3f1c <st_prep_buffer+0x684>

      // Query planner for a queued block
      if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) { pl_block = plan_get_system_motion_block(); }
    38fa:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    38fe:	82 ff       	sbrs	r24, 2
    3900:	07 c0       	rjmp	.+14     	; 0x3910 <st_prep_buffer+0x78>
    3902:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <plan_get_system_motion_block>
    3906:	90 93 3c 03 	sts	0x033C, r25	; 0x80033c <pl_block+0x1>
    390a:	80 93 3b 03 	sts	0x033B, r24	; 0x80033b <pl_block>
    390e:	06 c0       	rjmp	.+12     	; 0x391c <st_prep_buffer+0x84>
      else { pl_block = plan_get_current_block(); }
    3910:	0e 94 85 29 	call	0x530a	; 0x530a <plan_get_current_block>
    3914:	90 93 3c 03 	sts	0x033C, r25	; 0x80033c <pl_block+0x1>
    3918:	80 93 3b 03 	sts	0x033B, r24	; 0x80033b <pl_block>
      if (pl_block == NULL) { return; } // No planner blocks. Exit.
    391c:	e0 90 3b 03 	lds	r14, 0x033B	; 0x80033b <pl_block>
    3920:	f0 90 3c 03 	lds	r15, 0x033C	; 0x80033c <pl_block+0x1>
    3924:	e1 14       	cp	r14, r1
    3926:	f1 04       	cpc	r15, r1
    3928:	09 f4       	brne	.+2      	; 0x392c <st_prep_buffer+0x94>
    392a:	e6 c7       	rjmp	.+4044   	; 0x48f8 <st_prep_buffer+0x1060>

      // Check if we need to only recompute the velocity profile or load a new block.
      if (prep.recalculate_flag & PREP_FLAG_RECALCULATE) {
    392c:	d3 01       	movw	r26, r6
    392e:	11 96       	adiw	r26, 0x01	; 1
    3930:	1c 91       	ld	r17, X
    3932:	11 97       	sbiw	r26, 0x01	; 1
    3934:	81 2f       	mov	r24, r17
    3936:	81 70       	andi	r24, 0x01	; 1
    3938:	10 ff       	sbrs	r17, 0
    393a:	03 c0       	rjmp	.+6      	; 0x3942 <st_prep_buffer+0xaa>

        #ifdef PARKING_ENABLE
          if (prep.recalculate_flag & PREP_FLAG_PARKING) { prep.recalculate_flag &= ~(PREP_FLAG_RECALCULATE); }
          else { prep.recalculate_flag = false; }
        #else
          prep.recalculate_flag = false;
    393c:	11 96       	adiw	r26, 0x01	; 1
    393e:	1c 92       	st	X, r1
    3940:	eb c0       	rjmp	.+470    	; 0x3b18 <st_prep_buffer+0x280>


// Increments the step segment buffer block data ring buffer.
static uint8_t st_next_block_index(uint8_t block_index)
{
  block_index++;
    3942:	f3 01       	movw	r30, r6
    3944:	90 81       	ld	r25, Z
    3946:	9f 5f       	subi	r25, 0xFF	; 255
  if ( block_index == (SEGMENT_BUFFER_SIZE-1) ) { return(0); }
    3948:	99 30       	cpi	r25, 0x09	; 9
    394a:	09 f0       	breq	.+2      	; 0x394e <st_prep_buffer+0xb6>
  return(block_index);
    394c:	89 2f       	mov	r24, r25
        #endif

      } else {

        // Load the Bresenham stepping data for the block.
        prep.st_block_index = st_next_block_index(prep.st_block_index);
    394e:	d3 01       	movw	r26, r6
    3950:	8c 93       	st	X, r24

        // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
        // when the segment buffer completes the planner block, it may be discarded when the
        // segment buffer finishes the prepped block, but the stepper ISR is still executing it.
        st_prep_block = &st_block_buffer[prep.st_block_index];
    3952:	90 e0       	ldi	r25, 0x00	; 0
    3954:	fc 01       	movw	r30, r24
    3956:	ee 0f       	add	r30, r30
    3958:	ff 1f       	adc	r31, r31
    395a:	9f 01       	movw	r18, r30
    395c:	22 0f       	add	r18, r18
    395e:	33 1f       	adc	r19, r19
    3960:	22 0f       	add	r18, r18
    3962:	33 1f       	adc	r19, r19
    3964:	22 0f       	add	r18, r18
    3966:	33 1f       	adc	r19, r19
    3968:	e2 0f       	add	r30, r18
    396a:	f3 1f       	adc	r31, r19
    396c:	ea 54       	subi	r30, 0x4A	; 74
    396e:	fc 4f       	sbci	r31, 0xFC	; 252
    3970:	f0 93 3a 03 	sts	0x033A, r31	; 0x80033a <st_prep_block+0x1>
    3974:	e0 93 39 03 	sts	0x0339, r30	; 0x800339 <st_prep_block>
        #ifdef DEFAULTS_RAMPS_BOARD
          for (idx=0; idx<N_AXIS; idx++) {
            st_prep_block->direction_bits[idx] = pl_block->direction_bits[idx];
          }
        #else
          st_prep_block->direction_bits = pl_block->direction_bits;
    3978:	d7 01       	movw	r26, r14
    397a:	50 96       	adiw	r26, 0x10	; 16
    397c:	2c 91       	ld	r18, X
    397e:	50 97       	sbiw	r26, 0x10	; 16
    3980:	20 8b       	std	Z+16, r18	; 0x10
    3982:	97 01       	movw	r18, r14
    3984:	24 5f       	subi	r18, 0xF4	; 244
    3986:	3f 4f       	sbci	r19, 0xFF	; 255
    3988:	fa 82       	std	Y+2, r15	; 0x02
    398a:	e9 82       	std	Y+1, r14	; 0x01
          st_prep_block->step_event_count = (pl_block->step_event_count << 1);
        #else
          // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS
          // level, such that we never divide beyond the original data anywhere in the algorithm.
          // If the original data is divided, we can lose a step from integer roundoff.
          for (idx=0; idx<N_AXIS; idx++) { st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_AMASS_LEVEL; }
    398c:	4d 91       	ld	r20, X+
    398e:	5d 91       	ld	r21, X+
    3990:	6d 91       	ld	r22, X+
    3992:	7d 91       	ld	r23, X+
    3994:	44 0f       	add	r20, r20
    3996:	55 1f       	adc	r21, r21
    3998:	66 1f       	adc	r22, r22
    399a:	77 1f       	adc	r23, r23
    399c:	44 0f       	add	r20, r20
    399e:	55 1f       	adc	r21, r21
    39a0:	66 1f       	adc	r22, r22
    39a2:	77 1f       	adc	r23, r23
    39a4:	44 0f       	add	r20, r20
    39a6:	55 1f       	adc	r21, r21
    39a8:	66 1f       	adc	r22, r22
    39aa:	77 1f       	adc	r23, r23
    39ac:	41 93       	st	Z+, r20
    39ae:	51 93       	st	Z+, r21
    39b0:	61 93       	st	Z+, r22
    39b2:	71 93       	st	Z+, r23
    39b4:	a2 17       	cp	r26, r18
    39b6:	b3 07       	cpc	r27, r19
    39b8:	49 f7       	brne	.-46     	; 0x398c <st_prep_buffer+0xf4>
    39ba:	e9 80       	ldd	r14, Y+1	; 0x01
    39bc:	fa 80       	ldd	r15, Y+2	; 0x02
          st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
    39be:	88 0f       	add	r24, r24
    39c0:	99 1f       	adc	r25, r25
    39c2:	fc 01       	movw	r30, r24
    39c4:	ee 0f       	add	r30, r30
    39c6:	ff 1f       	adc	r31, r31
    39c8:	ee 0f       	add	r30, r30
    39ca:	ff 1f       	adc	r31, r31
    39cc:	ee 0f       	add	r30, r30
    39ce:	ff 1f       	adc	r31, r31
    39d0:	8e 0f       	add	r24, r30
    39d2:	9f 1f       	adc	r25, r31
    39d4:	9c 01       	movw	r18, r24
    39d6:	2a 54       	subi	r18, 0x4A	; 74
    39d8:	3c 4f       	sbci	r19, 0xFC	; 252
    39da:	f7 01       	movw	r30, r14
    39dc:	84 85       	ldd	r24, Z+12	; 0x0c
    39de:	95 85       	ldd	r25, Z+13	; 0x0d
    39e0:	a6 85       	ldd	r26, Z+14	; 0x0e
    39e2:	b7 85       	ldd	r27, Z+15	; 0x0f
    39e4:	88 0f       	add	r24, r24
    39e6:	99 1f       	adc	r25, r25
    39e8:	aa 1f       	adc	r26, r26
    39ea:	bb 1f       	adc	r27, r27
    39ec:	88 0f       	add	r24, r24
    39ee:	99 1f       	adc	r25, r25
    39f0:	aa 1f       	adc	r26, r26
    39f2:	bb 1f       	adc	r27, r27
    39f4:	88 0f       	add	r24, r24
    39f6:	99 1f       	adc	r25, r25
    39f8:	aa 1f       	adc	r26, r26
    39fa:	bb 1f       	adc	r27, r27
    39fc:	f9 01       	movw	r30, r18
    39fe:	84 87       	std	Z+12, r24	; 0x0c
    3a00:	95 87       	std	Z+13, r25	; 0x0d
    3a02:	a6 87       	std	Z+14, r26	; 0x0e
    3a04:	b7 87       	std	Z+15, r27	; 0x0f
        #endif

        // Initialize segment buffer data for generating the segments.
        prep.steps_remaining = (float)pl_block->step_event_count;
    3a06:	d7 01       	movw	r26, r14
    3a08:	1c 96       	adiw	r26, 0x0c	; 12
    3a0a:	6d 91       	ld	r22, X+
    3a0c:	7d 91       	ld	r23, X+
    3a0e:	8d 91       	ld	r24, X+
    3a10:	9c 91       	ld	r25, X
    3a12:	1f 97       	sbiw	r26, 0x0f	; 15
    3a14:	0e 94 09 40 	call	0x8012	; 0x8012 <__floatunsisf>
    3a18:	f3 01       	movw	r30, r6
    3a1a:	66 83       	std	Z+6, r22	; 0x06
    3a1c:	77 83       	std	Z+7, r23	; 0x07
    3a1e:	80 87       	std	Z+8, r24	; 0x08
    3a20:	91 87       	std	Z+9, r25	; 0x09
        prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
    3a22:	d7 01       	movw	r26, r14
    3a24:	92 96       	adiw	r26, 0x22	; 34
    3a26:	2d 91       	ld	r18, X+
    3a28:	3d 91       	ld	r19, X+
    3a2a:	4d 91       	ld	r20, X+
    3a2c:	5c 91       	ld	r21, X
    3a2e:	95 97       	sbiw	r26, 0x25	; 37
    3a30:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <__divsf3>
    3a34:	9b 01       	movw	r18, r22
    3a36:	ac 01       	movw	r20, r24
    3a38:	f3 01       	movw	r30, r6
    3a3a:	62 87       	std	Z+10, r22	; 0x0a
    3a3c:	73 87       	std	Z+11, r23	; 0x0b
    3a3e:	84 87       	std	Z+12, r24	; 0x0c
    3a40:	95 87       	std	Z+13, r25	; 0x0d
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
    3a42:	60 e0       	ldi	r22, 0x00	; 0
    3a44:	70 e0       	ldi	r23, 0x00	; 0
    3a46:	80 ea       	ldi	r24, 0xA0	; 160
    3a48:	9f e3       	ldi	r25, 0x3F	; 63
    3a4a:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <__divsf3>
    3a4e:	d3 01       	movw	r26, r6
    3a50:	1e 96       	adiw	r26, 0x0e	; 14
    3a52:	6d 93       	st	X+, r22
    3a54:	7d 93       	st	X+, r23
    3a56:	8d 93       	st	X+, r24
    3a58:	9c 93       	st	X, r25
    3a5a:	51 97       	sbiw	r26, 0x11	; 17
        prep.dt_remainder = 0.0; // Reset for new segment block
    3a5c:	f3 01       	movw	r30, r6
    3a5e:	12 82       	std	Z+2, r1	; 0x02
    3a60:	13 82       	std	Z+3, r1	; 0x03
    3a62:	14 82       	std	Z+4, r1	; 0x04
    3a64:	15 82       	std	Z+5, r1	; 0x05

        if ((sys.step_control & STEP_CONTROL_EXECUTE_HOLD) || (prep.recalculate_flag & PREP_FLAG_DECEL_OVERRIDE)) {
    3a66:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    3a6a:	81 fd       	sbrc	r24, 1
    3a6c:	02 c0       	rjmp	.+4      	; 0x3a72 <st_prep_buffer+0x1da>
    3a6e:	13 ff       	sbrs	r17, 3
    3a70:	1b c0       	rjmp	.+54     	; 0x3aa8 <st_prep_buffer+0x210>
          // New block loaded mid-hold. Override planner block entry speed to enforce deceleration.
          prep.current_speed = prep.exit_speed;
    3a72:	d3 01       	movw	r26, r6
    3a74:	5f 96       	adiw	r26, 0x1f	; 31
    3a76:	6d 91       	ld	r22, X+
    3a78:	7d 91       	ld	r23, X+
    3a7a:	8d 91       	ld	r24, X+
    3a7c:	9c 91       	ld	r25, X
    3a7e:	92 97       	sbiw	r26, 0x22	; 34
    3a80:	f3 01       	movw	r30, r6
    3a82:	67 8b       	std	Z+23, r22	; 0x17
    3a84:	70 8f       	std	Z+24, r23	; 0x18
    3a86:	81 8f       	std	Z+25, r24	; 0x19
    3a88:	92 8f       	std	Z+26, r25	; 0x1a
          pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed;
    3a8a:	9b 01       	movw	r18, r22
    3a8c:	ac 01       	movw	r20, r24
    3a8e:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    3a92:	d7 01       	movw	r26, r14
    3a94:	56 96       	adiw	r26, 0x16	; 22
    3a96:	6d 93       	st	X+, r22
    3a98:	7d 93       	st	X+, r23
    3a9a:	8d 93       	st	X+, r24
    3a9c:	9c 93       	st	X, r25
    3a9e:	59 97       	sbiw	r26, 0x19	; 25
          prep.recalculate_flag &= ~(PREP_FLAG_DECEL_OVERRIDE);
    3aa0:	17 7f       	andi	r17, 0xF7	; 247
    3aa2:	f3 01       	movw	r30, r6
    3aa4:	11 83       	std	Z+1, r17	; 0x01
    3aa6:	0e c0       	rjmp	.+28     	; 0x3ac4 <st_prep_buffer+0x22c>
        } else {
          prep.current_speed = sqrt(pl_block->entry_speed_sqr);
    3aa8:	d7 01       	movw	r26, r14
    3aaa:	56 96       	adiw	r26, 0x16	; 22
    3aac:	6d 91       	ld	r22, X+
    3aae:	7d 91       	ld	r23, X+
    3ab0:	8d 91       	ld	r24, X+
    3ab2:	9c 91       	ld	r25, X
    3ab4:	59 97       	sbiw	r26, 0x19	; 25
    3ab6:	0e 94 34 42 	call	0x8468	; 0x8468 <sqrt>
    3aba:	f3 01       	movw	r30, r6
    3abc:	67 8b       	std	Z+23, r22	; 0x17
    3abe:	70 8f       	std	Z+24, r23	; 0x18
    3ac0:	81 8f       	std	Z+25, r24	; 0x19
    3ac2:	92 8f       	std	Z+26, r25	; 0x1a
        }
        
        // Setup laser mode variables. PWM rate adjusted motions will always complete a motion with the
        // spindle off. 
        st_prep_block->is_pwm_rate_adjusted = false;
    3ac4:	20 91 39 03 	lds	r18, 0x0339	; 0x800339 <st_prep_block>
    3ac8:	30 91 3a 03 	lds	r19, 0x033A	; 0x80033a <st_prep_block+0x1>
    3acc:	3a 83       	std	Y+2, r19	; 0x02
    3ace:	29 83       	std	Y+1, r18	; 0x01
    3ad0:	d9 01       	movw	r26, r18
    3ad2:	51 96       	adiw	r26, 0x11	; 17
    3ad4:	1c 92       	st	X, r1
        if (settings.flags & BITFLAG_LASER_MODE) {
    3ad6:	e5 e1       	ldi	r30, 0x15	; 21
    3ad8:	ff e0       	ldi	r31, 0x0F	; 15
    3ada:	80 81       	ld	r24, Z
    3adc:	81 ff       	sbrs	r24, 1
    3ade:	1c c0       	rjmp	.+56     	; 0x3b18 <st_prep_buffer+0x280>
          if (pl_block->condition & PL_COND_FLAG_SPINDLE_CCW) { 
    3ae0:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    3ae4:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    3ae8:	81 89       	ldd	r24, Z+17	; 0x11
    3aea:	85 ff       	sbrs	r24, 5
    3aec:	15 c0       	rjmp	.+42     	; 0x3b18 <st_prep_buffer+0x280>
            // Pre-compute inverse programmed rate to speed up PWM updating per step segment.
            prep.inv_rate = 1.0/pl_block->programmed_rate;
    3aee:	26 a5       	ldd	r18, Z+46	; 0x2e
    3af0:	37 a5       	ldd	r19, Z+47	; 0x2f
    3af2:	40 a9       	ldd	r20, Z+48	; 0x30
    3af4:	51 a9       	ldd	r21, Z+49	; 0x31
    3af6:	60 e0       	ldi	r22, 0x00	; 0
    3af8:	70 e0       	ldi	r23, 0x00	; 0
    3afa:	80 e8       	ldi	r24, 0x80	; 128
    3afc:	9f e3       	ldi	r25, 0x3F	; 63
    3afe:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <__divsf3>
    3b02:	d3 01       	movw	r26, r6
    3b04:	9b 96       	adiw	r26, 0x2b	; 43
    3b06:	6d 93       	st	X+, r22
    3b08:	7d 93       	st	X+, r23
    3b0a:	8d 93       	st	X+, r24
    3b0c:	9c 93       	st	X, r25
    3b0e:	9e 97       	sbiw	r26, 0x2e	; 46
            st_prep_block->is_pwm_rate_adjusted = true; 
    3b10:	21 e0       	ldi	r18, 0x01	; 1
    3b12:	e9 81       	ldd	r30, Y+1	; 0x01
    3b14:	fa 81       	ldd	r31, Y+2	; 0x02
    3b16:	21 8b       	std	Z+17, r18	; 0x11
			 Compute the velocity profile of a new planner block based on its entry and exit
			 speeds, or recompute the profile of a partially-completed planner block if the
			 planner has updated it. For a commanded forced-deceleration, such as from a feed
			 hold, override the planner velocities and decelerate to the target exit speed.
			*/
			prep.mm_complete = 0.0; // Default velocity profile complete at 0.0mm from end of block.
    3b18:	d3 01       	movw	r26, r6
    3b1a:	53 96       	adiw	r26, 0x13	; 19
    3b1c:	1d 92       	st	X+, r1
    3b1e:	1d 92       	st	X+, r1
    3b20:	1d 92       	st	X+, r1
    3b22:	1c 92       	st	X, r1
    3b24:	56 97       	sbiw	r26, 0x16	; 22
			float inv_2_accel = 0.5/pl_block->acceleration;
    3b26:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    3b2a:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    3b2e:	fe 83       	std	Y+6, r31	; 0x06
    3b30:	ed 83       	std	Y+5, r30	; 0x05
    3b32:	86 8c       	ldd	r8, Z+30	; 0x1e
    3b34:	97 8c       	ldd	r9, Z+31	; 0x1f
    3b36:	a0 a0       	ldd	r10, Z+32	; 0x20
    3b38:	b1 a0       	ldd	r11, Z+33	; 0x21
    3b3a:	a5 01       	movw	r20, r10
    3b3c:	94 01       	movw	r18, r8
    3b3e:	60 e0       	ldi	r22, 0x00	; 0
    3b40:	70 e0       	ldi	r23, 0x00	; 0
    3b42:	80 e0       	ldi	r24, 0x00	; 0
    3b44:	9f e3       	ldi	r25, 0x3F	; 63
    3b46:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <__divsf3>
    3b4a:	69 83       	std	Y+1, r22	; 0x01
    3b4c:	7a 83       	std	Y+2, r23	; 0x02
    3b4e:	8b 83       	std	Y+3, r24	; 0x03
    3b50:	9c 83       	std	Y+4, r25	; 0x04
			if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { // [Forced Deceleration to Zero Velocity]
    3b52:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    3b56:	81 ff       	sbrs	r24, 1
    3b58:	54 c0       	rjmp	.+168    	; 0x3c02 <st_prep_buffer+0x36a>
				// Compute velocity profile parameters for a feed hold in-progress. This profile overrides
				// the planner block profile, enforcing a deceleration to zero speed.
				prep.ramp_type = RAMP_DECEL;
    3b5a:	e2 e0       	ldi	r30, 0x02	; 2
    3b5c:	d3 01       	movw	r26, r6
    3b5e:	52 96       	adiw	r26, 0x12	; 18
    3b60:	ec 93       	st	X, r30
				// Compute decelerate distance relative to end of block.
				float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
    3b62:	ad 81       	ldd	r26, Y+5	; 0x05
    3b64:	be 81       	ldd	r27, Y+6	; 0x06
    3b66:	92 96       	adiw	r26, 0x22	; 34
    3b68:	2d 90       	ld	r2, X+
    3b6a:	3d 90       	ld	r3, X+
    3b6c:	4d 90       	ld	r4, X+
    3b6e:	5c 90       	ld	r5, X
    3b70:	95 97       	sbiw	r26, 0x25	; 37
    3b72:	56 96       	adiw	r26, 0x16	; 22
    3b74:	cd 90       	ld	r12, X+
    3b76:	dd 90       	ld	r13, X+
    3b78:	ed 90       	ld	r14, X+
    3b7a:	fc 90       	ld	r15, X
    3b7c:	59 97       	sbiw	r26, 0x19	; 25
    3b7e:	a7 01       	movw	r20, r14
    3b80:	96 01       	movw	r18, r12
    3b82:	69 81       	ldd	r22, Y+1	; 0x01
    3b84:	7a 81       	ldd	r23, Y+2	; 0x02
    3b86:	8b 81       	ldd	r24, Y+3	; 0x03
    3b88:	9c 81       	ldd	r25, Y+4	; 0x04
    3b8a:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    3b8e:	9b 01       	movw	r18, r22
    3b90:	ac 01       	movw	r20, r24
    3b92:	c2 01       	movw	r24, r4
    3b94:	b1 01       	movw	r22, r2
    3b96:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    3b9a:	69 83       	std	Y+1, r22	; 0x01
    3b9c:	7a 83       	std	Y+2, r23	; 0x02
    3b9e:	8b 83       	std	Y+3, r24	; 0x03
    3ba0:	9c 83       	std	Y+4, r25	; 0x04
				if (decel_dist < 0.0) {
    3ba2:	20 e0       	ldi	r18, 0x00	; 0
    3ba4:	30 e0       	ldi	r19, 0x00	; 0
    3ba6:	a9 01       	movw	r20, r18
    3ba8:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    3bac:	88 23       	and	r24, r24
    3bae:	c4 f4       	brge	.+48     	; 0x3be0 <st_prep_buffer+0x348>
					// Deceleration through entire planner block. End of feed hold is not in this block.
					prep.exit_speed = sqrt(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);
    3bb0:	a5 01       	movw	r20, r10
    3bb2:	94 01       	movw	r18, r8
    3bb4:	c5 01       	movw	r24, r10
    3bb6:	b4 01       	movw	r22, r8
    3bb8:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    3bbc:	a2 01       	movw	r20, r4
    3bbe:	91 01       	movw	r18, r2
    3bc0:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    3bc4:	9b 01       	movw	r18, r22
    3bc6:	ac 01       	movw	r20, r24
    3bc8:	c7 01       	movw	r24, r14
    3bca:	b6 01       	movw	r22, r12
    3bcc:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    3bd0:	0e 94 34 42 	call	0x8468	; 0x8468 <sqrt>
    3bd4:	f3 01       	movw	r30, r6
    3bd6:	67 8f       	std	Z+31, r22	; 0x1f
    3bd8:	70 a3       	std	Z+32, r23	; 0x20
    3bda:	81 a3       	std	Z+33, r24	; 0x21
    3bdc:	92 a3       	std	Z+34, r25	; 0x22
    3bde:	99 c1       	rjmp	.+818    	; 0x3f12 <st_prep_buffer+0x67a>
				} else {
					prep.mm_complete = decel_dist; // End of feed hold.
    3be0:	29 81       	ldd	r18, Y+1	; 0x01
    3be2:	3a 81       	ldd	r19, Y+2	; 0x02
    3be4:	4b 81       	ldd	r20, Y+3	; 0x03
    3be6:	5c 81       	ldd	r21, Y+4	; 0x04
    3be8:	d3 01       	movw	r26, r6
    3bea:	53 96       	adiw	r26, 0x13	; 19
    3bec:	2d 93       	st	X+, r18
    3bee:	3d 93       	st	X+, r19
    3bf0:	4d 93       	st	X+, r20
    3bf2:	5c 93       	st	X, r21
    3bf4:	56 97       	sbiw	r26, 0x16	; 22
					prep.exit_speed = 0.0;
    3bf6:	f3 01       	movw	r30, r6
    3bf8:	17 8e       	std	Z+31, r1	; 0x1f
    3bfa:	10 a2       	std	Z+32, r1	; 0x20
    3bfc:	11 a2       	std	Z+33, r1	; 0x21
    3bfe:	12 a2       	std	Z+34, r1	; 0x22
    3c00:	88 c1       	rjmp	.+784    	; 0x3f12 <st_prep_buffer+0x67a>
				}
			} else { // [Normal Operation]
				// Compute or recompute velocity profile parameters of the prepped planner block.
				prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
    3c02:	d3 01       	movw	r26, r6
    3c04:	52 96       	adiw	r26, 0x12	; 18
    3c06:	1c 92       	st	X, r1
    3c08:	52 97       	sbiw	r26, 0x12	; 18
				prep.accelerate_until = pl_block->millimeters;
    3c0a:	ed 81       	ldd	r30, Y+5	; 0x05
    3c0c:	fe 81       	ldd	r31, Y+6	; 0x06
    3c0e:	42 a1       	ldd	r20, Z+34	; 0x22
    3c10:	53 a1       	ldd	r21, Z+35	; 0x23
    3c12:	64 a1       	ldd	r22, Z+36	; 0x24
    3c14:	75 a1       	ldd	r23, Z+37	; 0x25
    3c16:	93 96       	adiw	r26, 0x23	; 35
    3c18:	4d 93       	st	X+, r20
    3c1a:	5d 93       	st	X+, r21
    3c1c:	6d 93       	st	X+, r22
    3c1e:	7c 93       	st	X, r23
    3c20:	96 97       	sbiw	r26, 0x26	; 38

				float exit_speed_sqr;
				float nominal_speed;
        if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
    3c22:	82 ff       	sbrs	r24, 2
    3c24:	0a c0       	rjmp	.+20     	; 0x3c3a <st_prep_buffer+0x3a2>
          prep.exit_speed = exit_speed_sqr = 0.0; // Enforce stop at end of system motion.
    3c26:	f3 01       	movw	r30, r6
    3c28:	17 8e       	std	Z+31, r1	; 0x1f
    3c2a:	10 a2       	std	Z+32, r1	; 0x20
    3c2c:	11 a2       	std	Z+33, r1	; 0x21
    3c2e:	12 a2       	std	Z+34, r1	; 0x22
    3c30:	19 86       	std	Y+9, r1	; 0x09
    3c32:	1a 86       	std	Y+10, r1	; 0x0a
    3c34:	1b 86       	std	Y+11, r1	; 0x0b
    3c36:	1c 86       	std	Y+12, r1	; 0x0c
    3c38:	0f c0       	rjmp	.+30     	; 0x3c58 <st_prep_buffer+0x3c0>
        } else {
          exit_speed_sqr = plan_get_exec_block_exit_speed_sqr();
    3c3a:	0e 94 95 29 	call	0x532a	; 0x532a <plan_get_exec_block_exit_speed_sqr>
    3c3e:	69 87       	std	Y+9, r22	; 0x09
    3c40:	7a 87       	std	Y+10, r23	; 0x0a
    3c42:	8b 87       	std	Y+11, r24	; 0x0b
    3c44:	9c 87       	std	Y+12, r25	; 0x0c
          prep.exit_speed = sqrt(exit_speed_sqr);
    3c46:	0e 94 34 42 	call	0x8468	; 0x8468 <sqrt>
    3c4a:	d3 01       	movw	r26, r6
    3c4c:	5f 96       	adiw	r26, 0x1f	; 31
    3c4e:	6d 93       	st	X+, r22
    3c50:	7d 93       	st	X+, r23
    3c52:	8d 93       	st	X+, r24
    3c54:	9c 93       	st	X, r25
    3c56:	92 97       	sbiw	r26, 0x22	; 34
        }

        nominal_speed = plan_compute_profile_nominal_speed(pl_block);
    3c58:	80 91 3b 03 	lds	r24, 0x033B	; 0x80033b <pl_block>
    3c5c:	90 91 3c 03 	lds	r25, 0x033C	; 0x80033c <pl_block+0x1>
    3c60:	0e 94 b6 29 	call	0x536c	; 0x536c <plan_compute_profile_nominal_speed>
    3c64:	4b 01       	movw	r8, r22
    3c66:	5c 01       	movw	r10, r24
				float nominal_speed_sqr = nominal_speed*nominal_speed;
    3c68:	9b 01       	movw	r18, r22
    3c6a:	ac 01       	movw	r20, r24
    3c6c:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    3c70:	6d 83       	std	Y+5, r22	; 0x05
    3c72:	7e 83       	std	Y+6, r23	; 0x06
    3c74:	8f 83       	std	Y+7, r24	; 0x07
    3c76:	98 87       	std	Y+8, r25	; 0x08
				float intersect_distance =
								0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
    3c78:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    3c7c:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    3c80:	fe 87       	std	Y+14, r31	; 0x0e
    3c82:	ed 87       	std	Y+13, r30	; 0x0d
    3c84:	c2 a0       	ldd	r12, Z+34	; 0x22
    3c86:	d3 a0       	ldd	r13, Z+35	; 0x23
    3c88:	e4 a0       	ldd	r14, Z+36	; 0x24
    3c8a:	f5 a0       	ldd	r15, Z+37	; 0x25
    3c8c:	26 88       	ldd	r2, Z+22	; 0x16
    3c8e:	37 88       	ldd	r3, Z+23	; 0x17
    3c90:	40 8c       	ldd	r4, Z+24	; 0x18
    3c92:	51 8c       	ldd	r5, Z+25	; 0x19

        if (pl_block->entry_speed_sqr > nominal_speed_sqr) { // Only occurs during override reductions.
    3c94:	a2 01       	movw	r20, r4
    3c96:	91 01       	movw	r18, r2
    3c98:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    3c9c:	88 23       	and	r24, r24
    3c9e:	0c f0       	brlt	.+2      	; 0x3ca2 <st_prep_buffer+0x40a>
    3ca0:	71 c0       	rjmp	.+226    	; 0x3d84 <st_prep_buffer+0x4ec>
          prep.accelerate_until = pl_block->millimeters - inv_2_accel*(pl_block->entry_speed_sqr-nominal_speed_sqr);
    3ca2:	2d 81       	ldd	r18, Y+5	; 0x05
    3ca4:	3e 81       	ldd	r19, Y+6	; 0x06
    3ca6:	4f 81       	ldd	r20, Y+7	; 0x07
    3ca8:	58 85       	ldd	r21, Y+8	; 0x08
    3caa:	c2 01       	movw	r24, r4
    3cac:	b1 01       	movw	r22, r2
    3cae:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    3cb2:	29 81       	ldd	r18, Y+1	; 0x01
    3cb4:	3a 81       	ldd	r19, Y+2	; 0x02
    3cb6:	4b 81       	ldd	r20, Y+3	; 0x03
    3cb8:	5c 81       	ldd	r21, Y+4	; 0x04
    3cba:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    3cbe:	9b 01       	movw	r18, r22
    3cc0:	ac 01       	movw	r20, r24
    3cc2:	c7 01       	movw	r24, r14
    3cc4:	b6 01       	movw	r22, r12
    3cc6:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    3cca:	d3 01       	movw	r26, r6
    3ccc:	93 96       	adiw	r26, 0x23	; 35
    3cce:	6d 93       	st	X+, r22
    3cd0:	7d 93       	st	X+, r23
    3cd2:	8d 93       	st	X+, r24
    3cd4:	9c 93       	st	X, r25
    3cd6:	96 97       	sbiw	r26, 0x26	; 38
          if (prep.accelerate_until <= 0.0) { // Deceleration-only.
    3cd8:	20 e0       	ldi	r18, 0x00	; 0
    3cda:	30 e0       	ldi	r19, 0x00	; 0
    3cdc:	a9 01       	movw	r20, r18
    3cde:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    3ce2:	18 16       	cp	r1, r24
    3ce4:	84 f1       	brlt	.+96     	; 0x3d46 <st_prep_buffer+0x4ae>
            prep.ramp_type = RAMP_DECEL;
    3ce6:	22 e0       	ldi	r18, 0x02	; 2
    3ce8:	f3 01       	movw	r30, r6
    3cea:	22 8b       	std	Z+18, r18	; 0x12
            // prep.decelerate_after = pl_block->millimeters;
            // prep.maximum_speed = prep.current_speed;

            // Compute override block exit speed since it doesn't match the planner exit speed.
            prep.exit_speed = sqrt(pl_block->entry_speed_sqr - 2*pl_block->acceleration*pl_block->millimeters);
    3cec:	ad 85       	ldd	r26, Y+13	; 0x0d
    3cee:	be 85       	ldd	r27, Y+14	; 0x0e
    3cf0:	5e 96       	adiw	r26, 0x1e	; 30
    3cf2:	cd 90       	ld	r12, X+
    3cf4:	dd 90       	ld	r13, X+
    3cf6:	ed 90       	ld	r14, X+
    3cf8:	fc 90       	ld	r15, X
    3cfa:	91 97       	sbiw	r26, 0x21	; 33
    3cfc:	a7 01       	movw	r20, r14
    3cfe:	96 01       	movw	r18, r12
    3d00:	c7 01       	movw	r24, r14
    3d02:	b6 01       	movw	r22, r12
    3d04:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    3d08:	ed 85       	ldd	r30, Y+13	; 0x0d
    3d0a:	fe 85       	ldd	r31, Y+14	; 0x0e
    3d0c:	22 a1       	ldd	r18, Z+34	; 0x22
    3d0e:	33 a1       	ldd	r19, Z+35	; 0x23
    3d10:	44 a1       	ldd	r20, Z+36	; 0x24
    3d12:	55 a1       	ldd	r21, Z+37	; 0x25
    3d14:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    3d18:	9b 01       	movw	r18, r22
    3d1a:	ac 01       	movw	r20, r24
    3d1c:	ad 85       	ldd	r26, Y+13	; 0x0d
    3d1e:	be 85       	ldd	r27, Y+14	; 0x0e
    3d20:	56 96       	adiw	r26, 0x16	; 22
    3d22:	6d 91       	ld	r22, X+
    3d24:	7d 91       	ld	r23, X+
    3d26:	8d 91       	ld	r24, X+
    3d28:	9c 91       	ld	r25, X
    3d2a:	59 97       	sbiw	r26, 0x19	; 25
    3d2c:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    3d30:	0e 94 34 42 	call	0x8468	; 0x8468 <sqrt>
    3d34:	f3 01       	movw	r30, r6
    3d36:	67 8f       	std	Z+31, r22	; 0x1f
    3d38:	70 a3       	std	Z+32, r23	; 0x20
    3d3a:	81 a3       	std	Z+33, r24	; 0x21
    3d3c:	92 a3       	std	Z+34, r25	; 0x22
            prep.recalculate_flag |= PREP_FLAG_DECEL_OVERRIDE; // Flag to load next block as deceleration override.
    3d3e:	81 81       	ldd	r24, Z+1	; 0x01
    3d40:	88 60       	ori	r24, 0x08	; 8
    3d42:	81 83       	std	Z+1, r24	; 0x01
    3d44:	e6 c0       	rjmp	.+460    	; 0x3f12 <st_prep_buffer+0x67a>
            // Can be tricky since entry speed will be current speed, as in feed holds.
            // Also, look into near-zero speed handling issues with this.

          } else {
            // Decelerate to cruise or cruise-decelerate types. Guaranteed to intersect updated plan.
            prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
    3d46:	29 85       	ldd	r18, Y+9	; 0x09
    3d48:	3a 85       	ldd	r19, Y+10	; 0x0a
    3d4a:	4b 85       	ldd	r20, Y+11	; 0x0b
    3d4c:	5c 85       	ldd	r21, Y+12	; 0x0c
    3d4e:	6d 81       	ldd	r22, Y+5	; 0x05
    3d50:	7e 81       	ldd	r23, Y+6	; 0x06
    3d52:	8f 81       	ldd	r24, Y+7	; 0x07
    3d54:	98 85       	ldd	r25, Y+8	; 0x08
    3d56:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    3d5a:	29 81       	ldd	r18, Y+1	; 0x01
    3d5c:	3a 81       	ldd	r19, Y+2	; 0x02
    3d5e:	4b 81       	ldd	r20, Y+3	; 0x03
    3d60:	5c 81       	ldd	r21, Y+4	; 0x04
    3d62:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    3d66:	d3 01       	movw	r26, r6
    3d68:	97 96       	adiw	r26, 0x27	; 39
    3d6a:	6d 93       	st	X+, r22
    3d6c:	7d 93       	st	X+, r23
    3d6e:	8d 93       	st	X+, r24
    3d70:	9c 93       	st	X, r25
    3d72:	9a 97       	sbiw	r26, 0x2a	; 42
            prep.maximum_speed = nominal_speed;
    3d74:	f3 01       	movw	r30, r6
    3d76:	83 8e       	std	Z+27, r8	; 0x1b
    3d78:	94 8e       	std	Z+28, r9	; 0x1c
    3d7a:	a5 8e       	std	Z+29, r10	; 0x1d
    3d7c:	b6 8e       	std	Z+30, r11	; 0x1e
            prep.ramp_type = RAMP_DECEL_OVERRIDE;
    3d7e:	23 e0       	ldi	r18, 0x03	; 3
    3d80:	22 8b       	std	Z+18, r18	; 0x12
    3d82:	c7 c0       	rjmp	.+398    	; 0x3f12 <st_prep_buffer+0x67a>
          prep.exit_speed = sqrt(exit_speed_sqr);
        }

        nominal_speed = plan_compute_profile_nominal_speed(pl_block);
				float nominal_speed_sqr = nominal_speed*nominal_speed;
				float intersect_distance =
    3d84:	29 85       	ldd	r18, Y+9	; 0x09
    3d86:	3a 85       	ldd	r19, Y+10	; 0x0a
    3d88:	4b 85       	ldd	r20, Y+11	; 0x0b
    3d8a:	5c 85       	ldd	r21, Y+12	; 0x0c
    3d8c:	c2 01       	movw	r24, r4
    3d8e:	b1 01       	movw	r22, r2
    3d90:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    3d94:	29 81       	ldd	r18, Y+1	; 0x01
    3d96:	3a 81       	ldd	r19, Y+2	; 0x02
    3d98:	4b 81       	ldd	r20, Y+3	; 0x03
    3d9a:	5c 81       	ldd	r21, Y+4	; 0x04
    3d9c:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    3da0:	a7 01       	movw	r20, r14
    3da2:	96 01       	movw	r18, r12
    3da4:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    3da8:	20 e0       	ldi	r18, 0x00	; 0
    3daa:	30 e0       	ldi	r19, 0x00	; 0
    3dac:	40 e0       	ldi	r20, 0x00	; 0
    3dae:	5f e3       	ldi	r21, 0x3F	; 63
    3db0:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    3db4:	1b 01       	movw	r2, r22
    3db6:	2c 01       	movw	r4, r24
            // Decelerate to cruise or cruise-decelerate types. Guaranteed to intersect updated plan.
            prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
            prep.maximum_speed = nominal_speed;
            prep.ramp_type = RAMP_DECEL_OVERRIDE;
          }
				} else if (intersect_distance > 0.0) {
    3db8:	20 e0       	ldi	r18, 0x00	; 0
    3dba:	30 e0       	ldi	r19, 0x00	; 0
    3dbc:	a9 01       	movw	r20, r18
    3dbe:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    3dc2:	18 16       	cp	r1, r24
    3dc4:	0c f0       	brlt	.+2      	; 0x3dc8 <st_prep_buffer+0x530>
    3dc6:	93 c0       	rjmp	.+294    	; 0x3eee <st_prep_buffer+0x656>
					if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
    3dc8:	a2 01       	movw	r20, r4
    3dca:	91 01       	movw	r18, r2
    3dcc:	c7 01       	movw	r24, r14
    3dce:	b6 01       	movw	r22, r12
    3dd0:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    3dd4:	18 16       	cp	r1, r24
    3dd6:	0c f0       	brlt	.+2      	; 0x3dda <st_prep_buffer+0x542>
    3dd8:	85 c0       	rjmp	.+266    	; 0x3ee4 <st_prep_buffer+0x64c>
						// NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
						prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
    3dda:	29 85       	ldd	r18, Y+9	; 0x09
    3ddc:	3a 85       	ldd	r19, Y+10	; 0x0a
    3dde:	4b 85       	ldd	r20, Y+11	; 0x0b
    3de0:	5c 85       	ldd	r21, Y+12	; 0x0c
    3de2:	6d 81       	ldd	r22, Y+5	; 0x05
    3de4:	7e 81       	ldd	r23, Y+6	; 0x06
    3de6:	8f 81       	ldd	r24, Y+7	; 0x07
    3de8:	98 85       	ldd	r25, Y+8	; 0x08
    3dea:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    3dee:	29 81       	ldd	r18, Y+1	; 0x01
    3df0:	3a 81       	ldd	r19, Y+2	; 0x02
    3df2:	4b 81       	ldd	r20, Y+3	; 0x03
    3df4:	5c 81       	ldd	r21, Y+4	; 0x04
    3df6:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    3dfa:	9b 01       	movw	r18, r22
    3dfc:	ac 01       	movw	r20, r24
    3dfe:	d3 01       	movw	r26, r6
    3e00:	97 96       	adiw	r26, 0x27	; 39
    3e02:	6d 93       	st	X+, r22
    3e04:	7d 93       	st	X+, r23
    3e06:	8d 93       	st	X+, r24
    3e08:	9c 93       	st	X, r25
    3e0a:	9a 97       	sbiw	r26, 0x2a	; 42
						if (prep.decelerate_after < intersect_distance) { // Trapezoid type
    3e0c:	c2 01       	movw	r24, r4
    3e0e:	b1 01       	movw	r22, r2
    3e10:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    3e14:	18 16       	cp	r1, r24
    3e16:	d4 f5       	brge	.+116    	; 0x3e8c <st_prep_buffer+0x5f4>
							prep.maximum_speed = nominal_speed;
    3e18:	f3 01       	movw	r30, r6
    3e1a:	83 8e       	std	Z+27, r8	; 0x1b
    3e1c:	94 8e       	std	Z+28, r9	; 0x1c
    3e1e:	a5 8e       	std	Z+29, r10	; 0x1d
    3e20:	b6 8e       	std	Z+30, r11	; 0x1e
							if (pl_block->entry_speed_sqr == nominal_speed_sqr) {
    3e22:	ad 85       	ldd	r26, Y+13	; 0x0d
    3e24:	be 85       	ldd	r27, Y+14	; 0x0e
    3e26:	56 96       	adiw	r26, 0x16	; 22
    3e28:	2d 90       	ld	r2, X+
    3e2a:	3d 90       	ld	r3, X+
    3e2c:	4d 90       	ld	r4, X+
    3e2e:	5c 90       	ld	r5, X
    3e30:	59 97       	sbiw	r26, 0x19	; 25
    3e32:	a2 01       	movw	r20, r4
    3e34:	91 01       	movw	r18, r2
    3e36:	6d 81       	ldd	r22, Y+5	; 0x05
    3e38:	7e 81       	ldd	r23, Y+6	; 0x06
    3e3a:	8f 81       	ldd	r24, Y+7	; 0x07
    3e3c:	98 85       	ldd	r25, Y+8	; 0x08
    3e3e:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    3e42:	81 11       	cpse	r24, r1
    3e44:	04 c0       	rjmp	.+8      	; 0x3e4e <st_prep_buffer+0x5b6>
								// Cruise-deceleration or cruise-only type.
								prep.ramp_type = RAMP_CRUISE;
    3e46:	21 e0       	ldi	r18, 0x01	; 1
    3e48:	f3 01       	movw	r30, r6
    3e4a:	22 8b       	std	Z+18, r18	; 0x12
    3e4c:	62 c0       	rjmp	.+196    	; 0x3f12 <st_prep_buffer+0x67a>
							} else {
								// Full-trapezoid or acceleration-cruise types
								prep.accelerate_until -= inv_2_accel*(nominal_speed_sqr-pl_block->entry_speed_sqr);
    3e4e:	a2 01       	movw	r20, r4
    3e50:	91 01       	movw	r18, r2
    3e52:	6d 81       	ldd	r22, Y+5	; 0x05
    3e54:	7e 81       	ldd	r23, Y+6	; 0x06
    3e56:	8f 81       	ldd	r24, Y+7	; 0x07
    3e58:	98 85       	ldd	r25, Y+8	; 0x08
    3e5a:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    3e5e:	29 81       	ldd	r18, Y+1	; 0x01
    3e60:	3a 81       	ldd	r19, Y+2	; 0x02
    3e62:	4b 81       	ldd	r20, Y+3	; 0x03
    3e64:	5c 81       	ldd	r21, Y+4	; 0x04
    3e66:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    3e6a:	9b 01       	movw	r18, r22
    3e6c:	ac 01       	movw	r20, r24
    3e6e:	d3 01       	movw	r26, r6
    3e70:	93 96       	adiw	r26, 0x23	; 35
    3e72:	6d 91       	ld	r22, X+
    3e74:	7d 91       	ld	r23, X+
    3e76:	8d 91       	ld	r24, X+
    3e78:	9c 91       	ld	r25, X
    3e7a:	96 97       	sbiw	r26, 0x26	; 38
    3e7c:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    3e80:	f3 01       	movw	r30, r6
    3e82:	63 a3       	std	Z+35, r22	; 0x23
    3e84:	74 a3       	std	Z+36, r23	; 0x24
    3e86:	85 a3       	std	Z+37, r24	; 0x25
    3e88:	96 a3       	std	Z+38, r25	; 0x26
    3e8a:	43 c0       	rjmp	.+134    	; 0x3f12 <st_prep_buffer+0x67a>
							}
						} else { // Triangle type
							prep.accelerate_until = intersect_distance;
    3e8c:	d3 01       	movw	r26, r6
    3e8e:	93 96       	adiw	r26, 0x23	; 35
    3e90:	2d 92       	st	X+, r2
    3e92:	3d 92       	st	X+, r3
    3e94:	4d 92       	st	X+, r4
    3e96:	5c 92       	st	X, r5
    3e98:	96 97       	sbiw	r26, 0x26	; 38
							prep.decelerate_after = intersect_distance;
    3e9a:	f3 01       	movw	r30, r6
    3e9c:	27 a2       	std	Z+39, r2	; 0x27
    3e9e:	30 a6       	std	Z+40, r3	; 0x28
    3ea0:	41 a6       	std	Z+41, r4	; 0x29
    3ea2:	52 a6       	std	Z+42, r5	; 0x2a
							prep.maximum_speed = sqrt(2.0*pl_block->acceleration*intersect_distance+exit_speed_sqr);
    3ea4:	ad 85       	ldd	r26, Y+13	; 0x0d
    3ea6:	be 85       	ldd	r27, Y+14	; 0x0e
    3ea8:	5e 96       	adiw	r26, 0x1e	; 30
    3eaa:	cd 90       	ld	r12, X+
    3eac:	dd 90       	ld	r13, X+
    3eae:	ed 90       	ld	r14, X+
    3eb0:	fc 90       	ld	r15, X
    3eb2:	91 97       	sbiw	r26, 0x21	; 33
    3eb4:	a7 01       	movw	r20, r14
    3eb6:	96 01       	movw	r18, r12
    3eb8:	c7 01       	movw	r24, r14
    3eba:	b6 01       	movw	r22, r12
    3ebc:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    3ec0:	a2 01       	movw	r20, r4
    3ec2:	91 01       	movw	r18, r2
    3ec4:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    3ec8:	29 85       	ldd	r18, Y+9	; 0x09
    3eca:	3a 85       	ldd	r19, Y+10	; 0x0a
    3ecc:	4b 85       	ldd	r20, Y+11	; 0x0b
    3ece:	5c 85       	ldd	r21, Y+12	; 0x0c
    3ed0:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    3ed4:	0e 94 34 42 	call	0x8468	; 0x8468 <sqrt>
    3ed8:	f3 01       	movw	r30, r6
    3eda:	63 8f       	std	Z+27, r22	; 0x1b
    3edc:	74 8f       	std	Z+28, r23	; 0x1c
    3ede:	85 8f       	std	Z+29, r24	; 0x1d
    3ee0:	96 8f       	std	Z+30, r25	; 0x1e
    3ee2:	17 c0       	rjmp	.+46     	; 0x3f12 <st_prep_buffer+0x67a>
						}
					} else { // Deceleration-only type
            prep.ramp_type = RAMP_DECEL;
    3ee4:	e2 e0       	ldi	r30, 0x02	; 2
    3ee6:	d3 01       	movw	r26, r6
    3ee8:	52 96       	adiw	r26, 0x12	; 18
    3eea:	ec 93       	st	X, r30
    3eec:	12 c0       	rjmp	.+36     	; 0x3f12 <st_prep_buffer+0x67a>
            // prep.decelerate_after = pl_block->millimeters;
            // prep.maximum_speed = prep.current_speed;
					}
				} else { // Acceleration-only type
					prep.accelerate_until = 0.0;
    3eee:	d3 01       	movw	r26, r6
    3ef0:	93 96       	adiw	r26, 0x23	; 35
    3ef2:	1d 92       	st	X+, r1
    3ef4:	1d 92       	st	X+, r1
    3ef6:	1d 92       	st	X+, r1
    3ef8:	1c 92       	st	X, r1
    3efa:	96 97       	sbiw	r26, 0x26	; 38
					// prep.decelerate_after = 0.0;
					prep.maximum_speed = prep.exit_speed;
    3efc:	5f 96       	adiw	r26, 0x1f	; 31
    3efe:	8d 91       	ld	r24, X+
    3f00:	9d 91       	ld	r25, X+
    3f02:	0d 90       	ld	r0, X+
    3f04:	bc 91       	ld	r27, X
    3f06:	a0 2d       	mov	r26, r0
    3f08:	f3 01       	movw	r30, r6
    3f0a:	83 8f       	std	Z+27, r24	; 0x1b
    3f0c:	94 8f       	std	Z+28, r25	; 0x1c
    3f0e:	a5 8f       	std	Z+29, r26	; 0x1d
    3f10:	b6 8f       	std	Z+30, r27	; 0x1e
				}
			}
      
      bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM); // Force update whenever updating block.
    3f12:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    3f16:	88 60       	ori	r24, 0x08	; 8
    3f18:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <sys+0x4>
    }
    
    // Initialize new segment
    segment_t *prep_segment = &segment_buffer[segment_buffer_head];
    3f1c:	e0 91 41 03 	lds	r30, 0x0341	; 0x800341 <segment_buffer_head>
    3f20:	2e 2f       	mov	r18, r30
    3f22:	30 e0       	ldi	r19, 0x00	; 0
    3f24:	3b ab       	std	Y+51, r19	; 0x33
    3f26:	2a ab       	std	Y+50, r18	; 0x32

    // Set new segment to point to the current segment data block.
    prep_segment->st_block_index = prep.st_block_index;
    3f28:	f9 01       	movw	r30, r18
    3f2a:	ee 0f       	add	r30, r30
    3f2c:	ff 1f       	adc	r31, r31
    3f2e:	ee 0f       	add	r30, r30
    3f30:	ff 1f       	adc	r31, r31
    3f32:	ee 0f       	add	r30, r30
    3f34:	ff 1f       	adc	r31, r31
    3f36:	ea 59       	subi	r30, 0x9A	; 154
    3f38:	fc 4f       	sbci	r31, 0xFC	; 252
    3f3a:	d3 01       	movw	r26, r6
    3f3c:	8c 91       	ld	r24, X
    3f3e:	84 83       	std	Z+4, r24	; 0x04
    float dt_max = DT_SEGMENT; // Maximum segment time
    float dt = 0.0; // Initialize segment time
    float time_var = dt_max; // Time worker variable
    float mm_var; // mm-Distance worker variable
    float speed_var; // Speed worker variable
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    3f40:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    3f44:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    3f48:	fb 8f       	std	Y+27, r31	; 0x1b
    3f4a:	ea 8f       	std	Y+26, r30	; 0x1a
    3f4c:	f2 a1       	ldd	r31, Z+34	; 0x22
    3f4e:	fa a7       	std	Y+42, r31	; 0x2a
    3f50:	aa 8d       	ldd	r26, Y+26	; 0x1a
    3f52:	bb 8d       	ldd	r27, Y+27	; 0x1b
    3f54:	93 96       	adiw	r26, 0x23	; 35
    3f56:	bc 91       	ld	r27, X
    3f58:	bb a7       	std	Y+43, r27	; 0x2b
    3f5a:	ea 8d       	ldd	r30, Y+26	; 0x1a
    3f5c:	fb 8d       	ldd	r31, Y+27	; 0x1b
    3f5e:	f4 a1       	ldd	r31, Z+36	; 0x24
    3f60:	fc a7       	std	Y+44, r31	; 0x2c
    3f62:	aa 8d       	ldd	r26, Y+26	; 0x1a
    3f64:	bb 8d       	ldd	r27, Y+27	; 0x1b
    3f66:	95 96       	adiw	r26, 0x25	; 37
    3f68:	bc 91       	ld	r27, X
    3f6a:	bd a7       	std	Y+45, r27	; 0x2d
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    3f6c:	f3 01       	movw	r30, r6
    3f6e:	26 85       	ldd	r18, Z+14	; 0x0e
    3f70:	37 85       	ldd	r19, Z+15	; 0x0f
    3f72:	40 89       	ldd	r20, Z+16	; 0x10
    3f74:	51 89       	ldd	r21, Z+17	; 0x11
    3f76:	6a a5       	ldd	r22, Y+42	; 0x2a
    3f78:	7b a5       	ldd	r23, Y+43	; 0x2b
    3f7a:	8c a5       	ldd	r24, Y+44	; 0x2c
    3f7c:	9b 2f       	mov	r25, r27
    3f7e:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    3f82:	6a a3       	std	Y+34, r22	; 0x22
    3f84:	7b a3       	std	Y+35, r23	; 0x23
    3f86:	8c a3       	std	Y+36, r24	; 0x24
    3f88:	9d a3       	std	Y+37, r25	; 0x25
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }
    3f8a:	20 e0       	ldi	r18, 0x00	; 0
    3f8c:	30 e0       	ldi	r19, 0x00	; 0
    3f8e:	a9 01       	movw	r20, r18
    3f90:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    3f94:	88 23       	and	r24, r24
    3f96:	24 f4       	brge	.+8      	; 0x3fa0 <st_prep_buffer+0x708>
    3f98:	1a a2       	std	Y+34, r1	; 0x22
    3f9a:	1b a2       	std	Y+35, r1	; 0x23
    3f9c:	1c a2       	std	Y+36, r1	; 0x24
    3f9e:	1d a2       	std	Y+37, r1	; 0x25

    do {
      switch (prep.ramp_type) {
        case RAMP_DECEL_OVERRIDE:
          speed_var = pl_block->acceleration*time_var;
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
    3fa0:	d3 01       	movw	r26, r6
    3fa2:	5b 96       	adiw	r26, 0x1b	; 27
    3fa4:	bc 91       	ld	r27, X
    3fa6:	be 8b       	std	Y+22, r27	; 0x16
    3fa8:	f3 01       	movw	r30, r6
    3faa:	f4 8d       	ldd	r31, Z+28	; 0x1c
    3fac:	ff 8b       	std	Y+23, r31	; 0x17
    3fae:	d3 01       	movw	r26, r6
    3fb0:	5d 96       	adiw	r26, 0x1d	; 29
    3fb2:	bc 91       	ld	r27, X
    3fb4:	b8 8f       	std	Y+24, r27	; 0x18
    3fb6:	f3 01       	movw	r30, r6
    3fb8:	f6 8d       	ldd	r31, Z+30	; 0x1e
    3fba:	f9 8f       	std	Y+25, r31	; 0x19
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
    3fbc:	d3 01       	movw	r26, r6
    3fbe:	93 96       	adiw	r26, 0x23	; 35
    3fc0:	bc 91       	ld	r27, X
    3fc2:	be 8f       	std	Y+30, r27	; 0x1e
    3fc4:	f3 01       	movw	r30, r6
    3fc6:	f4 a1       	ldd	r31, Z+36	; 0x24
    3fc8:	ff 8f       	std	Y+31, r31	; 0x1f
    3fca:	d3 01       	movw	r26, r6
    3fcc:	95 96       	adiw	r26, 0x25	; 37
    3fce:	bc 91       	ld	r27, X
    3fd0:	b8 a3       	std	Y+32, r27	; 0x20
    3fd2:	f3 01       	movw	r30, r6
    3fd4:	f6 a1       	ldd	r31, Z+38	; 0x26
    3fd6:	f9 a3       	std	Y+33, r31	; 0x21
    3fd8:	d3 01       	movw	r26, r6
    3fda:	57 96       	adiw	r26, 0x17	; 23
    3fdc:	bc 91       	ld	r27, X
    3fde:	b9 83       	std	Y+1, r27	; 0x01
    3fe0:	f3 01       	movw	r30, r6
    3fe2:	f0 8d       	ldd	r31, Z+24	; 0x18
    3fe4:	fd 83       	std	Y+5, r31	; 0x05
    3fe6:	d3 01       	movw	r26, r6
    3fe8:	59 96       	adiw	r26, 0x19	; 25
    3fea:	bc 91       	ld	r27, X
    3fec:	b9 87       	std	Y+9, r27	; 0x09
    3fee:	f3 01       	movw	r30, r6
    3ff0:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3ff2:	f9 8b       	std	Y+17, r31	; 0x11
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    3ff4:	d3 01       	movw	r26, r6
    3ff6:	97 96       	adiw	r26, 0x27	; 39
    3ff8:	bc 91       	ld	r27, X
    3ffa:	be a3       	std	Y+38, r27	; 0x26
    3ffc:	f3 01       	movw	r30, r6
    3ffe:	f0 a5       	ldd	r31, Z+40	; 0x28
    4000:	ff a3       	std	Y+39, r31	; 0x27
    4002:	d3 01       	movw	r26, r6
    4004:	99 96       	adiw	r26, 0x29	; 41
    4006:	bc 91       	ld	r27, X
    4008:	b8 a7       	std	Y+40, r27	; 0x28
    400a:	f3 01       	movw	r30, r6
    400c:	f2 a5       	ldd	r31, Z+42	; 0x2a
    400e:	f9 a7       	std	Y+41, r31	; 0x29
    4010:	d3 01       	movw	r26, r6
    4012:	52 96       	adiw	r26, 0x12	; 18
    4014:	bc 91       	ld	r27, X
    4016:	bd 8f       	std	Y+29, r27	; 0x1d
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
    4018:	f3 01       	movw	r30, r6
    401a:	f3 89       	ldd	r31, Z+19	; 0x13
    401c:	fa 8b       	std	Y+18, r31	; 0x12
    401e:	d3 01       	movw	r26, r6
    4020:	54 96       	adiw	r26, 0x14	; 20
    4022:	bc 91       	ld	r27, X
    4024:	bb 8b       	std	Y+19, r27	; 0x13
    4026:	f3 01       	movw	r30, r6
    4028:	f5 89       	ldd	r31, Z+21	; 0x15
    402a:	fc 8b       	std	Y+20, r31	; 0x14
    402c:	d3 01       	movw	r26, r6
    402e:	56 96       	adiw	r26, 0x16	; 22
    4030:	bc 91       	ld	r27, X
    4032:	bd 8b       	std	Y+21, r27	; 0x15
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    4034:	f3 01       	movw	r30, r6
    4036:	f7 8d       	ldd	r31, Z+31	; 0x1f
    4038:	fe a7       	std	Y+46, r31	; 0x2e
    403a:	d3 01       	movw	r26, r6
    403c:	90 96       	adiw	r26, 0x20	; 32
    403e:	bc 91       	ld	r27, X
    4040:	bf a7       	std	Y+47, r27	; 0x2f
    4042:	f3 01       	movw	r30, r6
    4044:	f1 a1       	ldd	r31, Z+33	; 0x21
    4046:	f8 ab       	std	Y+48, r31	; 0x30
    4048:	d3 01       	movw	r26, r6
    404a:	92 96       	adiw	r26, 0x22	; 34
    404c:	bc 91       	ld	r27, X
    404e:	b9 ab       	std	Y+49, r27	; 0x31
    4050:	2e a1       	ldd	r18, Y+38	; 0x26
    4052:	3f a1       	ldd	r19, Y+39	; 0x27
    4054:	48 a5       	ldd	r20, Y+40	; 0x28
    4056:	59 a5       	ldd	r21, Y+41	; 0x29
    4058:	6e 8d       	ldd	r22, Y+30	; 0x1e
    405a:	7f 8d       	ldd	r23, Y+31	; 0x1f
    405c:	88 a1       	ldd	r24, Y+32	; 0x20
    405e:	99 a1       	ldd	r25, Y+33	; 0x21
    4060:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    4064:	81 11       	cpse	r24, r1
    4066:	02 c0       	rjmp	.+4      	; 0x406c <st_prep_buffer+0x7d4>
    4068:	8a ad       	ldd	r24, Y+58	; 0x3a
    406a:	01 c0       	rjmp	.+2      	; 0x406e <st_prep_buffer+0x7d6>
    406c:	81 e0       	ldi	r24, 0x01	; 1
    406e:	5a a4       	ldd	r5, Y+42	; 0x2a
    4070:	1b a5       	ldd	r17, Y+43	; 0x2b
    4072:	0c a5       	ldd	r16, Y+44	; 0x2c
    4074:	ed a5       	ldd	r30, Y+45	; 0x2d
    4076:	ec 8f       	std	Y+28, r30	; 0x1c
    4078:	0f 2e       	mov	r0, r31
    407a:	fe e3       	ldi	r31, 0x3E	; 62
    407c:	4f 2e       	mov	r4, r31
    407e:	f0 2d       	mov	r31, r0
    4080:	0f 2e       	mov	r0, r31
    4082:	f3 ec       	ldi	r31, 0xC3	; 195
    4084:	3f 2e       	mov	r3, r31
    4086:	f0 2d       	mov	r31, r0
    4088:	0f 2e       	mov	r0, r31
    408a:	fe e2       	ldi	r31, 0x2E	; 46
    408c:	2f 2e       	mov	r2, r31
    408e:	f0 2d       	mov	r31, r0
    4090:	0f 2e       	mov	r0, r31
    4092:	f9 e3       	ldi	r31, 0x39	; 57
    4094:	ff 2e       	mov	r15, r31
    4096:	f0 2d       	mov	r31, r0
    4098:	81 2c       	mov	r8, r1
    409a:	91 2c       	mov	r9, r1
    409c:	54 01       	movw	r10, r8
    409e:	0f 2e       	mov	r0, r31
    40a0:	fe e3       	ldi	r31, 0x3E	; 62
    40a2:	cf 2e       	mov	r12, r31
    40a4:	f0 2d       	mov	r31, r0
    40a6:	0f 2e       	mov	r0, r31
    40a8:	f3 ec       	ldi	r31, 0xC3	; 195
    40aa:	df 2e       	mov	r13, r31
    40ac:	f0 2d       	mov	r31, r0
    40ae:	0f 2e       	mov	r0, r31
    40b0:	fe e2       	ldi	r31, 0x2E	; 46
    40b2:	ef 2e       	mov	r14, r31
    40b4:	f0 2d       	mov	r31, r0
    40b6:	f9 e3       	ldi	r31, 0x39	; 57
    40b8:	fd 87       	std	Y+13, r31	; 0x0d
    40ba:	8d ab       	std	Y+53, r24	; 0x35
    40bc:	2d 8d       	ldd	r18, Y+29	; 0x1d
    40be:	2c af       	std	Y+60, r18	; 0x3c
    40c0:	7f aa       	std	Y+55, r7	; 0x37
    40c2:	6e aa       	std	Y+54, r6	; 0x36
    40c4:	7c 2c       	mov	r7, r12
    40c6:	81 2f       	mov	r24, r17
    40c8:	1e 2d       	mov	r17, r14
    40ca:	e5 2c       	mov	r14, r5
    40cc:	5d 2c       	mov	r5, r13
    40ce:	c0 2e       	mov	r12, r16
    40d0:	09 e3       	ldi	r16, 0x39	; 57
    40d2:	fb ae       	std	Y+59, r15	; 0x3b
    40d4:	fe 2e       	mov	r15, r30
    40d6:	d8 2e       	mov	r13, r24
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }

    do {
      switch (prep.ramp_type) {
    40d8:	3c ad       	ldd	r19, Y+60	; 0x3c
    40da:	31 30       	cpi	r19, 0x01	; 1
    40dc:	09 f4       	brne	.+2      	; 0x40e0 <st_prep_buffer+0x848>
    40de:	0f c1       	rjmp	.+542    	; 0x42fe <st_prep_buffer+0xa66>
    40e0:	08 f4       	brcc	.+2      	; 0x40e4 <st_prep_buffer+0x84c>
    40e2:	8f c0       	rjmp	.+286    	; 0x4202 <st_prep_buffer+0x96a>
    40e4:	33 30       	cpi	r19, 0x03	; 3
    40e6:	09 f0       	breq	.+2      	; 0x40ea <st_prep_buffer+0x852>
    40e8:	48 c1       	rjmp	.+656    	; 0x437a <st_prep_buffer+0xae2>
        case RAMP_DECEL_OVERRIDE:
          speed_var = pl_block->acceleration*time_var;
    40ea:	aa 8d       	ldd	r26, Y+26	; 0x1a
    40ec:	bb 8d       	ldd	r27, Y+27	; 0x1b
    40ee:	5e 96       	adiw	r26, 0x1e	; 30
    40f0:	2d 91       	ld	r18, X+
    40f2:	3d 91       	ld	r19, X+
    40f4:	4d 91       	ld	r20, X+
    40f6:	5c 91       	ld	r21, X
    40f8:	91 97       	sbiw	r26, 0x21	; 33
    40fa:	64 2d       	mov	r22, r4
    40fc:	73 2d       	mov	r23, r3
    40fe:	82 2d       	mov	r24, r2
    4100:	9b ad       	ldd	r25, Y+59	; 0x3b
    4102:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    4106:	6d 87       	std	Y+13, r22	; 0x0d
    4108:	7e 87       	std	Y+14, r23	; 0x0e
    410a:	8f 87       	std	Y+15, r24	; 0x0f
    410c:	98 8b       	std	Y+16, r25	; 0x10
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
    410e:	2e 89       	ldd	r18, Y+22	; 0x16
    4110:	3f 89       	ldd	r19, Y+23	; 0x17
    4112:	48 8d       	ldd	r20, Y+24	; 0x18
    4114:	59 8d       	ldd	r21, Y+25	; 0x19
    4116:	69 81       	ldd	r22, Y+1	; 0x01
    4118:	7d 81       	ldd	r23, Y+5	; 0x05
    411a:	89 85       	ldd	r24, Y+9	; 0x09
    411c:	99 89       	ldd	r25, Y+17	; 0x11
    411e:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    4122:	9b 01       	movw	r18, r22
    4124:	ac 01       	movw	r20, r24
    4126:	6d 85       	ldd	r22, Y+13	; 0x0d
    4128:	7e 85       	ldd	r23, Y+14	; 0x0e
    412a:	8f 85       	ldd	r24, Y+15	; 0x0f
    412c:	98 89       	ldd	r25, Y+16	; 0x10
    412e:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    4132:	88 23       	and	r24, r24
    4134:	9c f1       	brlt	.+102    	; 0x419c <st_prep_buffer+0x904>
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    4136:	2e 8d       	ldd	r18, Y+30	; 0x1e
    4138:	3f 8d       	ldd	r19, Y+31	; 0x1f
    413a:	48 a1       	ldd	r20, Y+32	; 0x20
    413c:	59 a1       	ldd	r21, Y+33	; 0x21
    413e:	6a a5       	ldd	r22, Y+42	; 0x2a
    4140:	7b a5       	ldd	r23, Y+43	; 0x2b
    4142:	8c a5       	ldd	r24, Y+44	; 0x2c
    4144:	9d a5       	ldd	r25, Y+45	; 0x2d
    4146:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    414a:	9b 01       	movw	r18, r22
    414c:	ac 01       	movw	r20, r24
    414e:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    4152:	6b 01       	movw	r12, r22
    4154:	7c 01       	movw	r14, r24
    4156:	29 81       	ldd	r18, Y+1	; 0x01
    4158:	3d 81       	ldd	r19, Y+5	; 0x05
    415a:	49 85       	ldd	r20, Y+9	; 0x09
    415c:	59 89       	ldd	r21, Y+17	; 0x11
    415e:	6e 89       	ldd	r22, Y+22	; 0x16
    4160:	7f 89       	ldd	r23, Y+23	; 0x17
    4162:	88 8d       	ldd	r24, Y+24	; 0x18
    4164:	99 8d       	ldd	r25, Y+25	; 0x19
    4166:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    416a:	9b 01       	movw	r18, r22
    416c:	ac 01       	movw	r20, r24
    416e:	c7 01       	movw	r24, r14
    4170:	b6 01       	movw	r22, r12
    4172:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <__divsf3>
    4176:	46 2e       	mov	r4, r22
    4178:	37 2e       	mov	r3, r23
    417a:	28 2e       	mov	r2, r24
    417c:	9b af       	std	Y+59, r25	; 0x3b
            prep.ramp_type = RAMP_CRUISE;
            prep.current_speed = prep.maximum_speed;
    417e:	be 89       	ldd	r27, Y+22	; 0x16
    4180:	b9 83       	std	Y+1, r27	; 0x01
    4182:	ef 89       	ldd	r30, Y+23	; 0x17
    4184:	ed 83       	std	Y+5, r30	; 0x05
    4186:	f8 8d       	ldd	r31, Y+24	; 0x18
    4188:	f9 87       	std	Y+9, r31	; 0x09
    418a:	29 8d       	ldd	r18, Y+25	; 0x19
    418c:	29 8b       	std	Y+17, r18	; 0x11
      switch (prep.ramp_type) {
        case RAMP_DECEL_OVERRIDE:
          speed_var = pl_block->acceleration*time_var;
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
    418e:	ee 8c       	ldd	r14, Y+30	; 0x1e
    4190:	df 8c       	ldd	r13, Y+31	; 0x1f
    4192:	c8 a0       	ldd	r12, Y+32	; 0x20
    4194:	f9 a0       	ldd	r15, Y+33	; 0x21
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            prep.ramp_type = RAMP_CRUISE;
    4196:	38 ad       	ldd	r19, Y+56	; 0x38
    4198:	3c af       	std	Y+60, r19	; 0x3c
    419a:	80 c1       	rjmp	.+768    	; 0x449c <st_prep_buffer+0xc04>
            prep.current_speed = prep.maximum_speed;
          } else { // Mid-deceleration override ramp.
            mm_remaining -= time_var*(prep.current_speed - 0.5*speed_var);
    419c:	20 e0       	ldi	r18, 0x00	; 0
    419e:	30 e0       	ldi	r19, 0x00	; 0
    41a0:	40 e0       	ldi	r20, 0x00	; 0
    41a2:	5f e3       	ldi	r21, 0x3F	; 63
    41a4:	6d 85       	ldd	r22, Y+13	; 0x0d
    41a6:	7e 85       	ldd	r23, Y+14	; 0x0e
    41a8:	8f 85       	ldd	r24, Y+15	; 0x0f
    41aa:	98 89       	ldd	r25, Y+16	; 0x10
    41ac:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    41b0:	9b 01       	movw	r18, r22
    41b2:	ac 01       	movw	r20, r24
    41b4:	69 81       	ldd	r22, Y+1	; 0x01
    41b6:	7d 81       	ldd	r23, Y+5	; 0x05
    41b8:	89 85       	ldd	r24, Y+9	; 0x09
    41ba:	99 89       	ldd	r25, Y+17	; 0x11
    41bc:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    41c0:	24 2d       	mov	r18, r4
    41c2:	33 2d       	mov	r19, r3
    41c4:	42 2d       	mov	r20, r2
    41c6:	5b ad       	ldd	r21, Y+59	; 0x3b
    41c8:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    41cc:	9b 01       	movw	r18, r22
    41ce:	ac 01       	movw	r20, r24
    41d0:	6e 2d       	mov	r22, r14
    41d2:	7d 2d       	mov	r23, r13
    41d4:	8c 2d       	mov	r24, r12
    41d6:	9f 2d       	mov	r25, r15
    41d8:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    41dc:	e6 2e       	mov	r14, r22
    41de:	d7 2e       	mov	r13, r23
    41e0:	c8 2e       	mov	r12, r24
    41e2:	f9 2e       	mov	r15, r25
            prep.current_speed -= speed_var;
    41e4:	2d 85       	ldd	r18, Y+13	; 0x0d
    41e6:	3e 85       	ldd	r19, Y+14	; 0x0e
    41e8:	4f 85       	ldd	r20, Y+15	; 0x0f
    41ea:	58 89       	ldd	r21, Y+16	; 0x10
    41ec:	69 81       	ldd	r22, Y+1	; 0x01
    41ee:	7d 81       	ldd	r23, Y+5	; 0x05
    41f0:	89 85       	ldd	r24, Y+9	; 0x09
    41f2:	99 89       	ldd	r25, Y+17	; 0x11
    41f4:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    41f8:	69 83       	std	Y+1, r22	; 0x01
    41fa:	7d 83       	std	Y+5, r23	; 0x05
    41fc:	89 87       	std	Y+9, r24	; 0x09
    41fe:	99 8b       	std	Y+17, r25	; 0x11
    4200:	4d c1       	rjmp	.+666    	; 0x449c <st_prep_buffer+0xc04>
          }
          break;
        case RAMP_ACCEL:
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
    4202:	aa 8d       	ldd	r26, Y+26	; 0x1a
    4204:	bb 8d       	ldd	r27, Y+27	; 0x1b
    4206:	5e 96       	adiw	r26, 0x1e	; 30
    4208:	2d 91       	ld	r18, X+
    420a:	3d 91       	ld	r19, X+
    420c:	4d 91       	ld	r20, X+
    420e:	5c 91       	ld	r21, X
    4210:	91 97       	sbiw	r26, 0x21	; 33
    4212:	64 2d       	mov	r22, r4
    4214:	73 2d       	mov	r23, r3
    4216:	82 2d       	mov	r24, r2
    4218:	9b ad       	ldd	r25, Y+59	; 0x3b
    421a:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    421e:	6d 87       	std	Y+13, r22	; 0x0d
    4220:	7e 87       	std	Y+14, r23	; 0x0e
    4222:	8f 87       	std	Y+15, r24	; 0x0f
    4224:	98 8b       	std	Y+16, r25	; 0x10
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
    4226:	20 e0       	ldi	r18, 0x00	; 0
    4228:	30 e0       	ldi	r19, 0x00	; 0
    422a:	40 e0       	ldi	r20, 0x00	; 0
    422c:	5f e3       	ldi	r21, 0x3F	; 63
    422e:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    4232:	29 81       	ldd	r18, Y+1	; 0x01
    4234:	3d 81       	ldd	r19, Y+5	; 0x05
    4236:	49 85       	ldd	r20, Y+9	; 0x09
    4238:	59 89       	ldd	r21, Y+17	; 0x11
    423a:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    423e:	24 2d       	mov	r18, r4
    4240:	33 2d       	mov	r19, r3
    4242:	42 2d       	mov	r20, r2
    4244:	5b ad       	ldd	r21, Y+59	; 0x3b
    4246:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    424a:	9b 01       	movw	r18, r22
    424c:	ac 01       	movw	r20, r24
    424e:	6e 2d       	mov	r22, r14
    4250:	7d 2d       	mov	r23, r13
    4252:	8c 2d       	mov	r24, r12
    4254:	9f 2d       	mov	r25, r15
    4256:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    425a:	e6 2e       	mov	r14, r22
    425c:	d7 2e       	mov	r13, r23
    425e:	c8 2e       	mov	r12, r24
    4260:	f9 2e       	mov	r15, r25
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    4262:	26 2f       	mov	r18, r22
    4264:	37 2f       	mov	r19, r23
    4266:	48 2f       	mov	r20, r24
    4268:	59 2f       	mov	r21, r25
    426a:	6e 8d       	ldd	r22, Y+30	; 0x1e
    426c:	7f 8d       	ldd	r23, Y+31	; 0x1f
    426e:	88 a1       	ldd	r24, Y+32	; 0x20
    4270:	99 a1       	ldd	r25, Y+33	; 0x21
    4272:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    4276:	18 16       	cp	r1, r24
    4278:	9c f5       	brge	.+102    	; 0x42e0 <st_prep_buffer+0xa48>
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    427a:	2e 8d       	ldd	r18, Y+30	; 0x1e
    427c:	3f 8d       	ldd	r19, Y+31	; 0x1f
    427e:	48 a1       	ldd	r20, Y+32	; 0x20
    4280:	59 a1       	ldd	r21, Y+33	; 0x21
    4282:	6a a5       	ldd	r22, Y+42	; 0x2a
    4284:	7b a5       	ldd	r23, Y+43	; 0x2b
    4286:	8c a5       	ldd	r24, Y+44	; 0x2c
    4288:	9d a5       	ldd	r25, Y+45	; 0x2d
    428a:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    428e:	9b 01       	movw	r18, r22
    4290:	ac 01       	movw	r20, r24
    4292:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    4296:	6b 01       	movw	r12, r22
    4298:	7c 01       	movw	r14, r24
    429a:	29 81       	ldd	r18, Y+1	; 0x01
    429c:	3d 81       	ldd	r19, Y+5	; 0x05
    429e:	49 85       	ldd	r20, Y+9	; 0x09
    42a0:	59 89       	ldd	r21, Y+17	; 0x11
    42a2:	6e 89       	ldd	r22, Y+22	; 0x16
    42a4:	7f 89       	ldd	r23, Y+23	; 0x17
    42a6:	88 8d       	ldd	r24, Y+24	; 0x18
    42a8:	99 8d       	ldd	r25, Y+25	; 0x19
    42aa:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    42ae:	9b 01       	movw	r18, r22
    42b0:	ac 01       	movw	r20, r24
    42b2:	c7 01       	movw	r24, r14
    42b4:	b6 01       	movw	r22, r12
    42b6:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <__divsf3>
    42ba:	46 2e       	mov	r4, r22
    42bc:	37 2e       	mov	r3, r23
    42be:	28 2e       	mov	r2, r24
    42c0:	9b af       	std	Y+59, r25	; 0x3b
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
    42c2:	be 89       	ldd	r27, Y+22	; 0x16
    42c4:	b9 83       	std	Y+1, r27	; 0x01
    42c6:	ef 89       	ldd	r30, Y+23	; 0x17
    42c8:	ed 83       	std	Y+5, r30	; 0x05
    42ca:	f8 8d       	ldd	r31, Y+24	; 0x18
    42cc:	f9 87       	std	Y+9, r31	; 0x09
    42ce:	29 8d       	ldd	r18, Y+25	; 0x19
    42d0:	29 8b       	std	Y+17, r18	; 0x11
    42d2:	3d a9       	ldd	r19, Y+53	; 0x35
    42d4:	3c af       	std	Y+60, r19	; 0x3c
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
    42d6:	ee 8c       	ldd	r14, Y+30	; 0x1e
    42d8:	df 8c       	ldd	r13, Y+31	; 0x1f
    42da:	c8 a0       	ldd	r12, Y+32	; 0x20
    42dc:	f9 a0       	ldd	r15, Y+33	; 0x21
    42de:	de c0       	rjmp	.+444    	; 0x449c <st_prep_buffer+0xc04>
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
          } else { // Acceleration only.
            prep.current_speed += speed_var;
    42e0:	2d 85       	ldd	r18, Y+13	; 0x0d
    42e2:	3e 85       	ldd	r19, Y+14	; 0x0e
    42e4:	4f 85       	ldd	r20, Y+15	; 0x0f
    42e6:	58 89       	ldd	r21, Y+16	; 0x10
    42e8:	69 81       	ldd	r22, Y+1	; 0x01
    42ea:	7d 81       	ldd	r23, Y+5	; 0x05
    42ec:	89 85       	ldd	r24, Y+9	; 0x09
    42ee:	99 89       	ldd	r25, Y+17	; 0x11
    42f0:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    42f4:	69 83       	std	Y+1, r22	; 0x01
    42f6:	7d 83       	std	Y+5, r23	; 0x05
    42f8:	89 87       	std	Y+9, r24	; 0x09
    42fa:	99 8b       	std	Y+17, r25	; 0x11
    42fc:	cf c0       	rjmp	.+414    	; 0x449c <st_prep_buffer+0xc04>
          break;
        case RAMP_CRUISE:
          // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
          // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To
          //   prevent this, simply enforce a minimum speed threshold in the planner.
          mm_var = mm_remaining - prep.maximum_speed*time_var;
    42fe:	2e 89       	ldd	r18, Y+22	; 0x16
    4300:	3f 89       	ldd	r19, Y+23	; 0x17
    4302:	48 8d       	ldd	r20, Y+24	; 0x18
    4304:	59 8d       	ldd	r21, Y+25	; 0x19
    4306:	64 2d       	mov	r22, r4
    4308:	73 2d       	mov	r23, r3
    430a:	82 2d       	mov	r24, r2
    430c:	9b ad       	ldd	r25, Y+59	; 0x3b
    430e:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    4312:	9b 01       	movw	r18, r22
    4314:	ac 01       	movw	r20, r24
    4316:	6e 2d       	mov	r22, r14
    4318:	7d 2d       	mov	r23, r13
    431a:	8c 2d       	mov	r24, r12
    431c:	9f 2d       	mov	r25, r15
    431e:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    4322:	6d 87       	std	Y+13, r22	; 0x0d
    4324:	7c 8f       	std	Y+28, r23	; 0x1c
    4326:	8d 8f       	std	Y+29, r24	; 0x1d
    4328:	69 2e       	mov	r6, r25
          if (mm_var < prep.decelerate_after) { // End of cruise.
    432a:	26 2f       	mov	r18, r22
    432c:	37 2f       	mov	r19, r23
    432e:	48 2f       	mov	r20, r24
    4330:	59 2f       	mov	r21, r25
    4332:	6e a1       	ldd	r22, Y+38	; 0x26
    4334:	7f a1       	ldd	r23, Y+39	; 0x27
    4336:	88 a5       	ldd	r24, Y+40	; 0x28
    4338:	99 a5       	ldd	r25, Y+41	; 0x29
    433a:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    433e:	18 16       	cp	r1, r24
    4340:	0c f0       	brlt	.+2      	; 0x4344 <st_prep_buffer+0xaac>
    4342:	a8 c0       	rjmp	.+336    	; 0x4494 <st_prep_buffer+0xbfc>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
    4344:	2e a1       	ldd	r18, Y+38	; 0x26
    4346:	3f a1       	ldd	r19, Y+39	; 0x27
    4348:	48 a5       	ldd	r20, Y+40	; 0x28
    434a:	59 a5       	ldd	r21, Y+41	; 0x29
    434c:	6e 2d       	mov	r22, r14
    434e:	7d 2d       	mov	r23, r13
    4350:	8c 2d       	mov	r24, r12
    4352:	9f 2d       	mov	r25, r15
    4354:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    4358:	2e 89       	ldd	r18, Y+22	; 0x16
    435a:	3f 89       	ldd	r19, Y+23	; 0x17
    435c:	48 8d       	ldd	r20, Y+24	; 0x18
    435e:	59 8d       	ldd	r21, Y+25	; 0x19
    4360:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <__divsf3>
    4364:	46 2e       	mov	r4, r22
    4366:	37 2e       	mov	r3, r23
    4368:	28 2e       	mov	r2, r24
    436a:	9b af       	std	Y+59, r25	; 0x3b
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
    436c:	ee a0       	ldd	r14, Y+38	; 0x26
    436e:	df a0       	ldd	r13, Y+39	; 0x27
    4370:	c8 a4       	ldd	r12, Y+40	; 0x28
    4372:	f9 a4       	ldd	r15, Y+41	; 0x29
            prep.ramp_type = RAMP_DECEL;
    4374:	49 ad       	ldd	r20, Y+57	; 0x39
    4376:	4c af       	std	Y+60, r20	; 0x3c
    4378:	91 c0       	rjmp	.+290    	; 0x449c <st_prep_buffer+0xc04>
            mm_remaining = mm_var;
          }
          break;
        default: // case RAMP_DECEL:
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
    437a:	aa 8d       	ldd	r26, Y+26	; 0x1a
    437c:	bb 8d       	ldd	r27, Y+27	; 0x1b
    437e:	5e 96       	adiw	r26, 0x1e	; 30
    4380:	2d 91       	ld	r18, X+
    4382:	3d 91       	ld	r19, X+
    4384:	4d 91       	ld	r20, X+
    4386:	5c 91       	ld	r21, X
    4388:	91 97       	sbiw	r26, 0x21	; 33
    438a:	64 2d       	mov	r22, r4
    438c:	73 2d       	mov	r23, r3
    438e:	82 2d       	mov	r24, r2
    4390:	9b ad       	ldd	r25, Y+59	; 0x3b
    4392:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    4396:	6d 87       	std	Y+13, r22	; 0x0d
    4398:	7e 87       	std	Y+14, r23	; 0x0e
    439a:	8f 87       	std	Y+15, r24	; 0x0f
    439c:	98 8b       	std	Y+16, r25	; 0x10
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
    439e:	9b 01       	movw	r18, r22
    43a0:	ac 01       	movw	r20, r24
    43a2:	69 81       	ldd	r22, Y+1	; 0x01
    43a4:	7d 81       	ldd	r23, Y+5	; 0x05
    43a6:	89 85       	ldd	r24, Y+9	; 0x09
    43a8:	99 89       	ldd	r25, Y+17	; 0x11
    43aa:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    43ae:	18 16       	cp	r1, r24
    43b0:	0c f0       	brlt	.+2      	; 0x43b4 <st_prep_buffer+0xb1c>
    43b2:	3f c0       	rjmp	.+126    	; 0x4432 <st_prep_buffer+0xb9a>
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
    43b4:	20 e0       	ldi	r18, 0x00	; 0
    43b6:	30 e0       	ldi	r19, 0x00	; 0
    43b8:	40 e0       	ldi	r20, 0x00	; 0
    43ba:	5f e3       	ldi	r21, 0x3F	; 63
    43bc:	6d 85       	ldd	r22, Y+13	; 0x0d
    43be:	7e 85       	ldd	r23, Y+14	; 0x0e
    43c0:	8f 85       	ldd	r24, Y+15	; 0x0f
    43c2:	98 89       	ldd	r25, Y+16	; 0x10
    43c4:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    43c8:	9b 01       	movw	r18, r22
    43ca:	ac 01       	movw	r20, r24
    43cc:	69 81       	ldd	r22, Y+1	; 0x01
    43ce:	7d 81       	ldd	r23, Y+5	; 0x05
    43d0:	89 85       	ldd	r24, Y+9	; 0x09
    43d2:	99 89       	ldd	r25, Y+17	; 0x11
    43d4:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    43d8:	24 2d       	mov	r18, r4
    43da:	33 2d       	mov	r19, r3
    43dc:	42 2d       	mov	r20, r2
    43de:	5b ad       	ldd	r21, Y+59	; 0x3b
    43e0:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    43e4:	9b 01       	movw	r18, r22
    43e6:	ac 01       	movw	r20, r24
    43e8:	6e 2d       	mov	r22, r14
    43ea:	7d 2d       	mov	r23, r13
    43ec:	8c 2d       	mov	r24, r12
    43ee:	9f 2d       	mov	r25, r15
    43f0:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    43f4:	6c 8f       	std	Y+28, r22	; 0x1c
    43f6:	7d 8f       	std	Y+29, r23	; 0x1d
    43f8:	8c ab       	std	Y+52, r24	; 0x34
    43fa:	69 2e       	mov	r6, r25
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
    43fc:	2a 89       	ldd	r18, Y+18	; 0x12
    43fe:	3b 89       	ldd	r19, Y+19	; 0x13
    4400:	4c 89       	ldd	r20, Y+20	; 0x14
    4402:	5d 89       	ldd	r21, Y+21	; 0x15
    4404:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    4408:	18 16       	cp	r1, r24
    440a:	9c f4       	brge	.+38     	; 0x4432 <st_prep_buffer+0xb9a>
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
    440c:	2d 85       	ldd	r18, Y+13	; 0x0d
    440e:	3e 85       	ldd	r19, Y+14	; 0x0e
    4410:	4f 85       	ldd	r20, Y+15	; 0x0f
    4412:	58 89       	ldd	r21, Y+16	; 0x10
    4414:	69 81       	ldd	r22, Y+1	; 0x01
    4416:	7d 81       	ldd	r23, Y+5	; 0x05
    4418:	89 85       	ldd	r24, Y+9	; 0x09
    441a:	99 89       	ldd	r25, Y+17	; 0x11
    441c:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    4420:	69 83       	std	Y+1, r22	; 0x01
    4422:	7d 83       	std	Y+5, r23	; 0x05
    4424:	89 87       	std	Y+9, r24	; 0x09
    4426:	99 8b       	std	Y+17, r25	; 0x11
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
              mm_remaining = mm_var;
    4428:	ec 8c       	ldd	r14, Y+28	; 0x1c
    442a:	dd 8c       	ldd	r13, Y+29	; 0x1d
    442c:	cc a8       	ldd	r12, Y+52	; 0x34
    442e:	f6 2c       	mov	r15, r6
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
    4430:	35 c0       	rjmp	.+106    	; 0x449c <st_prep_buffer+0xc04>
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    4432:	2a 89       	ldd	r18, Y+18	; 0x12
    4434:	3b 89       	ldd	r19, Y+19	; 0x13
    4436:	4c 89       	ldd	r20, Y+20	; 0x14
    4438:	5d 89       	ldd	r21, Y+21	; 0x15
    443a:	6e 2d       	mov	r22, r14
    443c:	7d 2d       	mov	r23, r13
    443e:	8c 2d       	mov	r24, r12
    4440:	9f 2d       	mov	r25, r15
    4442:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    4446:	9b 01       	movw	r18, r22
    4448:	ac 01       	movw	r20, r24
    444a:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    444e:	6b 01       	movw	r12, r22
    4450:	7c 01       	movw	r14, r24
    4452:	2e a5       	ldd	r18, Y+46	; 0x2e
    4454:	3f a5       	ldd	r19, Y+47	; 0x2f
    4456:	48 a9       	ldd	r20, Y+48	; 0x30
    4458:	59 a9       	ldd	r21, Y+49	; 0x31
    445a:	69 81       	ldd	r22, Y+1	; 0x01
    445c:	7d 81       	ldd	r23, Y+5	; 0x05
    445e:	89 85       	ldd	r24, Y+9	; 0x09
    4460:	99 89       	ldd	r25, Y+17	; 0x11
    4462:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    4466:	9b 01       	movw	r18, r22
    4468:	ac 01       	movw	r20, r24
    446a:	c7 01       	movw	r24, r14
    446c:	b6 01       	movw	r22, r12
    446e:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <__divsf3>
    4472:	46 2e       	mov	r4, r22
    4474:	37 2e       	mov	r3, r23
    4476:	28 2e       	mov	r2, r24
    4478:	9b af       	std	Y+59, r25	; 0x3b
          mm_remaining = prep.mm_complete;
          prep.current_speed = prep.exit_speed;
    447a:	be a5       	ldd	r27, Y+46	; 0x2e
    447c:	b9 83       	std	Y+1, r27	; 0x01
    447e:	ef a5       	ldd	r30, Y+47	; 0x2f
    4480:	ed 83       	std	Y+5, r30	; 0x05
    4482:	f8 a9       	ldd	r31, Y+48	; 0x30
    4484:	f9 87       	std	Y+9, r31	; 0x09
    4486:	29 a9       	ldd	r18, Y+49	; 0x31
    4488:	29 8b       	std	Y+17, r18	; 0x11
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete;
    448a:	ea 88       	ldd	r14, Y+18	; 0x12
    448c:	db 88       	ldd	r13, Y+19	; 0x13
    448e:	cc 88       	ldd	r12, Y+20	; 0x14
    4490:	fd 88       	ldd	r15, Y+21	; 0x15
    4492:	04 c0       	rjmp	.+8      	; 0x449c <st_prep_buffer+0xc04>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
          } else { // Cruising only.
            mm_remaining = mm_var;
    4494:	ed 84       	ldd	r14, Y+13	; 0x0d
    4496:	dc 8c       	ldd	r13, Y+28	; 0x1c
    4498:	cd 8c       	ldd	r12, Y+29	; 0x1d
    449a:	f6 2c       	mov	r15, r6
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete;
          prep.current_speed = prep.exit_speed;
      }
      dt += time_var; // Add computed ramp time to total segment time.
    449c:	24 2d       	mov	r18, r4
    449e:	33 2d       	mov	r19, r3
    44a0:	42 2d       	mov	r20, r2
    44a2:	5b ad       	ldd	r21, Y+59	; 0x3b
    44a4:	c5 01       	movw	r24, r10
    44a6:	b4 01       	movw	r22, r8
    44a8:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    44ac:	4b 01       	movw	r8, r22
    44ae:	5c 01       	movw	r10, r24
      if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
    44b0:	9b 01       	movw	r18, r22
    44b2:	ac 01       	movw	r20, r24
    44b4:	67 2d       	mov	r22, r7
    44b6:	75 2d       	mov	r23, r5
    44b8:	81 2f       	mov	r24, r17
    44ba:	90 2f       	mov	r25, r16
    44bc:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    44c0:	18 16       	cp	r1, r24
    44c2:	6c f4       	brge	.+26     	; 0x44de <st_prep_buffer+0xc46>
    44c4:	a5 01       	movw	r20, r10
    44c6:	94 01       	movw	r18, r8
    44c8:	67 2d       	mov	r22, r7
    44ca:	75 2d       	mov	r23, r5
    44cc:	81 2f       	mov	r24, r17
    44ce:	90 2f       	mov	r25, r16
    44d0:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    44d4:	46 2e       	mov	r4, r22
    44d6:	37 2e       	mov	r3, r23
    44d8:	28 2e       	mov	r2, r24
    44da:	9b af       	std	Y+59, r25	; 0x3b
    44dc:	36 c0       	rjmp	.+108    	; 0x454a <st_prep_buffer+0xcb2>
      else {
        if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
    44de:	2a a1       	ldd	r18, Y+34	; 0x22
    44e0:	3b a1       	ldd	r19, Y+35	; 0x23
    44e2:	4c a1       	ldd	r20, Y+36	; 0x24
    44e4:	5d a1       	ldd	r21, Y+37	; 0x25
    44e6:	6e 2d       	mov	r22, r14
    44e8:	7d 2d       	mov	r23, r13
    44ea:	8c 2d       	mov	r24, r12
    44ec:	9f 2d       	mov	r25, r15
    44ee:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    44f2:	18 16       	cp	r1, r24
    44f4:	a4 f0       	brlt	.+40     	; 0x451e <st_prep_buffer+0xc86>
    44f6:	3c ad       	ldd	r19, Y+60	; 0x3c
    44f8:	6e a8       	ldd	r6, Y+54	; 0x36
    44fa:	7f a8       	ldd	r7, Y+55	; 0x37
    44fc:	5e 2c       	mov	r5, r14
    44fe:	1d 2d       	mov	r17, r13
    4500:	0c 2d       	mov	r16, r12
    4502:	fc 8e       	std	Y+28, r15	; 0x1c
    4504:	d3 01       	movw	r26, r6
    4506:	52 96       	adiw	r26, 0x12	; 18
    4508:	3c 93       	st	X, r19
    450a:	89 81       	ldd	r24, Y+1	; 0x01
    450c:	9d 81       	ldd	r25, Y+5	; 0x05
    450e:	a9 85       	ldd	r26, Y+9	; 0x09
    4510:	b9 89       	ldd	r27, Y+17	; 0x11
    4512:	f3 01       	movw	r30, r6
    4514:	87 8b       	std	Z+23, r24	; 0x17
    4516:	90 8f       	std	Z+24, r25	; 0x18
    4518:	a1 8f       	std	Z+25, r26	; 0x19
    451a:	b2 8f       	std	Z+26, r27	; 0x1a
    451c:	37 c0       	rjmp	.+110    	; 0x458c <st_prep_buffer+0xcf4>
          // Increase segment time to ensure at least one step in segment. Override and loop
          // through distance calculations until minimum_mm or mm_complete.
          dt_max += DT_SEGMENT;
    451e:	2e e3       	ldi	r18, 0x3E	; 62
    4520:	33 ec       	ldi	r19, 0xC3	; 195
    4522:	4e e2       	ldi	r20, 0x2E	; 46
    4524:	59 e3       	ldi	r21, 0x39	; 57
    4526:	67 2d       	mov	r22, r7
    4528:	75 2d       	mov	r23, r5
    452a:	81 2f       	mov	r24, r17
    452c:	90 2f       	mov	r25, r16
    452e:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    4532:	76 2e       	mov	r7, r22
    4534:	57 2e       	mov	r5, r23
    4536:	18 2f       	mov	r17, r24
    4538:	09 2f       	mov	r16, r25
          time_var = dt_max - dt;
    453a:	a5 01       	movw	r20, r10
    453c:	94 01       	movw	r18, r8
    453e:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    4542:	46 2e       	mov	r4, r22
    4544:	37 2e       	mov	r3, r23
    4546:	28 2e       	mov	r2, r24
    4548:	9b af       	std	Y+59, r25	; 0x3b
        } else {
          break; // **Complete** Exit loop. Segment execution time maxed.
        }
      }
    } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
    454a:	2a 89       	ldd	r18, Y+18	; 0x12
    454c:	3b 89       	ldd	r19, Y+19	; 0x13
    454e:	4c 89       	ldd	r20, Y+20	; 0x14
    4550:	5d 89       	ldd	r21, Y+21	; 0x15
    4552:	6e 2d       	mov	r22, r14
    4554:	7d 2d       	mov	r23, r13
    4556:	8c 2d       	mov	r24, r12
    4558:	9f 2d       	mov	r25, r15
    455a:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    455e:	18 16       	cp	r1, r24
    4560:	0c f4       	brge	.+2      	; 0x4564 <st_prep_buffer+0xccc>
    4562:	ba cd       	rjmp	.-1164   	; 0x40d8 <st_prep_buffer+0x840>
    4564:	fc ad       	ldd	r31, Y+60	; 0x3c
    4566:	fd 8f       	std	Y+29, r31	; 0x1d
    4568:	6e a8       	ldd	r6, Y+54	; 0x36
    456a:	7f a8       	ldd	r7, Y+55	; 0x37
    456c:	5e 2c       	mov	r5, r14
    456e:	1d 2d       	mov	r17, r13
    4570:	0c 2d       	mov	r16, r12
    4572:	fc 8e       	std	Y+28, r15	; 0x1c
    4574:	d3 01       	movw	r26, r6
    4576:	52 96       	adiw	r26, 0x12	; 18
    4578:	fc 93       	st	X, r31
    457a:	89 81       	ldd	r24, Y+1	; 0x01
    457c:	9d 81       	ldd	r25, Y+5	; 0x05
    457e:	a9 85       	ldd	r26, Y+9	; 0x09
    4580:	b9 89       	ldd	r27, Y+17	; 0x11
    4582:	f3 01       	movw	r30, r6
    4584:	87 8b       	std	Z+23, r24	; 0x17
    4586:	90 8f       	std	Z+24, r25	; 0x18
    4588:	a1 8f       	std	Z+25, r26	; 0x19
    458a:	b2 8f       	std	Z+26, r27	; 0x1a

    /* -----------------------------------------------------------------------------------
      Compute spindle speed PWM output for step segment
    */
    
    if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
    458c:	e0 91 39 03 	lds	r30, 0x0339	; 0x800339 <st_prep_block>
    4590:	f0 91 3a 03 	lds	r31, 0x033A	; 0x80033a <st_prep_block+0x1>
    4594:	81 89       	ldd	r24, Z+17	; 0x11
    4596:	81 11       	cpse	r24, r1
    4598:	99 c1       	rjmp	.+818    	; 0x48cc <st_prep_buffer+0x1034>
    459a:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    459e:	83 fd       	sbrc	r24, 3
    45a0:	a5 c1       	rjmp	.+842    	; 0x48ec <st_prep_buffer+0x1054>
    45a2:	18 c0       	rjmp	.+48     	; 0x45d4 <st_prep_buffer+0xd3c>
        float rpm = pl_block->spindle_speed;
        // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.        
        if (st_prep_block->is_pwm_rate_adjusted) { rpm *= (prep.current_speed * prep.inv_rate); }
        // If current_speed is zero, then may need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE)
        // but this would be instantaneous only and during a motion. May not matter at all.
        prep.current_spindle_pwm = spindle_compute_pwm_value(rpm);
    45a4:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <spindle_compute_pwm_value>
    45a8:	d3 01       	movw	r26, r6
    45aa:	d0 96       	adiw	r26, 0x30	; 48
    45ac:	9c 93       	st	X, r25
    45ae:	8e 93       	st	-X, r24
    45b0:	9f 97       	sbiw	r26, 0x2f	; 47
    45b2:	0b c0       	rjmp	.+22     	; 0x45ca <st_prep_buffer+0xd32>
      } else { 
        sys.spindle_speed = 0.0;
    45b4:	10 92 2c 0c 	sts	0x0C2C, r1	; 0x800c2c <sys+0xe>
    45b8:	10 92 2d 0c 	sts	0x0C2D, r1	; 0x800c2d <sys+0xf>
    45bc:	10 92 2e 0c 	sts	0x0C2E, r1	; 0x800c2e <sys+0x10>
    45c0:	10 92 2f 0c 	sts	0x0C2F, r1	; 0x800c2f <sys+0x11>
        prep.current_spindle_pwm = SPINDLE_PWM_OFF_VALUE;
    45c4:	f3 01       	movw	r30, r6
    45c6:	10 aa       	std	Z+48, r1	; 0x30
    45c8:	17 a6       	std	Z+47, r1	; 0x2f
      }
      bit_false(sys.step_control,STEP_CONTROL_UPDATE_SPINDLE_PWM);
    45ca:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    45ce:	87 7f       	andi	r24, 0xF7	; 247
    45d0:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <sys+0x4>
    }
    prep_segment->spindle_pwm = prep.current_spindle_pwm; // Reload segment PWM value
    45d4:	8a a9       	ldd	r24, Y+50	; 0x32
    45d6:	9b a9       	ldd	r25, Y+51	; 0x33
    45d8:	88 0f       	add	r24, r24
    45da:	99 1f       	adc	r25, r25
    45dc:	88 0f       	add	r24, r24
    45de:	99 1f       	adc	r25, r25
    45e0:	88 0f       	add	r24, r24
    45e2:	99 1f       	adc	r25, r25
    45e4:	9c 01       	movw	r18, r24
    45e6:	2a 59       	subi	r18, 0x9A	; 154
    45e8:	3c 4f       	sbci	r19, 0xFC	; 252
    45ea:	19 01       	movw	r2, r18
    45ec:	d3 01       	movw	r26, r6
    45ee:	9f 96       	adiw	r26, 0x2f	; 47
    45f0:	8d 91       	ld	r24, X+
    45f2:	9c 91       	ld	r25, X
    45f4:	d0 97       	sbiw	r26, 0x30	; 48
    45f6:	f9 01       	movw	r30, r18
    45f8:	97 83       	std	Z+7, r25	; 0x07
    45fa:	86 83       	std	Z+6, r24	; 0x06
       However, since floats have only 7.2 significant digits, long moves with extremely
       high step counts can exceed the precision of floats, which can lead to lost steps.
       Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
       supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    */
    float step_dist_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
    45fc:	1a 96       	adiw	r26, 0x0a	; 10
    45fe:	2d 91       	ld	r18, X+
    4600:	3d 91       	ld	r19, X+
    4602:	4d 91       	ld	r20, X+
    4604:	5c 91       	ld	r21, X
    4606:	1d 97       	sbiw	r26, 0x0d	; 13
    4608:	65 2d       	mov	r22, r5
    460a:	71 2f       	mov	r23, r17
    460c:	80 2f       	mov	r24, r16
    460e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4610:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    4614:	69 83       	std	Y+1, r22	; 0x01
    4616:	7a 83       	std	Y+2, r23	; 0x02
    4618:	8b 83       	std	Y+3, r24	; 0x03
    461a:	9c 83       	std	Y+4, r25	; 0x04
    float n_steps_remaining = ceil(step_dist_remaining); // Round-up current steps remaining
    461c:	0e 94 56 3f 	call	0x7eac	; 0x7eac <ceil>
    4620:	6d 83       	std	Y+5, r22	; 0x05
    4622:	7e 83       	std	Y+6, r23	; 0x06
    4624:	8f 83       	std	Y+7, r24	; 0x07
    4626:	98 87       	std	Y+8, r25	; 0x08
    float last_n_steps_remaining = ceil(prep.steps_remaining); // Round-up last steps remaining
    4628:	d3 01       	movw	r26, r6
    462a:	16 96       	adiw	r26, 0x06	; 6
    462c:	6d 91       	ld	r22, X+
    462e:	7d 91       	ld	r23, X+
    4630:	8d 91       	ld	r24, X+
    4632:	9c 91       	ld	r25, X
    4634:	19 97       	sbiw	r26, 0x09	; 9
    4636:	0e 94 56 3f 	call	0x7eac	; 0x7eac <ceil>
    463a:	69 87       	std	Y+9, r22	; 0x09
    463c:	7a 87       	std	Y+10, r23	; 0x0a
    463e:	8b 87       	std	Y+11, r24	; 0x0b
    4640:	9c 87       	std	Y+12, r25	; 0x0c
    prep_segment->n_step = last_n_steps_remaining-n_steps_remaining; // Compute number of steps to execute.
    4642:	2d 81       	ldd	r18, Y+5	; 0x05
    4644:	3e 81       	ldd	r19, Y+6	; 0x06
    4646:	4f 81       	ldd	r20, Y+7	; 0x07
    4648:	58 85       	ldd	r21, Y+8	; 0x08
    464a:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    464e:	0e 94 dd 3f 	call	0x7fba	; 0x7fba <__fixunssfsi>
    4652:	6b 01       	movw	r12, r22
    4654:	7c 01       	movw	r14, r24
    4656:	f1 01       	movw	r30, r2
    4658:	71 83       	std	Z+1, r23	; 0x01
    465a:	60 83       	st	Z, r22

    // Bail if we are at the end of a feed hold and don't have a step to execute.
    if (prep_segment->n_step == 0) {
    465c:	67 2b       	or	r22, r23
    465e:	41 f4       	brne	.+16     	; 0x4670 <st_prep_buffer+0xdd8>
      if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) {
    4660:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    4664:	81 ff       	sbrs	r24, 1
    4666:	04 c0       	rjmp	.+8      	; 0x4670 <st_prep_buffer+0xdd8>
        // Less than one step to decelerate to zero speed, but already very close. AMASS
        // requires full steps to execute. So, just bail.
        bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    4668:	81 60       	ori	r24, 0x01	; 1
    466a:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <sys+0x4>
        #ifdef PARKING_ENABLE
          if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
        #endif
        return; // Segment not generated, but current step data still retained.
    466e:	44 c1       	rjmp	.+648    	; 0x48f8 <st_prep_buffer+0x1060>
    // apply it with the partial step distance to the current segment, so that it minutely
    // adjusts the whole segment rate to keep step output exact. These rate adjustments are
    // typically very small and do not adversely effect performance, but ensures that Grbl
    // outputs the exact acceleration and velocity profiles as computed by the planner.
    dt += prep.dt_remainder; // Apply previous segment partial step execute time
    float inv_rate = dt/(last_n_steps_remaining - step_dist_remaining); // Compute adjusted step rate inverse
    4670:	d3 01       	movw	r26, r6
    4672:	12 96       	adiw	r26, 0x02	; 2
    4674:	2d 91       	ld	r18, X+
    4676:	3d 91       	ld	r19, X+
    4678:	4d 91       	ld	r20, X+
    467a:	5c 91       	ld	r21, X
    467c:	15 97       	sbiw	r26, 0x05	; 5
    467e:	c5 01       	movw	r24, r10
    4680:	b4 01       	movw	r22, r8
    4682:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    4686:	4b 01       	movw	r8, r22
    4688:	5c 01       	movw	r10, r24
    468a:	29 81       	ldd	r18, Y+1	; 0x01
    468c:	3a 81       	ldd	r19, Y+2	; 0x02
    468e:	4b 81       	ldd	r20, Y+3	; 0x03
    4690:	5c 81       	ldd	r21, Y+4	; 0x04
    4692:	69 85       	ldd	r22, Y+9	; 0x09
    4694:	7a 85       	ldd	r23, Y+10	; 0x0a
    4696:	8b 85       	ldd	r24, Y+11	; 0x0b
    4698:	9c 85       	ldd	r25, Y+12	; 0x0c
    469a:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    469e:	9b 01       	movw	r18, r22
    46a0:	ac 01       	movw	r20, r24
    46a2:	c5 01       	movw	r24, r10
    46a4:	b4 01       	movw	r22, r8
    46a6:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <__divsf3>
    46aa:	4b 01       	movw	r8, r22
    46ac:	5c 01       	movw	r10, r24

    // Compute CPU cycles per step for the prepped segment.
    uint32_t cycles = ceil( (TICKS_PER_MICROSECOND*1000000*60)*inv_rate ); // (cycles/step)
    46ae:	20 ec       	ldi	r18, 0xC0	; 192
    46b0:	31 ee       	ldi	r19, 0xE1	; 225
    46b2:	44 e6       	ldi	r20, 0x64	; 100
    46b4:	5e e4       	ldi	r21, 0x4E	; 78
    46b6:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    46ba:	0e 94 56 3f 	call	0x7eac	; 0x7eac <ceil>
    46be:	0e 94 dd 3f 	call	0x7fba	; 0x7fba <__fixunssfsi>

    #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
      // Compute step timing and multi-axis smoothing level.
      // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
      if (cycles < AMASS_LEVEL1) { prep_segment->amass_level = 0; }
    46c2:	60 3d       	cpi	r22, 0xD0	; 208
    46c4:	b7 e0       	ldi	r27, 0x07	; 7
    46c6:	7b 07       	cpc	r23, r27
    46c8:	81 05       	cpc	r24, r1
    46ca:	91 05       	cpc	r25, r1
    46cc:	60 f4       	brcc	.+24     	; 0x46e6 <st_prep_buffer+0xe4e>
    46ce:	ea a9       	ldd	r30, Y+50	; 0x32
    46d0:	fb a9       	ldd	r31, Y+51	; 0x33
    46d2:	ee 0f       	add	r30, r30
    46d4:	ff 1f       	adc	r31, r31
    46d6:	ee 0f       	add	r30, r30
    46d8:	ff 1f       	adc	r31, r31
    46da:	ee 0f       	add	r30, r30
    46dc:	ff 1f       	adc	r31, r31
    46de:	ea 59       	subi	r30, 0x9A	; 154
    46e0:	fc 4f       	sbci	r31, 0xFC	; 252
    46e2:	15 82       	std	Z+5, r1	; 0x05
    46e4:	4d c0       	rjmp	.+154    	; 0x4780 <st_prep_buffer+0xee8>
      else {
        if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }
    46e6:	60 3a       	cpi	r22, 0xA0	; 160
    46e8:	ef e0       	ldi	r30, 0x0F	; 15
    46ea:	7e 07       	cpc	r23, r30
    46ec:	81 05       	cpc	r24, r1
    46ee:	91 05       	cpc	r25, r1
    46f0:	68 f4       	brcc	.+26     	; 0x470c <st_prep_buffer+0xe74>
    46f2:	ea a9       	ldd	r30, Y+50	; 0x32
    46f4:	fb a9       	ldd	r31, Y+51	; 0x33
    46f6:	ee 0f       	add	r30, r30
    46f8:	ff 1f       	adc	r31, r31
    46fa:	ee 0f       	add	r30, r30
    46fc:	ff 1f       	adc	r31, r31
    46fe:	ee 0f       	add	r30, r30
    4700:	ff 1f       	adc	r31, r31
    4702:	ea 59       	subi	r30, 0x9A	; 154
    4704:	fc 4f       	sbci	r31, 0xFC	; 252
    4706:	21 e0       	ldi	r18, 0x01	; 1
    4708:	25 83       	std	Z+5, r18	; 0x05
    470a:	1f c0       	rjmp	.+62     	; 0x474a <st_prep_buffer+0xeb2>
        else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }
    470c:	60 34       	cpi	r22, 0x40	; 64
    470e:	3f e1       	ldi	r19, 0x1F	; 31
    4710:	73 07       	cpc	r23, r19
    4712:	81 05       	cpc	r24, r1
    4714:	91 05       	cpc	r25, r1
    4716:	68 f4       	brcc	.+26     	; 0x4732 <st_prep_buffer+0xe9a>
    4718:	ea a9       	ldd	r30, Y+50	; 0x32
    471a:	fb a9       	ldd	r31, Y+51	; 0x33
    471c:	ee 0f       	add	r30, r30
    471e:	ff 1f       	adc	r31, r31
    4720:	ee 0f       	add	r30, r30
    4722:	ff 1f       	adc	r31, r31
    4724:	ee 0f       	add	r30, r30
    4726:	ff 1f       	adc	r31, r31
    4728:	ea 59       	subi	r30, 0x9A	; 154
    472a:	fc 4f       	sbci	r31, 0xFC	; 252
    472c:	42 e0       	ldi	r20, 0x02	; 2
    472e:	45 83       	std	Z+5, r20	; 0x05
    4730:	0c c0       	rjmp	.+24     	; 0x474a <st_prep_buffer+0xeb2>
        else { prep_segment->amass_level = 3; }
    4732:	ea a9       	ldd	r30, Y+50	; 0x32
    4734:	fb a9       	ldd	r31, Y+51	; 0x33
    4736:	ee 0f       	add	r30, r30
    4738:	ff 1f       	adc	r31, r31
    473a:	ee 0f       	add	r30, r30
    473c:	ff 1f       	adc	r31, r31
    473e:	ee 0f       	add	r30, r30
    4740:	ff 1f       	adc	r31, r31
    4742:	ea 59       	subi	r30, 0x9A	; 154
    4744:	fc 4f       	sbci	r31, 0xFC	; 252
    4746:	53 e0       	ldi	r21, 0x03	; 3
    4748:	55 83       	std	Z+5, r21	; 0x05
        cycles >>= prep_segment->amass_level;
    474a:	ea a9       	ldd	r30, Y+50	; 0x32
    474c:	fb a9       	ldd	r31, Y+51	; 0x33
    474e:	ee 0f       	add	r30, r30
    4750:	ff 1f       	adc	r31, r31
    4752:	ee 0f       	add	r30, r30
    4754:	ff 1f       	adc	r31, r31
    4756:	ee 0f       	add	r30, r30
    4758:	ff 1f       	adc	r31, r31
    475a:	ea 59       	subi	r30, 0x9A	; 154
    475c:	fc 4f       	sbci	r31, 0xFC	; 252
    475e:	25 81       	ldd	r18, Z+5	; 0x05
    4760:	02 2e       	mov	r0, r18
    4762:	04 c0       	rjmp	.+8      	; 0x476c <st_prep_buffer+0xed4>
    4764:	96 95       	lsr	r25
    4766:	87 95       	ror	r24
    4768:	77 95       	ror	r23
    476a:	67 95       	ror	r22
    476c:	0a 94       	dec	r0
    476e:	d2 f7       	brpl	.-12     	; 0x4764 <st_prep_buffer+0xecc>
        prep_segment->n_step <<= prep_segment->amass_level;
    4770:	d6 01       	movw	r26, r12
    4772:	02 c0       	rjmp	.+4      	; 0x4778 <st_prep_buffer+0xee0>
    4774:	aa 0f       	add	r26, r26
    4776:	bb 1f       	adc	r27, r27
    4778:	2a 95       	dec	r18
    477a:	e2 f7       	brpl	.-8      	; 0x4774 <st_prep_buffer+0xedc>
    477c:	b1 83       	std	Z+1, r27	; 0x01
    477e:	a0 83       	st	Z, r26
      }
      if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)
    4780:	61 15       	cp	r22, r1
    4782:	71 05       	cpc	r23, r1
    4784:	b1 e0       	ldi	r27, 0x01	; 1
    4786:	8b 07       	cpc	r24, r27
    4788:	91 05       	cpc	r25, r1
    478a:	68 f4       	brcc	.+26     	; 0x47a6 <st_prep_buffer+0xf0e>
    478c:	ea a9       	ldd	r30, Y+50	; 0x32
    478e:	fb a9       	ldd	r31, Y+51	; 0x33
    4790:	ee 0f       	add	r30, r30
    4792:	ff 1f       	adc	r31, r31
    4794:	ee 0f       	add	r30, r30
    4796:	ff 1f       	adc	r31, r31
    4798:	ee 0f       	add	r30, r30
    479a:	ff 1f       	adc	r31, r31
    479c:	ea 59       	subi	r30, 0x9A	; 154
    479e:	fc 4f       	sbci	r31, 0xFC	; 252
    47a0:	73 83       	std	Z+3, r23	; 0x03
    47a2:	62 83       	std	Z+2, r22	; 0x02
    47a4:	0e c0       	rjmp	.+28     	; 0x47c2 <st_prep_buffer+0xf2a>
      else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
    47a6:	ea a9       	ldd	r30, Y+50	; 0x32
    47a8:	fb a9       	ldd	r31, Y+51	; 0x33
    47aa:	ee 0f       	add	r30, r30
    47ac:	ff 1f       	adc	r31, r31
    47ae:	ee 0f       	add	r30, r30
    47b0:	ff 1f       	adc	r31, r31
    47b2:	ee 0f       	add	r30, r30
    47b4:	ff 1f       	adc	r31, r31
    47b6:	ea 59       	subi	r30, 0x9A	; 154
    47b8:	fc 4f       	sbci	r31, 0xFC	; 252
    47ba:	2f ef       	ldi	r18, 0xFF	; 255
    47bc:	3f ef       	ldi	r19, 0xFF	; 255
    47be:	33 83       	std	Z+3, r19	; 0x03
    47c0:	22 83       	std	Z+2, r18	; 0x02
        }
      }
    #endif

    // Segment complete! Increment segment buffer indices, so stepper ISR can immediately execute it.
    segment_buffer_head = segment_next_head;
    47c2:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <segment_next_head>
    47c6:	80 93 41 03 	sts	0x0341, r24	; 0x800341 <segment_buffer_head>
    if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
    47ca:	8f 5f       	subi	r24, 0xFF	; 255
    47cc:	8a 30       	cpi	r24, 0x0A	; 10
    47ce:	19 f0       	breq	.+6      	; 0x47d6 <st_prep_buffer+0xf3e>
    47d0:	80 93 40 03 	sts	0x0340, r24	; 0x800340 <segment_next_head>
    47d4:	02 c0       	rjmp	.+4      	; 0x47da <st_prep_buffer+0xf42>
    47d6:	10 92 40 03 	sts	0x0340, r1	; 0x800340 <segment_next_head>

    // Update the appropriate planner and segment data.
    pl_block->millimeters = mm_remaining;
    47da:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    47de:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    47e2:	85 2d       	mov	r24, r5
    47e4:	91 2f       	mov	r25, r17
    47e6:	a0 2f       	mov	r26, r16
    47e8:	bc 8d       	ldd	r27, Y+28	; 0x1c
    47ea:	82 a3       	std	Z+34, r24	; 0x22
    47ec:	93 a3       	std	Z+35, r25	; 0x23
    47ee:	a4 a3       	std	Z+36, r26	; 0x24
    47f0:	b5 a3       	std	Z+37, r27	; 0x25
    prep.steps_remaining = n_steps_remaining;
    47f2:	8d 81       	ldd	r24, Y+5	; 0x05
    47f4:	9e 81       	ldd	r25, Y+6	; 0x06
    47f6:	af 81       	ldd	r26, Y+7	; 0x07
    47f8:	b8 85       	ldd	r27, Y+8	; 0x08
    47fa:	f3 01       	movw	r30, r6
    47fc:	86 83       	std	Z+6, r24	; 0x06
    47fe:	97 83       	std	Z+7, r25	; 0x07
    4800:	a0 87       	std	Z+8, r26	; 0x08
    4802:	b1 87       	std	Z+9, r27	; 0x09
    prep.dt_remainder = (n_steps_remaining - step_dist_remaining)*inv_rate;
    4804:	29 81       	ldd	r18, Y+1	; 0x01
    4806:	3a 81       	ldd	r19, Y+2	; 0x02
    4808:	4b 81       	ldd	r20, Y+3	; 0x03
    480a:	5c 81       	ldd	r21, Y+4	; 0x04
    480c:	bc 01       	movw	r22, r24
    480e:	cd 01       	movw	r24, r26
    4810:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    4814:	a5 01       	movw	r20, r10
    4816:	94 01       	movw	r18, r8
    4818:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    481c:	d3 01       	movw	r26, r6
    481e:	12 96       	adiw	r26, 0x02	; 2
    4820:	6d 93       	st	X+, r22
    4822:	7d 93       	st	X+, r23
    4824:	8d 93       	st	X+, r24
    4826:	9c 93       	st	X, r25
    4828:	15 97       	sbiw	r26, 0x05	; 5

    // Check for exit conditions and flag to load next planner block.
    if (mm_remaining == prep.mm_complete) {
    482a:	53 96       	adiw	r26, 0x13	; 19
    482c:	2d 91       	ld	r18, X+
    482e:	3d 91       	ld	r19, X+
    4830:	4d 91       	ld	r20, X+
    4832:	5c 91       	ld	r21, X
    4834:	56 97       	sbiw	r26, 0x16	; 22
    4836:	65 2d       	mov	r22, r5
    4838:	71 2f       	mov	r23, r17
    483a:	80 2f       	mov	r24, r16
    483c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    483e:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    4842:	81 11       	cpse	r24, r1
    4844:	22 c0       	rjmp	.+68     	; 0x488a <st_prep_buffer+0xff2>
    4846:	45 2c       	mov	r4, r5
    4848:	2c 8c       	ldd	r2, Y+28	; 0x1c
      // End of planner block or forced-termination. No more distance to be executed.
      if (mm_remaining > 0.0) { // At end of forced-termination.
    484a:	20 e0       	ldi	r18, 0x00	; 0
    484c:	30 e0       	ldi	r19, 0x00	; 0
    484e:	a9 01       	movw	r20, r18
    4850:	64 2d       	mov	r22, r4
    4852:	71 2f       	mov	r23, r17
    4854:	80 2f       	mov	r24, r16
    4856:	92 2d       	mov	r25, r2
    4858:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    485c:	18 16       	cp	r1, r24
    485e:	34 f4       	brge	.+12     	; 0x486c <st_prep_buffer+0xfd4>
        // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
        // the segment queue, where realtime protocol will set new state upon receiving the
        // cycle stop flag from the ISR. Prep_segment is blocked until then.
        bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    4860:	ee e1       	ldi	r30, 0x1E	; 30
    4862:	fc e0       	ldi	r31, 0x0C	; 12
    4864:	84 81       	ldd	r24, Z+4	; 0x04
    4866:	81 60       	ori	r24, 0x01	; 1
    4868:	84 83       	std	Z+4, r24	; 0x04
        #ifdef PARKING_ENABLE
          if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
        #endif
        return; // Bail!
    486a:	46 c0       	rjmp	.+140    	; 0x48f8 <st_prep_buffer+0x1060>
      } else { // End of planner block
        // The planner block is complete. All steps are set to be executed in the segment buffer.
        if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
    486c:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    4870:	82 ff       	sbrs	r24, 2
    4872:	04 c0       	rjmp	.+8      	; 0x487c <st_prep_buffer+0xfe4>
          bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    4874:	81 60       	ori	r24, 0x01	; 1
    4876:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <sys+0x4>
          return;
    487a:	3e c0       	rjmp	.+124    	; 0x48f8 <st_prep_buffer+0x1060>
        }
        pl_block = NULL; // Set pointer to indicate check and load next planner block.
    487c:	10 92 3c 03 	sts	0x033C, r1	; 0x80033c <pl_block+0x1>
    4880:	10 92 3b 03 	sts	0x033B, r1	; 0x80033b <pl_block>
        plan_discard_current_block();
    4884:	25 d5       	rcall	.+2634   	; 0x52d0 <plan_discard_current_block>
          speed_var = pl_block->acceleration*time_var;
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            prep.ramp_type = RAMP_CRUISE;
    4886:	b1 e0       	ldi	r27, 0x01	; 1
    4888:	b8 af       	std	Y+56, r27	; 0x38
void st_prep_buffer()
{
  // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }

  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
    488a:	90 91 42 03 	lds	r25, 0x0342	; 0x800342 <segment_buffer_tail>
    488e:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <segment_next_head>
    4892:	98 13       	cpse	r25, r24
    4894:	2b c8       	rjmp	.-4010   	; 0x38ec <st_prep_buffer+0x54>
    4896:	30 c0       	rjmp	.+96     	; 0x48f8 <st_prep_buffer+0x1060>
      Compute spindle speed PWM output for step segment
    */
    
    if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
      if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
        float rpm = pl_block->spindle_speed;
    4898:	ea 8d       	ldd	r30, Y+26	; 0x1a
    489a:	fb 8d       	ldd	r31, Y+27	; 0x1b
    489c:	c2 a8       	ldd	r12, Z+50	; 0x32
    489e:	d3 a8       	ldd	r13, Z+51	; 0x33
    48a0:	e4 a8       	ldd	r14, Z+52	; 0x34
    48a2:	f5 a8       	ldd	r15, Z+53	; 0x35
        // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.        
        if (st_prep_block->is_pwm_rate_adjusted) { rpm *= (prep.current_speed * prep.inv_rate); }
    48a4:	d3 01       	movw	r26, r6
    48a6:	9b 96       	adiw	r26, 0x2b	; 43
    48a8:	2d 91       	ld	r18, X+
    48aa:	3d 91       	ld	r19, X+
    48ac:	4d 91       	ld	r20, X+
    48ae:	5c 91       	ld	r21, X
    48b0:	9e 97       	sbiw	r26, 0x2e	; 46
    48b2:	57 96       	adiw	r26, 0x17	; 23
    48b4:	6d 91       	ld	r22, X+
    48b6:	7d 91       	ld	r23, X+
    48b8:	8d 91       	ld	r24, X+
    48ba:	9c 91       	ld	r25, X
    48bc:	5a 97       	sbiw	r26, 0x1a	; 26
    48be:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    48c2:	a7 01       	movw	r20, r14
    48c4:	96 01       	movw	r18, r12
    48c6:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    48ca:	6c ce       	rjmp	.-808    	; 0x45a4 <st_prep_buffer+0xd0c>
    /* -----------------------------------------------------------------------------------
      Compute spindle speed PWM output for step segment
    */
    
    if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
      if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
    48cc:	ea 8d       	ldd	r30, Y+26	; 0x1a
    48ce:	fb 8d       	ldd	r31, Y+27	; 0x1b
    48d0:	81 89       	ldd	r24, Z+17	; 0x11
    48d2:	80 73       	andi	r24, 0x30	; 48
    48d4:	09 f4       	brne	.+2      	; 0x48d8 <st_prep_buffer+0x1040>
    48d6:	6e ce       	rjmp	.-804    	; 0x45b4 <st_prep_buffer+0xd1c>
    48d8:	df cf       	rjmp	.-66     	; 0x4898 <st_prep_buffer+0x1000>
        float rpm = pl_block->spindle_speed;
    48da:	aa 8d       	ldd	r26, Y+26	; 0x1a
    48dc:	bb 8d       	ldd	r27, Y+27	; 0x1b
    48de:	d2 96       	adiw	r26, 0x32	; 50
    48e0:	6d 91       	ld	r22, X+
    48e2:	7d 91       	ld	r23, X+
    48e4:	8d 91       	ld	r24, X+
    48e6:	9c 91       	ld	r25, X
    48e8:	d5 97       	sbiw	r26, 0x35	; 53
    48ea:	5c ce       	rjmp	.-840    	; 0x45a4 <st_prep_buffer+0xd0c>
    /* -----------------------------------------------------------------------------------
      Compute spindle speed PWM output for step segment
    */
    
    if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
      if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
    48ec:	ea 8d       	ldd	r30, Y+26	; 0x1a
    48ee:	fb 8d       	ldd	r31, Y+27	; 0x1b
    48f0:	81 89       	ldd	r24, Z+17	; 0x11
    48f2:	80 73       	andi	r24, 0x30	; 48
    48f4:	91 f7       	brne	.-28     	; 0x48da <st_prep_buffer+0x1042>
    48f6:	5e ce       	rjmp	.-836    	; 0x45b4 <st_prep_buffer+0xd1c>
        plan_discard_current_block();
      }
    }

  }
}
    48f8:	ec 96       	adiw	r28, 0x3c	; 60
    48fa:	0f b6       	in	r0, 0x3f	; 63
    48fc:	f8 94       	cli
    48fe:	de bf       	out	0x3e, r29	; 62
    4900:	0f be       	out	0x3f, r0	; 63
    4902:	cd bf       	out	0x3d, r28	; 61
    4904:	df 91       	pop	r29
    4906:	cf 91       	pop	r28
    4908:	1f 91       	pop	r17
    490a:	0f 91       	pop	r16
    490c:	ff 90       	pop	r15
    490e:	ef 90       	pop	r14
    4910:	df 90       	pop	r13
    4912:	cf 90       	pop	r12
    4914:	bf 90       	pop	r11
    4916:	af 90       	pop	r10
    4918:	9f 90       	pop	r9
    491a:	8f 90       	pop	r8
    491c:	7f 90       	pop	r7
    491e:	6f 90       	pop	r6
    4920:	5f 90       	pop	r5
    4922:	4f 90       	pop	r4
    4924:	3f 90       	pop	r3
    4926:	2f 90       	pop	r2
    4928:	08 95       	ret

0000492a <st_get_realtime_rate>:
// however is not exactly the current speed, but the speed computed in the last step segment
// in the segment buffer. It will always be behind by up to the number of segment blocks (-1)
// divided by the ACCELERATION TICKS PER SECOND in seconds.
float st_get_realtime_rate()
{
  if (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)){
    492a:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    492e:	8c 77       	andi	r24, 0x7C	; 124
    4930:	49 f0       	breq	.+18     	; 0x4944 <st_get_realtime_rate+0x1a>
    return prep.current_speed;
    4932:	60 91 1f 03 	lds	r22, 0x031F	; 0x80031f <prep+0x17>
    4936:	70 91 20 03 	lds	r23, 0x0320	; 0x800320 <prep+0x18>
    493a:	80 91 21 03 	lds	r24, 0x0321	; 0x800321 <prep+0x19>
    493e:	90 91 22 03 	lds	r25, 0x0322	; 0x800322 <prep+0x1a>
    4942:	08 95       	ret
  }
  return 0.0f;
    4944:	60 e0       	ldi	r22, 0x00	; 0
    4946:	70 e0       	ldi	r23, 0x00	; 0
    4948:	cb 01       	movw	r24, r22
}
    494a:	08 95       	ret

0000494c <eeprom_get_char>:
 *  \param  addr  EEPROM address to read from.
 *  \return  The byte read from the EEPROM address.
 */
unsigned char eeprom_get_char( unsigned int addr )
{
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    494c:	f9 99       	sbic	0x1f, 1	; 31
    494e:	fe cf       	rjmp	.-4      	; 0x494c <eeprom_get_char>
	EEAR = addr; // Set EEPROM address register.
    4950:	92 bd       	out	0x22, r25	; 34
    4952:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    4954:	81 e0       	ldi	r24, 0x01	; 1
    4956:	8f bb       	out	0x1f, r24	; 31
	return EEDR; // Return the byte read from EEPROM.
    4958:	80 b5       	in	r24, 0x20	; 32
}
    495a:	08 95       	ret

0000495c <eeprom_put_char>:
void eeprom_put_char( unsigned int addr, unsigned char new_value )
{
	char old_value; // Old EEPROM value.
	char diff_mask; // Difference mask, i.e. old value XOR new value.

	cli(); // Ensure atomic operation for the write operation.
    495c:	f8 94       	cli
	
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    495e:	f9 99       	sbic	0x1f, 1	; 31
    4960:	fe cf       	rjmp	.-4      	; 0x495e <eeprom_put_char+0x2>
	#ifndef EEPROM_IGNORE_SELFPROG
	do {} while( SPMCSR & (1<<SELFPRGEN) ); // Wait for completion of SPM.
	#endif
	
	EEAR = addr; // Set EEPROM address register.
    4962:	92 bd       	out	0x22, r25	; 34
    4964:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    4966:	81 e0       	ldi	r24, 0x01	; 1
    4968:	8f bb       	out	0x1f, r24	; 31
	old_value = EEDR; // Get old EEPROM value.
    496a:	80 b5       	in	r24, 0x20	; 32
	diff_mask = old_value ^ new_value; // Get bit differences.
    496c:	86 27       	eor	r24, r22
	
	// Check if any bits are changed to '1' in the new value.
	if( diff_mask & new_value ) {
    496e:	96 2f       	mov	r25, r22
    4970:	98 23       	and	r25, r24
    4972:	59 f0       	breq	.+22     	; 0x498a <eeprom_put_char+0x2e>
		// Now we know that _some_ bits need to be erased to '1'.
		
		// Check if any bits in the new value are '0'.
		if( new_value != 0xff ) {
    4974:	6f 3f       	cpi	r22, 0xFF	; 255
    4976:	29 f0       	breq	.+10     	; 0x4982 <eeprom_put_char+0x26>
			// Now we know that some bits need to be programmed to '0' also.
			
			EEDR = new_value; // Set EEPROM data register.
    4978:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    497a:	84 e0       	ldi	r24, 0x04	; 4
    497c:	8f bb       	out	0x1f, r24	; 31
			       (0<<EEPM1) | (0<<EEPM0); // ...and Erase+Write mode.
			EECR |= (1<<EEPE);  // Start Erase+Write operation.
    497e:	f9 9a       	sbi	0x1f, 1	; 31
    4980:	0a c0       	rjmp	.+20     	; 0x4996 <eeprom_put_char+0x3a>
		} else {
			// Now we know that all bits should be erased.

			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    4982:	84 e1       	ldi	r24, 0x14	; 20
    4984:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM0);  // ...and Erase-only mode.
			EECR |= (1<<EEPE);  // Start Erase-only operation.
    4986:	f9 9a       	sbi	0x1f, 1	; 31
    4988:	06 c0       	rjmp	.+12     	; 0x4996 <eeprom_put_char+0x3a>
		}
	} else {
		// Now we know that _no_ bits need to be erased to '1'.
		
		// Check if any bits are changed from '1' in the old value.
		if( diff_mask ) {
    498a:	88 23       	and	r24, r24
    498c:	21 f0       	breq	.+8      	; 0x4996 <eeprom_put_char+0x3a>
			// Now we know that _some_ bits need to the programmed to '0'.
			
			EEDR = new_value;   // Set EEPROM data register.
    498e:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    4990:	84 e2       	ldi	r24, 0x24	; 36
    4992:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM1);  // ...and Write-only mode.
			EECR |= (1<<EEPE);  // Start Write-only operation.
    4994:	f9 9a       	sbi	0x1f, 1	; 31
		}
	}
	
	sei(); // Restore interrupt flag state.
    4996:	78 94       	sei
    4998:	08 95       	ret

0000499a <memcpy_to_eeprom_with_checksum>:
}

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
    499a:	8f 92       	push	r8
    499c:	9f 92       	push	r9
    499e:	af 92       	push	r10
    49a0:	bf 92       	push	r11
    49a2:	cf 92       	push	r12
    49a4:	df 92       	push	r13
    49a6:	ef 92       	push	r14
    49a8:	ff 92       	push	r15
    49aa:	0f 93       	push	r16
    49ac:	1f 93       	push	r17
    49ae:	cf 93       	push	r28
    49b0:	df 93       	push	r29
    49b2:	7c 01       	movw	r14, r24
    49b4:	8b 01       	movw	r16, r22
    49b6:	6a 01       	movw	r12, r20
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    49b8:	41 15       	cp	r20, r1
    49ba:	51 05       	cpc	r21, r1
    49bc:	01 f1       	breq	.+64     	; 0x49fe <memcpy_to_eeprom_with_checksum+0x64>
    49be:	5a 01       	movw	r10, r20
    49c0:	c0 e0       	ldi	r28, 0x00	; 0
    checksum = (checksum << 1) || (checksum >> 7);
    49c2:	d1 e0       	ldi	r29, 0x01	; 1
    49c4:	01 c0       	rjmp	.+2      	; 0x49c8 <memcpy_to_eeprom_with_checksum+0x2e>
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
    49c6:	c4 01       	movw	r24, r8


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    49c8:	c1 11       	cpse	r28, r1
    49ca:	08 c0       	rjmp	.+16     	; 0x49dc <memcpy_to_eeprom_with_checksum+0x42>
    49cc:	6c 2f       	mov	r22, r28
    49ce:	cc 0f       	add	r28, r28
    49d0:	77 0b       	sbc	r23, r23
    49d2:	c7 2f       	mov	r28, r23
    49d4:	cc 1f       	adc	r28, r28
    49d6:	cc 27       	eor	r28, r28
    49d8:	cc 1f       	adc	r28, r28
    49da:	01 c0       	rjmp	.+2      	; 0x49de <memcpy_to_eeprom_with_checksum+0x44>
    49dc:	cd 2f       	mov	r28, r29
    checksum += *source;
    49de:	f8 01       	movw	r30, r16
    49e0:	61 91       	ld	r22, Z+
    49e2:	8f 01       	movw	r16, r30
    49e4:	c6 0f       	add	r28, r22
    eeprom_put_char(destination++, *(source++)); 
    49e6:	4c 01       	movw	r8, r24
    49e8:	ff ef       	ldi	r31, 0xFF	; 255
    49ea:	8f 1a       	sub	r8, r31
    49ec:	9f 0a       	sbc	r9, r31
    49ee:	b6 df       	rcall	.-148    	; 0x495c <eeprom_put_char>
// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    49f0:	21 e0       	ldi	r18, 0x01	; 1
    49f2:	a2 1a       	sub	r10, r18
    49f4:	b1 08       	sbc	r11, r1
    49f6:	39 f7       	brne	.-50     	; 0x49c6 <memcpy_to_eeprom_with_checksum+0x2c>
    49f8:	ec 0c       	add	r14, r12
    49fa:	fd 1c       	adc	r15, r13
    49fc:	01 c0       	rjmp	.+2      	; 0x4a00 <memcpy_to_eeprom_with_checksum+0x66>

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
    49fe:	c0 e0       	ldi	r28, 0x00	; 0
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
  }
  eeprom_put_char(destination, checksum);
    4a00:	6c 2f       	mov	r22, r28
    4a02:	c7 01       	movw	r24, r14
    4a04:	ab df       	rcall	.-170    	; 0x495c <eeprom_put_char>
}
    4a06:	df 91       	pop	r29
    4a08:	cf 91       	pop	r28
    4a0a:	1f 91       	pop	r17
    4a0c:	0f 91       	pop	r16
    4a0e:	ff 90       	pop	r15
    4a10:	ef 90       	pop	r14
    4a12:	df 90       	pop	r13
    4a14:	cf 90       	pop	r12
    4a16:	bf 90       	pop	r11
    4a18:	af 90       	pop	r10
    4a1a:	9f 90       	pop	r9
    4a1c:	8f 90       	pop	r8
    4a1e:	08 95       	ret

00004a20 <memcpy_from_eeprom_with_checksum>:

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
    4a20:	8f 92       	push	r8
    4a22:	9f 92       	push	r9
    4a24:	af 92       	push	r10
    4a26:	bf 92       	push	r11
    4a28:	cf 92       	push	r12
    4a2a:	df 92       	push	r13
    4a2c:	ef 92       	push	r14
    4a2e:	ff 92       	push	r15
    4a30:	0f 93       	push	r16
    4a32:	1f 93       	push	r17
    4a34:	cf 93       	push	r28
    4a36:	df 93       	push	r29
    4a38:	7b 01       	movw	r14, r22
    4a3a:	6a 01       	movw	r12, r20
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    4a3c:	41 15       	cp	r20, r1
    4a3e:	51 05       	cpc	r21, r1
    4a40:	09 f1       	breq	.+66     	; 0x4a84 <memcpy_from_eeprom_with_checksum+0x64>
    4a42:	c8 2f       	mov	r28, r24
    4a44:	d9 2f       	mov	r29, r25
    4a46:	5a 01       	movw	r10, r20
    4a48:	cb 01       	movw	r24, r22
    4a4a:	91 2c       	mov	r9, r1
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    4a4c:	88 24       	eor	r8, r8
    4a4e:	83 94       	inc	r8
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    data = eeprom_get_char(source++);
    4a50:	8c 01       	movw	r16, r24
    4a52:	0f 5f       	subi	r16, 0xFF	; 255
    4a54:	1f 4f       	sbci	r17, 0xFF	; 255
    4a56:	7a df       	rcall	.-268    	; 0x494c <eeprom_get_char>
    checksum = (checksum << 1) || (checksum >> 7);
    4a58:	91 10       	cpse	r9, r1
    4a5a:	08 c0       	rjmp	.+16     	; 0x4a6c <memcpy_from_eeprom_with_checksum+0x4c>
    4a5c:	29 2d       	mov	r18, r9
    4a5e:	99 0c       	add	r9, r9
    4a60:	33 0b       	sbc	r19, r19
    4a62:	23 2f       	mov	r18, r19
    4a64:	22 1f       	adc	r18, r18
    4a66:	22 27       	eor	r18, r18
    4a68:	22 1f       	adc	r18, r18
    4a6a:	01 c0       	rjmp	.+2      	; 0x4a6e <memcpy_from_eeprom_with_checksum+0x4e>
    4a6c:	28 2d       	mov	r18, r8
    checksum += data;    
    4a6e:	98 2e       	mov	r9, r24
    4a70:	92 0e       	add	r9, r18
    *(destination++) = data; 
    4a72:	89 93       	st	Y+, r24
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    4a74:	81 e0       	ldi	r24, 0x01	; 1
    4a76:	a8 1a       	sub	r10, r24
    4a78:	b1 08       	sbc	r11, r1
    data = eeprom_get_char(source++);
    4a7a:	c8 01       	movw	r24, r16
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    4a7c:	49 f7       	brne	.-46     	; 0x4a50 <memcpy_from_eeprom_with_checksum+0x30>
    4a7e:	ec 0c       	add	r14, r12
    4a80:	fd 1c       	adc	r15, r13
    4a82:	01 c0       	rjmp	.+2      	; 0x4a86 <memcpy_from_eeprom_with_checksum+0x66>
  }
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
    4a84:	91 2c       	mov	r9, r1
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += data;    
    *(destination++) = data; 
  }
  return(checksum == eeprom_get_char(source));
    4a86:	c7 01       	movw	r24, r14
    4a88:	61 df       	rcall	.-318    	; 0x494c <eeprom_get_char>
    4a8a:	21 e0       	ldi	r18, 0x01	; 1
    4a8c:	30 e0       	ldi	r19, 0x00	; 0
    4a8e:	89 15       	cp	r24, r9
    4a90:	11 f0       	breq	.+4      	; 0x4a96 <memcpy_from_eeprom_with_checksum+0x76>
    4a92:	20 e0       	ldi	r18, 0x00	; 0
    4a94:	30 e0       	ldi	r19, 0x00	; 0
}
    4a96:	c9 01       	movw	r24, r18
    4a98:	df 91       	pop	r29
    4a9a:	cf 91       	pop	r28
    4a9c:	1f 91       	pop	r17
    4a9e:	0f 91       	pop	r16
    4aa0:	ff 90       	pop	r15
    4aa2:	ef 90       	pop	r14
    4aa4:	df 90       	pop	r13
    4aa6:	cf 90       	pop	r12
    4aa8:	bf 90       	pop	r11
    4aaa:	af 90       	pop	r10
    4aac:	9f 90       	pop	r9
    4aae:	8f 90       	pop	r8
    4ab0:	08 95       	ret

00004ab2 <settings_store_startup_line>:
    .max_travel[Z_AXIS] = (-DEFAULT_Z_MAX_TRAVEL)};


// Method to store startup lines into EEPROM
void settings_store_startup_line(uint8_t n, char *line)
{
    4ab2:	1f 93       	push	r17
    4ab4:	cf 93       	push	r28
    4ab6:	df 93       	push	r29
    4ab8:	18 2f       	mov	r17, r24
    4aba:	eb 01       	movw	r28, r22
  #ifdef FORCE_BUFFER_SYNC_DURING_EEPROM_WRITE
    protocol_buffer_synchronize(); // A startup line may contain a motion and be executing. 
    4abc:	0e 94 2c 19 	call	0x3258	; 0x3258 <protocol_buffer_synchronize>
  #endif
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
  memcpy_to_eeprom_with_checksum(addr,(char*)line, LINE_BUFFER_SIZE);
    4ac0:	21 e0       	ldi	r18, 0x01	; 1
    4ac2:	31 e0       	ldi	r19, 0x01	; 1
    4ac4:	12 9f       	mul	r17, r18
    4ac6:	c0 01       	movw	r24, r0
    4ac8:	13 9f       	mul	r17, r19
    4aca:	90 0d       	add	r25, r0
    4acc:	11 24       	eor	r1, r1
    4ace:	40 e0       	ldi	r20, 0x00	; 0
    4ad0:	51 e0       	ldi	r21, 0x01	; 1
    4ad2:	be 01       	movw	r22, r28
    4ad4:	9d 5f       	subi	r25, 0xFD	; 253
    4ad6:	61 df       	rcall	.-318    	; 0x499a <memcpy_to_eeprom_with_checksum>
}
    4ad8:	df 91       	pop	r29
    4ada:	cf 91       	pop	r28
    4adc:	1f 91       	pop	r17
    4ade:	08 95       	ret

00004ae0 <settings_store_build_info>:
// Method to store build info into EEPROM
// NOTE: This function can only be called in IDLE state.
void settings_store_build_info(char *line)
{
  // Build info can only be stored when state is IDLE.
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_BUILD_INFO,(char*)line, LINE_BUFFER_SIZE);
    4ae0:	40 e0       	ldi	r20, 0x00	; 0
    4ae2:	51 e0       	ldi	r21, 0x01	; 1
    4ae4:	bc 01       	movw	r22, r24
    4ae6:	8e ea       	ldi	r24, 0xAE	; 174
    4ae8:	93 e0       	ldi	r25, 0x03	; 3
    4aea:	57 cf       	rjmp	.-338    	; 0x499a <memcpy_to_eeprom_with_checksum>
    4aec:	08 95       	ret

00004aee <settings_write_coord_data>:
}


// Method to store coord data parameters into EEPROM
void settings_write_coord_data(uint8_t coord_select, float *coord_data)
{
    4aee:	0f 93       	push	r16
    4af0:	1f 93       	push	r17
    4af2:	cf 93       	push	r28
    4af4:	c8 2f       	mov	r28, r24
    4af6:	8b 01       	movw	r16, r22
  #ifdef FORCE_BUFFER_SYNC_DURING_EEPROM_WRITE
    protocol_buffer_synchronize();
    4af8:	0e 94 2c 19 	call	0x3258	; 0x3258 <protocol_buffer_synchronize>
  #endif
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
  memcpy_to_eeprom_with_checksum(addr,(char*)coord_data, sizeof(float)*N_AXIS);
    4afc:	2d e0       	ldi	r18, 0x0D	; 13
    4afe:	c2 9f       	mul	r28, r18
    4b00:	c0 01       	movw	r24, r0
    4b02:	11 24       	eor	r1, r1
    4b04:	4c e0       	ldi	r20, 0x0C	; 12
    4b06:	50 e0       	ldi	r21, 0x00	; 0
    4b08:	b8 01       	movw	r22, r16
    4b0a:	9e 5f       	subi	r25, 0xFE	; 254
    4b0c:	46 df       	rcall	.-372    	; 0x499a <memcpy_to_eeprom_with_checksum>
}
    4b0e:	cf 91       	pop	r28
    4b10:	1f 91       	pop	r17
    4b12:	0f 91       	pop	r16
    4b14:	08 95       	ret

00004b16 <write_global_settings>:

// Method to store Grbl global settings struct and version number into EEPROM
// NOTE: This function can only be called in IDLE state.
void write_global_settings()
{
  eeprom_put_char(0, SETTINGS_VERSION);
    4b16:	6a e0       	ldi	r22, 0x0A	; 10
    4b18:	80 e0       	ldi	r24, 0x00	; 0
    4b1a:	90 e0       	ldi	r25, 0x00	; 0
    4b1c:	1f df       	rcall	.-450    	; 0x495c <eeprom_put_char>
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_GLOBAL, (char*)&settings, sizeof(settings_t));
    4b1e:	45 e5       	ldi	r20, 0x55	; 85
    4b20:	50 e0       	ldi	r21, 0x00	; 0
    4b22:	60 ed       	ldi	r22, 0xD0	; 208
    4b24:	7e e0       	ldi	r23, 0x0E	; 14
    4b26:	81 e0       	ldi	r24, 0x01	; 1
    4b28:	90 e0       	ldi	r25, 0x00	; 0
    4b2a:	37 cf       	rjmp	.-402    	; 0x499a <memcpy_to_eeprom_with_checksum>
    4b2c:	08 95       	ret

00004b2e <settings_restore>:
}


// Method to restore EEPROM-saved Grbl global settings back to defaults.
void settings_restore(uint8_t restore_flag) {
    4b2e:	0f 93       	push	r16
    4b30:	1f 93       	push	r17
    4b32:	cf 93       	push	r28
    4b34:	df 93       	push	r29
    4b36:	cd b7       	in	r28, 0x3d	; 61
    4b38:	de b7       	in	r29, 0x3e	; 62
    4b3a:	2c 97       	sbiw	r28, 0x0c	; 12
    4b3c:	0f b6       	in	r0, 0x3f	; 63
    4b3e:	f8 94       	cli
    4b40:	de bf       	out	0x3e, r29	; 62
    4b42:	0f be       	out	0x3f, r0	; 63
    4b44:	cd bf       	out	0x3d, r28	; 61
    4b46:	08 2f       	mov	r16, r24
  if (restore_flag & SETTINGS_RESTORE_DEFAULTS) {
    4b48:	80 ff       	sbrs	r24, 0
    4b4a:	0a c0       	rjmp	.+20     	; 0x4b60 <settings_restore+0x32>
    settings = defaults;
    4b4c:	85 e5       	ldi	r24, 0x55	; 85
    4b4e:	ea ee       	ldi	r30, 0xEA	; 234
    4b50:	f2 e0       	ldi	r31, 0x02	; 2
    4b52:	a0 ed       	ldi	r26, 0xD0	; 208
    4b54:	be e0       	ldi	r27, 0x0E	; 14
    4b56:	05 90       	lpm	r0, Z+
    4b58:	0d 92       	st	X+, r0
    4b5a:	8a 95       	dec	r24
    4b5c:	e1 f7       	brne	.-8      	; 0x4b56 <settings_restore+0x28>
    write_global_settings();
    4b5e:	db df       	rcall	.-74     	; 0x4b16 <write_global_settings>
  }

  if (restore_flag & SETTINGS_RESTORE_PARAMETERS) {
    4b60:	01 ff       	sbrs	r16, 1
    4b62:	10 c0       	rjmp	.+32     	; 0x4b84 <settings_restore+0x56>
    uint8_t idx;
    float coord_data[N_AXIS];
    memset(&coord_data, 0, sizeof(coord_data));
    4b64:	fe 01       	movw	r30, r28
    4b66:	31 96       	adiw	r30, 0x01	; 1
    4b68:	8c e0       	ldi	r24, 0x0C	; 12
    4b6a:	df 01       	movw	r26, r30
    4b6c:	1d 92       	st	X+, r1
    4b6e:	8a 95       	dec	r24
    4b70:	e9 f7       	brne	.-6      	; 0x4b6c <settings_restore+0x3e>
    for (idx=0; idx <= SETTING_INDEX_NCOORD; idx++) { settings_write_coord_data(idx, coord_data); }
    4b72:	10 e0       	ldi	r17, 0x00	; 0
    4b74:	be 01       	movw	r22, r28
    4b76:	6f 5f       	subi	r22, 0xFF	; 255
    4b78:	7f 4f       	sbci	r23, 0xFF	; 255
    4b7a:	81 2f       	mov	r24, r17
    4b7c:	b8 df       	rcall	.-144    	; 0x4aee <settings_write_coord_data>
    4b7e:	1f 5f       	subi	r17, 0xFF	; 255
    4b80:	18 30       	cpi	r17, 0x08	; 8
    4b82:	c1 f7       	brne	.-16     	; 0x4b74 <settings_restore+0x46>
  }

  if (restore_flag & SETTINGS_RESTORE_STARTUP_LINES) {
    4b84:	02 ff       	sbrs	r16, 2
    4b86:	10 c0       	rjmp	.+32     	; 0x4ba8 <settings_restore+0x7a>
    #if N_STARTUP_LINE > 0
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK, 0);
    4b88:	60 e0       	ldi	r22, 0x00	; 0
    4b8a:	80 e0       	ldi	r24, 0x00	; 0
    4b8c:	93 e0       	ldi	r25, 0x03	; 3
    4b8e:	e6 de       	rcall	.-564    	; 0x495c <eeprom_put_char>
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+1, 0); // Checksum
    4b90:	60 e0       	ldi	r22, 0x00	; 0
    4b92:	81 e0       	ldi	r24, 0x01	; 1
    4b94:	93 e0       	ldi	r25, 0x03	; 3
    4b96:	e2 de       	rcall	.-572    	; 0x495c <eeprom_put_char>
    #endif
    #if N_STARTUP_LINE > 1
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+1), 0);
    4b98:	60 e0       	ldi	r22, 0x00	; 0
    4b9a:	81 e0       	ldi	r24, 0x01	; 1
    4b9c:	94 e0       	ldi	r25, 0x04	; 4
    4b9e:	de de       	rcall	.-580    	; 0x495c <eeprom_put_char>
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+2), 0); // Checksum
    4ba0:	60 e0       	ldi	r22, 0x00	; 0
    4ba2:	82 e0       	ldi	r24, 0x02	; 2
    4ba4:	94 e0       	ldi	r25, 0x04	; 4
    4ba6:	da de       	rcall	.-588    	; 0x495c <eeprom_put_char>
    #endif
  }

  if (restore_flag & SETTINGS_RESTORE_BUILD_INFO) {
    4ba8:	03 ff       	sbrs	r16, 3
    4baa:	08 c0       	rjmp	.+16     	; 0x4bbc <settings_restore+0x8e>
    eeprom_put_char(EEPROM_ADDR_BUILD_INFO , 0);
    4bac:	60 e0       	ldi	r22, 0x00	; 0
    4bae:	8e ea       	ldi	r24, 0xAE	; 174
    4bb0:	93 e0       	ldi	r25, 0x03	; 3
    4bb2:	d4 de       	rcall	.-600    	; 0x495c <eeprom_put_char>
    eeprom_put_char(EEPROM_ADDR_BUILD_INFO+1 , 0); // Checksum
    4bb4:	60 e0       	ldi	r22, 0x00	; 0
    4bb6:	8f ea       	ldi	r24, 0xAF	; 175
    4bb8:	93 e0       	ldi	r25, 0x03	; 3
    4bba:	d0 de       	rcall	.-608    	; 0x495c <eeprom_put_char>
    4bbc:	2c 96       	adiw	r28, 0x0c	; 12
  }
}
    4bbe:	0f b6       	in	r0, 0x3f	; 63
    4bc0:	f8 94       	cli
    4bc2:	de bf       	out	0x3e, r29	; 62
    4bc4:	0f be       	out	0x3f, r0	; 63
    4bc6:	cd bf       	out	0x3d, r28	; 61
    4bc8:	df 91       	pop	r29
    4bca:	cf 91       	pop	r28
    4bcc:	1f 91       	pop	r17
    4bce:	0f 91       	pop	r16
    4bd0:	08 95       	ret

00004bd2 <settings_read_startup_line>:
    4bd2:	1f 93       	push	r17


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_startup_line(uint8_t n, char *line)
{
    4bd4:	cf 93       	push	r28
    4bd6:	df 93       	push	r29
    4bd8:	18 2f       	mov	r17, r24
    4bda:	eb 01       	movw	r28, r22
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
  if (!(memcpy_from_eeprom_with_checksum((char*)line, addr, LINE_BUFFER_SIZE))) {
    4bdc:	81 e0       	ldi	r24, 0x01	; 1
    4bde:	91 e0       	ldi	r25, 0x01	; 1
    4be0:	18 9f       	mul	r17, r24
    4be2:	b0 01       	movw	r22, r0
    4be4:	19 9f       	mul	r17, r25
    4be6:	70 0d       	add	r23, r0
    4be8:	11 24       	eor	r1, r1
    4bea:	7d 5f       	subi	r23, 0xFD	; 253
    4bec:	40 e0       	ldi	r20, 0x00	; 0
    4bee:	51 e0       	ldi	r21, 0x01	; 1
    4bf0:	ce 01       	movw	r24, r28
    4bf2:	16 df       	rcall	.-468    	; 0x4a20 <memcpy_from_eeprom_with_checksum>
    4bf4:	89 2b       	or	r24, r25
    4bf6:	31 f4       	brne	.+12     	; 0x4c04 <settings_read_startup_line+0x32>
    // Reset line with default value
    line[0] = 0; // Empty line
    4bf8:	18 82       	st	Y, r1
    settings_store_startup_line(n, line);
    4bfa:	be 01       	movw	r22, r28
    4bfc:	81 2f       	mov	r24, r17
    4bfe:	59 df       	rcall	.-334    	; 0x4ab2 <settings_store_startup_line>
    return(false);
    4c00:	80 e0       	ldi	r24, 0x00	; 0
    4c02:	01 c0       	rjmp	.+2      	; 0x4c06 <settings_read_startup_line+0x34>
  }
  return(true);
    4c04:	81 e0       	ldi	r24, 0x01	; 1
}
    4c06:	df 91       	pop	r29
    4c08:	cf 91       	pop	r28
    4c0a:	1f 91       	pop	r17
    4c0c:	08 95       	ret

00004c0e <settings_read_build_info>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_build_info(char *line)
{
    4c0e:	cf 93       	push	r28
    4c10:	df 93       	push	r29
    4c12:	ec 01       	movw	r28, r24
  if (!(memcpy_from_eeprom_with_checksum((char*)line, EEPROM_ADDR_BUILD_INFO, LINE_BUFFER_SIZE))) {
    4c14:	40 e0       	ldi	r20, 0x00	; 0
    4c16:	51 e0       	ldi	r21, 0x01	; 1
    4c18:	6e ea       	ldi	r22, 0xAE	; 174
    4c1a:	73 e0       	ldi	r23, 0x03	; 3
    4c1c:	01 df       	rcall	.-510    	; 0x4a20 <memcpy_from_eeprom_with_checksum>
    4c1e:	89 2b       	or	r24, r25
    4c20:	29 f4       	brne	.+10     	; 0x4c2c <settings_read_build_info+0x1e>
    // Reset line with default value
    line[0] = 0; // Empty line
    4c22:	18 82       	st	Y, r1
    settings_store_build_info(line);
    4c24:	ce 01       	movw	r24, r28
    4c26:	5c df       	rcall	.-328    	; 0x4ae0 <settings_store_build_info>
    return(false);
    4c28:	80 e0       	ldi	r24, 0x00	; 0
    4c2a:	01 c0       	rjmp	.+2      	; 0x4c2e <settings_read_build_info+0x20>
  }
  return(true);
    4c2c:	81 e0       	ldi	r24, 0x01	; 1
}
    4c2e:	df 91       	pop	r29
    4c30:	cf 91       	pop	r28
    4c32:	08 95       	ret

00004c34 <settings_read_coord_data>:


// Read selected coordinate data from EEPROM. Updates pointed coord_data value.
uint8_t settings_read_coord_data(uint8_t coord_select, float *coord_data)
{
    4c34:	1f 93       	push	r17
    4c36:	cf 93       	push	r28
    4c38:	df 93       	push	r29
    4c3a:	18 2f       	mov	r17, r24
    4c3c:	eb 01       	movw	r28, r22
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
  if (!(memcpy_from_eeprom_with_checksum((char*)coord_data, addr, sizeof(float)*N_AXIS))) {
    4c3e:	8d e0       	ldi	r24, 0x0D	; 13
    4c40:	18 9f       	mul	r17, r24
    4c42:	b0 01       	movw	r22, r0
    4c44:	11 24       	eor	r1, r1
    4c46:	7e 5f       	subi	r23, 0xFE	; 254
    4c48:	4c e0       	ldi	r20, 0x0C	; 12
    4c4a:	50 e0       	ldi	r21, 0x00	; 0
    4c4c:	ce 01       	movw	r24, r28
    4c4e:	e8 de       	rcall	.-560    	; 0x4a20 <memcpy_from_eeprom_with_checksum>
    4c50:	89 2b       	or	r24, r25
    4c52:	51 f4       	brne	.+20     	; 0x4c68 <settings_read_coord_data+0x34>
    // Reset with default zero vector
    clear_vector_float(coord_data);
    4c54:	8c e0       	ldi	r24, 0x0C	; 12
    4c56:	fe 01       	movw	r30, r28
    4c58:	11 92       	st	Z+, r1
    4c5a:	8a 95       	dec	r24
    4c5c:	e9 f7       	brne	.-6      	; 0x4c58 <settings_read_coord_data+0x24>
    settings_write_coord_data(coord_select,coord_data);
    4c5e:	be 01       	movw	r22, r28
    4c60:	81 2f       	mov	r24, r17
    4c62:	45 df       	rcall	.-374    	; 0x4aee <settings_write_coord_data>
    return(false);
    4c64:	80 e0       	ldi	r24, 0x00	; 0
    4c66:	01 c0       	rjmp	.+2      	; 0x4c6a <settings_read_coord_data+0x36>
  }
  return(true);
    4c68:	81 e0       	ldi	r24, 0x01	; 1
}
    4c6a:	df 91       	pop	r29
    4c6c:	cf 91       	pop	r28
    4c6e:	1f 91       	pop	r17
    4c70:	08 95       	ret

00004c72 <read_global_settings>:


// Reads Grbl global settings struct from EEPROM.
uint8_t read_global_settings() {
  // Check version-byte of eeprom
  uint8_t version = eeprom_get_char(0);
    4c72:	80 e0       	ldi	r24, 0x00	; 0
    4c74:	90 e0       	ldi	r25, 0x00	; 0
    4c76:	6a de       	rcall	.-812    	; 0x494c <eeprom_get_char>
  if (version == SETTINGS_VERSION) {
    4c78:	8a 30       	cpi	r24, 0x0A	; 10
    4c7a:	61 f4       	brne	.+24     	; 0x4c94 <read_global_settings+0x22>
    // Read settings-record and check checksum
    if (!(memcpy_from_eeprom_with_checksum((char*)&settings, EEPROM_ADDR_GLOBAL, sizeof(settings_t)))) {
    4c7c:	45 e5       	ldi	r20, 0x55	; 85
    4c7e:	50 e0       	ldi	r21, 0x00	; 0
    4c80:	61 e0       	ldi	r22, 0x01	; 1
    4c82:	70 e0       	ldi	r23, 0x00	; 0
    4c84:	80 ed       	ldi	r24, 0xD0	; 208
    4c86:	9e e0       	ldi	r25, 0x0E	; 14
    4c88:	cb de       	rcall	.-618    	; 0x4a20 <memcpy_from_eeprom_with_checksum>
      return(false);
    4c8a:	21 e0       	ldi	r18, 0x01	; 1
    4c8c:	89 2b       	or	r24, r25
    4c8e:	19 f4       	brne	.+6      	; 0x4c96 <read_global_settings+0x24>
    4c90:	20 e0       	ldi	r18, 0x00	; 0
    4c92:	01 c0       	rjmp	.+2      	; 0x4c96 <read_global_settings+0x24>
    }
  } else {
    return(false);
    4c94:	20 e0       	ldi	r18, 0x00	; 0
  }
  return(true);
}
    4c96:	82 2f       	mov	r24, r18
    4c98:	08 95       	ret

00004c9a <settings_store_global_setting>:


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
    4c9a:	cf 92       	push	r12
    4c9c:	df 92       	push	r13
    4c9e:	ef 92       	push	r14
    4ca0:	ff 92       	push	r15
    4ca2:	cf 93       	push	r28
    4ca4:	df 93       	push	r29
    4ca6:	c8 2f       	mov	r28, r24
    4ca8:	6a 01       	movw	r12, r20
    4caa:	7b 01       	movw	r14, r22
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); }
    4cac:	20 e0       	ldi	r18, 0x00	; 0
    4cae:	30 e0       	ldi	r19, 0x00	; 0
    4cb0:	a9 01       	movw	r20, r18
    4cb2:	c7 01       	movw	r24, r14
    4cb4:	b6 01       	movw	r22, r12
    4cb6:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    4cba:	88 23       	and	r24, r24
    4cbc:	0c f4       	brge	.+2      	; 0x4cc0 <settings_store_global_setting+0x26>
    4cbe:	07 c1       	rjmp	.+526    	; 0x4ece <settings_store_global_setting+0x234>
  if (parameter >= AXIS_SETTINGS_START_VAL) {
    4cc0:	c4 36       	cpi	r28, 0x64	; 100
    4cc2:	a0 f0       	brcs	.+40     	; 0x4cec <settings_store_global_setting+0x52>
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    4cc4:	ec e9       	ldi	r30, 0x9C	; 156
    4cc6:	ec 0f       	add	r30, r28
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    4cc8:	e3 30       	cpi	r30, 0x03	; 3
    4cca:	20 f0       	brcs	.+8      	; 0x4cd4 <settings_store_global_setting+0x3a>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4ccc:	ea 30       	cpi	r30, 0x0A	; 10
    4cce:	08 f0       	brcs	.+2      	; 0x4cd2 <settings_store_global_setting+0x38>
    4cd0:	0c c1       	rjmp	.+536    	; 0x4eea <settings_store_global_setting+0x250>
    4cd2:	ff c0       	rjmp	.+510    	; 0x4ed2 <settings_store_global_setting+0x238>
        switch (set_idx) {
          case 0:
            #ifdef MAX_STEP_RATE_HZ
              if (value*settings.max_rate[parameter] > (MAX_STEP_RATE_HZ*60.0)) { return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            #endif
            settings.steps_per_mm[parameter] = value;
    4cd4:	f0 e0       	ldi	r31, 0x00	; 0
    4cd6:	ee 0f       	add	r30, r30
    4cd8:	ff 1f       	adc	r31, r31
    4cda:	ee 0f       	add	r30, r30
    4cdc:	ff 1f       	adc	r31, r31
    4cde:	e0 53       	subi	r30, 0x30	; 48
    4ce0:	f1 4f       	sbci	r31, 0xF1	; 241
    4ce2:	c0 82       	st	Z, r12
    4ce4:	d1 82       	std	Z+1, r13	; 0x01
    4ce6:	e2 82       	std	Z+2, r14	; 0x02
    4ce8:	f3 82       	std	Z+3, r15	; 0x03
            break;
    4cea:	ee c0       	rjmp	.+476    	; 0x4ec8 <settings_store_global_setting+0x22e>
        parameter -= AXIS_SETTINGS_INCREMENT;
      }
    }
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    4cec:	c7 01       	movw	r24, r14
    4cee:	b6 01       	movw	r22, r12
    4cf0:	0e 94 75 42 	call	0x84ea	; 0x84ea <trunc>
    4cf4:	0e 94 dd 3f 	call	0x7fba	; 0x7fba <__fixunssfsi>
    switch(parameter) {
    4cf8:	8c 2f       	mov	r24, r28
    4cfa:	90 e0       	ldi	r25, 0x00	; 0
    4cfc:	81 32       	cpi	r24, 0x21	; 33
    4cfe:	91 05       	cpc	r25, r1
    4d00:	08 f0       	brcs	.+2      	; 0x4d04 <settings_store_global_setting+0x6a>
    4d02:	e9 c0       	rjmp	.+466    	; 0x4ed6 <settings_store_global_setting+0x23c>
    4d04:	fc 01       	movw	r30, r24
    4d06:	88 27       	eor	r24, r24
    4d08:	ed 5d       	subi	r30, 0xDD	; 221
    4d0a:	fe 4f       	sbci	r31, 0xFE	; 254
    4d0c:	8f 4f       	sbci	r24, 0xFF	; 255
    4d0e:	0c 94 b6 42 	jmp	0x856c	; 0x856c <__tablejump2__>
      case 0:
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    4d12:	63 30       	cpi	r22, 0x03	; 3
    4d14:	08 f4       	brcc	.+2      	; 0x4d18 <settings_store_global_setting+0x7e>
    4d16:	e1 c0       	rjmp	.+450    	; 0x4eda <settings_store_global_setting+0x240>
        settings.pulse_microseconds = int_value; break;
    4d18:	60 93 00 0f 	sts	0x0F00, r22	; 0x800f00 <settings+0x30>
    4d1c:	d5 c0       	rjmp	.+426    	; 0x4ec8 <settings_store_global_setting+0x22e>
      case 1: settings.stepper_idle_lock_time = int_value; break;
    4d1e:	60 93 03 0f 	sts	0x0F03, r22	; 0x800f03 <settings+0x33>
    4d22:	d2 c0       	rjmp	.+420    	; 0x4ec8 <settings_store_global_setting+0x22e>
      case 2:
        settings.step_invert_mask = int_value;
    4d24:	60 93 01 0f 	sts	0x0F01, r22	; 0x800f01 <settings+0x31>
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    4d28:	0e 94 99 1b 	call	0x3732	; 0x3732 <st_generate_step_dir_invert_masks>
        break;
    4d2c:	cd c0       	rjmp	.+410    	; 0x4ec8 <settings_store_global_setting+0x22e>
      case 3:
        settings.dir_invert_mask = int_value;
    4d2e:	60 93 02 0f 	sts	0x0F02, r22	; 0x800f02 <settings+0x32>
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    4d32:	0e 94 99 1b 	call	0x3732	; 0x3732 <st_generate_step_dir_invert_masks>
        break;
    4d36:	c8 c0       	rjmp	.+400    	; 0x4ec8 <settings_store_global_setting+0x22e>
      case 4: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }
    4d38:	66 23       	and	r22, r22
    4d3a:	31 f0       	breq	.+12     	; 0x4d48 <settings_store_global_setting+0xae>
    4d3c:	e5 e1       	ldi	r30, 0x15	; 21
    4d3e:	ff e0       	ldi	r31, 0x0F	; 15
    4d40:	80 81       	ld	r24, Z
    4d42:	84 60       	ori	r24, 0x04	; 4
    4d44:	80 83       	st	Z, r24
    4d46:	c0 c0       	rjmp	.+384    	; 0x4ec8 <settings_store_global_setting+0x22e>
        else { settings.flags &= ~BITFLAG_INVERT_ST_ENABLE; }
    4d48:	e5 e1       	ldi	r30, 0x15	; 21
    4d4a:	ff e0       	ldi	r31, 0x0F	; 15
    4d4c:	80 81       	ld	r24, Z
    4d4e:	8b 7f       	andi	r24, 0xFB	; 251
    4d50:	80 83       	st	Z, r24
    4d52:	ba c0       	rjmp	.+372    	; 0x4ec8 <settings_store_global_setting+0x22e>
        break;
      case 5: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
    4d54:	66 23       	and	r22, r22
    4d56:	31 f0       	breq	.+12     	; 0x4d64 <settings_store_global_setting+0xca>
    4d58:	e5 e1       	ldi	r30, 0x15	; 21
    4d5a:	ff e0       	ldi	r31, 0x0F	; 15
    4d5c:	80 81       	ld	r24, Z
    4d5e:	80 64       	ori	r24, 0x40	; 64
    4d60:	80 83       	st	Z, r24
    4d62:	b2 c0       	rjmp	.+356    	; 0x4ec8 <settings_store_global_setting+0x22e>
        else { settings.flags &= ~BITFLAG_INVERT_LIMIT_PINS; }
    4d64:	e5 e1       	ldi	r30, 0x15	; 21
    4d66:	ff e0       	ldi	r31, 0x0F	; 15
    4d68:	80 81       	ld	r24, Z
    4d6a:	8f 7b       	andi	r24, 0xBF	; 191
    4d6c:	80 83       	st	Z, r24
    4d6e:	ac c0       	rjmp	.+344    	; 0x4ec8 <settings_store_global_setting+0x22e>
        break;
      case 6: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_PROBE_PIN; }
    4d70:	66 23       	and	r22, r22
    4d72:	31 f0       	breq	.+12     	; 0x4d80 <settings_store_global_setting+0xe6>
    4d74:	e5 e1       	ldi	r30, 0x15	; 21
    4d76:	ff e0       	ldi	r31, 0x0F	; 15
    4d78:	80 81       	ld	r24, Z
    4d7a:	80 68       	ori	r24, 0x80	; 128
    4d7c:	80 83       	st	Z, r24
    4d7e:	05 c0       	rjmp	.+10     	; 0x4d8a <settings_store_global_setting+0xf0>
        else { settings.flags &= ~BITFLAG_INVERT_PROBE_PIN; }
    4d80:	e5 e1       	ldi	r30, 0x15	; 21
    4d82:	ff e0       	ldi	r31, 0x0F	; 15
    4d84:	80 81       	ld	r24, Z
    4d86:	8f 77       	andi	r24, 0x7F	; 127
    4d88:	80 83       	st	Z, r24
        probe_configure_invert_mask(false);
    4d8a:	80 e0       	ldi	r24, 0x00	; 0
    4d8c:	0e 94 dc 34 	call	0x69b8	; 0x69b8 <probe_configure_invert_mask>
        break;
    4d90:	9b c0       	rjmp	.+310    	; 0x4ec8 <settings_store_global_setting+0x22e>
      case 10: settings.status_report_mask = int_value; break;
    4d92:	60 93 04 0f 	sts	0x0F04, r22	; 0x800f04 <settings+0x34>
    4d96:	98 c0       	rjmp	.+304    	; 0x4ec8 <settings_store_global_setting+0x22e>
      case 11: settings.junction_deviation = value; break;
    4d98:	c0 92 05 0f 	sts	0x0F05, r12	; 0x800f05 <settings+0x35>
    4d9c:	d0 92 06 0f 	sts	0x0F06, r13	; 0x800f06 <settings+0x36>
    4da0:	e0 92 07 0f 	sts	0x0F07, r14	; 0x800f07 <settings+0x37>
    4da4:	f0 92 08 0f 	sts	0x0F08, r15	; 0x800f08 <settings+0x38>
    4da8:	8f c0       	rjmp	.+286    	; 0x4ec8 <settings_store_global_setting+0x22e>
      case 12: settings.arc_tolerance = value; break;
    4daa:	c0 92 09 0f 	sts	0x0F09, r12	; 0x800f09 <settings+0x39>
    4dae:	d0 92 0a 0f 	sts	0x0F0A, r13	; 0x800f0a <settings+0x3a>
    4db2:	e0 92 0b 0f 	sts	0x0F0B, r14	; 0x800f0b <settings+0x3b>
    4db6:	f0 92 0c 0f 	sts	0x0F0C, r15	; 0x800f0c <settings+0x3c>
    4dba:	86 c0       	rjmp	.+268    	; 0x4ec8 <settings_store_global_setting+0x22e>
      case 13:
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
    4dbc:	66 23       	and	r22, r22
    4dbe:	31 f0       	breq	.+12     	; 0x4dcc <settings_store_global_setting+0x132>
    4dc0:	e5 e1       	ldi	r30, 0x15	; 21
    4dc2:	ff e0       	ldi	r31, 0x0F	; 15
    4dc4:	80 81       	ld	r24, Z
    4dc6:	81 60       	ori	r24, 0x01	; 1
    4dc8:	80 83       	st	Z, r24
    4dca:	05 c0       	rjmp	.+10     	; 0x4dd6 <settings_store_global_setting+0x13c>
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
    4dcc:	e5 e1       	ldi	r30, 0x15	; 21
    4dce:	ff e0       	ldi	r31, 0x0F	; 15
    4dd0:	80 81       	ld	r24, Z
    4dd2:	8e 7f       	andi	r24, 0xFE	; 254
    4dd4:	80 83       	st	Z, r24
        system_flag_wco_change(); // Make sure WCO is immediately updated.
    4dd6:	0e 94 fb 3a 	call	0x75f6	; 0x75f6 <system_flag_wco_change>
        break;
    4dda:	76 c0       	rjmp	.+236    	; 0x4ec8 <settings_store_global_setting+0x22e>
      case 20:
        if (int_value) {
    4ddc:	66 23       	and	r22, r22
    4dde:	41 f0       	breq	.+16     	; 0x4df0 <settings_store_global_setting+0x156>
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    4de0:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    4de4:	84 ff       	sbrs	r24, 4
    4de6:	7b c0       	rjmp	.+246    	; 0x4ede <settings_store_global_setting+0x244>
          settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE;
    4de8:	80 62       	ori	r24, 0x20	; 32
    4dea:	80 93 15 0f 	sts	0x0F15, r24	; 0x800f15 <settings+0x45>
    4dee:	6c c0       	rjmp	.+216    	; 0x4ec8 <settings_store_global_setting+0x22e>
        } else { settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; }
    4df0:	e5 e1       	ldi	r30, 0x15	; 21
    4df2:	ff e0       	ldi	r31, 0x0F	; 15
    4df4:	80 81       	ld	r24, Z
    4df6:	8f 7d       	andi	r24, 0xDF	; 223
    4df8:	80 83       	st	Z, r24
    4dfa:	66 c0       	rjmp	.+204    	; 0x4ec8 <settings_store_global_setting+0x22e>
        break;
      case 21:
        if (int_value) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
    4dfc:	66 23       	and	r22, r22
    4dfe:	31 f0       	breq	.+12     	; 0x4e0c <settings_store_global_setting+0x172>
    4e00:	e5 e1       	ldi	r30, 0x15	; 21
    4e02:	ff e0       	ldi	r31, 0x0F	; 15
    4e04:	80 81       	ld	r24, Z
    4e06:	88 60       	ori	r24, 0x08	; 8
    4e08:	80 83       	st	Z, r24
    4e0a:	05 c0       	rjmp	.+10     	; 0x4e16 <settings_store_global_setting+0x17c>
        else { settings.flags &= ~BITFLAG_HARD_LIMIT_ENABLE; }
    4e0c:	e5 e1       	ldi	r30, 0x15	; 21
    4e0e:	ff e0       	ldi	r31, 0x0F	; 15
    4e10:	80 81       	ld	r24, Z
    4e12:	87 7f       	andi	r24, 0xF7	; 247
    4e14:	80 83       	st	Z, r24
        limits_init(); // Re-init to immediately change. NOTE: Nice to have but could be problematic later.
    4e16:	0e 94 44 30 	call	0x6088	; 0x6088 <limits_init>
        break;
    4e1a:	56 c0       	rjmp	.+172    	; 0x4ec8 <settings_store_global_setting+0x22e>
      case 22:
        if (int_value) { settings.flags |= BITFLAG_HOMING_ENABLE; }
    4e1c:	66 23       	and	r22, r22
    4e1e:	31 f0       	breq	.+12     	; 0x4e2c <settings_store_global_setting+0x192>
    4e20:	e5 e1       	ldi	r30, 0x15	; 21
    4e22:	ff e0       	ldi	r31, 0x0F	; 15
    4e24:	80 81       	ld	r24, Z
    4e26:	80 61       	ori	r24, 0x10	; 16
    4e28:	80 83       	st	Z, r24
    4e2a:	4e c0       	rjmp	.+156    	; 0x4ec8 <settings_store_global_setting+0x22e>
        else {
          settings.flags &= ~BITFLAG_HOMING_ENABLE;
          settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; // Force disable soft-limits.
    4e2c:	e5 e1       	ldi	r30, 0x15	; 21
    4e2e:	ff e0       	ldi	r31, 0x0F	; 15
    4e30:	80 81       	ld	r24, Z
    4e32:	8f 7c       	andi	r24, 0xCF	; 207
    4e34:	80 83       	st	Z, r24
    4e36:	48 c0       	rjmp	.+144    	; 0x4ec8 <settings_store_global_setting+0x22e>
        }
        break;
      case 23: settings.homing_dir_mask = int_value; break;
    4e38:	60 93 16 0f 	sts	0x0F16, r22	; 0x800f16 <settings+0x46>
    4e3c:	45 c0       	rjmp	.+138    	; 0x4ec8 <settings_store_global_setting+0x22e>
      case 24: settings.homing_feed_rate = value; break;
    4e3e:	c0 92 17 0f 	sts	0x0F17, r12	; 0x800f17 <settings+0x47>
    4e42:	d0 92 18 0f 	sts	0x0F18, r13	; 0x800f18 <settings+0x48>
    4e46:	e0 92 19 0f 	sts	0x0F19, r14	; 0x800f19 <settings+0x49>
    4e4a:	f0 92 1a 0f 	sts	0x0F1A, r15	; 0x800f1a <settings+0x4a>
    4e4e:	3c c0       	rjmp	.+120    	; 0x4ec8 <settings_store_global_setting+0x22e>
      case 25: settings.homing_seek_rate = value; break;
    4e50:	c0 92 1b 0f 	sts	0x0F1B, r12	; 0x800f1b <settings+0x4b>
    4e54:	d0 92 1c 0f 	sts	0x0F1C, r13	; 0x800f1c <settings+0x4c>
    4e58:	e0 92 1d 0f 	sts	0x0F1D, r14	; 0x800f1d <settings+0x4d>
    4e5c:	f0 92 1e 0f 	sts	0x0F1E, r15	; 0x800f1e <settings+0x4e>
    4e60:	33 c0       	rjmp	.+102    	; 0x4ec8 <settings_store_global_setting+0x22e>
      case 26: settings.homing_debounce_delay = int_value; break;
    4e62:	86 2f       	mov	r24, r22
    4e64:	90 e0       	ldi	r25, 0x00	; 0
    4e66:	90 93 20 0f 	sts	0x0F20, r25	; 0x800f20 <settings+0x50>
    4e6a:	80 93 1f 0f 	sts	0x0F1F, r24	; 0x800f1f <settings+0x4f>
    4e6e:	2c c0       	rjmp	.+88     	; 0x4ec8 <settings_store_global_setting+0x22e>
      case 27: settings.homing_pulloff = value; break;
    4e70:	c0 92 21 0f 	sts	0x0F21, r12	; 0x800f21 <settings+0x51>
    4e74:	d0 92 22 0f 	sts	0x0F22, r13	; 0x800f22 <settings+0x52>
    4e78:	e0 92 23 0f 	sts	0x0F23, r14	; 0x800f23 <settings+0x53>
    4e7c:	f0 92 24 0f 	sts	0x0F24, r15	; 0x800f24 <settings+0x54>
    4e80:	23 c0       	rjmp	.+70     	; 0x4ec8 <settings_store_global_setting+0x22e>
      case 30: settings.rpm_max = value; spindle_init(); break; // Re-initialize spindle rpm calibration
    4e82:	c0 92 0d 0f 	sts	0x0F0D, r12	; 0x800f0d <settings+0x3d>
    4e86:	d0 92 0e 0f 	sts	0x0F0E, r13	; 0x800f0e <settings+0x3e>
    4e8a:	e0 92 0f 0f 	sts	0x0F0F, r14	; 0x800f0f <settings+0x3f>
    4e8e:	f0 92 10 0f 	sts	0x0F10, r15	; 0x800f10 <settings+0x40>
    4e92:	0e 94 85 12 	call	0x250a	; 0x250a <spindle_init>
    4e96:	18 c0       	rjmp	.+48     	; 0x4ec8 <settings_store_global_setting+0x22e>
      case 31: settings.rpm_min = value; spindle_init(); break; // Re-initialize spindle rpm calibration
    4e98:	c0 92 11 0f 	sts	0x0F11, r12	; 0x800f11 <settings+0x41>
    4e9c:	d0 92 12 0f 	sts	0x0F12, r13	; 0x800f12 <settings+0x42>
    4ea0:	e0 92 13 0f 	sts	0x0F13, r14	; 0x800f13 <settings+0x43>
    4ea4:	f0 92 14 0f 	sts	0x0F14, r15	; 0x800f14 <settings+0x44>
    4ea8:	0e 94 85 12 	call	0x250a	; 0x250a <spindle_init>
    4eac:	0d c0       	rjmp	.+26     	; 0x4ec8 <settings_store_global_setting+0x22e>
      case 32:
        if (int_value) { settings.flags |= BITFLAG_LASER_MODE; }
    4eae:	66 23       	and	r22, r22
    4eb0:	31 f0       	breq	.+12     	; 0x4ebe <settings_store_global_setting+0x224>
    4eb2:	e5 e1       	ldi	r30, 0x15	; 21
    4eb4:	ff e0       	ldi	r31, 0x0F	; 15
    4eb6:	80 81       	ld	r24, Z
    4eb8:	82 60       	ori	r24, 0x02	; 2
    4eba:	80 83       	st	Z, r24
    4ebc:	05 c0       	rjmp	.+10     	; 0x4ec8 <settings_store_global_setting+0x22e>
        else { settings.flags &= ~BITFLAG_LASER_MODE; }
    4ebe:	e5 e1       	ldi	r30, 0x15	; 21
    4ec0:	ff e0       	ldi	r31, 0x0F	; 15
    4ec2:	80 81       	ld	r24, Z
    4ec4:	8d 7f       	andi	r24, 0xFD	; 253
    4ec6:	80 83       	st	Z, r24
        break;
      default:
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
    4ec8:	26 de       	rcall	.-948    	; 0x4b16 <write_global_settings>
  return(STATUS_OK);
    4eca:	80 e0       	ldi	r24, 0x00	; 0
    4ecc:	58 c0       	rjmp	.+176    	; 0x4f7e <settings_store_global_setting+0x2e4>
}


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); }
    4ece:	84 e0       	ldi	r24, 0x04	; 4
    4ed0:	56 c0       	rjmp	.+172    	; 0x4f7e <settings_store_global_setting+0x2e4>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4ed2:	83 e0       	ldi	r24, 0x03	; 3
    4ed4:	54 c0       	rjmp	.+168    	; 0x4f7e <settings_store_global_setting+0x2e4>
      case 32:
        if (int_value) { settings.flags |= BITFLAG_LASER_MODE; }
        else { settings.flags &= ~BITFLAG_LASER_MODE; }
        break;
      default:
        return(STATUS_INVALID_STATEMENT);
    4ed6:	83 e0       	ldi	r24, 0x03	; 3
    4ed8:	52 c0       	rjmp	.+164    	; 0x4f7e <settings_store_global_setting+0x2e4>
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    switch(parameter) {
      case 0:
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    4eda:	86 e0       	ldi	r24, 0x06	; 6
    4edc:	50 c0       	rjmp	.+160    	; 0x4f7e <settings_store_global_setting+0x2e4>
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
        system_flag_wco_change(); // Make sure WCO is immediately updated.
        break;
      case 20:
        if (int_value) {
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    4ede:	8a e0       	ldi	r24, 0x0A	; 10
    4ee0:	4e c0       	rjmp	.+156    	; 0x4f7e <settings_store_global_setting+0x2e4>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4ee2:	83 e0       	ldi	r24, 0x03	; 3
    4ee4:	4c c0       	rjmp	.+152    	; 0x4f7e <settings_store_global_setting+0x2e4>
    4ee6:	83 e0       	ldi	r24, 0x03	; 3
    4ee8:	4a c0       	rjmp	.+148    	; 0x4f7e <settings_store_global_setting+0x2e4>
        parameter -= AXIS_SETTINGS_INCREMENT;
    4eea:	e2 e9       	ldi	r30, 0x92	; 146
    4eec:	ec 0f       	add	r30, r28
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    4eee:	e3 30       	cpi	r30, 0x03	; 3
    4ef0:	70 f0       	brcs	.+28     	; 0x4f0e <settings_store_global_setting+0x274>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4ef2:	ea 30       	cpi	r30, 0x0A	; 10
    4ef4:	b0 f3       	brcs	.-20     	; 0x4ee2 <settings_store_global_setting+0x248>
        parameter -= AXIS_SETTINGS_INCREMENT;
    4ef6:	88 e8       	ldi	r24, 0x88	; 136
    4ef8:	8c 0f       	add	r24, r28
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    4efa:	83 30       	cpi	r24, 0x03	; 3
    4efc:	a0 f0       	brcs	.+40     	; 0x4f26 <settings_store_global_setting+0x28c>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4efe:	8a 30       	cpi	r24, 0x0A	; 10
    4f00:	90 f3       	brcs	.-28     	; 0x4ee6 <settings_store_global_setting+0x24c>
        parameter -= AXIS_SETTINGS_INCREMENT;
    4f02:	8e e7       	ldi	r24, 0x7E	; 126
    4f04:	8c 0f       	add	r24, r28
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    4f06:	83 30       	cpi	r24, 0x03	; 3
    4f08:	48 f1       	brcs	.+82     	; 0x4f5c <settings_store_global_setting+0x2c2>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4f0a:	83 e0       	ldi	r24, 0x03	; 3
    4f0c:	38 c0       	rjmp	.+112    	; 0x4f7e <settings_store_global_setting+0x2e4>
            break;
          case 1:
            #ifdef MAX_STEP_RATE_HZ
              if (value*settings.steps_per_mm[parameter] > (MAX_STEP_RATE_HZ*60.0)) {  return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            #endif
            settings.max_rate[parameter] = value;
    4f0e:	f0 e0       	ldi	r31, 0x00	; 0
    4f10:	ee 0f       	add	r30, r30
    4f12:	ff 1f       	adc	r31, r31
    4f14:	ee 0f       	add	r30, r30
    4f16:	ff 1f       	adc	r31, r31
    4f18:	e4 52       	subi	r30, 0x24	; 36
    4f1a:	f1 4f       	sbci	r31, 0xF1	; 241
    4f1c:	c0 82       	st	Z, r12
    4f1e:	d1 82       	std	Z+1, r13	; 0x01
    4f20:	e2 82       	std	Z+2, r14	; 0x02
    4f22:	f3 82       	std	Z+3, r15	; 0x03
            break;
    4f24:	d1 cf       	rjmp	.-94     	; 0x4ec8 <settings_store_global_setting+0x22e>
          case 2: settings.acceleration[parameter] = value*60*60; break; // Convert to mm/min^2 for grbl internal use.
    4f26:	c8 2f       	mov	r28, r24
    4f28:	d0 e0       	ldi	r29, 0x00	; 0
    4f2a:	cc 0f       	add	r28, r28
    4f2c:	dd 1f       	adc	r29, r29
    4f2e:	cc 0f       	add	r28, r28
    4f30:	dd 1f       	adc	r29, r29
    4f32:	c8 51       	subi	r28, 0x18	; 24
    4f34:	d1 4f       	sbci	r29, 0xF1	; 241
    4f36:	20 e0       	ldi	r18, 0x00	; 0
    4f38:	30 e0       	ldi	r19, 0x00	; 0
    4f3a:	40 e7       	ldi	r20, 0x70	; 112
    4f3c:	52 e4       	ldi	r21, 0x42	; 66
    4f3e:	c7 01       	movw	r24, r14
    4f40:	b6 01       	movw	r22, r12
    4f42:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    4f46:	20 e0       	ldi	r18, 0x00	; 0
    4f48:	30 e0       	ldi	r19, 0x00	; 0
    4f4a:	40 e7       	ldi	r20, 0x70	; 112
    4f4c:	52 e4       	ldi	r21, 0x42	; 66
    4f4e:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    4f52:	68 83       	st	Y, r22
    4f54:	79 83       	std	Y+1, r23	; 0x01
    4f56:	8a 83       	std	Y+2, r24	; 0x02
    4f58:	9b 83       	std	Y+3, r25	; 0x03
    4f5a:	b6 cf       	rjmp	.-148    	; 0x4ec8 <settings_store_global_setting+0x22e>
          case 3: settings.max_travel[parameter] = -value; break;  // Store as negative for grbl internal use.
    4f5c:	e8 2f       	mov	r30, r24
    4f5e:	f0 e0       	ldi	r31, 0x00	; 0
    4f60:	ee 0f       	add	r30, r30
    4f62:	ff 1f       	adc	r31, r31
    4f64:	ee 0f       	add	r30, r30
    4f66:	ff 1f       	adc	r31, r31
    4f68:	ec 50       	subi	r30, 0x0C	; 12
    4f6a:	f1 4f       	sbci	r31, 0xF1	; 241
    4f6c:	f7 fa       	bst	r15, 7
    4f6e:	f0 94       	com	r15
    4f70:	f7 f8       	bld	r15, 7
    4f72:	f0 94       	com	r15
    4f74:	c0 82       	st	Z, r12
    4f76:	d1 82       	std	Z+1, r13	; 0x01
    4f78:	e2 82       	std	Z+2, r14	; 0x02
    4f7a:	f3 82       	std	Z+3, r15	; 0x03
    4f7c:	a5 cf       	rjmp	.-182    	; 0x4ec8 <settings_store_global_setting+0x22e>
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
  return(STATUS_OK);
}
    4f7e:	df 91       	pop	r29
    4f80:	cf 91       	pop	r28
    4f82:	ff 90       	pop	r15
    4f84:	ef 90       	pop	r14
    4f86:	df 90       	pop	r13
    4f88:	cf 90       	pop	r12
    4f8a:	08 95       	ret

00004f8c <settings_init>:


// Initialize the config subsystem
void settings_init() {
  if(!read_global_settings()) {
    4f8c:	72 de       	rcall	.-796    	; 0x4c72 <read_global_settings>
    4f8e:	81 11       	cpse	r24, r1
    4f90:	07 c0       	rjmp	.+14     	; 0x4fa0 <settings_init+0x14>
    report_status_message(STATUS_SETTING_READ_FAIL);
    4f92:	87 e0       	ldi	r24, 0x07	; 7
    4f94:	0e 94 5e 35 	call	0x6abc	; 0x6abc <report_status_message>
    settings_restore(SETTINGS_RESTORE_ALL); // Force restore all EEPROM data.
    4f98:	8f ef       	ldi	r24, 0xFF	; 255
    4f9a:	c9 dd       	rcall	.-1134   	; 0x4b2e <settings_restore>
    report_grbl_settings();
    4f9c:	0c 94 e6 35 	jmp	0x6bcc	; 0x6bcc <report_grbl_settings>
    4fa0:	08 95       	ret

00004fa2 <get_step_pin_mask>:
  #ifdef DEFAULTS_RAMPS_BOARD
    if ( axis_idx == X_AXIS ) { return((1<<STEP_BIT(X_AXIS))); }
    if ( axis_idx == Y_AXIS ) { return((1<<STEP_BIT(Y_AXIS))); }
    return((1<<STEP_BIT(Z_AXIS)));
  #else
    if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    4fa2:	88 23       	and	r24, r24
    4fa4:	21 f0       	breq	.+8      	; 0x4fae <get_step_pin_mask+0xc>
    if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    4fa6:	81 30       	cpi	r24, 0x01	; 1
    4fa8:	21 f0       	breq	.+8      	; 0x4fb2 <get_step_pin_mask+0x10>
    return((1<<Z_STEP_BIT));
    4faa:	80 e1       	ldi	r24, 0x10	; 16
    4fac:	08 95       	ret
  #ifdef DEFAULTS_RAMPS_BOARD
    if ( axis_idx == X_AXIS ) { return((1<<STEP_BIT(X_AXIS))); }
    if ( axis_idx == Y_AXIS ) { return((1<<STEP_BIT(Y_AXIS))); }
    return((1<<STEP_BIT(Z_AXIS)));
  #else
    if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    4fae:	84 e0       	ldi	r24, 0x04	; 4
    4fb0:	08 95       	ret
    if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    4fb2:	88 e0       	ldi	r24, 0x08	; 8
    return((1<<Z_STEP_BIT));
  #endif // DEFAULTS_RAMPS_BOARD
}
    4fb4:	08 95       	ret

00004fb6 <get_direction_pin_mask>:
  #ifdef DEFAULTS_RAMPS_BOARD
    if ( axis_idx == X_AXIS ) { return((1<<DIRECTION_BIT(X_AXIS))); }
    if ( axis_idx == Y_AXIS ) { return((1<<DIRECTION_BIT(Y_AXIS))); }
    return((1<<DIRECTION_BIT(Z_AXIS)));
  #else
    if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    4fb6:	88 23       	and	r24, r24
    4fb8:	21 f0       	breq	.+8      	; 0x4fc2 <get_direction_pin_mask+0xc>
    if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    4fba:	81 30       	cpi	r24, 0x01	; 1
    4fbc:	21 f0       	breq	.+8      	; 0x4fc6 <get_direction_pin_mask+0x10>
    return((1<<Z_DIRECTION_BIT));
    4fbe:	80 e2       	ldi	r24, 0x20	; 32
    4fc0:	08 95       	ret
  #ifdef DEFAULTS_RAMPS_BOARD
    if ( axis_idx == X_AXIS ) { return((1<<DIRECTION_BIT(X_AXIS))); }
    if ( axis_idx == Y_AXIS ) { return((1<<DIRECTION_BIT(Y_AXIS))); }
    return((1<<DIRECTION_BIT(Z_AXIS)));
  #else
    if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    4fc2:	80 e8       	ldi	r24, 0x80	; 128
    4fc4:	08 95       	ret
    if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    4fc6:	80 e4       	ldi	r24, 0x40	; 64
    return((1<<Z_DIRECTION_BIT));
  #endif // DEFAULTS_RAMPS_BOARD
}
    4fc8:	08 95       	ret

00004fca <get_limit_pin_mask>:
     return((1<<MAX_LIMIT_BIT(Z_AXIS)));
  }
#else
  uint8_t get_limit_pin_mask(uint8_t axis_idx)
  {
    if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    4fca:	88 23       	and	r24, r24
    4fcc:	21 f0       	breq	.+8      	; 0x4fd6 <get_limit_pin_mask+0xc>
    if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    4fce:	81 30       	cpi	r24, 0x01	; 1
    4fd0:	21 f0       	breq	.+8      	; 0x4fda <get_limit_pin_mask+0x10>
    return((1<<Z_LIMIT_BIT));
    4fd2:	80 e4       	ldi	r24, 0x40	; 64
    4fd4:	08 95       	ret
     return((1<<MAX_LIMIT_BIT(Z_AXIS)));
  }
#else
  uint8_t get_limit_pin_mask(uint8_t axis_idx)
  {
    if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    4fd6:	80 e1       	ldi	r24, 0x10	; 16
    4fd8:	08 95       	ret
    if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    4fda:	80 e2       	ldi	r24, 0x20	; 32
    return((1<<Z_LIMIT_BIT));
  }
    4fdc:	08 95       	ret

00004fde <planner_recalculate>:
// NOTE: Deprecated. Not used unless classic status reports are enabled in config.h
uint8_t plan_get_block_buffer_count()
{
  if (block_buffer_head >= block_buffer_tail) { return(block_buffer_head-block_buffer_tail); }
  return(BLOCK_BUFFER_SIZE - (block_buffer_tail-block_buffer_head));
}
    4fde:	2f 92       	push	r2
    4fe0:	3f 92       	push	r3
    4fe2:	4f 92       	push	r4
    4fe4:	5f 92       	push	r5
    4fe6:	6f 92       	push	r6
    4fe8:	7f 92       	push	r7
    4fea:	8f 92       	push	r8
    4fec:	9f 92       	push	r9
    4fee:	af 92       	push	r10
    4ff0:	bf 92       	push	r11
    4ff2:	cf 92       	push	r12
    4ff4:	df 92       	push	r13
    4ff6:	ef 92       	push	r14
    4ff8:	ff 92       	push	r15
    4ffa:	0f 93       	push	r16
    4ffc:	1f 93       	push	r17
    4ffe:	cf 93       	push	r28
    5000:	df 93       	push	r29
    5002:	c0 91 76 04 	lds	r28, 0x0476	; 0x800476 <block_buffer_head>
    5006:	c1 11       	cpse	r28, r1
    5008:	01 c0       	rjmp	.+2      	; 0x500c <planner_recalculate+0x2e>
    500a:	c4 e2       	ldi	r28, 0x24	; 36
    500c:	c1 50       	subi	r28, 0x01	; 1
    500e:	d0 91 74 04 	lds	r29, 0x0474	; 0x800474 <block_buffer_planned>
    5012:	dc 17       	cp	r29, r28
    5014:	09 f4       	brne	.+2      	; 0x5018 <planner_recalculate+0x3a>
    5016:	36 c1       	rjmp	.+620    	; 0x5284 <planner_recalculate+0x2a6>
    5018:	0c 2f       	mov	r16, r28
    501a:	10 e0       	ldi	r17, 0x00	; 0
    501c:	26 e3       	ldi	r18, 0x36	; 54
    501e:	c2 9f       	mul	r28, r18
    5020:	c0 01       	movw	r24, r0
    5022:	11 24       	eor	r1, r1
    5024:	fc 01       	movw	r30, r24
    5026:	e8 58       	subi	r30, 0x88	; 136
    5028:	fb 4f       	sbci	r31, 0xFB	; 251
    502a:	6f 01       	movw	r12, r30
    502c:	e2 8c       	ldd	r14, Z+26	; 0x1a
    502e:	f3 8c       	ldd	r15, Z+27	; 0x1b
    5030:	94 8c       	ldd	r9, Z+28	; 0x1c
    5032:	85 8c       	ldd	r8, Z+29	; 0x1d
    5034:	66 8d       	ldd	r22, Z+30	; 0x1e
    5036:	77 8d       	ldd	r23, Z+31	; 0x1f
    5038:	80 a1       	ldd	r24, Z+32	; 0x20
    503a:	91 a1       	ldd	r25, Z+33	; 0x21
    503c:	9b 01       	movw	r18, r22
    503e:	ac 01       	movw	r20, r24
    5040:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    5044:	f6 01       	movw	r30, r12
    5046:	22 a1       	ldd	r18, Z+34	; 0x22
    5048:	33 a1       	ldd	r19, Z+35	; 0x23
    504a:	44 a1       	ldd	r20, Z+36	; 0x24
    504c:	55 a1       	ldd	r21, Z+37	; 0x25
    504e:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    5052:	a6 2e       	mov	r10, r22
    5054:	b7 2e       	mov	r11, r23
    5056:	c8 2e       	mov	r12, r24
    5058:	d9 2e       	mov	r13, r25
    505a:	26 2f       	mov	r18, r22
    505c:	37 2f       	mov	r19, r23
    505e:	48 2f       	mov	r20, r24
    5060:	59 2f       	mov	r21, r25
    5062:	6e 2d       	mov	r22, r14
    5064:	7f 2d       	mov	r23, r15
    5066:	89 2d       	mov	r24, r9
    5068:	98 2d       	mov	r25, r8
    506a:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    506e:	88 23       	and	r24, r24
    5070:	24 f0       	brlt	.+8      	; 0x507a <planner_recalculate+0x9c>
    5072:	ea 2c       	mov	r14, r10
    5074:	fb 2c       	mov	r15, r11
    5076:	9c 2c       	mov	r9, r12
    5078:	8d 2c       	mov	r8, r13
    507a:	86 e3       	ldi	r24, 0x36	; 54
    507c:	80 9f       	mul	r24, r16
    507e:	f0 01       	movw	r30, r0
    5080:	81 9f       	mul	r24, r17
    5082:	f0 0d       	add	r31, r0
    5084:	11 24       	eor	r1, r1
    5086:	e8 58       	subi	r30, 0x88	; 136
    5088:	fb 4f       	sbci	r31, 0xFB	; 251
    508a:	8e 2d       	mov	r24, r14
    508c:	9f 2d       	mov	r25, r15
    508e:	a9 2d       	mov	r26, r9
    5090:	b8 2d       	mov	r27, r8
    5092:	86 8b       	std	Z+22, r24	; 0x16
    5094:	97 8b       	std	Z+23, r25	; 0x17
    5096:	a0 8f       	std	Z+24, r26	; 0x18
    5098:	b1 8f       	std	Z+25, r27	; 0x19
    509a:	c1 11       	cpse	r28, r1
    509c:	01 c0       	rjmp	.+2      	; 0x50a0 <planner_recalculate+0xc2>
    509e:	c4 e2       	ldi	r28, 0x24	; 36
    50a0:	c1 50       	subi	r28, 0x01	; 1
    50a2:	dc 13       	cpse	r29, r28
    50a4:	07 c0       	rjmp	.+14     	; 0x50b4 <planner_recalculate+0xd6>
    50a6:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    50aa:	d8 13       	cpse	r29, r24
    50ac:	7c c0       	rjmp	.+248    	; 0x51a6 <planner_recalculate+0x1c8>
    50ae:	0e 94 2c 1c 	call	0x3858	; 0x3858 <st_update_plan_block_parameters>
    50b2:	79 c0       	rjmp	.+242    	; 0x51a6 <planner_recalculate+0x1c8>
    50b4:	26 e3       	ldi	r18, 0x36	; 54
    50b6:	20 9f       	mul	r18, r16
    50b8:	c0 01       	movw	r24, r0
    50ba:	21 9f       	mul	r18, r17
    50bc:	90 0d       	add	r25, r0
    50be:	11 24       	eor	r1, r1
    50c0:	9c 01       	movw	r18, r24
    50c2:	28 58       	subi	r18, 0x88	; 136
    50c4:	3b 4f       	sbci	r19, 0xFB	; 251
    50c6:	69 01       	movw	r12, r18
    50c8:	d6 e3       	ldi	r29, 0x36	; 54
    50ca:	ec 2e       	mov	r14, r28
    50cc:	f1 2c       	mov	r15, r1
    50ce:	de 9d       	mul	r29, r14
    50d0:	80 01       	movw	r16, r0
    50d2:	df 9d       	mul	r29, r15
    50d4:	10 0d       	add	r17, r0
    50d6:	11 24       	eor	r1, r1
    50d8:	08 58       	subi	r16, 0x88	; 136
    50da:	1b 4f       	sbci	r17, 0xFB	; 251
    50dc:	c1 11       	cpse	r28, r1
    50de:	01 c0       	rjmp	.+2      	; 0x50e2 <planner_recalculate+0x104>
    50e0:	c4 e2       	ldi	r28, 0x24	; 36
    50e2:	c1 50       	subi	r28, 0x01	; 1
    50e4:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    50e8:	8c 13       	cpse	r24, r28
    50ea:	02 c0       	rjmp	.+4      	; 0x50f0 <planner_recalculate+0x112>
    50ec:	0e 94 2c 1c 	call	0x3858	; 0x3858 <st_update_plan_block_parameters>
    50f0:	de 9d       	mul	r29, r14
    50f2:	f0 01       	movw	r30, r0
    50f4:	df 9d       	mul	r29, r15
    50f6:	f0 0d       	add	r31, r0
    50f8:	11 24       	eor	r1, r1
    50fa:	e8 58       	subi	r30, 0x88	; 136
    50fc:	fb 4f       	sbci	r31, 0xFB	; 251
    50fe:	42 8c       	ldd	r4, Z+26	; 0x1a
    5100:	53 8c       	ldd	r5, Z+27	; 0x1b
    5102:	64 8c       	ldd	r6, Z+28	; 0x1c
    5104:	75 8c       	ldd	r7, Z+29	; 0x1d
    5106:	a3 01       	movw	r20, r6
    5108:	92 01       	movw	r18, r4
    510a:	66 89       	ldd	r22, Z+22	; 0x16
    510c:	77 89       	ldd	r23, Z+23	; 0x17
    510e:	80 8d       	ldd	r24, Z+24	; 0x18
    5110:	91 8d       	ldd	r25, Z+25	; 0x19
    5112:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    5116:	88 23       	and	r24, r24
    5118:	09 f4       	brne	.+2      	; 0x511c <planner_recalculate+0x13e>
    511a:	40 c0       	rjmp	.+128    	; 0x519c <planner_recalculate+0x1be>
    511c:	de 9d       	mul	r29, r14
    511e:	c0 01       	movw	r24, r0
    5120:	df 9d       	mul	r29, r15
    5122:	90 0d       	add	r25, r0
    5124:	11 24       	eor	r1, r1
    5126:	fc 01       	movw	r30, r24
    5128:	e8 58       	subi	r30, 0x88	; 136
    512a:	fb 4f       	sbci	r31, 0xFB	; 251
    512c:	5f 01       	movw	r10, r30
    512e:	66 8d       	ldd	r22, Z+30	; 0x1e
    5130:	77 8d       	ldd	r23, Z+31	; 0x1f
    5132:	80 a1       	ldd	r24, Z+32	; 0x20
    5134:	91 a1       	ldd	r25, Z+33	; 0x21
    5136:	9b 01       	movw	r18, r22
    5138:	ac 01       	movw	r20, r24
    513a:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    513e:	f5 01       	movw	r30, r10
    5140:	22 a1       	ldd	r18, Z+34	; 0x22
    5142:	33 a1       	ldd	r19, Z+35	; 0x23
    5144:	44 a1       	ldd	r20, Z+36	; 0x24
    5146:	55 a1       	ldd	r21, Z+37	; 0x25
    5148:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    514c:	f6 01       	movw	r30, r12
    514e:	26 89       	ldd	r18, Z+22	; 0x16
    5150:	37 89       	ldd	r19, Z+23	; 0x17
    5152:	40 8d       	ldd	r20, Z+24	; 0x18
    5154:	51 8d       	ldd	r21, Z+25	; 0x19
    5156:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    515a:	4b 01       	movw	r8, r22
    515c:	5c 01       	movw	r10, r24
    515e:	9b 01       	movw	r18, r22
    5160:	ac 01       	movw	r20, r24
    5162:	c3 01       	movw	r24, r6
    5164:	b2 01       	movw	r22, r4
    5166:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    516a:	18 16       	cp	r1, r24
    516c:	64 f4       	brge	.+24     	; 0x5186 <planner_recalculate+0x1a8>
    516e:	de 9d       	mul	r29, r14
    5170:	f0 01       	movw	r30, r0
    5172:	df 9d       	mul	r29, r15
    5174:	f0 0d       	add	r31, r0
    5176:	11 24       	eor	r1, r1
    5178:	e8 58       	subi	r30, 0x88	; 136
    517a:	fb 4f       	sbci	r31, 0xFB	; 251
    517c:	86 8a       	std	Z+22, r8	; 0x16
    517e:	97 8a       	std	Z+23, r9	; 0x17
    5180:	a0 8e       	std	Z+24, r10	; 0x18
    5182:	b1 8e       	std	Z+25, r11	; 0x19
    5184:	0b c0       	rjmp	.+22     	; 0x519c <planner_recalculate+0x1be>
    5186:	de 9d       	mul	r29, r14
    5188:	f0 01       	movw	r30, r0
    518a:	df 9d       	mul	r29, r15
    518c:	f0 0d       	add	r31, r0
    518e:	11 24       	eor	r1, r1
    5190:	e8 58       	subi	r30, 0x88	; 136
    5192:	fb 4f       	sbci	r31, 0xFB	; 251
    5194:	46 8a       	std	Z+22, r4	; 0x16
    5196:	57 8a       	std	Z+23, r5	; 0x17
    5198:	60 8e       	std	Z+24, r6	; 0x18
    519a:	71 8e       	std	Z+25, r7	; 0x19
    519c:	68 01       	movw	r12, r16
    519e:	80 91 74 04 	lds	r24, 0x0474	; 0x800474 <block_buffer_planned>
    51a2:	8c 13       	cpse	r24, r28
    51a4:	92 cf       	rjmp	.-220    	; 0x50ca <planner_recalculate+0xec>
    51a6:	20 90 74 04 	lds	r2, 0x0474	; 0x800474 <block_buffer_planned>
    51aa:	f6 e3       	ldi	r31, 0x36	; 54
    51ac:	2f 9e       	mul	r2, r31
    51ae:	c0 01       	movw	r24, r0
    51b0:	11 24       	eor	r1, r1
    51b2:	9c 01       	movw	r18, r24
    51b4:	28 58       	subi	r18, 0x88	; 136
    51b6:	3b 4f       	sbci	r19, 0xFB	; 251
    51b8:	79 01       	movw	r14, r18
    51ba:	c1 e0       	ldi	r28, 0x01	; 1
    51bc:	c2 0d       	add	r28, r2
    51be:	c4 32       	cpi	r28, 0x24	; 36
    51c0:	09 f4       	brne	.+2      	; 0x51c4 <planner_recalculate+0x1e6>
    51c2:	c0 e0       	ldi	r28, 0x00	; 0
    51c4:	30 90 76 04 	lds	r3, 0x0476	; 0x800476 <block_buffer_head>
    51c8:	d6 e3       	ldi	r29, 0x36	; 54
    51ca:	58 c0       	rjmp	.+176    	; 0x527c <planner_recalculate+0x29e>
    51cc:	cc 2e       	mov	r12, r28
    51ce:	d1 2c       	mov	r13, r1
    51d0:	dc 9d       	mul	r29, r12
    51d2:	80 01       	movw	r16, r0
    51d4:	dd 9d       	mul	r29, r13
    51d6:	10 0d       	add	r17, r0
    51d8:	11 24       	eor	r1, r1
    51da:	08 58       	subi	r16, 0x88	; 136
    51dc:	1b 4f       	sbci	r17, 0xFB	; 251
    51de:	f7 01       	movw	r30, r14
    51e0:	46 88       	ldd	r4, Z+22	; 0x16
    51e2:	57 88       	ldd	r5, Z+23	; 0x17
    51e4:	60 8c       	ldd	r6, Z+24	; 0x18
    51e6:	71 8c       	ldd	r7, Z+25	; 0x19
    51e8:	f8 01       	movw	r30, r16
    51ea:	86 88       	ldd	r8, Z+22	; 0x16
    51ec:	97 88       	ldd	r9, Z+23	; 0x17
    51ee:	a0 8c       	ldd	r10, Z+24	; 0x18
    51f0:	b1 8c       	ldd	r11, Z+25	; 0x19
    51f2:	a5 01       	movw	r20, r10
    51f4:	94 01       	movw	r18, r8
    51f6:	c3 01       	movw	r24, r6
    51f8:	b2 01       	movw	r22, r4
    51fa:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    51fe:	88 23       	and	r24, r24
    5200:	24 f5       	brge	.+72     	; 0x524a <planner_recalculate+0x26c>
    5202:	f7 01       	movw	r30, r14
    5204:	66 8d       	ldd	r22, Z+30	; 0x1e
    5206:	77 8d       	ldd	r23, Z+31	; 0x1f
    5208:	80 a1       	ldd	r24, Z+32	; 0x20
    520a:	91 a1       	ldd	r25, Z+33	; 0x21
    520c:	9b 01       	movw	r18, r22
    520e:	ac 01       	movw	r20, r24
    5210:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    5214:	f7 01       	movw	r30, r14
    5216:	22 a1       	ldd	r18, Z+34	; 0x22
    5218:	33 a1       	ldd	r19, Z+35	; 0x23
    521a:	44 a1       	ldd	r20, Z+36	; 0x24
    521c:	55 a1       	ldd	r21, Z+37	; 0x25
    521e:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    5222:	a3 01       	movw	r20, r6
    5224:	92 01       	movw	r18, r4
    5226:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    522a:	2b 01       	movw	r4, r22
    522c:	3c 01       	movw	r6, r24
    522e:	9b 01       	movw	r18, r22
    5230:	ac 01       	movw	r20, r24
    5232:	c5 01       	movw	r24, r10
    5234:	b4 01       	movw	r22, r8
    5236:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    523a:	18 16       	cp	r1, r24
    523c:	34 f4       	brge	.+12     	; 0x524a <planner_recalculate+0x26c>
    523e:	f8 01       	movw	r30, r16
    5240:	46 8a       	std	Z+22, r4	; 0x16
    5242:	57 8a       	std	Z+23, r5	; 0x17
    5244:	60 8e       	std	Z+24, r6	; 0x18
    5246:	71 8e       	std	Z+25, r7	; 0x19
    5248:	2c 2e       	mov	r2, r28
    524a:	dc 9d       	mul	r29, r12
    524c:	f0 01       	movw	r30, r0
    524e:	dd 9d       	mul	r29, r13
    5250:	f0 0d       	add	r31, r0
    5252:	11 24       	eor	r1, r1
    5254:	e8 58       	subi	r30, 0x88	; 136
    5256:	fb 4f       	sbci	r31, 0xFB	; 251
    5258:	22 8d       	ldd	r18, Z+26	; 0x1a
    525a:	33 8d       	ldd	r19, Z+27	; 0x1b
    525c:	44 8d       	ldd	r20, Z+28	; 0x1c
    525e:	55 8d       	ldd	r21, Z+29	; 0x1d
    5260:	66 89       	ldd	r22, Z+22	; 0x16
    5262:	77 89       	ldd	r23, Z+23	; 0x17
    5264:	80 8d       	ldd	r24, Z+24	; 0x18
    5266:	91 8d       	ldd	r25, Z+25	; 0x19
    5268:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    526c:	81 11       	cpse	r24, r1
    526e:	01 c0       	rjmp	.+2      	; 0x5272 <planner_recalculate+0x294>
    5270:	2c 2e       	mov	r2, r28
    5272:	cf 5f       	subi	r28, 0xFF	; 255
    5274:	c4 32       	cpi	r28, 0x24	; 36
    5276:	09 f4       	brne	.+2      	; 0x527a <planner_recalculate+0x29c>
    5278:	c0 e0       	ldi	r28, 0x00	; 0
    527a:	78 01       	movw	r14, r16
    527c:	c3 11       	cpse	r28, r3
    527e:	a6 cf       	rjmp	.-180    	; 0x51cc <planner_recalculate+0x1ee>
    5280:	20 92 74 04 	sts	0x0474, r2	; 0x800474 <block_buffer_planned>
    5284:	df 91       	pop	r29
    5286:	cf 91       	pop	r28
    5288:	1f 91       	pop	r17
    528a:	0f 91       	pop	r16
    528c:	ff 90       	pop	r15
    528e:	ef 90       	pop	r14
    5290:	df 90       	pop	r13
    5292:	cf 90       	pop	r12
    5294:	bf 90       	pop	r11
    5296:	af 90       	pop	r10
    5298:	9f 90       	pop	r9
    529a:	8f 90       	pop	r8
    529c:	7f 90       	pop	r7
    529e:	6f 90       	pop	r6
    52a0:	5f 90       	pop	r5
    52a2:	4f 90       	pop	r4
    52a4:	3f 90       	pop	r3
    52a6:	2f 90       	pop	r2
    52a8:	08 95       	ret

000052aa <plan_reset_buffer>:
    52aa:	10 92 77 04 	sts	0x0477, r1	; 0x800477 <block_buffer_tail>
    52ae:	10 92 76 04 	sts	0x0476, r1	; 0x800476 <block_buffer_head>
    52b2:	81 e0       	ldi	r24, 0x01	; 1
    52b4:	80 93 75 04 	sts	0x0475, r24	; 0x800475 <next_buffer_head>
    52b8:	10 92 74 04 	sts	0x0474, r1	; 0x800474 <block_buffer_planned>
    52bc:	08 95       	ret

000052be <plan_reset>:
    52be:	8c e1       	ldi	r24, 0x1C	; 28
    52c0:	e8 e5       	ldi	r30, 0x58	; 88
    52c2:	f4 e0       	ldi	r31, 0x04	; 4
    52c4:	df 01       	movw	r26, r30
    52c6:	1d 92       	st	X+, r1
    52c8:	8a 95       	dec	r24
    52ca:	e9 f7       	brne	.-6      	; 0x52c6 <plan_reset+0x8>
    52cc:	ee cf       	rjmp	.-36     	; 0x52aa <plan_reset_buffer>
    52ce:	08 95       	ret

000052d0 <plan_discard_current_block>:
    52d0:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    52d4:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <block_buffer_head>
    52d8:	98 17       	cp	r25, r24
    52da:	69 f0       	breq	.+26     	; 0x52f6 <plan_discard_current_block+0x26>
    52dc:	91 e0       	ldi	r25, 0x01	; 1
    52de:	98 0f       	add	r25, r24
    52e0:	94 32       	cpi	r25, 0x24	; 36
    52e2:	09 f4       	brne	.+2      	; 0x52e6 <plan_discard_current_block+0x16>
    52e4:	90 e0       	ldi	r25, 0x00	; 0
    52e6:	20 91 74 04 	lds	r18, 0x0474	; 0x800474 <block_buffer_planned>
    52ea:	82 13       	cpse	r24, r18
    52ec:	02 c0       	rjmp	.+4      	; 0x52f2 <plan_discard_current_block+0x22>
    52ee:	90 93 74 04 	sts	0x0474, r25	; 0x800474 <block_buffer_planned>
    52f2:	90 93 77 04 	sts	0x0477, r25	; 0x800477 <block_buffer_tail>
    52f6:	08 95       	ret

000052f8 <plan_get_system_motion_block>:
    52f8:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <block_buffer_head>
    52fc:	26 e3       	ldi	r18, 0x36	; 54
    52fe:	82 9f       	mul	r24, r18
    5300:	c0 01       	movw	r24, r0
    5302:	11 24       	eor	r1, r1
    5304:	88 58       	subi	r24, 0x88	; 136
    5306:	9b 4f       	sbci	r25, 0xFB	; 251
    5308:	08 95       	ret

0000530a <plan_get_current_block>:
    530a:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    530e:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <block_buffer_head>
    5312:	98 17       	cp	r25, r24
    5314:	39 f0       	breq	.+14     	; 0x5324 <plan_get_current_block+0x1a>
    5316:	26 e3       	ldi	r18, 0x36	; 54
    5318:	82 9f       	mul	r24, r18
    531a:	c0 01       	movw	r24, r0
    531c:	11 24       	eor	r1, r1
    531e:	88 58       	subi	r24, 0x88	; 136
    5320:	9b 4f       	sbci	r25, 0xFB	; 251
    5322:	08 95       	ret
    5324:	80 e0       	ldi	r24, 0x00	; 0
    5326:	90 e0       	ldi	r25, 0x00	; 0
    5328:	08 95       	ret

0000532a <plan_get_exec_block_exit_speed_sqr>:
    532a:	e0 91 77 04 	lds	r30, 0x0477	; 0x800477 <block_buffer_tail>
    532e:	ef 5f       	subi	r30, 0xFF	; 255
    5330:	e4 32       	cpi	r30, 0x24	; 36
    5332:	09 f4       	brne	.+2      	; 0x5336 <plan_get_exec_block_exit_speed_sqr+0xc>
    5334:	e0 e0       	ldi	r30, 0x00	; 0
    5336:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <block_buffer_head>
    533a:	8e 17       	cp	r24, r30
    533c:	59 f0       	breq	.+22     	; 0x5354 <plan_get_exec_block_exit_speed_sqr+0x2a>
    533e:	86 e3       	ldi	r24, 0x36	; 54
    5340:	e8 9f       	mul	r30, r24
    5342:	f0 01       	movw	r30, r0
    5344:	11 24       	eor	r1, r1
    5346:	e8 58       	subi	r30, 0x88	; 136
    5348:	fb 4f       	sbci	r31, 0xFB	; 251
    534a:	66 89       	ldd	r22, Z+22	; 0x16
    534c:	77 89       	ldd	r23, Z+23	; 0x17
    534e:	80 8d       	ldd	r24, Z+24	; 0x18
    5350:	91 8d       	ldd	r25, Z+25	; 0x19
    5352:	08 95       	ret
    5354:	60 e0       	ldi	r22, 0x00	; 0
    5356:	70 e0       	ldi	r23, 0x00	; 0
    5358:	cb 01       	movw	r24, r22
    535a:	08 95       	ret

0000535c <plan_check_full_buffer>:
    535c:	81 e0       	ldi	r24, 0x01	; 1
    535e:	20 91 77 04 	lds	r18, 0x0477	; 0x800477 <block_buffer_tail>
    5362:	90 91 75 04 	lds	r25, 0x0475	; 0x800475 <next_buffer_head>
    5366:	29 13       	cpse	r18, r25
    5368:	80 e0       	ldi	r24, 0x00	; 0
    536a:	08 95       	ret

0000536c <plan_compute_profile_nominal_speed>:
    536c:	af 92       	push	r10
    536e:	bf 92       	push	r11
    5370:	cf 92       	push	r12
    5372:	df 92       	push	r13
    5374:	ef 92       	push	r14
    5376:	ff 92       	push	r15
    5378:	0f 93       	push	r16
    537a:	1f 93       	push	r17
    537c:	cf 93       	push	r28
    537e:	df 93       	push	r29
    5380:	ec 01       	movw	r28, r24
    5382:	1e a5       	ldd	r17, Y+46	; 0x2e
    5384:	af a4       	ldd	r10, Y+47	; 0x2f
    5386:	e8 a8       	ldd	r14, Y+48	; 0x30
    5388:	09 a9       	ldd	r16, Y+49	; 0x31
    538a:	89 89       	ldd	r24, Y+17	; 0x11
    538c:	80 ff       	sbrs	r24, 0
    538e:	1a c0       	rjmp	.+52     	; 0x53c4 <plan_compute_profile_nominal_speed+0x58>
    5390:	60 91 26 0c 	lds	r22, 0x0C26	; 0x800c26 <sys+0x8>
    5394:	70 e0       	ldi	r23, 0x00	; 0
    5396:	80 e0       	ldi	r24, 0x00	; 0
    5398:	90 e0       	ldi	r25, 0x00	; 0
    539a:	0e 94 0b 40 	call	0x8016	; 0x8016 <__floatsisf>
    539e:	2a e0       	ldi	r18, 0x0A	; 10
    53a0:	37 ed       	ldi	r19, 0xD7	; 215
    53a2:	43 e2       	ldi	r20, 0x23	; 35
    53a4:	5c e3       	ldi	r21, 0x3C	; 60
    53a6:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    53aa:	9b 01       	movw	r18, r22
    53ac:	ac 01       	movw	r20, r24
    53ae:	61 2f       	mov	r22, r17
    53b0:	7a 2d       	mov	r23, r10
    53b2:	8e 2d       	mov	r24, r14
    53b4:	90 2f       	mov	r25, r16
    53b6:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    53ba:	16 2f       	mov	r17, r22
    53bc:	a7 2e       	mov	r10, r23
    53be:	e8 2e       	mov	r14, r24
    53c0:	09 2f       	mov	r16, r25
    53c2:	2f c0       	rjmp	.+94     	; 0x5422 <plan_compute_profile_nominal_speed+0xb6>
    53c4:	82 fd       	sbrc	r24, 2
    53c6:	19 c0       	rjmp	.+50     	; 0x53fa <plan_compute_profile_nominal_speed+0x8e>
    53c8:	60 91 25 0c 	lds	r22, 0x0C25	; 0x800c25 <sys+0x7>
    53cc:	70 e0       	ldi	r23, 0x00	; 0
    53ce:	80 e0       	ldi	r24, 0x00	; 0
    53d0:	90 e0       	ldi	r25, 0x00	; 0
    53d2:	0e 94 0b 40 	call	0x8016	; 0x8016 <__floatsisf>
    53d6:	2a e0       	ldi	r18, 0x0A	; 10
    53d8:	37 ed       	ldi	r19, 0xD7	; 215
    53da:	43 e2       	ldi	r20, 0x23	; 35
    53dc:	5c e3       	ldi	r21, 0x3C	; 60
    53de:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    53e2:	9b 01       	movw	r18, r22
    53e4:	ac 01       	movw	r20, r24
    53e6:	61 2f       	mov	r22, r17
    53e8:	7a 2d       	mov	r23, r10
    53ea:	8e 2d       	mov	r24, r14
    53ec:	90 2f       	mov	r25, r16
    53ee:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    53f2:	16 2f       	mov	r17, r22
    53f4:	a7 2e       	mov	r10, r23
    53f6:	e8 2e       	mov	r14, r24
    53f8:	09 2f       	mov	r16, r25
    53fa:	ba a4       	ldd	r11, Y+42	; 0x2a
    53fc:	cb a4       	ldd	r12, Y+43	; 0x2b
    53fe:	dc a4       	ldd	r13, Y+44	; 0x2c
    5400:	fd a4       	ldd	r15, Y+45	; 0x2d
    5402:	2b 2d       	mov	r18, r11
    5404:	3c 2d       	mov	r19, r12
    5406:	4d 2d       	mov	r20, r13
    5408:	5f 2d       	mov	r21, r15
    540a:	61 2f       	mov	r22, r17
    540c:	7a 2d       	mov	r23, r10
    540e:	8e 2d       	mov	r24, r14
    5410:	90 2f       	mov	r25, r16
    5412:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    5416:	18 16       	cp	r1, r24
    5418:	24 f4       	brge	.+8      	; 0x5422 <plan_compute_profile_nominal_speed+0xb6>
    541a:	1b 2d       	mov	r17, r11
    541c:	ac 2c       	mov	r10, r12
    541e:	ed 2c       	mov	r14, r13
    5420:	0f 2d       	mov	r16, r15
    5422:	20 e0       	ldi	r18, 0x00	; 0
    5424:	30 e0       	ldi	r19, 0x00	; 0
    5426:	40 e8       	ldi	r20, 0x80	; 128
    5428:	5f e3       	ldi	r21, 0x3F	; 63
    542a:	61 2f       	mov	r22, r17
    542c:	7a 2d       	mov	r23, r10
    542e:	8e 2d       	mov	r24, r14
    5430:	90 2f       	mov	r25, r16
    5432:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    5436:	18 16       	cp	r1, r24
    5438:	1c f4       	brge	.+6      	; 0x5440 <plan_compute_profile_nominal_speed+0xd4>
    543a:	da 2d       	mov	r29, r10
    543c:	ce 2d       	mov	r28, r14
    543e:	04 c0       	rjmp	.+8      	; 0x5448 <plan_compute_profile_nominal_speed+0xdc>
    5440:	10 e0       	ldi	r17, 0x00	; 0
    5442:	d0 e0       	ldi	r29, 0x00	; 0
    5444:	c0 e8       	ldi	r28, 0x80	; 128
    5446:	0f e3       	ldi	r16, 0x3F	; 63
    5448:	61 2f       	mov	r22, r17
    544a:	7d 2f       	mov	r23, r29
    544c:	8c 2f       	mov	r24, r28
    544e:	90 2f       	mov	r25, r16
    5450:	df 91       	pop	r29
    5452:	cf 91       	pop	r28
    5454:	1f 91       	pop	r17
    5456:	0f 91       	pop	r16
    5458:	ff 90       	pop	r15
    545a:	ef 90       	pop	r14
    545c:	df 90       	pop	r13
    545e:	cf 90       	pop	r12
    5460:	bf 90       	pop	r11
    5462:	af 90       	pop	r10
    5464:	08 95       	ret

00005466 <plan_update_velocity_profile_parameters>:
    5466:	5f 92       	push	r5
    5468:	6f 92       	push	r6
    546a:	7f 92       	push	r7
    546c:	8f 92       	push	r8
    546e:	9f 92       	push	r9
    5470:	af 92       	push	r10
    5472:	bf 92       	push	r11
    5474:	cf 92       	push	r12
    5476:	df 92       	push	r13
    5478:	ef 92       	push	r14
    547a:	ff 92       	push	r15
    547c:	0f 93       	push	r16
    547e:	1f 93       	push	r17
    5480:	cf 93       	push	r28
    5482:	df 93       	push	r29
    5484:	10 91 77 04 	lds	r17, 0x0477	; 0x800477 <block_buffer_tail>
    5488:	50 90 76 04 	lds	r5, 0x0476	; 0x800476 <block_buffer_head>
    548c:	0f 2e       	mov	r0, r31
    548e:	f9 e9       	ldi	r31, 0x99	; 153
    5490:	9f 2e       	mov	r9, r31
    5492:	f0 2d       	mov	r31, r0
    5494:	0f 2e       	mov	r0, r31
    5496:	f6 e7       	ldi	r31, 0x76	; 118
    5498:	8f 2e       	mov	r8, r31
    549a:	f0 2d       	mov	r31, r0
    549c:	0f 2e       	mov	r0, r31
    549e:	f6 e9       	ldi	r31, 0x96	; 150
    54a0:	7f 2e       	mov	r7, r31
    54a2:	f0 2d       	mov	r31, r0
    54a4:	0f 2e       	mov	r0, r31
    54a6:	fe e7       	ldi	r31, 0x7E	; 126
    54a8:	6f 2e       	mov	r6, r31
    54aa:	f0 2d       	mov	r31, r0
    54ac:	0f 2e       	mov	r0, r31
    54ae:	f6 e3       	ldi	r31, 0x36	; 54
    54b0:	cf 2e       	mov	r12, r31
    54b2:	f0 2d       	mov	r31, r0
    54b4:	73 c0       	rjmp	.+230    	; 0x559c <plan_update_velocity_profile_parameters+0x136>
    54b6:	c1 2f       	mov	r28, r17
    54b8:	d0 e0       	ldi	r29, 0x00	; 0
    54ba:	cc 9e       	mul	r12, r28
    54bc:	c0 01       	movw	r24, r0
    54be:	cd 9e       	mul	r12, r29
    54c0:	90 0d       	add	r25, r0
    54c2:	11 24       	eor	r1, r1
    54c4:	88 58       	subi	r24, 0x88	; 136
    54c6:	9b 4f       	sbci	r25, 0xFB	; 251
    54c8:	51 df       	rcall	.-350    	; 0x536c <plan_compute_profile_nominal_speed>
    54ca:	06 2f       	mov	r16, r22
    54cc:	f7 2e       	mov	r15, r23
    54ce:	e8 2e       	mov	r14, r24
    54d0:	d9 2e       	mov	r13, r25
    54d2:	26 2f       	mov	r18, r22
    54d4:	37 2f       	mov	r19, r23
    54d6:	48 2f       	mov	r20, r24
    54d8:	59 2f       	mov	r21, r25
    54da:	69 2d       	mov	r22, r9
    54dc:	78 2d       	mov	r23, r8
    54de:	87 2d       	mov	r24, r7
    54e0:	96 2d       	mov	r25, r6
    54e2:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    54e6:	88 23       	and	r24, r24
    54e8:	cc f4       	brge	.+50     	; 0x551c <plan_update_velocity_profile_parameters+0xb6>
    54ea:	cc 9e       	mul	r12, r28
    54ec:	c0 01       	movw	r24, r0
    54ee:	cd 9e       	mul	r12, r29
    54f0:	90 0d       	add	r25, r0
    54f2:	11 24       	eor	r1, r1
    54f4:	9c 01       	movw	r18, r24
    54f6:	28 58       	subi	r18, 0x88	; 136
    54f8:	3b 4f       	sbci	r19, 0xFB	; 251
    54fa:	59 01       	movw	r10, r18
    54fc:	29 2d       	mov	r18, r9
    54fe:	38 2d       	mov	r19, r8
    5500:	47 2d       	mov	r20, r7
    5502:	56 2d       	mov	r21, r6
    5504:	69 2d       	mov	r22, r9
    5506:	78 2d       	mov	r23, r8
    5508:	87 2d       	mov	r24, r7
    550a:	96 2d       	mov	r25, r6
    550c:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    5510:	f5 01       	movw	r30, r10
    5512:	62 8f       	std	Z+26, r22	; 0x1a
    5514:	73 8f       	std	Z+27, r23	; 0x1b
    5516:	84 8f       	std	Z+28, r24	; 0x1c
    5518:	95 8f       	std	Z+29, r25	; 0x1d
    551a:	18 c0       	rjmp	.+48     	; 0x554c <plan_update_velocity_profile_parameters+0xe6>
    551c:	cc 9e       	mul	r12, r28
    551e:	c0 01       	movw	r24, r0
    5520:	cd 9e       	mul	r12, r29
    5522:	90 0d       	add	r25, r0
    5524:	11 24       	eor	r1, r1
    5526:	9c 01       	movw	r18, r24
    5528:	28 58       	subi	r18, 0x88	; 136
    552a:	3b 4f       	sbci	r19, 0xFB	; 251
    552c:	59 01       	movw	r10, r18
    552e:	20 2f       	mov	r18, r16
    5530:	3f 2d       	mov	r19, r15
    5532:	4e 2d       	mov	r20, r14
    5534:	5d 2d       	mov	r21, r13
    5536:	60 2f       	mov	r22, r16
    5538:	7f 2d       	mov	r23, r15
    553a:	8e 2d       	mov	r24, r14
    553c:	9d 2d       	mov	r25, r13
    553e:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    5542:	f5 01       	movw	r30, r10
    5544:	62 8f       	std	Z+26, r22	; 0x1a
    5546:	73 8f       	std	Z+27, r23	; 0x1b
    5548:	84 8f       	std	Z+28, r24	; 0x1c
    554a:	95 8f       	std	Z+29, r25	; 0x1d
    554c:	cc 9e       	mul	r12, r28
    554e:	f0 01       	movw	r30, r0
    5550:	cd 9e       	mul	r12, r29
    5552:	f0 0d       	add	r31, r0
    5554:	11 24       	eor	r1, r1
    5556:	e8 58       	subi	r30, 0x88	; 136
    5558:	fb 4f       	sbci	r31, 0xFB	; 251
    555a:	86 a0       	ldd	r8, Z+38	; 0x26
    555c:	97 a0       	ldd	r9, Z+39	; 0x27
    555e:	a0 a4       	ldd	r10, Z+40	; 0x28
    5560:	b1 a4       	ldd	r11, Z+41	; 0x29
    5562:	a5 01       	movw	r20, r10
    5564:	94 01       	movw	r18, r8
    5566:	62 8d       	ldd	r22, Z+26	; 0x1a
    5568:	73 8d       	ldd	r23, Z+27	; 0x1b
    556a:	84 8d       	ldd	r24, Z+28	; 0x1c
    556c:	95 8d       	ldd	r25, Z+29	; 0x1d
    556e:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    5572:	18 16       	cp	r1, r24
    5574:	5c f4       	brge	.+22     	; 0x558c <plan_update_velocity_profile_parameters+0x126>
    5576:	cc 9e       	mul	r12, r28
    5578:	f0 01       	movw	r30, r0
    557a:	cd 9e       	mul	r12, r29
    557c:	f0 0d       	add	r31, r0
    557e:	11 24       	eor	r1, r1
    5580:	e8 58       	subi	r30, 0x88	; 136
    5582:	fb 4f       	sbci	r31, 0xFB	; 251
    5584:	82 8e       	std	Z+26, r8	; 0x1a
    5586:	93 8e       	std	Z+27, r9	; 0x1b
    5588:	a4 8e       	std	Z+28, r10	; 0x1c
    558a:	b5 8e       	std	Z+29, r11	; 0x1d
    558c:	1f 5f       	subi	r17, 0xFF	; 255
    558e:	14 32       	cpi	r17, 0x24	; 36
    5590:	09 f4       	brne	.+2      	; 0x5594 <plan_update_velocity_profile_parameters+0x12e>
    5592:	10 e0       	ldi	r17, 0x00	; 0
    5594:	90 2e       	mov	r9, r16
    5596:	8f 2c       	mov	r8, r15
    5598:	7e 2c       	mov	r7, r14
    559a:	6d 2c       	mov	r6, r13
    559c:	15 11       	cpse	r17, r5
    559e:	8b cf       	rjmp	.-234    	; 0x54b6 <plan_update_velocity_profile_parameters+0x50>
    55a0:	89 2d       	mov	r24, r9
    55a2:	98 2d       	mov	r25, r8
    55a4:	a7 2d       	mov	r26, r7
    55a6:	b6 2d       	mov	r27, r6
    55a8:	80 93 70 04 	sts	0x0470, r24	; 0x800470 <pl+0x18>
    55ac:	90 93 71 04 	sts	0x0471, r25	; 0x800471 <pl+0x19>
    55b0:	a0 93 72 04 	sts	0x0472, r26	; 0x800472 <pl+0x1a>
    55b4:	b0 93 73 04 	sts	0x0473, r27	; 0x800473 <pl+0x1b>
    55b8:	df 91       	pop	r29
    55ba:	cf 91       	pop	r28
    55bc:	1f 91       	pop	r17
    55be:	0f 91       	pop	r16
    55c0:	ff 90       	pop	r15
    55c2:	ef 90       	pop	r14
    55c4:	df 90       	pop	r13
    55c6:	cf 90       	pop	r12
    55c8:	bf 90       	pop	r11
    55ca:	af 90       	pop	r10
    55cc:	9f 90       	pop	r9
    55ce:	8f 90       	pop	r8
    55d0:	7f 90       	pop	r7
    55d2:	6f 90       	pop	r6
    55d4:	5f 90       	pop	r5
    55d6:	08 95       	ret

000055d8 <plan_buffer_line>:
    55d8:	2f 92       	push	r2
    55da:	3f 92       	push	r3
    55dc:	4f 92       	push	r4
    55de:	5f 92       	push	r5
    55e0:	6f 92       	push	r6
    55e2:	7f 92       	push	r7
    55e4:	8f 92       	push	r8
    55e6:	9f 92       	push	r9
    55e8:	af 92       	push	r10
    55ea:	bf 92       	push	r11
    55ec:	cf 92       	push	r12
    55ee:	df 92       	push	r13
    55f0:	ef 92       	push	r14
    55f2:	ff 92       	push	r15
    55f4:	0f 93       	push	r16
    55f6:	1f 93       	push	r17
    55f8:	cf 93       	push	r28
    55fa:	df 93       	push	r29
    55fc:	cd b7       	in	r28, 0x3d	; 61
    55fe:	de b7       	in	r29, 0x3e	; 62
    5600:	c6 54       	subi	r28, 0x46	; 70
    5602:	d1 09       	sbc	r29, r1
    5604:	0f b6       	in	r0, 0x3f	; 63
    5606:	f8 94       	cli
    5608:	de bf       	out	0x3e, r29	; 62
    560a:	0f be       	out	0x3f, r0	; 63
    560c:	cd bf       	out	0x3d, r28	; 61
    560e:	23 96       	adiw	r28, 0x03	; 3
    5610:	7f af       	std	Y+63, r23	; 0x3f
    5612:	6e af       	std	Y+62, r22	; 0x3e
    5614:	23 97       	sbiw	r28, 0x03	; 3
    5616:	20 90 76 04 	lds	r2, 0x0476	; 0x800476 <block_buffer_head>
    561a:	a2 2c       	mov	r10, r2
    561c:	b1 2c       	mov	r11, r1
    561e:	26 e3       	ldi	r18, 0x36	; 54
    5620:	2a 9d       	mul	r18, r10
    5622:	a0 01       	movw	r20, r0
    5624:	2b 9d       	mul	r18, r11
    5626:	50 0d       	add	r21, r0
    5628:	11 24       	eor	r1, r1
    562a:	ba 01       	movw	r22, r20
    562c:	68 58       	subi	r22, 0x88	; 136
    562e:	7b 4f       	sbci	r23, 0xFB	; 251
    5630:	21 96       	adiw	r28, 0x01	; 1
    5632:	7f af       	std	Y+63, r23	; 0x3f
    5634:	6e af       	std	Y+62, r22	; 0x3e
    5636:	21 97       	sbiw	r28, 0x01	; 1
    5638:	fb 01       	movw	r30, r22
    563a:	11 92       	st	Z+, r1
    563c:	2a 95       	dec	r18
    563e:	e9 f7       	brne	.-6      	; 0x563a <plan_buffer_line+0x62>
    5640:	23 96       	adiw	r28, 0x03	; 3
    5642:	ee ad       	ldd	r30, Y+62	; 0x3e
    5644:	ff ad       	ldd	r31, Y+63	; 0x3f
    5646:	23 97       	sbiw	r28, 0x03	; 3
    5648:	24 85       	ldd	r18, Z+12	; 0x0c
    564a:	fb 01       	movw	r30, r22
    564c:	21 8b       	std	Z+17, r18	; 0x11
    564e:	23 96       	adiw	r28, 0x03	; 3
    5650:	ee ad       	ldd	r30, Y+62	; 0x3e
    5652:	ff ad       	ldd	r31, Y+63	; 0x3f
    5654:	23 97       	sbiw	r28, 0x03	; 3
    5656:	44 81       	ldd	r20, Z+4	; 0x04
    5658:	55 81       	ldd	r21, Z+5	; 0x05
    565a:	66 81       	ldd	r22, Z+6	; 0x06
    565c:	77 81       	ldd	r23, Z+7	; 0x07
    565e:	21 96       	adiw	r28, 0x01	; 1
    5660:	ee ad       	ldd	r30, Y+62	; 0x3e
    5662:	ff ad       	ldd	r31, Y+63	; 0x3f
    5664:	21 97       	sbiw	r28, 0x01	; 1
    5666:	42 ab       	std	Z+50, r20	; 0x32
    5668:	53 ab       	std	Z+51, r21	; 0x33
    566a:	64 ab       	std	Z+52, r22	; 0x34
    566c:	75 ab       	std	Z+53, r23	; 0x35
    566e:	23 96       	adiw	r28, 0x03	; 3
    5670:	ee ad       	ldd	r30, Y+62	; 0x3e
    5672:	ff ad       	ldd	r31, Y+63	; 0x3f
    5674:	23 97       	sbiw	r28, 0x03	; 3
    5676:	40 85       	ldd	r20, Z+8	; 0x08
    5678:	51 85       	ldd	r21, Z+9	; 0x09
    567a:	62 85       	ldd	r22, Z+10	; 0x0a
    567c:	73 85       	ldd	r23, Z+11	; 0x0b
    567e:	21 96       	adiw	r28, 0x01	; 1
    5680:	ee ad       	ldd	r30, Y+62	; 0x3e
    5682:	ff ad       	ldd	r31, Y+63	; 0x3f
    5684:	21 97       	sbiw	r28, 0x01	; 1
    5686:	42 8b       	std	Z+18, r20	; 0x12
    5688:	53 8b       	std	Z+19, r21	; 0x13
    568a:	64 8b       	std	Z+20, r22	; 0x14
    568c:	75 8b       	std	Z+21, r23	; 0x15
    568e:	21 ff       	sbrs	r18, 1
    5690:	0a c0       	rjmp	.+20     	; 0x56a6 <plan_buffer_line+0xce>
    5692:	2c e0       	ldi	r18, 0x0C	; 12
    5694:	e3 e4       	ldi	r30, 0x43	; 67
    5696:	fc e0       	ldi	r31, 0x0C	; 12
    5698:	de 01       	movw	r26, r28
    569a:	1d 96       	adiw	r26, 0x0d	; 13
    569c:	01 90       	ld	r0, Z+
    569e:	0d 92       	st	X+, r0
    56a0:	2a 95       	dec	r18
    56a2:	e1 f7       	brne	.-8      	; 0x569c <plan_buffer_line+0xc4>
    56a4:	65 c2       	rjmp	.+1226   	; 0x5b70 <plan_buffer_line+0x598>
    56a6:	2c e0       	ldi	r18, 0x0C	; 12
    56a8:	e8 e5       	ldi	r30, 0x58	; 88
    56aa:	f4 e0       	ldi	r31, 0x04	; 4
    56ac:	de 01       	movw	r26, r28
    56ae:	1d 96       	adiw	r26, 0x0d	; 13
    56b0:	01 90       	ld	r0, Z+
    56b2:	0d 92       	st	X+, r0
    56b4:	2a 95       	dec	r18
    56b6:	e1 f7       	brne	.-8      	; 0x56b0 <plan_buffer_line+0xd8>
    56b8:	5b c2       	rjmp	.+1206   	; 0x5b70 <plan_buffer_line+0x598>
    56ba:	e9 ad       	ldd	r30, Y+57	; 0x39
    56bc:	fa ad       	ldd	r31, Y+58	; 0x3a
    56be:	61 91       	ld	r22, Z+
    56c0:	71 91       	ld	r23, Z+
    56c2:	81 91       	ld	r24, Z+
    56c4:	91 91       	ld	r25, Z+
    56c6:	fa af       	std	Y+58, r31	; 0x3a
    56c8:	e9 af       	std	Y+57, r30	; 0x39
    56ca:	eb ad       	ldd	r30, Y+59	; 0x3b
    56cc:	fc ad       	ldd	r31, Y+60	; 0x3c
    56ce:	21 91       	ld	r18, Z+
    56d0:	31 91       	ld	r19, Z+
    56d2:	41 91       	ld	r20, Z+
    56d4:	51 91       	ld	r21, Z+
    56d6:	fc af       	std	Y+60, r31	; 0x3c
    56d8:	eb af       	std	Y+59, r30	; 0x3b
    56da:	2d ab       	std	Y+53, r18	; 0x35
    56dc:	3e ab       	std	Y+54, r19	; 0x36
    56de:	4f ab       	std	Y+55, r20	; 0x37
    56e0:	58 af       	std	Y+56, r21	; 0x38
    56e2:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    56e6:	0e 94 77 41 	call	0x82ee	; 0x82ee <lround>
    56ea:	f4 01       	movw	r30, r8
    56ec:	61 93       	st	Z+, r22
    56ee:	71 93       	st	Z+, r23
    56f0:	81 93       	st	Z+, r24
    56f2:	91 93       	st	Z+, r25
    56f4:	4f 01       	movw	r8, r30
    56f6:	f6 01       	movw	r30, r12
    56f8:	01 91       	ld	r16, Z+
    56fa:	11 91       	ld	r17, Z+
    56fc:	21 91       	ld	r18, Z+
    56fe:	31 91       	ld	r19, Z+
    5700:	6f 01       	movw	r12, r30
    5702:	60 1b       	sub	r22, r16
    5704:	71 0b       	sbc	r23, r17
    5706:	82 0b       	sbc	r24, r18
    5708:	93 0b       	sbc	r25, r19
    570a:	8b 01       	movw	r16, r22
    570c:	9c 01       	movw	r18, r24
    570e:	3a f4       	brpl	.+14     	; 0x571e <plan_buffer_line+0x146>
    5710:	00 27       	eor	r16, r16
    5712:	11 27       	eor	r17, r17
    5714:	98 01       	movw	r18, r16
    5716:	06 1b       	sub	r16, r22
    5718:	17 0b       	sbc	r17, r23
    571a:	28 0b       	sbc	r18, r24
    571c:	39 0b       	sbc	r19, r25
    571e:	f1 01       	movw	r30, r2
    5720:	01 93       	st	Z+, r16
    5722:	11 93       	st	Z+, r17
    5724:	21 93       	st	Z+, r18
    5726:	31 93       	st	Z+, r19
    5728:	1f 01       	movw	r2, r30
    572a:	f7 01       	movw	r30, r14
    572c:	40 80       	ld	r4, Z
    572e:	51 80       	ldd	r5, Z+1	; 0x01
    5730:	62 80       	ldd	r6, Z+2	; 0x02
    5732:	73 80       	ldd	r7, Z+3	; 0x03
    5734:	40 16       	cp	r4, r16
    5736:	51 06       	cpc	r5, r17
    5738:	62 06       	cpc	r6, r18
    573a:	73 06       	cpc	r7, r19
    573c:	10 f4       	brcc	.+4      	; 0x5742 <plan_buffer_line+0x16a>
    573e:	28 01       	movw	r4, r16
    5740:	39 01       	movw	r6, r18
    5742:	f7 01       	movw	r30, r14
    5744:	40 82       	st	Z, r4
    5746:	51 82       	std	Z+1, r5	; 0x01
    5748:	62 82       	std	Z+2, r6	; 0x02
    574a:	73 82       	std	Z+3, r7	; 0x03
    574c:	0e 94 0b 40 	call	0x8016	; 0x8016 <__floatsisf>
    5750:	2d a9       	ldd	r18, Y+53	; 0x35
    5752:	3e a9       	ldd	r19, Y+54	; 0x36
    5754:	4f a9       	ldd	r20, Y+55	; 0x37
    5756:	58 ad       	ldd	r21, Y+56	; 0x38
    5758:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <__divsf3>
    575c:	ed ad       	ldd	r30, Y+61	; 0x3d
    575e:	fe ad       	ldd	r31, Y+62	; 0x3e
    5760:	61 93       	st	Z+, r22
    5762:	71 93       	st	Z+, r23
    5764:	81 93       	st	Z+, r24
    5766:	91 93       	st	Z+, r25
    5768:	fe af       	std	Y+62, r31	; 0x3e
    576a:	ed af       	std	Y+61, r30	; 0x3d
    576c:	20 e0       	ldi	r18, 0x00	; 0
    576e:	30 e0       	ldi	r19, 0x00	; 0
    5770:	a9 01       	movw	r20, r18
    5772:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    5776:	88 23       	and	r24, r24
    5778:	4c f4       	brge	.+18     	; 0x578c <plan_buffer_line+0x1b4>
    577a:	89 a9       	ldd	r24, Y+49	; 0x31
    577c:	1c dc       	rcall	.-1992   	; 0x4fb6 <get_direction_pin_mask>
    577e:	27 96       	adiw	r28, 0x07	; 7
    5780:	ee ad       	ldd	r30, Y+62	; 0x3e
    5782:	ff ad       	ldd	r31, Y+63	; 0x3f
    5784:	27 97       	sbiw	r28, 0x07	; 7
    5786:	90 81       	ld	r25, Z
    5788:	89 2b       	or	r24, r25
    578a:	80 83       	st	Z, r24
    578c:	f9 a9       	ldd	r31, Y+49	; 0x31
    578e:	ff 5f       	subi	r31, 0xFF	; 255
    5790:	f9 ab       	std	Y+49, r31	; 0x31
    5792:	f3 30       	cpi	r31, 0x03	; 3
    5794:	09 f0       	breq	.+2      	; 0x5798 <plan_buffer_line+0x1c0>
    5796:	91 cf       	rjmp	.-222    	; 0x56ba <plan_buffer_line+0xe2>
    5798:	86 e3       	ldi	r24, 0x36	; 54
    579a:	8a 9d       	mul	r24, r10
    579c:	f0 01       	movw	r30, r0
    579e:	8b 9d       	mul	r24, r11
    57a0:	f0 0d       	add	r31, r0
    57a2:	11 24       	eor	r1, r1
    57a4:	e8 58       	subi	r30, 0x88	; 136
    57a6:	fb 4f       	sbci	r31, 0xFB	; 251
    57a8:	84 85       	ldd	r24, Z+12	; 0x0c
    57aa:	95 85       	ldd	r25, Z+13	; 0x0d
    57ac:	a6 85       	ldd	r26, Z+14	; 0x0e
    57ae:	b7 85       	ldd	r27, Z+15	; 0x0f
    57b0:	89 2b       	or	r24, r25
    57b2:	8a 2b       	or	r24, r26
    57b4:	8b 2b       	or	r24, r27
    57b6:	09 f4       	brne	.+2      	; 0x57ba <plan_buffer_line+0x1e2>
    57b8:	d7 c1       	rjmp	.+942    	; 0x5b68 <plan_buffer_line+0x590>
    57ba:	ce 01       	movw	r24, r28
    57bc:	49 96       	adiw	r24, 0x19	; 25
    57be:	8e d3       	rcall	.+1820   	; 0x5edc <convert_delta_vector_to_unit_vector>
    57c0:	26 e3       	ldi	r18, 0x36	; 54
    57c2:	2a 9d       	mul	r18, r10
    57c4:	80 01       	movw	r16, r0
    57c6:	2b 9d       	mul	r18, r11
    57c8:	10 0d       	add	r17, r0
    57ca:	11 24       	eor	r1, r1
    57cc:	08 58       	subi	r16, 0x88	; 136
    57ce:	1b 4f       	sbci	r17, 0xFB	; 251
    57d0:	f8 01       	movw	r30, r16
    57d2:	62 a3       	std	Z+34, r22	; 0x22
    57d4:	73 a3       	std	Z+35, r23	; 0x23
    57d6:	84 a3       	std	Z+36, r24	; 0x24
    57d8:	95 a3       	std	Z+37, r25	; 0x25
    57da:	be 01       	movw	r22, r28
    57dc:	67 5e       	subi	r22, 0xE7	; 231
    57de:	7f 4f       	sbci	r23, 0xFF	; 255
    57e0:	88 ee       	ldi	r24, 0xE8	; 232
    57e2:	9e e0       	ldi	r25, 0x0E	; 14
    57e4:	e2 d3       	rcall	.+1988   	; 0x5faa <limit_value_by_axis_maximum>
    57e6:	f8 01       	movw	r30, r16
    57e8:	66 8f       	std	Z+30, r22	; 0x1e
    57ea:	77 8f       	std	Z+31, r23	; 0x1f
    57ec:	80 a3       	std	Z+32, r24	; 0x20
    57ee:	91 a3       	std	Z+33, r25	; 0x21
    57f0:	be 01       	movw	r22, r28
    57f2:	67 5e       	subi	r22, 0xE7	; 231
    57f4:	7f 4f       	sbci	r23, 0xFF	; 255
    57f6:	8c ed       	ldi	r24, 0xDC	; 220
    57f8:	9e e0       	ldi	r25, 0x0E	; 14
    57fa:	d7 d3       	rcall	.+1966   	; 0x5faa <limit_value_by_axis_maximum>
    57fc:	f8 01       	movw	r30, r16
    57fe:	62 a7       	std	Z+42, r22	; 0x2a
    5800:	73 a7       	std	Z+43, r23	; 0x2b
    5802:	84 a7       	std	Z+44, r24	; 0x2c
    5804:	95 a7       	std	Z+45, r25	; 0x2d
    5806:	11 89       	ldd	r17, Z+17	; 0x11
    5808:	10 ff       	sbrs	r17, 0
    580a:	0d c0       	rjmp	.+26     	; 0x5826 <plan_buffer_line+0x24e>
    580c:	26 e3       	ldi	r18, 0x36	; 54
    580e:	2a 9d       	mul	r18, r10
    5810:	f0 01       	movw	r30, r0
    5812:	2b 9d       	mul	r18, r11
    5814:	f0 0d       	add	r31, r0
    5816:	11 24       	eor	r1, r1
    5818:	e8 58       	subi	r30, 0x88	; 136
    581a:	fb 4f       	sbci	r31, 0xFB	; 251
    581c:	66 a7       	std	Z+46, r22	; 0x2e
    581e:	77 a7       	std	Z+47, r23	; 0x2f
    5820:	80 ab       	std	Z+48, r24	; 0x30
    5822:	91 ab       	std	Z+49, r25	; 0x31
    5824:	22 c0       	rjmp	.+68     	; 0x586a <plan_buffer_line+0x292>
    5826:	23 96       	adiw	r28, 0x03	; 3
    5828:	ee ad       	ldd	r30, Y+62	; 0x3e
    582a:	ff ad       	ldd	r31, Y+63	; 0x3f
    582c:	23 97       	sbiw	r28, 0x03	; 3
    582e:	20 81       	ld	r18, Z
    5830:	31 81       	ldd	r19, Z+1	; 0x01
    5832:	42 81       	ldd	r20, Z+2	; 0x02
    5834:	53 81       	ldd	r21, Z+3	; 0x03
    5836:	86 e3       	ldi	r24, 0x36	; 54
    5838:	8a 9d       	mul	r24, r10
    583a:	f0 01       	movw	r30, r0
    583c:	8b 9d       	mul	r24, r11
    583e:	f0 0d       	add	r31, r0
    5840:	11 24       	eor	r1, r1
    5842:	e8 58       	subi	r30, 0x88	; 136
    5844:	fb 4f       	sbci	r31, 0xFB	; 251
    5846:	26 a7       	std	Z+46, r18	; 0x2e
    5848:	37 a7       	std	Z+47, r19	; 0x2f
    584a:	40 ab       	std	Z+48, r20	; 0x30
    584c:	51 ab       	std	Z+49, r21	; 0x31
    584e:	13 ff       	sbrs	r17, 3
    5850:	0c c0       	rjmp	.+24     	; 0x586a <plan_buffer_line+0x292>
    5852:	7f 01       	movw	r14, r30
    5854:	62 a1       	ldd	r22, Z+34	; 0x22
    5856:	73 a1       	ldd	r23, Z+35	; 0x23
    5858:	84 a1       	ldd	r24, Z+36	; 0x24
    585a:	95 a1       	ldd	r25, Z+37	; 0x25
    585c:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    5860:	f7 01       	movw	r30, r14
    5862:	66 a7       	std	Z+46, r22	; 0x2e
    5864:	77 a7       	std	Z+47, r23	; 0x2f
    5866:	80 ab       	std	Z+48, r24	; 0x30
    5868:	91 ab       	std	Z+49, r25	; 0x31
    586a:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <block_buffer_head>
    586e:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    5872:	98 17       	cp	r25, r24
    5874:	11 f0       	breq	.+4      	; 0x587a <plan_buffer_line+0x2a2>
    5876:	11 ff       	sbrs	r17, 1
    5878:	11 c0       	rjmp	.+34     	; 0x589c <plan_buffer_line+0x2c4>
    587a:	86 e3       	ldi	r24, 0x36	; 54
    587c:	8a 9d       	mul	r24, r10
    587e:	f0 01       	movw	r30, r0
    5880:	8b 9d       	mul	r24, r11
    5882:	f0 0d       	add	r31, r0
    5884:	11 24       	eor	r1, r1
    5886:	e8 58       	subi	r30, 0x88	; 136
    5888:	fb 4f       	sbci	r31, 0xFB	; 251
    588a:	16 8a       	std	Z+22, r1	; 0x16
    588c:	17 8a       	std	Z+23, r1	; 0x17
    588e:	10 8e       	std	Z+24, r1	; 0x18
    5890:	11 8e       	std	Z+25, r1	; 0x19
    5892:	16 a2       	std	Z+38, r1	; 0x26
    5894:	17 a2       	std	Z+39, r1	; 0x27
    5896:	10 a6       	std	Z+40, r1	; 0x28
    5898:	11 a6       	std	Z+41, r1	; 0x29
    589a:	d6 c0       	rjmp	.+428    	; 0x5a48 <plan_buffer_line+0x470>
    589c:	04 e6       	ldi	r16, 0x64	; 100
    589e:	14 e0       	ldi	r17, 0x04	; 4
    58a0:	1e 01       	movw	r2, r28
    58a2:	f5 e2       	ldi	r31, 0x25	; 37
    58a4:	2f 0e       	add	r2, r31
    58a6:	31 1c       	adc	r3, r1
    58a8:	41 01       	movw	r8, r2
    58aa:	19 aa       	std	Y+49, r1	; 0x31
    58ac:	1a aa       	std	Y+50, r1	; 0x32
    58ae:	1b aa       	std	Y+51, r1	; 0x33
    58b0:	1c aa       	std	Y+52, r1	; 0x34
    58b2:	f8 01       	movw	r30, r16
    58b4:	c1 90       	ld	r12, Z+
    58b6:	d1 90       	ld	r13, Z+
    58b8:	e1 90       	ld	r14, Z+
    58ba:	f1 90       	ld	r15, Z+
    58bc:	8f 01       	movw	r16, r30
    58be:	25 96       	adiw	r28, 0x05	; 5
    58c0:	ee ad       	ldd	r30, Y+62	; 0x3e
    58c2:	ff ad       	ldd	r31, Y+63	; 0x3f
    58c4:	25 97       	sbiw	r28, 0x05	; 5
    58c6:	41 90       	ld	r4, Z+
    58c8:	51 90       	ld	r5, Z+
    58ca:	61 90       	ld	r6, Z+
    58cc:	71 90       	ld	r7, Z+
    58ce:	25 96       	adiw	r28, 0x05	; 5
    58d0:	ff af       	std	Y+63, r31	; 0x3f
    58d2:	ee af       	std	Y+62, r30	; 0x3e
    58d4:	25 97       	sbiw	r28, 0x05	; 5
    58d6:	a3 01       	movw	r20, r6
    58d8:	92 01       	movw	r18, r4
    58da:	c7 01       	movw	r24, r14
    58dc:	b6 01       	movw	r22, r12
    58de:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    58e2:	9b 01       	movw	r18, r22
    58e4:	ac 01       	movw	r20, r24
    58e6:	69 a9       	ldd	r22, Y+49	; 0x31
    58e8:	7a a9       	ldd	r23, Y+50	; 0x32
    58ea:	8b a9       	ldd	r24, Y+51	; 0x33
    58ec:	9c a9       	ldd	r25, Y+52	; 0x34
    58ee:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    58f2:	69 ab       	std	Y+49, r22	; 0x31
    58f4:	7a ab       	std	Y+50, r23	; 0x32
    58f6:	8b ab       	std	Y+51, r24	; 0x33
    58f8:	9c ab       	std	Y+52, r25	; 0x34
    58fa:	a7 01       	movw	r20, r14
    58fc:	96 01       	movw	r18, r12
    58fe:	c3 01       	movw	r24, r6
    5900:	b2 01       	movw	r22, r4
    5902:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    5906:	f1 01       	movw	r30, r2
    5908:	61 93       	st	Z+, r22
    590a:	71 93       	st	Z+, r23
    590c:	81 93       	st	Z+, r24
    590e:	91 93       	st	Z+, r25
    5910:	1f 01       	movw	r2, r30
    5912:	25 96       	adiw	r28, 0x05	; 5
    5914:	2e ad       	ldd	r18, Y+62	; 0x3e
    5916:	3f ad       	ldd	r19, Y+63	; 0x3f
    5918:	25 97       	sbiw	r28, 0x05	; 5
    591a:	28 15       	cp	r18, r8
    591c:	39 05       	cpc	r19, r9
    591e:	49 f6       	brne	.-110    	; 0x58b2 <plan_buffer_line+0x2da>
    5920:	2f ee       	ldi	r18, 0xEF	; 239
    5922:	3f ef       	ldi	r19, 0xFF	; 255
    5924:	4f e7       	ldi	r20, 0x7F	; 127
    5926:	5f e3       	ldi	r21, 0x3F	; 63
    5928:	69 a9       	ldd	r22, Y+49	; 0x31
    592a:	7a a9       	ldd	r23, Y+50	; 0x32
    592c:	8b a9       	ldd	r24, Y+51	; 0x33
    592e:	9c a9       	ldd	r25, Y+52	; 0x34
    5930:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    5934:	18 16       	cp	r1, r24
    5936:	6c f4       	brge	.+26     	; 0x5952 <plan_buffer_line+0x37a>
    5938:	86 e3       	ldi	r24, 0x36	; 54
    593a:	8a 9d       	mul	r24, r10
    593c:	f0 01       	movw	r30, r0
    593e:	8b 9d       	mul	r24, r11
    5940:	f0 0d       	add	r31, r0
    5942:	11 24       	eor	r1, r1
    5944:	e8 58       	subi	r30, 0x88	; 136
    5946:	fb 4f       	sbci	r31, 0xFB	; 251
    5948:	16 a2       	std	Z+38, r1	; 0x26
    594a:	17 a2       	std	Z+39, r1	; 0x27
    594c:	10 a6       	std	Z+40, r1	; 0x28
    594e:	11 a6       	std	Z+41, r1	; 0x29
    5950:	7b c0       	rjmp	.+246    	; 0x5a48 <plan_buffer_line+0x470>
    5952:	2f ee       	ldi	r18, 0xEF	; 239
    5954:	3f ef       	ldi	r19, 0xFF	; 255
    5956:	4f e7       	ldi	r20, 0x7F	; 127
    5958:	5f eb       	ldi	r21, 0xBF	; 191
    595a:	69 a9       	ldd	r22, Y+49	; 0x31
    595c:	7a a9       	ldd	r23, Y+50	; 0x32
    595e:	8b a9       	ldd	r24, Y+51	; 0x33
    5960:	9c a9       	ldd	r25, Y+52	; 0x34
    5962:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    5966:	88 23       	and	r24, r24
    5968:	8c f4       	brge	.+34     	; 0x598c <plan_buffer_line+0x3b4>
    596a:	86 e3       	ldi	r24, 0x36	; 54
    596c:	8a 9d       	mul	r24, r10
    596e:	f0 01       	movw	r30, r0
    5970:	8b 9d       	mul	r24, r11
    5972:	f0 0d       	add	r31, r0
    5974:	11 24       	eor	r1, r1
    5976:	e8 58       	subi	r30, 0x88	; 136
    5978:	fb 4f       	sbci	r31, 0xFB	; 251
    597a:	89 e9       	ldi	r24, 0x99	; 153
    597c:	96 e7       	ldi	r25, 0x76	; 118
    597e:	a6 e9       	ldi	r26, 0x96	; 150
    5980:	be e7       	ldi	r27, 0x7E	; 126
    5982:	86 a3       	std	Z+38, r24	; 0x26
    5984:	97 a3       	std	Z+39, r25	; 0x27
    5986:	a0 a7       	std	Z+40, r26	; 0x28
    5988:	b1 a7       	std	Z+41, r27	; 0x29
    598a:	5e c0       	rjmp	.+188    	; 0x5a48 <plan_buffer_line+0x470>
    598c:	ce 01       	movw	r24, r28
    598e:	85 96       	adiw	r24, 0x25	; 37
    5990:	a5 d2       	rcall	.+1354   	; 0x5edc <convert_delta_vector_to_unit_vector>
    5992:	be 01       	movw	r22, r28
    5994:	6b 5d       	subi	r22, 0xDB	; 219
    5996:	7f 4f       	sbci	r23, 0xFF	; 255
    5998:	88 ee       	ldi	r24, 0xE8	; 232
    599a:	9e e0       	ldi	r25, 0x0E	; 14
    599c:	06 d3       	rcall	.+1548   	; 0x5faa <limit_value_by_axis_maximum>
    599e:	6b 01       	movw	r12, r22
    59a0:	7c 01       	movw	r14, r24
    59a2:	29 a9       	ldd	r18, Y+49	; 0x31
    59a4:	3a a9       	ldd	r19, Y+50	; 0x32
    59a6:	4b a9       	ldd	r20, Y+51	; 0x33
    59a8:	5c a9       	ldd	r21, Y+52	; 0x34
    59aa:	60 e0       	ldi	r22, 0x00	; 0
    59ac:	70 e0       	ldi	r23, 0x00	; 0
    59ae:	80 e8       	ldi	r24, 0x80	; 128
    59b0:	9f e3       	ldi	r25, 0x3F	; 63
    59b2:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    59b6:	20 e0       	ldi	r18, 0x00	; 0
    59b8:	30 e0       	ldi	r19, 0x00	; 0
    59ba:	40 e0       	ldi	r20, 0x00	; 0
    59bc:	5f e3       	ldi	r21, 0x3F	; 63
    59be:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    59c2:	0e 94 34 42 	call	0x8468	; 0x8468 <sqrt>
    59c6:	2b 01       	movw	r4, r22
    59c8:	3c 01       	movw	r6, r24
    59ca:	20 91 05 0f 	lds	r18, 0x0F05	; 0x800f05 <settings+0x35>
    59ce:	30 91 06 0f 	lds	r19, 0x0F06	; 0x800f06 <settings+0x36>
    59d2:	40 91 07 0f 	lds	r20, 0x0F07	; 0x800f07 <settings+0x37>
    59d6:	50 91 08 0f 	lds	r21, 0x0F08	; 0x800f08 <settings+0x38>
    59da:	c7 01       	movw	r24, r14
    59dc:	b6 01       	movw	r22, r12
    59de:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    59e2:	a3 01       	movw	r20, r6
    59e4:	92 01       	movw	r18, r4
    59e6:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    59ea:	6b 01       	movw	r12, r22
    59ec:	7c 01       	movw	r14, r24
    59ee:	a3 01       	movw	r20, r6
    59f0:	92 01       	movw	r18, r4
    59f2:	60 e0       	ldi	r22, 0x00	; 0
    59f4:	70 e0       	ldi	r23, 0x00	; 0
    59f6:	80 e8       	ldi	r24, 0x80	; 128
    59f8:	9f e3       	ldi	r25, 0x3F	; 63
    59fa:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <__subsf3>
    59fe:	9b 01       	movw	r18, r22
    5a00:	ac 01       	movw	r20, r24
    5a02:	c7 01       	movw	r24, r14
    5a04:	b6 01       	movw	r22, r12
    5a06:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <__divsf3>
    5a0a:	e6 2e       	mov	r14, r22
    5a0c:	f7 2e       	mov	r15, r23
    5a0e:	08 2f       	mov	r16, r24
    5a10:	19 2f       	mov	r17, r25
    5a12:	20 e0       	ldi	r18, 0x00	; 0
    5a14:	30 e0       	ldi	r19, 0x00	; 0
    5a16:	a9 01       	movw	r20, r18
    5a18:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    5a1c:	88 23       	and	r24, r24
    5a1e:	24 f4       	brge	.+8      	; 0x5a28 <plan_buffer_line+0x450>
    5a20:	e1 2c       	mov	r14, r1
    5a22:	f1 2c       	mov	r15, r1
    5a24:	00 e0       	ldi	r16, 0x00	; 0
    5a26:	10 e0       	ldi	r17, 0x00	; 0
    5a28:	86 e3       	ldi	r24, 0x36	; 54
    5a2a:	8a 9d       	mul	r24, r10
    5a2c:	f0 01       	movw	r30, r0
    5a2e:	8b 9d       	mul	r24, r11
    5a30:	f0 0d       	add	r31, r0
    5a32:	11 24       	eor	r1, r1
    5a34:	e8 58       	subi	r30, 0x88	; 136
    5a36:	fb 4f       	sbci	r31, 0xFB	; 251
    5a38:	4e 2d       	mov	r20, r14
    5a3a:	5f 2d       	mov	r21, r15
    5a3c:	60 2f       	mov	r22, r16
    5a3e:	71 2f       	mov	r23, r17
    5a40:	46 a3       	std	Z+38, r20	; 0x26
    5a42:	57 a3       	std	Z+39, r21	; 0x27
    5a44:	60 a7       	std	Z+40, r22	; 0x28
    5a46:	71 a7       	std	Z+41, r23	; 0x29
    5a48:	86 e3       	ldi	r24, 0x36	; 54
    5a4a:	8a 9d       	mul	r24, r10
    5a4c:	f0 01       	movw	r30, r0
    5a4e:	8b 9d       	mul	r24, r11
    5a50:	f0 0d       	add	r31, r0
    5a52:	11 24       	eor	r1, r1
    5a54:	e8 58       	subi	r30, 0x88	; 136
    5a56:	fb 4f       	sbci	r31, 0xFB	; 251
    5a58:	81 89       	ldd	r24, Z+17	; 0x11
    5a5a:	81 fd       	sbrc	r24, 1
    5a5c:	87 c0       	rjmp	.+270    	; 0x5b6c <plan_buffer_line+0x594>
    5a5e:	21 96       	adiw	r28, 0x01	; 1
    5a60:	8e ad       	ldd	r24, Y+62	; 0x3e
    5a62:	9f ad       	ldd	r25, Y+63	; 0x3f
    5a64:	21 97       	sbiw	r28, 0x01	; 1
    5a66:	82 dc       	rcall	.-1788   	; 0x536c <plan_compute_profile_nominal_speed>
    5a68:	6b 01       	movw	r12, r22
    5a6a:	7c 01       	movw	r14, r24
    5a6c:	40 90 70 04 	lds	r4, 0x0470	; 0x800470 <pl+0x18>
    5a70:	50 90 71 04 	lds	r5, 0x0471	; 0x800471 <pl+0x19>
    5a74:	60 90 72 04 	lds	r6, 0x0472	; 0x800472 <pl+0x1a>
    5a78:	70 90 73 04 	lds	r7, 0x0473	; 0x800473 <pl+0x1b>
    5a7c:	a3 01       	movw	r20, r6
    5a7e:	92 01       	movw	r18, r4
    5a80:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    5a84:	18 16       	cp	r1, r24
    5a86:	a4 f4       	brge	.+40     	; 0x5ab0 <plan_buffer_line+0x4d8>
    5a88:	86 e3       	ldi	r24, 0x36	; 54
    5a8a:	8a 9d       	mul	r24, r10
    5a8c:	80 01       	movw	r16, r0
    5a8e:	8b 9d       	mul	r24, r11
    5a90:	10 0d       	add	r17, r0
    5a92:	11 24       	eor	r1, r1
    5a94:	08 58       	subi	r16, 0x88	; 136
    5a96:	1b 4f       	sbci	r17, 0xFB	; 251
    5a98:	a3 01       	movw	r20, r6
    5a9a:	92 01       	movw	r18, r4
    5a9c:	c3 01       	movw	r24, r6
    5a9e:	b2 01       	movw	r22, r4
    5aa0:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    5aa4:	f8 01       	movw	r30, r16
    5aa6:	62 8f       	std	Z+26, r22	; 0x1a
    5aa8:	73 8f       	std	Z+27, r23	; 0x1b
    5aaa:	84 8f       	std	Z+28, r24	; 0x1c
    5aac:	95 8f       	std	Z+29, r25	; 0x1d
    5aae:	13 c0       	rjmp	.+38     	; 0x5ad6 <plan_buffer_line+0x4fe>
    5ab0:	86 e3       	ldi	r24, 0x36	; 54
    5ab2:	8a 9d       	mul	r24, r10
    5ab4:	80 01       	movw	r16, r0
    5ab6:	8b 9d       	mul	r24, r11
    5ab8:	10 0d       	add	r17, r0
    5aba:	11 24       	eor	r1, r1
    5abc:	08 58       	subi	r16, 0x88	; 136
    5abe:	1b 4f       	sbci	r17, 0xFB	; 251
    5ac0:	a7 01       	movw	r20, r14
    5ac2:	96 01       	movw	r18, r12
    5ac4:	c7 01       	movw	r24, r14
    5ac6:	b6 01       	movw	r22, r12
    5ac8:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    5acc:	f8 01       	movw	r30, r16
    5ace:	62 8f       	std	Z+26, r22	; 0x1a
    5ad0:	73 8f       	std	Z+27, r23	; 0x1b
    5ad2:	84 8f       	std	Z+28, r24	; 0x1c
    5ad4:	95 8f       	std	Z+29, r25	; 0x1d
    5ad6:	86 e3       	ldi	r24, 0x36	; 54
    5ad8:	8a 9d       	mul	r24, r10
    5ada:	f0 01       	movw	r30, r0
    5adc:	8b 9d       	mul	r24, r11
    5ade:	f0 0d       	add	r31, r0
    5ae0:	11 24       	eor	r1, r1
    5ae2:	e8 58       	subi	r30, 0x88	; 136
    5ae4:	fb 4f       	sbci	r31, 0xFB	; 251
    5ae6:	46 a0       	ldd	r4, Z+38	; 0x26
    5ae8:	57 a0       	ldd	r5, Z+39	; 0x27
    5aea:	60 a4       	ldd	r6, Z+40	; 0x28
    5aec:	71 a4       	ldd	r7, Z+41	; 0x29
    5aee:	a3 01       	movw	r20, r6
    5af0:	92 01       	movw	r18, r4
    5af2:	62 8d       	ldd	r22, Z+26	; 0x1a
    5af4:	73 8d       	ldd	r23, Z+27	; 0x1b
    5af6:	84 8d       	ldd	r24, Z+28	; 0x1c
    5af8:	95 8d       	ldd	r25, Z+29	; 0x1d
    5afa:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    5afe:	18 16       	cp	r1, r24
    5b00:	64 f4       	brge	.+24     	; 0x5b1a <plan_buffer_line+0x542>
    5b02:	86 e3       	ldi	r24, 0x36	; 54
    5b04:	8a 9d       	mul	r24, r10
    5b06:	f0 01       	movw	r30, r0
    5b08:	8b 9d       	mul	r24, r11
    5b0a:	f0 0d       	add	r31, r0
    5b0c:	11 24       	eor	r1, r1
    5b0e:	e8 58       	subi	r30, 0x88	; 136
    5b10:	fb 4f       	sbci	r31, 0xFB	; 251
    5b12:	42 8e       	std	Z+26, r4	; 0x1a
    5b14:	53 8e       	std	Z+27, r5	; 0x1b
    5b16:	64 8e       	std	Z+28, r6	; 0x1c
    5b18:	75 8e       	std	Z+29, r7	; 0x1d
    5b1a:	c0 92 70 04 	sts	0x0470, r12	; 0x800470 <pl+0x18>
    5b1e:	d0 92 71 04 	sts	0x0471, r13	; 0x800471 <pl+0x19>
    5b22:	e0 92 72 04 	sts	0x0472, r14	; 0x800472 <pl+0x1a>
    5b26:	f0 92 73 04 	sts	0x0473, r15	; 0x800473 <pl+0x1b>
    5b2a:	8c e0       	ldi	r24, 0x0C	; 12
    5b2c:	fe 01       	movw	r30, r28
    5b2e:	79 96       	adiw	r30, 0x19	; 25
    5b30:	a4 e6       	ldi	r26, 0x64	; 100
    5b32:	b4 e0       	ldi	r27, 0x04	; 4
    5b34:	01 90       	ld	r0, Z+
    5b36:	0d 92       	st	X+, r0
    5b38:	8a 95       	dec	r24
    5b3a:	e1 f7       	brne	.-8      	; 0x5b34 <plan_buffer_line+0x55c>
    5b3c:	8c e0       	ldi	r24, 0x0C	; 12
    5b3e:	fe 01       	movw	r30, r28
    5b40:	31 96       	adiw	r30, 0x01	; 1
    5b42:	a8 e5       	ldi	r26, 0x58	; 88
    5b44:	b4 e0       	ldi	r27, 0x04	; 4
    5b46:	01 90       	ld	r0, Z+
    5b48:	0d 92       	st	X+, r0
    5b4a:	8a 95       	dec	r24
    5b4c:	e1 f7       	brne	.-8      	; 0x5b46 <plan_buffer_line+0x56e>
    5b4e:	80 91 75 04 	lds	r24, 0x0475	; 0x800475 <next_buffer_head>
    5b52:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <block_buffer_head>
    5b56:	8f 5f       	subi	r24, 0xFF	; 255
    5b58:	84 32       	cpi	r24, 0x24	; 36
    5b5a:	09 f4       	brne	.+2      	; 0x5b5e <plan_buffer_line+0x586>
    5b5c:	80 e0       	ldi	r24, 0x00	; 0
    5b5e:	80 93 75 04 	sts	0x0475, r24	; 0x800475 <next_buffer_head>
    5b62:	3d da       	rcall	.-2950   	; 0x4fde <planner_recalculate>
    5b64:	81 e0       	ldi	r24, 0x01	; 1
    5b66:	39 c0       	rjmp	.+114    	; 0x5bda <plan_buffer_line+0x602>
    5b68:	80 e0       	ldi	r24, 0x00	; 0
    5b6a:	37 c0       	rjmp	.+110    	; 0x5bda <plan_buffer_line+0x602>
    5b6c:	81 e0       	ldi	r24, 0x01	; 1
    5b6e:	35 c0       	rjmp	.+106    	; 0x5bda <plan_buffer_line+0x602>
    5b70:	89 af       	std	Y+57, r24	; 0x39
    5b72:	9a af       	std	Y+58, r25	; 0x3a
    5b74:	20 ed       	ldi	r18, 0xD0	; 208
    5b76:	3e e0       	ldi	r19, 0x0E	; 14
    5b78:	3c af       	std	Y+60, r19	; 0x3c
    5b7a:	2b af       	std	Y+59, r18	; 0x3b
    5b7c:	ae 01       	movw	r20, r28
    5b7e:	4f 5f       	subi	r20, 0xFF	; 255
    5b80:	5f 4f       	sbci	r21, 0xFF	; 255
    5b82:	4a 01       	movw	r8, r20
    5b84:	6e 01       	movw	r12, r28
    5b86:	5d e0       	ldi	r21, 0x0D	; 13
    5b88:	c5 0e       	add	r12, r21
    5b8a:	d1 1c       	adc	r13, r1
    5b8c:	66 e3       	ldi	r22, 0x36	; 54
    5b8e:	26 9e       	mul	r2, r22
    5b90:	c0 01       	movw	r24, r0
    5b92:	11 24       	eor	r1, r1
    5b94:	fc 01       	movw	r30, r24
    5b96:	e8 58       	subi	r30, 0x88	; 136
    5b98:	fb 4f       	sbci	r31, 0xFB	; 251
    5b9a:	1f 01       	movw	r2, r30
    5b9c:	9e 01       	movw	r18, r28
    5b9e:	27 5e       	subi	r18, 0xE7	; 231
    5ba0:	3f 4f       	sbci	r19, 0xFF	; 255
    5ba2:	25 96       	adiw	r28, 0x05	; 5
    5ba4:	3f af       	std	Y+63, r19	; 0x3f
    5ba6:	2e af       	std	Y+62, r18	; 0x3e
    5ba8:	25 97       	sbiw	r28, 0x05	; 5
    5baa:	3e af       	std	Y+62, r19	; 0x3e
    5bac:	2d af       	std	Y+61, r18	; 0x3d
    5bae:	10 e0       	ldi	r17, 0x00	; 0
    5bb0:	26 e3       	ldi	r18, 0x36	; 54
    5bb2:	2a 9d       	mul	r18, r10
    5bb4:	c0 01       	movw	r24, r0
    5bb6:	2b 9d       	mul	r18, r11
    5bb8:	90 0d       	add	r25, r0
    5bba:	11 24       	eor	r1, r1
    5bbc:	88 58       	subi	r24, 0x88	; 136
    5bbe:	9b 4f       	sbci	r25, 0xFB	; 251
    5bc0:	7c 01       	movw	r14, r24
    5bc2:	3c e0       	ldi	r19, 0x0C	; 12
    5bc4:	e3 0e       	add	r14, r19
    5bc6:	f1 1c       	adc	r15, r1
    5bc8:	ac 01       	movw	r20, r24
    5bca:	40 5f       	subi	r20, 0xF0	; 240
    5bcc:	5f 4f       	sbci	r21, 0xFF	; 255
    5bce:	27 96       	adiw	r28, 0x07	; 7
    5bd0:	5f af       	std	Y+63, r21	; 0x3f
    5bd2:	4e af       	std	Y+62, r20	; 0x3e
    5bd4:	27 97       	sbiw	r28, 0x07	; 7
    5bd6:	19 ab       	std	Y+49, r17	; 0x31
    5bd8:	70 cd       	rjmp	.-1312   	; 0x56ba <plan_buffer_line+0xe2>
    5bda:	ca 5b       	subi	r28, 0xBA	; 186
    5bdc:	df 4f       	sbci	r29, 0xFF	; 255
    5bde:	0f b6       	in	r0, 0x3f	; 63
    5be0:	f8 94       	cli
    5be2:	de bf       	out	0x3e, r29	; 62
    5be4:	0f be       	out	0x3f, r0	; 63
    5be6:	cd bf       	out	0x3d, r28	; 61
    5be8:	df 91       	pop	r29
    5bea:	cf 91       	pop	r28
    5bec:	1f 91       	pop	r17
    5bee:	0f 91       	pop	r16
    5bf0:	ff 90       	pop	r15
    5bf2:	ef 90       	pop	r14
    5bf4:	df 90       	pop	r13
    5bf6:	cf 90       	pop	r12
    5bf8:	bf 90       	pop	r11
    5bfa:	af 90       	pop	r10
    5bfc:	9f 90       	pop	r9
    5bfe:	8f 90       	pop	r8
    5c00:	7f 90       	pop	r7
    5c02:	6f 90       	pop	r6
    5c04:	5f 90       	pop	r5
    5c06:	4f 90       	pop	r4
    5c08:	3f 90       	pop	r3
    5c0a:	2f 90       	pop	r2
    5c0c:	08 95       	ret

00005c0e <plan_sync_position>:
    5c0e:	e3 e4       	ldi	r30, 0x43	; 67
    5c10:	fc e0       	ldi	r31, 0x0C	; 12
    5c12:	a8 e5       	ldi	r26, 0x58	; 88
    5c14:	b4 e0       	ldi	r27, 0x04	; 4
    5c16:	8f e4       	ldi	r24, 0x4F	; 79
    5c18:	9c e0       	ldi	r25, 0x0C	; 12
    5c1a:	41 91       	ld	r20, Z+
    5c1c:	51 91       	ld	r21, Z+
    5c1e:	61 91       	ld	r22, Z+
    5c20:	71 91       	ld	r23, Z+
    5c22:	4d 93       	st	X+, r20
    5c24:	5d 93       	st	X+, r21
    5c26:	6d 93       	st	X+, r22
    5c28:	7d 93       	st	X+, r23
    5c2a:	e8 17       	cp	r30, r24
    5c2c:	f9 07       	cpc	r31, r25
    5c2e:	a9 f7       	brne	.-22     	; 0x5c1a <plan_sync_position+0xc>
    5c30:	08 95       	ret

00005c32 <plan_get_block_buffer_available>:
    5c32:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <block_buffer_head>
    5c36:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    5c3a:	98 17       	cp	r25, r24
    5c3c:	18 f0       	brcs	.+6      	; 0x5c44 <plan_get_block_buffer_available+0x12>
    5c3e:	8d 5d       	subi	r24, 0xDD	; 221
    5c40:	89 1b       	sub	r24, r25
    5c42:	08 95       	ret
    5c44:	81 50       	subi	r24, 0x01	; 1
    5c46:	89 1b       	sub	r24, r25
    5c48:	08 95       	ret

00005c4a <plan_cycle_reinitialize>:
// Re-initialize buffer plan with a partially completed block, assumed to exist at the buffer tail.
// Called after a steppers have come to a complete stop for a feed hold and the cycle is stopped.
void plan_cycle_reinitialize()
{
  // Re-plan from a complete stop. Reset planner entry speeds and buffer planned pointer.
  st_update_plan_block_parameters();
    5c4a:	0e 94 2c 1c 	call	0x3858	; 0x3858 <st_update_plan_block_parameters>
  block_buffer_planned = block_buffer_tail;
    5c4e:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    5c52:	80 93 74 04 	sts	0x0474, r24	; 0x800474 <block_buffer_planned>
  planner_recalculate();
    5c56:	c3 c9       	rjmp	.-3194   	; 0x4fde <planner_recalculate>
    5c58:	08 95       	ret

00005c5a <read_float>:
// Delays variable defined microseconds. Compiler compatibility fix for _delay_us(),
// which only accepts constants in future compiler releases. Written to perform more
// efficiently with larger delays, as the counter adds parasitic time in each iteration.
void delay_us(uint32_t us)
{
  while (us) {
    5c5a:	4f 92       	push	r4
    5c5c:	5f 92       	push	r5
    5c5e:	6f 92       	push	r6
    5c60:	7f 92       	push	r7
    5c62:	8f 92       	push	r8
    5c64:	9f 92       	push	r9
    5c66:	af 92       	push	r10
    5c68:	bf 92       	push	r11
    5c6a:	cf 92       	push	r12
    5c6c:	df 92       	push	r13
    5c6e:	ef 92       	push	r14
    5c70:	ff 92       	push	r15
    5c72:	0f 93       	push	r16
    5c74:	1f 93       	push	r17
    5c76:	cf 93       	push	r28
    5c78:	df 93       	push	r29
    5c7a:	dc 01       	movw	r26, r24
    5c7c:	fb 01       	movw	r30, r22
    5c7e:	c0 81       	ld	r28, Z
    5c80:	d0 e0       	ldi	r29, 0x00	; 0
    5c82:	fc 01       	movw	r30, r24
    5c84:	ec 0f       	add	r30, r28
    5c86:	fd 1f       	adc	r31, r29
    5c88:	90 81       	ld	r25, Z
    5c8a:	9d 32       	cpi	r25, 0x2D	; 45
    5c8c:	29 f4       	brne	.+10     	; 0x5c98 <read_float+0x3e>
    5c8e:	ef 01       	movw	r28, r30
    5c90:	22 96       	adiw	r28, 0x02	; 2
    5c92:	91 81       	ldd	r25, Z+1	; 0x01
    5c94:	01 e0       	ldi	r16, 0x01	; 1
    5c96:	0b c0       	rjmp	.+22     	; 0x5cae <read_float+0x54>
    5c98:	9b 32       	cpi	r25, 0x2B	; 43
    5c9a:	29 f0       	breq	.+10     	; 0x5ca6 <read_float+0x4c>
    5c9c:	21 96       	adiw	r28, 0x01	; 1
    5c9e:	ca 0f       	add	r28, r26
    5ca0:	db 1f       	adc	r29, r27
    5ca2:	00 e0       	ldi	r16, 0x00	; 0
    5ca4:	04 c0       	rjmp	.+8      	; 0x5cae <read_float+0x54>
    5ca6:	ef 01       	movw	r28, r30
    5ca8:	22 96       	adiw	r28, 0x02	; 2
    5caa:	91 81       	ldd	r25, Z+1	; 0x01
    5cac:	00 e0       	ldi	r16, 0x00	; 0
    5cae:	80 e0       	ldi	r24, 0x00	; 0
    5cb0:	20 e0       	ldi	r18, 0x00	; 0
    5cb2:	10 e0       	ldi	r17, 0x00	; 0
    5cb4:	41 2c       	mov	r4, r1
    5cb6:	51 2c       	mov	r5, r1
    5cb8:	32 01       	movw	r6, r4
    5cba:	31 e0       	ldi	r19, 0x01	; 1
    5cbc:	fe 01       	movw	r30, r28
    5cbe:	90 53       	subi	r25, 0x30	; 48
    5cc0:	9a 30       	cpi	r25, 0x0A	; 10
    5cc2:	10 f5       	brcc	.+68     	; 0x5d08 <read_float+0xae>
    5cc4:	2f 5f       	subi	r18, 0xFF	; 255
    5cc6:	29 30       	cpi	r18, 0x09	; 9
    5cc8:	d8 f4       	brcc	.+54     	; 0x5d00 <read_float+0xa6>
    5cca:	81 11       	cpse	r24, r1
    5ccc:	11 50       	subi	r17, 0x01	; 1
    5cce:	53 01       	movw	r10, r6
    5cd0:	42 01       	movw	r8, r4
    5cd2:	88 0c       	add	r8, r8
    5cd4:	99 1c       	adc	r9, r9
    5cd6:	aa 1c       	adc	r10, r10
    5cd8:	bb 1c       	adc	r11, r11
    5cda:	88 0c       	add	r8, r8
    5cdc:	99 1c       	adc	r9, r9
    5cde:	aa 1c       	adc	r10, r10
    5ce0:	bb 1c       	adc	r11, r11
    5ce2:	84 0c       	add	r8, r4
    5ce4:	95 1c       	adc	r9, r5
    5ce6:	a6 1c       	adc	r10, r6
    5ce8:	b7 1c       	adc	r11, r7
    5cea:	88 0c       	add	r8, r8
    5cec:	99 1c       	adc	r9, r9
    5cee:	aa 1c       	adc	r10, r10
    5cf0:	bb 1c       	adc	r11, r11
    5cf2:	24 01       	movw	r4, r8
    5cf4:	35 01       	movw	r6, r10
    5cf6:	49 0e       	add	r4, r25
    5cf8:	51 1c       	adc	r5, r1
    5cfa:	61 1c       	adc	r6, r1
    5cfc:	71 1c       	adc	r7, r1
    5cfe:	09 c0       	rjmp	.+18     	; 0x5d12 <read_float+0xb8>
    5d00:	81 11       	cpse	r24, r1
    5d02:	07 c0       	rjmp	.+14     	; 0x5d12 <read_float+0xb8>
    5d04:	1f 5f       	subi	r17, 0xFF	; 255
    5d06:	05 c0       	rjmp	.+10     	; 0x5d12 <read_float+0xb8>
    5d08:	9e 3f       	cpi	r25, 0xFE	; 254
    5d0a:	31 f4       	brne	.+12     	; 0x5d18 <read_float+0xbe>
    5d0c:	81 11       	cpse	r24, r1
    5d0e:	04 c0       	rjmp	.+8      	; 0x5d18 <read_float+0xbe>
    5d10:	83 2f       	mov	r24, r19
    5d12:	90 81       	ld	r25, Z
    5d14:	21 96       	adiw	r28, 0x01	; 1
    5d16:	d2 cf       	rjmp	.-92     	; 0x5cbc <read_float+0x62>
    5d18:	22 23       	and	r18, r18
    5d1a:	09 f4       	brne	.+2      	; 0x5d1e <read_float+0xc4>
    5d1c:	52 c0       	rjmp	.+164    	; 0x5dc2 <read_float+0x168>
    5d1e:	6a 01       	movw	r12, r20
    5d20:	7b 01       	movw	r14, r22
    5d22:	5d 01       	movw	r10, r26
    5d24:	c3 01       	movw	r24, r6
    5d26:	b2 01       	movw	r22, r4
    5d28:	0e 94 09 40 	call	0x8012	; 0x8012 <__floatunsisf>
    5d2c:	2b 01       	movw	r4, r22
    5d2e:	3c 01       	movw	r6, r24
    5d30:	20 e0       	ldi	r18, 0x00	; 0
    5d32:	30 e0       	ldi	r19, 0x00	; 0
    5d34:	a9 01       	movw	r20, r18
    5d36:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    5d3a:	88 23       	and	r24, r24
    5d3c:	51 f1       	breq	.+84     	; 0x5d92 <read_float+0x138>
    5d3e:	1f 3f       	cpi	r17, 0xFF	; 255
    5d40:	6c f4       	brge	.+26     	; 0x5d5c <read_float+0x102>
    5d42:	2a e0       	ldi	r18, 0x0A	; 10
    5d44:	37 ed       	ldi	r19, 0xD7	; 215
    5d46:	43 e2       	ldi	r20, 0x23	; 35
    5d48:	5c e3       	ldi	r21, 0x3C	; 60
    5d4a:	c3 01       	movw	r24, r6
    5d4c:	b2 01       	movw	r22, r4
    5d4e:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    5d52:	2b 01       	movw	r4, r22
    5d54:	3c 01       	movw	r6, r24
    5d56:	1e 5f       	subi	r17, 0xFE	; 254
    5d58:	1f 3f       	cpi	r17, 0xFF	; 255
    5d5a:	9c f3       	brlt	.-26     	; 0x5d42 <read_float+0xe8>
    5d5c:	11 23       	and	r17, r17
    5d5e:	5c f4       	brge	.+22     	; 0x5d76 <read_float+0x11c>
    5d60:	2d ec       	ldi	r18, 0xCD	; 205
    5d62:	3c ec       	ldi	r19, 0xCC	; 204
    5d64:	4c ec       	ldi	r20, 0xCC	; 204
    5d66:	5d e3       	ldi	r21, 0x3D	; 61
    5d68:	c3 01       	movw	r24, r6
    5d6a:	b2 01       	movw	r22, r4
    5d6c:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    5d70:	2b 01       	movw	r4, r22
    5d72:	3c 01       	movw	r6, r24
    5d74:	0e c0       	rjmp	.+28     	; 0x5d92 <read_float+0x138>
    5d76:	11 16       	cp	r1, r17
    5d78:	64 f4       	brge	.+24     	; 0x5d92 <read_float+0x138>
    5d7a:	20 e0       	ldi	r18, 0x00	; 0
    5d7c:	30 e0       	ldi	r19, 0x00	; 0
    5d7e:	40 e2       	ldi	r20, 0x20	; 32
    5d80:	51 e4       	ldi	r21, 0x41	; 65
    5d82:	c3 01       	movw	r24, r6
    5d84:	b2 01       	movw	r22, r4
    5d86:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    5d8a:	2b 01       	movw	r4, r22
    5d8c:	3c 01       	movw	r6, r24
    5d8e:	11 50       	subi	r17, 0x01	; 1
    5d90:	a1 f7       	brne	.-24     	; 0x5d7a <read_float+0x120>
    5d92:	00 23       	and	r16, r16
    5d94:	51 f0       	breq	.+20     	; 0x5daa <read_float+0x150>
    5d96:	77 fa       	bst	r7, 7
    5d98:	70 94       	com	r7
    5d9a:	77 f8       	bld	r7, 7
    5d9c:	70 94       	com	r7
    5d9e:	f6 01       	movw	r30, r12
    5da0:	40 82       	st	Z, r4
    5da2:	51 82       	std	Z+1, r5	; 0x01
    5da4:	62 82       	std	Z+2, r6	; 0x02
    5da6:	73 82       	std	Z+3, r7	; 0x03
    5da8:	05 c0       	rjmp	.+10     	; 0x5db4 <read_float+0x15a>
    5daa:	f6 01       	movw	r30, r12
    5dac:	40 82       	st	Z, r4
    5dae:	51 82       	std	Z+1, r5	; 0x01
    5db0:	62 82       	std	Z+2, r6	; 0x02
    5db2:	73 82       	std	Z+3, r7	; 0x03
    5db4:	ca 19       	sub	r28, r10
    5db6:	db 09       	sbc	r29, r11
    5db8:	c1 50       	subi	r28, 0x01	; 1
    5dba:	f7 01       	movw	r30, r14
    5dbc:	c0 83       	st	Z, r28
    5dbe:	81 e0       	ldi	r24, 0x01	; 1
    5dc0:	01 c0       	rjmp	.+2      	; 0x5dc4 <read_float+0x16a>
    5dc2:	80 e0       	ldi	r24, 0x00	; 0
    5dc4:	df 91       	pop	r29
    5dc6:	cf 91       	pop	r28
    5dc8:	1f 91       	pop	r17
    5dca:	0f 91       	pop	r16
    5dcc:	ff 90       	pop	r15
    5dce:	ef 90       	pop	r14
    5dd0:	df 90       	pop	r13
    5dd2:	cf 90       	pop	r12
    5dd4:	bf 90       	pop	r11
    5dd6:	af 90       	pop	r10
    5dd8:	9f 90       	pop	r9
    5dda:	8f 90       	pop	r8
    5ddc:	7f 90       	pop	r7
    5dde:	6f 90       	pop	r6
    5de0:	5f 90       	pop	r5
    5de2:	4f 90       	pop	r4
    5de4:	08 95       	ret

00005de6 <delay_sec>:
    5de6:	ff 92       	push	r15
    5de8:	0f 93       	push	r16
    5dea:	1f 93       	push	r17
    5dec:	cf 93       	push	r28
    5dee:	df 93       	push	r29
    5df0:	f4 2e       	mov	r15, r20
    5df2:	20 e0       	ldi	r18, 0x00	; 0
    5df4:	30 e0       	ldi	r19, 0x00	; 0
    5df6:	40 ea       	ldi	r20, 0xA0	; 160
    5df8:	51 e4       	ldi	r21, 0x41	; 65
    5dfa:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    5dfe:	0e 94 56 3f 	call	0x7eac	; 0x7eac <ceil>
    5e02:	0e 94 dd 3f 	call	0x7fba	; 0x7fba <__fixunssfsi>
    5e06:	61 15       	cp	r22, r1
    5e08:	71 05       	cpc	r23, r1
    5e0a:	21 f1       	breq	.+72     	; 0x5e54 <delay_sec+0x6e>
    5e0c:	20 91 1f 0c 	lds	r18, 0x0C1F	; 0x800c1f <sys+0x1>
    5e10:	21 11       	cpse	r18, r1
    5e12:	20 c0       	rjmp	.+64     	; 0x5e54 <delay_sec+0x6e>
    5e14:	eb 01       	movw	r28, r22
    5e16:	0e e1       	ldi	r16, 0x1E	; 30
    5e18:	1c e0       	ldi	r17, 0x0C	; 12
    5e1a:	05 c0       	rjmp	.+10     	; 0x5e26 <delay_sec+0x40>
    5e1c:	21 97       	sbiw	r28, 0x01	; 1
    5e1e:	f8 01       	movw	r30, r16
    5e20:	81 81       	ldd	r24, Z+1	; 0x01
    5e22:	81 11       	cpse	r24, r1
    5e24:	17 c0       	rjmp	.+46     	; 0x5e54 <delay_sec+0x6e>
    5e26:	f1 10       	cpse	r15, r1
    5e28:	03 c0       	rjmp	.+6      	; 0x5e30 <delay_sec+0x4a>
    5e2a:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <protocol_execute_realtime>
    5e2e:	06 c0       	rjmp	.+12     	; 0x5e3c <delay_sec+0x56>
    5e30:	0e 94 33 15 	call	0x2a66	; 0x2a66 <protocol_exec_rt_system>
    5e34:	f8 01       	movw	r30, r16
    5e36:	82 81       	ldd	r24, Z+2	; 0x02
    5e38:	81 fd       	sbrc	r24, 1
    5e3a:	0c c0       	rjmp	.+24     	; 0x5e54 <delay_sec+0x6e>
    5e3c:	ff ef       	ldi	r31, 0xFF	; 255
    5e3e:	20 e7       	ldi	r18, 0x70	; 112
    5e40:	82 e0       	ldi	r24, 0x02	; 2
    5e42:	f1 50       	subi	r31, 0x01	; 1
    5e44:	20 40       	sbci	r18, 0x00	; 0
    5e46:	80 40       	sbci	r24, 0x00	; 0
    5e48:	e1 f7       	brne	.-8      	; 0x5e42 <delay_sec+0x5c>
    5e4a:	00 c0       	rjmp	.+0      	; 0x5e4c <delay_sec+0x66>
    5e4c:	00 00       	nop
    5e4e:	c1 30       	cpi	r28, 0x01	; 1
    5e50:	d1 05       	cpc	r29, r1
    5e52:	21 f7       	brne	.-56     	; 0x5e1c <delay_sec+0x36>
    5e54:	df 91       	pop	r29
    5e56:	cf 91       	pop	r28
    5e58:	1f 91       	pop	r17
    5e5a:	0f 91       	pop	r16
    5e5c:	ff 90       	pop	r15
    5e5e:	08 95       	ret

00005e60 <delay_ms>:
    5e60:	00 97       	sbiw	r24, 0x00	; 0
    5e62:	41 f0       	breq	.+16     	; 0x5e74 <delay_ms+0x14>
    5e64:	ef e9       	ldi	r30, 0x9F	; 159
    5e66:	ff e0       	ldi	r31, 0x0F	; 15
    5e68:	31 97       	sbiw	r30, 0x01	; 1
    5e6a:	f1 f7       	brne	.-4      	; 0x5e68 <delay_ms+0x8>
    5e6c:	00 c0       	rjmp	.+0      	; 0x5e6e <delay_ms+0xe>
    5e6e:	00 00       	nop
    5e70:	01 97       	sbiw	r24, 0x01	; 1
    5e72:	c1 f7       	brne	.-16     	; 0x5e64 <delay_ms+0x4>
    5e74:	08 95       	ret

00005e76 <hypot_f>:
  }
}


// Simple hypotenuse computation function.
float hypot_f(float x, float y) { return(sqrt(x*x + y*y)); }
    5e76:	4f 92       	push	r4
    5e78:	5f 92       	push	r5
    5e7a:	6f 92       	push	r6
    5e7c:	7f 92       	push	r7
    5e7e:	8f 92       	push	r8
    5e80:	9f 92       	push	r9
    5e82:	af 92       	push	r10
    5e84:	bf 92       	push	r11
    5e86:	cf 92       	push	r12
    5e88:	df 92       	push	r13
    5e8a:	ef 92       	push	r14
    5e8c:	ff 92       	push	r15
    5e8e:	4b 01       	movw	r8, r22
    5e90:	5c 01       	movw	r10, r24
    5e92:	69 01       	movw	r12, r18
    5e94:	7a 01       	movw	r14, r20
    5e96:	a5 01       	movw	r20, r10
    5e98:	94 01       	movw	r18, r8
    5e9a:	c5 01       	movw	r24, r10
    5e9c:	b4 01       	movw	r22, r8
    5e9e:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    5ea2:	4b 01       	movw	r8, r22
    5ea4:	5c 01       	movw	r10, r24
    5ea6:	a7 01       	movw	r20, r14
    5ea8:	96 01       	movw	r18, r12
    5eaa:	c7 01       	movw	r24, r14
    5eac:	b6 01       	movw	r22, r12
    5eae:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    5eb2:	9b 01       	movw	r18, r22
    5eb4:	ac 01       	movw	r20, r24
    5eb6:	c5 01       	movw	r24, r10
    5eb8:	b4 01       	movw	r22, r8
    5eba:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    5ebe:	0e 94 34 42 	call	0x8468	; 0x8468 <sqrt>
    5ec2:	ff 90       	pop	r15
    5ec4:	ef 90       	pop	r14
    5ec6:	df 90       	pop	r13
    5ec8:	cf 90       	pop	r12
    5eca:	bf 90       	pop	r11
    5ecc:	af 90       	pop	r10
    5ece:	9f 90       	pop	r9
    5ed0:	8f 90       	pop	r8
    5ed2:	7f 90       	pop	r7
    5ed4:	6f 90       	pop	r6
    5ed6:	5f 90       	pop	r5
    5ed8:	4f 90       	pop	r4
    5eda:	08 95       	ret

00005edc <convert_delta_vector_to_unit_vector>:


float convert_delta_vector_to_unit_vector(float *vector)
{
    5edc:	4f 92       	push	r4
    5ede:	5f 92       	push	r5
    5ee0:	6f 92       	push	r6
    5ee2:	7f 92       	push	r7
    5ee4:	af 92       	push	r10
    5ee6:	bf 92       	push	r11
    5ee8:	cf 92       	push	r12
    5eea:	df 92       	push	r13
    5eec:	ef 92       	push	r14
    5eee:	ff 92       	push	r15
    5ef0:	0f 93       	push	r16
    5ef2:	1f 93       	push	r17
    5ef4:	cf 93       	push	r28
    5ef6:	df 93       	push	r29
    5ef8:	ec 01       	movw	r28, r24
    5efa:	5c 01       	movw	r10, r24
    5efc:	8c e0       	ldi	r24, 0x0C	; 12
    5efe:	a8 0e       	add	r10, r24
    5f00:	b1 1c       	adc	r11, r1
    5f02:	8e 01       	movw	r16, r28
  uint8_t idx;
  float magnitude = 0.0;
    5f04:	41 2c       	mov	r4, r1
    5f06:	51 2c       	mov	r5, r1
    5f08:	32 01       	movw	r6, r4
  for (idx=0; idx<N_AXIS; idx++) {
    if (vector[idx] != 0.0) {
    5f0a:	f8 01       	movw	r30, r16
    5f0c:	c1 90       	ld	r12, Z+
    5f0e:	d1 90       	ld	r13, Z+
    5f10:	e1 90       	ld	r14, Z+
    5f12:	f1 90       	ld	r15, Z+
    5f14:	8f 01       	movw	r16, r30
    5f16:	20 e0       	ldi	r18, 0x00	; 0
    5f18:	30 e0       	ldi	r19, 0x00	; 0
    5f1a:	a9 01       	movw	r20, r18
    5f1c:	c7 01       	movw	r24, r14
    5f1e:	b6 01       	movw	r22, r12
    5f20:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    5f24:	88 23       	and	r24, r24
    5f26:	71 f0       	breq	.+28     	; 0x5f44 <convert_delta_vector_to_unit_vector+0x68>
      magnitude += vector[idx]*vector[idx];
    5f28:	a7 01       	movw	r20, r14
    5f2a:	96 01       	movw	r18, r12
    5f2c:	c7 01       	movw	r24, r14
    5f2e:	b6 01       	movw	r22, r12
    5f30:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    5f34:	9b 01       	movw	r18, r22
    5f36:	ac 01       	movw	r20, r24
    5f38:	c3 01       	movw	r24, r6
    5f3a:	b2 01       	movw	r22, r4
    5f3c:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    5f40:	2b 01       	movw	r4, r22
    5f42:	3c 01       	movw	r6, r24

float convert_delta_vector_to_unit_vector(float *vector)
{
  uint8_t idx;
  float magnitude = 0.0;
  for (idx=0; idx<N_AXIS; idx++) {
    5f44:	0a 15       	cp	r16, r10
    5f46:	1b 05       	cpc	r17, r11
    5f48:	01 f7       	brne	.-64     	; 0x5f0a <convert_delta_vector_to_unit_vector+0x2e>
    if (vector[idx] != 0.0) {
      magnitude += vector[idx]*vector[idx];
    }
  }
  magnitude = sqrt(magnitude);
    5f4a:	c3 01       	movw	r24, r6
    5f4c:	b2 01       	movw	r22, r4
    5f4e:	0e 94 34 42 	call	0x8468	; 0x8468 <sqrt>
    5f52:	2b 01       	movw	r4, r22
    5f54:	3c 01       	movw	r6, r24
  float inv_magnitude = 1.0/magnitude;
    5f56:	9b 01       	movw	r18, r22
    5f58:	ac 01       	movw	r20, r24
    5f5a:	60 e0       	ldi	r22, 0x00	; 0
    5f5c:	70 e0       	ldi	r23, 0x00	; 0
    5f5e:	80 e8       	ldi	r24, 0x80	; 128
    5f60:	9f e3       	ldi	r25, 0x3F	; 63
    5f62:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <__divsf3>
    5f66:	6b 01       	movw	r12, r22
    5f68:	7c 01       	movw	r14, r24
  for (idx=0; idx<N_AXIS; idx++) { vector[idx] *= inv_magnitude; }
    5f6a:	a7 01       	movw	r20, r14
    5f6c:	96 01       	movw	r18, r12
    5f6e:	68 81       	ld	r22, Y
    5f70:	79 81       	ldd	r23, Y+1	; 0x01
    5f72:	8a 81       	ldd	r24, Y+2	; 0x02
    5f74:	9b 81       	ldd	r25, Y+3	; 0x03
    5f76:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    5f7a:	69 93       	st	Y+, r22
    5f7c:	79 93       	st	Y+, r23
    5f7e:	89 93       	st	Y+, r24
    5f80:	99 93       	st	Y+, r25
    5f82:	ca 15       	cp	r28, r10
    5f84:	db 05       	cpc	r29, r11
    5f86:	89 f7       	brne	.-30     	; 0x5f6a <convert_delta_vector_to_unit_vector+0x8e>
  return(magnitude);
}
    5f88:	c3 01       	movw	r24, r6
    5f8a:	b2 01       	movw	r22, r4
    5f8c:	df 91       	pop	r29
    5f8e:	cf 91       	pop	r28
    5f90:	1f 91       	pop	r17
    5f92:	0f 91       	pop	r16
    5f94:	ff 90       	pop	r15
    5f96:	ef 90       	pop	r14
    5f98:	df 90       	pop	r13
    5f9a:	cf 90       	pop	r12
    5f9c:	bf 90       	pop	r11
    5f9e:	af 90       	pop	r10
    5fa0:	7f 90       	pop	r7
    5fa2:	6f 90       	pop	r6
    5fa4:	5f 90       	pop	r5
    5fa6:	4f 90       	pop	r4
    5fa8:	08 95       	ret

00005faa <limit_value_by_axis_maximum>:


float limit_value_by_axis_maximum(float *max_value, float *unit_vec)
{
    5faa:	6f 92       	push	r6
    5fac:	7f 92       	push	r7
    5fae:	8f 92       	push	r8
    5fb0:	9f 92       	push	r9
    5fb2:	af 92       	push	r10
    5fb4:	bf 92       	push	r11
    5fb6:	cf 92       	push	r12
    5fb8:	df 92       	push	r13
    5fba:	ef 92       	push	r14
    5fbc:	ff 92       	push	r15
    5fbe:	0f 93       	push	r16
    5fc0:	1f 93       	push	r17
    5fc2:	cf 93       	push	r28
    5fc4:	df 93       	push	r29
    5fc6:	eb 01       	movw	r28, r22
    5fc8:	8c 01       	movw	r16, r24
    5fca:	7b 01       	movw	r14, r22
    5fcc:	8c e0       	ldi	r24, 0x0C	; 12
    5fce:	e8 0e       	add	r14, r24
    5fd0:	f1 1c       	adc	r15, r1
  uint8_t idx;
  float limit_value = SOME_LARGE_VALUE;
    5fd2:	0f 2e       	mov	r0, r31
    5fd4:	f9 e9       	ldi	r31, 0x99	; 153
    5fd6:	7f 2e       	mov	r7, r31
    5fd8:	f0 2d       	mov	r31, r0
    5fda:	0f 2e       	mov	r0, r31
    5fdc:	f6 e7       	ldi	r31, 0x76	; 118
    5fde:	cf 2e       	mov	r12, r31
    5fe0:	f0 2d       	mov	r31, r0
    5fe2:	0f 2e       	mov	r0, r31
    5fe4:	f6 e9       	ldi	r31, 0x96	; 150
    5fe6:	df 2e       	mov	r13, r31
    5fe8:	f0 2d       	mov	r31, r0
    5fea:	0f 2e       	mov	r0, r31
    5fec:	fe e7       	ldi	r31, 0x7E	; 126
    5fee:	6f 2e       	mov	r6, r31
    5ff0:	f0 2d       	mov	r31, r0
  for (idx=0; idx<N_AXIS; idx++) {
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
    5ff2:	89 90       	ld	r8, Y+
    5ff4:	99 90       	ld	r9, Y+
    5ff6:	a9 90       	ld	r10, Y+
    5ff8:	b9 90       	ld	r11, Y+
    5ffa:	20 e0       	ldi	r18, 0x00	; 0
    5ffc:	30 e0       	ldi	r19, 0x00	; 0
    5ffe:	a9 01       	movw	r20, r18
    6000:	c5 01       	movw	r24, r10
    6002:	b4 01       	movw	r22, r8
    6004:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    6008:	88 23       	and	r24, r24
    600a:	d9 f0       	breq	.+54     	; 0x6042 <limit_value_by_axis_maximum+0x98>
      limit_value = min(limit_value,fabs(max_value[idx]/unit_vec[idx]));
    600c:	a5 01       	movw	r20, r10
    600e:	94 01       	movw	r18, r8
    6010:	f8 01       	movw	r30, r16
    6012:	60 81       	ld	r22, Z
    6014:	71 81       	ldd	r23, Z+1	; 0x01
    6016:	82 81       	ldd	r24, Z+2	; 0x02
    6018:	93 81       	ldd	r25, Z+3	; 0x03
    601a:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <__divsf3>
    601e:	4b 01       	movw	r8, r22
    6020:	5c 01       	movw	r10, r24
    6022:	e8 94       	clt
    6024:	b7 f8       	bld	r11, 7
    6026:	27 2d       	mov	r18, r7
    6028:	3c 2d       	mov	r19, r12
    602a:	4d 2d       	mov	r20, r13
    602c:	56 2d       	mov	r21, r6
    602e:	c5 01       	movw	r24, r10
    6030:	b4 01       	movw	r22, r8
    6032:	0e 94 6c 41 	call	0x82d8	; 0x82d8 <__gesf2>
    6036:	18 16       	cp	r1, r24
    6038:	24 f0       	brlt	.+8      	; 0x6042 <limit_value_by_axis_maximum+0x98>
    603a:	78 2c       	mov	r7, r8
    603c:	c9 2c       	mov	r12, r9
    603e:	da 2c       	mov	r13, r10
    6040:	6b 2c       	mov	r6, r11
    6042:	0c 5f       	subi	r16, 0xFC	; 252
    6044:	1f 4f       	sbci	r17, 0xFF	; 255

float limit_value_by_axis_maximum(float *max_value, float *unit_vec)
{
  uint8_t idx;
  float limit_value = SOME_LARGE_VALUE;
  for (idx=0; idx<N_AXIS; idx++) {
    6046:	ce 15       	cp	r28, r14
    6048:	df 05       	cpc	r29, r15
    604a:	99 f6       	brne	.-90     	; 0x5ff2 <limit_value_by_axis_maximum+0x48>
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
      limit_value = min(limit_value,fabs(max_value[idx]/unit_vec[idx]));
    }
  }
  return(limit_value);
}
    604c:	67 2d       	mov	r22, r7
    604e:	7c 2d       	mov	r23, r12
    6050:	8d 2d       	mov	r24, r13
    6052:	96 2d       	mov	r25, r6
    6054:	df 91       	pop	r29
    6056:	cf 91       	pop	r28
    6058:	1f 91       	pop	r17
    605a:	0f 91       	pop	r16
    605c:	ff 90       	pop	r15
    605e:	ef 90       	pop	r14
    6060:	df 90       	pop	r13
    6062:	cf 90       	pop	r12
    6064:	bf 90       	pop	r11
    6066:	af 90       	pop	r10
    6068:	9f 90       	pop	r9
    606a:	8f 90       	pop	r8
    606c:	7f 90       	pop	r7
    606e:	6f 90       	pop	r6
    6070:	08 95       	ret

00006072 <limits_disable>:
    #ifndef DISABLE_HW_LIMITS
     LIMIT_PCMSK &= ~LIMIT_MASK;  // Disable specific pins of the Pin Change Interrupt
     PCICR &= ~(1 << LIMIT_INT);  // Disable Pin Change Interrupt
    #endif
  #else
    LIMIT_PCMSK &= ~LIMIT_MASK;  // Disable specific pins of the Pin Change Interrupt
    6072:	eb e6       	ldi	r30, 0x6B	; 107
    6074:	f0 e0       	ldi	r31, 0x00	; 0
    6076:	80 81       	ld	r24, Z
    6078:	8f 78       	andi	r24, 0x8F	; 143
    607a:	80 83       	st	Z, r24
    PCICR &= ~(1 << LIMIT_INT);  // Disable Pin Change Interrupt
    607c:	e8 e6       	ldi	r30, 0x68	; 104
    607e:	f0 e0       	ldi	r31, 0x00	; 0
    6080:	80 81       	ld	r24, Z
    6082:	8e 7f       	andi	r24, 0xFE	; 254
    6084:	80 83       	st	Z, r24
    6086:	08 95       	ret

00006088 <limits_init>:
        WDTCSR |= (1<<WDCE) | (1<<WDE);
        WDTCSR = (1<<WDP0); // Set time-out at ~32msec.
      #endif
    #endif // DISABLE_HW_LIMITS
  #else
    LIMIT_DDR &= ~(LIMIT_MASK); // Set as input pins
    6088:	84 b1       	in	r24, 0x04	; 4
    608a:	8f 78       	andi	r24, 0x8F	; 143
    608c:	84 b9       	out	0x04, r24	; 4

    #ifdef DISABLE_LIMIT_PIN_PULL_UP
      LIMIT_PORT &= ~(LIMIT_MASK); // Normal low operation. Requires external pull-down.
    #else
      LIMIT_PORT |= (LIMIT_MASK);  // Enable internal pull-up resistors. Normal high operation.
    608e:	85 b1       	in	r24, 0x05	; 5
    6090:	80 67       	ori	r24, 0x70	; 112
    6092:	85 b9       	out	0x05, r24	; 5
    #endif

    if (bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE)) {
    6094:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    6098:	83 ff       	sbrs	r24, 3
    609a:	0b c0       	rjmp	.+22     	; 0x60b2 <limits_init+0x2a>
      LIMIT_PCMSK |= LIMIT_MASK; // Enable specific pins of the Pin Change Interrupt
    609c:	eb e6       	ldi	r30, 0x6B	; 107
    609e:	f0 e0       	ldi	r31, 0x00	; 0
    60a0:	80 81       	ld	r24, Z
    60a2:	80 67       	ori	r24, 0x70	; 112
    60a4:	80 83       	st	Z, r24
      PCICR |= (1 << LIMIT_INT); // Enable Pin Change Interrupt
    60a6:	e8 e6       	ldi	r30, 0x68	; 104
    60a8:	f0 e0       	ldi	r31, 0x00	; 0
    60aa:	80 81       	ld	r24, Z
    60ac:	81 60       	ori	r24, 0x01	; 1
    60ae:	80 83       	st	Z, r24
    60b0:	01 c0       	rjmp	.+2      	; 0x60b4 <limits_init+0x2c>
    } else {
      limits_disable();
    60b2:	df df       	rcall	.-66     	; 0x6072 <limits_disable>
    }
  
    #ifdef ENABLE_SOFTWARE_DEBOUNCE
      MCUSR &= ~(1<<WDRF);
    60b4:	84 b7       	in	r24, 0x34	; 52
    60b6:	87 7f       	andi	r24, 0xF7	; 247
    60b8:	84 bf       	out	0x34, r24	; 52
      WDTCSR |= (1<<WDCE) | (1<<WDE);
    60ba:	e0 e6       	ldi	r30, 0x60	; 96
    60bc:	f0 e0       	ldi	r31, 0x00	; 0
    60be:	80 81       	ld	r24, Z
    60c0:	88 61       	ori	r24, 0x18	; 24
    60c2:	80 83       	st	Z, r24
      WDTCSR = (1<<WDP0); // Set time-out at ~32msec.
    60c4:	81 e0       	ldi	r24, 0x01	; 1
    60c6:	80 83       	st	Z, r24
    60c8:	08 95       	ret

000060ca <limits_get_state>:

// Returns limit state as a bit-wise uint8 variable. Each bit indicates an axis limit, where 
// triggered is 1 and not triggered is 0. Invert mask is applied. Axes are defined by their
// number in bit position, i.e. Z_AXIS is (1<<2) or bit 2, and Y_AXIS is (1<<1) or bit 1.
uint8_t limits_get_state()
{
    60ca:	ef 92       	push	r14
    60cc:	ff 92       	push	r15
    60ce:	0f 93       	push	r16
    60d0:	1f 93       	push	r17
    60d2:	cf 93       	push	r28
    60d4:	df 93       	push	r29
      if (pin)
        limit_state |= (1 << idx);
    } 
    //return(limit_state);
  #else
    uint8_t pin = (LIMIT_PIN & LIMIT_MASK);
    60d6:	c3 b1       	in	r28, 0x03	; 3
    60d8:	c0 77       	andi	r28, 0x70	; 112
    #ifdef INVERT_LIMIT_PIN_MASK
      pin ^= INVERT_LIMIT_PIN_MASK;
    #endif
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
    60da:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    60de:	86 fd       	sbrc	r24, 6
    60e0:	2b c0       	rjmp	.+86     	; 0x6138 <limits_get_state+0x6e>
    60e2:	80 e7       	ldi	r24, 0x70	; 112
    60e4:	c8 27       	eor	r28, r24
    60e6:	28 c0       	rjmp	.+80     	; 0x6138 <limits_get_state+0x6e>
    if (pin) {  
    60e8:	00 e0       	ldi	r16, 0x00	; 0
    60ea:	10 e0       	ldi	r17, 0x00	; 0
    60ec:	d0 e0       	ldi	r29, 0x00	; 0
      uint8_t idx;
      for (idx=0; idx<N_AXIS; idx++) {
        if (pin & get_limit_pin_mask(idx)) { limit_state |= (1 << idx); }
    60ee:	ee 24       	eor	r14, r14
    60f0:	e3 94       	inc	r14
    60f2:	f1 2c       	mov	r15, r1
    60f4:	80 2f       	mov	r24, r16
    60f6:	0e 94 e5 27 	call	0x4fca	; 0x4fca <get_limit_pin_mask>
    60fa:	8c 23       	and	r24, r28
    60fc:	41 f0       	breq	.+16     	; 0x610e <limits_get_state+0x44>
    60fe:	c7 01       	movw	r24, r14
    6100:	00 2e       	mov	r0, r16
    6102:	02 c0       	rjmp	.+4      	; 0x6108 <limits_get_state+0x3e>
    6104:	88 0f       	add	r24, r24
    6106:	99 1f       	adc	r25, r25
    6108:	0a 94       	dec	r0
    610a:	e2 f7       	brpl	.-8      	; 0x6104 <limits_get_state+0x3a>
    610c:	d8 2b       	or	r29, r24
    610e:	0f 5f       	subi	r16, 0xFF	; 255
    6110:	1f 4f       	sbci	r17, 0xFF	; 255
      pin ^= INVERT_LIMIT_PIN_MASK;
    #endif
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
    if (pin) {  
      uint8_t idx;
      for (idx=0; idx<N_AXIS; idx++) {
    6112:	03 30       	cpi	r16, 0x03	; 3
    6114:	11 05       	cpc	r17, r1
    6116:	71 f7       	brne	.-36     	; 0x60f4 <limits_get_state+0x2a>
    }
    //return(limit_state);
  #endif //DEFAULTS_RAMPS_BOARD
//Ignore Hardware Limit triggers on the Y-Axis (Spindle Index Pulse) when LATHE is defined and not Homing, signal index pulse received when not homing
  #ifdef LATHE
	if (sys.state!=STATE_HOMING) {						//when not homing
    6118:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    611c:	84 30       	cpi	r24, 0x04	; 4
    611e:	81 f0       	breq	.+32     	; 0x6140 <limits_get_state+0x76>
	  limit_state &= ~(1<<Y_AXIS);						//Clear state to avoid limit triggered alarm
    6120:	dd 7f       	andi	r29, 0xFD	; 253
      if (pin & get_limit_pin_mask(Y_AXIS))				//If the limit input is set
    6122:	81 e0       	ldi	r24, 0x01	; 1
    6124:	0e 94 e5 27 	call	0x4fca	; 0x4fca <get_limit_pin_mask>
    6128:	8c 23       	and	r24, r28
    612a:	51 f0       	breq	.+20     	; 0x6140 <limits_get_state+0x76>
	    bit_true(sys_sync_state, EXEC_SPINDLE_INDEX);	//Signal the receive of a spindle index pulse
    612c:	80 91 14 0c 	lds	r24, 0x0C14	; 0x800c14 <sys_sync_state>
    6130:	81 60       	ori	r24, 0x01	; 1
    6132:	80 93 14 0c 	sts	0x0C14, r24	; 0x800c14 <sys_sync_state>
	}
  #endif
  return(limit_state);
    6136:	04 c0       	rjmp	.+8      	; 0x6140 <limits_get_state+0x76>
    uint8_t pin = (LIMIT_PIN & LIMIT_MASK);
    #ifdef INVERT_LIMIT_PIN_MASK
      pin ^= INVERT_LIMIT_PIN_MASK;
    #endif
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
    if (pin) {  
    6138:	c1 11       	cpse	r28, r1
    613a:	d6 cf       	rjmp	.-84     	; 0x60e8 <limits_get_state+0x1e>
// Returns limit state as a bit-wise uint8 variable. Each bit indicates an axis limit, where 
// triggered is 1 and not triggered is 0. Invert mask is applied. Axes are defined by their
// number in bit position, i.e. Z_AXIS is (1<<2) or bit 2, and Y_AXIS is (1<<1) or bit 1.
uint8_t limits_get_state()
{
  uint8_t limit_state = 0;
    613c:	d0 e0       	ldi	r29, 0x00	; 0
    613e:	ec cf       	rjmp	.-40     	; 0x6118 <limits_get_state+0x4e>
      if (pin & get_limit_pin_mask(Y_AXIS))				//If the limit input is set
	    bit_true(sys_sync_state, EXEC_SPINDLE_INDEX);	//Signal the receive of a spindle index pulse
	}
  #endif
  return(limit_state);
}
    6140:	8d 2f       	mov	r24, r29
    6142:	df 91       	pop	r29
    6144:	cf 91       	pop	r28
    6146:	1f 91       	pop	r17
    6148:	0f 91       	pop	r16
    614a:	ff 90       	pop	r15
    614c:	ef 90       	pop	r14
    614e:	08 95       	ret

00006150 <__vector_9>:
        }
      }
    }  
  #else // OPTIONAL: Software debounce limit pin routine.
    // Upon limit pin change, enable watchdog timer to create a short delay. 
    ISR(LIMIT_INT_vect) { if (!(WDTCSR & (1<<WDIE))) { WDTCSR |= (1<<WDIE); } }
    6150:	1f 92       	push	r1
    6152:	0f 92       	push	r0
    6154:	0f b6       	in	r0, 0x3f	; 63
    6156:	0f 92       	push	r0
    6158:	11 24       	eor	r1, r1
    615a:	0b b6       	in	r0, 0x3b	; 59
    615c:	0f 92       	push	r0
    615e:	8f 93       	push	r24
    6160:	ef 93       	push	r30
    6162:	ff 93       	push	r31
    6164:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    6168:	86 fd       	sbrc	r24, 6
    616a:	05 c0       	rjmp	.+10     	; 0x6176 <__vector_9+0x26>
    616c:	e0 e6       	ldi	r30, 0x60	; 96
    616e:	f0 e0       	ldi	r31, 0x00	; 0
    6170:	80 81       	ld	r24, Z
    6172:	80 64       	ori	r24, 0x40	; 64
    6174:	80 83       	st	Z, r24
    6176:	ff 91       	pop	r31
    6178:	ef 91       	pop	r30
    617a:	8f 91       	pop	r24
    617c:	0f 90       	pop	r0
    617e:	0b be       	out	0x3b, r0	; 59
    6180:	0f 90       	pop	r0
    6182:	0f be       	out	0x3f, r0	; 63
    6184:	0f 90       	pop	r0
    6186:	1f 90       	pop	r1
    6188:	18 95       	reti

0000618a <__vector_12>:
    ISR(WDT_vect) // Watchdog timer ISR
    {
    618a:	1f 92       	push	r1
    618c:	0f 92       	push	r0
    618e:	0f b6       	in	r0, 0x3f	; 63
    6190:	0f 92       	push	r0
    6192:	11 24       	eor	r1, r1
    6194:	0b b6       	in	r0, 0x3b	; 59
    6196:	0f 92       	push	r0
    6198:	2f 93       	push	r18
    619a:	3f 93       	push	r19
    619c:	4f 93       	push	r20
    619e:	5f 93       	push	r21
    61a0:	6f 93       	push	r22
    61a2:	7f 93       	push	r23
    61a4:	8f 93       	push	r24
    61a6:	9f 93       	push	r25
    61a8:	af 93       	push	r26
    61aa:	bf 93       	push	r27
    61ac:	ef 93       	push	r30
    61ae:	ff 93       	push	r31
      WDTCSR &= ~(1<<WDIE); // Disable watchdog timer. 
    61b0:	e0 e6       	ldi	r30, 0x60	; 96
    61b2:	f0 e0       	ldi	r31, 0x00	; 0
    61b4:	80 81       	ld	r24, Z
    61b6:	8f 7b       	andi	r24, 0xBF	; 191
    61b8:	80 83       	st	Z, r24
      if (sys.state != STATE_ALARM) {  // Ignore if already in alarm state. 
    61ba:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    61be:	81 30       	cpi	r24, 0x01	; 1
    61c0:	61 f0       	breq	.+24     	; 0x61da <__vector_12+0x50>
        if (!(sys_rt_exec_alarm)) {
    61c2:	80 91 53 0c 	lds	r24, 0x0C53	; 0x800c53 <sys_rt_exec_alarm>
    61c6:	81 11       	cpse	r24, r1
    61c8:	08 c0       	rjmp	.+16     	; 0x61da <__vector_12+0x50>
          // Check limit pin state. 
          if (limits_get_state()) {
    61ca:	7f df       	rcall	.-258    	; 0x60ca <limits_get_state>
    61cc:	88 23       	and	r24, r24
    61ce:	29 f0       	breq	.+10     	; 0x61da <__vector_12+0x50>
            mc_reset(); // Initiate system kill.
    61d0:	0e 94 23 07 	call	0xe46	; 0xe46 <mc_reset>
            system_set_exec_alarm(EXEC_ALARM_HARD_LIMIT); // Indicate hard limit critical event
    61d4:	81 e0       	ldi	r24, 0x01	; 1
    61d6:	0e 94 01 3e 	call	0x7c02	; 0x7c02 <system_set_exec_alarm>
          }
        }  
      }
    }
    61da:	ff 91       	pop	r31
    61dc:	ef 91       	pop	r30
    61de:	bf 91       	pop	r27
    61e0:	af 91       	pop	r26
    61e2:	9f 91       	pop	r25
    61e4:	8f 91       	pop	r24
    61e6:	7f 91       	pop	r23
    61e8:	6f 91       	pop	r22
    61ea:	5f 91       	pop	r21
    61ec:	4f 91       	pop	r20
    61ee:	3f 91       	pop	r19
    61f0:	2f 91       	pop	r18
    61f2:	0f 90       	pop	r0
    61f4:	0b be       	out	0x3b, r0	; 59
    61f6:	0f 90       	pop	r0
    61f8:	0f be       	out	0x3f, r0	; 63
    61fa:	0f 90       	pop	r0
    61fc:	1f 90       	pop	r1
    61fe:	18 95       	reti

00006200 <limits_go_home>:
// mask, which prevents the stepper algorithm from executing step pulses. Homing motions typically
// circumvent the processes for executing motions in normal operation.
// NOTE: Only the abort realtime command can interrupt this process.
// TODO: Move limit pin-specific calls to a general function for portability.
void limits_go_home(uint8_t cycle_mask)
{
    6200:	2f 92       	push	r2
    6202:	3f 92       	push	r3
    6204:	4f 92       	push	r4
    6206:	5f 92       	push	r5
    6208:	6f 92       	push	r6
    620a:	7f 92       	push	r7
    620c:	8f 92       	push	r8
    620e:	9f 92       	push	r9
    6210:	af 92       	push	r10
    6212:	bf 92       	push	r11
    6214:	cf 92       	push	r12
    6216:	df 92       	push	r13
    6218:	ef 92       	push	r14
    621a:	ff 92       	push	r15
    621c:	0f 93       	push	r16
    621e:	1f 93       	push	r17
    6220:	cf 93       	push	r28
    6222:	df 93       	push	r29
    6224:	cd b7       	in	r28, 0x3d	; 61
    6226:	de b7       	in	r29, 0x3e	; 62
    6228:	a9 97       	sbiw	r28, 0x29	; 41
    622a:	0f b6       	in	r0, 0x3f	; 63
    622c:	f8 94       	cli
    622e:	de bf       	out	0x3e, r29	; 62
    6230:	0f be       	out	0x3f, r0	; 63
    6232:	cd bf       	out	0x3d, r28	; 61
  if (sys.abort) { return; } // Block if system reset has been issued.
    6234:	90 91 1f 0c 	lds	r25, 0x0C1F	; 0x800c1f <sys+0x1>
    6238:	91 11       	cpse	r25, r1
    623a:	e1 c1       	rjmp	.+962    	; 0x65fe <limits_go_home+0x3fe>
    623c:	8f a3       	std	Y+39, r24	; 0x27

  // Initialize plan data struct for homing motion. Spindle and coolant are disabled.
  plan_line_data_t plan_data;
  plan_line_data_t *pl_data = &plan_data;
  memset(pl_data,0,sizeof(plan_line_data_t));
    623e:	fe 01       	movw	r30, r28
    6240:	31 96       	adiw	r30, 0x01	; 1
    6242:	8d e0       	ldi	r24, 0x0D	; 13
    6244:	df 01       	movw	r26, r30
    6246:	1d 92       	st	X+, r1
    6248:	8a 95       	dec	r24
    624a:	e9 f7       	brne	.-6      	; 0x6246 <limits_go_home+0x46>
  pl_data->condition = (PL_COND_FLAG_SYSTEM_MOTION|PL_COND_FLAG_NO_FEED_OVERRIDE);
    624c:	86 e0       	ldi	r24, 0x06	; 6
    624e:	8d 87       	std	Y+13, r24	; 0x0d
    6250:	e0 ed       	ldi	r30, 0xD0	; 208
    6252:	fe e0       	ldi	r31, 0x0E	; 14
    6254:	fc a3       	std	Y+36, r31	; 0x24
    6256:	eb a3       	std	Y+35, r30	; 0x23
    6258:	7f 01       	movw	r14, r30
    625a:	9e 01       	movw	r18, r28
    625c:	22 5f       	subi	r18, 0xF2	; 242
    625e:	3f 4f       	sbci	r19, 0xFF	; 255
    6260:	59 01       	movw	r10, r18
    6262:	00 e0       	ldi	r16, 0x00	; 0
    6264:	10 e0       	ldi	r17, 0x00	; 0

  // Initialize variables used for homing computations.
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  uint8_t step_pin[N_AXIS];
  float target[N_AXIS];
  float max_travel = 0.0;
    6266:	41 2c       	mov	r4, r1
    6268:	51 2c       	mov	r5, r1
    626a:	32 01       	movw	r6, r4
    step_pin[idx] = get_step_pin_mask(idx);
    #ifdef COREXY
      if ((idx==A_MOTOR)||(idx==B_MOTOR)) { step_pin[idx] = (get_step_pin_mask(X_AXIS)|get_step_pin_mask(Y_AXIS)); }
    #endif

    if (bit_istrue(cycle_mask,bit(idx))) {
    626c:	3f a1       	ldd	r19, Y+39	; 0x27
    626e:	c3 2e       	mov	r12, r19
    6270:	d1 2c       	mov	r13, r1
  float target[N_AXIS];
  float max_travel = 0.0;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    // Initialize step pin masks
    step_pin[idx] = get_step_pin_mask(idx);
    6272:	80 2f       	mov	r24, r16
    6274:	0e 94 d1 27 	call	0x4fa2	; 0x4fa2 <get_step_pin_mask>
    6278:	d5 01       	movw	r26, r10
    627a:	8d 93       	st	X+, r24
    627c:	5d 01       	movw	r10, r26
    #ifdef COREXY
      if ((idx==A_MOTOR)||(idx==B_MOTOR)) { step_pin[idx] = (get_step_pin_mask(X_AXIS)|get_step_pin_mask(Y_AXIS)); }
    #endif

    if (bit_istrue(cycle_mask,bit(idx))) {
    627e:	de 8e       	std	Y+30, r13	; 0x1e
    6280:	cd 8e       	std	Y+29, r12	; 0x1d
    6282:	c6 01       	movw	r24, r12
    6284:	00 2e       	mov	r0, r16
    6286:	02 c0       	rjmp	.+4      	; 0x628c <limits_go_home+0x8c>
    6288:	95 95       	asr	r25
    628a:	87 95       	ror	r24
    628c:	0a 94       	dec	r0
    628e:	e2 f7       	brpl	.-8      	; 0x6288 <limits_go_home+0x88>
    6290:	80 ff       	sbrs	r24, 0
    6292:	19 c0       	rjmp	.+50     	; 0x62c6 <limits_go_home+0xc6>
      // Set target based on max_travel setting. Ensure homing switches engaged with search scalar.
      // NOTE: settings.max_travel[] is stored as a negative value.
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    6294:	20 e0       	ldi	r18, 0x00	; 0
    6296:	30 e0       	ldi	r19, 0x00	; 0
    6298:	40 ec       	ldi	r20, 0xC0	; 192
    629a:	5f eb       	ldi	r21, 0xBF	; 191
    629c:	f7 01       	movw	r30, r14
    629e:	64 a1       	ldd	r22, Z+36	; 0x24
    62a0:	75 a1       	ldd	r23, Z+37	; 0x25
    62a2:	86 a1       	ldd	r24, Z+38	; 0x26
    62a4:	97 a1       	ldd	r25, Z+39	; 0x27
    62a6:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    62aa:	86 2e       	mov	r8, r22
    62ac:	97 2e       	mov	r9, r23
    62ae:	28 2e       	mov	r2, r24
    62b0:	39 2e       	mov	r3, r25
    62b2:	a3 01       	movw	r20, r6
    62b4:	92 01       	movw	r18, r4
    62b6:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    62ba:	88 23       	and	r24, r24
    62bc:	24 f0       	brlt	.+8      	; 0x62c6 <limits_go_home+0xc6>
    62be:	48 2c       	mov	r4, r8
    62c0:	59 2c       	mov	r5, r9
    62c2:	62 2c       	mov	r6, r2
    62c4:	73 2c       	mov	r7, r3
    62c6:	0f 5f       	subi	r16, 0xFF	; 255
    62c8:	1f 4f       	sbci	r17, 0xFF	; 255
    62ca:	f4 e0       	ldi	r31, 0x04	; 4
    62cc:	ef 0e       	add	r14, r31
    62ce:	f1 1c       	adc	r15, r1
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  uint8_t step_pin[N_AXIS];
  float target[N_AXIS];
  float max_travel = 0.0;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    62d0:	03 30       	cpi	r16, 0x03	; 3
    62d2:	11 05       	cpc	r17, r1
    62d4:	71 f6       	brne	.-100    	; 0x6272 <limits_go_home+0x72>
    62d6:	2d 8c       	ldd	r2, Y+29	; 0x1d
    62d8:	3e 8c       	ldd	r3, Y+30	; 0x1e
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    }
  }
  // Set search mode with approach at seek rate to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
  float homing_rate = settings.homing_seek_rate;
    62da:	80 91 1b 0f 	lds	r24, 0x0F1B	; 0x800f1b <settings+0x4b>
    62de:	90 91 1c 0f 	lds	r25, 0x0F1C	; 0x800f1c <settings+0x4c>
    62e2:	a0 91 1d 0f 	lds	r26, 0x0F1D	; 0x800f1d <settings+0x4d>
    62e6:	b0 91 1e 0f 	lds	r27, 0x0F1E	; 0x800f1e <settings+0x4e>
    62ea:	8f 8f       	std	Y+31, r24	; 0x1f
    62ec:	98 a3       	std	Y+32, r25	; 0x20
    62ee:	a9 a3       	std	Y+33, r26	; 0x21
    62f0:	ba a3       	std	Y+34, r27	; 0x22
    62f2:	94 e0       	ldi	r25, 0x04	; 4
    62f4:	9d 8f       	std	Y+29, r25	; 0x1d
      // NOTE: settings.max_travel[] is stored as a negative value.
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    }
  }
  // Set search mode with approach at seek rate to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
    62f6:	01 e0       	ldi	r16, 0x01	; 1
          axislock |= step_pin[idx];
        }

      }
      homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
      sys.homing_axis_lock = axislock;
    62f8:	0f 2e       	mov	r0, r31
    62fa:	fe e1       	ldi	r31, 0x1E	; 30
    62fc:	cf 2e       	mov	r12, r31
    62fe:	fc e0       	ldi	r31, 0x0C	; 12
    6300:	df 2e       	mov	r13, r31
    6302:	f0 2d       	mov	r31, r0
    } while (n_cycle-- > 0);
  #else
    uint8_t limit_state, axislock, n_active_axis;
    do {

      system_convert_array_steps_to_mpos(target,sys_position);
    6304:	63 e4       	ldi	r22, 0x43	; 67
    6306:	7c e0       	ldi	r23, 0x0C	; 12
    6308:	ce 01       	movw	r24, r28
    630a:	41 96       	adiw	r24, 0x11	; 17
    630c:	0e 94 1a 3b 	call	0x7634	; 0x7634 <system_convert_array_steps_to_mpos>
          #else
            sys_position[idx] = 0;
          #endif
          // Set target direction based on cycle mask and homing cycle approach state.
          // NOTE: This happens to compile smaller than any other implementation tried.
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
    6310:	a6 e1       	ldi	r26, 0x16	; 22
    6312:	bf e0       	ldi	r27, 0x0F	; 15
    6314:	ec 90       	ld	r14, X
    6316:	f1 2c       	mov	r15, r1
    6318:	ae 01       	movw	r20, r28
    631a:	4f 5e       	subi	r20, 0xEF	; 239
    631c:	5f 4f       	sbci	r21, 0xFF	; 255
    631e:	e3 e4       	ldi	r30, 0x43	; 67
    6320:	fc e0       	ldi	r31, 0x0C	; 12
    6322:	fe a3       	std	Y+38, r31	; 0x26
    6324:	ed a3       	std	Y+37, r30	; 0x25
    6326:	de 01       	movw	r26, r28
    6328:	1e 96       	adiw	r26, 0x0e	; 14
    632a:	80 e0       	ldi	r24, 0x00	; 0
    632c:	90 e0       	ldi	r25, 0x00	; 0

      system_convert_array_steps_to_mpos(target,sys_position);

      // Initialize and declare variables needed for homing routine.
      axislock = 0;
      n_active_axis = 0;
    632e:	60 e0       	ldi	r22, 0x00	; 0
    do {

      system_convert_array_steps_to_mpos(target,sys_position);

      // Initialize and declare variables needed for homing routine.
      axislock = 0;
    6330:	10 e0       	ldi	r17, 0x00	; 0
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
            if (approach) { target[idx] = -max_travel; }
            else { target[idx] = max_travel; }
          } else {
            if (approach) { target[idx] = max_travel; }
            else { target[idx] = -max_travel; }
    6332:	53 01       	movw	r10, r6
    6334:	42 01       	movw	r8, r4
    6336:	b7 fa       	bst	r11, 7
    6338:	b0 94       	com	r11
    633a:	b7 f8       	bld	r11, 7
    633c:	b0 94       	com	r11
    633e:	b9 a7       	std	Y+41, r27	; 0x29
    6340:	a8 a7       	std	Y+40, r26	; 0x28
      // Initialize and declare variables needed for homing routine.
      axislock = 0;
      n_active_axis = 0;
      for (idx=0; idx<N_AXIS; idx++) {
        // Set target location for active axes and setup computation for homing rate.
        if (bit_istrue(cycle_mask,bit(idx))) {
    6342:	91 01       	movw	r18, r2
    6344:	08 2e       	mov	r0, r24
    6346:	02 c0       	rjmp	.+4      	; 0x634c <limits_go_home+0x14c>
    6348:	35 95       	asr	r19
    634a:	27 95       	ror	r18
    634c:	0a 94       	dec	r0
    634e:	e2 f7       	brpl	.-8      	; 0x6348 <limits_go_home+0x148>
    6350:	20 ff       	sbrs	r18, 0
    6352:	31 c0       	rjmp	.+98     	; 0x63b6 <limits_go_home+0x1b6>
          n_active_axis++;
    6354:	6f 5f       	subi	r22, 0xFF	; 255
              sys_position[A_MOTOR] = sys_position[B_MOTOR] = axis_position;
            } else {
              sys_position[Z_AXIS] = 0;
            }
          #else
            sys_position[idx] = 0;
    6356:	10 82       	st	Z, r1
    6358:	11 82       	std	Z+1, r1	; 0x01
    635a:	12 82       	std	Z+2, r1	; 0x02
    635c:	13 82       	std	Z+3, r1	; 0x03
          #endif
          // Set target direction based on cycle mask and homing cycle approach state.
          // NOTE: This happens to compile smaller than any other implementation tried.
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
    635e:	97 01       	movw	r18, r14
    6360:	08 2e       	mov	r0, r24
    6362:	02 c0       	rjmp	.+4      	; 0x6368 <limits_go_home+0x168>
    6364:	35 95       	asr	r19
    6366:	27 95       	ror	r18
    6368:	0a 94       	dec	r0
    636a:	e2 f7       	brpl	.-8      	; 0x6364 <limits_go_home+0x164>
    636c:	20 ff       	sbrs	r18, 0
    636e:	10 c0       	rjmp	.+32     	; 0x6390 <limits_go_home+0x190>
            if (approach) { target[idx] = -max_travel; }
    6370:	00 23       	and	r16, r16
    6372:	39 f0       	breq	.+14     	; 0x6382 <limits_go_home+0x182>
    6374:	da 01       	movw	r26, r20
    6376:	8d 92       	st	X+, r8
    6378:	9d 92       	st	X+, r9
    637a:	ad 92       	st	X+, r10
    637c:	bc 92       	st	X, r11
    637e:	13 97       	sbiw	r26, 0x03	; 3
    6380:	16 c0       	rjmp	.+44     	; 0x63ae <limits_go_home+0x1ae>
            else { target[idx] = max_travel; }
    6382:	da 01       	movw	r26, r20
    6384:	4d 92       	st	X+, r4
    6386:	5d 92       	st	X+, r5
    6388:	6d 92       	st	X+, r6
    638a:	7c 92       	st	X, r7
    638c:	13 97       	sbiw	r26, 0x03	; 3
    638e:	0f c0       	rjmp	.+30     	; 0x63ae <limits_go_home+0x1ae>
          } else {
            if (approach) { target[idx] = max_travel; }
    6390:	00 23       	and	r16, r16
    6392:	39 f0       	breq	.+14     	; 0x63a2 <limits_go_home+0x1a2>
    6394:	da 01       	movw	r26, r20
    6396:	4d 92       	st	X+, r4
    6398:	5d 92       	st	X+, r5
    639a:	6d 92       	st	X+, r6
    639c:	7c 92       	st	X, r7
    639e:	13 97       	sbiw	r26, 0x03	; 3
    63a0:	06 c0       	rjmp	.+12     	; 0x63ae <limits_go_home+0x1ae>
            else { target[idx] = -max_travel; }
    63a2:	da 01       	movw	r26, r20
    63a4:	8d 92       	st	X+, r8
    63a6:	9d 92       	st	X+, r9
    63a8:	ad 92       	st	X+, r10
    63aa:	bc 92       	st	X, r11
    63ac:	13 97       	sbiw	r26, 0x03	; 3
          }
          // Apply axislock to the step port pins active in this cycle.
          axislock |= step_pin[idx];
    63ae:	a8 a5       	ldd	r26, Y+40	; 0x28
    63b0:	b9 a5       	ldd	r27, Y+41	; 0x29
    63b2:	2c 91       	ld	r18, X
    63b4:	12 2b       	or	r17, r18
    63b6:	01 96       	adiw	r24, 0x01	; 1
    63b8:	28 a5       	ldd	r18, Y+40	; 0x28
    63ba:	39 a5       	ldd	r19, Y+41	; 0x29
    63bc:	2f 5f       	subi	r18, 0xFF	; 255
    63be:	3f 4f       	sbci	r19, 0xFF	; 255
    63c0:	39 a7       	std	Y+41, r19	; 0x29
    63c2:	28 a7       	std	Y+40, r18	; 0x28
    63c4:	4c 5f       	subi	r20, 0xFC	; 252
    63c6:	5f 4f       	sbci	r21, 0xFF	; 255
    63c8:	34 96       	adiw	r30, 0x04	; 4
      system_convert_array_steps_to_mpos(target,sys_position);

      // Initialize and declare variables needed for homing routine.
      axislock = 0;
      n_active_axis = 0;
      for (idx=0; idx<N_AXIS; idx++) {
    63ca:	83 30       	cpi	r24, 0x03	; 3
    63cc:	91 05       	cpc	r25, r1
    63ce:	09 f0       	breq	.+2      	; 0x63d2 <limits_go_home+0x1d2>
    63d0:	b8 cf       	rjmp	.-144    	; 0x6342 <limits_go_home+0x142>
          // Apply axislock to the step port pins active in this cycle.
          axislock |= step_pin[idx];
        }

      }
      homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
    63d2:	46 2e       	mov	r4, r22
    63d4:	51 2c       	mov	r5, r1
    63d6:	61 2c       	mov	r6, r1
    63d8:	71 2c       	mov	r7, r1
    63da:	c3 01       	movw	r24, r6
    63dc:	b2 01       	movw	r22, r4
    63de:	0e 94 09 40 	call	0x8012	; 0x8012 <__floatunsisf>
    63e2:	0e 94 34 42 	call	0x8468	; 0x8468 <sqrt>
    63e6:	9b 01       	movw	r18, r22
    63e8:	ac 01       	movw	r20, r24
      sys.homing_axis_lock = axislock;
    63ea:	d6 01       	movw	r26, r12
    63ec:	16 96       	adiw	r26, 0x06	; 6
    63ee:	1c 93       	st	X, r17

      // Perform homing cycle. Planner buffer should be empty, as required to initiate the homing cycle.
      pl_data->feed_rate = homing_rate; // Set current homing rate.
    63f0:	6f 8d       	ldd	r22, Y+31	; 0x1f
    63f2:	78 a1       	ldd	r23, Y+32	; 0x20
    63f4:	89 a1       	ldd	r24, Y+33	; 0x21
    63f6:	9a a1       	ldd	r25, Y+34	; 0x22
    63f8:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    63fc:	69 83       	std	Y+1, r22	; 0x01
    63fe:	7a 83       	std	Y+2, r23	; 0x02
    6400:	8b 83       	std	Y+3, r24	; 0x03
    6402:	9c 83       	std	Y+4, r25	; 0x04
      plan_buffer_line(target, pl_data); // Bypass mc_line(). Directly plan homing motion.
    6404:	be 01       	movw	r22, r28
    6406:	6f 5f       	subi	r22, 0xFF	; 255
    6408:	7f 4f       	sbci	r23, 0xFF	; 255
    640a:	ce 01       	movw	r24, r28
    640c:	41 96       	adiw	r24, 0x11	; 17
    640e:	e4 d8       	rcall	.-3640   	; 0x55d8 <plan_buffer_line>

      sys.step_control = STEP_CONTROL_EXECUTE_SYS_MOTION; // Set to execute homing motion and clear existing flags.
    6410:	24 e0       	ldi	r18, 0x04	; 4
    6412:	f6 01       	movw	r30, r12
    6414:	24 83       	std	Z+4, r18	; 0x04
      st_prep_buffer(); // Prep and fill segment buffer from newly planned block.
    6416:	0e 94 4c 1c 	call	0x3898	; 0x3898 <st_prep_buffer>
      st_wake_up(); // Initiate motion
    641a:	0e 94 3f 19 	call	0x327e	; 0x327e <st_wake_up>
      do {
        if (approach) {
    641e:	00 23       	and	r16, r16
    6420:	f1 f0       	breq	.+60     	; 0x645e <limits_go_home+0x25e>
          // Check limit state. Lock out cycle axes when they change.
          limit_state = limits_get_state();
    6422:	53 de       	rcall	.-858    	; 0x60ca <limits_get_state>
    6424:	fe 01       	movw	r30, r28
    6426:	3e 96       	adiw	r30, 0x0e	; 14
    6428:	20 e0       	ldi	r18, 0x00	; 0
    642a:	30 e0       	ldi	r19, 0x00	; 0
          for (idx=0; idx<N_AXIS; idx++) {
            if (axislock & step_pin[idx]) {
              if (limit_state & (1 << idx)) {
    642c:	68 2f       	mov	r22, r24
    642e:	70 e0       	ldi	r23, 0x00	; 0
      do {
        if (approach) {
          // Check limit state. Lock out cycle axes when they change.
          limit_state = limits_get_state();
          for (idx=0; idx<N_AXIS; idx++) {
            if (axislock & step_pin[idx]) {
    6430:	81 91       	ld	r24, Z+
    6432:	98 2f       	mov	r25, r24
    6434:	91 23       	and	r25, r17
    6436:	59 f0       	breq	.+22     	; 0x644e <limits_go_home+0x24e>
              if (limit_state & (1 << idx)) {
    6438:	ab 01       	movw	r20, r22
    643a:	02 2e       	mov	r0, r18
    643c:	02 c0       	rjmp	.+4      	; 0x6442 <limits_go_home+0x242>
    643e:	55 95       	asr	r21
    6440:	47 95       	ror	r20
    6442:	0a 94       	dec	r0
    6444:	e2 f7       	brpl	.-8      	; 0x643e <limits_go_home+0x23e>
    6446:	40 ff       	sbrs	r20, 0
    6448:	02 c0       	rjmp	.+4      	; 0x644e <limits_go_home+0x24e>
                #ifdef COREXY
                  if (idx==Z_AXIS) { axislock &= ~(step_pin[Z_AXIS]); }
                  else { axislock &= ~(step_pin[A_MOTOR]|step_pin[B_MOTOR]); }
                #else
                  axislock &= ~(step_pin[idx]);
    644a:	80 95       	com	r24
    644c:	18 23       	and	r17, r24
    644e:	2f 5f       	subi	r18, 0xFF	; 255
    6450:	3f 4f       	sbci	r19, 0xFF	; 255
      st_wake_up(); // Initiate motion
      do {
        if (approach) {
          // Check limit state. Lock out cycle axes when they change.
          limit_state = limits_get_state();
          for (idx=0; idx<N_AXIS; idx++) {
    6452:	23 30       	cpi	r18, 0x03	; 3
    6454:	31 05       	cpc	r19, r1
    6456:	61 f7       	brne	.-40     	; 0x6430 <limits_go_home+0x230>
                  axislock &= ~(step_pin[idx]);
                #endif
              }
            }
          }
          sys.homing_axis_lock = axislock;
    6458:	d6 01       	movw	r26, r12
    645a:	16 96       	adiw	r26, 0x06	; 6
    645c:	1c 93       	st	X, r17
        }

        st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
    645e:	0e 94 4c 1c 	call	0x3898	; 0x3898 <st_prep_buffer>

        // Exit routines: No time to run protocol_execute_realtime() in this loop.
        if (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET | EXEC_CYCLE_STOP)) {
    6462:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    6466:	84 73       	andi	r24, 0x34	; 52
    6468:	31 f1       	breq	.+76     	; 0x64b6 <limits_go_home+0x2b6>
          uint8_t rt_exec = sys_rt_exec_state;
    646a:	10 91 31 0c 	lds	r17, 0x0C31	; 0x800c31 <sys_rt_exec_state>
          // Homing failure condition: Reset issued during cycle.
          if (rt_exec & EXEC_RESET) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_RESET); }
    646e:	14 ff       	sbrs	r17, 4
    6470:	03 c0       	rjmp	.+6      	; 0x6478 <limits_go_home+0x278>
    6472:	86 e0       	ldi	r24, 0x06	; 6
    6474:	0e 94 01 3e 	call	0x7c02	; 0x7c02 <system_set_exec_alarm>
          // Homing failure condition: Safety door was opened.
          if (rt_exec & EXEC_SAFETY_DOOR) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_DOOR); }
    6478:	15 ff       	sbrs	r17, 5
    647a:	03 c0       	rjmp	.+6      	; 0x6482 <limits_go_home+0x282>
    647c:	87 e0       	ldi	r24, 0x07	; 7
    647e:	0e 94 01 3e 	call	0x7c02	; 0x7c02 <system_set_exec_alarm>
          // Homing failure condition: Limit switch still engaged after pull-off motion
          if (!approach && (limits_get_state() & cycle_mask)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_PULLOFF); }
    6482:	01 11       	cpse	r16, r1
    6484:	b9 c0       	rjmp	.+370    	; 0x65f8 <limits_go_home+0x3f8>
    6486:	21 de       	rcall	.-958    	; 0x60ca <limits_get_state>
    6488:	bf a1       	ldd	r27, Y+39	; 0x27
    648a:	8b 23       	and	r24, r27
    648c:	39 f0       	breq	.+14     	; 0x649c <limits_go_home+0x29c>
    648e:	88 e0       	ldi	r24, 0x08	; 8
    6490:	0e 94 01 3e 	call	0x7c02	; 0x7c02 <system_set_exec_alarm>
    6494:	03 c0       	rjmp	.+6      	; 0x649c <limits_go_home+0x29c>
          // Homing failure condition: Limit switch not found during approach.
          if (approach && (rt_exec & EXEC_CYCLE_STOP)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_APPROACH); }
    6496:	89 e0       	ldi	r24, 0x09	; 9
    6498:	0e 94 01 3e 	call	0x7c02	; 0x7c02 <system_set_exec_alarm>
          if (sys_rt_exec_alarm) {
    649c:	80 91 53 0c 	lds	r24, 0x0C53	; 0x800c53 <sys_rt_exec_alarm>
    64a0:	88 23       	and	r24, r24
    64a2:	29 f0       	breq	.+10     	; 0x64ae <limits_go_home+0x2ae>
            mc_reset(); // Stop motors, if they are running.
    64a4:	0e 94 23 07 	call	0xe46	; 0xe46 <mc_reset>
            protocol_execute_realtime();
    64a8:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <protocol_execute_realtime>
            return;
    64ac:	a8 c0       	rjmp	.+336    	; 0x65fe <limits_go_home+0x3fe>
          } else {
            // Pull-off motion complete. Disable CYCLE_STOP from executing.
            system_clear_exec_state_flag(EXEC_CYCLE_STOP);
    64ae:	84 e0       	ldi	r24, 0x04	; 4
    64b0:	0e 94 f7 3d 	call	0x7bee	; 0x7bee <system_clear_exec_state_flag>
            break;
    64b4:	04 c0       	rjmp	.+8      	; 0x64be <limits_go_home+0x2be>
          }
        }

      } while (STEP_MASK & axislock);
    64b6:	81 2f       	mov	r24, r17
    64b8:	8c 71       	andi	r24, 0x1C	; 28
    64ba:	09 f0       	breq	.+2      	; 0x64be <limits_go_home+0x2be>
    64bc:	b0 cf       	rjmp	.-160    	; 0x641e <limits_go_home+0x21e>
      st_reset(); // Immediately force kill steppers and reset step segment buffer.
    64be:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <st_reset>
      delay_ms(settings.homing_debounce_delay); // Delay to allow transient dynamics to dissipate.
    64c2:	ef e1       	ldi	r30, 0x1F	; 31
    64c4:	ff e0       	ldi	r31, 0x0F	; 15
    64c6:	80 81       	ld	r24, Z
    64c8:	91 81       	ldd	r25, Z+1	; 0x01
    64ca:	ca dc       	rcall	.-1644   	; 0x5e60 <delay_ms>

      // Reverse direction and reset homing rate for locate cycle(s).
      approach = !approach;
    64cc:	f1 e0       	ldi	r31, 0x01	; 1
    64ce:	0f 27       	eor	r16, r31

      // After first cycle, homing enters locating phase. Shorten search to pull-off distance.
      if (approach) {
    64d0:	d1 f0       	breq	.+52     	; 0x6506 <limits_go_home+0x306>
        max_travel = settings.homing_pulloff*HOMING_AXIS_LOCATE_SCALAR;
    64d2:	20 e0       	ldi	r18, 0x00	; 0
    64d4:	30 e0       	ldi	r19, 0x00	; 0
    64d6:	40 ea       	ldi	r20, 0xA0	; 160
    64d8:	50 e4       	ldi	r21, 0x40	; 64
    64da:	a1 e2       	ldi	r26, 0x21	; 33
    64dc:	bf e0       	ldi	r27, 0x0F	; 15
    64de:	6d 91       	ld	r22, X+
    64e0:	7d 91       	ld	r23, X+
    64e2:	8d 91       	ld	r24, X+
    64e4:	9c 91       	ld	r25, X
    64e6:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    64ea:	2b 01       	movw	r4, r22
    64ec:	3c 01       	movw	r6, r24
        homing_rate = settings.homing_feed_rate;
    64ee:	a7 e1       	ldi	r26, 0x17	; 23
    64f0:	bf e0       	ldi	r27, 0x0F	; 15
    64f2:	8d 91       	ld	r24, X+
    64f4:	9d 91       	ld	r25, X+
    64f6:	0d 90       	ld	r0, X+
    64f8:	bc 91       	ld	r27, X
    64fa:	a0 2d       	mov	r26, r0
    64fc:	8f 8f       	std	Y+31, r24	; 0x1f
    64fe:	98 a3       	std	Y+32, r25	; 0x20
    6500:	a9 a3       	std	Y+33, r26	; 0x21
    6502:	ba a3       	std	Y+34, r27	; 0x22
    6504:	11 c0       	rjmp	.+34     	; 0x6528 <limits_go_home+0x328>
      } else {
        max_travel = settings.homing_pulloff;
    6506:	e1 e2       	ldi	r30, 0x21	; 33
    6508:	ff e0       	ldi	r31, 0x0F	; 15
    650a:	40 80       	ld	r4, Z
    650c:	51 80       	ldd	r5, Z+1	; 0x01
    650e:	62 80       	ldd	r6, Z+2	; 0x02
    6510:	73 80       	ldd	r7, Z+3	; 0x03
        homing_rate = settings.homing_seek_rate;
    6512:	ab e1       	ldi	r26, 0x1B	; 27
    6514:	bf e0       	ldi	r27, 0x0F	; 15
    6516:	8d 91       	ld	r24, X+
    6518:	9d 91       	ld	r25, X+
    651a:	0d 90       	ld	r0, X+
    651c:	bc 91       	ld	r27, X
    651e:	a0 2d       	mov	r26, r0
    6520:	8f 8f       	std	Y+31, r24	; 0x1f
    6522:	98 a3       	std	Y+32, r25	; 0x20
    6524:	a9 a3       	std	Y+33, r26	; 0x21
    6526:	ba a3       	std	Y+34, r27	; 0x22
    6528:	bd 8d       	ldd	r27, Y+29	; 0x1d
    652a:	b1 50       	subi	r27, 0x01	; 1
    652c:	bd 8f       	std	Y+29, r27	; 0x1d
      }
    } while (n_cycle-- > 0);
    652e:	b1 11       	cpse	r27, r1
    6530:	e9 ce       	rjmp	.-558    	; 0x6304 <limits_go_home+0x104>
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
      #ifdef HOMING_FORCE_SET_ORIGIN
        set_axis_position = 0;
      #else
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    6532:	e0 90 16 0f 	lds	r14, 0x0F16	; 0x800f16 <settings+0x46>
    6536:	f1 2c       	mov	r15, r1
          set_axis_position = lround((settings.max_travel[idx]+settings.homing_pulloff)*settings.steps_per_mm[idx]);
    6538:	80 90 21 0f 	lds	r8, 0x0F21	; 0x800f21 <settings+0x51>
    653c:	90 90 22 0f 	lds	r9, 0x0F22	; 0x800f22 <settings+0x52>
    6540:	a0 90 23 0f 	lds	r10, 0x0F23	; 0x800f23 <settings+0x53>
    6544:	b0 90 24 0f 	lds	r11, 0x0F24	; 0x800f24 <settings+0x54>
        } else {
          set_axis_position = lround(-settings.homing_pulloff*settings.steps_per_mm[idx]);
    6548:	24 01       	movw	r4, r8
    654a:	35 01       	movw	r6, r10
    654c:	77 fa       	bst	r7, 7
    654e:	70 94       	com	r7
    6550:	77 f8       	bld	r7, 7
    6552:	70 94       	com	r7
    6554:	00 e0       	ldi	r16, 0x00	; 0
    6556:	10 e0       	ldi	r17, 0x00	; 0
    6558:	cd a0       	ldd	r12, Y+37	; 0x25
    655a:	de a0       	ldd	r13, Y+38	; 0x26
  // triggering when hard limits are enabled or when more than one axes shares a limit pin.
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
    655c:	c1 01       	movw	r24, r2
    655e:	00 2e       	mov	r0, r16
    6560:	02 c0       	rjmp	.+4      	; 0x6566 <limits_go_home+0x366>
    6562:	95 95       	asr	r25
    6564:	87 95       	ror	r24
    6566:	0a 94       	dec	r0
    6568:	e2 f7       	brpl	.-8      	; 0x6562 <limits_go_home+0x362>
    656a:	80 ff       	sbrs	r24, 0
    656c:	34 c0       	rjmp	.+104    	; 0x65d6 <limits_go_home+0x3d6>
      #ifdef HOMING_FORCE_SET_ORIGIN
        set_axis_position = 0;
      #else
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    656e:	c7 01       	movw	r24, r14
    6570:	00 2e       	mov	r0, r16
    6572:	02 c0       	rjmp	.+4      	; 0x6578 <limits_go_home+0x378>
    6574:	95 95       	asr	r25
    6576:	87 95       	ror	r24
    6578:	0a 94       	dec	r0
    657a:	e2 f7       	brpl	.-8      	; 0x6574 <limits_go_home+0x374>
    657c:	80 ff       	sbrs	r24, 0
    657e:	15 c0       	rjmp	.+42     	; 0x65aa <limits_go_home+0x3aa>
          set_axis_position = lround((settings.max_travel[idx]+settings.homing_pulloff)*settings.steps_per_mm[idx]);
    6580:	eb a1       	ldd	r30, Y+35	; 0x23
    6582:	fc a1       	ldd	r31, Y+36	; 0x24
    6584:	24 a1       	ldd	r18, Z+36	; 0x24
    6586:	35 a1       	ldd	r19, Z+37	; 0x25
    6588:	46 a1       	ldd	r20, Z+38	; 0x26
    658a:	57 a1       	ldd	r21, Z+39	; 0x27
    658c:	c5 01       	movw	r24, r10
    658e:	b4 01       	movw	r22, r8
    6590:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    6594:	ab a1       	ldd	r26, Y+35	; 0x23
    6596:	bc a1       	ldd	r27, Y+36	; 0x24
    6598:	2d 91       	ld	r18, X+
    659a:	3d 91       	ld	r19, X+
    659c:	4d 91       	ld	r20, X+
    659e:	5c 91       	ld	r21, X
    65a0:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    65a4:	0e 94 77 41 	call	0x82ee	; 0x82ee <lround>
    65a8:	0c c0       	rjmp	.+24     	; 0x65c2 <limits_go_home+0x3c2>
        } else {
          set_axis_position = lround(-settings.homing_pulloff*settings.steps_per_mm[idx]);
    65aa:	eb a1       	ldd	r30, Y+35	; 0x23
    65ac:	fc a1       	ldd	r31, Y+36	; 0x24
    65ae:	20 81       	ld	r18, Z
    65b0:	31 81       	ldd	r19, Z+1	; 0x01
    65b2:	42 81       	ldd	r20, Z+2	; 0x02
    65b4:	53 81       	ldd	r21, Z+3	; 0x03
    65b6:	c3 01       	movw	r24, r6
    65b8:	b2 01       	movw	r22, r4
    65ba:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    65be:	0e 94 77 41 	call	0x82ee	; 0x82ee <lround>
          sys_position[B_MOTOR] = off_axis_position - set_axis_position;
        } else {
          sys_position[idx] = set_axis_position;
        }
      #else
        sys_position[idx] = set_axis_position;
    65c2:	d6 01       	movw	r26, r12
    65c4:	6c 93       	st	X, r22
    65c6:	11 96       	adiw	r26, 0x01	; 1
    65c8:	7c 93       	st	X, r23
    65ca:	11 97       	sbiw	r26, 0x01	; 1
    65cc:	12 96       	adiw	r26, 0x02	; 2
    65ce:	8c 93       	st	X, r24
    65d0:	12 97       	sbiw	r26, 0x02	; 2
    65d2:	13 96       	adiw	r26, 0x03	; 3
    65d4:	9c 93       	st	X, r25
    65d6:	0f 5f       	subi	r16, 0xFF	; 255
    65d8:	1f 4f       	sbci	r17, 0xFF	; 255
    65da:	b4 e0       	ldi	r27, 0x04	; 4
    65dc:	cb 0e       	add	r12, r27
    65de:	d1 1c       	adc	r13, r1
    65e0:	eb a1       	ldd	r30, Y+35	; 0x23
    65e2:	fc a1       	ldd	r31, Y+36	; 0x24
    65e4:	34 96       	adiw	r30, 0x04	; 4
    65e6:	fc a3       	std	Y+36, r31	; 0x24
    65e8:	eb a3       	std	Y+35, r30	; 0x23
  // set up pull-off maneuver from axes limit switches that have been homed. This provides
  // some initial clearance off the switches and should also help prevent them from falsely
  // triggering when hard limits are enabled or when more than one axes shares a limit pin.
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    65ea:	03 30       	cpi	r16, 0x03	; 3
    65ec:	11 05       	cpc	r17, r1
    65ee:	09 f0       	breq	.+2      	; 0x65f2 <limits_go_home+0x3f2>
    65f0:	b5 cf       	rjmp	.-150    	; 0x655c <limits_go_home+0x35c>
        sys_position[idx] = set_axis_position;
      #endif

    }
  }
  sys.step_control = STEP_CONTROL_NORMAL_OP; // Return step control to normal operation.
    65f2:	10 92 22 0c 	sts	0x0C22, r1	; 0x800c22 <sys+0x4>
    65f6:	03 c0       	rjmp	.+6      	; 0x65fe <limits_go_home+0x3fe>
          // Homing failure condition: Safety door was opened.
          if (rt_exec & EXEC_SAFETY_DOOR) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_DOOR); }
          // Homing failure condition: Limit switch still engaged after pull-off motion
          if (!approach && (limits_get_state() & cycle_mask)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_PULLOFF); }
          // Homing failure condition: Limit switch not found during approach.
          if (approach && (rt_exec & EXEC_CYCLE_STOP)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_APPROACH); }
    65f8:	12 ff       	sbrs	r17, 2
    65fa:	50 cf       	rjmp	.-352    	; 0x649c <limits_go_home+0x29c>
    65fc:	4c cf       	rjmp	.-360    	; 0x6496 <limits_go_home+0x296>
      #endif

    }
  }
  sys.step_control = STEP_CONTROL_NORMAL_OP; // Return step control to normal operation.
}
    65fe:	a9 96       	adiw	r28, 0x29	; 41
    6600:	0f b6       	in	r0, 0x3f	; 63
    6602:	f8 94       	cli
    6604:	de bf       	out	0x3e, r29	; 62
    6606:	0f be       	out	0x3f, r0	; 63
    6608:	cd bf       	out	0x3d, r28	; 61
    660a:	df 91       	pop	r29
    660c:	cf 91       	pop	r28
    660e:	1f 91       	pop	r17
    6610:	0f 91       	pop	r16
    6612:	ff 90       	pop	r15
    6614:	ef 90       	pop	r14
    6616:	df 90       	pop	r13
    6618:	cf 90       	pop	r12
    661a:	bf 90       	pop	r11
    661c:	af 90       	pop	r10
    661e:	9f 90       	pop	r9
    6620:	8f 90       	pop	r8
    6622:	7f 90       	pop	r7
    6624:	6f 90       	pop	r6
    6626:	5f 90       	pop	r5
    6628:	4f 90       	pop	r4
    662a:	3f 90       	pop	r3
    662c:	2f 90       	pop	r2
    662e:	08 95       	ret

00006630 <limits_soft_check>:

// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
// NOTE: Used by jogging to limit travel within soft-limit volume.
void limits_soft_check(float *target)
{
    6630:	cf 93       	push	r28
    6632:	df 93       	push	r29
  if (system_check_travel_limits(target)) {
    6634:	0e 94 34 3b 	call	0x7668	; 0x7668 <system_check_travel_limits>
    6638:	88 23       	and	r24, r24
    663a:	d1 f0       	breq	.+52     	; 0x6670 <limits_soft_check+0x40>
    sys.soft_limit = true;
    663c:	ee e1       	ldi	r30, 0x1E	; 30
    663e:	fc e0       	ldi	r31, 0x0C	; 12
    6640:	81 e0       	ldi	r24, 0x01	; 1
    6642:	83 83       	std	Z+3, r24	; 0x03
    // Force feed hold if cycle is active. All buffered blocks are guaranteed to be within
    // workspace volume so just come to a controlled stop so position is not lost. When complete
    // enter alarm mode.
    if (sys.state == STATE_CYCLE) {
    6644:	80 81       	ld	r24, Z
    6646:	88 30       	cpi	r24, 0x08	; 8
    6648:	61 f4       	brne	.+24     	; 0x6662 <limits_soft_check+0x32>
      system_set_exec_state_flag(EXEC_FEED_HOLD);
    664a:	0e 94 99 3b 	call	0x7732	; 0x7732 <system_set_exec_state_flag>
      do {
        protocol_execute_realtime();
        if (sys.abort) { return; }
    664e:	ce e1       	ldi	r28, 0x1E	; 30
    6650:	dc e0       	ldi	r29, 0x0C	; 12
    // workspace volume so just come to a controlled stop so position is not lost. When complete
    // enter alarm mode.
    if (sys.state == STATE_CYCLE) {
      system_set_exec_state_flag(EXEC_FEED_HOLD);
      do {
        protocol_execute_realtime();
    6652:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <protocol_execute_realtime>
        if (sys.abort) { return; }
    6656:	89 81       	ldd	r24, Y+1	; 0x01
    6658:	81 11       	cpse	r24, r1
    665a:	0a c0       	rjmp	.+20     	; 0x6670 <limits_soft_check+0x40>
      } while ( sys.state != STATE_IDLE );
    665c:	88 81       	ld	r24, Y
    665e:	81 11       	cpse	r24, r1
    6660:	f8 cf       	rjmp	.-16     	; 0x6652 <limits_soft_check+0x22>
    }
    mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
    6662:	0e 94 23 07 	call	0xe46	; 0xe46 <mc_reset>
    system_set_exec_alarm(EXEC_ALARM_SOFT_LIMIT); // Indicate soft limit critical event
    6666:	82 e0       	ldi	r24, 0x02	; 2
    6668:	0e 94 01 3e 	call	0x7c02	; 0x7c02 <system_set_exec_alarm>
    protocol_execute_realtime(); // Execute to enter critical event loop and system abort
    666c:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <protocol_execute_realtime>
    return;
  }
}
    6670:	df 91       	pop	r29
    6672:	cf 91       	pop	r28
    6674:	08 95       	ret

00006676 <printString>:
      n /= 2;
  }

  for (; i > 0; i--)
      serial_write('0' + buf[i - 1]);
}
    6676:	cf 93       	push	r28
    6678:	df 93       	push	r29
    667a:	ec 01       	movw	r28, r24
    667c:	88 81       	ld	r24, Y
    667e:	88 23       	and	r24, r24
    6680:	31 f0       	breq	.+12     	; 0x668e <printString+0x18>
    6682:	21 96       	adiw	r28, 0x01	; 1
    6684:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    6688:	89 91       	ld	r24, Y+
    668a:	81 11       	cpse	r24, r1
    668c:	fb cf       	rjmp	.-10     	; 0x6684 <printString+0xe>
    668e:	df 91       	pop	r29
    6690:	cf 91       	pop	r28
    6692:	08 95       	ret

00006694 <printPgmString>:
    6694:	cf 93       	push	r28
    6696:	df 93       	push	r29
    6698:	ec 01       	movw	r28, r24
    669a:	21 96       	adiw	r28, 0x01	; 1
    669c:	fc 01       	movw	r30, r24
    669e:	84 91       	lpm	r24, Z
    66a0:	88 23       	and	r24, r24
    66a2:	39 f0       	breq	.+14     	; 0x66b2 <printPgmString+0x1e>
    66a4:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    66a8:	fe 01       	movw	r30, r28
    66aa:	84 91       	lpm	r24, Z
    66ac:	21 96       	adiw	r28, 0x01	; 1
    66ae:	81 11       	cpse	r24, r1
    66b0:	f9 cf       	rjmp	.-14     	; 0x66a4 <printPgmString+0x10>
    66b2:	df 91       	pop	r29
    66b4:	cf 91       	pop	r28
    66b6:	08 95       	ret

000066b8 <print_uint8_base10>:
    66b8:	cf 93       	push	r28
    66ba:	df 93       	push	r29
    66bc:	84 36       	cpi	r24, 0x64	; 100
    66be:	90 f0       	brcs	.+36     	; 0x66e4 <print_uint8_base10+0x2c>
    66c0:	9d ec       	ldi	r25, 0xCD	; 205
    66c2:	89 9f       	mul	r24, r25
    66c4:	91 2d       	mov	r25, r1
    66c6:	11 24       	eor	r1, r1
    66c8:	96 95       	lsr	r25
    66ca:	96 95       	lsr	r25
    66cc:	96 95       	lsr	r25
    66ce:	39 2f       	mov	r19, r25
    66d0:	33 0f       	add	r19, r19
    66d2:	23 2f       	mov	r18, r19
    66d4:	22 0f       	add	r18, r18
    66d6:	22 0f       	add	r18, r18
    66d8:	23 0f       	add	r18, r19
    66da:	82 1b       	sub	r24, r18
    66dc:	d0 e3       	ldi	r29, 0x30	; 48
    66de:	d8 0f       	add	r29, r24
    66e0:	89 2f       	mov	r24, r25
    66e2:	01 c0       	rjmp	.+2      	; 0x66e6 <print_uint8_base10+0x2e>
    66e4:	d0 e0       	ldi	r29, 0x00	; 0
    66e6:	8a 30       	cpi	r24, 0x0A	; 10
    66e8:	f8 f0       	brcs	.+62     	; 0x6728 <print_uint8_base10+0x70>
    66ea:	9d ec       	ldi	r25, 0xCD	; 205
    66ec:	89 9f       	mul	r24, r25
    66ee:	91 2d       	mov	r25, r1
    66f0:	11 24       	eor	r1, r1
    66f2:	96 95       	lsr	r25
    66f4:	96 95       	lsr	r25
    66f6:	96 95       	lsr	r25
    66f8:	39 2f       	mov	r19, r25
    66fa:	33 0f       	add	r19, r19
    66fc:	23 2f       	mov	r18, r19
    66fe:	22 0f       	add	r18, r18
    6700:	22 0f       	add	r18, r18
    6702:	23 0f       	add	r18, r19
    6704:	c8 2f       	mov	r28, r24
    6706:	c2 1b       	sub	r28, r18
    6708:	c0 5d       	subi	r28, 0xD0	; 208
    670a:	80 e3       	ldi	r24, 0x30	; 48
    670c:	89 0f       	add	r24, r25
    670e:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    6712:	cc 23       	and	r28, r28
    6714:	19 f0       	breq	.+6      	; 0x671c <print_uint8_base10+0x64>
    6716:	8c 2f       	mov	r24, r28
    6718:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    671c:	dd 23       	and	r29, r29
    671e:	41 f0       	breq	.+16     	; 0x6730 <print_uint8_base10+0x78>
    6720:	8d 2f       	mov	r24, r29
    6722:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    6726:	04 c0       	rjmp	.+8      	; 0x6730 <print_uint8_base10+0x78>
    6728:	80 5d       	subi	r24, 0xD0	; 208
    672a:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    672e:	f6 cf       	rjmp	.-20     	; 0x671c <print_uint8_base10+0x64>
    6730:	df 91       	pop	r29
    6732:	cf 91       	pop	r28
    6734:	08 95       	ret

00006736 <print_uint32_base10>:


void print_uint32_base10(uint32_t n)
{
    6736:	8f 92       	push	r8
    6738:	9f 92       	push	r9
    673a:	af 92       	push	r10
    673c:	bf 92       	push	r11
    673e:	ef 92       	push	r14
    6740:	ff 92       	push	r15
    6742:	1f 93       	push	r17
    6744:	cf 93       	push	r28
    6746:	df 93       	push	r29
    6748:	cd b7       	in	r28, 0x3d	; 61
    674a:	de b7       	in	r29, 0x3e	; 62
    674c:	2a 97       	sbiw	r28, 0x0a	; 10
    674e:	0f b6       	in	r0, 0x3f	; 63
    6750:	f8 94       	cli
    6752:	de bf       	out	0x3e, r29	; 62
    6754:	0f be       	out	0x3f, r0	; 63
    6756:	cd bf       	out	0x3d, r28	; 61
  if (n == 0) {
    6758:	61 15       	cp	r22, r1
    675a:	71 05       	cpc	r23, r1
    675c:	81 05       	cpc	r24, r1
    675e:	91 05       	cpc	r25, r1
    6760:	21 f4       	brne	.+8      	; 0x676a <print_uint32_base10+0x34>
    serial_write('0');
    6762:	80 e3       	ldi	r24, 0x30	; 48
    6764:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    6768:	2c c0       	rjmp	.+88     	; 0x67c2 <print_uint32_base10+0x8c>
    676a:	20 e0       	ldi	r18, 0x00	; 0

  unsigned char buf[10];
  uint8_t i = 0;

  while (n > 0) {
    buf[i++] = n % 10;
    676c:	0f 2e       	mov	r0, r31
    676e:	fa e0       	ldi	r31, 0x0A	; 10
    6770:	8f 2e       	mov	r8, r31
    6772:	91 2c       	mov	r9, r1
    6774:	a1 2c       	mov	r10, r1
    6776:	b1 2c       	mov	r11, r1
    6778:	f0 2d       	mov	r31, r0
    677a:	11 e0       	ldi	r17, 0x01	; 1
    677c:	12 0f       	add	r17, r18
    677e:	ee 24       	eor	r14, r14
    6780:	e3 94       	inc	r14
    6782:	f1 2c       	mov	r15, r1
    6784:	ec 0e       	add	r14, r28
    6786:	fd 1e       	adc	r15, r29
    6788:	e2 0e       	add	r14, r18
    678a:	f1 1c       	adc	r15, r1
    678c:	a5 01       	movw	r20, r10
    678e:	94 01       	movw	r18, r8
    6790:	0e 94 94 42 	call	0x8528	; 0x8528 <__udivmodsi4>
    6794:	f7 01       	movw	r30, r14
    6796:	60 83       	st	Z, r22
    n /= 10;
    6798:	62 2f       	mov	r22, r18
    679a:	73 2f       	mov	r23, r19
    679c:	84 2f       	mov	r24, r20
    679e:	95 2f       	mov	r25, r21

  unsigned char buf[10];
  uint8_t i = 0;

  while (n > 0) {
    buf[i++] = n % 10;
    67a0:	21 2f       	mov	r18, r17
  }

  unsigned char buf[10];
  uint8_t i = 0;

  while (n > 0) {
    67a2:	61 15       	cp	r22, r1
    67a4:	71 05       	cpc	r23, r1
    67a6:	81 05       	cpc	r24, r1
    67a8:	91 05       	cpc	r25, r1
    67aa:	39 f7       	brne	.-50     	; 0x677a <print_uint32_base10+0x44>
    buf[i++] = n % 10;
    n /= 10;
  }

  for (; i > 0; i--)
    67ac:	11 23       	and	r17, r17
    67ae:	49 f0       	breq	.+18     	; 0x67c2 <print_uint32_base10+0x8c>
    serial_write('0' + buf[i-1]);
    67b0:	fe 01       	movw	r30, r28
    67b2:	e1 0f       	add	r30, r17
    67b4:	f1 1d       	adc	r31, r1
    67b6:	80 81       	ld	r24, Z
    67b8:	80 5d       	subi	r24, 0xD0	; 208
    67ba:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
  while (n > 0) {
    buf[i++] = n % 10;
    n /= 10;
  }

  for (; i > 0; i--)
    67be:	11 50       	subi	r17, 0x01	; 1
    67c0:	b9 f7       	brne	.-18     	; 0x67b0 <print_uint32_base10+0x7a>
    serial_write('0' + buf[i-1]);
}
    67c2:	2a 96       	adiw	r28, 0x0a	; 10
    67c4:	0f b6       	in	r0, 0x3f	; 63
    67c6:	f8 94       	cli
    67c8:	de bf       	out	0x3e, r29	; 62
    67ca:	0f be       	out	0x3f, r0	; 63
    67cc:	cd bf       	out	0x3d, r28	; 61
    67ce:	df 91       	pop	r29
    67d0:	cf 91       	pop	r28
    67d2:	1f 91       	pop	r17
    67d4:	ff 90       	pop	r15
    67d6:	ef 90       	pop	r14
    67d8:	bf 90       	pop	r11
    67da:	af 90       	pop	r10
    67dc:	9f 90       	pop	r9
    67de:	8f 90       	pop	r8
    67e0:	08 95       	ret

000067e2 <printInteger>:


void printInteger(long n)
{
    67e2:	cf 92       	push	r12
    67e4:	df 92       	push	r13
    67e6:	ef 92       	push	r14
    67e8:	ff 92       	push	r15
    67ea:	6b 01       	movw	r12, r22
    67ec:	7c 01       	movw	r14, r24
  if (n < 0) {
    67ee:	99 23       	and	r25, r25
    67f0:	64 f4       	brge	.+24     	; 0x680a <printInteger+0x28>
    serial_write('-');
    67f2:	8d e2       	ldi	r24, 0x2D	; 45
    67f4:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    print_uint32_base10(-n);
    67f8:	66 27       	eor	r22, r22
    67fa:	77 27       	eor	r23, r23
    67fc:	cb 01       	movw	r24, r22
    67fe:	6c 19       	sub	r22, r12
    6800:	7d 09       	sbc	r23, r13
    6802:	8e 09       	sbc	r24, r14
    6804:	9f 09       	sbc	r25, r15
    6806:	97 df       	rcall	.-210    	; 0x6736 <print_uint32_base10>
    6808:	01 c0       	rjmp	.+2      	; 0x680c <printInteger+0x2a>
  } else {
    print_uint32_base10(n);
    680a:	95 df       	rcall	.-214    	; 0x6736 <print_uint32_base10>
    680c:	ff 90       	pop	r15
  }
}
    680e:	ef 90       	pop	r14
    6810:	df 90       	pop	r13
    6812:	cf 90       	pop	r12
    6814:	08 95       	ret

00006816 <printFloat>:
    6816:	8f 92       	push	r8
// more digits than a float. Number of decimal places, which are tracked by a counter,
// may be set by the user. The integer is then efficiently converted to a string.
// NOTE: AVR '%' and '/' integer operations are very efficient. Bitshifting speed-up
// techniques are actually just slightly slower. Found this out the hard way.
void printFloat(float n, uint8_t decimal_places)
{
    6818:	9f 92       	push	r9
    681a:	af 92       	push	r10
    681c:	bf 92       	push	r11
    681e:	cf 92       	push	r12
    6820:	df 92       	push	r13
    6822:	ef 92       	push	r14
    6824:	ff 92       	push	r15
    6826:	0f 93       	push	r16
    6828:	1f 93       	push	r17
    682a:	cf 93       	push	r28
    682c:	df 93       	push	r29
    682e:	cd b7       	in	r28, 0x3d	; 61
    6830:	de b7       	in	r29, 0x3e	; 62
    6832:	2d 97       	sbiw	r28, 0x0d	; 13
    6834:	0f b6       	in	r0, 0x3f	; 63
    6836:	f8 94       	cli
    6838:	de bf       	out	0x3e, r29	; 62
    683a:	0f be       	out	0x3f, r0	; 63
    683c:	cd bf       	out	0x3d, r28	; 61
    683e:	6b 01       	movw	r12, r22
    6840:	7c 01       	movw	r14, r24
    6842:	04 2f       	mov	r16, r20
  if (n < 0) {
    6844:	20 e0       	ldi	r18, 0x00	; 0
    6846:	30 e0       	ldi	r19, 0x00	; 0
    6848:	a9 01       	movw	r20, r18
    684a:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <__cmpsf2>
    684e:	88 23       	and	r24, r24
    6850:	3c f4       	brge	.+14     	; 0x6860 <printFloat+0x4a>
    serial_write('-');
    6852:	8d e2       	ldi	r24, 0x2D	; 45
    6854:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    n = -n;
    6858:	f7 fa       	bst	r15, 7
    685a:	f0 94       	com	r15
    685c:	f7 f8       	bld	r15, 7
    685e:	f0 94       	com	r15
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    6860:	02 30       	cpi	r16, 0x02	; 2
    6862:	88 f0       	brcs	.+34     	; 0x6886 <printFloat+0x70>
    6864:	10 2f       	mov	r17, r16
    n *= 100;
    6866:	20 e0       	ldi	r18, 0x00	; 0
    6868:	30 e0       	ldi	r19, 0x00	; 0
    686a:	48 ec       	ldi	r20, 0xC8	; 200
    686c:	52 e4       	ldi	r21, 0x42	; 66
    686e:	c7 01       	movw	r24, r14
    6870:	b6 01       	movw	r22, r12
    6872:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    6876:	6b 01       	movw	r12, r22
    6878:	7c 01       	movw	r14, r24
    decimals -= 2;
    687a:	12 50       	subi	r17, 0x02	; 2
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    687c:	12 30       	cpi	r17, 0x02	; 2
    687e:	98 f7       	brcc	.-26     	; 0x6866 <printFloat+0x50>
    6880:	80 2f       	mov	r24, r16
    6882:	81 70       	andi	r24, 0x01	; 1
    6884:	01 c0       	rjmp	.+2      	; 0x6888 <printFloat+0x72>
  if (n < 0) {
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
    6886:	80 2f       	mov	r24, r16
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    n *= 100;
    decimals -= 2;
  }
  if (decimals) { n *= 10; }
    6888:	88 23       	and	r24, r24
    688a:	51 f0       	breq	.+20     	; 0x68a0 <printFloat+0x8a>
    688c:	20 e0       	ldi	r18, 0x00	; 0
    688e:	30 e0       	ldi	r19, 0x00	; 0
    6890:	40 e2       	ldi	r20, 0x20	; 32
    6892:	51 e4       	ldi	r21, 0x41	; 65
    6894:	c7 01       	movw	r24, r14
    6896:	b6 01       	movw	r22, r12
    6898:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    689c:	6b 01       	movw	r12, r22
    689e:	7c 01       	movw	r14, r24
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.

  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
  uint32_t a = (long)n;
    68a0:	20 e0       	ldi	r18, 0x00	; 0
    68a2:	30 e0       	ldi	r19, 0x00	; 0
    68a4:	40 e0       	ldi	r20, 0x00	; 0
    68a6:	5f e3       	ldi	r21, 0x3F	; 63
    68a8:	c7 01       	movw	r24, r14
    68aa:	b6 01       	movw	r22, r12
    68ac:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <__addsf3>
    68b0:	0e 94 d8 3f 	call	0x7fb0	; 0x7fb0 <__fixsfsi>
  while(a > 0) {
    68b4:	61 15       	cp	r22, r1
    68b6:	71 05       	cpc	r23, r1
    68b8:	81 05       	cpc	r24, r1
    68ba:	91 05       	cpc	r25, r1
    68bc:	19 f1       	breq	.+70     	; 0x6904 <printFloat+0xee>
    68be:	20 e0       	ldi	r18, 0x00	; 0
    buf[i++] = (a % 10) + '0'; // Get digit
    68c0:	0f 2e       	mov	r0, r31
    68c2:	fa e0       	ldi	r31, 0x0A	; 10
    68c4:	8f 2e       	mov	r8, r31
    68c6:	91 2c       	mov	r9, r1
    68c8:	a1 2c       	mov	r10, r1
    68ca:	b1 2c       	mov	r11, r1
    68cc:	f0 2d       	mov	r31, r0
    68ce:	11 e0       	ldi	r17, 0x01	; 1
    68d0:	12 0f       	add	r17, r18
    68d2:	ee 24       	eor	r14, r14
    68d4:	e3 94       	inc	r14
    68d6:	f1 2c       	mov	r15, r1
    68d8:	ec 0e       	add	r14, r28
    68da:	fd 1e       	adc	r15, r29
    68dc:	e2 0e       	add	r14, r18
    68de:	f1 1c       	adc	r15, r1
    68e0:	a5 01       	movw	r20, r10
    68e2:	94 01       	movw	r18, r8
    68e4:	0e 94 94 42 	call	0x8528	; 0x8528 <__udivmodsi4>
    68e8:	60 5d       	subi	r22, 0xD0	; 208
    68ea:	f7 01       	movw	r30, r14
    68ec:	60 83       	st	Z, r22
    a /= 10;
    68ee:	62 2f       	mov	r22, r18
    68f0:	73 2f       	mov	r23, r19
    68f2:	84 2f       	mov	r24, r20
    68f4:	95 2f       	mov	r25, r21
  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
  uint32_t a = (long)n;
  while(a > 0) {
    buf[i++] = (a % 10) + '0'; // Get digit
    68f6:	21 2f       	mov	r18, r17

  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
  uint32_t a = (long)n;
  while(a > 0) {
    68f8:	61 15       	cp	r22, r1
    68fa:	71 05       	cpc	r23, r1
    68fc:	81 05       	cpc	r24, r1
    68fe:	91 05       	cpc	r25, r1
    6900:	31 f7       	brne	.-52     	; 0x68ce <printFloat+0xb8>
    6902:	01 c0       	rjmp	.+2      	; 0x6906 <printFloat+0xf0>
  if (decimals) { n *= 10; }
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.

  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
    6904:	10 e0       	ldi	r17, 0x00	; 0
  uint32_t a = (long)n;
  while(a > 0) {
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) {
    6906:	10 17       	cp	r17, r16
    6908:	60 f4       	brcc	.+24     	; 0x6922 <printFloat+0x10c>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
    690a:	80 e3       	ldi	r24, 0x30	; 48
    690c:	e1 e0       	ldi	r30, 0x01	; 1
    690e:	f0 e0       	ldi	r31, 0x00	; 0
    6910:	ec 0f       	add	r30, r28
    6912:	fd 1f       	adc	r31, r29
    6914:	e1 0f       	add	r30, r17
    6916:	f1 1d       	adc	r31, r1
    6918:	80 83       	st	Z, r24
    691a:	1f 5f       	subi	r17, 0xFF	; 255
  uint32_t a = (long)n;
  while(a > 0) {
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) {
    691c:	01 13       	cpse	r16, r17
    691e:	f6 cf       	rjmp	.-20     	; 0x690c <printFloat+0xf6>
    6920:	02 c0       	rjmp	.+4      	; 0x6926 <printFloat+0x110>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
  }
  if (i == decimal_places) { // Fill in leading zero, if needed.
    6922:	01 13       	cpse	r16, r17
    6924:	07 c0       	rjmp	.+14     	; 0x6934 <printFloat+0x11e>
    buf[i++] = '0';
    6926:	11 e0       	ldi	r17, 0x01	; 1
    6928:	10 0f       	add	r17, r16
    692a:	80 e3       	ldi	r24, 0x30	; 48
    692c:	fe 01       	movw	r30, r28
    692e:	e0 0f       	add	r30, r16
    6930:	f1 1d       	adc	r31, r1
    6932:	81 83       	std	Z+1, r24	; 0x01
  }

  // Print the generated string.
  for (; i > 0; i--) {
    6934:	11 23       	and	r17, r17
    6936:	69 f0       	breq	.+26     	; 0x6952 <printFloat+0x13c>
    if (i == decimal_places) { serial_write('.'); } // Insert decimal point in right place.
    6938:	01 13       	cpse	r16, r17
    693a:	03 c0       	rjmp	.+6      	; 0x6942 <printFloat+0x12c>
    693c:	8e e2       	ldi	r24, 0x2E	; 46
    693e:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    serial_write(buf[i-1]);
    6942:	fe 01       	movw	r30, r28
    6944:	e1 0f       	add	r30, r17
    6946:	f1 1d       	adc	r31, r1
    6948:	80 81       	ld	r24, Z
    694a:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
  if (i == decimal_places) { // Fill in leading zero, if needed.
    buf[i++] = '0';
  }

  // Print the generated string.
  for (; i > 0; i--) {
    694e:	11 50       	subi	r17, 0x01	; 1
    6950:	99 f7       	brne	.-26     	; 0x6938 <printFloat+0x122>
    if (i == decimal_places) { serial_write('.'); } // Insert decimal point in right place.
    serial_write(buf[i-1]);
  }
}
    6952:	2d 96       	adiw	r28, 0x0d	; 13
    6954:	0f b6       	in	r0, 0x3f	; 63
    6956:	f8 94       	cli
    6958:	de bf       	out	0x3e, r29	; 62
    695a:	0f be       	out	0x3f, r0	; 63
    695c:	cd bf       	out	0x3d, r28	; 61
    695e:	df 91       	pop	r29
    6960:	cf 91       	pop	r28
    6962:	1f 91       	pop	r17
    6964:	0f 91       	pop	r16
    6966:	ff 90       	pop	r15
    6968:	ef 90       	pop	r14
    696a:	df 90       	pop	r13
    696c:	cf 90       	pop	r12
    696e:	bf 90       	pop	r11
    6970:	af 90       	pop	r10
    6972:	9f 90       	pop	r9
    6974:	8f 90       	pop	r8
    6976:	08 95       	ret

00006978 <printFloat_CoordValue>:
// Floating value printing handlers for special variables types used in Grbl and are defined
// in the config.h.
//  - CoordValue: Handles all position or coordinate values in inches or mm reporting.
//  - RateValue: Handles feed rate and current velocity in inches or mm reporting.
void printFloat_CoordValue(float n) {
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
    6978:	20 91 15 0f 	lds	r18, 0x0F15	; 0x800f15 <settings+0x45>
    697c:	20 ff       	sbrs	r18, 0
    697e:	09 c0       	rjmp	.+18     	; 0x6992 <printFloat_CoordValue+0x1a>
    printFloat(n*INCH_PER_MM,N_DECIMAL_COORDVALUE_INCH);
    6980:	2b e8       	ldi	r18, 0x8B	; 139
    6982:	32 e4       	ldi	r19, 0x42	; 66
    6984:	41 e2       	ldi	r20, 0x21	; 33
    6986:	5d e3       	ldi	r21, 0x3D	; 61
    6988:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    698c:	44 e0       	ldi	r20, 0x04	; 4
    698e:	43 cf       	rjmp	.-378    	; 0x6816 <printFloat>
    6990:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_COORDVALUE_MM);
    6992:	43 e0       	ldi	r20, 0x03	; 3
    6994:	40 cf       	rjmp	.-384    	; 0x6816 <printFloat>
    6996:	08 95       	ret

00006998 <printFloat_RateValue>:
  }
}

void printFloat_RateValue(float n) {
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
    6998:	20 91 15 0f 	lds	r18, 0x0F15	; 0x800f15 <settings+0x45>
    699c:	20 ff       	sbrs	r18, 0
    699e:	09 c0       	rjmp	.+18     	; 0x69b2 <printFloat_RateValue+0x1a>
    printFloat(n*INCH_PER_MM,N_DECIMAL_RATEVALUE_INCH);
    69a0:	2b e8       	ldi	r18, 0x8B	; 139
    69a2:	32 e4       	ldi	r19, 0x42	; 66
    69a4:	41 e2       	ldi	r20, 0x21	; 33
    69a6:	5d e3       	ldi	r21, 0x3D	; 61
    69a8:	0e 94 a7 41 	call	0x834e	; 0x834e <__mulsf3>
    69ac:	41 e0       	ldi	r20, 0x01	; 1
    69ae:	33 cf       	rjmp	.-410    	; 0x6816 <printFloat>
    69b0:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_RATEVALUE_MM);
    69b2:	40 e0       	ldi	r20, 0x00	; 0
    69b4:	30 cf       	rjmp	.-416    	; 0x6816 <printFloat>
    69b6:	08 95       	ret

000069b8 <probe_configure_invert_mask>:
// Called by probe_init() and the mc_probe() routines. Sets up the probe pin invert mask to
// appropriately set the pin logic according to setting for normal-high/normal-low operation
// and the probing cycle modes for toward-workpiece/away-from-workpiece.
void probe_configure_invert_mask(uint8_t is_probe_away)
{
  probe_invert_mask = 0; // Initialize as zero.
    69b8:	10 92 25 0f 	sts	0x0F25, r1	; 0x800f25 <probe_invert_mask>
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_PROBE_PIN)) { probe_invert_mask ^= PROBE_MASK; }
    69bc:	90 91 15 0f 	lds	r25, 0x0F15	; 0x800f15 <settings+0x45>
    69c0:	99 23       	and	r25, r25
    69c2:	1c f0       	brlt	.+6      	; 0x69ca <probe_configure_invert_mask+0x12>
    69c4:	90 e8       	ldi	r25, 0x80	; 128
    69c6:	90 93 25 0f 	sts	0x0F25, r25	; 0x800f25 <probe_invert_mask>
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
    69ca:	88 23       	and	r24, r24
    69cc:	29 f0       	breq	.+10     	; 0x69d8 <probe_configure_invert_mask+0x20>
    69ce:	80 91 25 0f 	lds	r24, 0x0F25	; 0x800f25 <probe_invert_mask>
    69d2:	80 58       	subi	r24, 0x80	; 128
    69d4:	80 93 25 0f 	sts	0x0F25, r24	; 0x800f25 <probe_invert_mask>
    69d8:	08 95       	ret

000069da <probe_init>:


// Probe pin initialization routine.
void probe_init()
{
  PROBE_DDR &= ~(PROBE_MASK); // Configure as input pins
    69da:	e7 e0       	ldi	r30, 0x07	; 7
    69dc:	f1 e0       	ldi	r31, 0x01	; 1
    69de:	80 81       	ld	r24, Z
    69e0:	8f 77       	andi	r24, 0x7F	; 127
    69e2:	80 83       	st	Z, r24
  #ifdef DISABLE_PROBE_PIN_PULL_UP
    PROBE_PORT &= ~(PROBE_MASK); // Normal low operation. Requires external pull-down.
  #else
    PROBE_PORT |= PROBE_MASK;    // Enable internal pull-up resistors. Normal high operation.
    69e4:	e8 e0       	ldi	r30, 0x08	; 8
    69e6:	f1 e0       	ldi	r31, 0x01	; 1
    69e8:	80 81       	ld	r24, Z
    69ea:	80 68       	ori	r24, 0x80	; 128
    69ec:	80 83       	st	Z, r24
  #endif
  probe_configure_invert_mask(false); // Initialize invert mask.
    69ee:	80 e0       	ldi	r24, 0x00	; 0
    69f0:	e3 cf       	rjmp	.-58     	; 0x69b8 <probe_configure_invert_mask>
    69f2:	08 95       	ret

000069f4 <probe_get_state>:
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
}


// Returns the probe pin state. Triggered = true. Called by gcode parser and probe state monitor.
uint8_t probe_get_state() { return((PROBE_PIN & PROBE_MASK) ^ probe_invert_mask); }
    69f4:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
    69f8:	80 78       	andi	r24, 0x80	; 128
    69fa:	90 91 25 0f 	lds	r25, 0x0F25	; 0x800f25 <probe_invert_mask>
    69fe:	89 27       	eor	r24, r25
    6a00:	08 95       	ret

00006a02 <probe_state_monitor>:
// Monitors probe pin state and records the system position when detected. Called by the
// stepper ISR per ISR tick.
// NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
void probe_state_monitor()
{
  if (probe_get_state()) {
    6a02:	f8 df       	rcall	.-16     	; 0x69f4 <probe_get_state>
    6a04:	88 23       	and	r24, r24
    6a06:	81 f0       	breq	.+32     	; 0x6a28 <probe_state_monitor+0x26>
    sys_probe_state = PROBE_OFF;
    6a08:	10 92 32 0c 	sts	0x0C32, r1	; 0x800c32 <sys_probe_state>
    memcpy(sys_probe_position, sys_position, sizeof(sys_position));
    6a0c:	8c e0       	ldi	r24, 0x0C	; 12
    6a0e:	e3 e4       	ldi	r30, 0x43	; 67
    6a10:	fc e0       	ldi	r31, 0x0C	; 12
    6a12:	a7 e3       	ldi	r26, 0x37	; 55
    6a14:	bc e0       	ldi	r27, 0x0C	; 12
    6a16:	01 90       	ld	r0, Z+
    6a18:	0d 92       	st	X+, r0
    6a1a:	8a 95       	dec	r24
    6a1c:	e1 f7       	brne	.-8      	; 0x6a16 <probe_state_monitor+0x14>
    bit_true(sys_rt_exec_state, EXEC_MOTION_CANCEL);
    6a1e:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    6a22:	80 64       	ori	r24, 0x40	; 64
    6a24:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <sys_rt_exec_state>
    6a28:	08 95       	ret

00006a2a <report_util_line_feed>:
// and has been sent into protocol_execute_line() routine to be executed by Grbl.
void report_echo_line_received(char *line)
{
  printPgmString(PSTR("[echo: ")); printString(line);
  report_util_feedback_line_feed();
}
    6a2a:	8c e1       	ldi	r24, 0x1C	; 28
    6a2c:	95 e0       	ldi	r25, 0x05	; 5
    6a2e:	32 ce       	rjmp	.-924    	; 0x6694 <printPgmString>
    6a30:	08 95       	ret

00006a32 <report_util_feedback_line_feed>:
    6a32:	8d e5       	ldi	r24, 0x5D	; 93
    6a34:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    6a38:	f8 cf       	rjmp	.-16     	; 0x6a2a <report_util_line_feed>
    6a3a:	08 95       	ret

00006a3c <report_util_axis_values>:
    6a3c:	0f 93       	push	r16
    6a3e:	1f 93       	push	r17
    6a40:	cf 93       	push	r28
    6a42:	8c 01       	movw	r16, r24
    6a44:	c0 e0       	ldi	r28, 0x00	; 0
    6a46:	f8 01       	movw	r30, r16
    6a48:	61 91       	ld	r22, Z+
    6a4a:	71 91       	ld	r23, Z+
    6a4c:	81 91       	ld	r24, Z+
    6a4e:	91 91       	ld	r25, Z+
    6a50:	8f 01       	movw	r16, r30
    6a52:	92 df       	rcall	.-220    	; 0x6978 <printFloat_CoordValue>
    6a54:	c2 30       	cpi	r28, 0x02	; 2
    6a56:	18 f4       	brcc	.+6      	; 0x6a5e <report_util_axis_values+0x22>
    6a58:	8c e2       	ldi	r24, 0x2C	; 44
    6a5a:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    6a5e:	cf 5f       	subi	r28, 0xFF	; 255
    6a60:	c3 30       	cpi	r28, 0x03	; 3
    6a62:	89 f7       	brne	.-30     	; 0x6a46 <report_util_axis_values+0xa>
    6a64:	cf 91       	pop	r28
    6a66:	1f 91       	pop	r17
    6a68:	0f 91       	pop	r16
    6a6a:	08 95       	ret

00006a6c <report_util_setting_prefix>:
    6a6c:	cf 93       	push	r28
    6a6e:	c8 2f       	mov	r28, r24
    6a70:	84 e2       	ldi	r24, 0x24	; 36
    6a72:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    6a76:	8c 2f       	mov	r24, r28
    6a78:	1f de       	rcall	.-962    	; 0x66b8 <print_uint8_base10>
    6a7a:	8d e3       	ldi	r24, 0x3D	; 61
    6a7c:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    6a80:	cf 91       	pop	r28
    6a82:	08 95       	ret

00006a84 <report_util_uint8_setting>:
    6a84:	cf 93       	push	r28
    6a86:	c6 2f       	mov	r28, r22
    6a88:	f1 df       	rcall	.-30     	; 0x6a6c <report_util_setting_prefix>
    6a8a:	8c 2f       	mov	r24, r28
    6a8c:	15 de       	rcall	.-982    	; 0x66b8 <print_uint8_base10>
    6a8e:	cd df       	rcall	.-102    	; 0x6a2a <report_util_line_feed>
    6a90:	cf 91       	pop	r28
    6a92:	08 95       	ret

00006a94 <report_util_float_setting>:
    6a94:	cf 92       	push	r12
    6a96:	df 92       	push	r13
    6a98:	ef 92       	push	r14
    6a9a:	ff 92       	push	r15
    6a9c:	cf 93       	push	r28
    6a9e:	6a 01       	movw	r12, r20
    6aa0:	7b 01       	movw	r14, r22
    6aa2:	c2 2f       	mov	r28, r18
    6aa4:	e3 df       	rcall	.-58     	; 0x6a6c <report_util_setting_prefix>
    6aa6:	4c 2f       	mov	r20, r28
    6aa8:	c7 01       	movw	r24, r14
    6aaa:	b6 01       	movw	r22, r12
    6aac:	b4 de       	rcall	.-664    	; 0x6816 <printFloat>
    6aae:	bd df       	rcall	.-134    	; 0x6a2a <report_util_line_feed>
    6ab0:	cf 91       	pop	r28
    6ab2:	ff 90       	pop	r15
    6ab4:	ef 90       	pop	r14
    6ab6:	df 90       	pop	r13
    6ab8:	cf 90       	pop	r12
    6aba:	08 95       	ret

00006abc <report_status_message>:
    6abc:	cf 93       	push	r28
    6abe:	c8 2f       	mov	r28, r24
    6ac0:	81 11       	cpse	r24, r1
    6ac2:	04 c0       	rjmp	.+8      	; 0x6acc <report_status_message+0x10>
    6ac4:	86 e2       	ldi	r24, 0x26	; 38
    6ac6:	95 e0       	ldi	r25, 0x05	; 5
    6ac8:	e5 dd       	rcall	.-1078   	; 0x6694 <printPgmString>
    6aca:	06 c0       	rjmp	.+12     	; 0x6ad8 <report_status_message+0x1c>
    6acc:	8f e1       	ldi	r24, 0x1F	; 31
    6ace:	95 e0       	ldi	r25, 0x05	; 5
    6ad0:	e1 dd       	rcall	.-1086   	; 0x6694 <printPgmString>
    6ad2:	8c 2f       	mov	r24, r28
    6ad4:	f1 dd       	rcall	.-1054   	; 0x66b8 <print_uint8_base10>
    6ad6:	a9 df       	rcall	.-174    	; 0x6a2a <report_util_line_feed>
    6ad8:	cf 91       	pop	r28
    6ada:	08 95       	ret

00006adc <report_alarm_message>:
    6adc:	cf 93       	push	r28
    6ade:	c8 2f       	mov	r28, r24
    6ae0:	85 e1       	ldi	r24, 0x15	; 21
    6ae2:	95 e0       	ldi	r25, 0x05	; 5
    6ae4:	d7 dd       	rcall	.-1106   	; 0x6694 <printPgmString>
    6ae6:	8c 2f       	mov	r24, r28
    6ae8:	e7 dd       	rcall	.-1074   	; 0x66b8 <print_uint8_base10>
    6aea:	9f df       	rcall	.-194    	; 0x6a2a <report_util_line_feed>
    6aec:	84 ef       	ldi	r24, 0xF4	; 244
    6aee:	91 e0       	ldi	r25, 0x01	; 1
    6af0:	b7 d9       	rcall	.-3218   	; 0x5e60 <delay_ms>
    6af2:	cf 91       	pop	r28
    6af4:	08 95       	ret

00006af6 <report_synchronization_state>:
    6af6:	80 e1       	ldi	r24, 0x10	; 16
    6af8:	95 e0       	ldi	r25, 0x05	; 5
    6afa:	cc dd       	rcall	.-1128   	; 0x6694 <printPgmString>
    6afc:	60 91 55 0c 	lds	r22, 0x0C55	; 0x800c55 <sys_index_pulse_count>
    6b00:	70 e0       	ldi	r23, 0x00	; 0
    6b02:	80 e0       	ldi	r24, 0x00	; 0
    6b04:	90 e0       	ldi	r25, 0x00	; 0
    6b06:	17 de       	rcall	.-978    	; 0x6736 <print_uint32_base10>
    6b08:	8a e0       	ldi	r24, 0x0A	; 10
    6b0a:	95 e0       	ldi	r25, 0x05	; 5
    6b0c:	c3 dd       	rcall	.-1146   	; 0x6694 <printPgmString>
    6b0e:	60 91 15 0c 	lds	r22, 0x0C15	; 0x800c15 <sys_synchronization_pulse_count>
    6b12:	70 91 16 0c 	lds	r23, 0x0C16	; 0x800c16 <sys_synchronization_pulse_count+0x1>
    6b16:	80 91 17 0c 	lds	r24, 0x0C17	; 0x800c17 <sys_synchronization_pulse_count+0x2>
    6b1a:	90 91 18 0c 	lds	r25, 0x0C18	; 0x800c18 <sys_synchronization_pulse_count+0x3>
    6b1e:	0b de       	rcall	.-1002   	; 0x6736 <print_uint32_base10>
    6b20:	84 e0       	ldi	r24, 0x04	; 4
    6b22:	95 e0       	ldi	r25, 0x05	; 5
    6b24:	b7 dd       	rcall	.-1170   	; 0x6694 <printPgmString>
    6b26:	60 91 1a 0c 	lds	r22, 0x0C1A	; 0x800c1a <sys_sync_time_passed>
    6b2a:	70 91 1b 0c 	lds	r23, 0x0C1B	; 0x800c1b <sys_sync_time_passed+0x1>
    6b2e:	80 91 1c 0c 	lds	r24, 0x0C1C	; 0x800c1c <sys_sync_time_passed+0x2>
    6b32:	90 91 1d 0c 	lds	r25, 0x0C1D	; 0x800c1d <sys_sync_time_passed+0x3>
    6b36:	ff dd       	rcall	.-1026   	; 0x6736 <print_uint32_base10>
    6b38:	78 cf       	rjmp	.-272    	; 0x6a2a <report_util_line_feed>
    6b3a:	08 95       	ret

00006b3c <report_feedback_message>:
    6b3c:	cf 93       	push	r28
    6b3e:	c8 2f       	mov	r28, r24
    6b40:	8e ef       	ldi	r24, 0xFE	; 254
    6b42:	94 e0       	ldi	r25, 0x04	; 4
    6b44:	a7 dd       	rcall	.-1202   	; 0x6694 <printPgmString>
    6b46:	8c 2f       	mov	r24, r28
    6b48:	90 e0       	ldi	r25, 0x00	; 0
    6b4a:	fc 01       	movw	r30, r24
    6b4c:	31 97       	sbiw	r30, 0x01	; 1
    6b4e:	eb 30       	cpi	r30, 0x0B	; 11
    6b50:	f1 05       	cpc	r31, r1
    6b52:	88 f5       	brcc	.+98     	; 0x6bb6 <report_feedback_message+0x7a>
    6b54:	88 27       	eor	r24, r24
    6b56:	ec 5b       	subi	r30, 0xBC	; 188
    6b58:	fe 4f       	sbci	r31, 0xFE	; 254
    6b5a:	8f 4f       	sbci	r24, 0xFF	; 255
    6b5c:	0c 94 b6 42 	jmp	0x856c	; 0x856c <__tablejump2__>
    6b60:	8c ee       	ldi	r24, 0xEC	; 236
    6b62:	94 e0       	ldi	r25, 0x04	; 4
    6b64:	97 dd       	rcall	.-1234   	; 0x6694 <printPgmString>
    6b66:	27 c0       	rjmp	.+78     	; 0x6bb6 <report_feedback_message+0x7a>
    6b68:	88 ed       	ldi	r24, 0xD8	; 216
    6b6a:	94 e0       	ldi	r25, 0x04	; 4
    6b6c:	93 dd       	rcall	.-1242   	; 0x6694 <printPgmString>
    6b6e:	23 c0       	rjmp	.+70     	; 0x6bb6 <report_feedback_message+0x7a>
    6b70:	86 ec       	ldi	r24, 0xC6	; 198
    6b72:	94 e0       	ldi	r25, 0x04	; 4
    6b74:	8f dd       	rcall	.-1250   	; 0x6694 <printPgmString>
    6b76:	1f c0       	rjmp	.+62     	; 0x6bb6 <report_feedback_message+0x7a>
    6b78:	8e eb       	ldi	r24, 0xBE	; 190
    6b7a:	94 e0       	ldi	r25, 0x04	; 4
    6b7c:	8b dd       	rcall	.-1258   	; 0x6694 <printPgmString>
    6b7e:	1b c0       	rjmp	.+54     	; 0x6bb6 <report_feedback_message+0x7a>
    6b80:	85 eb       	ldi	r24, 0xB5	; 181
    6b82:	94 e0       	ldi	r25, 0x04	; 4
    6b84:	87 dd       	rcall	.-1266   	; 0x6694 <printPgmString>
    6b86:	17 c0       	rjmp	.+46     	; 0x6bb6 <report_feedback_message+0x7a>
    6b88:	8a ea       	ldi	r24, 0xAA	; 170
    6b8a:	94 e0       	ldi	r25, 0x04	; 4
    6b8c:	83 dd       	rcall	.-1274   	; 0x6694 <printPgmString>
    6b8e:	13 c0       	rjmp	.+38     	; 0x6bb6 <report_feedback_message+0x7a>
    6b90:	8d e9       	ldi	r24, 0x9D	; 157
    6b92:	94 e0       	ldi	r25, 0x04	; 4
    6b94:	7f dd       	rcall	.-1282   	; 0x6694 <printPgmString>
    6b96:	0f c0       	rjmp	.+30     	; 0x6bb6 <report_feedback_message+0x7a>
    6b98:	85 e9       	ldi	r24, 0x95	; 149
    6b9a:	94 e0       	ldi	r25, 0x04	; 4
    6b9c:	7b dd       	rcall	.-1290   	; 0x6694 <printPgmString>
    6b9e:	0b c0       	rjmp	.+22     	; 0x6bb6 <report_feedback_message+0x7a>
    6ba0:	82 e8       	ldi	r24, 0x82	; 130
    6ba2:	94 e0       	ldi	r25, 0x04	; 4
    6ba4:	77 dd       	rcall	.-1298   	; 0x6694 <printPgmString>
    6ba6:	07 c0       	rjmp	.+14     	; 0x6bb6 <report_feedback_message+0x7a>
    6ba8:	80 e7       	ldi	r24, 0x70	; 112
    6baa:	94 e0       	ldi	r25, 0x04	; 4
    6bac:	73 dd       	rcall	.-1306   	; 0x6694 <printPgmString>
    6bae:	03 c0       	rjmp	.+6      	; 0x6bb6 <report_feedback_message+0x7a>
    6bb0:	87 e6       	ldi	r24, 0x67	; 103
    6bb2:	94 e0       	ldi	r25, 0x04	; 4
    6bb4:	6f dd       	rcall	.-1314   	; 0x6694 <printPgmString>
    6bb6:	3d df       	rcall	.-390    	; 0x6a32 <report_util_feedback_line_feed>
    6bb8:	cf 91       	pop	r28
    6bba:	08 95       	ret

00006bbc <report_init_message>:
    6bbc:	8a e4       	ldi	r24, 0x4A	; 74
    6bbe:	94 e0       	ldi	r25, 0x04	; 4
    6bc0:	69 cd       	rjmp	.-1326   	; 0x6694 <printPgmString>
    6bc2:	08 95       	ret

00006bc4 <report_grbl_help>:
    6bc4:	80 e0       	ldi	r24, 0x00	; 0
    6bc6:	94 e0       	ldi	r25, 0x04	; 4
    6bc8:	65 cd       	rjmp	.-1334   	; 0x6694 <printPgmString>
    6bca:	08 95       	ret

00006bcc <report_grbl_settings>:
    6bcc:	ef 92       	push	r14
    6bce:	ff 92       	push	r15
    6bd0:	0f 93       	push	r16
    6bd2:	1f 93       	push	r17
    6bd4:	cf 93       	push	r28
    6bd6:	df 93       	push	r29
    6bd8:	00 ed       	ldi	r16, 0xD0	; 208
    6bda:	1e e0       	ldi	r17, 0x0E	; 14
    6bdc:	f8 01       	movw	r30, r16
    6bde:	60 a9       	ldd	r22, Z+48	; 0x30
    6be0:	70 e0       	ldi	r23, 0x00	; 0
    6be2:	80 e0       	ldi	r24, 0x00	; 0
    6be4:	4f df       	rcall	.-354    	; 0x6a84 <report_util_uint8_setting>
    6be6:	f8 01       	movw	r30, r16
    6be8:	63 a9       	ldd	r22, Z+51	; 0x33
    6bea:	70 e0       	ldi	r23, 0x00	; 0
    6bec:	81 e0       	ldi	r24, 0x01	; 1
    6bee:	4a df       	rcall	.-364    	; 0x6a84 <report_util_uint8_setting>
    6bf0:	f8 01       	movw	r30, r16
    6bf2:	61 a9       	ldd	r22, Z+49	; 0x31
    6bf4:	70 e0       	ldi	r23, 0x00	; 0
    6bf6:	82 e0       	ldi	r24, 0x02	; 2
    6bf8:	45 df       	rcall	.-374    	; 0x6a84 <report_util_uint8_setting>
    6bfa:	f8 01       	movw	r30, r16
    6bfc:	62 a9       	ldd	r22, Z+50	; 0x32
    6bfe:	70 e0       	ldi	r23, 0x00	; 0
    6c00:	83 e0       	ldi	r24, 0x03	; 3
    6c02:	40 df       	rcall	.-384    	; 0x6a84 <report_util_uint8_setting>
    6c04:	c5 e1       	ldi	r28, 0x15	; 21
    6c06:	df e0       	ldi	r29, 0x0F	; 15
    6c08:	68 81       	ld	r22, Y
    6c0a:	62 fb       	bst	r22, 2
    6c0c:	66 27       	eor	r22, r22
    6c0e:	60 f9       	bld	r22, 0
    6c10:	70 e0       	ldi	r23, 0x00	; 0
    6c12:	84 e0       	ldi	r24, 0x04	; 4
    6c14:	37 df       	rcall	.-402    	; 0x6a84 <report_util_uint8_setting>
    6c16:	68 81       	ld	r22, Y
    6c18:	66 fb       	bst	r22, 6
    6c1a:	66 27       	eor	r22, r22
    6c1c:	60 f9       	bld	r22, 0
    6c1e:	70 e0       	ldi	r23, 0x00	; 0
    6c20:	85 e0       	ldi	r24, 0x05	; 5
    6c22:	30 df       	rcall	.-416    	; 0x6a84 <report_util_uint8_setting>
    6c24:	88 81       	ld	r24, Y
    6c26:	08 2e       	mov	r0, r24
    6c28:	00 0c       	add	r0, r0
    6c2a:	99 0b       	sbc	r25, r25
    6c2c:	69 2f       	mov	r22, r25
    6c2e:	66 1f       	adc	r22, r22
    6c30:	66 27       	eor	r22, r22
    6c32:	66 1f       	adc	r22, r22
    6c34:	70 e0       	ldi	r23, 0x00	; 0
    6c36:	86 e0       	ldi	r24, 0x06	; 6
    6c38:	25 df       	rcall	.-438    	; 0x6a84 <report_util_uint8_setting>
    6c3a:	f8 01       	movw	r30, r16
    6c3c:	64 a9       	ldd	r22, Z+52	; 0x34
    6c3e:	70 e0       	ldi	r23, 0x00	; 0
    6c40:	8a e0       	ldi	r24, 0x0A	; 10
    6c42:	20 df       	rcall	.-448    	; 0x6a84 <report_util_uint8_setting>
    6c44:	f8 01       	movw	r30, r16
    6c46:	45 a9       	ldd	r20, Z+53	; 0x35
    6c48:	56 a9       	ldd	r21, Z+54	; 0x36
    6c4a:	67 a9       	ldd	r22, Z+55	; 0x37
    6c4c:	70 ad       	ldd	r23, Z+56	; 0x38
    6c4e:	23 e0       	ldi	r18, 0x03	; 3
    6c50:	8b e0       	ldi	r24, 0x0B	; 11
    6c52:	20 df       	rcall	.-448    	; 0x6a94 <report_util_float_setting>
    6c54:	f8 01       	movw	r30, r16
    6c56:	41 ad       	ldd	r20, Z+57	; 0x39
    6c58:	52 ad       	ldd	r21, Z+58	; 0x3a
    6c5a:	63 ad       	ldd	r22, Z+59	; 0x3b
    6c5c:	74 ad       	ldd	r23, Z+60	; 0x3c
    6c5e:	23 e0       	ldi	r18, 0x03	; 3
    6c60:	8c e0       	ldi	r24, 0x0C	; 12
    6c62:	18 df       	rcall	.-464    	; 0x6a94 <report_util_float_setting>
    6c64:	68 81       	ld	r22, Y
    6c66:	61 70       	andi	r22, 0x01	; 1
    6c68:	70 e0       	ldi	r23, 0x00	; 0
    6c6a:	8d e0       	ldi	r24, 0x0D	; 13
    6c6c:	0b df       	rcall	.-490    	; 0x6a84 <report_util_uint8_setting>
    6c6e:	68 81       	ld	r22, Y
    6c70:	65 fb       	bst	r22, 5
    6c72:	66 27       	eor	r22, r22
    6c74:	60 f9       	bld	r22, 0
    6c76:	70 e0       	ldi	r23, 0x00	; 0
    6c78:	84 e1       	ldi	r24, 0x14	; 20
    6c7a:	04 df       	rcall	.-504    	; 0x6a84 <report_util_uint8_setting>
    6c7c:	68 81       	ld	r22, Y
    6c7e:	63 fb       	bst	r22, 3
    6c80:	66 27       	eor	r22, r22
    6c82:	60 f9       	bld	r22, 0
    6c84:	70 e0       	ldi	r23, 0x00	; 0
    6c86:	85 e1       	ldi	r24, 0x15	; 21
    6c88:	fd de       	rcall	.-518    	; 0x6a84 <report_util_uint8_setting>
    6c8a:	68 81       	ld	r22, Y
    6c8c:	62 95       	swap	r22
    6c8e:	61 70       	andi	r22, 0x01	; 1
    6c90:	70 e0       	ldi	r23, 0x00	; 0
    6c92:	86 e1       	ldi	r24, 0x16	; 22
    6c94:	f7 de       	rcall	.-530    	; 0x6a84 <report_util_uint8_setting>
    6c96:	60 91 16 0f 	lds	r22, 0x0F16	; 0x800f16 <settings+0x46>
    6c9a:	70 e0       	ldi	r23, 0x00	; 0
    6c9c:	87 e1       	ldi	r24, 0x17	; 23
    6c9e:	f2 de       	rcall	.-540    	; 0x6a84 <report_util_uint8_setting>
    6ca0:	40 91 17 0f 	lds	r20, 0x0F17	; 0x800f17 <settings+0x47>
    6ca4:	50 91 18 0f 	lds	r21, 0x0F18	; 0x800f18 <settings+0x48>
    6ca8:	60 91 19 0f 	lds	r22, 0x0F19	; 0x800f19 <settings+0x49>
    6cac:	70 91 1a 0f 	lds	r23, 0x0F1A	; 0x800f1a <settings+0x4a>
    6cb0:	23 e0       	ldi	r18, 0x03	; 3
    6cb2:	88 e1       	ldi	r24, 0x18	; 24
    6cb4:	ef de       	rcall	.-546    	; 0x6a94 <report_util_float_setting>
    6cb6:	40 91 1b 0f 	lds	r20, 0x0F1B	; 0x800f1b <settings+0x4b>
    6cba:	50 91 1c 0f 	lds	r21, 0x0F1C	; 0x800f1c <settings+0x4c>
    6cbe:	60 91 1d 0f 	lds	r22, 0x0F1D	; 0x800f1d <settings+0x4d>
    6cc2:	70 91 1e 0f 	lds	r23, 0x0F1E	; 0x800f1e <settings+0x4e>
    6cc6:	23 e0       	ldi	r18, 0x03	; 3
    6cc8:	89 e1       	ldi	r24, 0x19	; 25
    6cca:	e4 de       	rcall	.-568    	; 0x6a94 <report_util_float_setting>
    6ccc:	60 91 1f 0f 	lds	r22, 0x0F1F	; 0x800f1f <settings+0x4f>
    6cd0:	70 91 20 0f 	lds	r23, 0x0F20	; 0x800f20 <settings+0x50>
    6cd4:	8a e1       	ldi	r24, 0x1A	; 26
    6cd6:	d6 de       	rcall	.-596    	; 0x6a84 <report_util_uint8_setting>
    6cd8:	40 91 21 0f 	lds	r20, 0x0F21	; 0x800f21 <settings+0x51>
    6cdc:	50 91 22 0f 	lds	r21, 0x0F22	; 0x800f22 <settings+0x52>
    6ce0:	60 91 23 0f 	lds	r22, 0x0F23	; 0x800f23 <settings+0x53>
    6ce4:	70 91 24 0f 	lds	r23, 0x0F24	; 0x800f24 <settings+0x54>
    6ce8:	23 e0       	ldi	r18, 0x03	; 3
    6cea:	8b e1       	ldi	r24, 0x1B	; 27
    6cec:	d3 de       	rcall	.-602    	; 0x6a94 <report_util_float_setting>
    6cee:	40 91 0d 0f 	lds	r20, 0x0F0D	; 0x800f0d <settings+0x3d>
    6cf2:	50 91 0e 0f 	lds	r21, 0x0F0E	; 0x800f0e <settings+0x3e>
    6cf6:	60 91 0f 0f 	lds	r22, 0x0F0F	; 0x800f0f <settings+0x3f>
    6cfa:	70 91 10 0f 	lds	r23, 0x0F10	; 0x800f10 <settings+0x40>
    6cfe:	20 e0       	ldi	r18, 0x00	; 0
    6d00:	8e e1       	ldi	r24, 0x1E	; 30
    6d02:	c8 de       	rcall	.-624    	; 0x6a94 <report_util_float_setting>
    6d04:	40 91 11 0f 	lds	r20, 0x0F11	; 0x800f11 <settings+0x41>
    6d08:	50 91 12 0f 	lds	r21, 0x0F12	; 0x800f12 <settings+0x42>
    6d0c:	60 91 13 0f 	lds	r22, 0x0F13	; 0x800f13 <settings+0x43>
    6d10:	70 91 14 0f 	lds	r23, 0x0F14	; 0x800f14 <settings+0x44>
    6d14:	20 e0       	ldi	r18, 0x00	; 0
    6d16:	8f e1       	ldi	r24, 0x1F	; 31
    6d18:	bd de       	rcall	.-646    	; 0x6a94 <report_util_float_setting>
    6d1a:	68 81       	ld	r22, Y
    6d1c:	66 95       	lsr	r22
    6d1e:	61 70       	andi	r22, 0x01	; 1
    6d20:	70 e0       	ldi	r23, 0x00	; 0
    6d22:	80 e2       	ldi	r24, 0x20	; 32
    6d24:	af de       	rcall	.-674    	; 0x6a84 <report_util_uint8_setting>
    6d26:	0f 2e       	mov	r0, r31
    6d28:	f4 e6       	ldi	r31, 0x64	; 100
    6d2a:	ff 2e       	mov	r15, r31
    6d2c:	f0 2d       	mov	r31, r0
    6d2e:	d0 e0       	ldi	r29, 0x00	; 0
    6d30:	3f c0       	rjmp	.+126    	; 0x6db0 <report_grbl_settings+0x1e4>
    6d32:	d1 30       	cpi	r29, 0x01	; 1
    6d34:	79 f0       	breq	.+30     	; 0x6d54 <report_grbl_settings+0x188>
    6d36:	28 f0       	brcs	.+10     	; 0x6d42 <report_grbl_settings+0x176>
    6d38:	d2 30       	cpi	r29, 0x02	; 2
    6d3a:	a9 f0       	breq	.+42     	; 0x6d66 <report_grbl_settings+0x19a>
    6d3c:	d3 30       	cpi	r29, 0x03	; 3
    6d3e:	21 f1       	breq	.+72     	; 0x6d88 <report_grbl_settings+0x1bc>
    6d40:	2c c0       	rjmp	.+88     	; 0x6d9a <report_grbl_settings+0x1ce>
    6d42:	f8 01       	movw	r30, r16
    6d44:	40 81       	ld	r20, Z
    6d46:	51 81       	ldd	r21, Z+1	; 0x01
    6d48:	62 81       	ldd	r22, Z+2	; 0x02
    6d4a:	73 81       	ldd	r23, Z+3	; 0x03
    6d4c:	23 e0       	ldi	r18, 0x03	; 3
    6d4e:	8c 2f       	mov	r24, r28
    6d50:	a1 de       	rcall	.-702    	; 0x6a94 <report_util_float_setting>
    6d52:	23 c0       	rjmp	.+70     	; 0x6d9a <report_grbl_settings+0x1ce>
    6d54:	f8 01       	movw	r30, r16
    6d56:	44 85       	ldd	r20, Z+12	; 0x0c
    6d58:	55 85       	ldd	r21, Z+13	; 0x0d
    6d5a:	66 85       	ldd	r22, Z+14	; 0x0e
    6d5c:	77 85       	ldd	r23, Z+15	; 0x0f
    6d5e:	23 e0       	ldi	r18, 0x03	; 3
    6d60:	8c 2f       	mov	r24, r28
    6d62:	98 de       	rcall	.-720    	; 0x6a94 <report_util_float_setting>
    6d64:	1a c0       	rjmp	.+52     	; 0x6d9a <report_grbl_settings+0x1ce>
    6d66:	20 e0       	ldi	r18, 0x00	; 0
    6d68:	30 e0       	ldi	r19, 0x00	; 0
    6d6a:	41 e6       	ldi	r20, 0x61	; 97
    6d6c:	55 e4       	ldi	r21, 0x45	; 69
    6d6e:	f8 01       	movw	r30, r16
    6d70:	60 8d       	ldd	r22, Z+24	; 0x18
    6d72:	71 8d       	ldd	r23, Z+25	; 0x19
    6d74:	82 8d       	ldd	r24, Z+26	; 0x1a
    6d76:	93 8d       	ldd	r25, Z+27	; 0x1b
    6d78:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <__divsf3>
    6d7c:	ab 01       	movw	r20, r22
    6d7e:	bc 01       	movw	r22, r24
    6d80:	23 e0       	ldi	r18, 0x03	; 3
    6d82:	8c 2f       	mov	r24, r28
    6d84:	87 de       	rcall	.-754    	; 0x6a94 <report_util_float_setting>
    6d86:	09 c0       	rjmp	.+18     	; 0x6d9a <report_grbl_settings+0x1ce>
    6d88:	f8 01       	movw	r30, r16
    6d8a:	44 a1       	ldd	r20, Z+36	; 0x24
    6d8c:	55 a1       	ldd	r21, Z+37	; 0x25
    6d8e:	66 a1       	ldd	r22, Z+38	; 0x26
    6d90:	77 a1       	ldd	r23, Z+39	; 0x27
    6d92:	70 58       	subi	r23, 0x80	; 128
    6d94:	23 e0       	ldi	r18, 0x03	; 3
    6d96:	8c 2f       	mov	r24, r28
    6d98:	7d de       	rcall	.-774    	; 0x6a94 <report_util_float_setting>
    6d9a:	0c 5f       	subi	r16, 0xFC	; 252
    6d9c:	1f 4f       	sbci	r17, 0xFF	; 255
    6d9e:	cf 5f       	subi	r28, 0xFF	; 255
    6da0:	ce 11       	cpse	r28, r14
    6da2:	c7 cf       	rjmp	.-114    	; 0x6d32 <report_grbl_settings+0x166>
    6da4:	fa e0       	ldi	r31, 0x0A	; 10
    6da6:	ff 0e       	add	r15, r31
    6da8:	df 5f       	subi	r29, 0xFF	; 255
    6daa:	8c e8       	ldi	r24, 0x8C	; 140
    6dac:	f8 16       	cp	r15, r24
    6dae:	49 f0       	breq	.+18     	; 0x6dc2 <report_grbl_settings+0x1f6>
    6db0:	00 ed       	ldi	r16, 0xD0	; 208
    6db2:	1e e0       	ldi	r17, 0x0E	; 14
    6db4:	0f 2e       	mov	r0, r31
    6db6:	f3 e0       	ldi	r31, 0x03	; 3
    6db8:	ef 2e       	mov	r14, r31
    6dba:	f0 2d       	mov	r31, r0
    6dbc:	ef 0c       	add	r14, r15
    6dbe:	cf 2d       	mov	r28, r15
    6dc0:	b8 cf       	rjmp	.-144    	; 0x6d32 <report_grbl_settings+0x166>
    6dc2:	df 91       	pop	r29
    6dc4:	cf 91       	pop	r28
    6dc6:	1f 91       	pop	r17
    6dc8:	0f 91       	pop	r16
    6dca:	ff 90       	pop	r15
    6dcc:	ef 90       	pop	r14
    6dce:	08 95       	ret

00006dd0 <report_probe_parameters>:
    6dd0:	cf 93       	push	r28
    6dd2:	df 93       	push	r29
    6dd4:	cd b7       	in	r28, 0x3d	; 61
    6dd6:	de b7       	in	r29, 0x3e	; 62
    6dd8:	2c 97       	sbiw	r28, 0x0c	; 12
    6dda:	0f b6       	in	r0, 0x3f	; 63
    6ddc:	f8 94       	cli
    6dde:	de bf       	out	0x3e, r29	; 62
    6de0:	0f be       	out	0x3f, r0	; 63
    6de2:	cd bf       	out	0x3d, r28	; 61
    6de4:	8a ef       	ldi	r24, 0xFA	; 250
    6de6:	93 e0       	ldi	r25, 0x03	; 3
    6de8:	55 dc       	rcall	.-1878   	; 0x6694 <printPgmString>
    6dea:	67 e3       	ldi	r22, 0x37	; 55
    6dec:	7c e0       	ldi	r23, 0x0C	; 12
    6dee:	ce 01       	movw	r24, r28
    6df0:	01 96       	adiw	r24, 0x01	; 1
    6df2:	20 d4       	rcall	.+2112   	; 0x7634 <system_convert_array_steps_to_mpos>
    6df4:	ce 01       	movw	r24, r28
    6df6:	01 96       	adiw	r24, 0x01	; 1
    6df8:	21 de       	rcall	.-958    	; 0x6a3c <report_util_axis_values>
    6dfa:	8a e3       	ldi	r24, 0x3A	; 58
    6dfc:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    6e00:	80 91 23 0c 	lds	r24, 0x0C23	; 0x800c23 <sys+0x5>
    6e04:	59 dc       	rcall	.-1870   	; 0x66b8 <print_uint8_base10>
    6e06:	15 de       	rcall	.-982    	; 0x6a32 <report_util_feedback_line_feed>
    6e08:	2c 96       	adiw	r28, 0x0c	; 12
    6e0a:	0f b6       	in	r0, 0x3f	; 63
    6e0c:	f8 94       	cli
    6e0e:	de bf       	out	0x3e, r29	; 62
    6e10:	0f be       	out	0x3f, r0	; 63
    6e12:	cd bf       	out	0x3d, r28	; 61
    6e14:	df 91       	pop	r29
    6e16:	cf 91       	pop	r28
    6e18:	08 95       	ret

00006e1a <report_ngc_parameters>:
    6e1a:	0f 93       	push	r16
    6e1c:	1f 93       	push	r17
    6e1e:	cf 93       	push	r28
    6e20:	df 93       	push	r29
    6e22:	cd b7       	in	r28, 0x3d	; 61
    6e24:	de b7       	in	r29, 0x3e	; 62
    6e26:	2c 97       	sbiw	r28, 0x0c	; 12
    6e28:	0f b6       	in	r0, 0x3f	; 63
    6e2a:	f8 94       	cli
    6e2c:	de bf       	out	0x3e, r29	; 62
    6e2e:	0f be       	out	0x3f, r0	; 63
    6e30:	cd bf       	out	0x3d, r28	; 61
    6e32:	01 e0       	ldi	r16, 0x01	; 1
    6e34:	01 c0       	rjmp	.+2      	; 0x6e38 <report_ngc_parameters+0x1e>
    6e36:	0f 5f       	subi	r16, 0xFF	; 255
    6e38:	1f ef       	ldi	r17, 0xFF	; 255
    6e3a:	10 0f       	add	r17, r16
    6e3c:	be 01       	movw	r22, r28
    6e3e:	6f 5f       	subi	r22, 0xFF	; 255
    6e40:	7f 4f       	sbci	r23, 0xFF	; 255
    6e42:	81 2f       	mov	r24, r17
    6e44:	0e 94 1a 26 	call	0x4c34	; 0x4c34 <settings_read_coord_data>
    6e48:	81 11       	cpse	r24, r1
    6e4a:	03 c0       	rjmp	.+6      	; 0x6e52 <report_ngc_parameters+0x38>
    6e4c:	87 e0       	ldi	r24, 0x07	; 7
    6e4e:	36 de       	rcall	.-916    	; 0x6abc <report_status_message>
    6e50:	40 c0       	rjmp	.+128    	; 0x6ed2 <report_ngc_parameters+0xb8>
    6e52:	87 ef       	ldi	r24, 0xF7	; 247
    6e54:	93 e0       	ldi	r25, 0x03	; 3
    6e56:	1e dc       	rcall	.-1988   	; 0x6694 <printPgmString>
    6e58:	16 30       	cpi	r17, 0x06	; 6
    6e5a:	19 f0       	breq	.+6      	; 0x6e62 <report_ngc_parameters+0x48>
    6e5c:	17 30       	cpi	r17, 0x07	; 7
    6e5e:	61 f0       	breq	.+24     	; 0x6e78 <report_ngc_parameters+0x5e>
    6e60:	16 c0       	rjmp	.+44     	; 0x6e8e <report_ngc_parameters+0x74>
    6e62:	84 ef       	ldi	r24, 0xF4	; 244
    6e64:	93 e0       	ldi	r25, 0x03	; 3
    6e66:	16 dc       	rcall	.-2004   	; 0x6694 <printPgmString>
    6e68:	8a e3       	ldi	r24, 0x3A	; 58
    6e6a:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    6e6e:	ce 01       	movw	r24, r28
    6e70:	01 96       	adiw	r24, 0x01	; 1
    6e72:	e4 dd       	rcall	.-1080   	; 0x6a3c <report_util_axis_values>
    6e74:	de dd       	rcall	.-1092   	; 0x6a32 <report_util_feedback_line_feed>
    6e76:	df cf       	rjmp	.-66     	; 0x6e36 <report_ngc_parameters+0x1c>
    6e78:	81 ef       	ldi	r24, 0xF1	; 241
    6e7a:	93 e0       	ldi	r25, 0x03	; 3
    6e7c:	0b dc       	rcall	.-2026   	; 0x6694 <printPgmString>
    6e7e:	8a e3       	ldi	r24, 0x3A	; 58
    6e80:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    6e84:	ce 01       	movw	r24, r28
    6e86:	01 96       	adiw	r24, 0x01	; 1
    6e88:	d9 dd       	rcall	.-1102   	; 0x6a3c <report_util_axis_values>
    6e8a:	d3 dd       	rcall	.-1114   	; 0x6a32 <report_util_feedback_line_feed>
    6e8c:	0d c0       	rjmp	.+26     	; 0x6ea8 <report_ngc_parameters+0x8e>
    6e8e:	85 e3       	ldi	r24, 0x35	; 53
    6e90:	80 0f       	add	r24, r16
    6e92:	12 dc       	rcall	.-2012   	; 0x66b8 <print_uint8_base10>
    6e94:	8a e3       	ldi	r24, 0x3A	; 58
    6e96:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    6e9a:	ce 01       	movw	r24, r28
    6e9c:	01 96       	adiw	r24, 0x01	; 1
    6e9e:	ce dd       	rcall	.-1124   	; 0x6a3c <report_util_axis_values>
    6ea0:	c8 dd       	rcall	.-1136   	; 0x6a32 <report_util_feedback_line_feed>
    6ea2:	08 30       	cpi	r16, 0x08	; 8
    6ea4:	08 f4       	brcc	.+2      	; 0x6ea8 <report_ngc_parameters+0x8e>
    6ea6:	c7 cf       	rjmp	.-114    	; 0x6e36 <report_ngc_parameters+0x1c>
    6ea8:	8b ee       	ldi	r24, 0xEB	; 235
    6eaa:	93 e0       	ldi	r25, 0x03	; 3
    6eac:	f3 db       	rcall	.-2074   	; 0x6694 <printPgmString>
    6eae:	86 e8       	ldi	r24, 0x86	; 134
    6eb0:	9c e0       	ldi	r25, 0x0C	; 12
    6eb2:	c4 dd       	rcall	.-1144   	; 0x6a3c <report_util_axis_values>
    6eb4:	be dd       	rcall	.-1156   	; 0x6a32 <report_util_feedback_line_feed>
    6eb6:	85 ee       	ldi	r24, 0xE5	; 229
    6eb8:	93 e0       	ldi	r25, 0x03	; 3
    6eba:	ec db       	rcall	.-2088   	; 0x6694 <printPgmString>
    6ebc:	60 91 92 0c 	lds	r22, 0x0C92	; 0x800c92 <gc_state+0x3c>
    6ec0:	70 91 93 0c 	lds	r23, 0x0C93	; 0x800c93 <gc_state+0x3d>
    6ec4:	80 91 94 0c 	lds	r24, 0x0C94	; 0x800c94 <gc_state+0x3e>
    6ec8:	90 91 95 0c 	lds	r25, 0x0C95	; 0x800c95 <gc_state+0x3f>
    6ecc:	55 dd       	rcall	.-1366   	; 0x6978 <printFloat_CoordValue>
    6ece:	b1 dd       	rcall	.-1182   	; 0x6a32 <report_util_feedback_line_feed>
    6ed0:	7f df       	rcall	.-258    	; 0x6dd0 <report_probe_parameters>
    6ed2:	2c 96       	adiw	r28, 0x0c	; 12
    6ed4:	0f b6       	in	r0, 0x3f	; 63
    6ed6:	f8 94       	cli
    6ed8:	de bf       	out	0x3e, r29	; 62
    6eda:	0f be       	out	0x3f, r0	; 63
    6edc:	cd bf       	out	0x3d, r28	; 61
    6ede:	df 91       	pop	r29
    6ee0:	cf 91       	pop	r28
    6ee2:	1f 91       	pop	r17
    6ee4:	0f 91       	pop	r16
    6ee6:	08 95       	ret

00006ee8 <report_gcode_modes>:
    6ee8:	cf 93       	push	r28
    6eea:	df 93       	push	r29
    6eec:	8f ed       	ldi	r24, 0xDF	; 223
    6eee:	93 e0       	ldi	r25, 0x03	; 3
    6ef0:	d1 db       	rcall	.-2142   	; 0x6694 <printPgmString>
    6ef2:	80 91 56 0c 	lds	r24, 0x0C56	; 0x800c56 <gc_state>
    6ef6:	8c 38       	cpi	r24, 0x8C	; 140
    6ef8:	40 f0       	brcs	.+16     	; 0x6f0a <report_gcode_modes+0x22>
    6efa:	8b ed       	ldi	r24, 0xDB	; 219
    6efc:	93 e0       	ldi	r25, 0x03	; 3
    6efe:	ca db       	rcall	.-2156   	; 0x6694 <printPgmString>
    6f00:	80 91 56 0c 	lds	r24, 0x0C56	; 0x800c56 <gc_state>
    6f04:	8a 58       	subi	r24, 0x8A	; 138
    6f06:	d8 db       	rcall	.-2128   	; 0x66b8 <print_uint8_base10>
    6f08:	01 c0       	rjmp	.+2      	; 0x6f0c <report_gcode_modes+0x24>
    6f0a:	d6 db       	rcall	.-2132   	; 0x66b8 <print_uint8_base10>
    6f0c:	8f ec       	ldi	r24, 0xCF	; 207
    6f0e:	93 e0       	ldi	r25, 0x03	; 3
    6f10:	c1 db       	rcall	.-2174   	; 0x6694 <printPgmString>
    6f12:	c6 e5       	ldi	r28, 0x56	; 86
    6f14:	dc e0       	ldi	r29, 0x0C	; 12
    6f16:	8e 81       	ldd	r24, Y+6	; 0x06
    6f18:	8a 5c       	subi	r24, 0xCA	; 202
    6f1a:	ce db       	rcall	.-2148   	; 0x66b8 <print_uint8_base10>
    6f1c:	8f ec       	ldi	r24, 0xCF	; 207
    6f1e:	93 e0       	ldi	r25, 0x03	; 3
    6f20:	b9 db       	rcall	.-2190   	; 0x6694 <printPgmString>
    6f22:	8c 81       	ldd	r24, Y+4	; 0x04
    6f24:	8f 5e       	subi	r24, 0xEF	; 239
    6f26:	c8 db       	rcall	.-2160   	; 0x66b8 <print_uint8_base10>
    6f28:	8f ec       	ldi	r24, 0xCF	; 207
    6f2a:	93 e0       	ldi	r25, 0x03	; 3
    6f2c:	b3 db       	rcall	.-2202   	; 0x6694 <printPgmString>
    6f2e:	9a 81       	ldd	r25, Y+2	; 0x02
    6f30:	85 e1       	ldi	r24, 0x15	; 21
    6f32:	89 1b       	sub	r24, r25
    6f34:	c1 db       	rcall	.-2174   	; 0x66b8 <print_uint8_base10>
    6f36:	8f ec       	ldi	r24, 0xCF	; 207
    6f38:	93 e0       	ldi	r25, 0x03	; 3
    6f3a:	ac db       	rcall	.-2216   	; 0x6694 <printPgmString>
    6f3c:	8b 81       	ldd	r24, Y+3	; 0x03
    6f3e:	86 5a       	subi	r24, 0xA6	; 166
    6f40:	bb db       	rcall	.-2186   	; 0x66b8 <print_uint8_base10>
    6f42:	8f ec       	ldi	r24, 0xCF	; 207
    6f44:	93 e0       	ldi	r25, 0x03	; 3
    6f46:	a6 db       	rcall	.-2228   	; 0x6694 <printPgmString>
    6f48:	99 81       	ldd	r25, Y+1	; 0x01
    6f4a:	8e e5       	ldi	r24, 0x5E	; 94
    6f4c:	89 1b       	sub	r24, r25
    6f4e:	b4 db       	rcall	.-2200   	; 0x66b8 <print_uint8_base10>
    6f50:	8f 81       	ldd	r24, Y+7	; 0x07
    6f52:	88 23       	and	r24, r24
    6f54:	89 f0       	breq	.+34     	; 0x6f78 <report_gcode_modes+0x90>
    6f56:	8c ec       	ldi	r24, 0xCC	; 204
    6f58:	93 e0       	ldi	r25, 0x03	; 3
    6f5a:	9c db       	rcall	.-2248   	; 0x6694 <printPgmString>
    6f5c:	80 91 5d 0c 	lds	r24, 0x0C5D	; 0x800c5d <gc_state+0x7>
    6f60:	83 30       	cpi	r24, 0x03	; 3
    6f62:	29 f0       	breq	.+10     	; 0x6f6e <report_gcode_modes+0x86>
    6f64:	8e 31       	cpi	r24, 0x1E	; 30
    6f66:	39 f0       	breq	.+14     	; 0x6f76 <report_gcode_modes+0x8e>
    6f68:	82 30       	cpi	r24, 0x02	; 2
    6f6a:	31 f4       	brne	.+12     	; 0x6f78 <report_gcode_modes+0x90>
    6f6c:	04 c0       	rjmp	.+8      	; 0x6f76 <report_gcode_modes+0x8e>
    6f6e:	80 e3       	ldi	r24, 0x30	; 48
    6f70:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    6f74:	01 c0       	rjmp	.+2      	; 0x6f78 <report_gcode_modes+0x90>
    6f76:	a0 db       	rcall	.-2240   	; 0x66b8 <print_uint8_base10>
    6f78:	8c ec       	ldi	r24, 0xCC	; 204
    6f7a:	93 e0       	ldi	r25, 0x03	; 3
    6f7c:	8b db       	rcall	.-2282   	; 0x6694 <printPgmString>
    6f7e:	80 91 5f 0c 	lds	r24, 0x0C5F	; 0x800c5f <gc_state+0x9>
    6f82:	80 31       	cpi	r24, 0x10	; 16
    6f84:	29 f0       	breq	.+10     	; 0x6f90 <report_gcode_modes+0xa8>
    6f86:	80 32       	cpi	r24, 0x20	; 32
    6f88:	39 f0       	breq	.+14     	; 0x6f98 <report_gcode_modes+0xb0>
    6f8a:	81 11       	cpse	r24, r1
    6f8c:	0c c0       	rjmp	.+24     	; 0x6fa6 <report_gcode_modes+0xbe>
    6f8e:	08 c0       	rjmp	.+16     	; 0x6fa0 <report_gcode_modes+0xb8>
    6f90:	83 e3       	ldi	r24, 0x33	; 51
    6f92:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    6f96:	07 c0       	rjmp	.+14     	; 0x6fa6 <report_gcode_modes+0xbe>
    6f98:	84 e3       	ldi	r24, 0x34	; 52
    6f9a:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    6f9e:	03 c0       	rjmp	.+6      	; 0x6fa6 <report_gcode_modes+0xbe>
    6fa0:	85 e3       	ldi	r24, 0x35	; 53
    6fa2:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    6fa6:	8c ec       	ldi	r24, 0xCC	; 204
    6fa8:	93 e0       	ldi	r25, 0x03	; 3
    6faa:	74 db       	rcall	.-2328   	; 0x6694 <printPgmString>
    6fac:	80 91 5e 0c 	lds	r24, 0x0C5E	; 0x800c5e <gc_state+0x8>
    6fb0:	88 23       	and	r24, r24
    6fb2:	61 f0       	breq	.+24     	; 0x6fcc <report_gcode_modes+0xe4>
    6fb4:	1c f4       	brge	.+6      	; 0x6fbc <report_gcode_modes+0xd4>
    6fb6:	87 e3       	ldi	r24, 0x37	; 55
    6fb8:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    6fbc:	80 91 5e 0c 	lds	r24, 0x0C5E	; 0x800c5e <gc_state+0x8>
    6fc0:	86 ff       	sbrs	r24, 6
    6fc2:	07 c0       	rjmp	.+14     	; 0x6fd2 <report_gcode_modes+0xea>
    6fc4:	88 e3       	ldi	r24, 0x38	; 56
    6fc6:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    6fca:	03 c0       	rjmp	.+6      	; 0x6fd2 <report_gcode_modes+0xea>
    6fcc:	89 e3       	ldi	r24, 0x39	; 57
    6fce:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    6fd2:	88 ed       	ldi	r24, 0xD8	; 216
    6fd4:	93 e0       	ldi	r25, 0x03	; 3
    6fd6:	5e db       	rcall	.-2372   	; 0x6694 <printPgmString>
    6fd8:	c6 e5       	ldi	r28, 0x56	; 86
    6fda:	dc e0       	ldi	r29, 0x0C	; 12
    6fdc:	8b 89       	ldd	r24, Y+19	; 0x13
    6fde:	6c db       	rcall	.-2344   	; 0x66b8 <print_uint8_base10>
    6fe0:	85 ed       	ldi	r24, 0xD5	; 213
    6fe2:	93 e0       	ldi	r25, 0x03	; 3
    6fe4:	57 db       	rcall	.-2386   	; 0x6694 <printPgmString>
    6fe6:	6f 85       	ldd	r22, Y+15	; 0x0f
    6fe8:	78 89       	ldd	r23, Y+16	; 0x10
    6fea:	89 89       	ldd	r24, Y+17	; 0x11
    6fec:	9a 89       	ldd	r25, Y+18	; 0x12
    6fee:	d4 dc       	rcall	.-1624   	; 0x6998 <printFloat_RateValue>
    6ff0:	82 ed       	ldi	r24, 0xD2	; 210
    6ff2:	93 e0       	ldi	r25, 0x03	; 3
    6ff4:	4f db       	rcall	.-2402   	; 0x6694 <printPgmString>
    6ff6:	6b 85       	ldd	r22, Y+11	; 0x0b
    6ff8:	7c 85       	ldd	r23, Y+12	; 0x0c
    6ffa:	8d 85       	ldd	r24, Y+13	; 0x0d
    6ffc:	9e 85       	ldd	r25, Y+14	; 0x0e
    6ffe:	40 e0       	ldi	r20, 0x00	; 0
    7000:	0a dc       	rcall	.-2028   	; 0x6816 <printFloat>
    7002:	17 dd       	rcall	.-1490   	; 0x6a32 <report_util_feedback_line_feed>
    7004:	df 91       	pop	r29
    7006:	cf 91       	pop	r28
    7008:	08 95       	ret

0000700a <report_startup_line>:
    700a:	1f 93       	push	r17
    700c:	cf 93       	push	r28
    700e:	df 93       	push	r29
    7010:	18 2f       	mov	r17, r24
    7012:	eb 01       	movw	r28, r22
    7014:	89 ec       	ldi	r24, 0xC9	; 201
    7016:	93 e0       	ldi	r25, 0x03	; 3
    7018:	3d db       	rcall	.-2438   	; 0x6694 <printPgmString>
    701a:	81 2f       	mov	r24, r17
    701c:	4d db       	rcall	.-2406   	; 0x66b8 <print_uint8_base10>
    701e:	8d e3       	ldi	r24, 0x3D	; 61
    7020:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    7024:	ce 01       	movw	r24, r28
    7026:	27 db       	rcall	.-2482   	; 0x6676 <printString>
    7028:	00 dd       	rcall	.-1536   	; 0x6a2a <report_util_line_feed>
    702a:	df 91       	pop	r29
    702c:	cf 91       	pop	r28
    702e:	1f 91       	pop	r17
    7030:	08 95       	ret

00007032 <report_execute_startup_message>:
    7032:	0f 93       	push	r16
    7034:	1f 93       	push	r17
    7036:	cf 93       	push	r28
    7038:	8c 01       	movw	r16, r24
    703a:	c6 2f       	mov	r28, r22
    703c:	8e e3       	ldi	r24, 0x3E	; 62
    703e:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    7042:	c8 01       	movw	r24, r16
    7044:	18 db       	rcall	.-2512   	; 0x6676 <printString>
    7046:	8a e3       	ldi	r24, 0x3A	; 58
    7048:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    704c:	8c 2f       	mov	r24, r28
    704e:	36 dd       	rcall	.-1428   	; 0x6abc <report_status_message>
    7050:	cf 91       	pop	r28
    7052:	1f 91       	pop	r17
    7054:	0f 91       	pop	r16
    7056:	08 95       	ret

00007058 <report_build_info>:
    7058:	cf 93       	push	r28
    705a:	df 93       	push	r29
    705c:	ec 01       	movw	r28, r24
    705e:	80 eb       	ldi	r24, 0xB0	; 176
    7060:	93 e0       	ldi	r25, 0x03	; 3
    7062:	18 db       	rcall	.-2512   	; 0x6694 <printPgmString>
    7064:	ce 01       	movw	r24, r28
    7066:	07 db       	rcall	.-2546   	; 0x6676 <printString>
    7068:	e4 dc       	rcall	.-1592   	; 0x6a32 <report_util_feedback_line_feed>
    706a:	8a ea       	ldi	r24, 0xAA	; 170
    706c:	93 e0       	ldi	r25, 0x03	; 3
    706e:	12 db       	rcall	.-2524   	; 0x6694 <printPgmString>
    7070:	86 e5       	ldi	r24, 0x56	; 86
    7072:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    7076:	8e e4       	ldi	r24, 0x4E	; 78
    7078:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    707c:	8d e4       	ldi	r24, 0x4D	; 77
    707e:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    7082:	8b e2       	ldi	r24, 0x2B	; 43
    7084:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    7088:	88 e4       	ldi	r24, 0x48	; 72
    708a:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    708e:	83 e5       	ldi	r24, 0x53	; 83
    7090:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    7094:	8c e4       	ldi	r24, 0x4C	; 76
    7096:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    709a:	8c e2       	ldi	r24, 0x2C	; 44
    709c:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    70a0:	83 e2       	ldi	r24, 0x23	; 35
    70a2:	0a db       	rcall	.-2540   	; 0x66b8 <print_uint8_base10>
    70a4:	8c e2       	ldi	r24, 0x2C	; 44
    70a6:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    70aa:	8f ef       	ldi	r24, 0xFF	; 255
    70ac:	05 db       	rcall	.-2550   	; 0x66b8 <print_uint8_base10>
    70ae:	c1 dc       	rcall	.-1662   	; 0x6a32 <report_util_feedback_line_feed>
    70b0:	df 91       	pop	r29
    70b2:	cf 91       	pop	r28
    70b4:	08 95       	ret

000070b6 <report_realtime_status>:
 // and the actual location of the CNC machine. Users may change the following function to their
 // specific needs, but the desired real-time data report must be as short as possible. This is
 // requires as it minimizes the computational overhead and allows grbl to keep running smoothly,
 // especially during g-code programs with fast, short line segments and high frequency reports (5-20Hz).
void report_realtime_status()
{
    70b6:	4f 92       	push	r4
    70b8:	5f 92       	push	r5
    70ba:	6f 92       	push	r6
    70bc:	7f 92       	push	r7
    70be:	8f 92       	push	r8
    70c0:	9f 92       	push	r9
    70c2:	af 92       	push	r10
    70c4:	bf 92       	push	r11
    70c6:	cf 92       	push	r12
    70c8:	df 92       	push	r13
    70ca:	ef 92       	push	r14
    70cc:	ff 92       	push	r15
    70ce:	0f 93       	push	r16
    70d0:	1f 93       	push	r17
    70d2:	cf 93       	push	r28
    70d4:	df 93       	push	r29
    70d6:	cd b7       	in	r28, 0x3d	; 61
    70d8:	de b7       	in	r29, 0x3e	; 62
    70da:	a4 97       	sbiw	r28, 0x24	; 36
    70dc:	0f b6       	in	r0, 0x3f	; 63
    70de:	f8 94       	cli
    70e0:	de bf       	out	0x3e, r29	; 62
    70e2:	0f be       	out	0x3f, r0	; 63
    70e4:	cd bf       	out	0x3d, r28	; 61
  uint8_t idx;
  int32_t current_position[N_AXIS]; // Copy current state of the system position variable
  memcpy(current_position,sys_position,sizeof(sys_position));
    70e6:	8c e0       	ldi	r24, 0x0C	; 12
    70e8:	e3 e4       	ldi	r30, 0x43	; 67
    70ea:	fc e0       	ldi	r31, 0x0C	; 12
    70ec:	de 01       	movw	r26, r28
    70ee:	11 96       	adiw	r26, 0x01	; 1
    70f0:	01 90       	ld	r0, Z+
    70f2:	0d 92       	st	X+, r0
    70f4:	8a 95       	dec	r24
    70f6:	e1 f7       	brne	.-8      	; 0x70f0 <report_realtime_status+0x3a>
  float print_position[N_AXIS];
  system_convert_array_steps_to_mpos(print_position,current_position);
    70f8:	be 01       	movw	r22, r28
    70fa:	6f 5f       	subi	r22, 0xFF	; 255
    70fc:	7f 4f       	sbci	r23, 0xFF	; 255
    70fe:	ce 01       	movw	r24, r28
    7100:	0d 96       	adiw	r24, 0x0d	; 13
    7102:	98 d2       	rcall	.+1328   	; 0x7634 <system_convert_array_steps_to_mpos>

  // Report current machine state and sub-states
  serial_write('<');
    7104:	8c e3       	ldi	r24, 0x3C	; 60
    7106:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
  switch (sys.state) {
    710a:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    710e:	88 30       	cpi	r24, 0x08	; 8
    7110:	c9 f0       	breq	.+50     	; 0x7144 <report_realtime_status+0x8e>
    7112:	40 f4       	brcc	.+16     	; 0x7124 <report_realtime_status+0x6e>
    7114:	81 30       	cpi	r24, 0x01	; 1
    7116:	a9 f1       	breq	.+106    	; 0x7182 <report_realtime_status+0xcc>
    7118:	88 f0       	brcs	.+34     	; 0x713c <report_realtime_status+0x86>
    711a:	82 30       	cpi	r24, 0x02	; 2
    711c:	b1 f1       	breq	.+108    	; 0x718a <report_realtime_status+0xd4>
    711e:	84 30       	cpi	r24, 0x04	; 4
    7120:	61 f1       	breq	.+88     	; 0x717a <report_realtime_status+0xc4>
    7122:	55 c0       	rjmp	.+170    	; 0x71ce <report_realtime_status+0x118>
    7124:	80 32       	cpi	r24, 0x20	; 32
    7126:	29 f1       	breq	.+74     	; 0x7172 <report_realtime_status+0xbc>
    7128:	18 f4       	brcc	.+6      	; 0x7130 <report_realtime_status+0x7a>
    712a:	80 31       	cpi	r24, 0x10	; 16
    712c:	79 f0       	breq	.+30     	; 0x714c <report_realtime_status+0x96>
    712e:	4f c0       	rjmp	.+158    	; 0x71ce <report_realtime_status+0x118>
    7130:	80 34       	cpi	r24, 0x40	; 64
    7132:	79 f1       	breq	.+94     	; 0x7192 <report_realtime_status+0xdc>
    7134:	80 38       	cpi	r24, 0x80	; 128
    7136:	09 f4       	brne	.+2      	; 0x713a <report_realtime_status+0x84>
    7138:	47 c0       	rjmp	.+142    	; 0x71c8 <report_realtime_status+0x112>
    713a:	49 c0       	rjmp	.+146    	; 0x71ce <report_realtime_status+0x118>
    case STATE_IDLE: printPgmString(PSTR("Idle")); break;
    713c:	85 ea       	ldi	r24, 0xA5	; 165
    713e:	93 e0       	ldi	r25, 0x03	; 3
    7140:	a9 da       	rcall	.-2734   	; 0x6694 <printPgmString>
    7142:	45 c0       	rjmp	.+138    	; 0x71ce <report_realtime_status+0x118>
    case STATE_CYCLE: printPgmString(PSTR("Run")); break;
    7144:	81 ea       	ldi	r24, 0xA1	; 161
    7146:	93 e0       	ldi	r25, 0x03	; 3
    7148:	a5 da       	rcall	.-2742   	; 0x6694 <printPgmString>
    714a:	41 c0       	rjmp	.+130    	; 0x71ce <report_realtime_status+0x118>
    case STATE_HOLD:
      if (!(sys.suspend & SUSPEND_JOG_CANCEL)) {
    714c:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    7150:	88 23       	and	r24, r24
        printPgmString(PSTR("Hold:"));
    7152:	7c f0       	brlt	.+30     	; 0x7172 <report_realtime_status+0xbc>
    7154:	8b e9       	ldi	r24, 0x9B	; 155
    7156:	93 e0       	ldi	r25, 0x03	; 3
    7158:	9d da       	rcall	.-2758   	; 0x6694 <printPgmString>
        if (sys.suspend & SUSPEND_HOLD_COMPLETE) { serial_write('0'); } // Ready to resume
    715a:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    715e:	80 ff       	sbrs	r24, 0
    7160:	04 c0       	rjmp	.+8      	; 0x716a <report_realtime_status+0xb4>
    7162:	80 e3       	ldi	r24, 0x30	; 48
    7164:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    7168:	32 c0       	rjmp	.+100    	; 0x71ce <report_realtime_status+0x118>
        else { serial_write('1'); } // Actively holding
    716a:	81 e3       	ldi	r24, 0x31	; 49
    716c:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
        break;
      } // Continues to print jog state during jog cancel.
    case STATE_JOG: printPgmString(PSTR("Jog")); break;
    7170:	2e c0       	rjmp	.+92     	; 0x71ce <report_realtime_status+0x118>
    7172:	87 e9       	ldi	r24, 0x97	; 151
    7174:	93 e0       	ldi	r25, 0x03	; 3
    7176:	8e da       	rcall	.-2788   	; 0x6694 <printPgmString>
    case STATE_HOMING: printPgmString(PSTR("Home")); break;
    7178:	2a c0       	rjmp	.+84     	; 0x71ce <report_realtime_status+0x118>
    717a:	82 e9       	ldi	r24, 0x92	; 146
    717c:	93 e0       	ldi	r25, 0x03	; 3
    717e:	8a da       	rcall	.-2796   	; 0x6694 <printPgmString>
    case STATE_ALARM: printPgmString(PSTR("Alarm")); break;
    7180:	26 c0       	rjmp	.+76     	; 0x71ce <report_realtime_status+0x118>
    7182:	8c e8       	ldi	r24, 0x8C	; 140
    7184:	93 e0       	ldi	r25, 0x03	; 3
    7186:	86 da       	rcall	.-2804   	; 0x6694 <printPgmString>
    case STATE_CHECK_MODE: printPgmString(PSTR("Check")); break;
    7188:	22 c0       	rjmp	.+68     	; 0x71ce <report_realtime_status+0x118>
    718a:	86 e8       	ldi	r24, 0x86	; 134
    718c:	93 e0       	ldi	r25, 0x03	; 3
    718e:	82 da       	rcall	.-2812   	; 0x6694 <printPgmString>
    7190:	1e c0       	rjmp	.+60     	; 0x71ce <report_realtime_status+0x118>
    case STATE_SAFETY_DOOR:
      printPgmString(PSTR("Door:"));
    7192:	80 e8       	ldi	r24, 0x80	; 128
    7194:	93 e0       	ldi	r25, 0x03	; 3
    7196:	7e da       	rcall	.-2820   	; 0x6694 <printPgmString>
    7198:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
      if (sys.suspend & SUSPEND_INITIATE_RESTORE) {
    719c:	83 ff       	sbrs	r24, 3
    719e:	04 c0       	rjmp	.+8      	; 0x71a8 <report_realtime_status+0xf2>
    71a0:	83 e3       	ldi	r24, 0x33	; 51
        serial_write('3'); // Restoring
    71a2:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    71a6:	13 c0       	rjmp	.+38     	; 0x71ce <report_realtime_status+0x118>
    71a8:	82 ff       	sbrs	r24, 2
      } else {
        if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
    71aa:	0a c0       	rjmp	.+20     	; 0x71c0 <report_realtime_status+0x10a>
    71ac:	85 ff       	sbrs	r24, 5
          if (sys.suspend & SUSPEND_SAFETY_DOOR_AJAR) {
    71ae:	04 c0       	rjmp	.+8      	; 0x71b8 <report_realtime_status+0x102>
    71b0:	81 e3       	ldi	r24, 0x31	; 49
            serial_write('1'); // Door ajar
    71b2:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    71b6:	0b c0       	rjmp	.+22     	; 0x71ce <report_realtime_status+0x118>
    71b8:	80 e3       	ldi	r24, 0x30	; 48
          } else {
            serial_write('0');
    71ba:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    71be:	07 c0       	rjmp	.+14     	; 0x71ce <report_realtime_status+0x118>
          } // Door closed and ready to resume
        } else {
          serial_write('2'); // Retracting
    71c0:	82 e3       	ldi	r24, 0x32	; 50
    71c2:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    71c6:	03 c0       	rjmp	.+6      	; 0x71ce <report_realtime_status+0x118>
        }
      }
      break;
    case STATE_SLEEP: printPgmString(PSTR("Sleep")); break;
    71c8:	8a e7       	ldi	r24, 0x7A	; 122
    71ca:	93 e0       	ldi	r25, 0x03	; 3
    71cc:	63 da       	rcall	.-2874   	; 0x6694 <printPgmString>
    71ce:	80 91 04 0f 	lds	r24, 0x0F04	; 0x800f04 <settings+0x34>
    71d2:	28 2f       	mov	r18, r24
  }

  float wco[N_AXIS];
  if (bit_isfalse(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE) ||
    71d4:	21 70       	andi	r18, 0x01	; 1
    71d6:	e2 2e       	mov	r14, r18
    71d8:	80 ff       	sbrs	r24, 0
    71da:	04 c0       	rjmp	.+8      	; 0x71e4 <report_realtime_status+0x12e>
    71dc:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <sys+0xc>
    71e0:	81 11       	cpse	r24, r1
    71e2:	52 c0       	rjmp	.+164    	; 0x7288 <report_realtime_status+0x1d2>
    71e4:	40 90 92 0c 	lds	r4, 0x0C92	; 0x800c92 <gc_state+0x3c>
      (sys.report_wco_counter == 0) ) {
    for (idx=0; idx< N_AXIS; idx++) {
      // Apply work coordinate offsets and tool length offset to current position.
      wco[idx] = gc_state.coord_system[idx]+gc_state.coord_offset[idx];
      if (idx == TOOL_LENGTH_OFFSET_AXIS) { wco[idx] += gc_state.tool_length_offset; }
    71e8:	50 90 93 0c 	lds	r5, 0x0C93	; 0x800c93 <gc_state+0x3d>
    71ec:	60 90 94 0c 	lds	r6, 0x0C94	; 0x800c94 <gc_state+0x3e>
    71f0:	70 90 95 0c 	lds	r7, 0x0C95	; 0x800c95 <gc_state+0x3f>
    71f4:	0f 2e       	mov	r0, r31
    71f6:	fa e7       	ldi	r31, 0x7A	; 122
    71f8:	cf 2e       	mov	r12, r31
    71fa:	fc e0       	ldi	r31, 0x0C	; 12
    71fc:	df 2e       	mov	r13, r31
    71fe:	f0 2d       	mov	r31, r0
    7200:	8e 01       	movw	r16, r28
    7202:	07 5e       	subi	r16, 0xE7	; 231
    7204:	1f 4f       	sbci	r17, 0xFF	; 255
    7206:	5e 01       	movw	r10, r28
    7208:	8d e0       	ldi	r24, 0x0D	; 13
    720a:	a8 0e       	add	r10, r24
    720c:	b1 1c       	adc	r11, r1
    720e:	f1 2c       	mov	r15, r1
    7210:	f6 01       	movw	r30, r12
  float wco[N_AXIS];
  if (bit_isfalse(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE) ||
      (sys.report_wco_counter == 0) ) {
    for (idx=0; idx< N_AXIS; idx++) {
      // Apply work coordinate offsets and tool length offset to current position.
      wco[idx] = gc_state.coord_system[idx]+gc_state.coord_offset[idx];
    7212:	61 91       	ld	r22, Z+
    7214:	71 91       	ld	r23, Z+
    7216:	81 91       	ld	r24, Z+
    7218:	91 91       	ld	r25, Z+
    721a:	6f 01       	movw	r12, r30
    721c:	20 85       	ldd	r18, Z+8	; 0x08
    721e:	31 85       	ldd	r19, Z+9	; 0x09
    7220:	42 85       	ldd	r20, Z+10	; 0x0a
    7222:	53 85       	ldd	r21, Z+11	; 0x0b
    7224:	7d d5       	rcall	.+2810   	; 0x7d20 <__addsf3>
    7226:	48 01       	movw	r8, r16
    7228:	f8 01       	movw	r30, r16
    722a:	60 83       	st	Z, r22
    722c:	71 83       	std	Z+1, r23	; 0x01
    722e:	82 83       	std	Z+2, r24	; 0x02
    7230:	93 83       	std	Z+3, r25	; 0x03
      if (idx == TOOL_LENGTH_OFFSET_AXIS) { wco[idx] += gc_state.tool_length_offset; }
    7232:	f2 e0       	ldi	r31, 0x02	; 2
    7234:	ff 12       	cpse	r15, r31
    7236:	0b c0       	rjmp	.+22     	; 0x724e <report_realtime_status+0x198>
    7238:	a3 01       	movw	r20, r6
    723a:	92 01       	movw	r18, r4
    723c:	71 d5       	rcall	.+2786   	; 0x7d20 <__addsf3>
    723e:	f8 01       	movw	r30, r16
    7240:	60 83       	st	Z, r22
    7242:	71 83       	std	Z+1, r23	; 0x01
    7244:	82 83       	std	Z+2, r24	; 0x02
    7246:	93 83       	std	Z+3, r25	; 0x03
    7248:	e1 10       	cpse	r14, r1
      if (bit_isfalse(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE)) {
    724a:	1e c0       	rjmp	.+60     	; 0x7288 <report_realtime_status+0x1d2>
    724c:	02 c0       	rjmp	.+4      	; 0x7252 <report_realtime_status+0x19c>
    724e:	e1 10       	cpse	r14, r1
    7250:	10 c0       	rjmp	.+32     	; 0x7272 <report_realtime_status+0x1bc>
        print_position[idx] -= wco[idx];
    7252:	f4 01       	movw	r30, r8
    7254:	20 81       	ld	r18, Z
    7256:	31 81       	ldd	r19, Z+1	; 0x01
    7258:	42 81       	ldd	r20, Z+2	; 0x02
    725a:	53 81       	ldd	r21, Z+3	; 0x03
    725c:	f5 01       	movw	r30, r10
    725e:	60 81       	ld	r22, Z
    7260:	71 81       	ldd	r23, Z+1	; 0x01
    7262:	82 81       	ldd	r24, Z+2	; 0x02
    7264:	93 81       	ldd	r25, Z+3	; 0x03
    7266:	5b d5       	rcall	.+2742   	; 0x7d1e <__subsf3>
    7268:	f5 01       	movw	r30, r10
    726a:	60 83       	st	Z, r22
    726c:	71 83       	std	Z+1, r23	; 0x01
    726e:	82 83       	std	Z+2, r24	; 0x02
    7270:	93 83       	std	Z+3, r25	; 0x03
    7272:	f3 94       	inc	r15
  }

  float wco[N_AXIS];
  if (bit_isfalse(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE) ||
      (sys.report_wco_counter == 0) ) {
    for (idx=0; idx< N_AXIS; idx++) {
    7274:	0c 5f       	subi	r16, 0xFC	; 252
    7276:	1f 4f       	sbci	r17, 0xFF	; 255
    7278:	f4 e0       	ldi	r31, 0x04	; 4
    727a:	af 0e       	add	r10, r31
    727c:	b1 1c       	adc	r11, r1
    727e:	23 e0       	ldi	r18, 0x03	; 3
    7280:	f2 12       	cpse	r15, r18
      }
    }
  }

  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE)) {
    7282:	c6 cf       	rjmp	.-116    	; 0x7210 <report_realtime_status+0x15a>
    7284:	ee 20       	and	r14, r14
    printPgmString(PSTR("|MPos:"));
    7286:	21 f0       	breq	.+8      	; 0x7290 <report_realtime_status+0x1da>
    7288:	83 e7       	ldi	r24, 0x73	; 115
    728a:	93 e0       	ldi	r25, 0x03	; 3
    728c:	03 da       	rcall	.-3066   	; 0x6694 <printPgmString>
  } else {
    printPgmString(PSTR("|WPos:"));
    728e:	03 c0       	rjmp	.+6      	; 0x7296 <report_realtime_status+0x1e0>
    7290:	8c e6       	ldi	r24, 0x6C	; 108
    7292:	93 e0       	ldi	r25, 0x03	; 3
  }
  report_util_axis_values(print_position);
    7294:	ff d9       	rcall	.-3074   	; 0x6694 <printPgmString>
    7296:	ce 01       	movw	r24, r28
    7298:	0d 96       	adiw	r24, 0x0d	; 13

  // Returns planner and serial read buffer states.
  #ifdef REPORT_FIELD_BUFFER_STATE
    if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_BUFFER_STATE)) {
    729a:	d0 db       	rcall	.-2144   	; 0x6a3c <report_util_axis_values>
    729c:	80 91 04 0f 	lds	r24, 0x0F04	; 0x800f04 <settings+0x34>
    72a0:	81 ff       	sbrs	r24, 1
      printPgmString(PSTR("|Bf:"));
    72a2:	0c c0       	rjmp	.+24     	; 0x72bc <report_realtime_status+0x206>
    72a4:	87 e6       	ldi	r24, 0x67	; 103
    72a6:	93 e0       	ldi	r25, 0x03	; 3
    72a8:	f5 d9       	rcall	.-3094   	; 0x6694 <printPgmString>
      print_uint8_base10(plan_get_block_buffer_available());
    72aa:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <plan_get_block_buffer_available>
    72ae:	04 da       	rcall	.-3064   	; 0x66b8 <print_uint8_base10>
    72b0:	8c e2       	ldi	r24, 0x2C	; 44
      serial_write(',');
    72b2:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    72b6:	0e 94 fd 13 	call	0x27fa	; 0x27fa <serial_get_rx_buffer_available>
      print_uint8_base10(serial_get_rx_buffer_available());
    72ba:	fe d9       	rcall	.-3076   	; 0x66b8 <print_uint8_base10>
    72bc:	0e 94 85 29 	call	0x530a	; 0x530a <plan_get_current_block>
  #endif

  #ifdef REPORT_FIELD_LINE_NUMBERS
    // Report current line number
    plan_block_t * cur_block = plan_get_current_block();
    if (cur_block != NULL) {
    72c0:	00 97       	sbiw	r24, 0x00	; 0
      uint32_t ln = cur_block->line_number;
    72c2:	81 f0       	breq	.+32     	; 0x72e4 <report_realtime_status+0x22e>
    72c4:	fc 01       	movw	r30, r24
    72c6:	c2 88       	ldd	r12, Z+18	; 0x12
    72c8:	d3 88       	ldd	r13, Z+19	; 0x13
      if (ln > 0) {
    72ca:	e4 88       	ldd	r14, Z+20	; 0x14
    72cc:	f5 88       	ldd	r15, Z+21	; 0x15
    72ce:	c1 14       	cp	r12, r1
    72d0:	d1 04       	cpc	r13, r1
    72d2:	e1 04       	cpc	r14, r1
        printPgmString(PSTR("|Ln:"));
    72d4:	f1 04       	cpc	r15, r1
    72d6:	31 f0       	breq	.+12     	; 0x72e4 <report_realtime_status+0x22e>
    72d8:	82 e6       	ldi	r24, 0x62	; 98
    72da:	93 e0       	ldi	r25, 0x03	; 3
        printInteger(ln);
    72dc:	db d9       	rcall	.-3146   	; 0x6694 <printPgmString>
    72de:	c7 01       	movw	r24, r14
    72e0:	b6 01       	movw	r22, r12
    }
  #endif

  // Report realtime feed speed
  #ifdef REPORT_FIELD_CURRENT_FEED_SPEED
    printPgmString(PSTR("|FS:"));
    72e2:	7f da       	rcall	.-2818   	; 0x67e2 <printInteger>
    72e4:	8d e5       	ldi	r24, 0x5D	; 93
    72e6:	93 e0       	ldi	r25, 0x03	; 3
    printFloat_RateValue(st_get_realtime_rate());
    72e8:	d5 d9       	rcall	.-3158   	; 0x6694 <printPgmString>
    72ea:	0e 94 95 24 	call	0x492a	; 0x492a <st_get_realtime_rate>
    72ee:	54 db       	rcall	.-2392   	; 0x6998 <printFloat_RateValue>
    serial_write(',');
    72f0:	8c e2       	ldi	r24, 0x2C	; 44
    72f2:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    printFloat(sys.spindle_speed,N_DECIMAL_RPMVALUE);
    72f6:	60 91 2c 0c 	lds	r22, 0x0C2C	; 0x800c2c <sys+0xe>
    72fa:	70 91 2d 0c 	lds	r23, 0x0C2D	; 0x800c2d <sys+0xf>
    72fe:	80 91 2e 0c 	lds	r24, 0x0C2E	; 0x800c2e <sys+0x10>
    7302:	90 91 2f 0c 	lds	r25, 0x0C2F	; 0x800c2f <sys+0x11>
    7306:	40 e0       	ldi	r20, 0x00	; 0
    7308:	86 da       	rcall	.-2804   	; 0x6816 <printFloat>
  #endif

  #ifdef REPORT_FIELD_PIN_STATE
    uint8_t lim_pin_state = limits_get_state();
    730a:	0e 94 65 30 	call	0x60ca	; 0x60ca <limits_get_state>
    730e:	08 2f       	mov	r16, r24
    uint8_t ctrl_pin_state = system_control_get_state();
    7310:	ea d0       	rcall	.+468    	; 0x74e6 <system_control_get_state>
    7312:	18 2f       	mov	r17, r24
    7314:	6f db       	rcall	.-2338   	; 0x69f4 <probe_get_state>
    uint8_t prb_pin_state = probe_get_state();
    7316:	f8 2e       	mov	r15, r24
    7318:	80 2f       	mov	r24, r16
    731a:	81 2b       	or	r24, r17
    if (lim_pin_state | ctrl_pin_state | prb_pin_state) {
    731c:	8f 29       	or	r24, r15
    731e:	79 f1       	breq	.+94     	; 0x737e <report_realtime_status+0x2c8>
    7320:	88 e5       	ldi	r24, 0x58	; 88
    7322:	93 e0       	ldi	r25, 0x03	; 3
      printPgmString(PSTR("|Pn:"));
    7324:	b7 d9       	rcall	.-3218   	; 0x6694 <printPgmString>
    7326:	ff 20       	and	r15, r15
    7328:	19 f0       	breq	.+6      	; 0x7330 <report_realtime_status+0x27a>
    732a:	80 e5       	ldi	r24, 0x50	; 80
      if (prb_pin_state) { serial_write('P'); }
    732c:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    7330:	00 23       	and	r16, r16
    7332:	79 f0       	breq	.+30     	; 0x7352 <report_realtime_status+0x29c>
    7334:	00 ff       	sbrs	r16, 0
      if (lim_pin_state) {
    7336:	03 c0       	rjmp	.+6      	; 0x733e <report_realtime_status+0x288>
    7338:	88 e5       	ldi	r24, 0x58	; 88
        if (bit_istrue(lim_pin_state,bit(X_AXIS))) { serial_write('X'); }
    733a:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    733e:	01 ff       	sbrs	r16, 1
    7340:	03 c0       	rjmp	.+6      	; 0x7348 <report_realtime_status+0x292>
    7342:	89 e5       	ldi	r24, 0x59	; 89
        if (bit_istrue(lim_pin_state,bit(Y_AXIS))) { serial_write('Y'); }
    7344:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    7348:	02 ff       	sbrs	r16, 2
    734a:	03 c0       	rjmp	.+6      	; 0x7352 <report_realtime_status+0x29c>
    734c:	8a e5       	ldi	r24, 0x5A	; 90
        if (bit_istrue(lim_pin_state,bit(Z_AXIS))) { serial_write('Z'); }
    734e:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    7352:	11 23       	and	r17, r17
    7354:	a1 f0       	breq	.+40     	; 0x737e <report_realtime_status+0x2c8>
    7356:	10 ff       	sbrs	r17, 0
      }
      if (ctrl_pin_state) {
    7358:	03 c0       	rjmp	.+6      	; 0x7360 <report_realtime_status+0x2aa>
    735a:	84 e4       	ldi	r24, 0x44	; 68
        if (bit_istrue(ctrl_pin_state,CONTROL_PIN_INDEX_SAFETY_DOOR)) { serial_write('D'); }
    735c:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    7360:	11 ff       	sbrs	r17, 1
    7362:	03 c0       	rjmp	.+6      	; 0x736a <report_realtime_status+0x2b4>
    7364:	82 e5       	ldi	r24, 0x52	; 82
        if (bit_istrue(ctrl_pin_state,CONTROL_PIN_INDEX_RESET)) { serial_write('R'); }
    7366:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    736a:	12 ff       	sbrs	r17, 2
    736c:	03 c0       	rjmp	.+6      	; 0x7374 <report_realtime_status+0x2be>
    736e:	88 e4       	ldi	r24, 0x48	; 72
        if (bit_istrue(ctrl_pin_state,CONTROL_PIN_INDEX_FEED_HOLD)) { serial_write('H'); }
    7370:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    7374:	13 ff       	sbrs	r17, 3
    7376:	03 c0       	rjmp	.+6      	; 0x737e <report_realtime_status+0x2c8>
    7378:	83 e5       	ldi	r24, 0x53	; 83
        if (bit_istrue(ctrl_pin_state,CONTROL_PIN_INDEX_CYCLE_START)) { serial_write('S'); }
    737a:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    737e:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <sys+0xc>
    7382:	88 23       	and	r24, r24
      }
    }
  #endif

  #ifdef REPORT_FIELD_WORK_COORD_OFFSET
    if (sys.report_wco_counter > 0) { sys.report_wco_counter--; }
    7384:	21 f0       	breq	.+8      	; 0x738e <report_realtime_status+0x2d8>
    7386:	81 50       	subi	r24, 0x01	; 1
    7388:	80 93 2a 0c 	sts	0x0C2A, r24	; 0x800c2a <sys+0xc>
    738c:	18 c0       	rjmp	.+48     	; 0x73be <report_realtime_status+0x308>
    738e:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    else {
      if (sys.state & (STATE_HOMING | STATE_CYCLE | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)) {
    7392:	8c 77       	andi	r24, 0x7C	; 124
    7394:	21 f0       	breq	.+8      	; 0x739e <report_realtime_status+0x2e8>
    7396:	8d e1       	ldi	r24, 0x1D	; 29
        sys.report_wco_counter = (REPORT_WCO_REFRESH_BUSY_COUNT-1); // Reset counter for slow refresh
    7398:	80 93 2a 0c 	sts	0x0C2A, r24	; 0x800c2a <sys+0xc>
    739c:	03 c0       	rjmp	.+6      	; 0x73a4 <report_realtime_status+0x2ee>
    739e:	89 e0       	ldi	r24, 0x09	; 9
      } else { sys.report_wco_counter = (REPORT_WCO_REFRESH_IDLE_COUNT-1); }
    73a0:	80 93 2a 0c 	sts	0x0C2A, r24	; 0x800c2a <sys+0xc>
    73a4:	80 91 29 0c 	lds	r24, 0x0C29	; 0x800c29 <sys+0xb>
      if (sys.report_ovr_counter == 0) { sys.report_ovr_counter = 1; } // Set override on next report.
    73a8:	81 11       	cpse	r24, r1
    73aa:	03 c0       	rjmp	.+6      	; 0x73b2 <report_realtime_status+0x2fc>
    73ac:	81 e0       	ldi	r24, 0x01	; 1
    73ae:	80 93 29 0c 	sts	0x0C29, r24	; 0x800c29 <sys+0xb>
    73b2:	82 e5       	ldi	r24, 0x52	; 82
      printPgmString(PSTR("|WCO:"));
    73b4:	93 e0       	ldi	r25, 0x03	; 3
    73b6:	6e d9       	rcall	.-3364   	; 0x6694 <printPgmString>
    73b8:	ce 01       	movw	r24, r28
      report_util_axis_values(wco);
    73ba:	49 96       	adiw	r24, 0x19	; 25
    73bc:	3f db       	rcall	.-2434   	; 0x6a3c <report_util_axis_values>
    73be:	80 91 29 0c 	lds	r24, 0x0C29	; 0x800c29 <sys+0xb>
    }
  #endif

  #ifdef REPORT_FIELD_OVERRIDES
    if (sys.report_ovr_counter > 0) { sys.report_ovr_counter--; }
    73c2:	88 23       	and	r24, r24
    73c4:	21 f0       	breq	.+8      	; 0x73ce <report_realtime_status+0x318>
    73c6:	81 50       	subi	r24, 0x01	; 1
    73c8:	80 93 29 0c 	sts	0x0C29, r24	; 0x800c29 <sys+0xb>
    73cc:	3b c0       	rjmp	.+118    	; 0x7444 <report_realtime_status+0x38e>
    else {
      if (sys.state & (STATE_HOMING | STATE_CYCLE | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)) {
    73ce:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    73d2:	8c 77       	andi	r24, 0x7C	; 124
        sys.report_ovr_counter = (REPORT_OVR_REFRESH_BUSY_COUNT-1); // Reset counter for slow refresh
    73d4:	21 f0       	breq	.+8      	; 0x73de <report_realtime_status+0x328>
    73d6:	83 e1       	ldi	r24, 0x13	; 19
    73d8:	80 93 29 0c 	sts	0x0C29, r24	; 0x800c29 <sys+0xb>
      } else { sys.report_ovr_counter = (REPORT_OVR_REFRESH_IDLE_COUNT-1); }
    73dc:	03 c0       	rjmp	.+6      	; 0x73e4 <report_realtime_status+0x32e>
    73de:	89 e0       	ldi	r24, 0x09	; 9
    73e0:	80 93 29 0c 	sts	0x0C29, r24	; 0x800c29 <sys+0xb>
      printPgmString(PSTR("|Ov:"));
    73e4:	8d e4       	ldi	r24, 0x4D	; 77
    73e6:	93 e0       	ldi	r25, 0x03	; 3
    73e8:	55 d9       	rcall	.-3414   	; 0x6694 <printPgmString>
      print_uint8_base10(sys.f_override);
    73ea:	0e e1       	ldi	r16, 0x1E	; 30
    73ec:	1c e0       	ldi	r17, 0x0C	; 12
    73ee:	f8 01       	movw	r30, r16
    73f0:	87 81       	ldd	r24, Z+7	; 0x07
    73f2:	62 d9       	rcall	.-3388   	; 0x66b8 <print_uint8_base10>
    73f4:	8c e2       	ldi	r24, 0x2C	; 44
      serial_write(',');
    73f6:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    73fa:	f8 01       	movw	r30, r16
      print_uint8_base10(sys.r_override);
    73fc:	80 85       	ldd	r24, Z+8	; 0x08
    73fe:	5c d9       	rcall	.-3400   	; 0x66b8 <print_uint8_base10>
    7400:	8c e2       	ldi	r24, 0x2C	; 44
    7402:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
      serial_write(',');
    7406:	f8 01       	movw	r30, r16
    7408:	81 85       	ldd	r24, Z+9	; 0x09
      print_uint8_base10(sys.spindle_speed_ovr);
    740a:	56 d9       	rcall	.-3412   	; 0x66b8 <print_uint8_base10>
    740c:	0e 94 68 12 	call	0x24d0	; 0x24d0 <spindle_get_state>

      uint8_t sp_state = spindle_get_state();
    7410:	08 2f       	mov	r16, r24
    7412:	0e 94 b2 13 	call	0x2764	; 0x2764 <coolant_get_state>
      uint8_t cl_state = coolant_get_state();
    7416:	18 2f       	mov	r17, r24
    7418:	01 11       	cpse	r16, r1
    741a:	2e c0       	rjmp	.+92     	; 0x7478 <report_realtime_status+0x3c2>
      if (sp_state || cl_state) {
    741c:	81 11       	cpse	r24, r1
    741e:	32 c0       	rjmp	.+100    	; 0x7484 <report_realtime_status+0x3ce>
    7420:	11 c0       	rjmp	.+34     	; 0x7444 <report_realtime_status+0x38e>
        printPgmString(PSTR("|A:"));
        if (sp_state) { // != SPINDLE_STATE_DISABLE
          if (sp_state == SPINDLE_STATE_CW) { serial_write('S'); } // CW
    7422:	83 e5       	ldi	r24, 0x53	; 83
    7424:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
    7428:	03 c0       	rjmp	.+6      	; 0x7430 <report_realtime_status+0x37a>
          else { serial_write('C'); } // CCW
    742a:	83 e4       	ldi	r24, 0x43	; 67
    742c:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
        }
        if (cl_state & COOLANT_STATE_FLOOD) { serial_write('F'); }
    7430:	16 ff       	sbrs	r17, 6
    7432:	03 c0       	rjmp	.+6      	; 0x743a <report_realtime_status+0x384>
    7434:	86 e4       	ldi	r24, 0x46	; 70
    7436:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
        if (cl_state & COOLANT_STATE_MIST) { serial_write('M'); }
    743a:	11 23       	and	r17, r17
    743c:	1c f4       	brge	.+6      	; 0x7444 <report_realtime_status+0x38e>
    743e:	8d e4       	ldi	r24, 0x4D	; 77
      }  
    }
  #endif
  
  #ifdef LATHE
      printPgmString(PSTR("|Sp:"));
    7440:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
      print_uint32_base10(sys_synchronization_pulse_count);
    7444:	84 e4       	ldi	r24, 0x44	; 68
    7446:	93 e0       	ldi	r25, 0x03	; 3
    7448:	25 d9       	rcall	.-3510   	; 0x6694 <printPgmString>
    744a:	60 91 15 0c 	lds	r22, 0x0C15	; 0x800c15 <sys_synchronization_pulse_count>
    744e:	70 91 16 0c 	lds	r23, 0x0C16	; 0x800c16 <sys_synchronization_pulse_count+0x1>
    7452:	80 91 17 0c 	lds	r24, 0x0C17	; 0x800c17 <sys_synchronization_pulse_count+0x2>
    7456:	90 91 18 0c 	lds	r25, 0x0C18	; 0x800c18 <sys_synchronization_pulse_count+0x3>
      printPgmString(PSTR("|Si:"));
    745a:	6d d9       	rcall	.-3366   	; 0x6736 <print_uint32_base10>
    745c:	8f e3       	ldi	r24, 0x3F	; 63
    745e:	93 e0       	ldi	r25, 0x03	; 3
      print_uint32_base10(sys_index_pulse_count);
    7460:	19 d9       	rcall	.-3534   	; 0x6694 <printPgmString>
    7462:	60 91 55 0c 	lds	r22, 0x0C55	; 0x800c55 <sys_index_pulse_count>
    7466:	70 e0       	ldi	r23, 0x00	; 0
    7468:	80 e0       	ldi	r24, 0x00	; 0
    746a:	90 e0       	ldi	r25, 0x00	; 0
    746c:	64 d9       	rcall	.-3384   	; 0x6736 <print_uint32_base10>
  #endif

  serial_write('>');
    746e:	8e e3       	ldi	r24, 0x3E	; 62
    7470:	0e 94 1a 14 	call	0x2834	; 0x2834 <serial_write>
  report_util_line_feed();
    7474:	da da       	rcall	.-2636   	; 0x6a2a <report_util_line_feed>
    7476:	0a c0       	rjmp	.+20     	; 0x748c <report_realtime_status+0x3d6>
}
    7478:	89 e4       	ldi	r24, 0x49	; 73
      print_uint8_base10(sys.spindle_speed_ovr);

      uint8_t sp_state = spindle_get_state();
      uint8_t cl_state = coolant_get_state();
      if (sp_state || cl_state) {
        printPgmString(PSTR("|A:"));
    747a:	93 e0       	ldi	r25, 0x03	; 3
    747c:	0b d9       	rcall	.-3562   	; 0x6694 <printPgmString>
    747e:	01 30       	cpi	r16, 0x01	; 1
    7480:	a1 f6       	brne	.-88     	; 0x742a <report_realtime_status+0x374>
        if (sp_state) { // != SPINDLE_STATE_DISABLE
          if (sp_state == SPINDLE_STATE_CW) { serial_write('S'); } // CW
    7482:	cf cf       	rjmp	.-98     	; 0x7422 <report_realtime_status+0x36c>
    7484:	89 e4       	ldi	r24, 0x49	; 73
    7486:	93 e0       	ldi	r25, 0x03	; 3
      print_uint8_base10(sys.spindle_speed_ovr);

      uint8_t sp_state = spindle_get_state();
      uint8_t cl_state = coolant_get_state();
      if (sp_state || cl_state) {
        printPgmString(PSTR("|A:"));
    7488:	05 d9       	rcall	.-3574   	; 0x6694 <printPgmString>
    748a:	d2 cf       	rjmp	.-92     	; 0x7430 <report_realtime_status+0x37a>
    748c:	a4 96       	adiw	r28, 0x24	; 36
    748e:	0f b6       	in	r0, 0x3f	; 63
    7490:	f8 94       	cli
      print_uint32_base10(sys_index_pulse_count);
  #endif

  serial_write('>');
  report_util_line_feed();
}
    7492:	de bf       	out	0x3e, r29	; 62
    7494:	0f be       	out	0x3f, r0	; 63
    7496:	cd bf       	out	0x3d, r28	; 61
    7498:	df 91       	pop	r29
    749a:	cf 91       	pop	r28
    749c:	1f 91       	pop	r17
    749e:	0f 91       	pop	r16
    74a0:	ff 90       	pop	r15
    74a2:	ef 90       	pop	r14
    74a4:	df 90       	pop	r13
    74a6:	cf 90       	pop	r12
    74a8:	bf 90       	pop	r11
    74aa:	af 90       	pop	r10
    74ac:	9f 90       	pop	r9
    74ae:	8f 90       	pop	r8
    74b0:	7f 90       	pop	r7
    74b2:	6f 90       	pop	r6
    74b4:	5f 90       	pop	r5
    74b6:	4f 90       	pop	r4
    74b8:	08 95       	ret

000074ba <report_realtime_debug>:
    74ba:	08 95       	ret

000074bc <system_init>:
#include "grbl.h"


void system_init()
{
  CONTROL_DDR &= ~(CONTROL_MASK); // Configure as input pins
    74bc:	e7 e0       	ldi	r30, 0x07	; 7
    74be:	f1 e0       	ldi	r31, 0x01	; 1
    74c0:	80 81       	ld	r24, Z
    74c2:	80 77       	andi	r24, 0x70	; 112
    74c4:	80 83       	st	Z, r24
  #ifdef DISABLE_CONTROL_PIN_PULL_UP
    CONTROL_PORT &= ~(CONTROL_MASK); // Normal low operation. Requires external pull-down.
  #else
    CONTROL_PORT |= CONTROL_MASK;   // Enable internal pull-up resistors. Normal high operation.
    74c6:	e8 e0       	ldi	r30, 0x08	; 8
    74c8:	f1 e0       	ldi	r31, 0x01	; 1
    74ca:	80 81       	ld	r24, Z
    74cc:	8f 68       	ori	r24, 0x8F	; 143
    74ce:	80 83       	st	Z, r24
  #endif
  CONTROL_PCMSK |= CONTROL_MASK;  // Enable specific pins of the Pin Change Interrupt
    74d0:	ed e6       	ldi	r30, 0x6D	; 109
    74d2:	f0 e0       	ldi	r31, 0x00	; 0
    74d4:	80 81       	ld	r24, Z
    74d6:	8f 68       	ori	r24, 0x8F	; 143
    74d8:	80 83       	st	Z, r24
  PCICR |= (1 << CONTROL_INT);   // Enable Pin Change Interrupt
    74da:	e8 e6       	ldi	r30, 0x68	; 104
    74dc:	f0 e0       	ldi	r31, 0x00	; 0
    74de:	80 81       	ld	r24, Z
    74e0:	84 60       	ori	r24, 0x04	; 4
    74e2:	80 83       	st	Z, r24
    74e4:	08 95       	ret

000074e6 <system_control_get_state>:
// triggered is 1 and not triggered is 0. Invert mask is applied. Bitfield organization is
// defined by the CONTROL_PIN_INDEX in the header file.
uint8_t system_control_get_state()
{
  uint8_t control_state = 0;
  uint8_t pin = (CONTROL_PIN & CONTROL_MASK);
    74e6:	20 91 06 01 	lds	r18, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
    74ea:	32 2f       	mov	r19, r18
    74ec:	3f 78       	andi	r19, 0x8F	; 143
  #ifdef INVERT_CONTROL_PIN_MASK
    pin ^= INVERT_CONTROL_PIN_MASK;
  #endif
  if (pin) {
    74ee:	79 f0       	breq	.+30     	; 0x750e <system_control_get_state+0x28>
// Returns control pin state as a uint8 bitfield. Each bit indicates the input pin state, where
// triggered is 1 and not triggered is 0. Invert mask is applied. Bitfield organization is
// defined by the CONTROL_PIN_INDEX in the header file.
uint8_t system_control_get_state()
{
  uint8_t control_state = 0;
    74f0:	23 fb       	bst	r18, 3
    74f2:	88 27       	eor	r24, r24
    74f4:	80 f9       	bld	r24, 0
    74f6:	91 e0       	ldi	r25, 0x01	; 1
    74f8:	89 27       	eor	r24, r25
  #ifdef INVERT_CONTROL_PIN_MASK
    pin ^= INVERT_CONTROL_PIN_MASK;
  #endif
  if (pin) {
    if (bit_isfalse(pin,(1<<CONTROL_SAFETY_DOOR_BIT))) { control_state |= CONTROL_PIN_INDEX_SAFETY_DOOR; }
    if (bit_isfalse(pin,(1<<CONTROL_RESET_BIT))) { control_state |= CONTROL_PIN_INDEX_RESET; }
    74fa:	20 ff       	sbrs	r18, 0
    74fc:	82 60       	ori	r24, 0x02	; 2
    if (bit_isfalse(pin,(1<<CONTROL_FEED_HOLD_BIT))) { control_state |= CONTROL_PIN_INDEX_FEED_HOLD; }
    74fe:	21 ff       	sbrs	r18, 1
    7500:	84 60       	ori	r24, 0x04	; 4
    if (bit_isfalse(pin,(1<<CONTROL_CYCLE_START_BIT))) { control_state |= CONTROL_PIN_INDEX_CYCLE_START; }
    7502:	22 ff       	sbrs	r18, 2
    7504:	88 60       	ori	r24, 0x08	; 8
    if (bit_isfalse(pin,(1<<CONTROL_SPINDLE_SYNC_BIT))) { control_state |= CONTROL_PIN_INDEX_SPINDLE_SYNC; }
    7506:	33 23       	and	r19, r19
    7508:	1c f0       	brlt	.+6      	; 0x7510 <system_control_get_state+0x2a>
    750a:	80 61       	ori	r24, 0x10	; 16
    750c:	08 95       	ret
// Returns control pin state as a uint8 bitfield. Each bit indicates the input pin state, where
// triggered is 1 and not triggered is 0. Invert mask is applied. Bitfield organization is
// defined by the CONTROL_PIN_INDEX in the header file.
uint8_t system_control_get_state()
{
  uint8_t control_state = 0;
    750e:	80 e0       	ldi	r24, 0x00	; 0
    if (bit_isfalse(pin,(1<<CONTROL_FEED_HOLD_BIT))) { control_state |= CONTROL_PIN_INDEX_FEED_HOLD; }
    if (bit_isfalse(pin,(1<<CONTROL_CYCLE_START_BIT))) { control_state |= CONTROL_PIN_INDEX_CYCLE_START; }
    if (bit_isfalse(pin,(1<<CONTROL_SPINDLE_SYNC_BIT))) { control_state |= CONTROL_PIN_INDEX_SPINDLE_SYNC; }
  }
  return(control_state);
}
    7510:	08 95       	ret

00007512 <__vector_11>:
// Pin change interrupt for pin-out commands, i.e. cycle start, feed hold, and reset. Sets
// only the realtime command execute variable to have the main program execute these when
// its ready. This works exactly like the character-based realtime commands when picked off
// directly from the incoming serial data stream.
ISR(CONTROL_INT_vect)
{
    7512:	1f 92       	push	r1
    7514:	0f 92       	push	r0
    7516:	0f b6       	in	r0, 0x3f	; 63
    7518:	0f 92       	push	r0
    751a:	11 24       	eor	r1, r1
    751c:	0b b6       	in	r0, 0x3b	; 59
    751e:	0f 92       	push	r0
    7520:	2f 93       	push	r18
    7522:	3f 93       	push	r19
    7524:	4f 93       	push	r20
    7526:	5f 93       	push	r21
    7528:	6f 93       	push	r22
    752a:	7f 93       	push	r23
    752c:	8f 93       	push	r24
    752e:	9f 93       	push	r25
    7530:	af 93       	push	r26
    7532:	bf 93       	push	r27
    7534:	ef 93       	push	r30
    7536:	ff 93       	push	r31
  uint8_t pin = system_control_get_state();
    7538:	d6 df       	rcall	.-84     	; 0x74e6 <system_control_get_state>
  if (pin) {
    753a:	88 23       	and	r24, r24
    753c:	21 f1       	breq	.+72     	; 0x7586 <__vector_11+0x74>
    if (bit_istrue(pin,CONTROL_PIN_INDEX_RESET)) {
    753e:	81 ff       	sbrs	r24, 1
    7540:	03 c0       	rjmp	.+6      	; 0x7548 <__vector_11+0x36>
      mc_reset();
    7542:	0e 94 23 07 	call	0xe46	; 0xe46 <mc_reset>
    7546:	1f c0       	rjmp	.+62     	; 0x7586 <__vector_11+0x74>
    } else if (bit_istrue(pin,CONTROL_PIN_INDEX_CYCLE_START)) {
    7548:	83 ff       	sbrs	r24, 3
    754a:	06 c0       	rjmp	.+12     	; 0x7558 <__vector_11+0x46>
      bit_true(sys_rt_exec_state, EXEC_CYCLE_START);
    754c:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    7550:	82 60       	ori	r24, 0x02	; 2
    7552:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <sys_rt_exec_state>
    7556:	17 c0       	rjmp	.+46     	; 0x7586 <__vector_11+0x74>
    } else if (bit_istrue(pin,CONTROL_PIN_INDEX_FEED_HOLD)) {
    7558:	82 ff       	sbrs	r24, 2
    755a:	06 c0       	rjmp	.+12     	; 0x7568 <__vector_11+0x56>
      bit_true(sys_rt_exec_state, EXEC_FEED_HOLD); 
    755c:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    7560:	88 60       	ori	r24, 0x08	; 8
    7562:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <sys_rt_exec_state>
    7566:	0f c0       	rjmp	.+30     	; 0x7586 <__vector_11+0x74>
    } else if (bit_istrue(pin,CONTROL_PIN_INDEX_SAFETY_DOOR)) {
    7568:	80 ff       	sbrs	r24, 0
    756a:	06 c0       	rjmp	.+12     	; 0x7578 <__vector_11+0x66>
      bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
    756c:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    7570:	80 62       	ori	r24, 0x20	; 32
    7572:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <sys_rt_exec_state>
    7576:	07 c0       	rjmp	.+14     	; 0x7586 <__vector_11+0x74>
	} else if (bit_istrue(pin,CONTROL_PIN_INDEX_SPINDLE_SYNC)) {
    7578:	84 ff       	sbrs	r24, 4
    757a:	05 c0       	rjmp	.+10     	; 0x7586 <__vector_11+0x74>
	 bit_true(sys_sync_state, EXEC_SPINDLE_SYNC);   } 
    757c:	80 91 14 0c 	lds	r24, 0x0C14	; 0x800c14 <sys_sync_state>
    7580:	82 60       	ori	r24, 0x02	; 2
    7582:	80 93 14 0c 	sts	0x0C14, r24	; 0x800c14 <sys_sync_state>
  }
}
    7586:	ff 91       	pop	r31
    7588:	ef 91       	pop	r30
    758a:	bf 91       	pop	r27
    758c:	af 91       	pop	r26
    758e:	9f 91       	pop	r25
    7590:	8f 91       	pop	r24
    7592:	7f 91       	pop	r23
    7594:	6f 91       	pop	r22
    7596:	5f 91       	pop	r21
    7598:	4f 91       	pop	r20
    759a:	3f 91       	pop	r19
    759c:	2f 91       	pop	r18
    759e:	0f 90       	pop	r0
    75a0:	0b be       	out	0x3b, r0	; 59
    75a2:	0f 90       	pop	r0
    75a4:	0f be       	out	0x3f, r0	; 63
    75a6:	0f 90       	pop	r0
    75a8:	1f 90       	pop	r1
    75aa:	18 95       	reti

000075ac <system_check_safety_door_ajar>:


// Returns if safety door is ajar(T) or closed(F), based on pin state.
uint8_t system_check_safety_door_ajar()
{
    return(system_control_get_state() & CONTROL_PIN_INDEX_SAFETY_DOOR);
    75ac:	9c df       	rcall	.-200    	; 0x74e6 <system_control_get_state>
}
    75ae:	81 70       	andi	r24, 0x01	; 1
    75b0:	08 95       	ret

000075b2 <system_execute_startup>:


// Executes user startup script, if stored.
void system_execute_startup(char *line)
{
    75b2:	0f 93       	push	r16
    75b4:	1f 93       	push	r17
    75b6:	cf 93       	push	r28
    75b8:	8c 01       	movw	r16, r24
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    75ba:	c0 e0       	ldi	r28, 0x00	; 0
    if (!(settings_read_startup_line(n, line))) {
    75bc:	b8 01       	movw	r22, r16
    75be:	8c 2f       	mov	r24, r28
    75c0:	0e 94 e9 25 	call	0x4bd2	; 0x4bd2 <settings_read_startup_line>
    75c4:	81 11       	cpse	r24, r1
    75c6:	06 c0       	rjmp	.+12     	; 0x75d4 <system_execute_startup+0x22>
      line[0] = 0;
    75c8:	f8 01       	movw	r30, r16
    75ca:	10 82       	st	Z, r1
      report_execute_startup_message(line,STATUS_SETTING_READ_FAIL);
    75cc:	67 e0       	ldi	r22, 0x07	; 7
    75ce:	c8 01       	movw	r24, r16
    75d0:	30 dd       	rcall	.-1440   	; 0x7032 <report_execute_startup_message>
    75d2:	0a c0       	rjmp	.+20     	; 0x75e8 <system_execute_startup+0x36>
    } else {
      if (line[0] != 0) {
    75d4:	f8 01       	movw	r30, r16
    75d6:	80 81       	ld	r24, Z
    75d8:	88 23       	and	r24, r24
    75da:	31 f0       	breq	.+12     	; 0x75e8 <system_execute_startup+0x36>
        uint8_t status_code = gc_execute_line(line);
    75dc:	c8 01       	movw	r24, r16
    75de:	0e 94 60 07 	call	0xec0	; 0xec0 <gc_execute_line>
        report_execute_startup_message(line,status_code);
    75e2:	68 2f       	mov	r22, r24
    75e4:	c8 01       	movw	r24, r16
    75e6:	25 dd       	rcall	.-1462   	; 0x7032 <report_execute_startup_message>

// Executes user startup script, if stored.
void system_execute_startup(char *line)
{
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    75e8:	cf 5f       	subi	r28, 0xFF	; 255
    75ea:	c2 30       	cpi	r28, 0x02	; 2
    75ec:	39 f7       	brne	.-50     	; 0x75bc <system_execute_startup+0xa>
        uint8_t status_code = gc_execute_line(line);
        report_execute_startup_message(line,status_code);
      }
    }
  }
}
    75ee:	cf 91       	pop	r28
    75f0:	1f 91       	pop	r17
    75f2:	0f 91       	pop	r16
    75f4:	08 95       	ret

000075f6 <system_flag_wco_change>:


void system_flag_wco_change()
{
  #ifdef FORCE_BUFFER_SYNC_DURING_WCO_CHANGE
    protocol_buffer_synchronize();
    75f6:	0e 94 2c 19 	call	0x3258	; 0x3258 <protocol_buffer_synchronize>
  #endif
  sys.report_wco_counter = 0;
    75fa:	10 92 2a 0c 	sts	0x0C2A, r1	; 0x800c2a <sys+0xc>
    75fe:	08 95       	ret

00007600 <system_convert_axis_steps_to_mpos>:

// Returns machine position of axis 'idx'. Must be sent a 'step' array.
// NOTE: If motor steps and machine position are not in the same coordinate frame, this function
//   serves as a central place to compute the transformation.
float system_convert_axis_steps_to_mpos(int32_t *steps, uint8_t idx)
{
    7600:	cf 93       	push	r28
    7602:	df 93       	push	r29
      pos = (float)system_convert_corexy_to_y_axis_steps(steps) / settings.steps_per_mm[idx];
    } else {
      pos = steps[idx]/settings.steps_per_mm[idx];
    }
  #else
    pos = steps[idx]/settings.steps_per_mm[idx];
    7604:	c6 2f       	mov	r28, r22
    7606:	d0 e0       	ldi	r29, 0x00	; 0
    7608:	cc 0f       	add	r28, r28
    760a:	dd 1f       	adc	r29, r29
    760c:	cc 0f       	add	r28, r28
    760e:	dd 1f       	adc	r29, r29
    7610:	8c 0f       	add	r24, r28
    7612:	9d 1f       	adc	r25, r29
  #endif
  return(pos);
    7614:	fc 01       	movw	r30, r24
    7616:	60 81       	ld	r22, Z
    7618:	71 81       	ldd	r23, Z+1	; 0x01
    761a:	82 81       	ldd	r24, Z+2	; 0x02
    761c:	93 81       	ldd	r25, Z+3	; 0x03
    761e:	fb d4       	rcall	.+2550   	; 0x8016 <__floatsisf>
      pos = (float)system_convert_corexy_to_y_axis_steps(steps) / settings.steps_per_mm[idx];
    } else {
      pos = steps[idx]/settings.steps_per_mm[idx];
    }
  #else
    pos = steps[idx]/settings.steps_per_mm[idx];
    7620:	c0 53       	subi	r28, 0x30	; 48
    7622:	d1 4f       	sbci	r29, 0xF1	; 241
  #endif
  return(pos);
    7624:	28 81       	ld	r18, Y
    7626:	39 81       	ldd	r19, Y+1	; 0x01
    7628:	4a 81       	ldd	r20, Y+2	; 0x02
    762a:	5b 81       	ldd	r21, Y+3	; 0x03
    762c:	59 d4       	rcall	.+2226   	; 0x7ee0 <__divsf3>
}
    762e:	df 91       	pop	r29
    7630:	cf 91       	pop	r28
    7632:	08 95       	ret

00007634 <system_convert_array_steps_to_mpos>:


void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
    7634:	ef 92       	push	r14
    7636:	ff 92       	push	r15
    7638:	0f 93       	push	r16
    763a:	1f 93       	push	r17
    763c:	cf 93       	push	r28
    763e:	7b 01       	movw	r14, r22
    7640:	8c 01       	movw	r16, r24
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    7642:	c0 e0       	ldi	r28, 0x00	; 0
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
    7644:	6c 2f       	mov	r22, r28
    7646:	c7 01       	movw	r24, r14
    7648:	db df       	rcall	.-74     	; 0x7600 <system_convert_axis_steps_to_mpos>
    764a:	f8 01       	movw	r30, r16
    764c:	61 93       	st	Z+, r22
    764e:	71 93       	st	Z+, r23
    7650:	81 93       	st	Z+, r24
    7652:	91 93       	st	Z+, r25
    7654:	8f 01       	movw	r16, r30


void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    7656:	cf 5f       	subi	r28, 0xFF	; 255
    7658:	c3 30       	cpi	r28, 0x03	; 3
    765a:	a1 f7       	brne	.-24     	; 0x7644 <system_convert_array_steps_to_mpos+0x10>
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
  }
  return;
}
    765c:	cf 91       	pop	r28
    765e:	1f 91       	pop	r17
    7660:	0f 91       	pop	r16
    7662:	ff 90       	pop	r15
    7664:	ef 90       	pop	r14
    7666:	08 95       	ret

00007668 <system_check_travel_limits>:
#endif


// Checks and reports if target array exceeds machine travel limits.
uint8_t system_check_travel_limits(float *target)
{
    7668:	cf 92       	push	r12
    766a:	df 92       	push	r13
    766c:	ef 92       	push	r14
    766e:	ff 92       	push	r15
    7670:	cf 93       	push	r28
    7672:	df 93       	push	r29
    7674:	ec 01       	movw	r28, r24
      } else {
        if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { return(true); }
      }
    #else
      // NOTE: max_travel is stored as negative
      if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { return(true); }
    7676:	c8 80       	ld	r12, Y
    7678:	d9 80       	ldd	r13, Y+1	; 0x01
    767a:	ea 80       	ldd	r14, Y+2	; 0x02
    767c:	fb 80       	ldd	r15, Y+3	; 0x03
    767e:	20 e0       	ldi	r18, 0x00	; 0
    7680:	30 e0       	ldi	r19, 0x00	; 0
    7682:	a9 01       	movw	r20, r18
    7684:	c7 01       	movw	r24, r14
    7686:	b6 01       	movw	r22, r12
    7688:	27 d6       	rcall	.+3150   	; 0x82d8 <__gesf2>
    768a:	18 16       	cp	r1, r24
    768c:	0c f4       	brge	.+2      	; 0x7690 <system_check_travel_limits+0x28>
    768e:	41 c0       	rjmp	.+130    	; 0x7712 <system_check_travel_limits+0xaa>
    7690:	20 91 f4 0e 	lds	r18, 0x0EF4	; 0x800ef4 <settings+0x24>
    7694:	30 91 f5 0e 	lds	r19, 0x0EF5	; 0x800ef5 <settings+0x25>
    7698:	40 91 f6 0e 	lds	r20, 0x0EF6	; 0x800ef6 <settings+0x26>
    769c:	50 91 f7 0e 	lds	r21, 0x0EF7	; 0x800ef7 <settings+0x27>
    76a0:	c7 01       	movw	r24, r14
    76a2:	b6 01       	movw	r22, r12
    76a4:	16 d4       	rcall	.+2092   	; 0x7ed2 <__cmpsf2>
    76a6:	88 23       	and	r24, r24
    76a8:	b4 f1       	brlt	.+108    	; 0x7716 <system_check_travel_limits+0xae>
    76aa:	cc 80       	ldd	r12, Y+4	; 0x04
    76ac:	dd 80       	ldd	r13, Y+5	; 0x05
    76ae:	ee 80       	ldd	r14, Y+6	; 0x06
    76b0:	ff 80       	ldd	r15, Y+7	; 0x07
    76b2:	20 e0       	ldi	r18, 0x00	; 0
    76b4:	30 e0       	ldi	r19, 0x00	; 0
    76b6:	a9 01       	movw	r20, r18
    76b8:	c7 01       	movw	r24, r14
    76ba:	b6 01       	movw	r22, r12
    76bc:	0d d6       	rcall	.+3098   	; 0x82d8 <__gesf2>
    76be:	18 16       	cp	r1, r24
    76c0:	64 f1       	brlt	.+88     	; 0x771a <system_check_travel_limits+0xb2>
    76c2:	20 91 f8 0e 	lds	r18, 0x0EF8	; 0x800ef8 <settings+0x28>
    76c6:	30 91 f9 0e 	lds	r19, 0x0EF9	; 0x800ef9 <settings+0x29>
    76ca:	40 91 fa 0e 	lds	r20, 0x0EFA	; 0x800efa <settings+0x2a>
    76ce:	50 91 fb 0e 	lds	r21, 0x0EFB	; 0x800efb <settings+0x2b>
    76d2:	c7 01       	movw	r24, r14
    76d4:	b6 01       	movw	r22, r12
    76d6:	fd d3       	rcall	.+2042   	; 0x7ed2 <__cmpsf2>
    76d8:	88 23       	and	r24, r24
    76da:	0c f1       	brlt	.+66     	; 0x771e <system_check_travel_limits+0xb6>
    76dc:	c8 84       	ldd	r12, Y+8	; 0x08
    76de:	d9 84       	ldd	r13, Y+9	; 0x09
    76e0:	ea 84       	ldd	r14, Y+10	; 0x0a
    76e2:	fb 84       	ldd	r15, Y+11	; 0x0b
    76e4:	20 e0       	ldi	r18, 0x00	; 0
    76e6:	30 e0       	ldi	r19, 0x00	; 0
    76e8:	a9 01       	movw	r20, r18
    76ea:	c7 01       	movw	r24, r14
    76ec:	b6 01       	movw	r22, r12
    76ee:	f4 d5       	rcall	.+3048   	; 0x82d8 <__gesf2>
    76f0:	18 16       	cp	r1, r24
    76f2:	bc f0       	brlt	.+46     	; 0x7722 <system_check_travel_limits+0xba>
    76f4:	20 91 fc 0e 	lds	r18, 0x0EFC	; 0x800efc <settings+0x2c>
    76f8:	30 91 fd 0e 	lds	r19, 0x0EFD	; 0x800efd <settings+0x2d>
    76fc:	40 91 fe 0e 	lds	r20, 0x0EFE	; 0x800efe <settings+0x2e>
    7700:	50 91 ff 0e 	lds	r21, 0x0EFF	; 0x800eff <settings+0x2f>
    7704:	c7 01       	movw	r24, r14
    7706:	b6 01       	movw	r22, r12
    7708:	e4 d3       	rcall	.+1992   	; 0x7ed2 <__cmpsf2>
    770a:	88 1f       	adc	r24, r24
    770c:	88 27       	eor	r24, r24
    770e:	88 1f       	adc	r24, r24
    7710:	09 c0       	rjmp	.+18     	; 0x7724 <system_check_travel_limits+0xbc>
    7712:	81 e0       	ldi	r24, 0x01	; 1
    7714:	07 c0       	rjmp	.+14     	; 0x7724 <system_check_travel_limits+0xbc>
    7716:	81 e0       	ldi	r24, 0x01	; 1
    7718:	05 c0       	rjmp	.+10     	; 0x7724 <system_check_travel_limits+0xbc>
    771a:	81 e0       	ldi	r24, 0x01	; 1
    771c:	03 c0       	rjmp	.+6      	; 0x7724 <system_check_travel_limits+0xbc>
    771e:	81 e0       	ldi	r24, 0x01	; 1
    7720:	01 c0       	rjmp	.+2      	; 0x7724 <system_check_travel_limits+0xbc>
    7722:	81 e0       	ldi	r24, 0x01	; 1
    #endif
  }
  return(false);
}
    7724:	df 91       	pop	r29
    7726:	cf 91       	pop	r28
    7728:	ff 90       	pop	r15
    772a:	ef 90       	pop	r14
    772c:	df 90       	pop	r13
    772e:	cf 90       	pop	r12
    7730:	08 95       	ret

00007732 <system_set_exec_state_flag>:


// Special handlers for setting and clearing Grbl's real-time execution flags.
void system_set_exec_state_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    7732:	9f b7       	in	r25, 0x3f	; 63
  cli();
    7734:	f8 94       	cli
  sys_rt_exec_state |= (mask);
    7736:	20 91 31 0c 	lds	r18, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    773a:	82 2b       	or	r24, r18
    773c:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <sys_rt_exec_state>
  SREG = sreg;
    7740:	9f bf       	out	0x3f, r25	; 63
    7742:	08 95       	ret

00007744 <system_execute_line>:
// next line during a cycle, so for switches like block delete, the switch only effects
// the lines that are processed afterward, not necessarily real-time during a cycle,
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line)
{
    7744:	8f 92       	push	r8
    7746:	9f 92       	push	r9
    7748:	af 92       	push	r10
    774a:	bf 92       	push	r11
    774c:	cf 92       	push	r12
    774e:	df 92       	push	r13
    7750:	ef 92       	push	r14
    7752:	ff 92       	push	r15
    7754:	0f 93       	push	r16
    7756:	1f 93       	push	r17
    7758:	cf 93       	push	r28
    775a:	df 93       	push	r29
    775c:	cd b7       	in	r28, 0x3d	; 61
    775e:	de b7       	in	r29, 0x3e	; 62
    7760:	29 97       	sbiw	r28, 0x09	; 9
    7762:	0f b6       	in	r0, 0x3f	; 63
    7764:	f8 94       	cli
    7766:	de bf       	out	0x3e, r29	; 62
    7768:	0f be       	out	0x3f, r0	; 63
    776a:	cd bf       	out	0x3d, r28	; 61
    776c:	8c 01       	movw	r16, r24
  uint8_t char_counter = 1;
    776e:	81 e0       	ldi	r24, 0x01	; 1
    7770:	89 83       	std	Y+1, r24	; 0x01
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    7772:	f8 01       	movw	r30, r16
    7774:	81 81       	ldd	r24, Z+1	; 0x01
    7776:	83 34       	cpi	r24, 0x43	; 67
    7778:	09 f1       	breq	.+66     	; 0x77bc <system_execute_line+0x78>
    777a:	30 f4       	brcc	.+12     	; 0x7788 <system_execute_line+0x44>
    777c:	88 23       	and	r24, r24
    777e:	61 f0       	breq	.+24     	; 0x7798 <system_execute_line+0x54>
    7780:	84 32       	cpi	r24, 0x24	; 36
    7782:	09 f0       	breq	.+2      	; 0x7786 <system_execute_line+0x42>
    7784:	56 c0       	rjmp	.+172    	; 0x7832 <system_execute_line+0xee>
    7786:	1a c0       	rjmp	.+52     	; 0x77bc <system_execute_line+0x78>
    7788:	8a 34       	cpi	r24, 0x4A	; 74
    778a:	49 f0       	breq	.+18     	; 0x779e <system_execute_line+0x5a>
    778c:	88 35       	cpi	r24, 0x58	; 88
    778e:	b1 f0       	breq	.+44     	; 0x77bc <system_execute_line+0x78>
    7790:	87 34       	cpi	r24, 0x47	; 71
    7792:	09 f0       	breq	.+2      	; 0x7796 <system_execute_line+0x52>
    7794:	4e c0       	rjmp	.+156    	; 0x7832 <system_execute_line+0xee>
    7796:	12 c0       	rjmp	.+36     	; 0x77bc <system_execute_line+0x78>
    case 0 : report_grbl_help(); break;
    7798:	15 da       	rcall	.-3030   	; 0x6bc4 <report_grbl_help>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    779a:	f1 2c       	mov	r15, r1
{
  uint8_t char_counter = 1;
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    779c:	14 c2       	rjmp	.+1064   	; 0x7bc6 <system_execute_line+0x482>
    case 'J' : // Jogging
      // Execute only if in IDLE or JOG states.
      if (sys.state != STATE_IDLE && sys.state != STATE_JOG) { return(STATUS_IDLE_ERROR); }
    779e:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    77a2:	8f 7d       	andi	r24, 0xDF	; 223
    77a4:	09 f0       	breq	.+2      	; 0x77a8 <system_execute_line+0x64>
    77a6:	85 c1       	rjmp	.+778    	; 0x7ab2 <system_execute_line+0x36e>
      if(line[2] != '=') { return(STATUS_INVALID_STATEMENT); }
    77a8:	f8 01       	movw	r30, r16
    77aa:	82 81       	ldd	r24, Z+2	; 0x02
    77ac:	8d 33       	cpi	r24, 0x3D	; 61
    77ae:	09 f0       	breq	.+2      	; 0x77b2 <system_execute_line+0x6e>
    77b0:	84 c1       	rjmp	.+776    	; 0x7aba <system_execute_line+0x376>
      return(gc_execute_line(line)); // NOTE: $J= is ignored inside g-code parser and used to detect jog motions.
    77b2:	c8 01       	movw	r24, r16
    77b4:	0e 94 60 07 	call	0xec0	; 0xec0 <gc_execute_line>
    77b8:	f8 2e       	mov	r15, r24
    77ba:	05 c2       	rjmp	.+1034   	; 0x7bc6 <system_execute_line+0x482>
      break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    77bc:	f8 01       	movw	r30, r16
    77be:	92 81       	ldd	r25, Z+2	; 0x02
    77c0:	91 11       	cpse	r25, r1
    77c2:	80 c1       	rjmp	.+768    	; 0x7ac4 <system_execute_line+0x380>
      switch( line[1] ) {
    77c4:	83 34       	cpi	r24, 0x43	; 67
    77c6:	a1 f0       	breq	.+40     	; 0x77f0 <system_execute_line+0xac>
    77c8:	18 f4       	brcc	.+6      	; 0x77d0 <system_execute_line+0x8c>
    77ca:	84 32       	cpi	r24, 0x24	; 36
    77cc:	31 f0       	breq	.+12     	; 0x77da <system_execute_line+0x96>
    77ce:	7f c1       	rjmp	.+766    	; 0x7ace <system_execute_line+0x38a>
    77d0:	87 34       	cpi	r24, 0x47	; 71
    77d2:	59 f0       	breq	.+22     	; 0x77ea <system_execute_line+0xa6>
    77d4:	88 35       	cpi	r24, 0x58	; 88
    77d6:	f9 f0       	breq	.+62     	; 0x7816 <system_execute_line+0xd2>
    77d8:	7a c1       	rjmp	.+756    	; 0x7ace <system_execute_line+0x38a>
    77da:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    77de:	88 71       	andi	r24, 0x18	; 24
    77e0:	f8 2e       	mov	r15, r24
        case '$' : // Prints Grbl settings
          if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    77e2:	09 f0       	breq	.+2      	; 0x77e6 <system_execute_line+0xa2>
          else { report_grbl_settings(); }
    77e4:	76 c1       	rjmp	.+748    	; 0x7ad2 <system_execute_line+0x38e>
          break;
    77e6:	f2 d9       	rcall	.-3100   	; 0x6bcc <report_grbl_settings>
        case 'G' : // Prints gcode parser state
          // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
          report_gcode_modes();
    77e8:	ee c1       	rjmp	.+988    	; 0x7bc6 <system_execute_line+0x482>
    77ea:	7e db       	rcall	.-2308   	; 0x6ee8 <report_gcode_modes>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    77ec:	f1 2c       	mov	r15, r1
          else { report_grbl_settings(); }
          break;
        case 'G' : // Prints gcode parser state
          // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
          report_gcode_modes();
          break;
    77ee:	eb c1       	rjmp	.+982    	; 0x7bc6 <system_execute_line+0x482>
        case 'C' : // Set check g-code mode [IDLE/CHECK]
          // Perform reset when toggling off. Check g-code mode should only work if Grbl
          // is idle and ready, regardless of alarm locks. This is mainly to keep things
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) {
    77f0:	f0 90 1e 0c 	lds	r15, 0x0C1E	; 0x800c1e <sys>
    77f4:	f2 e0       	ldi	r31, 0x02	; 2
    77f6:	ff 12       	cpse	r15, r31
    77f8:	06 c0       	rjmp	.+12     	; 0x7806 <system_execute_line+0xc2>
            mc_reset();
    77fa:	0e 94 23 07 	call	0xe46	; 0xe46 <mc_reset>
            report_feedback_message(MESSAGE_DISABLED);
    77fe:	85 e0       	ldi	r24, 0x05	; 5
    7800:	9d d9       	rcall	.-3270   	; 0x6b3c <report_feedback_message>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7802:	f1 2c       	mov	r15, r1
    7804:	e0 c1       	rjmp	.+960    	; 0x7bc6 <system_execute_line+0x482>
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) {
            mc_reset();
            report_feedback_message(MESSAGE_DISABLED);
          } else {
            if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    7806:	f1 10       	cpse	r15, r1
    7808:	68 c1       	rjmp	.+720    	; 0x7ada <system_execute_line+0x396>
            sys.state = STATE_CHECK_MODE;
    780a:	82 e0       	ldi	r24, 0x02	; 2
    780c:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
            report_feedback_message(MESSAGE_ENABLED);
    7810:	84 e0       	ldi	r24, 0x04	; 4
    7812:	94 d9       	rcall	.-3288   	; 0x6b3c <report_feedback_message>
    7814:	d8 c1       	rjmp	.+944    	; 0x7bc6 <system_execute_line+0x482>
          }
          break;
        case 'X' : // Disable alarm lock [ALARM]
          if (sys.state == STATE_ALARM) {
    7816:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    781a:	81 30       	cpi	r24, 0x01	; 1
    781c:	09 f0       	breq	.+2      	; 0x7820 <system_execute_line+0xdc>
            // Block if safety door is ajar.
            if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); }
    781e:	61 c1       	rjmp	.+706    	; 0x7ae2 <system_execute_line+0x39e>
    7820:	c5 de       	rcall	.-630    	; 0x75ac <system_check_safety_door_ajar>
    7822:	f8 2e       	mov	r15, r24
    7824:	81 11       	cpse	r24, r1
            report_feedback_message(MESSAGE_ALARM_UNLOCK);
    7826:	5f c1       	rjmp	.+702    	; 0x7ae6 <system_execute_line+0x3a2>
    7828:	83 e0       	ldi	r24, 0x03	; 3
    782a:	88 d9       	rcall	.-3312   	; 0x6b3c <report_feedback_message>
            sys.state = STATE_IDLE;
    782c:	10 92 1e 0c 	sts	0x0C1E, r1	; 0x800c1e <sys>
    7830:	ca c1       	rjmp	.+916    	; 0x7bc6 <system_execute_line+0x482>
          break;
      }
      break;
    default :
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    7832:	90 91 1e 0c 	lds	r25, 0x0C1E	; 0x800c1e <sys>
    7836:	92 30       	cpi	r25, 0x02	; 2
    7838:	08 f0       	brcs	.+2      	; 0x783c <system_execute_line+0xf8>
    783a:	5a c1       	rjmp	.+692    	; 0x7af0 <system_execute_line+0x3ac>
      switch( line[1] ) {
    783c:	89 34       	cpi	r24, 0x49	; 73
    783e:	09 f4       	brne	.+2      	; 0x7842 <system_execute_line+0xfe>
    7840:	5e c0       	rjmp	.+188    	; 0x78fe <system_execute_line+0x1ba>
    7842:	28 f4       	brcc	.+10     	; 0x784e <system_execute_line+0x10a>
    7844:	83 32       	cpi	r24, 0x23	; 35
    7846:	69 f0       	breq	.+26     	; 0x7862 <system_execute_line+0x11e>
    7848:	88 34       	cpi	r24, 0x48	; 72
    784a:	91 f0       	breq	.+36     	; 0x7870 <system_execute_line+0x12c>
    784c:	c2 c0       	rjmp	.+388    	; 0x79d2 <system_execute_line+0x28e>
    784e:	82 35       	cpi	r24, 0x52	; 82
    7850:	09 f4       	brne	.+2      	; 0x7854 <system_execute_line+0x110>
    7852:	77 c0       	rjmp	.+238    	; 0x7942 <system_execute_line+0x1fe>
    7854:	83 35       	cpi	r24, 0x53	; 83
    7856:	09 f4       	brne	.+2      	; 0x785a <system_execute_line+0x116>
    7858:	42 c0       	rjmp	.+132    	; 0x78de <system_execute_line+0x19a>
    785a:	8e 34       	cpi	r24, 0x4E	; 78
    785c:	09 f0       	breq	.+2      	; 0x7860 <system_execute_line+0x11c>
    785e:	b9 c0       	rjmp	.+370    	; 0x79d2 <system_execute_line+0x28e>
    7860:	9a c0       	rjmp	.+308    	; 0x7996 <system_execute_line+0x252>
        case '#' : // Print Grbl NGC parameters
          if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7862:	f8 01       	movw	r30, r16
    7864:	82 81       	ldd	r24, Z+2	; 0x02
    7866:	81 11       	cpse	r24, r1
          else { report_ngc_parameters(); }
    7868:	47 c1       	rjmp	.+654    	; 0x7af8 <system_execute_line+0x3b4>
    786a:	d7 da       	rcall	.-2642   	; 0x6e1a <report_ngc_parameters>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    786c:	f1 2c       	mov	r15, r1
        case '#' : // Print Grbl NGC parameters
          if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
          else { report_ngc_parameters(); }
          break;
        case 'H' : // Perform homing cycle [IDLE/ALARM]
          if (bit_isfalse(settings.flags,BITFLAG_HOMING_ENABLE)) {return(STATUS_SETTING_DISABLED); }
    786e:	ab c1       	rjmp	.+854    	; 0x7bc6 <system_execute_line+0x482>
    7870:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    7874:	84 ff       	sbrs	r24, 4
          if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); } // Block if safety door is ajar.
    7876:	45 c1       	rjmp	.+650    	; 0x7b02 <system_execute_line+0x3be>
    7878:	99 de       	rcall	.-718    	; 0x75ac <system_check_safety_door_ajar>
    787a:	e8 2e       	mov	r14, r24
    787c:	81 11       	cpse	r24, r1
    787e:	46 c1       	rjmp	.+652    	; 0x7b0c <system_execute_line+0x3c8>
          sys.state = STATE_HOMING; // Set system state variable
    7880:	84 e0       	ldi	r24, 0x04	; 4
    7882:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
          if (line[2] == 0) {
    7886:	f8 01       	movw	r30, r16
    7888:	82 81       	ldd	r24, Z+2	; 0x02
    788a:	81 11       	cpse	r24, r1
    788c:	03 c0       	rjmp	.+6      	; 0x7894 <system_execute_line+0x150>
            mc_homing_cycle(HOMING_CYCLE_ALL);
    788e:	0e 94 91 06 	call	0xd22	; 0xd22 <mc_homing_cycle>
    7892:	16 c0       	rjmp	.+44     	; 0x78c0 <system_execute_line+0x17c>
          #ifdef HOMING_SINGLE_AXIS_COMMANDS
            } else if (line[3] == 0) {
    7894:	f8 01       	movw	r30, r16
    7896:	93 81       	ldd	r25, Z+3	; 0x03
    7898:	91 11       	cpse	r25, r1
    789a:	3d c1       	rjmp	.+634    	; 0x7b16 <system_execute_line+0x3d2>
              switch (line[2]) {
    789c:	89 35       	cpi	r24, 0x59	; 89
    789e:	49 f0       	breq	.+18     	; 0x78b2 <system_execute_line+0x16e>
    78a0:	8a 35       	cpi	r24, 0x5A	; 90
    78a2:	59 f0       	breq	.+22     	; 0x78ba <system_execute_line+0x176>
    78a4:	88 35       	cpi	r24, 0x58	; 88
    78a6:	09 f0       	breq	.+2      	; 0x78aa <system_execute_line+0x166>
    78a8:	3b c1       	rjmp	.+630    	; 0x7b20 <system_execute_line+0x3dc>
                case 'X': mc_homing_cycle(HOMING_CYCLE_X); break;
    78aa:	81 e0       	ldi	r24, 0x01	; 1
    78ac:	0e 94 91 06 	call	0xd22	; 0xd22 <mc_homing_cycle>
    78b0:	07 c0       	rjmp	.+14     	; 0x78c0 <system_execute_line+0x17c>
                case 'Y': mc_homing_cycle(HOMING_CYCLE_Y); break;
    78b2:	82 e0       	ldi	r24, 0x02	; 2
    78b4:	0e 94 91 06 	call	0xd22	; 0xd22 <mc_homing_cycle>
    78b8:	03 c0       	rjmp	.+6      	; 0x78c0 <system_execute_line+0x17c>
                case 'Z': mc_homing_cycle(HOMING_CYCLE_Z); break;
    78ba:	84 e0       	ldi	r24, 0x04	; 4
    78bc:	0e 94 91 06 	call	0xd22	; 0xd22 <mc_homing_cycle>
                default: return(STATUS_INVALID_STATEMENT);
              }
          #endif
          } else { return(STATUS_INVALID_STATEMENT); }
          if (!sys.abort) {  // Execute startup scripts after successful homing.
    78c0:	f0 90 1f 0c 	lds	r15, 0x0C1F	; 0x800c1f <sys+0x1>
    78c4:	f1 10       	cpse	r15, r1
    78c6:	31 c1       	rjmp	.+610    	; 0x7b2a <system_execute_line+0x3e6>
            sys.state = STATE_IDLE; // Set to IDLE when complete.
    78c8:	10 92 1e 0c 	sts	0x0C1E, r1	; 0x800c1e <sys>
            st_go_idle(); // Set steppers to the settings idle state before returning.
    78cc:	0e 94 57 19 	call	0x32ae	; 0x32ae <st_go_idle>
            if (line[2] == 0) { system_execute_startup(line); }
    78d0:	f8 01       	movw	r30, r16
    78d2:	82 81       	ldd	r24, Z+2	; 0x02
    78d4:	81 11       	cpse	r24, r1
    78d6:	77 c1       	rjmp	.+750    	; 0x7bc6 <system_execute_line+0x482>
    78d8:	c8 01       	movw	r24, r16
    78da:	6b de       	rcall	.-810    	; 0x75b2 <system_execute_startup>
    78dc:	74 c1       	rjmp	.+744    	; 0x7bc6 <system_execute_line+0x482>
          }
          break;
        case 'S' : // Puts Grbl to sleep [IDLE/ALARM]
          if ((line[2] != 'L') || (line[3] != 'P') || (line[4] != 0)) { return(STATUS_INVALID_STATEMENT); }
    78de:	f8 01       	movw	r30, r16
    78e0:	82 81       	ldd	r24, Z+2	; 0x02
    78e2:	8c 34       	cpi	r24, 0x4C	; 76
    78e4:	09 f0       	breq	.+2      	; 0x78e8 <system_execute_line+0x1a4>
    78e6:	23 c1       	rjmp	.+582    	; 0x7b2e <system_execute_line+0x3ea>
    78e8:	83 81       	ldd	r24, Z+3	; 0x03
    78ea:	80 35       	cpi	r24, 0x50	; 80
    78ec:	09 f0       	breq	.+2      	; 0x78f0 <system_execute_line+0x1ac>
    78ee:	24 c1       	rjmp	.+584    	; 0x7b38 <system_execute_line+0x3f4>
    78f0:	84 81       	ldd	r24, Z+4	; 0x04
    78f2:	81 11       	cpse	r24, r1
          system_set_exec_state_flag(EXEC_SLEEP); // Set to execute sleep mode immediately
    78f4:	26 c1       	rjmp	.+588    	; 0x7b42 <system_execute_line+0x3fe>
    78f6:	80 e8       	ldi	r24, 0x80	; 128
    78f8:	1c df       	rcall	.-456    	; 0x7732 <system_set_exec_state_flag>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    78fa:	f1 2c       	mov	r15, r1
          }
          break;
        case 'S' : // Puts Grbl to sleep [IDLE/ALARM]
          if ((line[2] != 'L') || (line[3] != 'P') || (line[4] != 0)) { return(STATUS_INVALID_STATEMENT); }
          system_set_exec_state_flag(EXEC_SLEEP); // Set to execute sleep mode immediately
          break;
    78fc:	64 c1       	rjmp	.+712    	; 0x7bc6 <system_execute_line+0x482>
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) {
    78fe:	82 e0       	ldi	r24, 0x02	; 2
    7900:	89 83       	std	Y+1, r24	; 0x01
    7902:	f8 01       	movw	r30, r16
    7904:	82 81       	ldd	r24, Z+2	; 0x02
    7906:	81 11       	cpse	r24, r1
            settings_read_build_info(line);
    7908:	07 c0       	rjmp	.+14     	; 0x7918 <system_execute_line+0x1d4>
    790a:	c8 01       	movw	r24, r16
    790c:	0e 94 07 26 	call	0x4c0e	; 0x4c0e <settings_read_build_info>
            report_build_info(line);
    7910:	c8 01       	movw	r24, r16
    7912:	a2 db       	rcall	.-2236   	; 0x7058 <report_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7914:	f1 2c       	mov	r15, r1
    7916:	57 c1       	rjmp	.+686    	; 0x7bc6 <system_execute_line+0x482>
          if ( line[++char_counter] == 0 ) {
            settings_read_build_info(line);
            report_build_info(line);
          #ifdef ENABLE_BUILD_INFO_WRITE_COMMAND
            } else { // Store startup line [IDLE/ALARM]
              if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    7918:	8d 33       	cpi	r24, 0x3D	; 61
    791a:	09 f0       	breq	.+2      	; 0x791e <system_execute_line+0x1da>
    791c:	17 c1       	rjmp	.+558    	; 0x7b4c <system_execute_line+0x408>
    791e:	83 e0       	ldi	r24, 0x03	; 3
              helper_var = char_counter; // Set helper variable as counter to start of user info line.
              do {
                line[char_counter-helper_var] = line[char_counter];
    7920:	f8 01       	movw	r30, r16
    7922:	e8 0f       	add	r30, r24
    7924:	f1 1d       	adc	r31, r1
    7926:	90 81       	ld	r25, Z
    7928:	df 01       	movw	r26, r30
    792a:	13 97       	sbiw	r26, 0x03	; 3
    792c:	9c 93       	st	X, r25
              } while (line[char_counter++] != 0);
    792e:	8f 5f       	subi	r24, 0xFF	; 255
    7930:	90 81       	ld	r25, Z
    7932:	91 11       	cpse	r25, r1
    7934:	f5 cf       	rjmp	.-22     	; 0x7920 <system_execute_line+0x1dc>
    7936:	89 83       	std	Y+1, r24	; 0x01
              settings_store_build_info(line);
    7938:	c8 01       	movw	r24, r16
    793a:	0e 94 70 25 	call	0x4ae0	; 0x4ae0 <settings_store_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    793e:	f1 2c       	mov	r15, r1
    7940:	42 c1       	rjmp	.+644    	; 0x7bc6 <system_execute_line+0x482>
              settings_store_build_info(line);
          #endif
          }
          break;
        case 'R' : // Restore defaults [IDLE/ALARM]
          if ((line[2] != 'S') || (line[3] != 'T') || (line[4] != '=') || (line[6] != 0)) { return(STATUS_INVALID_STATEMENT); }
    7942:	f8 01       	movw	r30, r16
    7944:	82 81       	ldd	r24, Z+2	; 0x02
    7946:	83 35       	cpi	r24, 0x53	; 83
    7948:	09 f0       	breq	.+2      	; 0x794c <system_execute_line+0x208>
    794a:	05 c1       	rjmp	.+522    	; 0x7b56 <system_execute_line+0x412>
    794c:	83 81       	ldd	r24, Z+3	; 0x03
    794e:	84 35       	cpi	r24, 0x54	; 84
    7950:	09 f0       	breq	.+2      	; 0x7954 <system_execute_line+0x210>
    7952:	06 c1       	rjmp	.+524    	; 0x7b60 <system_execute_line+0x41c>
    7954:	84 81       	ldd	r24, Z+4	; 0x04
    7956:	8d 33       	cpi	r24, 0x3D	; 61
    7958:	09 f0       	breq	.+2      	; 0x795c <system_execute_line+0x218>
    795a:	07 c1       	rjmp	.+526    	; 0x7b6a <system_execute_line+0x426>
    795c:	86 81       	ldd	r24, Z+6	; 0x06
    795e:	81 11       	cpse	r24, r1
    7960:	09 c1       	rjmp	.+530    	; 0x7b74 <system_execute_line+0x430>
          switch (line[5]) {
    7962:	85 81       	ldd	r24, Z+5	; 0x05
    7964:	84 32       	cpi	r24, 0x24	; 36
    7966:	31 f0       	breq	.+12     	; 0x7974 <system_execute_line+0x230>
    7968:	8a 32       	cpi	r24, 0x2A	; 42
    796a:	61 f0       	breq	.+24     	; 0x7984 <system_execute_line+0x240>
    796c:	83 32       	cpi	r24, 0x23	; 35
    796e:	09 f0       	breq	.+2      	; 0x7972 <system_execute_line+0x22e>
    7970:	06 c1       	rjmp	.+524    	; 0x7b7e <system_execute_line+0x43a>
    7972:	04 c0       	rjmp	.+8      	; 0x797c <system_execute_line+0x238>
            #ifdef ENABLE_RESTORE_EEPROM_DEFAULT_SETTINGS
              case '$': settings_restore(SETTINGS_RESTORE_DEFAULTS); break;
    7974:	81 e0       	ldi	r24, 0x01	; 1
    7976:	0e 94 97 25 	call	0x4b2e	; 0x4b2e <settings_restore>
            #endif
            #ifdef ENABLE_RESTORE_EEPROM_CLEAR_PARAMETERS
              case '#': settings_restore(SETTINGS_RESTORE_PARAMETERS); break;
    797a:	07 c0       	rjmp	.+14     	; 0x798a <system_execute_line+0x246>
    797c:	82 e0       	ldi	r24, 0x02	; 2
    797e:	0e 94 97 25 	call	0x4b2e	; 0x4b2e <settings_restore>
            #endif
            #ifdef ENABLE_RESTORE_EEPROM_WIPE_ALL
              case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
    7982:	03 c0       	rjmp	.+6      	; 0x798a <system_execute_line+0x246>
    7984:	8f ef       	ldi	r24, 0xFF	; 255
    7986:	0e 94 97 25 	call	0x4b2e	; 0x4b2e <settings_restore>
            #endif
            default: return(STATUS_INVALID_STATEMENT);
          }
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
    798a:	89 e0       	ldi	r24, 0x09	; 9
    798c:	d7 d8       	rcall	.-3666   	; 0x6b3c <report_feedback_message>
          mc_reset(); // Force reset to ensure settings are initialized correctly.
    798e:	0e 94 23 07 	call	0xe46	; 0xe46 <mc_reset>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7992:	f1 2c       	mov	r15, r1
            #endif
            default: return(STATUS_INVALID_STATEMENT);
          }
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
          mc_reset(); // Force reset to ensure settings are initialized correctly.
          break;
    7994:	18 c1       	rjmp	.+560    	; 0x7bc6 <system_execute_line+0x482>
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
    7996:	82 e0       	ldi	r24, 0x02	; 2
    7998:	89 83       	std	Y+1, r24	; 0x01
    799a:	f8 01       	movw	r30, r16
    799c:	82 81       	ldd	r24, Z+2	; 0x02
    799e:	81 11       	cpse	r24, r1
    79a0:	13 c0       	rjmp	.+38     	; 0x79c8 <system_execute_line+0x284>
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
              if (!(settings_read_startup_line(helper_var, line))) {
    79a2:	f1 2c       	mov	r15, r1
    79a4:	b8 01       	movw	r22, r16
    79a6:	8f 2d       	mov	r24, r15
    79a8:	0e 94 e9 25 	call	0x4bd2	; 0x4bd2 <settings_read_startup_line>
                report_status_message(STATUS_SETTING_READ_FAIL);
    79ac:	81 11       	cpse	r24, r1
    79ae:	03 c0       	rjmp	.+6      	; 0x79b6 <system_execute_line+0x272>
    79b0:	87 e0       	ldi	r24, 0x07	; 7
    79b2:	84 d8       	rcall	.-3832   	; 0x6abc <report_status_message>
              } else {
                report_startup_line(helper_var,line);
    79b4:	03 c0       	rjmp	.+6      	; 0x79bc <system_execute_line+0x278>
    79b6:	b8 01       	movw	r22, r16
    79b8:	8f 2d       	mov	r24, r15
    79ba:	27 db       	rcall	.-2482   	; 0x700a <report_startup_line>
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
          mc_reset(); // Force reset to ensure settings are initialized correctly.
          break;
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
    79bc:	f3 94       	inc	r15
    79be:	f2 e0       	ldi	r31, 0x02	; 2
    79c0:	ff 12       	cpse	r15, r31
    79c2:	f0 cf       	rjmp	.-32     	; 0x79a4 <system_execute_line+0x260>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    79c4:	f1 2c       	mov	r15, r1
    79c6:	ff c0       	rjmp	.+510    	; 0x7bc6 <system_execute_line+0x482>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    79c8:	91 11       	cpse	r25, r1
    79ca:	de c0       	rjmp	.+444    	; 0x7b88 <system_execute_line+0x444>
            helper_var = true;  // Set helper_var to flag storing method.
    79cc:	ff 24       	eor	r15, r15
    79ce:	f3 94       	inc	r15
    79d0:	01 c0       	rjmp	.+2      	; 0x79d4 <system_execute_line+0x290>
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line)
{
  uint8_t char_counter = 1;
  uint8_t helper_var = 0; // Helper variable
    79d2:	f1 2c       	mov	r15, r1
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
            helper_var = true;  // Set helper_var to flag storing method.
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    79d4:	ae 01       	movw	r20, r28
    79d6:	4e 5f       	subi	r20, 0xFE	; 254
    79d8:	5f 4f       	sbci	r21, 0xFF	; 255
    79da:	be 01       	movw	r22, r28
    79dc:	6f 5f       	subi	r22, 0xFF	; 255
    79de:	7f 4f       	sbci	r23, 0xFF	; 255
    79e0:	c8 01       	movw	r24, r16
    79e2:	0e 94 2d 2e 	call	0x5c5a	; 0x5c5a <read_float>
    79e6:	88 23       	and	r24, r24
    79e8:	09 f4       	brne	.+2      	; 0x79ec <system_execute_line+0x2a8>
    79ea:	d2 c0       	rjmp	.+420    	; 0x7b90 <system_execute_line+0x44c>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    79ec:	89 81       	ldd	r24, Y+1	; 0x01
    79ee:	41 e0       	ldi	r20, 0x01	; 1
    79f0:	48 0f       	add	r20, r24
    79f2:	49 83       	std	Y+1, r20	; 0x01
    79f4:	f8 01       	movw	r30, r16
    79f6:	e8 0f       	add	r30, r24
    79f8:	f1 1d       	adc	r31, r1
    79fa:	80 81       	ld	r24, Z
    79fc:	8d 33       	cpi	r24, 0x3D	; 61
    79fe:	09 f0       	breq	.+2      	; 0x7a02 <system_execute_line+0x2be>
    7a00:	cb c0       	rjmp	.+406    	; 0x7b98 <system_execute_line+0x454>
          if (helper_var) { // Store startup line
    7a02:	ff 20       	and	r15, r15
    7a04:	39 f1       	breq	.+78     	; 0x7a54 <system_execute_line+0x310>
    7a06:	24 2f       	mov	r18, r20
            // Prepare sending gcode block to gcode parser by shifting all characters
            helper_var = char_counter; // Set helper variable as counter to start of gcode block
            do {
              line[char_counter-helper_var] = line[char_counter];
    7a08:	50 e0       	ldi	r21, 0x00	; 0
    7a0a:	82 2f       	mov	r24, r18
    7a0c:	90 e0       	ldi	r25, 0x00	; 0
    7a0e:	d8 01       	movw	r26, r16
    7a10:	a8 0f       	add	r26, r24
    7a12:	b9 1f       	adc	r27, r25
    7a14:	3c 91       	ld	r19, X
    7a16:	84 1b       	sub	r24, r20
    7a18:	95 0b       	sbc	r25, r21
    7a1a:	f8 01       	movw	r30, r16
    7a1c:	e8 0f       	add	r30, r24
    7a1e:	f9 1f       	adc	r31, r25
    7a20:	30 83       	st	Z, r19
            } while (line[char_counter++] != 0);
    7a22:	2f 5f       	subi	r18, 0xFF	; 255
    7a24:	8c 91       	ld	r24, X
    7a26:	81 11       	cpse	r24, r1
    7a28:	f0 cf       	rjmp	.-32     	; 0x7a0a <system_execute_line+0x2c6>
    7a2a:	29 83       	std	Y+1, r18	; 0x01
            if (char_counter > EEPROM_LINE_SIZE) { return(STATUS_LINE_LENGTH_EXCEEDED); }
    7a2c:	21 35       	cpi	r18, 0x51	; 81
    7a2e:	08 f0       	brcs	.+2      	; 0x7a32 <system_execute_line+0x2ee>
    7a30:	b8 c0       	rjmp	.+368    	; 0x7ba2 <system_execute_line+0x45e>
            // Execute gcode block to ensure block is valid.
            helper_var = gc_execute_line(line); // Set helper_var to returned status code.
    7a32:	c8 01       	movw	r24, r16
    7a34:	0e 94 60 07 	call	0xec0	; 0xec0 <gc_execute_line>
            if (helper_var) { return(helper_var); }
    7a38:	f8 2e       	mov	r15, r24
            else {
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
    7a3a:	81 11       	cpse	r24, r1
    7a3c:	c4 c0       	rjmp	.+392    	; 0x7bc6 <system_execute_line+0x482>
    7a3e:	6a 81       	ldd	r22, Y+2	; 0x02
    7a40:	7b 81       	ldd	r23, Y+3	; 0x03
    7a42:	8c 81       	ldd	r24, Y+4	; 0x04
    7a44:	9d 81       	ldd	r25, Y+5	; 0x05
              settings_store_startup_line(helper_var,line);
    7a46:	51 d5       	rcall	.+2722   	; 0x84ea <trunc>
    7a48:	b8 d2       	rcall	.+1392   	; 0x7fba <__fixunssfsi>
    7a4a:	86 2f       	mov	r24, r22
    7a4c:	b8 01       	movw	r22, r16
    7a4e:	0e 94 59 25 	call	0x4ab2	; 0x4ab2 <settings_store_startup_line>
    7a52:	b9 c0       	rjmp	.+370    	; 0x7bc6 <system_execute_line+0x482>
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    7a54:	ae 01       	movw	r20, r28
    7a56:	4a 5f       	subi	r20, 0xFA	; 250
    7a58:	5f 4f       	sbci	r21, 0xFF	; 255
    7a5a:	be 01       	movw	r22, r28
    7a5c:	6f 5f       	subi	r22, 0xFF	; 255
    7a5e:	7f 4f       	sbci	r23, 0xFF	; 255
    7a60:	c8 01       	movw	r24, r16
    7a62:	0e 94 2d 2e 	call	0x5c5a	; 0x5c5a <read_float>
    7a66:	88 23       	and	r24, r24
    7a68:	09 f4       	brne	.+2      	; 0x7a6c <system_execute_line+0x328>
    7a6a:	a0 c0       	rjmp	.+320    	; 0x7bac <system_execute_line+0x468>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    7a6c:	89 81       	ldd	r24, Y+1	; 0x01
    7a6e:	f8 01       	movw	r30, r16
    7a70:	e8 0f       	add	r30, r24
    7a72:	f1 1d       	adc	r31, r1
    7a74:	80 81       	ld	r24, Z
    7a76:	81 11       	cpse	r24, r1
    7a78:	9d c0       	rjmp	.+314    	; 0x7bb4 <system_execute_line+0x470>
    7a7a:	ca 80       	ldd	r12, Y+2	; 0x02
    7a7c:	db 80       	ldd	r13, Y+3	; 0x03
    7a7e:	ec 80       	ldd	r14, Y+4	; 0x04
    7a80:	fd 80       	ldd	r15, Y+5	; 0x05
    7a82:	20 e0       	ldi	r18, 0x00	; 0
    7a84:	30 e0       	ldi	r19, 0x00	; 0
    7a86:	4f e7       	ldi	r20, 0x7F	; 127
    7a88:	53 e4       	ldi	r21, 0x43	; 67
    7a8a:	c7 01       	movw	r24, r14
    7a8c:	b6 01       	movw	r22, r12
    7a8e:	24 d4       	rcall	.+2120   	; 0x82d8 <__gesf2>
    7a90:	18 16       	cp	r1, r24
    7a92:	0c f4       	brge	.+2      	; 0x7a96 <system_execute_line+0x352>
            return(settings_store_global_setting((uint8_t)parameter, value));
    7a94:	94 c0       	rjmp	.+296    	; 0x7bbe <system_execute_line+0x47a>
    7a96:	8e 80       	ldd	r8, Y+6	; 0x06
    7a98:	9f 80       	ldd	r9, Y+7	; 0x07
    7a9a:	a8 84       	ldd	r10, Y+8	; 0x08
    7a9c:	b9 84       	ldd	r11, Y+9	; 0x09
    7a9e:	c7 01       	movw	r24, r14
    7aa0:	b6 01       	movw	r22, r12
    7aa2:	8b d2       	rcall	.+1302   	; 0x7fba <__fixunssfsi>
    7aa4:	86 2f       	mov	r24, r22
    7aa6:	b5 01       	movw	r22, r10
    7aa8:	a4 01       	movw	r20, r8
    7aaa:	0e 94 4d 26 	call	0x4c9a	; 0x4c9a <settings_store_global_setting>
    7aae:	f8 2e       	mov	r15, r24
    7ab0:	8a c0       	rjmp	.+276    	; 0x7bc6 <system_execute_line+0x482>
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    case 'J' : // Jogging
      // Execute only if in IDLE or JOG states.
      if (sys.state != STATE_IDLE && sys.state != STATE_JOG) { return(STATUS_IDLE_ERROR); }
    7ab2:	68 94       	set
    7ab4:	ff 24       	eor	r15, r15
    7ab6:	f3 f8       	bld	r15, 3
    7ab8:	86 c0       	rjmp	.+268    	; 0x7bc6 <system_execute_line+0x482>
      if(line[2] != '=') { return(STATUS_INVALID_STATEMENT); }
    7aba:	0f 2e       	mov	r0, r31
    7abc:	f3 e0       	ldi	r31, 0x03	; 3
    7abe:	ff 2e       	mov	r15, r31
    7ac0:	f0 2d       	mov	r31, r0
    7ac2:	81 c0       	rjmp	.+258    	; 0x7bc6 <system_execute_line+0x482>
      return(gc_execute_line(line)); // NOTE: $J= is ignored inside g-code parser and used to detect jog motions.
      break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7ac4:	0f 2e       	mov	r0, r31
    7ac6:	f3 e0       	ldi	r31, 0x03	; 3
    7ac8:	ff 2e       	mov	r15, r31
    7aca:	f0 2d       	mov	r31, r0
    7acc:	7c c0       	rjmp	.+248    	; 0x7bc6 <system_execute_line+0x482>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7ace:	f1 2c       	mov	r15, r1
    7ad0:	7a c0       	rjmp	.+244    	; 0x7bc6 <system_execute_line+0x482>
      break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
      switch( line[1] ) {
        case '$' : // Prints Grbl settings
          if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    7ad2:	68 94       	set
    7ad4:	ff 24       	eor	r15, r15
    7ad6:	f3 f8       	bld	r15, 3
    7ad8:	76 c0       	rjmp	.+236    	; 0x7bc6 <system_execute_line+0x482>
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) {
            mc_reset();
            report_feedback_message(MESSAGE_DISABLED);
          } else {
            if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    7ada:	68 94       	set
    7adc:	ff 24       	eor	r15, r15
    7ade:	f3 f8       	bld	r15, 3
    7ae0:	72 c0       	rjmp	.+228    	; 0x7bc6 <system_execute_line+0x482>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7ae2:	f1 2c       	mov	r15, r1
    7ae4:	70 c0       	rjmp	.+224    	; 0x7bc6 <system_execute_line+0x482>
          }
          break;
        case 'X' : // Disable alarm lock [ALARM]
          if (sys.state == STATE_ALARM) {
            // Block if safety door is ajar.
            if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); }
    7ae6:	0f 2e       	mov	r0, r31
    7ae8:	fd e0       	ldi	r31, 0x0D	; 13
    7aea:	ff 2e       	mov	r15, r31
    7aec:	f0 2d       	mov	r31, r0
    7aee:	6b c0       	rjmp	.+214    	; 0x7bc6 <system_execute_line+0x482>
          break;
      }
      break;
    default :
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    7af0:	68 94       	set
    7af2:	ff 24       	eor	r15, r15
    7af4:	f3 f8       	bld	r15, 3
    7af6:	67 c0       	rjmp	.+206    	; 0x7bc6 <system_execute_line+0x482>
      switch( line[1] ) {
        case '#' : // Print Grbl NGC parameters
          if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7af8:	0f 2e       	mov	r0, r31
    7afa:	f3 e0       	ldi	r31, 0x03	; 3
    7afc:	ff 2e       	mov	r15, r31
    7afe:	f0 2d       	mov	r31, r0
    7b00:	62 c0       	rjmp	.+196    	; 0x7bc6 <system_execute_line+0x482>
          else { report_ngc_parameters(); }
          break;
        case 'H' : // Perform homing cycle [IDLE/ALARM]
          if (bit_isfalse(settings.flags,BITFLAG_HOMING_ENABLE)) {return(STATUS_SETTING_DISABLED); }
    7b02:	0f 2e       	mov	r0, r31
    7b04:	f5 e0       	ldi	r31, 0x05	; 5
    7b06:	ff 2e       	mov	r15, r31
    7b08:	f0 2d       	mov	r31, r0
    7b0a:	5d c0       	rjmp	.+186    	; 0x7bc6 <system_execute_line+0x482>
          if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); } // Block if safety door is ajar.
    7b0c:	0f 2e       	mov	r0, r31
    7b0e:	fd e0       	ldi	r31, 0x0D	; 13
    7b10:	ff 2e       	mov	r15, r31
    7b12:	f0 2d       	mov	r31, r0
    7b14:	58 c0       	rjmp	.+176    	; 0x7bc6 <system_execute_line+0x482>
                case 'Y': mc_homing_cycle(HOMING_CYCLE_Y); break;
                case 'Z': mc_homing_cycle(HOMING_CYCLE_Z); break;
                default: return(STATUS_INVALID_STATEMENT);
              }
          #endif
          } else { return(STATUS_INVALID_STATEMENT); }
    7b16:	0f 2e       	mov	r0, r31
    7b18:	f3 e0       	ldi	r31, 0x03	; 3
    7b1a:	ff 2e       	mov	r15, r31
    7b1c:	f0 2d       	mov	r31, r0
    7b1e:	53 c0       	rjmp	.+166    	; 0x7bc6 <system_execute_line+0x482>
            } else if (line[3] == 0) {
              switch (line[2]) {
                case 'X': mc_homing_cycle(HOMING_CYCLE_X); break;
                case 'Y': mc_homing_cycle(HOMING_CYCLE_Y); break;
                case 'Z': mc_homing_cycle(HOMING_CYCLE_Z); break;
                default: return(STATUS_INVALID_STATEMENT);
    7b20:	0f 2e       	mov	r0, r31
    7b22:	f3 e0       	ldi	r31, 0x03	; 3
    7b24:	ff 2e       	mov	r15, r31
    7b26:	f0 2d       	mov	r31, r0
    7b28:	4e c0       	rjmp	.+156    	; 0x7bc6 <system_execute_line+0x482>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7b2a:	fe 2c       	mov	r15, r14
    7b2c:	4c c0       	rjmp	.+152    	; 0x7bc6 <system_execute_line+0x482>
            st_go_idle(); // Set steppers to the settings idle state before returning.
            if (line[2] == 0) { system_execute_startup(line); }
          }
          break;
        case 'S' : // Puts Grbl to sleep [IDLE/ALARM]
          if ((line[2] != 'L') || (line[3] != 'P') || (line[4] != 0)) { return(STATUS_INVALID_STATEMENT); }
    7b2e:	0f 2e       	mov	r0, r31
    7b30:	f3 e0       	ldi	r31, 0x03	; 3
    7b32:	ff 2e       	mov	r15, r31
    7b34:	f0 2d       	mov	r31, r0
    7b36:	47 c0       	rjmp	.+142    	; 0x7bc6 <system_execute_line+0x482>
    7b38:	0f 2e       	mov	r0, r31
    7b3a:	f3 e0       	ldi	r31, 0x03	; 3
    7b3c:	ff 2e       	mov	r15, r31
    7b3e:	f0 2d       	mov	r31, r0
    7b40:	42 c0       	rjmp	.+132    	; 0x7bc6 <system_execute_line+0x482>
    7b42:	0f 2e       	mov	r0, r31
    7b44:	f3 e0       	ldi	r31, 0x03	; 3
    7b46:	ff 2e       	mov	r15, r31
    7b48:	f0 2d       	mov	r31, r0
    7b4a:	3d c0       	rjmp	.+122    	; 0x7bc6 <system_execute_line+0x482>
          if ( line[++char_counter] == 0 ) {
            settings_read_build_info(line);
            report_build_info(line);
          #ifdef ENABLE_BUILD_INFO_WRITE_COMMAND
            } else { // Store startup line [IDLE/ALARM]
              if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    7b4c:	0f 2e       	mov	r0, r31
    7b4e:	f3 e0       	ldi	r31, 0x03	; 3
    7b50:	ff 2e       	mov	r15, r31
    7b52:	f0 2d       	mov	r31, r0
    7b54:	38 c0       	rjmp	.+112    	; 0x7bc6 <system_execute_line+0x482>
              settings_store_build_info(line);
          #endif
          }
          break;
        case 'R' : // Restore defaults [IDLE/ALARM]
          if ((line[2] != 'S') || (line[3] != 'T') || (line[4] != '=') || (line[6] != 0)) { return(STATUS_INVALID_STATEMENT); }
    7b56:	0f 2e       	mov	r0, r31
    7b58:	f3 e0       	ldi	r31, 0x03	; 3
    7b5a:	ff 2e       	mov	r15, r31
    7b5c:	f0 2d       	mov	r31, r0
    7b5e:	33 c0       	rjmp	.+102    	; 0x7bc6 <system_execute_line+0x482>
    7b60:	0f 2e       	mov	r0, r31
    7b62:	f3 e0       	ldi	r31, 0x03	; 3
    7b64:	ff 2e       	mov	r15, r31
    7b66:	f0 2d       	mov	r31, r0
    7b68:	2e c0       	rjmp	.+92     	; 0x7bc6 <system_execute_line+0x482>
    7b6a:	0f 2e       	mov	r0, r31
    7b6c:	f3 e0       	ldi	r31, 0x03	; 3
    7b6e:	ff 2e       	mov	r15, r31
    7b70:	f0 2d       	mov	r31, r0
    7b72:	29 c0       	rjmp	.+82     	; 0x7bc6 <system_execute_line+0x482>
    7b74:	0f 2e       	mov	r0, r31
    7b76:	f3 e0       	ldi	r31, 0x03	; 3
    7b78:	ff 2e       	mov	r15, r31
    7b7a:	f0 2d       	mov	r31, r0
    7b7c:	24 c0       	rjmp	.+72     	; 0x7bc6 <system_execute_line+0x482>
              case '#': settings_restore(SETTINGS_RESTORE_PARAMETERS); break;
            #endif
            #ifdef ENABLE_RESTORE_EEPROM_WIPE_ALL
              case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
            #endif
            default: return(STATUS_INVALID_STATEMENT);
    7b7e:	0f 2e       	mov	r0, r31
    7b80:	f3 e0       	ldi	r31, 0x03	; 3
    7b82:	ff 2e       	mov	r15, r31
    7b84:	f0 2d       	mov	r31, r0
    7b86:	1f c0       	rjmp	.+62     	; 0x7bc6 <system_execute_line+0x482>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    7b88:	68 94       	set
    7b8a:	ff 24       	eor	r15, r15
    7b8c:	f3 f8       	bld	r15, 3
    7b8e:	1b c0       	rjmp	.+54     	; 0x7bc6 <system_execute_line+0x482>
            helper_var = true;  // Set helper_var to flag storing method.
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    7b90:	68 94       	set
    7b92:	ff 24       	eor	r15, r15
    7b94:	f1 f8       	bld	r15, 1
    7b96:	17 c0       	rjmp	.+46     	; 0x7bc6 <system_execute_line+0x482>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    7b98:	0f 2e       	mov	r0, r31
    7b9a:	f3 e0       	ldi	r31, 0x03	; 3
    7b9c:	ff 2e       	mov	r15, r31
    7b9e:	f0 2d       	mov	r31, r0
    7ba0:	12 c0       	rjmp	.+36     	; 0x7bc6 <system_execute_line+0x482>
            // Prepare sending gcode block to gcode parser by shifting all characters
            helper_var = char_counter; // Set helper variable as counter to start of gcode block
            do {
              line[char_counter-helper_var] = line[char_counter];
            } while (line[char_counter++] != 0);
            if (char_counter > EEPROM_LINE_SIZE) { return(STATUS_LINE_LENGTH_EXCEEDED); }
    7ba2:	0f 2e       	mov	r0, r31
    7ba4:	fe e0       	ldi	r31, 0x0E	; 14
    7ba6:	ff 2e       	mov	r15, r31
    7ba8:	f0 2d       	mov	r31, r0
    7baa:	0d c0       	rjmp	.+26     	; 0x7bc6 <system_execute_line+0x482>
            else {
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
              settings_store_startup_line(helper_var,line);
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    7bac:	68 94       	set
    7bae:	ff 24       	eor	r15, r15
    7bb0:	f1 f8       	bld	r15, 1
    7bb2:	09 c0       	rjmp	.+18     	; 0x7bc6 <system_execute_line+0x482>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    7bb4:	0f 2e       	mov	r0, r31
    7bb6:	f3 e0       	ldi	r31, 0x03	; 3
    7bb8:	ff 2e       	mov	r15, r31
    7bba:	f0 2d       	mov	r31, r0
    7bbc:	04 c0       	rjmp	.+8      	; 0x7bc6 <system_execute_line+0x482>
    7bbe:	0f 2e       	mov	r0, r31
    7bc0:	f3 e0       	ldi	r31, 0x03	; 3
    7bc2:	ff 2e       	mov	r15, r31
    7bc4:	f0 2d       	mov	r31, r0
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
}
    7bc6:	8f 2d       	mov	r24, r15
    7bc8:	29 96       	adiw	r28, 0x09	; 9
    7bca:	0f b6       	in	r0, 0x3f	; 63
    7bcc:	f8 94       	cli
    7bce:	de bf       	out	0x3e, r29	; 62
    7bd0:	0f be       	out	0x3f, r0	; 63
    7bd2:	cd bf       	out	0x3d, r28	; 61
    7bd4:	df 91       	pop	r29
    7bd6:	cf 91       	pop	r28
    7bd8:	1f 91       	pop	r17
    7bda:	0f 91       	pop	r16
    7bdc:	ff 90       	pop	r15
    7bde:	ef 90       	pop	r14
    7be0:	df 90       	pop	r13
    7be2:	cf 90       	pop	r12
    7be4:	bf 90       	pop	r11
    7be6:	af 90       	pop	r10
    7be8:	9f 90       	pop	r9
    7bea:	8f 90       	pop	r8
    7bec:	08 95       	ret

00007bee <system_clear_exec_state_flag>:
  sys_rt_exec_state |= (mask);
  SREG = sreg;
}

void system_clear_exec_state_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    7bee:	2f b7       	in	r18, 0x3f	; 63
  cli();
    7bf0:	f8 94       	cli
  sys_rt_exec_state &= ~(mask);
    7bf2:	90 91 31 0c 	lds	r25, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    7bf6:	80 95       	com	r24
    7bf8:	89 23       	and	r24, r25
    7bfa:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <sys_rt_exec_state>
  SREG = sreg;
    7bfe:	2f bf       	out	0x3f, r18	; 63
    7c00:	08 95       	ret

00007c02 <system_set_exec_alarm>:
}

void system_set_exec_alarm(uint8_t code) {
  uint8_t sreg = SREG;
    7c02:	9f b7       	in	r25, 0x3f	; 63
  cli();
    7c04:	f8 94       	cli
  sys_rt_exec_alarm = code;
    7c06:	80 93 53 0c 	sts	0x0C53, r24	; 0x800c53 <sys_rt_exec_alarm>
  SREG = sreg;
    7c0a:	9f bf       	out	0x3f, r25	; 63
    7c0c:	08 95       	ret

00007c0e <system_clear_exec_alarm>:
}

void system_clear_exec_alarm() {
  uint8_t sreg = SREG;
    7c0e:	8f b7       	in	r24, 0x3f	; 63
  cli();
    7c10:	f8 94       	cli
  sys_rt_exec_alarm = 0;
    7c12:	10 92 53 0c 	sts	0x0C53, r1	; 0x800c53 <sys_rt_exec_alarm>
  SREG = sreg;
    7c16:	8f bf       	out	0x3f, r24	; 63
    7c18:	08 95       	ret

00007c1a <system_set_exec_motion_override_flag>:
}

void system_set_exec_motion_override_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    7c1a:	9f b7       	in	r25, 0x3f	; 63
  cli();
    7c1c:	f8 94       	cli
  sys_rt_exec_motion_override |= (mask);
    7c1e:	20 91 19 0c 	lds	r18, 0x0C19	; 0x800c19 <sys_rt_exec_motion_override>
    7c22:	82 2b       	or	r24, r18
    7c24:	80 93 19 0c 	sts	0x0C19, r24	; 0x800c19 <sys_rt_exec_motion_override>
  SREG = sreg;
    7c28:	9f bf       	out	0x3f, r25	; 63
    7c2a:	08 95       	ret

00007c2c <system_set_exec_accessory_override_flag>:
}

void system_set_exec_accessory_override_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    7c2c:	9f b7       	in	r25, 0x3f	; 63
  cli();
    7c2e:	f8 94       	cli
  sys_rt_exec_accessory_override |= (mask);
    7c30:	20 91 30 0c 	lds	r18, 0x0C30	; 0x800c30 <sys_rt_exec_accessory_override>
    7c34:	82 2b       	or	r24, r18
    7c36:	80 93 30 0c 	sts	0x0C30, r24	; 0x800c30 <sys_rt_exec_accessory_override>
  SREG = sreg;
    7c3a:	9f bf       	out	0x3f, r25	; 63
    7c3c:	08 95       	ret

00007c3e <system_clear_exec_motion_overrides>:
}

void system_clear_exec_motion_overrides() {
  uint8_t sreg = SREG;
    7c3e:	8f b7       	in	r24, 0x3f	; 63
  cli();
    7c40:	f8 94       	cli
  sys_rt_exec_motion_override = 0;
    7c42:	10 92 19 0c 	sts	0x0C19, r1	; 0x800c19 <sys_rt_exec_motion_override>
  SREG = sreg;
    7c46:	8f bf       	out	0x3f, r24	; 63
    7c48:	08 95       	ret

00007c4a <system_clear_exec_accessory_overrides>:
}

void system_clear_exec_accessory_overrides() {
  uint8_t sreg = SREG;
    7c4a:	8f b7       	in	r24, 0x3f	; 63
  cli();
    7c4c:	f8 94       	cli
  sys_rt_exec_accessory_override = 0;
    7c4e:	10 92 30 0c 	sts	0x0C30, r1	; 0x800c30 <sys_rt_exec_accessory_override>
  SREG = sreg;
    7c52:	8f bf       	out	0x3f, r24	; 63
    7c54:	08 95       	ret

00007c56 <sleep_init>:
// Initialization routine for sleep timer.
void sleep_init()
{
  // Configure Timer 3: Sleep Counter Overflow Interrupt
  // NOTE: By using an overflow interrupt, the timer is automatically reloaded upon overflow.
  TCCR3B = 0; // Normal operation. Overflow.
    7c56:	e1 e9       	ldi	r30, 0x91	; 145
    7c58:	f0 e0       	ldi	r31, 0x00	; 0
    7c5a:	10 82       	st	Z, r1
  TCCR3A = 0;
    7c5c:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
  TCCR3B = (TCCR3B & ~((1<<CS32) | (1<<CS31))) | (1<<CS30); // Stop timer
    7c60:	80 81       	ld	r24, Z
    7c62:	88 7f       	andi	r24, 0xF8	; 248
    7c64:	81 60       	ori	r24, 0x01	; 1
    7c66:	80 83       	st	Z, r24
  // TCCR3B |= (1<<CS32); // Enable timer with 1/256 prescaler. ~4.4min max with uint8 and 1.05sec/tick
  // TCCR3B |= (1<<CS31); // Enable timer with 1/8 prescaler. ~8.3sec max with uint8 and 32.7msec/tick
  TCCR3B |= (1<<CS31)|(1<<CS30); // Enable timer with 1/64 prescaler. ~66.8sec max with uint8 and 0.262sec/tick
    7c68:	80 81       	ld	r24, Z
    7c6a:	83 60       	ori	r24, 0x03	; 3
    7c6c:	80 83       	st	Z, r24
  TIMSK3 |= (1<<TOIE3); // Enable timer3 overflow interrupt
} 


// Disable sleep timer.
static void sleep_disable() {  TIMSK3 &= ~(1<<TOIE3); } // Disable timer overflow interrupt
    7c6e:	e1 e7       	ldi	r30, 0x71	; 113
    7c70:	f0 e0       	ldi	r31, 0x00	; 0
    7c72:	80 81       	ld	r24, Z
    7c74:	8e 7f       	andi	r24, 0xFE	; 254
    7c76:	80 83       	st	Z, r24
    7c78:	08 95       	ret

00007c7a <__vector_35>:
  sleep_disable();
}


// Increment sleep counter with each timer overflow.
ISR(TIMER3_OVF_vect) { sleep_counter++; }
    7c7a:	1f 92       	push	r1
    7c7c:	0f 92       	push	r0
    7c7e:	0f b6       	in	r0, 0x3f	; 63
    7c80:	0f 92       	push	r0
    7c82:	11 24       	eor	r1, r1
    7c84:	8f 93       	push	r24
    7c86:	80 91 26 0f 	lds	r24, 0x0F26	; 0x800f26 <sleep_counter>
    7c8a:	8f 5f       	subi	r24, 0xFF	; 255
    7c8c:	80 93 26 0f 	sts	0x0F26, r24	; 0x800f26 <sleep_counter>
    7c90:	8f 91       	pop	r24
    7c92:	0f 90       	pop	r0
    7c94:	0f be       	out	0x3f, r0	; 63
    7c96:	0f 90       	pop	r0
    7c98:	1f 90       	pop	r1
    7c9a:	18 95       	reti

00007c9c <jog_execute>:
#include "grbl.h"


// Sets up valid jog motion received from g-code parser, checks for soft-limits, and executes the jog.
uint8_t jog_execute(plan_line_data_t *pl_data, parser_block_t *gc_block)
{
    7c9c:	0f 93       	push	r16
    7c9e:	1f 93       	push	r17
    7ca0:	cf 93       	push	r28
    7ca2:	df 93       	push	r29
    7ca4:	ec 01       	movw	r28, r24
    7ca6:	8b 01       	movw	r16, r22
  // Initialize planner data struct for jogging motions.
  // NOTE: Spindle and coolant are allowed to fully function with overrides during a jog.
  pl_data->feed_rate = gc_block->values.f;
    7ca8:	fb 01       	movw	r30, r22
    7caa:	84 85       	ldd	r24, Z+12	; 0x0c
    7cac:	95 85       	ldd	r25, Z+13	; 0x0d
    7cae:	a6 85       	ldd	r26, Z+14	; 0x0e
    7cb0:	b7 85       	ldd	r27, Z+15	; 0x0f
    7cb2:	88 83       	st	Y, r24
    7cb4:	99 83       	std	Y+1, r25	; 0x01
    7cb6:	aa 83       	std	Y+2, r26	; 0x02
    7cb8:	bb 83       	std	Y+3, r27	; 0x03
  pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
    7cba:	8c 85       	ldd	r24, Y+12	; 0x0c
    7cbc:	84 60       	ori	r24, 0x04	; 4
    7cbe:	8c 87       	std	Y+12, r24	; 0x0c
  pl_data->line_number = gc_block->values.n;
    7cc0:	85 8d       	ldd	r24, Z+29	; 0x1d
    7cc2:	96 8d       	ldd	r25, Z+30	; 0x1e
    7cc4:	a7 8d       	ldd	r26, Z+31	; 0x1f
    7cc6:	b0 a1       	ldd	r27, Z+32	; 0x20
    7cc8:	88 87       	std	Y+8, r24	; 0x08
    7cca:	99 87       	std	Y+9, r25	; 0x09
    7ccc:	aa 87       	std	Y+10, r26	; 0x0a
    7cce:	bb 87       	std	Y+11, r27	; 0x0b

  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
    7cd0:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    7cd4:	85 ff       	sbrs	r24, 5
    7cd6:	05 c0       	rjmp	.+10     	; 0x7ce2 <jog_execute+0x46>
    if (system_check_travel_limits(gc_block->values.xyz)) { return(STATUS_TRAVEL_EXCEEDED); }
    7cd8:	cb 01       	movw	r24, r22
    7cda:	8e 96       	adiw	r24, 0x2e	; 46
    7cdc:	c5 dc       	rcall	.-1654   	; 0x7668 <system_check_travel_limits>
    7cde:	81 11       	cpse	r24, r1
    7ce0:	15 c0       	rjmp	.+42     	; 0x7d0c <jog_execute+0x70>
  }

  // Valid jog command. Plan, set state, and execute.
  mc_line(gc_block->values.xyz,pl_data);
    7ce2:	be 01       	movw	r22, r28
    7ce4:	c8 01       	movw	r24, r16
    7ce6:	8e 96       	adiw	r24, 0x2e	; 46
    7ce8:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <mc_line>
  if (sys.state == STATE_IDLE) {
    7cec:	c0 91 1e 0c 	lds	r28, 0x0C1E	; 0x800c1e <sys>
    7cf0:	c1 11       	cpse	r28, r1
    7cf2:	0e c0       	rjmp	.+28     	; 0x7d10 <jog_execute+0x74>
    if (plan_get_current_block() != NULL) { // Check if there is a block to execute.
    7cf4:	0e 94 85 29 	call	0x530a	; 0x530a <plan_get_current_block>
    7cf8:	89 2b       	or	r24, r25
    7cfa:	59 f0       	breq	.+22     	; 0x7d12 <jog_execute+0x76>
      sys.state = STATE_JOG;
    7cfc:	80 e2       	ldi	r24, 0x20	; 32
    7cfe:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
      st_prep_buffer();
    7d02:	0e 94 4c 1c 	call	0x3898	; 0x3898 <st_prep_buffer>
      st_wake_up();  // NOTE: Manual start. No state machine required.
    7d06:	0e 94 3f 19 	call	0x327e	; 0x327e <st_wake_up>
    7d0a:	03 c0       	rjmp	.+6      	; 0x7d12 <jog_execute+0x76>
  pl_data->feed_rate = gc_block->values.f;
  pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
  pl_data->line_number = gc_block->values.n;

  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
    if (system_check_travel_limits(gc_block->values.xyz)) { return(STATUS_TRAVEL_EXCEEDED); }
    7d0c:	cf e0       	ldi	r28, 0x0F	; 15
    7d0e:	01 c0       	rjmp	.+2      	; 0x7d12 <jog_execute+0x76>
      st_prep_buffer();
      st_wake_up();  // NOTE: Manual start. No state machine required.
    }
  }

  return(STATUS_OK);
    7d10:	c0 e0       	ldi	r28, 0x00	; 0
}
    7d12:	8c 2f       	mov	r24, r28
    7d14:	df 91       	pop	r29
    7d16:	cf 91       	pop	r28
    7d18:	1f 91       	pop	r17
    7d1a:	0f 91       	pop	r16
    7d1c:	08 95       	ret

00007d1e <__subsf3>:
    7d1e:	50 58       	subi	r21, 0x80	; 128

00007d20 <__addsf3>:
    7d20:	bb 27       	eor	r27, r27
    7d22:	aa 27       	eor	r26, r26
    7d24:	0e d0       	rcall	.+28     	; 0x7d42 <__addsf3x>
    7d26:	76 c2       	rjmp	.+1260   	; 0x8214 <__fp_round>
    7d28:	3f d2       	rcall	.+1150   	; 0x81a8 <__fp_pscA>
    7d2a:	30 f0       	brcs	.+12     	; 0x7d38 <__addsf3+0x18>
    7d2c:	44 d2       	rcall	.+1160   	; 0x81b6 <__fp_pscB>
    7d2e:	20 f0       	brcs	.+8      	; 0x7d38 <__addsf3+0x18>
    7d30:	31 f4       	brne	.+12     	; 0x7d3e <__addsf3+0x1e>
    7d32:	9f 3f       	cpi	r25, 0xFF	; 255
    7d34:	11 f4       	brne	.+4      	; 0x7d3a <__addsf3+0x1a>
    7d36:	1e f4       	brtc	.+6      	; 0x7d3e <__addsf3+0x1e>
    7d38:	0f c2       	rjmp	.+1054   	; 0x8158 <__fp_nan>
    7d3a:	0e f4       	brtc	.+2      	; 0x7d3e <__addsf3+0x1e>
    7d3c:	e0 95       	com	r30
    7d3e:	e7 fb       	bst	r30, 7
    7d40:	dc c1       	rjmp	.+952    	; 0x80fa <__fp_inf>

00007d42 <__addsf3x>:
    7d42:	e9 2f       	mov	r30, r25
    7d44:	89 d2       	rcall	.+1298   	; 0x8258 <__fp_split3>
    7d46:	80 f3       	brcs	.-32     	; 0x7d28 <__addsf3+0x8>
    7d48:	ba 17       	cp	r27, r26
    7d4a:	62 07       	cpc	r22, r18
    7d4c:	73 07       	cpc	r23, r19
    7d4e:	84 07       	cpc	r24, r20
    7d50:	95 07       	cpc	r25, r21
    7d52:	18 f0       	brcs	.+6      	; 0x7d5a <__addsf3x+0x18>
    7d54:	71 f4       	brne	.+28     	; 0x7d72 <__addsf3x+0x30>
    7d56:	9e f5       	brtc	.+102    	; 0x7dbe <__addsf3x+0x7c>
    7d58:	b8 c2       	rjmp	.+1392   	; 0x82ca <__fp_zero>
    7d5a:	0e f4       	brtc	.+2      	; 0x7d5e <__addsf3x+0x1c>
    7d5c:	e0 95       	com	r30
    7d5e:	0b 2e       	mov	r0, r27
    7d60:	ba 2f       	mov	r27, r26
    7d62:	a0 2d       	mov	r26, r0
    7d64:	0b 01       	movw	r0, r22
    7d66:	b9 01       	movw	r22, r18
    7d68:	90 01       	movw	r18, r0
    7d6a:	0c 01       	movw	r0, r24
    7d6c:	ca 01       	movw	r24, r20
    7d6e:	a0 01       	movw	r20, r0
    7d70:	11 24       	eor	r1, r1
    7d72:	ff 27       	eor	r31, r31
    7d74:	59 1b       	sub	r21, r25
    7d76:	99 f0       	breq	.+38     	; 0x7d9e <__addsf3x+0x5c>
    7d78:	59 3f       	cpi	r21, 0xF9	; 249
    7d7a:	50 f4       	brcc	.+20     	; 0x7d90 <__addsf3x+0x4e>
    7d7c:	50 3e       	cpi	r21, 0xE0	; 224
    7d7e:	68 f1       	brcs	.+90     	; 0x7dda <__addsf3x+0x98>
    7d80:	1a 16       	cp	r1, r26
    7d82:	f0 40       	sbci	r31, 0x00	; 0
    7d84:	a2 2f       	mov	r26, r18
    7d86:	23 2f       	mov	r18, r19
    7d88:	34 2f       	mov	r19, r20
    7d8a:	44 27       	eor	r20, r20
    7d8c:	58 5f       	subi	r21, 0xF8	; 248
    7d8e:	f3 cf       	rjmp	.-26     	; 0x7d76 <__addsf3x+0x34>
    7d90:	46 95       	lsr	r20
    7d92:	37 95       	ror	r19
    7d94:	27 95       	ror	r18
    7d96:	a7 95       	ror	r26
    7d98:	f0 40       	sbci	r31, 0x00	; 0
    7d9a:	53 95       	inc	r21
    7d9c:	c9 f7       	brne	.-14     	; 0x7d90 <__addsf3x+0x4e>
    7d9e:	7e f4       	brtc	.+30     	; 0x7dbe <__addsf3x+0x7c>
    7da0:	1f 16       	cp	r1, r31
    7da2:	ba 0b       	sbc	r27, r26
    7da4:	62 0b       	sbc	r22, r18
    7da6:	73 0b       	sbc	r23, r19
    7da8:	84 0b       	sbc	r24, r20
    7daa:	ba f0       	brmi	.+46     	; 0x7dda <__addsf3x+0x98>
    7dac:	91 50       	subi	r25, 0x01	; 1
    7dae:	a1 f0       	breq	.+40     	; 0x7dd8 <__addsf3x+0x96>
    7db0:	ff 0f       	add	r31, r31
    7db2:	bb 1f       	adc	r27, r27
    7db4:	66 1f       	adc	r22, r22
    7db6:	77 1f       	adc	r23, r23
    7db8:	88 1f       	adc	r24, r24
    7dba:	c2 f7       	brpl	.-16     	; 0x7dac <__addsf3x+0x6a>
    7dbc:	0e c0       	rjmp	.+28     	; 0x7dda <__addsf3x+0x98>
    7dbe:	ba 0f       	add	r27, r26
    7dc0:	62 1f       	adc	r22, r18
    7dc2:	73 1f       	adc	r23, r19
    7dc4:	84 1f       	adc	r24, r20
    7dc6:	48 f4       	brcc	.+18     	; 0x7dda <__addsf3x+0x98>
    7dc8:	87 95       	ror	r24
    7dca:	77 95       	ror	r23
    7dcc:	67 95       	ror	r22
    7dce:	b7 95       	ror	r27
    7dd0:	f7 95       	ror	r31
    7dd2:	9e 3f       	cpi	r25, 0xFE	; 254
    7dd4:	08 f0       	brcs	.+2      	; 0x7dd8 <__addsf3x+0x96>
    7dd6:	b3 cf       	rjmp	.-154    	; 0x7d3e <__addsf3+0x1e>
    7dd8:	93 95       	inc	r25
    7dda:	88 0f       	add	r24, r24
    7ddc:	08 f0       	brcs	.+2      	; 0x7de0 <__addsf3x+0x9e>
    7dde:	99 27       	eor	r25, r25
    7de0:	ee 0f       	add	r30, r30
    7de2:	97 95       	ror	r25
    7de4:	87 95       	ror	r24
    7de6:	08 95       	ret
    7de8:	df d1       	rcall	.+958    	; 0x81a8 <__fp_pscA>
    7dea:	58 f0       	brcs	.+22     	; 0x7e02 <__addsf3x+0xc0>
    7dec:	80 e8       	ldi	r24, 0x80	; 128
    7dee:	91 e0       	ldi	r25, 0x01	; 1
    7df0:	09 f4       	brne	.+2      	; 0x7df4 <__addsf3x+0xb2>
    7df2:	9e ef       	ldi	r25, 0xFE	; 254
    7df4:	e0 d1       	rcall	.+960    	; 0x81b6 <__fp_pscB>
    7df6:	28 f0       	brcs	.+10     	; 0x7e02 <__addsf3x+0xc0>
    7df8:	40 e8       	ldi	r20, 0x80	; 128
    7dfa:	51 e0       	ldi	r21, 0x01	; 1
    7dfc:	59 f4       	brne	.+22     	; 0x7e14 <atan2+0xe>
    7dfe:	5e ef       	ldi	r21, 0xFE	; 254
    7e00:	09 c0       	rjmp	.+18     	; 0x7e14 <atan2+0xe>
    7e02:	aa c1       	rjmp	.+852    	; 0x8158 <__fp_nan>
    7e04:	62 c2       	rjmp	.+1220   	; 0x82ca <__fp_zero>

00007e06 <atan2>:
    7e06:	e9 2f       	mov	r30, r25
    7e08:	e0 78       	andi	r30, 0x80	; 128
    7e0a:	26 d2       	rcall	.+1100   	; 0x8258 <__fp_split3>
    7e0c:	68 f3       	brcs	.-38     	; 0x7de8 <__addsf3x+0xa6>
    7e0e:	09 2e       	mov	r0, r25
    7e10:	05 2a       	or	r0, r21
    7e12:	c1 f3       	breq	.-16     	; 0x7e04 <__addsf3x+0xc2>
    7e14:	26 17       	cp	r18, r22
    7e16:	37 07       	cpc	r19, r23
    7e18:	48 07       	cpc	r20, r24
    7e1a:	59 07       	cpc	r21, r25
    7e1c:	38 f0       	brcs	.+14     	; 0x7e2c <atan2+0x26>
    7e1e:	0e 2e       	mov	r0, r30
    7e20:	07 f8       	bld	r0, 7
    7e22:	e0 25       	eor	r30, r0
    7e24:	69 f0       	breq	.+26     	; 0x7e40 <atan2+0x3a>
    7e26:	e0 25       	eor	r30, r0
    7e28:	e0 64       	ori	r30, 0x40	; 64
    7e2a:	0a c0       	rjmp	.+20     	; 0x7e40 <atan2+0x3a>
    7e2c:	ef 63       	ori	r30, 0x3F	; 63
    7e2e:	07 f8       	bld	r0, 7
    7e30:	00 94       	com	r0
    7e32:	07 fa       	bst	r0, 7
    7e34:	db 01       	movw	r26, r22
    7e36:	b9 01       	movw	r22, r18
    7e38:	9d 01       	movw	r18, r26
    7e3a:	dc 01       	movw	r26, r24
    7e3c:	ca 01       	movw	r24, r20
    7e3e:	ad 01       	movw	r20, r26
    7e40:	ef 93       	push	r30
    7e42:	5d d0       	rcall	.+186    	; 0x7efe <__divsf3_pse>
    7e44:	e7 d1       	rcall	.+974    	; 0x8214 <__fp_round>
    7e46:	0a d0       	rcall	.+20     	; 0x7e5c <atan>
    7e48:	5f 91       	pop	r21
    7e4a:	55 23       	and	r21, r21
    7e4c:	31 f0       	breq	.+12     	; 0x7e5a <atan2+0x54>
    7e4e:	2b ed       	ldi	r18, 0xDB	; 219
    7e50:	3f e0       	ldi	r19, 0x0F	; 15
    7e52:	49 e4       	ldi	r20, 0x49	; 73
    7e54:	50 fd       	sbrc	r21, 0
    7e56:	49 ec       	ldi	r20, 0xC9	; 201
    7e58:	63 cf       	rjmp	.-314    	; 0x7d20 <__addsf3>
    7e5a:	08 95       	ret

00007e5c <atan>:
    7e5c:	df 93       	push	r29
    7e5e:	dd 27       	eor	r29, r29
    7e60:	b9 2f       	mov	r27, r25
    7e62:	bf 77       	andi	r27, 0x7F	; 127
    7e64:	40 e8       	ldi	r20, 0x80	; 128
    7e66:	5f e3       	ldi	r21, 0x3F	; 63
    7e68:	16 16       	cp	r1, r22
    7e6a:	17 06       	cpc	r1, r23
    7e6c:	48 07       	cpc	r20, r24
    7e6e:	5b 07       	cpc	r21, r27
    7e70:	10 f4       	brcc	.+4      	; 0x7e76 <atan+0x1a>
    7e72:	d9 2f       	mov	r29, r25
    7e74:	35 d2       	rcall	.+1130   	; 0x82e0 <inverse>
    7e76:	9f 93       	push	r25
    7e78:	8f 93       	push	r24
    7e7a:	7f 93       	push	r23
    7e7c:	6f 93       	push	r22
    7e7e:	32 d3       	rcall	.+1636   	; 0x84e4 <square>
    7e80:	ee e9       	ldi	r30, 0x9E	; 158
    7e82:	f2 e0       	ldi	r31, 0x02	; 2
    7e84:	6c d1       	rcall	.+728    	; 0x815e <__fp_powser>
    7e86:	c6 d1       	rcall	.+908    	; 0x8214 <__fp_round>
    7e88:	2f 91       	pop	r18
    7e8a:	3f 91       	pop	r19
    7e8c:	4f 91       	pop	r20
    7e8e:	5f 91       	pop	r21
    7e90:	6a d2       	rcall	.+1236   	; 0x8366 <__mulsf3x>
    7e92:	dd 23       	and	r29, r29
    7e94:	49 f0       	breq	.+18     	; 0x7ea8 <atan+0x4c>
    7e96:	90 58       	subi	r25, 0x80	; 128
    7e98:	a2 ea       	ldi	r26, 0xA2	; 162
    7e9a:	2a ed       	ldi	r18, 0xDA	; 218
    7e9c:	3f e0       	ldi	r19, 0x0F	; 15
    7e9e:	49 ec       	ldi	r20, 0xC9	; 201
    7ea0:	5f e3       	ldi	r21, 0x3F	; 63
    7ea2:	d0 78       	andi	r29, 0x80	; 128
    7ea4:	5d 27       	eor	r21, r29
    7ea6:	4d df       	rcall	.-358    	; 0x7d42 <__addsf3x>
    7ea8:	df 91       	pop	r29
    7eaa:	b4 c1       	rjmp	.+872    	; 0x8214 <__fp_round>

00007eac <ceil>:
    7eac:	f7 d1       	rcall	.+1006   	; 0x829c <__fp_trunc>
    7eae:	80 f0       	brcs	.+32     	; 0x7ed0 <ceil+0x24>
    7eb0:	9f 37       	cpi	r25, 0x7F	; 127
    7eb2:	40 f4       	brcc	.+16     	; 0x7ec4 <ceil+0x18>
    7eb4:	91 11       	cpse	r25, r1
    7eb6:	0e f4       	brtc	.+2      	; 0x7eba <ceil+0xe>
    7eb8:	09 c2       	rjmp	.+1042   	; 0x82cc <__fp_szero>
    7eba:	60 e0       	ldi	r22, 0x00	; 0
    7ebc:	70 e0       	ldi	r23, 0x00	; 0
    7ebe:	80 e8       	ldi	r24, 0x80	; 128
    7ec0:	9f e3       	ldi	r25, 0x3F	; 63
    7ec2:	08 95       	ret
    7ec4:	26 f0       	brts	.+8      	; 0x7ece <ceil+0x22>
    7ec6:	1b 16       	cp	r1, r27
    7ec8:	61 1d       	adc	r22, r1
    7eca:	71 1d       	adc	r23, r1
    7ecc:	81 1d       	adc	r24, r1
    7ece:	1b c1       	rjmp	.+566    	; 0x8106 <__fp_mintl>
    7ed0:	35 c1       	rjmp	.+618    	; 0x813c <__fp_mpack>

00007ed2 <__cmpsf2>:
    7ed2:	ef d0       	rcall	.+478    	; 0x80b2 <__fp_cmp>
    7ed4:	08 f4       	brcc	.+2      	; 0x7ed8 <__cmpsf2+0x6>
    7ed6:	81 e0       	ldi	r24, 0x01	; 1
    7ed8:	08 95       	ret

00007eda <cos>:
    7eda:	75 d1       	rcall	.+746    	; 0x81c6 <__fp_rempio2>
    7edc:	e3 95       	inc	r30
    7ede:	ab c1       	rjmp	.+854    	; 0x8236 <__fp_sinus>

00007ee0 <__divsf3>:
    7ee0:	0c d0       	rcall	.+24     	; 0x7efa <__divsf3x>
    7ee2:	98 c1       	rjmp	.+816    	; 0x8214 <__fp_round>
    7ee4:	68 d1       	rcall	.+720    	; 0x81b6 <__fp_pscB>
    7ee6:	40 f0       	brcs	.+16     	; 0x7ef8 <__divsf3+0x18>
    7ee8:	5f d1       	rcall	.+702    	; 0x81a8 <__fp_pscA>
    7eea:	30 f0       	brcs	.+12     	; 0x7ef8 <__divsf3+0x18>
    7eec:	21 f4       	brne	.+8      	; 0x7ef6 <__divsf3+0x16>
    7eee:	5f 3f       	cpi	r21, 0xFF	; 255
    7ef0:	19 f0       	breq	.+6      	; 0x7ef8 <__divsf3+0x18>
    7ef2:	03 c1       	rjmp	.+518    	; 0x80fa <__fp_inf>
    7ef4:	51 11       	cpse	r21, r1
    7ef6:	ea c1       	rjmp	.+980    	; 0x82cc <__fp_szero>
    7ef8:	2f c1       	rjmp	.+606    	; 0x8158 <__fp_nan>

00007efa <__divsf3x>:
    7efa:	ae d1       	rcall	.+860    	; 0x8258 <__fp_split3>
    7efc:	98 f3       	brcs	.-26     	; 0x7ee4 <__divsf3+0x4>

00007efe <__divsf3_pse>:
    7efe:	99 23       	and	r25, r25
    7f00:	c9 f3       	breq	.-14     	; 0x7ef4 <__divsf3+0x14>
    7f02:	55 23       	and	r21, r21
    7f04:	b1 f3       	breq	.-20     	; 0x7ef2 <__divsf3+0x12>
    7f06:	95 1b       	sub	r25, r21
    7f08:	55 0b       	sbc	r21, r21
    7f0a:	bb 27       	eor	r27, r27
    7f0c:	aa 27       	eor	r26, r26
    7f0e:	62 17       	cp	r22, r18
    7f10:	73 07       	cpc	r23, r19
    7f12:	84 07       	cpc	r24, r20
    7f14:	38 f0       	brcs	.+14     	; 0x7f24 <__divsf3_pse+0x26>
    7f16:	9f 5f       	subi	r25, 0xFF	; 255
    7f18:	5f 4f       	sbci	r21, 0xFF	; 255
    7f1a:	22 0f       	add	r18, r18
    7f1c:	33 1f       	adc	r19, r19
    7f1e:	44 1f       	adc	r20, r20
    7f20:	aa 1f       	adc	r26, r26
    7f22:	a9 f3       	breq	.-22     	; 0x7f0e <__divsf3_pse+0x10>
    7f24:	33 d0       	rcall	.+102    	; 0x7f8c <__divsf3_pse+0x8e>
    7f26:	0e 2e       	mov	r0, r30
    7f28:	3a f0       	brmi	.+14     	; 0x7f38 <__divsf3_pse+0x3a>
    7f2a:	e0 e8       	ldi	r30, 0x80	; 128
    7f2c:	30 d0       	rcall	.+96     	; 0x7f8e <__divsf3_pse+0x90>
    7f2e:	91 50       	subi	r25, 0x01	; 1
    7f30:	50 40       	sbci	r21, 0x00	; 0
    7f32:	e6 95       	lsr	r30
    7f34:	00 1c       	adc	r0, r0
    7f36:	ca f7       	brpl	.-14     	; 0x7f2a <__divsf3_pse+0x2c>
    7f38:	29 d0       	rcall	.+82     	; 0x7f8c <__divsf3_pse+0x8e>
    7f3a:	fe 2f       	mov	r31, r30
    7f3c:	27 d0       	rcall	.+78     	; 0x7f8c <__divsf3_pse+0x8e>
    7f3e:	66 0f       	add	r22, r22
    7f40:	77 1f       	adc	r23, r23
    7f42:	88 1f       	adc	r24, r24
    7f44:	bb 1f       	adc	r27, r27
    7f46:	26 17       	cp	r18, r22
    7f48:	37 07       	cpc	r19, r23
    7f4a:	48 07       	cpc	r20, r24
    7f4c:	ab 07       	cpc	r26, r27
    7f4e:	b0 e8       	ldi	r27, 0x80	; 128
    7f50:	09 f0       	breq	.+2      	; 0x7f54 <__divsf3_pse+0x56>
    7f52:	bb 0b       	sbc	r27, r27
    7f54:	80 2d       	mov	r24, r0
    7f56:	bf 01       	movw	r22, r30
    7f58:	ff 27       	eor	r31, r31
    7f5a:	93 58       	subi	r25, 0x83	; 131
    7f5c:	5f 4f       	sbci	r21, 0xFF	; 255
    7f5e:	2a f0       	brmi	.+10     	; 0x7f6a <__divsf3_pse+0x6c>
    7f60:	9e 3f       	cpi	r25, 0xFE	; 254
    7f62:	51 05       	cpc	r21, r1
    7f64:	68 f0       	brcs	.+26     	; 0x7f80 <__divsf3_pse+0x82>
    7f66:	c9 c0       	rjmp	.+402    	; 0x80fa <__fp_inf>
    7f68:	b1 c1       	rjmp	.+866    	; 0x82cc <__fp_szero>
    7f6a:	5f 3f       	cpi	r21, 0xFF	; 255
    7f6c:	ec f3       	brlt	.-6      	; 0x7f68 <__divsf3_pse+0x6a>
    7f6e:	98 3e       	cpi	r25, 0xE8	; 232
    7f70:	dc f3       	brlt	.-10     	; 0x7f68 <__divsf3_pse+0x6a>
    7f72:	86 95       	lsr	r24
    7f74:	77 95       	ror	r23
    7f76:	67 95       	ror	r22
    7f78:	b7 95       	ror	r27
    7f7a:	f7 95       	ror	r31
    7f7c:	9f 5f       	subi	r25, 0xFF	; 255
    7f7e:	c9 f7       	brne	.-14     	; 0x7f72 <__divsf3_pse+0x74>
    7f80:	88 0f       	add	r24, r24
    7f82:	91 1d       	adc	r25, r1
    7f84:	96 95       	lsr	r25
    7f86:	87 95       	ror	r24
    7f88:	97 f9       	bld	r25, 7
    7f8a:	08 95       	ret
    7f8c:	e1 e0       	ldi	r30, 0x01	; 1
    7f8e:	66 0f       	add	r22, r22
    7f90:	77 1f       	adc	r23, r23
    7f92:	88 1f       	adc	r24, r24
    7f94:	bb 1f       	adc	r27, r27
    7f96:	62 17       	cp	r22, r18
    7f98:	73 07       	cpc	r23, r19
    7f9a:	84 07       	cpc	r24, r20
    7f9c:	ba 07       	cpc	r27, r26
    7f9e:	20 f0       	brcs	.+8      	; 0x7fa8 <__divsf3_pse+0xaa>
    7fa0:	62 1b       	sub	r22, r18
    7fa2:	73 0b       	sbc	r23, r19
    7fa4:	84 0b       	sbc	r24, r20
    7fa6:	ba 0b       	sbc	r27, r26
    7fa8:	ee 1f       	adc	r30, r30
    7faa:	88 f7       	brcc	.-30     	; 0x7f8e <__divsf3_pse+0x90>
    7fac:	e0 95       	com	r30
    7fae:	08 95       	ret

00007fb0 <__fixsfsi>:
    7fb0:	04 d0       	rcall	.+8      	; 0x7fba <__fixunssfsi>
    7fb2:	68 94       	set
    7fb4:	b1 11       	cpse	r27, r1
    7fb6:	8a c1       	rjmp	.+788    	; 0x82cc <__fp_szero>
    7fb8:	08 95       	ret

00007fba <__fixunssfsi>:
    7fba:	56 d1       	rcall	.+684    	; 0x8268 <__fp_splitA>
    7fbc:	88 f0       	brcs	.+34     	; 0x7fe0 <__fixunssfsi+0x26>
    7fbe:	9f 57       	subi	r25, 0x7F	; 127
    7fc0:	90 f0       	brcs	.+36     	; 0x7fe6 <__fixunssfsi+0x2c>
    7fc2:	b9 2f       	mov	r27, r25
    7fc4:	99 27       	eor	r25, r25
    7fc6:	b7 51       	subi	r27, 0x17	; 23
    7fc8:	a0 f0       	brcs	.+40     	; 0x7ff2 <__fixunssfsi+0x38>
    7fca:	d1 f0       	breq	.+52     	; 0x8000 <__fixunssfsi+0x46>
    7fcc:	66 0f       	add	r22, r22
    7fce:	77 1f       	adc	r23, r23
    7fd0:	88 1f       	adc	r24, r24
    7fd2:	99 1f       	adc	r25, r25
    7fd4:	1a f0       	brmi	.+6      	; 0x7fdc <__fixunssfsi+0x22>
    7fd6:	ba 95       	dec	r27
    7fd8:	c9 f7       	brne	.-14     	; 0x7fcc <__fixunssfsi+0x12>
    7fda:	12 c0       	rjmp	.+36     	; 0x8000 <__fixunssfsi+0x46>
    7fdc:	b1 30       	cpi	r27, 0x01	; 1
    7fde:	81 f0       	breq	.+32     	; 0x8000 <__fixunssfsi+0x46>
    7fe0:	74 d1       	rcall	.+744    	; 0x82ca <__fp_zero>
    7fe2:	b1 e0       	ldi	r27, 0x01	; 1
    7fe4:	08 95       	ret
    7fe6:	71 c1       	rjmp	.+738    	; 0x82ca <__fp_zero>
    7fe8:	67 2f       	mov	r22, r23
    7fea:	78 2f       	mov	r23, r24
    7fec:	88 27       	eor	r24, r24
    7fee:	b8 5f       	subi	r27, 0xF8	; 248
    7ff0:	39 f0       	breq	.+14     	; 0x8000 <__fixunssfsi+0x46>
    7ff2:	b9 3f       	cpi	r27, 0xF9	; 249
    7ff4:	cc f3       	brlt	.-14     	; 0x7fe8 <__fixunssfsi+0x2e>
    7ff6:	86 95       	lsr	r24
    7ff8:	77 95       	ror	r23
    7ffa:	67 95       	ror	r22
    7ffc:	b3 95       	inc	r27
    7ffe:	d9 f7       	brne	.-10     	; 0x7ff6 <__fixunssfsi+0x3c>
    8000:	3e f4       	brtc	.+14     	; 0x8010 <__fixunssfsi+0x56>
    8002:	90 95       	com	r25
    8004:	80 95       	com	r24
    8006:	70 95       	com	r23
    8008:	61 95       	neg	r22
    800a:	7f 4f       	sbci	r23, 0xFF	; 255
    800c:	8f 4f       	sbci	r24, 0xFF	; 255
    800e:	9f 4f       	sbci	r25, 0xFF	; 255
    8010:	08 95       	ret

00008012 <__floatunsisf>:
    8012:	e8 94       	clt
    8014:	09 c0       	rjmp	.+18     	; 0x8028 <__floatsisf+0x12>

00008016 <__floatsisf>:
    8016:	97 fb       	bst	r25, 7
    8018:	3e f4       	brtc	.+14     	; 0x8028 <__floatsisf+0x12>
    801a:	90 95       	com	r25
    801c:	80 95       	com	r24
    801e:	70 95       	com	r23
    8020:	61 95       	neg	r22
    8022:	7f 4f       	sbci	r23, 0xFF	; 255
    8024:	8f 4f       	sbci	r24, 0xFF	; 255
    8026:	9f 4f       	sbci	r25, 0xFF	; 255
    8028:	99 23       	and	r25, r25
    802a:	a9 f0       	breq	.+42     	; 0x8056 <__floatsisf+0x40>
    802c:	f9 2f       	mov	r31, r25
    802e:	96 e9       	ldi	r25, 0x96	; 150
    8030:	bb 27       	eor	r27, r27
    8032:	93 95       	inc	r25
    8034:	f6 95       	lsr	r31
    8036:	87 95       	ror	r24
    8038:	77 95       	ror	r23
    803a:	67 95       	ror	r22
    803c:	b7 95       	ror	r27
    803e:	f1 11       	cpse	r31, r1
    8040:	f8 cf       	rjmp	.-16     	; 0x8032 <__floatsisf+0x1c>
    8042:	fa f4       	brpl	.+62     	; 0x8082 <__floatsisf+0x6c>
    8044:	bb 0f       	add	r27, r27
    8046:	11 f4       	brne	.+4      	; 0x804c <__floatsisf+0x36>
    8048:	60 ff       	sbrs	r22, 0
    804a:	1b c0       	rjmp	.+54     	; 0x8082 <__floatsisf+0x6c>
    804c:	6f 5f       	subi	r22, 0xFF	; 255
    804e:	7f 4f       	sbci	r23, 0xFF	; 255
    8050:	8f 4f       	sbci	r24, 0xFF	; 255
    8052:	9f 4f       	sbci	r25, 0xFF	; 255
    8054:	16 c0       	rjmp	.+44     	; 0x8082 <__floatsisf+0x6c>
    8056:	88 23       	and	r24, r24
    8058:	11 f0       	breq	.+4      	; 0x805e <__floatsisf+0x48>
    805a:	96 e9       	ldi	r25, 0x96	; 150
    805c:	11 c0       	rjmp	.+34     	; 0x8080 <__floatsisf+0x6a>
    805e:	77 23       	and	r23, r23
    8060:	21 f0       	breq	.+8      	; 0x806a <__floatsisf+0x54>
    8062:	9e e8       	ldi	r25, 0x8E	; 142
    8064:	87 2f       	mov	r24, r23
    8066:	76 2f       	mov	r23, r22
    8068:	05 c0       	rjmp	.+10     	; 0x8074 <__floatsisf+0x5e>
    806a:	66 23       	and	r22, r22
    806c:	71 f0       	breq	.+28     	; 0x808a <__floatsisf+0x74>
    806e:	96 e8       	ldi	r25, 0x86	; 134
    8070:	86 2f       	mov	r24, r22
    8072:	70 e0       	ldi	r23, 0x00	; 0
    8074:	60 e0       	ldi	r22, 0x00	; 0
    8076:	2a f0       	brmi	.+10     	; 0x8082 <__floatsisf+0x6c>
    8078:	9a 95       	dec	r25
    807a:	66 0f       	add	r22, r22
    807c:	77 1f       	adc	r23, r23
    807e:	88 1f       	adc	r24, r24
    8080:	da f7       	brpl	.-10     	; 0x8078 <__floatsisf+0x62>
    8082:	88 0f       	add	r24, r24
    8084:	96 95       	lsr	r25
    8086:	87 95       	ror	r24
    8088:	97 f9       	bld	r25, 7
    808a:	08 95       	ret

0000808c <floor>:
    808c:	07 d1       	rcall	.+526    	; 0x829c <__fp_trunc>
    808e:	80 f0       	brcs	.+32     	; 0x80b0 <floor+0x24>
    8090:	9f 37       	cpi	r25, 0x7F	; 127
    8092:	40 f4       	brcc	.+16     	; 0x80a4 <floor+0x18>
    8094:	91 11       	cpse	r25, r1
    8096:	0e f0       	brts	.+2      	; 0x809a <floor+0xe>
    8098:	19 c1       	rjmp	.+562    	; 0x82cc <__fp_szero>
    809a:	60 e0       	ldi	r22, 0x00	; 0
    809c:	70 e0       	ldi	r23, 0x00	; 0
    809e:	80 e8       	ldi	r24, 0x80	; 128
    80a0:	9f eb       	ldi	r25, 0xBF	; 191
    80a2:	08 95       	ret
    80a4:	26 f4       	brtc	.+8      	; 0x80ae <floor+0x22>
    80a6:	1b 16       	cp	r1, r27
    80a8:	61 1d       	adc	r22, r1
    80aa:	71 1d       	adc	r23, r1
    80ac:	81 1d       	adc	r24, r1
    80ae:	2b c0       	rjmp	.+86     	; 0x8106 <__fp_mintl>
    80b0:	45 c0       	rjmp	.+138    	; 0x813c <__fp_mpack>

000080b2 <__fp_cmp>:
    80b2:	99 0f       	add	r25, r25
    80b4:	00 08       	sbc	r0, r0
    80b6:	55 0f       	add	r21, r21
    80b8:	aa 0b       	sbc	r26, r26
    80ba:	e0 e8       	ldi	r30, 0x80	; 128
    80bc:	fe ef       	ldi	r31, 0xFE	; 254
    80be:	16 16       	cp	r1, r22
    80c0:	17 06       	cpc	r1, r23
    80c2:	e8 07       	cpc	r30, r24
    80c4:	f9 07       	cpc	r31, r25
    80c6:	c0 f0       	brcs	.+48     	; 0x80f8 <__fp_cmp+0x46>
    80c8:	12 16       	cp	r1, r18
    80ca:	13 06       	cpc	r1, r19
    80cc:	e4 07       	cpc	r30, r20
    80ce:	f5 07       	cpc	r31, r21
    80d0:	98 f0       	brcs	.+38     	; 0x80f8 <__fp_cmp+0x46>
    80d2:	62 1b       	sub	r22, r18
    80d4:	73 0b       	sbc	r23, r19
    80d6:	84 0b       	sbc	r24, r20
    80d8:	95 0b       	sbc	r25, r21
    80da:	39 f4       	brne	.+14     	; 0x80ea <__fp_cmp+0x38>
    80dc:	0a 26       	eor	r0, r26
    80de:	61 f0       	breq	.+24     	; 0x80f8 <__fp_cmp+0x46>
    80e0:	23 2b       	or	r18, r19
    80e2:	24 2b       	or	r18, r20
    80e4:	25 2b       	or	r18, r21
    80e6:	21 f4       	brne	.+8      	; 0x80f0 <__fp_cmp+0x3e>
    80e8:	08 95       	ret
    80ea:	0a 26       	eor	r0, r26
    80ec:	09 f4       	brne	.+2      	; 0x80f0 <__fp_cmp+0x3e>
    80ee:	a1 40       	sbci	r26, 0x01	; 1
    80f0:	a6 95       	lsr	r26
    80f2:	8f ef       	ldi	r24, 0xFF	; 255
    80f4:	81 1d       	adc	r24, r1
    80f6:	81 1d       	adc	r24, r1
    80f8:	08 95       	ret

000080fa <__fp_inf>:
    80fa:	97 f9       	bld	r25, 7
    80fc:	9f 67       	ori	r25, 0x7F	; 127
    80fe:	80 e8       	ldi	r24, 0x80	; 128
    8100:	70 e0       	ldi	r23, 0x00	; 0
    8102:	60 e0       	ldi	r22, 0x00	; 0
    8104:	08 95       	ret

00008106 <__fp_mintl>:
    8106:	88 23       	and	r24, r24
    8108:	71 f4       	brne	.+28     	; 0x8126 <__fp_mintl+0x20>
    810a:	77 23       	and	r23, r23
    810c:	21 f0       	breq	.+8      	; 0x8116 <__fp_mintl+0x10>
    810e:	98 50       	subi	r25, 0x08	; 8
    8110:	87 2b       	or	r24, r23
    8112:	76 2f       	mov	r23, r22
    8114:	07 c0       	rjmp	.+14     	; 0x8124 <__fp_mintl+0x1e>
    8116:	66 23       	and	r22, r22
    8118:	11 f4       	brne	.+4      	; 0x811e <__fp_mintl+0x18>
    811a:	99 27       	eor	r25, r25
    811c:	0d c0       	rjmp	.+26     	; 0x8138 <__fp_mintl+0x32>
    811e:	90 51       	subi	r25, 0x10	; 16
    8120:	86 2b       	or	r24, r22
    8122:	70 e0       	ldi	r23, 0x00	; 0
    8124:	60 e0       	ldi	r22, 0x00	; 0
    8126:	2a f0       	brmi	.+10     	; 0x8132 <__fp_mintl+0x2c>
    8128:	9a 95       	dec	r25
    812a:	66 0f       	add	r22, r22
    812c:	77 1f       	adc	r23, r23
    812e:	88 1f       	adc	r24, r24
    8130:	da f7       	brpl	.-10     	; 0x8128 <__fp_mintl+0x22>
    8132:	88 0f       	add	r24, r24
    8134:	96 95       	lsr	r25
    8136:	87 95       	ror	r24
    8138:	97 f9       	bld	r25, 7
    813a:	08 95       	ret

0000813c <__fp_mpack>:
    813c:	9f 3f       	cpi	r25, 0xFF	; 255
    813e:	31 f0       	breq	.+12     	; 0x814c <__fp_mpack_finite+0xc>

00008140 <__fp_mpack_finite>:
    8140:	91 50       	subi	r25, 0x01	; 1
    8142:	20 f4       	brcc	.+8      	; 0x814c <__fp_mpack_finite+0xc>
    8144:	87 95       	ror	r24
    8146:	77 95       	ror	r23
    8148:	67 95       	ror	r22
    814a:	b7 95       	ror	r27
    814c:	88 0f       	add	r24, r24
    814e:	91 1d       	adc	r25, r1
    8150:	96 95       	lsr	r25
    8152:	87 95       	ror	r24
    8154:	97 f9       	bld	r25, 7
    8156:	08 95       	ret

00008158 <__fp_nan>:
    8158:	9f ef       	ldi	r25, 0xFF	; 255
    815a:	80 ec       	ldi	r24, 0xC0	; 192
    815c:	08 95       	ret

0000815e <__fp_powser>:
    815e:	df 93       	push	r29
    8160:	cf 93       	push	r28
    8162:	1f 93       	push	r17
    8164:	0f 93       	push	r16
    8166:	ff 92       	push	r15
    8168:	ef 92       	push	r14
    816a:	df 92       	push	r13
    816c:	7b 01       	movw	r14, r22
    816e:	8c 01       	movw	r16, r24
    8170:	68 94       	set
    8172:	05 c0       	rjmp	.+10     	; 0x817e <__fp_powser+0x20>
    8174:	da 2e       	mov	r13, r26
    8176:	ef 01       	movw	r28, r30
    8178:	f6 d0       	rcall	.+492    	; 0x8366 <__mulsf3x>
    817a:	fe 01       	movw	r30, r28
    817c:	e8 94       	clt
    817e:	a5 91       	lpm	r26, Z+
    8180:	25 91       	lpm	r18, Z+
    8182:	35 91       	lpm	r19, Z+
    8184:	45 91       	lpm	r20, Z+
    8186:	55 91       	lpm	r21, Z+
    8188:	ae f3       	brts	.-22     	; 0x8174 <__fp_powser+0x16>
    818a:	ef 01       	movw	r28, r30
    818c:	da dd       	rcall	.-1100   	; 0x7d42 <__addsf3x>
    818e:	fe 01       	movw	r30, r28
    8190:	97 01       	movw	r18, r14
    8192:	a8 01       	movw	r20, r16
    8194:	da 94       	dec	r13
    8196:	79 f7       	brne	.-34     	; 0x8176 <__fp_powser+0x18>
    8198:	df 90       	pop	r13
    819a:	ef 90       	pop	r14
    819c:	ff 90       	pop	r15
    819e:	0f 91       	pop	r16
    81a0:	1f 91       	pop	r17
    81a2:	cf 91       	pop	r28
    81a4:	df 91       	pop	r29
    81a6:	08 95       	ret

000081a8 <__fp_pscA>:
    81a8:	00 24       	eor	r0, r0
    81aa:	0a 94       	dec	r0
    81ac:	16 16       	cp	r1, r22
    81ae:	17 06       	cpc	r1, r23
    81b0:	18 06       	cpc	r1, r24
    81b2:	09 06       	cpc	r0, r25
    81b4:	08 95       	ret

000081b6 <__fp_pscB>:
    81b6:	00 24       	eor	r0, r0
    81b8:	0a 94       	dec	r0
    81ba:	12 16       	cp	r1, r18
    81bc:	13 06       	cpc	r1, r19
    81be:	14 06       	cpc	r1, r20
    81c0:	05 06       	cpc	r0, r21
    81c2:	08 95       	ret
    81c4:	c9 cf       	rjmp	.-110    	; 0x8158 <__fp_nan>

000081c6 <__fp_rempio2>:
    81c6:	50 d0       	rcall	.+160    	; 0x8268 <__fp_splitA>
    81c8:	e8 f3       	brcs	.-6      	; 0x81c4 <__fp_pscB+0xe>
    81ca:	e8 94       	clt
    81cc:	e0 e0       	ldi	r30, 0x00	; 0
    81ce:	bb 27       	eor	r27, r27
    81d0:	9f 57       	subi	r25, 0x7F	; 127
    81d2:	f0 f0       	brcs	.+60     	; 0x8210 <__fp_rempio2+0x4a>
    81d4:	2a ed       	ldi	r18, 0xDA	; 218
    81d6:	3f e0       	ldi	r19, 0x0F	; 15
    81d8:	49 ec       	ldi	r20, 0xC9	; 201
    81da:	06 c0       	rjmp	.+12     	; 0x81e8 <__fp_rempio2+0x22>
    81dc:	ee 0f       	add	r30, r30
    81de:	bb 0f       	add	r27, r27
    81e0:	66 1f       	adc	r22, r22
    81e2:	77 1f       	adc	r23, r23
    81e4:	88 1f       	adc	r24, r24
    81e6:	28 f0       	brcs	.+10     	; 0x81f2 <__fp_rempio2+0x2c>
    81e8:	b2 3a       	cpi	r27, 0xA2	; 162
    81ea:	62 07       	cpc	r22, r18
    81ec:	73 07       	cpc	r23, r19
    81ee:	84 07       	cpc	r24, r20
    81f0:	28 f0       	brcs	.+10     	; 0x81fc <__fp_rempio2+0x36>
    81f2:	b2 5a       	subi	r27, 0xA2	; 162
    81f4:	62 0b       	sbc	r22, r18
    81f6:	73 0b       	sbc	r23, r19
    81f8:	84 0b       	sbc	r24, r20
    81fa:	e3 95       	inc	r30
    81fc:	9a 95       	dec	r25
    81fe:	72 f7       	brpl	.-36     	; 0x81dc <__fp_rempio2+0x16>
    8200:	80 38       	cpi	r24, 0x80	; 128
    8202:	30 f4       	brcc	.+12     	; 0x8210 <__fp_rempio2+0x4a>
    8204:	9a 95       	dec	r25
    8206:	bb 0f       	add	r27, r27
    8208:	66 1f       	adc	r22, r22
    820a:	77 1f       	adc	r23, r23
    820c:	88 1f       	adc	r24, r24
    820e:	d2 f7       	brpl	.-12     	; 0x8204 <__fp_rempio2+0x3e>
    8210:	90 48       	sbci	r25, 0x80	; 128
    8212:	96 cf       	rjmp	.-212    	; 0x8140 <__fp_mpack_finite>

00008214 <__fp_round>:
    8214:	09 2e       	mov	r0, r25
    8216:	03 94       	inc	r0
    8218:	00 0c       	add	r0, r0
    821a:	11 f4       	brne	.+4      	; 0x8220 <__fp_round+0xc>
    821c:	88 23       	and	r24, r24
    821e:	52 f0       	brmi	.+20     	; 0x8234 <__fp_round+0x20>
    8220:	bb 0f       	add	r27, r27
    8222:	40 f4       	brcc	.+16     	; 0x8234 <__fp_round+0x20>
    8224:	bf 2b       	or	r27, r31
    8226:	11 f4       	brne	.+4      	; 0x822c <__fp_round+0x18>
    8228:	60 ff       	sbrs	r22, 0
    822a:	04 c0       	rjmp	.+8      	; 0x8234 <__fp_round+0x20>
    822c:	6f 5f       	subi	r22, 0xFF	; 255
    822e:	7f 4f       	sbci	r23, 0xFF	; 255
    8230:	8f 4f       	sbci	r24, 0xFF	; 255
    8232:	9f 4f       	sbci	r25, 0xFF	; 255
    8234:	08 95       	ret

00008236 <__fp_sinus>:
    8236:	ef 93       	push	r30
    8238:	e0 ff       	sbrs	r30, 0
    823a:	06 c0       	rjmp	.+12     	; 0x8248 <__fp_sinus+0x12>
    823c:	a2 ea       	ldi	r26, 0xA2	; 162
    823e:	2a ed       	ldi	r18, 0xDA	; 218
    8240:	3f e0       	ldi	r19, 0x0F	; 15
    8242:	49 ec       	ldi	r20, 0xC9	; 201
    8244:	5f eb       	ldi	r21, 0xBF	; 191
    8246:	7d dd       	rcall	.-1286   	; 0x7d42 <__addsf3x>
    8248:	e5 df       	rcall	.-54     	; 0x8214 <__fp_round>
    824a:	0f 90       	pop	r0
    824c:	03 94       	inc	r0
    824e:	01 fc       	sbrc	r0, 1
    8250:	90 58       	subi	r25, 0x80	; 128
    8252:	eb ec       	ldi	r30, 0xCB	; 203
    8254:	f2 e0       	ldi	r31, 0x02	; 2
    8256:	57 c1       	rjmp	.+686    	; 0x8506 <__fp_powsodd>

00008258 <__fp_split3>:
    8258:	57 fd       	sbrc	r21, 7
    825a:	90 58       	subi	r25, 0x80	; 128
    825c:	44 0f       	add	r20, r20
    825e:	55 1f       	adc	r21, r21
    8260:	59 f0       	breq	.+22     	; 0x8278 <__fp_splitA+0x10>
    8262:	5f 3f       	cpi	r21, 0xFF	; 255
    8264:	71 f0       	breq	.+28     	; 0x8282 <__fp_splitA+0x1a>
    8266:	47 95       	ror	r20

00008268 <__fp_splitA>:
    8268:	88 0f       	add	r24, r24
    826a:	97 fb       	bst	r25, 7
    826c:	99 1f       	adc	r25, r25
    826e:	61 f0       	breq	.+24     	; 0x8288 <__fp_splitA+0x20>
    8270:	9f 3f       	cpi	r25, 0xFF	; 255
    8272:	79 f0       	breq	.+30     	; 0x8292 <__fp_splitA+0x2a>
    8274:	87 95       	ror	r24
    8276:	08 95       	ret
    8278:	12 16       	cp	r1, r18
    827a:	13 06       	cpc	r1, r19
    827c:	14 06       	cpc	r1, r20
    827e:	55 1f       	adc	r21, r21
    8280:	f2 cf       	rjmp	.-28     	; 0x8266 <__fp_split3+0xe>
    8282:	46 95       	lsr	r20
    8284:	f1 df       	rcall	.-30     	; 0x8268 <__fp_splitA>
    8286:	08 c0       	rjmp	.+16     	; 0x8298 <__fp_splitA+0x30>
    8288:	16 16       	cp	r1, r22
    828a:	17 06       	cpc	r1, r23
    828c:	18 06       	cpc	r1, r24
    828e:	99 1f       	adc	r25, r25
    8290:	f1 cf       	rjmp	.-30     	; 0x8274 <__fp_splitA+0xc>
    8292:	86 95       	lsr	r24
    8294:	71 05       	cpc	r23, r1
    8296:	61 05       	cpc	r22, r1
    8298:	08 94       	sec
    829a:	08 95       	ret

0000829c <__fp_trunc>:
    829c:	e5 df       	rcall	.-54     	; 0x8268 <__fp_splitA>
    829e:	a0 f0       	brcs	.+40     	; 0x82c8 <__fp_trunc+0x2c>
    82a0:	be e7       	ldi	r27, 0x7E	; 126
    82a2:	b9 17       	cp	r27, r25
    82a4:	88 f4       	brcc	.+34     	; 0x82c8 <__fp_trunc+0x2c>
    82a6:	bb 27       	eor	r27, r27
    82a8:	9f 38       	cpi	r25, 0x8F	; 143
    82aa:	60 f4       	brcc	.+24     	; 0x82c4 <__fp_trunc+0x28>
    82ac:	16 16       	cp	r1, r22
    82ae:	b1 1d       	adc	r27, r1
    82b0:	67 2f       	mov	r22, r23
    82b2:	78 2f       	mov	r23, r24
    82b4:	88 27       	eor	r24, r24
    82b6:	98 5f       	subi	r25, 0xF8	; 248
    82b8:	f7 cf       	rjmp	.-18     	; 0x82a8 <__fp_trunc+0xc>
    82ba:	86 95       	lsr	r24
    82bc:	77 95       	ror	r23
    82be:	67 95       	ror	r22
    82c0:	b1 1d       	adc	r27, r1
    82c2:	93 95       	inc	r25
    82c4:	96 39       	cpi	r25, 0x96	; 150
    82c6:	c8 f3       	brcs	.-14     	; 0x82ba <__fp_trunc+0x1e>
    82c8:	08 95       	ret

000082ca <__fp_zero>:
    82ca:	e8 94       	clt

000082cc <__fp_szero>:
    82cc:	bb 27       	eor	r27, r27
    82ce:	66 27       	eor	r22, r22
    82d0:	77 27       	eor	r23, r23
    82d2:	cb 01       	movw	r24, r22
    82d4:	97 f9       	bld	r25, 7
    82d6:	08 95       	ret

000082d8 <__gesf2>:
    82d8:	ec de       	rcall	.-552    	; 0x80b2 <__fp_cmp>
    82da:	08 f4       	brcc	.+2      	; 0x82de <__gesf2+0x6>
    82dc:	8f ef       	ldi	r24, 0xFF	; 255
    82de:	08 95       	ret

000082e0 <inverse>:
    82e0:	9b 01       	movw	r18, r22
    82e2:	ac 01       	movw	r20, r24
    82e4:	60 e0       	ldi	r22, 0x00	; 0
    82e6:	70 e0       	ldi	r23, 0x00	; 0
    82e8:	80 e8       	ldi	r24, 0x80	; 128
    82ea:	9f e3       	ldi	r25, 0x3F	; 63
    82ec:	f9 cd       	rjmp	.-1038   	; 0x7ee0 <__divsf3>

000082ee <lround>:
    82ee:	bc df       	rcall	.-136    	; 0x8268 <__fp_splitA>
    82f0:	58 f1       	brcs	.+86     	; 0x8348 <lround+0x5a>
    82f2:	9e 57       	subi	r25, 0x7E	; 126
    82f4:	58 f1       	brcs	.+86     	; 0x834c <lround+0x5e>
    82f6:	98 51       	subi	r25, 0x18	; 24
    82f8:	a0 f0       	brcs	.+40     	; 0x8322 <lround+0x34>
    82fa:	e9 f0       	breq	.+58     	; 0x8336 <lround+0x48>
    82fc:	98 30       	cpi	r25, 0x08	; 8
    82fe:	20 f5       	brcc	.+72     	; 0x8348 <lround+0x5a>
    8300:	09 2e       	mov	r0, r25
    8302:	99 27       	eor	r25, r25
    8304:	66 0f       	add	r22, r22
    8306:	77 1f       	adc	r23, r23
    8308:	88 1f       	adc	r24, r24
    830a:	99 1f       	adc	r25, r25
    830c:	0a 94       	dec	r0
    830e:	d1 f7       	brne	.-12     	; 0x8304 <lround+0x16>
    8310:	12 c0       	rjmp	.+36     	; 0x8336 <lround+0x48>
    8312:	06 2e       	mov	r0, r22
    8314:	67 2f       	mov	r22, r23
    8316:	78 2f       	mov	r23, r24
    8318:	88 27       	eor	r24, r24
    831a:	98 5f       	subi	r25, 0xF8	; 248
    831c:	11 f4       	brne	.+4      	; 0x8322 <lround+0x34>
    831e:	00 0c       	add	r0, r0
    8320:	07 c0       	rjmp	.+14     	; 0x8330 <lround+0x42>
    8322:	99 3f       	cpi	r25, 0xF9	; 249
    8324:	b4 f3       	brlt	.-20     	; 0x8312 <lround+0x24>
    8326:	86 95       	lsr	r24
    8328:	77 95       	ror	r23
    832a:	67 95       	ror	r22
    832c:	93 95       	inc	r25
    832e:	d9 f7       	brne	.-10     	; 0x8326 <lround+0x38>
    8330:	61 1d       	adc	r22, r1
    8332:	71 1d       	adc	r23, r1
    8334:	81 1d       	adc	r24, r1
    8336:	3e f4       	brtc	.+14     	; 0x8346 <lround+0x58>
    8338:	90 95       	com	r25
    833a:	80 95       	com	r24
    833c:	70 95       	com	r23
    833e:	61 95       	neg	r22
    8340:	7f 4f       	sbci	r23, 0xFF	; 255
    8342:	8f 4f       	sbci	r24, 0xFF	; 255
    8344:	9f 4f       	sbci	r25, 0xFF	; 255
    8346:	08 95       	ret
    8348:	68 94       	set
    834a:	c0 cf       	rjmp	.-128    	; 0x82cc <__fp_szero>
    834c:	be cf       	rjmp	.-132    	; 0x82ca <__fp_zero>

0000834e <__mulsf3>:
    834e:	0b d0       	rcall	.+22     	; 0x8366 <__mulsf3x>
    8350:	61 cf       	rjmp	.-318    	; 0x8214 <__fp_round>
    8352:	2a df       	rcall	.-428    	; 0x81a8 <__fp_pscA>
    8354:	28 f0       	brcs	.+10     	; 0x8360 <__mulsf3+0x12>
    8356:	2f df       	rcall	.-418    	; 0x81b6 <__fp_pscB>
    8358:	18 f0       	brcs	.+6      	; 0x8360 <__mulsf3+0x12>
    835a:	95 23       	and	r25, r21
    835c:	09 f0       	breq	.+2      	; 0x8360 <__mulsf3+0x12>
    835e:	cd ce       	rjmp	.-614    	; 0x80fa <__fp_inf>
    8360:	fb ce       	rjmp	.-522    	; 0x8158 <__fp_nan>
    8362:	11 24       	eor	r1, r1
    8364:	b3 cf       	rjmp	.-154    	; 0x82cc <__fp_szero>

00008366 <__mulsf3x>:
    8366:	78 df       	rcall	.-272    	; 0x8258 <__fp_split3>
    8368:	a0 f3       	brcs	.-24     	; 0x8352 <__mulsf3+0x4>

0000836a <__mulsf3_pse>:
    836a:	95 9f       	mul	r25, r21
    836c:	d1 f3       	breq	.-12     	; 0x8362 <__mulsf3+0x14>
    836e:	95 0f       	add	r25, r21
    8370:	50 e0       	ldi	r21, 0x00	; 0
    8372:	55 1f       	adc	r21, r21
    8374:	62 9f       	mul	r22, r18
    8376:	f0 01       	movw	r30, r0
    8378:	72 9f       	mul	r23, r18
    837a:	bb 27       	eor	r27, r27
    837c:	f0 0d       	add	r31, r0
    837e:	b1 1d       	adc	r27, r1
    8380:	63 9f       	mul	r22, r19
    8382:	aa 27       	eor	r26, r26
    8384:	f0 0d       	add	r31, r0
    8386:	b1 1d       	adc	r27, r1
    8388:	aa 1f       	adc	r26, r26
    838a:	64 9f       	mul	r22, r20
    838c:	66 27       	eor	r22, r22
    838e:	b0 0d       	add	r27, r0
    8390:	a1 1d       	adc	r26, r1
    8392:	66 1f       	adc	r22, r22
    8394:	82 9f       	mul	r24, r18
    8396:	22 27       	eor	r18, r18
    8398:	b0 0d       	add	r27, r0
    839a:	a1 1d       	adc	r26, r1
    839c:	62 1f       	adc	r22, r18
    839e:	73 9f       	mul	r23, r19
    83a0:	b0 0d       	add	r27, r0
    83a2:	a1 1d       	adc	r26, r1
    83a4:	62 1f       	adc	r22, r18
    83a6:	83 9f       	mul	r24, r19
    83a8:	a0 0d       	add	r26, r0
    83aa:	61 1d       	adc	r22, r1
    83ac:	22 1f       	adc	r18, r18
    83ae:	74 9f       	mul	r23, r20
    83b0:	33 27       	eor	r19, r19
    83b2:	a0 0d       	add	r26, r0
    83b4:	61 1d       	adc	r22, r1
    83b6:	23 1f       	adc	r18, r19
    83b8:	84 9f       	mul	r24, r20
    83ba:	60 0d       	add	r22, r0
    83bc:	21 1d       	adc	r18, r1
    83be:	82 2f       	mov	r24, r18
    83c0:	76 2f       	mov	r23, r22
    83c2:	6a 2f       	mov	r22, r26
    83c4:	11 24       	eor	r1, r1
    83c6:	9f 57       	subi	r25, 0x7F	; 127
    83c8:	50 40       	sbci	r21, 0x00	; 0
    83ca:	8a f0       	brmi	.+34     	; 0x83ee <__mulsf3_pse+0x84>
    83cc:	e1 f0       	breq	.+56     	; 0x8406 <__mulsf3_pse+0x9c>
    83ce:	88 23       	and	r24, r24
    83d0:	4a f0       	brmi	.+18     	; 0x83e4 <__mulsf3_pse+0x7a>
    83d2:	ee 0f       	add	r30, r30
    83d4:	ff 1f       	adc	r31, r31
    83d6:	bb 1f       	adc	r27, r27
    83d8:	66 1f       	adc	r22, r22
    83da:	77 1f       	adc	r23, r23
    83dc:	88 1f       	adc	r24, r24
    83de:	91 50       	subi	r25, 0x01	; 1
    83e0:	50 40       	sbci	r21, 0x00	; 0
    83e2:	a9 f7       	brne	.-22     	; 0x83ce <__mulsf3_pse+0x64>
    83e4:	9e 3f       	cpi	r25, 0xFE	; 254
    83e6:	51 05       	cpc	r21, r1
    83e8:	70 f0       	brcs	.+28     	; 0x8406 <__mulsf3_pse+0x9c>
    83ea:	87 ce       	rjmp	.-754    	; 0x80fa <__fp_inf>
    83ec:	6f cf       	rjmp	.-290    	; 0x82cc <__fp_szero>
    83ee:	5f 3f       	cpi	r21, 0xFF	; 255
    83f0:	ec f3       	brlt	.-6      	; 0x83ec <__mulsf3_pse+0x82>
    83f2:	98 3e       	cpi	r25, 0xE8	; 232
    83f4:	dc f3       	brlt	.-10     	; 0x83ec <__mulsf3_pse+0x82>
    83f6:	86 95       	lsr	r24
    83f8:	77 95       	ror	r23
    83fa:	67 95       	ror	r22
    83fc:	b7 95       	ror	r27
    83fe:	f7 95       	ror	r31
    8400:	e7 95       	ror	r30
    8402:	9f 5f       	subi	r25, 0xFF	; 255
    8404:	c1 f7       	brne	.-16     	; 0x83f6 <__mulsf3_pse+0x8c>
    8406:	fe 2b       	or	r31, r30
    8408:	88 0f       	add	r24, r24
    840a:	91 1d       	adc	r25, r1
    840c:	96 95       	lsr	r25
    840e:	87 95       	ror	r24
    8410:	97 f9       	bld	r25, 7
    8412:	08 95       	ret

00008414 <round>:
    8414:	29 df       	rcall	.-430    	; 0x8268 <__fp_splitA>
    8416:	e0 f0       	brcs	.+56     	; 0x8450 <round+0x3c>
    8418:	9e 37       	cpi	r25, 0x7E	; 126
    841a:	d8 f0       	brcs	.+54     	; 0x8452 <round+0x3e>
    841c:	96 39       	cpi	r25, 0x96	; 150
    841e:	b8 f4       	brcc	.+46     	; 0x844e <round+0x3a>
    8420:	9e 38       	cpi	r25, 0x8E	; 142
    8422:	48 f4       	brcc	.+18     	; 0x8436 <round+0x22>
    8424:	67 2f       	mov	r22, r23
    8426:	78 2f       	mov	r23, r24
    8428:	88 27       	eor	r24, r24
    842a:	98 5f       	subi	r25, 0xF8	; 248
    842c:	f9 cf       	rjmp	.-14     	; 0x8420 <round+0xc>
    842e:	86 95       	lsr	r24
    8430:	77 95       	ror	r23
    8432:	67 95       	ror	r22
    8434:	93 95       	inc	r25
    8436:	95 39       	cpi	r25, 0x95	; 149
    8438:	d0 f3       	brcs	.-12     	; 0x842e <round+0x1a>
    843a:	b6 2f       	mov	r27, r22
    843c:	b1 70       	andi	r27, 0x01	; 1
    843e:	6b 0f       	add	r22, r27
    8440:	71 1d       	adc	r23, r1
    8442:	81 1d       	adc	r24, r1
    8444:	20 f4       	brcc	.+8      	; 0x844e <round+0x3a>
    8446:	87 95       	ror	r24
    8448:	77 95       	ror	r23
    844a:	67 95       	ror	r22
    844c:	93 95       	inc	r25
    844e:	5b ce       	rjmp	.-842    	; 0x8106 <__fp_mintl>
    8450:	75 ce       	rjmp	.-790    	; 0x813c <__fp_mpack>
    8452:	3c cf       	rjmp	.-392    	; 0x82cc <__fp_szero>

00008454 <sin>:
    8454:	9f 93       	push	r25
    8456:	b7 de       	rcall	.-658    	; 0x81c6 <__fp_rempio2>
    8458:	0f 90       	pop	r0
    845a:	07 fc       	sbrc	r0, 7
    845c:	ee 5f       	subi	r30, 0xFE	; 254
    845e:	eb ce       	rjmp	.-554    	; 0x8236 <__fp_sinus>
    8460:	11 f4       	brne	.+4      	; 0x8466 <sin+0x12>
    8462:	0e f4       	brtc	.+2      	; 0x8466 <sin+0x12>
    8464:	79 ce       	rjmp	.-782    	; 0x8158 <__fp_nan>
    8466:	6a ce       	rjmp	.-812    	; 0x813c <__fp_mpack>

00008468 <sqrt>:
    8468:	ff de       	rcall	.-514    	; 0x8268 <__fp_splitA>
    846a:	d0 f3       	brcs	.-12     	; 0x8460 <sin+0xc>
    846c:	99 23       	and	r25, r25
    846e:	d9 f3       	breq	.-10     	; 0x8466 <sin+0x12>
    8470:	ce f3       	brts	.-14     	; 0x8464 <sin+0x10>
    8472:	9f 57       	subi	r25, 0x7F	; 127
    8474:	55 0b       	sbc	r21, r21
    8476:	87 ff       	sbrs	r24, 7
    8478:	3f d0       	rcall	.+126    	; 0x84f8 <__fp_norm2>
    847a:	00 24       	eor	r0, r0
    847c:	a0 e6       	ldi	r26, 0x60	; 96
    847e:	40 ea       	ldi	r20, 0xA0	; 160
    8480:	90 01       	movw	r18, r0
    8482:	80 58       	subi	r24, 0x80	; 128
    8484:	56 95       	lsr	r21
    8486:	97 95       	ror	r25
    8488:	28 f4       	brcc	.+10     	; 0x8494 <sqrt+0x2c>
    848a:	80 5c       	subi	r24, 0xC0	; 192
    848c:	66 0f       	add	r22, r22
    848e:	77 1f       	adc	r23, r23
    8490:	88 1f       	adc	r24, r24
    8492:	20 f0       	brcs	.+8      	; 0x849c <sqrt+0x34>
    8494:	26 17       	cp	r18, r22
    8496:	37 07       	cpc	r19, r23
    8498:	48 07       	cpc	r20, r24
    849a:	30 f4       	brcc	.+12     	; 0x84a8 <sqrt+0x40>
    849c:	62 1b       	sub	r22, r18
    849e:	73 0b       	sbc	r23, r19
    84a0:	84 0b       	sbc	r24, r20
    84a2:	20 29       	or	r18, r0
    84a4:	31 29       	or	r19, r1
    84a6:	4a 2b       	or	r20, r26
    84a8:	a6 95       	lsr	r26
    84aa:	17 94       	ror	r1
    84ac:	07 94       	ror	r0
    84ae:	20 25       	eor	r18, r0
    84b0:	31 25       	eor	r19, r1
    84b2:	4a 27       	eor	r20, r26
    84b4:	58 f7       	brcc	.-42     	; 0x848c <sqrt+0x24>
    84b6:	66 0f       	add	r22, r22
    84b8:	77 1f       	adc	r23, r23
    84ba:	88 1f       	adc	r24, r24
    84bc:	20 f0       	brcs	.+8      	; 0x84c6 <sqrt+0x5e>
    84be:	26 17       	cp	r18, r22
    84c0:	37 07       	cpc	r19, r23
    84c2:	48 07       	cpc	r20, r24
    84c4:	30 f4       	brcc	.+12     	; 0x84d2 <sqrt+0x6a>
    84c6:	62 0b       	sbc	r22, r18
    84c8:	73 0b       	sbc	r23, r19
    84ca:	84 0b       	sbc	r24, r20
    84cc:	20 0d       	add	r18, r0
    84ce:	31 1d       	adc	r19, r1
    84d0:	41 1d       	adc	r20, r1
    84d2:	a0 95       	com	r26
    84d4:	81 f7       	brne	.-32     	; 0x84b6 <sqrt+0x4e>
    84d6:	b9 01       	movw	r22, r18
    84d8:	84 2f       	mov	r24, r20
    84da:	91 58       	subi	r25, 0x81	; 129
    84dc:	88 0f       	add	r24, r24
    84de:	96 95       	lsr	r25
    84e0:	87 95       	ror	r24
    84e2:	08 95       	ret

000084e4 <square>:
    84e4:	9b 01       	movw	r18, r22
    84e6:	ac 01       	movw	r20, r24
    84e8:	32 cf       	rjmp	.-412    	; 0x834e <__mulsf3>

000084ea <trunc>:
    84ea:	d8 de       	rcall	.-592    	; 0x829c <__fp_trunc>
    84ec:	20 f0       	brcs	.+8      	; 0x84f6 <trunc+0xc>
    84ee:	9f 37       	cpi	r25, 0x7F	; 127
    84f0:	08 f4       	brcc	.+2      	; 0x84f4 <trunc+0xa>
    84f2:	ec ce       	rjmp	.-552    	; 0x82cc <__fp_szero>
    84f4:	08 ce       	rjmp	.-1008   	; 0x8106 <__fp_mintl>
    84f6:	22 ce       	rjmp	.-956    	; 0x813c <__fp_mpack>

000084f8 <__fp_norm2>:
    84f8:	91 50       	subi	r25, 0x01	; 1
    84fa:	50 40       	sbci	r21, 0x00	; 0
    84fc:	66 0f       	add	r22, r22
    84fe:	77 1f       	adc	r23, r23
    8500:	88 1f       	adc	r24, r24
    8502:	d2 f7       	brpl	.-12     	; 0x84f8 <__fp_norm2>
    8504:	08 95       	ret

00008506 <__fp_powsodd>:
    8506:	9f 93       	push	r25
    8508:	8f 93       	push	r24
    850a:	7f 93       	push	r23
    850c:	6f 93       	push	r22
    850e:	ff 93       	push	r31
    8510:	ef 93       	push	r30
    8512:	9b 01       	movw	r18, r22
    8514:	ac 01       	movw	r20, r24
    8516:	1b df       	rcall	.-458    	; 0x834e <__mulsf3>
    8518:	ef 91       	pop	r30
    851a:	ff 91       	pop	r31
    851c:	20 de       	rcall	.-960    	; 0x815e <__fp_powser>
    851e:	2f 91       	pop	r18
    8520:	3f 91       	pop	r19
    8522:	4f 91       	pop	r20
    8524:	5f 91       	pop	r21
    8526:	13 cf       	rjmp	.-474    	; 0x834e <__mulsf3>

00008528 <__udivmodsi4>:
    8528:	a1 e2       	ldi	r26, 0x21	; 33
    852a:	1a 2e       	mov	r1, r26
    852c:	aa 1b       	sub	r26, r26
    852e:	bb 1b       	sub	r27, r27
    8530:	fd 01       	movw	r30, r26
    8532:	0d c0       	rjmp	.+26     	; 0x854e <__udivmodsi4_ep>

00008534 <__udivmodsi4_loop>:
    8534:	aa 1f       	adc	r26, r26
    8536:	bb 1f       	adc	r27, r27
    8538:	ee 1f       	adc	r30, r30
    853a:	ff 1f       	adc	r31, r31
    853c:	a2 17       	cp	r26, r18
    853e:	b3 07       	cpc	r27, r19
    8540:	e4 07       	cpc	r30, r20
    8542:	f5 07       	cpc	r31, r21
    8544:	20 f0       	brcs	.+8      	; 0x854e <__udivmodsi4_ep>
    8546:	a2 1b       	sub	r26, r18
    8548:	b3 0b       	sbc	r27, r19
    854a:	e4 0b       	sbc	r30, r20
    854c:	f5 0b       	sbc	r31, r21

0000854e <__udivmodsi4_ep>:
    854e:	66 1f       	adc	r22, r22
    8550:	77 1f       	adc	r23, r23
    8552:	88 1f       	adc	r24, r24
    8554:	99 1f       	adc	r25, r25
    8556:	1a 94       	dec	r1
    8558:	69 f7       	brne	.-38     	; 0x8534 <__udivmodsi4_loop>
    855a:	60 95       	com	r22
    855c:	70 95       	com	r23
    855e:	80 95       	com	r24
    8560:	90 95       	com	r25
    8562:	9b 01       	movw	r18, r22
    8564:	ac 01       	movw	r20, r24
    8566:	bd 01       	movw	r22, r26
    8568:	cf 01       	movw	r24, r30
    856a:	08 95       	ret

0000856c <__tablejump2__>:
    856c:	ee 0f       	add	r30, r30
    856e:	ff 1f       	adc	r31, r31
    8570:	88 1f       	adc	r24, r24
    8572:	8b bf       	out	0x3b, r24	; 59
    8574:	07 90       	elpm	r0, Z+
    8576:	f6 91       	elpm	r31, Z
    8578:	e0 2d       	mov	r30, r0
    857a:	19 94       	eijmp

0000857c <__umulhisi3>:
    857c:	a2 9f       	mul	r26, r18
    857e:	b0 01       	movw	r22, r0
    8580:	b3 9f       	mul	r27, r19
    8582:	c0 01       	movw	r24, r0
    8584:	a3 9f       	mul	r26, r19
    8586:	70 0d       	add	r23, r0
    8588:	81 1d       	adc	r24, r1
    858a:	11 24       	eor	r1, r1
    858c:	91 1d       	adc	r25, r1
    858e:	b2 9f       	mul	r27, r18
    8590:	70 0d       	add	r23, r0
    8592:	81 1d       	adc	r24, r1
    8594:	11 24       	eor	r1, r1
    8596:	91 1d       	adc	r25, r1
    8598:	08 95       	ret

0000859a <memcmp>:
    859a:	fb 01       	movw	r30, r22
    859c:	dc 01       	movw	r26, r24
    859e:	04 c0       	rjmp	.+8      	; 0x85a8 <memcmp+0xe>
    85a0:	8d 91       	ld	r24, X+
    85a2:	01 90       	ld	r0, Z+
    85a4:	80 19       	sub	r24, r0
    85a6:	21 f4       	brne	.+8      	; 0x85b0 <memcmp+0x16>
    85a8:	41 50       	subi	r20, 0x01	; 1
    85aa:	50 40       	sbci	r21, 0x00	; 0
    85ac:	c8 f7       	brcc	.-14     	; 0x85a0 <memcmp+0x6>
    85ae:	88 1b       	sub	r24, r24
    85b0:	99 0b       	sbc	r25, r25
    85b2:	08 95       	ret

000085b4 <_exit>:
    85b4:	f8 94       	cli

000085b6 <__stop_program>:
    85b6:	ff cf       	rjmp	.-2      	; 0x85b6 <__stop_program>


GRBL-L-Mega.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800200  00800200  00008624  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000085b0  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000d27  00800200  00800200  00008624  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00008624  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00008654  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006d8  00000000  00000000  00008694  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000b061  00000000  00000000  00008d6c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002c8c  00000000  00000000  00013dcd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00006371  00000000  00000000  00016a59  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000016b4  00000000  00000000  0001cdcc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000021f2  00000000  00000000  0001e480  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000070af  00000000  00000000  00020672  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000006e0  00000000  00000000  00027721  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	96 c2       	rjmp	.+1324   	; 0x52e <__ctors_end>
       2:	00 00       	nop
       4:	a7 c2       	rjmp	.+1358   	; 0x554 <__bad_interrupt>
       6:	00 00       	nop
       8:	a5 c2       	rjmp	.+1354   	; 0x554 <__bad_interrupt>
       a:	00 00       	nop
       c:	a3 c2       	rjmp	.+1350   	; 0x554 <__bad_interrupt>
       e:	00 00       	nop
      10:	a1 c2       	rjmp	.+1346   	; 0x554 <__bad_interrupt>
      12:	00 00       	nop
      14:	9f c2       	rjmp	.+1342   	; 0x554 <__bad_interrupt>
      16:	00 00       	nop
      18:	9d c2       	rjmp	.+1338   	; 0x554 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	9b c2       	rjmp	.+1334   	; 0x554 <__bad_interrupt>
      1e:	00 00       	nop
      20:	99 c2       	rjmp	.+1330   	; 0x554 <__bad_interrupt>
      22:	00 00       	nop
      24:	0c 94 7e 30 	jmp	0x60fc	; 0x60fc <__vector_9>
      28:	95 c2       	rjmp	.+1322   	; 0x554 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	0c 94 85 3a 	jmp	0x750a	; 0x750a <__vector_11>
      30:	0c 94 9b 30 	jmp	0x6136	; 0x6136 <__vector_12>
      34:	8f c2       	rjmp	.+1310   	; 0x554 <__bad_interrupt>
      36:	00 00       	nop
      38:	8d c2       	rjmp	.+1306   	; 0x554 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	8b c2       	rjmp	.+1302   	; 0x554 <__bad_interrupt>
      3e:	00 00       	nop
      40:	89 c2       	rjmp	.+1298   	; 0x554 <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 5b 19 	jmp	0x32b6	; 0x32b6 <__vector_17>
      48:	85 c2       	rjmp	.+1290   	; 0x554 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	83 c2       	rjmp	.+1286   	; 0x554 <__bad_interrupt>
      4e:	00 00       	nop
      50:	81 c2       	rjmp	.+1282   	; 0x554 <__bad_interrupt>
      52:	00 00       	nop
      54:	7f c2       	rjmp	.+1278   	; 0x554 <__bad_interrupt>
      56:	00 00       	nop
      58:	7d c2       	rjmp	.+1274   	; 0x554 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0c 94 59 1b 	jmp	0x36b2	; 0x36b2 <__vector_23>
      60:	79 c2       	rjmp	.+1266   	; 0x554 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 4c 14 	jmp	0x2898	; 0x2898 <__vector_25>
      68:	0c 94 10 14 	jmp	0x2820	; 0x2820 <__vector_26>
      6c:	73 c2       	rjmp	.+1254   	; 0x554 <__bad_interrupt>
      6e:	00 00       	nop
      70:	71 c2       	rjmp	.+1250   	; 0x554 <__bad_interrupt>
      72:	00 00       	nop
      74:	6f c2       	rjmp	.+1246   	; 0x554 <__bad_interrupt>
      76:	00 00       	nop
      78:	6d c2       	rjmp	.+1242   	; 0x554 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	6b c2       	rjmp	.+1238   	; 0x554 <__bad_interrupt>
      7e:	00 00       	nop
      80:	69 c2       	rjmp	.+1234   	; 0x554 <__bad_interrupt>
      82:	00 00       	nop
      84:	67 c2       	rjmp	.+1230   	; 0x554 <__bad_interrupt>
      86:	00 00       	nop
      88:	65 c2       	rjmp	.+1226   	; 0x554 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	0c 94 39 3e 	jmp	0x7c72	; 0x7c72 <__vector_35>
      90:	61 c2       	rjmp	.+1218   	; 0x554 <__bad_interrupt>
      92:	00 00       	nop
      94:	5f c2       	rjmp	.+1214   	; 0x554 <__bad_interrupt>
      96:	00 00       	nop
      98:	5d c2       	rjmp	.+1210   	; 0x554 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	5b c2       	rjmp	.+1206   	; 0x554 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	59 c2       	rjmp	.+1202   	; 0x554 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	57 c2       	rjmp	.+1198   	; 0x554 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	55 c2       	rjmp	.+1194   	; 0x554 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	53 c2       	rjmp	.+1190   	; 0x554 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	51 c2       	rjmp	.+1186   	; 0x554 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	4f c2       	rjmp	.+1182   	; 0x554 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	4d c2       	rjmp	.+1178   	; 0x554 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	4b c2       	rjmp	.+1174   	; 0x554 <__bad_interrupt>
      be:	00 00       	nop
      c0:	49 c2       	rjmp	.+1170   	; 0x554 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	47 c2       	rjmp	.+1166   	; 0x554 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	46 c2       	rjmp	.+1164   	; 0x556 <__vector_50>
      ca:	00 00       	nop
      cc:	43 c2       	rjmp	.+1158   	; 0x554 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	41 c2       	rjmp	.+1154   	; 0x554 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	3f c2       	rjmp	.+1150   	; 0x554 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	3d c2       	rjmp	.+1146   	; 0x554 <__bad_interrupt>
      da:	00 00       	nop
      dc:	3b c2       	rjmp	.+1142   	; 0x554 <__bad_interrupt>
      de:	00 00       	nop
      e0:	39 c2       	rjmp	.+1138   	; 0x554 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	18 08       	sbc	r1, r8
      e6:	18 08       	sbc	r1, r8
      e8:	18 08       	sbc	r1, r8
      ea:	18 08       	sbc	r1, r8
      ec:	0f 08       	sbc	r0, r15
      ee:	8e 11       	cpse	r24, r14
      f0:	8e 11       	cpse	r24, r14
      f2:	8e 11       	cpse	r24, r14
      f4:	8e 11       	cpse	r24, r14
      f6:	8e 11       	cpse	r24, r14
      f8:	04 08       	sbc	r0, r4
      fa:	8e 11       	cpse	r24, r14
      fc:	8e 11       	cpse	r24, r14
      fe:	8e 11       	cpse	r24, r14
     100:	8e 11       	cpse	r24, r14
     102:	8e 11       	cpse	r24, r14
     104:	8e 11       	cpse	r24, r14
     106:	42 08       	sbc	r4, r2
     108:	42 08       	sbc	r4, r2
     10a:	42 08       	sbc	r4, r2
     10c:	63 08       	sbc	r6, r3
     10e:	63 08       	sbc	r6, r3
     110:	8e 11       	cpse	r24, r14
     112:	8e 11       	cpse	r24, r14
     114:	8e 11       	cpse	r24, r14
     116:	8e 11       	cpse	r24, r14
     118:	8e 11       	cpse	r24, r14
     11a:	8e 11       	cpse	r24, r14
     11c:	04 08       	sbc	r0, r4
     11e:	8e 11       	cpse	r24, r14
     120:	04 08       	sbc	r0, r4
     122:	8e 11       	cpse	r24, r14
     124:	8e 11       	cpse	r24, r14
     126:	8e 11       	cpse	r24, r14
     128:	8e 11       	cpse	r24, r14
     12a:	8e 11       	cpse	r24, r14
     12c:	8e 11       	cpse	r24, r14
     12e:	8e 11       	cpse	r24, r14
     130:	18 08       	sbc	r1, r8
     132:	8e 11       	cpse	r24, r14
     134:	8e 08       	sbc	r8, r14
     136:	8e 11       	cpse	r24, r14
     138:	8e 11       	cpse	r24, r14
     13a:	69 08       	sbc	r6, r9
     13c:	8e 11       	cpse	r24, r14
     13e:	8e 11       	cpse	r24, r14
     140:	8e 11       	cpse	r24, r14
     142:	8e 11       	cpse	r24, r14
     144:	8e 11       	cpse	r24, r14
     146:	69 08       	sbc	r6, r9
     148:	8e 11       	cpse	r24, r14
     14a:	8e 11       	cpse	r24, r14
     14c:	8e 11       	cpse	r24, r14
     14e:	0f 08       	sbc	r0, r15
     150:	82 08       	sbc	r8, r2
     152:	82 08       	sbc	r8, r2
     154:	82 08       	sbc	r8, r2
     156:	82 08       	sbc	r8, r2
     158:	82 08       	sbc	r8, r2
     15a:	82 08       	sbc	r8, r2
     15c:	8e 11       	cpse	r24, r14
     15e:	88 08       	sbc	r8, r8
     160:	8e 11       	cpse	r24, r14
     162:	8e 11       	cpse	r24, r14
     164:	8e 11       	cpse	r24, r14
     166:	8e 11       	cpse	r24, r14
     168:	8e 11       	cpse	r24, r14
     16a:	8e 11       	cpse	r24, r14
     16c:	8e 11       	cpse	r24, r14
     16e:	8e 11       	cpse	r24, r14
     170:	8e 11       	cpse	r24, r14
     172:	8e 11       	cpse	r24, r14
     174:	8e 11       	cpse	r24, r14
     176:	8e 11       	cpse	r24, r14
     178:	8e 11       	cpse	r24, r14
     17a:	8e 11       	cpse	r24, r14
     17c:	8e 11       	cpse	r24, r14
     17e:	8e 11       	cpse	r24, r14
     180:	8e 11       	cpse	r24, r14
     182:	8e 11       	cpse	r24, r14
     184:	1e 08       	sbc	r1, r14
     186:	8e 11       	cpse	r24, r14
     188:	8e 11       	cpse	r24, r14
     18a:	8e 11       	cpse	r24, r14
     18c:	8e 11       	cpse	r24, r14
     18e:	8e 11       	cpse	r24, r14
     190:	8e 11       	cpse	r24, r14
     192:	8e 11       	cpse	r24, r14
     194:	8e 11       	cpse	r24, r14
     196:	8e 11       	cpse	r24, r14
     198:	48 08       	sbc	r4, r8
     19a:	48 08       	sbc	r4, r8
     19c:	04 08       	sbc	r0, r4
     19e:	5d 08       	sbc	r5, r13
     1a0:	5d 08       	sbc	r5, r13
     1a2:	b7 08       	sbc	r11, r7
     1a4:	b7 08       	sbc	r11, r7
     1a6:	b7 08       	sbc	r11, r7
     1a8:	c6 08       	sbc	r12, r6
     1aa:	c6 08       	sbc	r12, r6
     1ac:	c6 08       	sbc	r12, r6
     1ae:	a8 11       	cpse	r26, r8
     1b0:	dd 08       	sbc	r13, r13
     1b2:	dd 08       	sbc	r13, r13
     1b4:	dd 08       	sbc	r13, r13
     1b6:	a8 11       	cpse	r26, r8
     1b8:	a8 11       	cpse	r26, r8
     1ba:	a8 11       	cpse	r26, r8
     1bc:	a8 11       	cpse	r26, r8
     1be:	a8 11       	cpse	r26, r8
     1c0:	a8 11       	cpse	r26, r8
     1c2:	a8 11       	cpse	r26, r8
     1c4:	a8 11       	cpse	r26, r8
     1c6:	a8 11       	cpse	r26, r8
     1c8:	a8 11       	cpse	r26, r8
     1ca:	a8 11       	cpse	r26, r8
     1cc:	a8 11       	cpse	r26, r8
     1ce:	a8 11       	cpse	r26, r8
     1d0:	a8 11       	cpse	r26, r8
     1d2:	a8 11       	cpse	r26, r8
     1d4:	a8 11       	cpse	r26, r8
     1d6:	a8 11       	cpse	r26, r8
     1d8:	a8 11       	cpse	r26, r8
     1da:	a8 11       	cpse	r26, r8
     1dc:	a8 11       	cpse	r26, r8
     1de:	b7 08       	sbc	r11, r7
     1e0:	1d 09       	sbc	r17, r13
     1e2:	ac 11       	cpse	r26, r12
     1e4:	ac 11       	cpse	r26, r12
     1e6:	27 09       	sbc	r18, r7
     1e8:	34 09       	sbc	r19, r4
     1ea:	41 09       	sbc	r20, r1
     1ec:	4e 09       	sbc	r20, r14
     1ee:	ac 11       	cpse	r26, r12
     1f0:	52 09       	sbc	r21, r2
     1f2:	ac 11       	cpse	r26, r12
     1f4:	60 09       	sbc	r22, r0
     1f6:	ac 11       	cpse	r26, r12
     1f8:	6a 09       	sbc	r22, r10
     1fa:	74 09       	sbc	r23, r4
     1fc:	7e 09       	sbc	r23, r14
     1fe:	ac 11       	cpse	r26, r12
     200:	ac 11       	cpse	r26, r12
     202:	ac 11       	cpse	r26, r12
     204:	8e 09       	sbc	r24, r14
     206:	9b 09       	sbc	r25, r11
     208:	a8 09       	sbc	r26, r8
     20a:	8d 14       	cp	r8, r13
     20c:	91 14       	cp	r9, r1
     20e:	99 14       	cp	r9, r9
     210:	f0 14       	cp	r15, r0
     212:	f0 14       	cp	r15, r0
     214:	f0 14       	cp	r15, r0
     216:	f0 14       	cp	r15, r0
     218:	f0 14       	cp	r15, r0
     21a:	f0 14       	cp	r15, r0
     21c:	f0 14       	cp	r15, r0
     21e:	f0 14       	cp	r15, r0
     220:	f0 14       	cp	r15, r0
     222:	a2 14       	cp	r10, r2
     224:	a6 14       	cp	r10, r6
     226:	aa 14       	cp	r10, r10
     228:	ae 14       	cp	r10, r14
     22a:	b2 14       	cp	r11, r2
     22c:	b6 14       	cp	r11, r6
     22e:	ba 14       	cp	r11, r10
     230:	be 14       	cp	r11, r14
     232:	f0 14       	cp	r15, r0
     234:	c2 14       	cp	r12, r2
     236:	c6 14       	cp	r12, r6
     238:	ca 14       	cp	r12, r10
     23a:	ce 14       	cp	r12, r14
     23c:	d2 14       	cp	r13, r2
     23e:	d6 14       	cp	r13, r6
     240:	f0 14       	cp	r15, r0
     242:	da 14       	cp	r13, r10
     244:	de 14       	cp	r13, r14
     246:	5f 26       	eor	r5, r31
     248:	65 26       	eor	r6, r21
     24a:	68 26       	eor	r6, r24
     24c:	6d 26       	eor	r6, r29
     24e:	72 26       	eor	r7, r18
     250:	80 26       	eor	r8, r16
     252:	8e 26       	eor	r8, r30
     254:	41 27       	eor	r20, r17
     256:	41 27       	eor	r20, r17
     258:	41 27       	eor	r20, r17
     25a:	9f 26       	eor	r9, r31
     25c:	a2 26       	eor	r10, r18
     25e:	ab 26       	eor	r10, r27
     260:	b4 26       	eor	r11, r20
     262:	41 27       	eor	r20, r17
     264:	41 27       	eor	r20, r17
     266:	41 27       	eor	r20, r17
     268:	41 27       	eor	r20, r17
     26a:	41 27       	eor	r20, r17
     26c:	41 27       	eor	r20, r17
     26e:	c4 26       	eor	r12, r20
     270:	d4 26       	eor	r13, r20
     272:	e4 26       	eor	r14, r20
     274:	f2 26       	eor	r15, r18
     276:	f5 26       	eor	r15, r21
     278:	fe 26       	eor	r15, r30
     27a:	07 27       	eor	r16, r23
     27c:	0e 27       	eor	r16, r30
     27e:	41 27       	eor	r20, r17
     280:	41 27       	eor	r20, r17
     282:	17 27       	eor	r17, r23
     284:	22 27       	eor	r18, r18
     286:	2d 27       	eor	r18, r29
     288:	bd 35       	cpi	r27, 0x5D	; 93
     28a:	c1 35       	cpi	r28, 0x51	; 81
     28c:	c5 35       	cpi	r28, 0x55	; 85
     28e:	c9 35       	cpi	r28, 0x59	; 89
     290:	cd 35       	cpi	r28, 0x5D	; 93
     292:	d1 35       	cpi	r29, 0x51	; 81
     294:	d5 35       	cpi	r29, 0x55	; 85
     296:	d9 35       	cpi	r29, 0x59	; 89
     298:	dd 35       	cpi	r29, 0x5D	; 93
     29a:	e1 35       	cpi	r30, 0x51	; 81
     29c:	e5 35       	cpi	r30, 0x55	; 85
     29e:	08 4a       	sbci	r16, 0xA8	; 168
     2a0:	d7 3b       	cpi	r29, 0xB7	; 183
     2a2:	3b ce       	rjmp	.-906    	; 0xffffff1a <__eeprom_end+0xff7eff1a>
     2a4:	01 6e       	ori	r16, 0xE1	; 225
     2a6:	84 bc       	out	0x24, r8	; 36
     2a8:	bf fd       	.word	0xfdbf	; ????
     2aa:	c1 2f       	mov	r28, r17
     2ac:	3d 6c       	ori	r19, 0xCD	; 205
     2ae:	74 31       	cpi	r23, 0x14	; 20
     2b0:	9a bd       	out	0x2a, r25	; 42
     2b2:	56 83       	std	Z+6, r21	; 0x06
     2b4:	3d da       	rcall	.-2950   	; 0xfffff730 <__eeprom_end+0xff7ef730>
     2b6:	3d 00       	.word	0x003d	; ????
     2b8:	c7 7f       	andi	r28, 0xF7	; 247
     2ba:	11 be       	out	0x31, r1	; 49
     2bc:	d9 e4       	ldi	r29, 0x49	; 73
     2be:	bb 4c       	sbci	r27, 0xCB	; 203
     2c0:	3e 91       	ld	r19, -X
     2c2:	6b aa       	std	Y+51, r6	; 0x33
     2c4:	aa be       	out	0x3a, r10	; 58
     2c6:	00 00       	nop
     2c8:	00 80       	ld	r0, Z
     2ca:	3f 05       	cpc	r19, r15
     2cc:	a8 4c       	sbci	r26, 0xC8	; 200
     2ce:	cd b2       	in	r12, 0x1d	; 29
     2d0:	d4 4e       	sbci	r29, 0xE4	; 228
     2d2:	b9 38       	cpi	r27, 0x89	; 137
     2d4:	36 a9       	ldd	r19, Z+54	; 0x36
     2d6:	02 0c       	add	r0, r2
     2d8:	50 b9       	out	0x00, r21	; 0
     2da:	91 86       	std	Z+9, r9	; 0x09
     2dc:	88 08       	sbc	r8, r8
     2de:	3c a6       	std	Y+44, r3	; 0x2c
     2e0:	aa aa       	std	Y+50, r10	; 0x32
     2e2:	2a be       	out	0x3a, r2	; 58
     2e4:	00 00       	nop
     2e6:	00 80       	ld	r0, Z
     2e8:	3f 00       	.word	0x003f	; ????

000002ea <__trampolines_end>:
     2ea:	00 00       	nop
     2ec:	7a 43       	sbci	r23, 0x3A	; 58
     2ee:	00 00       	nop
     2f0:	7a 43       	sbci	r23, 0x3A	; 58
     2f2:	00 00       	nop
     2f4:	7a 43       	sbci	r23, 0x3A	; 58
     2f6:	00 00       	nop
     2f8:	fa 43       	sbci	r31, 0x3A	; 58
     2fa:	00 00       	nop
     2fc:	fa 43       	sbci	r31, 0x3A	; 58
     2fe:	00 00       	nop
     300:	fa 43       	sbci	r31, 0x3A	; 58
     302:	00 a0       	ldd	r0, Z+32	; 0x20
     304:	0c 47       	sbci	r16, 0x7C	; 124
     306:	00 a0       	ldd	r0, Z+32	; 0x20
     308:	0c 47       	sbci	r16, 0x7C	; 124
     30a:	00 a0       	ldd	r0, Z+32	; 0x20
     30c:	0c 47       	sbci	r16, 0x7C	; 124
     30e:	00 00       	nop
     310:	48 c3       	rjmp	.+1680   	; 0x9a2 <mc_arc+0x25c>
     312:	00 00       	nop
     314:	48 c3       	rjmp	.+1680   	; 0x9a6 <mc_arc+0x260>
     316:	00 00       	nop
     318:	48 c3       	rjmp	.+1680   	; 0x9aa <mc_arc+0x264>
     31a:	0a 00       	.word	0x000a	; ????
     31c:	00 19       	sub	r16, r0
     31e:	01 0a       	sbc	r0, r17
     320:	d7 23       	and	r29, r23
     322:	3c 6f       	ori	r19, 0xFC	; 252
     324:	12 03       	mulsu	r17, r18
     326:	3b 00       	.word	0x003b	; ????
     328:	00 7a       	andi	r16, 0xA0	; 160
     32a:	44 00       	.word	0x0044	; ????
     32c:	00 00       	nop
     32e:	00 00       	nop
     330:	00 00       	nop
     332:	00 c8       	rjmp	.-4096   	; 0xfffff334 <__eeprom_end+0xff7ef334>
     334:	41 00       	.word	0x0041	; ????
     336:	00 fa       	bst	r0, 0
     338:	43 fa       	bst	r4, 3
     33a:	00 00       	nop
     33c:	00 80       	ld	r0, Z
     33e:	3f 7c       	Address 0x0000033e is out of bounds.
.word	0xffff	; ????

0000033f <__c.2810>:
     33f:	7c 41 3a 00                                         |A:.

00000343 <__c.2806>:
     343:	7c 4f 76 3a 00                                      |Ov:.

00000348 <__c.2804>:
     348:	7c 57 43 4f 3a 00                                   |WCO:.

0000034e <__c.2802>:
     34e:	7c 50 6e 3a 00                                      |Pn:.

00000353 <__c.2797>:
     353:	7c 46 53 3a 00                                      |FS:.

00000358 <__c.2795>:
     358:	7c 4c 6e 3a 00                                      |Ln:.

0000035d <__c.2791>:
     35d:	7c 42 66 3a 00                                      |Bf:.

00000362 <__c.2789>:
     362:	7c 57 50 6f 73 3a 00                                |WPos:.

00000369 <__c.2787>:
     369:	7c 4d 50 6f 73 3a 00                                |MPos:.

00000370 <__c.2781>:
     370:	53 6c 65 65 70 00                                   Sleep.

00000376 <__c.2778>:
     376:	44 6f 6f 72 3a 00                                   Door:.

0000037c <__c.2775>:
     37c:	43 68 65 63 6b 00                                   Check.

00000382 <__c.2772>:
     382:	41 6c 61 72 6d 00                                   Alarm.

00000388 <__c.2769>:
     388:	48 6f 6d 65 00                                      Home.

0000038d <__c.2766>:
     38d:	4a 6f 67 00                                         Jog.

00000391 <__c.2763>:
     391:	48 6f 6c 64 3a 00                                   Hold:.

00000397 <__c.2760>:
     397:	52 75 6e 00                                         Run.

0000039b <__c.2756>:
     39b:	49 64 6c 65 00                                      Idle.

000003a0 <__c.2743>:
     3a0:	5b 4f 50 54 3a 00                                   [OPT:.

000003a6 <__c.2741>:
     3a6:	5b 56 45 52 3a 31 2e 31 67 2e 32 30 31 38 30 38     [VER:1.1g.201808
     3b6:	31 33 2e 4d 65 67 61 3a 00                          13.Mega:.

000003bf <__c.2732>:
     3bf:	24 4e 00                                            $N.

000003c2 <__c.2571>:
     3c2:	20 4d 00                                             M.

000003c5 <__c.2567>:
     3c5:	20 47 00                                             G.

000003c8 <__c.2726>:
     3c8:	20 53 00                                             S.

000003cb <__c.2724>:
     3cb:	20 46 00                                             F.

000003ce <__c.2722>:
     3ce:	20 54 00                                             T.

000003d1 <__c.2712>:
     3d1:	33 38 2e 00                                         38..

000003d5 <__c.2710>:
     3d5:	5b 47 43 3a 47 00                                   [GC:G.

000003db <__c.2706>:
     3db:	5b 54 4c 4f 3a 00                                   [TLO:.

000003e1 <__c.2704>:
     3e1:	5b 47 39 32 3a 00                                   [G92:.

000003e7 <__c.2698>:
     3e7:	33 30 00                                            30.

000003ea <__c.2694>:
     3ea:	32 38 00                                            28.

000003ed <__c.2691>:
     3ed:	5b 47 00                                            [G.

000003f0 <__c.2684>:
     3f0:	5b 50 52 42 3a 00                                   [PRB:.

000003f6 <__c.2664>:
     3f6:	5b 48 4c 50 3a 24 24 20 24 23 20 24 47 20 24 49     [HLP:$$ $# $G $I
     406:	20 24 4e 20 24 78 3d 76 61 6c 20 24 4e 78 3d 6c      $N $x=val $Nx=l
     416:	69 6e 65 20 24 4a 3d 6c 69 6e 65 20 24 53 4c 50     ine $J=line $SLP
     426:	20 24 43 20 24 58 20 24 48 20 7e 20 21 20 3f 20      $C $X $H ~ ! ? 
     436:	63 74 72 6c 2d 78 5d 0d 0a 00                       ctrl-x]...

00000440 <__c.2660>:
     440:	0d 0a 47 72 62 6c 20 31 2e 31 67 20 5b 27 24 27     ..Grbl 1.1g ['$'
     450:	20 66 6f 72 20 68 65 6c 70 5d 0d 0a 00               for help]...

0000045d <__c.2656>:
     45d:	53 6c 65 65 70 69 6e 67 00                          Sleeping.

00000466 <__c.2653>:
     466:	52 65 73 74 6f 72 69 6e 67 20 73 70 69 6e 64 6c     Restoring spindl
     476:	65 00                                               e.

00000478 <__c.2650>:
     478:	52 65 73 74 6f 72 69 6e 67 20 64 65 66 61 75 6c     Restoring defaul
     488:	74 73 00                                            ts.

0000048b <__c.2647>:
     48b:	50 67 6d 20 45 6e 64 00                             Pgm End.

00000493 <__c.2644>:
     493:	43 68 65 63 6b 20 4c 69 6d 69 74 73 00              Check Limits.

000004a0 <__c.2641>:
     4a0:	43 68 65 63 6b 20 44 6f 6f 72 00                    Check Door.

000004ab <__c.2638>:
     4ab:	44 69 73 61 62 6c 65 64 00                          Disabled.

000004b4 <__c.2635>:
     4b4:	45 6e 61 62 6c 65 64 00                             Enabled.

000004bc <__c.2632>:
     4bc:	43 61 75 74 69 6f 6e 3a 20 55 6e 6c 6f 63 6b 65     Caution: Unlocke
     4cc:	64 00                                               d.

000004ce <__c.2629>:
     4ce:	27 24 48 27 7c 27 24 58 27 20 74 6f 20 75 6e 6c     '$H'|'$X' to unl
     4de:	6f 63 6b 00                                         ock.

000004e2 <__c.2625>:
     4e2:	52 65 73 65 74 20 74 6f 20 63 6f 6e 74 69 6e 75     Reset to continu
     4f2:	65 00                                               e.

000004f4 <__c.2622>:
     4f4:	5b 4d 53 47 3a 00                                   [MSG:.

000004fa <__c.2617>:
     4fa:	7c 52 50 4d 3a 20 00                                |RPM: .

00000501 <__c.2612>:
     501:	7c 53 70 3a 20 00                                   |Sp: .

00000507 <__c.2610>:
     507:	7c 53 74 3a 20 00                                   |St: .

0000050d <__c.2608>:
     50d:	7c 53 73 3a 20 00                                   |Ss: .

00000513 <__c.2606>:
     513:	53 69 3a 20 00                                      Si: .

00000518 <__c.2602>:
     518:	41 4c 41 52 4d 3a 00                                ALARM:.

0000051f <__c.2561>:
     51f:	0d 0a 00                                            ...

00000522 <__c.2597>:
     522:	65 72 72 6f 72 3a 00                                error:.

00000529 <__c.2593>:
     529:	6f 6b 0d 0a 00                                      ok...

0000052e <__ctors_end>:
     52e:	11 24       	eor	r1, r1
     530:	1f be       	out	0x3f, r1	; 63
     532:	cf ef       	ldi	r28, 0xFF	; 255
     534:	d1 e2       	ldi	r29, 0x21	; 33
     536:	de bf       	out	0x3e, r29	; 62
     538:	cd bf       	out	0x3d, r28	; 61
     53a:	00 e0       	ldi	r16, 0x00	; 0
     53c:	0c bf       	out	0x3c, r16	; 60

0000053e <__do_clear_bss>:
     53e:	2f e0       	ldi	r18, 0x0F	; 15
     540:	a0 e0       	ldi	r26, 0x00	; 0
     542:	b2 e0       	ldi	r27, 0x02	; 2
     544:	01 c0       	rjmp	.+2      	; 0x548 <.do_clear_bss_start>

00000546 <.do_clear_bss_loop>:
     546:	1d 92       	st	X+, r1

00000548 <.do_clear_bss_start>:
     548:	a7 32       	cpi	r26, 0x27	; 39
     54a:	b2 07       	cpc	r27, r18
     54c:	e1 f7       	brne	.-8      	; 0x546 <.do_clear_bss_loop>
     54e:	5d d0       	rcall	.+186    	; 0x60a <main>
     550:	0c 94 d6 42 	jmp	0x85ac	; 0x85ac <_exit>

00000554 <__bad_interrupt>:
     554:	55 cd       	rjmp	.-1366   	; 0x0 <__vectors>

00000556 <__vector_50>:
#include "timekeeper.h"

uint32_t overflows;

// overflow interrupt for timekeeper - counts timer ticks beyond 16 bits
ISR(TIMER5_OVF_vect) {
     556:	1f 92       	push	r1
     558:	0f 92       	push	r0
     55a:	0f b6       	in	r0, 0x3f	; 63
     55c:	0f 92       	push	r0
     55e:	11 24       	eor	r1, r1
     560:	8f 93       	push	r24
     562:	9f 93       	push	r25
     564:	af 93       	push	r26
     566:	bf 93       	push	r27
	overflows++;
     568:	80 91 10 0c 	lds	r24, 0x0C10	; 0x800c10 <overflows>
     56c:	90 91 11 0c 	lds	r25, 0x0C11	; 0x800c11 <overflows+0x1>
     570:	a0 91 12 0c 	lds	r26, 0x0C12	; 0x800c12 <overflows+0x2>
     574:	b0 91 13 0c 	lds	r27, 0x0C13	; 0x800c13 <overflows+0x3>
     578:	01 96       	adiw	r24, 0x01	; 1
     57a:	a1 1d       	adc	r26, r1
     57c:	b1 1d       	adc	r27, r1
     57e:	80 93 10 0c 	sts	0x0C10, r24	; 0x800c10 <overflows>
     582:	90 93 11 0c 	sts	0x0C11, r25	; 0x800c11 <overflows+0x1>
     586:	a0 93 12 0c 	sts	0x0C12, r26	; 0x800c12 <overflows+0x2>
     58a:	b0 93 13 0c 	sts	0x0C13, r27	; 0x800c13 <overflows+0x3>
}
     58e:	bf 91       	pop	r27
     590:	af 91       	pop	r26
     592:	9f 91       	pop	r25
     594:	8f 91       	pop	r24
     596:	0f 90       	pop	r0
     598:	0f be       	out	0x3f, r0	; 63
     59a:	0f 90       	pop	r0
     59c:	1f 90       	pop	r1
     59e:	18 95       	reti

000005a0 <timekeeper_reset>:
  timekeeper_reset();
}

void timekeeper_reset()
{
  overflows = 0;
     5a0:	10 92 10 0c 	sts	0x0C10, r1	; 0x800c10 <overflows>
     5a4:	10 92 11 0c 	sts	0x0C11, r1	; 0x800c11 <overflows+0x1>
     5a8:	10 92 12 0c 	sts	0x0C12, r1	; 0x800c12 <overflows+0x2>
     5ac:	10 92 13 0c 	sts	0x0C13, r1	; 0x800c13 <overflows+0x3>
  TCNT5=0;		
     5b0:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <__TEXT_REGION_LENGTH__+0x700125>
     5b4:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
     5b8:	08 95       	ret

000005ba <timekeeper_init>:

void timekeeper_init() {
  // Configure Timer 5: system timer interrupt
  //TCCR5B &= ~(1<<WGM13); // waveform generation = 0100 = CTC
  //TCCR5B |=  (1<<WGM12);
  TCCR5A =0; // timer outputs disconnected, no waveform generation.
     5ba:	e0 e2       	ldi	r30, 0x20	; 32
     5bc:	f1 e0       	ldi	r31, 0x01	; 1
     5be:	10 82       	st	Z, r1
  TCCR5A &= ~((1<<COM5A1) | (1<<COM5A0) | (1<<COM5B1) | (1<<COM5B0)); // Disconnect OC1 output
     5c0:	80 81       	ld	r24, Z
     5c2:	8f 70       	andi	r24, 0x0F	; 15
     5c4:	80 83       	st	Z, r24
  TCCR5B |=  (1<<CS11) | (1<<CS10); // pre-scaler: 1/64 (4 microseconds per tick @ 16MHz)
     5c6:	e1 e2       	ldi	r30, 0x21	; 33
     5c8:	f1 e0       	ldi	r31, 0x01	; 1
     5ca:	80 81       	ld	r24, Z
     5cc:	83 60       	ori	r24, 0x03	; 3
     5ce:	80 83       	st	Z, r24
  TIMSK5 |=  (1<<TOIE5); // enable overflow interrupt  
     5d0:	e3 e7       	ldi	r30, 0x73	; 115
     5d2:	f0 e0       	ldi	r31, 0x00	; 0
     5d4:	80 81       	ld	r24, Z
     5d6:	81 60       	ori	r24, 0x01	; 1
     5d8:	80 83       	st	Z, r24
  timekeeper_reset();
     5da:	e2 cf       	rjmp	.-60     	; 0x5a0 <timekeeper_reset>
     5dc:	08 95       	ret

000005de <get_timer_ticks>:
	// each timer tick are 4 microseconds
	return (get_timer_ticks()/(uint32_t)250);
}

uint32_t get_timer_ticks(){
	uint32_t ticks = TCNT5;
     5de:	20 91 24 01 	lds	r18, 0x0124	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
     5e2:	30 91 25 01 	lds	r19, 0x0125	; 0x800125 <__TEXT_REGION_LENGTH__+0x700125>
	return ticks+((overflows)<<16) ;
     5e6:	80 91 10 0c 	lds	r24, 0x0C10	; 0x800c10 <overflows>
     5ea:	90 91 11 0c 	lds	r25, 0x0C11	; 0x800c11 <overflows+0x1>
     5ee:	a0 91 12 0c 	lds	r26, 0x0C12	; 0x800c12 <overflows+0x2>
     5f2:	b0 91 13 0c 	lds	r27, 0x0C13	; 0x800c13 <overflows+0x3>
     5f6:	dc 01       	movw	r26, r24
     5f8:	99 27       	eor	r25, r25
     5fa:	88 27       	eor	r24, r24
     5fc:	bc 01       	movw	r22, r24
     5fe:	cd 01       	movw	r24, r26
     600:	62 0f       	add	r22, r18
     602:	73 1f       	adc	r23, r19
     604:	81 1d       	adc	r24, r1
     606:	91 1d       	adc	r25, r1
}
     608:	08 95       	ret

0000060a <main>:


int main(void)
{
  // Initialize system upon power-up.
  serial_init();   // Setup serial baud rate and interrupts
     60a:	0e 94 e7 13 	call	0x27ce	; 0x27ce <serial_init>
  settings_init(); // Load Grbl settings from EEPROM
     60e:	0e 94 9c 27 	call	0x4f38	; 0x4f38 <settings_init>
  stepper_init();  // Configure stepper pins and interrupt timers
     612:	0e 94 e0 1b 	call	0x37c0	; 0x37c0 <stepper_init>
  system_init();   // Configure pinout pins and pin-change interrupt
     616:	0e 94 5a 3a 	call	0x74b4	; 0x74b4 <system_init>

  memset(sys_position,0,sizeof(sys_position)); // Clear machine position.
     61a:	8c e0       	ldi	r24, 0x0C	; 12
     61c:	e3 e4       	ldi	r30, 0x43	; 67
     61e:	fc e0       	ldi	r31, 0x0C	; 12
     620:	df 01       	movw	r26, r30
     622:	1d 92       	st	X+, r1
     624:	8a 95       	dec	r24
     626:	e9 f7       	brne	.-6      	; 0x622 <main+0x18>
  sei(); // Enable interrupts
     628:	78 94       	sei
  // Initialize system state.
  #ifdef FORCE_INITIALIZATION_ALARM
    // Force Grbl into an ALARM state upon a power-cycle or hard reset.
    sys.state = STATE_ALARM;
  #else
    sys.state = STATE_IDLE;
     62a:	10 92 1e 0c 	sts	0x0C1E, r1	; 0x800c1e <sys>
  // Grbl initialization loop upon power-up or a system abort. For the latter, all processes
  // will return to this loop to be cleanly re-initialized.
  for(;;) {

    // Reset system variables.
    uint8_t prior_state = sys.state;
     62e:	ce e1       	ldi	r28, 0x1E	; 30
     630:	dc e0       	ldi	r29, 0x0C	; 12
    memset(&sys, 0, sizeof(system_t)); // Clear system struct variable.
     632:	0f 2e       	mov	r0, r31
     634:	f2 e1       	ldi	r31, 0x12	; 18
     636:	df 2e       	mov	r13, r31
     638:	f0 2d       	mov	r31, r0
    sys.state = prior_state;
    sys.f_override = DEFAULT_FEED_OVERRIDE;  // Set to 100%
     63a:	14 e6       	ldi	r17, 0x64	; 100
    sys.r_override = DEFAULT_RAPID_OVERRIDE; // Set to 100%
    sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE; // Set to 100%
		memset(sys_probe_position,0,sizeof(sys_probe_position)); // Clear probe position.
     63c:	0f 2e       	mov	r0, r31
     63e:	f7 e3       	ldi	r31, 0x37	; 55
     640:	ef 2e       	mov	r14, r31
     642:	fc e0       	ldi	r31, 0x0C	; 12
     644:	ff 2e       	mov	r15, r31
     646:	f0 2d       	mov	r31, r0
     648:	0c e0       	ldi	r16, 0x0C	; 12
  // Grbl initialization loop upon power-up or a system abort. For the latter, all processes
  // will return to this loop to be cleanly re-initialized.
  for(;;) {

    // Reset system variables.
    uint8_t prior_state = sys.state;
     64a:	88 81       	ld	r24, Y
    memset(&sys, 0, sizeof(system_t)); // Clear system struct variable.
     64c:	fe 01       	movw	r30, r28
     64e:	9d 2d       	mov	r25, r13
     650:	11 92       	st	Z+, r1
     652:	9a 95       	dec	r25
     654:	e9 f7       	brne	.-6      	; 0x650 <main+0x46>
    sys.state = prior_state;
     656:	88 83       	st	Y, r24
    sys.f_override = DEFAULT_FEED_OVERRIDE;  // Set to 100%
     658:	1f 83       	std	Y+7, r17	; 0x07
    sys.r_override = DEFAULT_RAPID_OVERRIDE; // Set to 100%
     65a:	18 87       	std	Y+8, r17	; 0x08
    sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE; // Set to 100%
     65c:	19 87       	std	Y+9, r17	; 0x09
		memset(sys_probe_position,0,sizeof(sys_probe_position)); // Clear probe position.
     65e:	d7 01       	movw	r26, r14
     660:	e0 2f       	mov	r30, r16
     662:	1d 92       	st	X+, r1
     664:	ea 95       	dec	r30
     666:	e9 f7       	brne	.-6      	; 0x662 <main+0x58>
    sys_probe_state = 0;
     668:	10 92 32 0c 	sts	0x0C32, r1	; 0x800c32 <sys_probe_state>
    sys_rt_exec_state = 0;
     66c:	10 92 31 0c 	sts	0x0C31, r1	; 0x800c31 <sys_rt_exec_state>
    sys_rt_exec_alarm = 0;
     670:	10 92 53 0c 	sts	0x0C53, r1	; 0x800c53 <sys_rt_exec_alarm>
    sys_rt_exec_motion_override = 0;
     674:	10 92 19 0c 	sts	0x0C19, r1	; 0x800c19 <sys_rt_exec_motion_override>
    sys_rt_exec_accessory_override = 0;
     678:	10 92 30 0c 	sts	0x0C30, r1	; 0x800c30 <sys_rt_exec_accessory_override>
	
	sys_index_pulse_count=0;
     67c:	10 92 55 0c 	sts	0x0C55, r1	; 0x800c55 <sys_index_pulse_count>
	sys_synchronization_pulse_count=0;
     680:	10 92 15 0c 	sts	0x0C15, r1	; 0x800c15 <sys_synchronization_pulse_count>
     684:	10 92 16 0c 	sts	0x0C16, r1	; 0x800c16 <sys_synchronization_pulse_count+0x1>
     688:	10 92 17 0c 	sts	0x0C17, r1	; 0x800c17 <sys_synchronization_pulse_count+0x2>
     68c:	10 92 18 0c 	sts	0x0C18, r1	; 0x800c18 <sys_synchronization_pulse_count+0x3>

    // Reset Grbl primary systems.
    serial_reset_read_buffer(); // Clear serial read buffer
     690:	0e 94 03 15 	call	0x2a06	; 0x2a06 <serial_reset_read_buffer>
    gc_init(); // Set g-code parser to default state
     694:	03 d4       	rcall	.+2054   	; 0xe9c <gc_init>
    spindle_init();
     696:	0e 94 62 12 	call	0x24c4	; 0x24c4 <spindle_init>
	timekeeper_init();
     69a:	8f df       	rcall	.-226    	; 0x5ba <timekeeper_init>
    coolant_init();
     69c:	0e 94 a4 13 	call	0x2748	; 0x2748 <coolant_init>
    limits_init();
     6a0:	0e 94 1a 30 	call	0x6034	; 0x6034 <limits_init>
    probe_init();
     6a4:	0e 94 c3 34 	call	0x6986	; 0x6986 <probe_init>
    sleep_init();
     6a8:	0e 94 27 3e 	call	0x7c4e	; 0x7c4e <sleep_init>
    plan_reset(); // Clear block buffer and planner variables
     6ac:	0e 94 35 29 	call	0x526a	; 0x526a <plan_reset>
    st_reset(); // Clear stepper subsystem variables.
     6b0:	0e 94 af 1b 	call	0x375e	; 0x375e <st_reset>

    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
     6b4:	0e 94 dd 2d 	call	0x5bba	; 0x5bba <plan_sync_position>
    gc_sync_position();
     6b8:	03 d4       	rcall	.+2054   	; 0xec0 <gc_sync_position>

    // Print welcome message. Indicates an initialization has occured at power-up or with a reset.
    report_init_message();
     6ba:	0e 94 eb 35 	call	0x6bd6	; 0x6bd6 <report_init_message>

    // Start Grbl main loop. Processes program inputs and executes them.
    protocol_main_loop();
     6be:	0e 94 4f 18 	call	0x309e	; 0x309e <protocol_main_loop>
     6c2:	c3 cf       	rjmp	.-122    	; 0x64a <main+0x40>

000006c4 <mc_line>:
// NOTE: This is the primary gateway to the grbl planner. All line motions, including arc line
// segments, must pass through this routine before being passed to the planner. The seperation of
// mc_line and plan_buffer_line is done primarily to place non-planner-type functions from being
// in the planner and to let backlash compensation or canned cycle integration simple and direct.
void mc_line(float *target, plan_line_data_t *pl_data)
{
     6c4:	ef 92       	push	r14
     6c6:	ff 92       	push	r15
     6c8:	0f 93       	push	r16
     6ca:	1f 93       	push	r17
     6cc:	cf 93       	push	r28
     6ce:	df 93       	push	r29
     6d0:	8c 01       	movw	r16, r24
     6d2:	7b 01       	movw	r14, r22
  // If enabled, check for soft limit violations. Placed here all line motions are picked up
  // from everywhere in Grbl.
  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
     6d4:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
     6d8:	85 ff       	sbrs	r24, 5
     6da:	07 c0       	rjmp	.+14     	; 0x6ea <mc_line+0x26>
    // NOTE: Block jog state. Jogging is a special case and soft limits are handled independently.
    if (sys.state != STATE_JOG) { limits_soft_check(target); }
     6dc:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
     6e0:	80 32       	cpi	r24, 0x20	; 32
     6e2:	39 f0       	breq	.+14     	; 0x6f2 <mc_line+0x2e>
     6e4:	c8 01       	movw	r24, r16
     6e6:	0e 94 ee 32 	call	0x65dc	; 0x65dc <limits_soft_check>
  }

  // If in check gcode mode, prevent motion by blocking planner. Soft limits still work.
  if (sys.state == STATE_CHECK_MODE) { return; }
     6ea:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
     6ee:	82 30       	cpi	r24, 0x02	; 2
     6f0:	19 f1       	breq	.+70     	; 0x738 <mc_line+0x74>

  // If the buffer is full: good! That means we are well ahead of the robot.
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
    if (sys.abort) { return; } // Bail, if system abort.
     6f2:	ce e1       	ldi	r28, 0x1E	; 30
     6f4:	dc e0       	ldi	r29, 0x0C	; 12
  // parser and planner are separate from the system machine positions, this is doable.

  // If the buffer is full: good! That means we are well ahead of the robot.
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
     6f6:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail, if system abort.
     6fa:	89 81       	ldd	r24, Y+1	; 0x01
     6fc:	81 11       	cpse	r24, r1
     6fe:	1c c0       	rjmp	.+56     	; 0x738 <mc_line+0x74>
    if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffer is full.
     700:	0e 94 84 29 	call	0x5308	; 0x5308 <plan_check_full_buffer>
     704:	88 23       	and	r24, r24
     706:	19 f0       	breq	.+6      	; 0x70e <mc_line+0x4a>
     708:	0e 94 08 15 	call	0x2a10	; 0x2a10 <protocol_auto_cycle_start>
    else { break; }
  } while (1);
     70c:	f4 cf       	rjmp	.-24     	; 0x6f6 <mc_line+0x32>

  // Plan and queue motion into planner buffer
  if (plan_buffer_line(target, pl_data) == PLAN_EMPTY_BLOCK) {
     70e:	b7 01       	movw	r22, r14
     710:	c8 01       	movw	r24, r16
     712:	0e 94 c2 2a 	call	0x5584	; 0x5584 <plan_buffer_line>
     716:	81 11       	cpse	r24, r1
     718:	0f c0       	rjmp	.+30     	; 0x738 <mc_line+0x74>
    if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
     71a:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
     71e:	81 ff       	sbrs	r24, 1
     720:	0b c0       	rjmp	.+22     	; 0x738 <mc_line+0x74>
      // Correctly set spindle state, if there is a coincident position passed. Forces a buffer
      // sync while in M3 laser mode only.
      if (pl_data->condition & PL_COND_FLAG_SPINDLE_CW) {
     722:	f7 01       	movw	r30, r14
     724:	84 85       	ldd	r24, Z+12	; 0x0c
     726:	84 ff       	sbrs	r24, 4
     728:	07 c0       	rjmp	.+14     	; 0x738 <mc_line+0x74>
        spindle_sync(PL_COND_FLAG_SPINDLE_CW, pl_data->spindle_speed);
     72a:	44 81       	ldd	r20, Z+4	; 0x04
     72c:	55 81       	ldd	r21, Z+5	; 0x05
     72e:	66 81       	ldd	r22, Z+6	; 0x06
     730:	77 81       	ldd	r23, Z+7	; 0x07
     732:	80 e1       	ldi	r24, 0x10	; 16
     734:	0e 94 78 13 	call	0x26f0	; 0x26f0 <spindle_sync>
      }
    }
  }
}
     738:	df 91       	pop	r29
     73a:	cf 91       	pop	r28
     73c:	1f 91       	pop	r17
     73e:	0f 91       	pop	r16
     740:	ff 90       	pop	r15
     742:	ef 90       	pop	r14
     744:	08 95       	ret

00000746 <mc_arc>:
// The arc is approximated by generating a huge number of tiny, linear segments. The chordal tolerance
// of each segment is configured in settings.arc_tolerance, which is defined to be the maximum normal
// distance from segment to the circle when the end points both lie on the circle.
void mc_arc(float *target, plan_line_data_t *pl_data, float *position, float *offset, float radius,
  uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc)
{
     746:	2f 92       	push	r2
     748:	3f 92       	push	r3
     74a:	4f 92       	push	r4
     74c:	5f 92       	push	r5
     74e:	6f 92       	push	r6
     750:	7f 92       	push	r7
     752:	8f 92       	push	r8
     754:	9f 92       	push	r9
     756:	af 92       	push	r10
     758:	bf 92       	push	r11
     75a:	cf 92       	push	r12
     75c:	df 92       	push	r13
     75e:	ef 92       	push	r14
     760:	ff 92       	push	r15
     762:	0f 93       	push	r16
     764:	1f 93       	push	r17
     766:	cf 93       	push	r28
     768:	df 93       	push	r29
     76a:	cd b7       	in	r28, 0x3d	; 61
     76c:	de b7       	in	r29, 0x3e	; 62
     76e:	e2 97       	sbiw	r28, 0x32	; 50
     770:	0f b6       	in	r0, 0x3f	; 63
     772:	f8 94       	cli
     774:	de bf       	out	0x3e, r29	; 62
     776:	0f be       	out	0x3f, r0	; 63
     778:	cd bf       	out	0x3d, r28	; 61
     77a:	9a ab       	std	Y+50, r25	; 0x32
     77c:	89 ab       	std	Y+49, r24	; 0x31
     77e:	78 8b       	std	Y+16, r23	; 0x10
     780:	6f 87       	std	Y+15, r22	; 0x0f
     782:	5e 87       	std	Y+14, r21	; 0x0e
     784:	4d 87       	std	Y+13, r20	; 0x0d
     786:	39 01       	movw	r6, r18
     788:	ed 82       	std	Y+5, r14	; 0x05
     78a:	fe 82       	std	Y+6, r15	; 0x06
     78c:	0f 83       	std	Y+7, r16	; 0x07
     78e:	18 87       	std	Y+8, r17	; 0x08
     790:	89 8a       	std	Y+17, r8	; 0x11
  float center_axis0 = position[axis_0] + offset[axis_0];
     792:	d1 2c       	mov	r13, r1
     794:	cc 0c       	add	r12, r12
     796:	dd 1c       	adc	r13, r13
     798:	cc 0c       	add	r12, r12
     79a:	dd 1c       	adc	r13, r13
     79c:	ca 01       	movw	r24, r20
     79e:	8c 0d       	add	r24, r12
     7a0:	9d 1d       	adc	r25, r13
     7a2:	9e 8b       	std	Y+22, r25	; 0x16
     7a4:	8d 8b       	std	Y+21, r24	; 0x15
     7a6:	d9 01       	movw	r26, r18
     7a8:	ac 0d       	add	r26, r12
     7aa:	bd 1d       	adc	r27, r13
     7ac:	be a7       	std	Y+46, r27	; 0x2e
     7ae:	ad a7       	std	Y+45, r26	; 0x2d
     7b0:	2d 90       	ld	r2, X+
     7b2:	3d 90       	ld	r3, X+
     7b4:	4d 90       	ld	r4, X+
     7b6:	5c 90       	ld	r5, X
     7b8:	fc 01       	movw	r30, r24
     7ba:	20 81       	ld	r18, Z
     7bc:	31 81       	ldd	r19, Z+1	; 0x01
     7be:	42 81       	ldd	r20, Z+2	; 0x02
     7c0:	53 81       	ldd	r21, Z+3	; 0x03
     7c2:	c2 01       	movw	r24, r4
     7c4:	b1 01       	movw	r22, r2
     7c6:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
     7ca:	6f 8b       	std	Y+23, r22	; 0x17
     7cc:	78 8f       	std	Y+24, r23	; 0x18
     7ce:	89 8f       	std	Y+25, r24	; 0x19
     7d0:	9a 8f       	std	Y+26, r25	; 0x1a
  float center_axis1 = position[axis_1] + offset[axis_1];
     7d2:	0a 2d       	mov	r16, r10
     7d4:	10 e0       	ldi	r17, 0x00	; 0
     7d6:	00 0f       	add	r16, r16
     7d8:	11 1f       	adc	r17, r17
     7da:	00 0f       	add	r16, r16
     7dc:	11 1f       	adc	r17, r17
     7de:	8d 85       	ldd	r24, Y+13	; 0x0d
     7e0:	9e 85       	ldd	r25, Y+14	; 0x0e
     7e2:	80 0f       	add	r24, r16
     7e4:	91 1f       	adc	r25, r17
     7e6:	9c 8f       	std	Y+28, r25	; 0x1c
     7e8:	8b 8f       	std	Y+27, r24	; 0x1b
     7ea:	d3 01       	movw	r26, r6
     7ec:	a0 0f       	add	r26, r16
     7ee:	b1 1f       	adc	r27, r17
     7f0:	b8 ab       	std	Y+48, r27	; 0x30
     7f2:	af a7       	std	Y+47, r26	; 0x2f
     7f4:	8d 90       	ld	r8, X+
     7f6:	9d 90       	ld	r9, X+
     7f8:	ad 90       	ld	r10, X+
     7fa:	bc 90       	ld	r11, X
     7fc:	fc 01       	movw	r30, r24
     7fe:	20 81       	ld	r18, Z
     800:	31 81       	ldd	r19, Z+1	; 0x01
     802:	42 81       	ldd	r20, Z+2	; 0x02
     804:	53 81       	ldd	r21, Z+3	; 0x03
     806:	c5 01       	movw	r24, r10
     808:	b4 01       	movw	r22, r8
     80a:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
     80e:	6d 8f       	std	Y+29, r22	; 0x1d
     810:	7e 8f       	std	Y+30, r23	; 0x1e
     812:	8f 8f       	std	Y+31, r24	; 0x1f
     814:	98 a3       	std	Y+32, r25	; 0x20
  float r_axis0 = -offset[axis_0];  // Radius vector from center to current location
     816:	d2 01       	movw	r26, r4
     818:	c1 01       	movw	r24, r2
     81a:	b0 58       	subi	r27, 0x80	; 128
     81c:	89 83       	std	Y+1, r24	; 0x01
     81e:	9a 83       	std	Y+2, r25	; 0x02
     820:	ab 83       	std	Y+3, r26	; 0x03
     822:	bc 83       	std	Y+4, r27	; 0x04
  float r_axis1 = -offset[axis_1];
     824:	d5 01       	movw	r26, r10
     826:	c4 01       	movw	r24, r8
     828:	b0 58       	subi	r27, 0x80	; 128
     82a:	89 87       	std	Y+9, r24	; 0x09
     82c:	9a 87       	std	Y+10, r25	; 0x0a
     82e:	ab 87       	std	Y+11, r26	; 0x0b
     830:	bc 87       	std	Y+12, r27	; 0x0c
  float rt_axis0 = target[axis_0] - center_axis0;
     832:	e9 a9       	ldd	r30, Y+49	; 0x31
     834:	fa a9       	ldd	r31, Y+50	; 0x32
     836:	ec 0d       	add	r30, r12
     838:	fd 1d       	adc	r31, r13
     83a:	2f 89       	ldd	r18, Y+23	; 0x17
     83c:	38 8d       	ldd	r19, Y+24	; 0x18
     83e:	49 8d       	ldd	r20, Y+25	; 0x19
     840:	5a 8d       	ldd	r21, Y+26	; 0x1a
     842:	60 81       	ld	r22, Z
     844:	71 81       	ldd	r23, Z+1	; 0x01
     846:	82 81       	ldd	r24, Z+2	; 0x02
     848:	93 81       	ldd	r25, Z+3	; 0x03
     84a:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
     84e:	6b 01       	movw	r12, r22
     850:	7c 01       	movw	r14, r24
  float rt_axis1 = target[axis_1] - center_axis1;
     852:	e9 a9       	ldd	r30, Y+49	; 0x31
     854:	fa a9       	ldd	r31, Y+50	; 0x32
     856:	e0 0f       	add	r30, r16
     858:	f1 1f       	adc	r31, r17
     85a:	2d 8d       	ldd	r18, Y+29	; 0x1d
     85c:	3e 8d       	ldd	r19, Y+30	; 0x1e
     85e:	4f 8d       	ldd	r20, Y+31	; 0x1f
     860:	58 a1       	ldd	r21, Y+32	; 0x20
     862:	60 81       	ld	r22, Z
     864:	71 81       	ldd	r23, Z+1	; 0x01
     866:	82 81       	ldd	r24, Z+2	; 0x02
     868:	93 81       	ldd	r25, Z+3	; 0x03
     86a:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
     86e:	4b 01       	movw	r8, r22
     870:	5c 01       	movw	r10, r24

  // CCW angle between position and target from circle center. Only one atan2() trig computation required.
  float angular_travel = atan2(r_axis0*rt_axis1-r_axis1*rt_axis0, r_axis0*rt_axis0+r_axis1*rt_axis1);
     872:	a7 01       	movw	r20, r14
     874:	96 01       	movw	r18, r12
     876:	69 81       	ldd	r22, Y+1	; 0x01
     878:	7a 81       	ldd	r23, Y+2	; 0x02
     87a:	8b 81       	ldd	r24, Y+3	; 0x03
     87c:	9c 81       	ldd	r25, Y+4	; 0x04
     87e:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     882:	2b 01       	movw	r4, r22
     884:	3c 01       	movw	r6, r24
     886:	a5 01       	movw	r20, r10
     888:	94 01       	movw	r18, r8
     88a:	69 85       	ldd	r22, Y+9	; 0x09
     88c:	7a 85       	ldd	r23, Y+10	; 0x0a
     88e:	8b 85       	ldd	r24, Y+11	; 0x0b
     890:	9c 85       	ldd	r25, Y+12	; 0x0c
     892:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     896:	9b 01       	movw	r18, r22
     898:	ac 01       	movw	r20, r24
     89a:	c3 01       	movw	r24, r6
     89c:	b2 01       	movw	r22, r4
     89e:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
     8a2:	2b 01       	movw	r4, r22
     8a4:	3c 01       	movw	r6, r24
     8a6:	a5 01       	movw	r20, r10
     8a8:	94 01       	movw	r18, r8
     8aa:	69 81       	ldd	r22, Y+1	; 0x01
     8ac:	7a 81       	ldd	r23, Y+2	; 0x02
     8ae:	8b 81       	ldd	r24, Y+3	; 0x03
     8b0:	9c 81       	ldd	r25, Y+4	; 0x04
     8b2:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     8b6:	4b 01       	movw	r8, r22
     8b8:	5c 01       	movw	r10, r24
     8ba:	a7 01       	movw	r20, r14
     8bc:	96 01       	movw	r18, r12
     8be:	69 85       	ldd	r22, Y+9	; 0x09
     8c0:	7a 85       	ldd	r23, Y+10	; 0x0a
     8c2:	8b 85       	ldd	r24, Y+11	; 0x0b
     8c4:	9c 85       	ldd	r25, Y+12	; 0x0c
     8c6:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     8ca:	9b 01       	movw	r18, r22
     8cc:	ac 01       	movw	r20, r24
     8ce:	c5 01       	movw	r24, r10
     8d0:	b4 01       	movw	r22, r8
     8d2:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
     8d6:	a3 01       	movw	r20, r6
     8d8:	92 01       	movw	r18, r4
     8da:	0e 94 ff 3e 	call	0x7dfe	; 0x7dfe <atan2>
     8de:	4b 01       	movw	r8, r22
     8e0:	5c 01       	movw	r10, r24
  if (is_clockwise_arc) { // Correct atan2 output per direction
     8e2:	29 96       	adiw	r28, 0x09	; 9
     8e4:	8f ad       	ldd	r24, Y+63	; 0x3f
     8e6:	29 97       	sbiw	r28, 0x09	; 9
     8e8:	88 23       	and	r24, r24
     8ea:	a9 f0       	breq	.+42     	; 0x916 <mc_arc+0x1d0>
    if (angular_travel >= -ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel -= 2*M_PI; }
     8ec:	2d eb       	ldi	r18, 0xBD	; 189
     8ee:	37 e3       	ldi	r19, 0x37	; 55
     8f0:	46 e0       	ldi	r20, 0x06	; 6
     8f2:	55 eb       	ldi	r21, 0xB5	; 181
     8f4:	c5 01       	movw	r24, r10
     8f6:	b4 01       	movw	r22, r8
     8f8:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
     8fc:	88 23       	and	r24, r24
     8fe:	fc f0       	brlt	.+62     	; 0x93e <mc_arc+0x1f8>
     900:	2b ed       	ldi	r18, 0xDB	; 219
     902:	3f e0       	ldi	r19, 0x0F	; 15
     904:	49 ec       	ldi	r20, 0xC9	; 201
     906:	50 e4       	ldi	r21, 0x40	; 64
     908:	c5 01       	movw	r24, r10
     90a:	b4 01       	movw	r22, r8
     90c:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
     910:	4b 01       	movw	r8, r22
     912:	5c 01       	movw	r10, r24
     914:	14 c0       	rjmp	.+40     	; 0x93e <mc_arc+0x1f8>
  } else {
    if (angular_travel <= ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel += 2*M_PI; }
     916:	2d eb       	ldi	r18, 0xBD	; 189
     918:	37 e3       	ldi	r19, 0x37	; 55
     91a:	46 e0       	ldi	r20, 0x06	; 6
     91c:	55 e3       	ldi	r21, 0x35	; 53
     91e:	c5 01       	movw	r24, r10
     920:	b4 01       	movw	r22, r8
     922:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
     926:	18 16       	cp	r1, r24
     928:	54 f0       	brlt	.+20     	; 0x93e <mc_arc+0x1f8>
     92a:	2b ed       	ldi	r18, 0xDB	; 219
     92c:	3f e0       	ldi	r19, 0x0F	; 15
     92e:	49 ec       	ldi	r20, 0xC9	; 201
     930:	50 e4       	ldi	r21, 0x40	; 64
     932:	c5 01       	movw	r24, r10
     934:	b4 01       	movw	r22, r8
     936:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
     93a:	4b 01       	movw	r8, r22
     93c:	5c 01       	movw	r10, r24
  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
     93e:	c0 90 09 0f 	lds	r12, 0x0F09	; 0x800f09 <settings+0x39>
     942:	d0 90 0a 0f 	lds	r13, 0x0F0A	; 0x800f0a <settings+0x3a>
     946:	e0 90 0b 0f 	lds	r14, 0x0F0B	; 0x800f0b <settings+0x3b>
     94a:	f0 90 0c 0f 	lds	r15, 0x0F0C	; 0x800f0c <settings+0x3c>
     94e:	2d 81       	ldd	r18, Y+5	; 0x05
     950:	3e 81       	ldd	r19, Y+6	; 0x06
     952:	4f 81       	ldd	r20, Y+7	; 0x07
     954:	58 85       	ldd	r21, Y+8	; 0x08
     956:	ca 01       	movw	r24, r20
     958:	b9 01       	movw	r22, r18
     95a:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
     95e:	2b 01       	movw	r4, r22
     960:	3c 01       	movw	r6, r24
     962:	a7 01       	movw	r20, r14
     964:	96 01       	movw	r18, r12
     966:	c3 01       	movw	r24, r6
     968:	b2 01       	movw	r22, r4
     96a:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
     96e:	a7 01       	movw	r20, r14
     970:	96 01       	movw	r18, r12
     972:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     976:	0e 94 30 42 	call	0x8460	; 0x8460 <sqrt>
     97a:	6b 01       	movw	r12, r22
     97c:	7c 01       	movw	r14, r24

  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
     97e:	20 e0       	ldi	r18, 0x00	; 0
     980:	30 e0       	ldi	r19, 0x00	; 0
     982:	40 e0       	ldi	r20, 0x00	; 0
     984:	5f e3       	ldi	r21, 0x3F	; 63
     986:	c5 01       	movw	r24, r10
     988:	b4 01       	movw	r22, r8
     98a:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     98e:	2d 81       	ldd	r18, Y+5	; 0x05
     990:	3e 81       	ldd	r19, Y+6	; 0x06
     992:	4f 81       	ldd	r20, Y+7	; 0x07
     994:	58 85       	ldd	r21, Y+8	; 0x08
     996:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     99a:	9f 77       	andi	r25, 0x7F	; 127
     99c:	a7 01       	movw	r20, r14
     99e:	96 01       	movw	r18, r12
     9a0:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__divsf3>
     9a4:	0e 94 42 40 	call	0x8084	; 0x8084 <floor>
     9a8:	0e 94 d9 3f 	call	0x7fb2	; 0x7fb2 <__fixunssfsi>
     9ac:	6b 01       	movw	r12, r22
     9ae:	7c 01       	movw	r14, r24
     9b0:	3b 01       	movw	r6, r22
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );

  if (segments) {
     9b2:	61 15       	cp	r22, r1
     9b4:	71 05       	cpc	r23, r1
     9b6:	09 f4       	brne	.+2      	; 0x9ba <mc_arc+0x274>
     9b8:	87 c1       	rjmp	.+782    	; 0xcc8 <mc_arc+0x582>
    // Multiply inverse feed_rate to compensate for the fact that this movement is approximated
    // by a number of discrete segments. The inverse feed_rate should be correct for the sum of
    // all segments.
    if (pl_data->condition & PL_COND_FLAG_INVERSE_TIME) { 
     9ba:	af 85       	ldd	r26, Y+15	; 0x0f
     9bc:	b8 89       	ldd	r27, Y+16	; 0x10
     9be:	1c 96       	adiw	r26, 0x0c	; 12
     9c0:	1c 91       	ld	r17, X
     9c2:	13 ff       	sbrs	r17, 3
     9c4:	18 c0       	rjmp	.+48     	; 0x9f6 <mc_arc+0x2b0>
      pl_data->feed_rate *= segments; 
     9c6:	80 e0       	ldi	r24, 0x00	; 0
     9c8:	90 e0       	ldi	r25, 0x00	; 0
     9ca:	0e 94 05 40 	call	0x800a	; 0x800a <__floatunsisf>
     9ce:	9b 01       	movw	r18, r22
     9d0:	ac 01       	movw	r20, r24
     9d2:	ef 85       	ldd	r30, Y+15	; 0x0f
     9d4:	f8 89       	ldd	r31, Y+16	; 0x10
     9d6:	60 81       	ld	r22, Z
     9d8:	71 81       	ldd	r23, Z+1	; 0x01
     9da:	82 81       	ldd	r24, Z+2	; 0x02
     9dc:	93 81       	ldd	r25, Z+3	; 0x03
     9de:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     9e2:	af 85       	ldd	r26, Y+15	; 0x0f
     9e4:	b8 89       	ldd	r27, Y+16	; 0x10
     9e6:	6d 93       	st	X+, r22
     9e8:	7d 93       	st	X+, r23
     9ea:	8d 93       	st	X+, r24
     9ec:	9c 93       	st	X, r25
     9ee:	13 97       	sbiw	r26, 0x03	; 3
      bit_false(pl_data->condition,PL_COND_FLAG_INVERSE_TIME); // Force as feed absolute mode over arc segments.
     9f0:	17 7f       	andi	r17, 0xF7	; 247
     9f2:	1c 96       	adiw	r26, 0x0c	; 12
     9f4:	1c 93       	st	X, r17
    }
    
    float theta_per_segment = angular_travel/segments;
     9f6:	b6 01       	movw	r22, r12
     9f8:	80 e0       	ldi	r24, 0x00	; 0
     9fa:	90 e0       	ldi	r25, 0x00	; 0
     9fc:	0e 94 05 40 	call	0x800a	; 0x800a <__floatunsisf>
     a00:	6b 01       	movw	r12, r22
     a02:	7c 01       	movw	r14, r24
     a04:	9b 01       	movw	r18, r22
     a06:	ac 01       	movw	r20, r24
     a08:	c5 01       	movw	r24, r10
     a0a:	b4 01       	movw	r22, r8
     a0c:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__divsf3>
     a10:	69 a7       	std	Y+41, r22	; 0x29
     a12:	7a a7       	std	Y+42, r23	; 0x2a
     a14:	8b a7       	std	Y+43, r24	; 0x2b
     a16:	9c a7       	std	Y+44, r25	; 0x2c
    float linear_per_segment = (target[axis_linear] - position[axis_linear])/segments;
     a18:	b9 89       	ldd	r27, Y+17	; 0x11
     a1a:	8b 2e       	mov	r8, r27
     a1c:	91 2c       	mov	r9, r1
     a1e:	88 0c       	add	r8, r8
     a20:	99 1c       	adc	r9, r9
     a22:	88 0c       	add	r8, r8
     a24:	99 1c       	adc	r9, r9
     a26:	4d 84       	ldd	r4, Y+13	; 0x0d
     a28:	5e 84       	ldd	r5, Y+14	; 0x0e
     a2a:	48 0c       	add	r4, r8
     a2c:	59 1c       	adc	r5, r9
     a2e:	e9 a9       	ldd	r30, Y+49	; 0x31
     a30:	fa a9       	ldd	r31, Y+50	; 0x32
     a32:	e8 0d       	add	r30, r8
     a34:	f9 1d       	adc	r31, r9
     a36:	d2 01       	movw	r26, r4
     a38:	2d 91       	ld	r18, X+
     a3a:	3d 91       	ld	r19, X+
     a3c:	4d 91       	ld	r20, X+
     a3e:	5c 91       	ld	r21, X
     a40:	60 81       	ld	r22, Z
     a42:	71 81       	ldd	r23, Z+1	; 0x01
     a44:	82 81       	ldd	r24, Z+2	; 0x02
     a46:	93 81       	ldd	r25, Z+3	; 0x03
     a48:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
     a4c:	a7 01       	movw	r20, r14
     a4e:	96 01       	movw	r18, r12
     a50:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__divsf3>
     a54:	69 8b       	std	Y+17, r22	; 0x11
     a56:	7a 8b       	std	Y+18, r23	; 0x12
     a58:	8b 8b       	std	Y+19, r24	; 0x13
     a5a:	9c 8b       	std	Y+20, r25	; 0x14
       without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
       a correction, the planner should have caught up to the lag caused by the initial mc_arc overhead.
       This is important when there are successive arc motions.
    */
    // Computes: cos_T = 1 - theta_per_segment^2/2, sin_T = theta_per_segment - theta_per_segment^3/6) in ~52usec
    float cos_T = 2.0 - theta_per_segment*theta_per_segment;
     a5c:	29 a5       	ldd	r18, Y+41	; 0x29
     a5e:	3a a5       	ldd	r19, Y+42	; 0x2a
     a60:	4b a5       	ldd	r20, Y+43	; 0x2b
     a62:	5c a5       	ldd	r21, Y+44	; 0x2c
     a64:	ca 01       	movw	r24, r20
     a66:	b9 01       	movw	r22, r18
     a68:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     a6c:	9b 01       	movw	r18, r22
     a6e:	ac 01       	movw	r20, r24
     a70:	60 e0       	ldi	r22, 0x00	; 0
     a72:	70 e0       	ldi	r23, 0x00	; 0
     a74:	80 e0       	ldi	r24, 0x00	; 0
     a76:	90 e4       	ldi	r25, 0x40	; 64
     a78:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
     a7c:	6b 01       	movw	r12, r22
     a7e:	7c 01       	movw	r14, r24
    float sin_T = theta_per_segment*0.16666667*(cos_T + 4.0);
     a80:	2b ea       	ldi	r18, 0xAB	; 171
     a82:	3a ea       	ldi	r19, 0xAA	; 170
     a84:	4a e2       	ldi	r20, 0x2A	; 42
     a86:	5e e3       	ldi	r21, 0x3E	; 62
     a88:	69 a5       	ldd	r22, Y+41	; 0x29
     a8a:	7a a5       	ldd	r23, Y+42	; 0x2a
     a8c:	8b a5       	ldd	r24, Y+43	; 0x2b
     a8e:	9c a5       	ldd	r25, Y+44	; 0x2c
     a90:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     a94:	4b 01       	movw	r8, r22
     a96:	5c 01       	movw	r10, r24
     a98:	20 e0       	ldi	r18, 0x00	; 0
     a9a:	30 e0       	ldi	r19, 0x00	; 0
     a9c:	40 e8       	ldi	r20, 0x80	; 128
     a9e:	50 e4       	ldi	r21, 0x40	; 64
     aa0:	c7 01       	movw	r24, r14
     aa2:	b6 01       	movw	r22, r12
     aa4:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
     aa8:	9b 01       	movw	r18, r22
     aaa:	ac 01       	movw	r20, r24
     aac:	c5 01       	movw	r24, r10
     aae:	b4 01       	movw	r22, r8
     ab0:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     ab4:	69 a3       	std	Y+33, r22	; 0x21
     ab6:	7a a3       	std	Y+34, r23	; 0x22
     ab8:	8b a3       	std	Y+35, r24	; 0x23
     aba:	9c a3       	std	Y+36, r25	; 0x24
    cos_T *= 0.5;
     abc:	20 e0       	ldi	r18, 0x00	; 0
     abe:	30 e0       	ldi	r19, 0x00	; 0
     ac0:	40 e0       	ldi	r20, 0x00	; 0
     ac2:	5f e3       	ldi	r21, 0x3F	; 63
     ac4:	c7 01       	movw	r24, r14
     ac6:	b6 01       	movw	r22, r12
     ac8:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     acc:	6d a3       	std	Y+37, r22	; 0x25
     ace:	7e a3       	std	Y+38, r23	; 0x26
     ad0:	8f a3       	std	Y+39, r24	; 0x27
     ad2:	98 a7       	std	Y+40, r25	; 0x28
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;

    for (i = 1; i<segments; i++) { // Increment (segments-1).
     ad4:	b2 e0       	ldi	r27, 0x02	; 2
     ad6:	6b 16       	cp	r6, r27
     ad8:	71 04       	cpc	r7, r1
     ada:	08 f4       	brcc	.+2      	; 0xade <mc_arc+0x398>
     adc:	f5 c0       	rjmp	.+490    	; 0xcc8 <mc_arc+0x582>
     ade:	10 e0       	ldi	r17, 0x00	; 0
     ae0:	22 24       	eor	r2, r2
     ae2:	23 94       	inc	r2
     ae4:	31 2c       	mov	r3, r1
      position[axis_linear] += linear_per_segment;

      mc_line(position, pl_data);

      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
     ae6:	c9 84       	ldd	r12, Y+9	; 0x09
     ae8:	da 84       	ldd	r13, Y+10	; 0x0a
     aea:	eb 84       	ldd	r14, Y+11	; 0x0b
     aec:	fc 84       	ldd	r15, Y+12	; 0x0c
    uint16_t i;
    uint8_t count = 0;

    for (i = 1; i<segments; i++) { // Increment (segments-1).

      if (count < N_ARC_CORRECTION) {
     aee:	1c 30       	cpi	r17, 0x0C	; 12
     af0:	08 f0       	brcs	.+2      	; 0xaf4 <mc_arc+0x3ae>
     af2:	44 c0       	rjmp	.+136    	; 0xb7c <mc_arc+0x436>
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
     af4:	a7 01       	movw	r20, r14
     af6:	96 01       	movw	r18, r12
     af8:	6d a1       	ldd	r22, Y+37	; 0x25
     afa:	7e a1       	ldd	r23, Y+38	; 0x26
     afc:	8f a1       	ldd	r24, Y+39	; 0x27
     afe:	98 a5       	ldd	r25, Y+40	; 0x28
     b00:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     b04:	4b 01       	movw	r8, r22
     b06:	5c 01       	movw	r10, r24
     b08:	29 81       	ldd	r18, Y+1	; 0x01
     b0a:	3a 81       	ldd	r19, Y+2	; 0x02
     b0c:	4b 81       	ldd	r20, Y+3	; 0x03
     b0e:	5c 81       	ldd	r21, Y+4	; 0x04
     b10:	69 a1       	ldd	r22, Y+33	; 0x21
     b12:	7a a1       	ldd	r23, Y+34	; 0x22
     b14:	8b a1       	ldd	r24, Y+35	; 0x23
     b16:	9c a1       	ldd	r25, Y+36	; 0x24
     b18:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     b1c:	a5 01       	movw	r20, r10
     b1e:	94 01       	movw	r18, r8
     b20:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
     b24:	96 2e       	mov	r9, r22
     b26:	a7 2e       	mov	r10, r23
     b28:	b8 2e       	mov	r11, r24
     b2a:	09 2f       	mov	r16, r25
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
     b2c:	29 81       	ldd	r18, Y+1	; 0x01
     b2e:	3a 81       	ldd	r19, Y+2	; 0x02
     b30:	4b 81       	ldd	r20, Y+3	; 0x03
     b32:	5c 81       	ldd	r21, Y+4	; 0x04
     b34:	6d a1       	ldd	r22, Y+37	; 0x25
     b36:	7e a1       	ldd	r23, Y+38	; 0x26
     b38:	8f a1       	ldd	r24, Y+39	; 0x27
     b3a:	98 a5       	ldd	r25, Y+40	; 0x28
     b3c:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     b40:	69 83       	std	Y+1, r22	; 0x01
     b42:	7a 83       	std	Y+2, r23	; 0x02
     b44:	8b 83       	std	Y+3, r24	; 0x03
     b46:	9c 83       	std	Y+4, r25	; 0x04
     b48:	a7 01       	movw	r20, r14
     b4a:	96 01       	movw	r18, r12
     b4c:	69 a1       	ldd	r22, Y+33	; 0x21
     b4e:	7a a1       	ldd	r23, Y+34	; 0x22
     b50:	8b a1       	ldd	r24, Y+35	; 0x23
     b52:	9c a1       	ldd	r25, Y+36	; 0x24
     b54:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     b58:	9b 01       	movw	r18, r22
     b5a:	ac 01       	movw	r20, r24
     b5c:	69 81       	ldd	r22, Y+1	; 0x01
     b5e:	7a 81       	ldd	r23, Y+2	; 0x02
     b60:	8b 81       	ldd	r24, Y+3	; 0x03
     b62:	9c 81       	ldd	r25, Y+4	; 0x04
     b64:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
     b68:	69 83       	std	Y+1, r22	; 0x01
     b6a:	7a 83       	std	Y+2, r23	; 0x02
     b6c:	8b 83       	std	Y+3, r24	; 0x03
     b6e:	9c 83       	std	Y+4, r25	; 0x04
        r_axis1 = r_axisi;
        count++;
     b70:	1f 5f       	subi	r17, 0xFF	; 255

      if (count < N_ARC_CORRECTION) {
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
        r_axis1 = r_axisi;
     b72:	c9 2c       	mov	r12, r9
     b74:	da 2c       	mov	r13, r10
     b76:	eb 2c       	mov	r14, r11
     b78:	f0 2e       	mov	r15, r16
     b7a:	66 c0       	rjmp	.+204    	; 0xc48 <mc_arc+0x502>
        count++;
      } else {
        // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments. ~375 usec
        // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
        cos_Ti = cos(i*theta_per_segment);
     b7c:	b1 01       	movw	r22, r2
     b7e:	80 e0       	ldi	r24, 0x00	; 0
     b80:	90 e0       	ldi	r25, 0x00	; 0
     b82:	0e 94 05 40 	call	0x800a	; 0x800a <__floatunsisf>
     b86:	29 a5       	ldd	r18, Y+41	; 0x29
     b88:	3a a5       	ldd	r19, Y+42	; 0x2a
     b8a:	4b a5       	ldd	r20, Y+43	; 0x2b
     b8c:	5c a5       	ldd	r21, Y+44	; 0x2c
     b8e:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     b92:	6b 01       	movw	r12, r22
     b94:	7c 01       	movw	r14, r24
     b96:	0e 94 69 3f 	call	0x7ed2	; 0x7ed2 <cos>
     b9a:	6d 83       	std	Y+5, r22	; 0x05
     b9c:	7e 83       	std	Y+6, r23	; 0x06
     b9e:	8f 83       	std	Y+7, r24	; 0x07
     ba0:	98 87       	std	Y+8, r25	; 0x08
        sin_Ti = sin(i*theta_per_segment);
     ba2:	c7 01       	movw	r24, r14
     ba4:	b6 01       	movw	r22, r12
     ba6:	0e 94 26 42 	call	0x844c	; 0x844c <sin>
     baa:	69 87       	std	Y+9, r22	; 0x09
     bac:	7a 87       	std	Y+10, r23	; 0x0a
     bae:	8b 87       	std	Y+11, r24	; 0x0b
     bb0:	9c 87       	std	Y+12, r25	; 0x0c
        r_axis0 = -offset[axis_0]*cos_Ti + offset[axis_1]*sin_Ti;
     bb2:	ed a5       	ldd	r30, Y+45	; 0x2d
     bb4:	fe a5       	ldd	r31, Y+46	; 0x2e
     bb6:	c0 80       	ld	r12, Z
     bb8:	d1 80       	ldd	r13, Z+1	; 0x01
     bba:	e2 80       	ldd	r14, Z+2	; 0x02
     bbc:	f3 80       	ldd	r15, Z+3	; 0x03
     bbe:	f7 fa       	bst	r15, 7
     bc0:	f0 94       	com	r15
     bc2:	f7 f8       	bld	r15, 7
     bc4:	f0 94       	com	r15
     bc6:	af a5       	ldd	r26, Y+47	; 0x2f
     bc8:	b8 a9       	ldd	r27, Y+48	; 0x30
     bca:	8d 90       	ld	r8, X+
     bcc:	9d 90       	ld	r9, X+
     bce:	ad 90       	ld	r10, X+
     bd0:	bc 90       	ld	r11, X
     bd2:	a7 01       	movw	r20, r14
     bd4:	96 01       	movw	r18, r12
     bd6:	6d 81       	ldd	r22, Y+5	; 0x05
     bd8:	7e 81       	ldd	r23, Y+6	; 0x06
     bda:	8f 81       	ldd	r24, Y+7	; 0x07
     bdc:	98 85       	ldd	r25, Y+8	; 0x08
     bde:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     be2:	69 83       	std	Y+1, r22	; 0x01
     be4:	7a 83       	std	Y+2, r23	; 0x02
     be6:	8b 83       	std	Y+3, r24	; 0x03
     be8:	9c 83       	std	Y+4, r25	; 0x04
     bea:	a5 01       	movw	r20, r10
     bec:	94 01       	movw	r18, r8
     bee:	69 85       	ldd	r22, Y+9	; 0x09
     bf0:	7a 85       	ldd	r23, Y+10	; 0x0a
     bf2:	8b 85       	ldd	r24, Y+11	; 0x0b
     bf4:	9c 85       	ldd	r25, Y+12	; 0x0c
     bf6:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     bfa:	9b 01       	movw	r18, r22
     bfc:	ac 01       	movw	r20, r24
     bfe:	69 81       	ldd	r22, Y+1	; 0x01
     c00:	7a 81       	ldd	r23, Y+2	; 0x02
     c02:	8b 81       	ldd	r24, Y+3	; 0x03
     c04:	9c 81       	ldd	r25, Y+4	; 0x04
     c06:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
     c0a:	69 83       	std	Y+1, r22	; 0x01
     c0c:	7a 83       	std	Y+2, r23	; 0x02
     c0e:	8b 83       	std	Y+3, r24	; 0x03
     c10:	9c 83       	std	Y+4, r25	; 0x04
        r_axis1 = -offset[axis_0]*sin_Ti - offset[axis_1]*cos_Ti;
     c12:	a7 01       	movw	r20, r14
     c14:	96 01       	movw	r18, r12
     c16:	69 85       	ldd	r22, Y+9	; 0x09
     c18:	7a 85       	ldd	r23, Y+10	; 0x0a
     c1a:	8b 85       	ldd	r24, Y+11	; 0x0b
     c1c:	9c 85       	ldd	r25, Y+12	; 0x0c
     c1e:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     c22:	6b 01       	movw	r12, r22
     c24:	7c 01       	movw	r14, r24
     c26:	a5 01       	movw	r20, r10
     c28:	94 01       	movw	r18, r8
     c2a:	6d 81       	ldd	r22, Y+5	; 0x05
     c2c:	7e 81       	ldd	r23, Y+6	; 0x06
     c2e:	8f 81       	ldd	r24, Y+7	; 0x07
     c30:	98 85       	ldd	r25, Y+8	; 0x08
     c32:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     c36:	9b 01       	movw	r18, r22
     c38:	ac 01       	movw	r20, r24
     c3a:	c7 01       	movw	r24, r14
     c3c:	b6 01       	movw	r22, r12
     c3e:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
     c42:	6b 01       	movw	r12, r22
     c44:	7c 01       	movw	r14, r24
        count = 0;
     c46:	10 e0       	ldi	r17, 0x00	; 0
      }

      // Update arc_target location
      position[axis_0] = center_axis0 + r_axis0;
     c48:	2f 89       	ldd	r18, Y+23	; 0x17
     c4a:	38 8d       	ldd	r19, Y+24	; 0x18
     c4c:	49 8d       	ldd	r20, Y+25	; 0x19
     c4e:	5a 8d       	ldd	r21, Y+26	; 0x1a
     c50:	69 81       	ldd	r22, Y+1	; 0x01
     c52:	7a 81       	ldd	r23, Y+2	; 0x02
     c54:	8b 81       	ldd	r24, Y+3	; 0x03
     c56:	9c 81       	ldd	r25, Y+4	; 0x04
     c58:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
     c5c:	ed 89       	ldd	r30, Y+21	; 0x15
     c5e:	fe 89       	ldd	r31, Y+22	; 0x16
     c60:	60 83       	st	Z, r22
     c62:	71 83       	std	Z+1, r23	; 0x01
     c64:	82 83       	std	Z+2, r24	; 0x02
     c66:	93 83       	std	Z+3, r25	; 0x03
      position[axis_1] = center_axis1 + r_axis1;
     c68:	2d 8d       	ldd	r18, Y+29	; 0x1d
     c6a:	3e 8d       	ldd	r19, Y+30	; 0x1e
     c6c:	4f 8d       	ldd	r20, Y+31	; 0x1f
     c6e:	58 a1       	ldd	r21, Y+32	; 0x20
     c70:	c7 01       	movw	r24, r14
     c72:	b6 01       	movw	r22, r12
     c74:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
     c78:	ab 8d       	ldd	r26, Y+27	; 0x1b
     c7a:	bc 8d       	ldd	r27, Y+28	; 0x1c
     c7c:	6d 93       	st	X+, r22
     c7e:	7d 93       	st	X+, r23
     c80:	8d 93       	st	X+, r24
     c82:	9c 93       	st	X, r25
     c84:	13 97       	sbiw	r26, 0x03	; 3
      position[axis_linear] += linear_per_segment;
     c86:	29 89       	ldd	r18, Y+17	; 0x11
     c88:	3a 89       	ldd	r19, Y+18	; 0x12
     c8a:	4b 89       	ldd	r20, Y+19	; 0x13
     c8c:	5c 89       	ldd	r21, Y+20	; 0x14
     c8e:	f2 01       	movw	r30, r4
     c90:	60 81       	ld	r22, Z
     c92:	71 81       	ldd	r23, Z+1	; 0x01
     c94:	82 81       	ldd	r24, Z+2	; 0x02
     c96:	93 81       	ldd	r25, Z+3	; 0x03
     c98:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
     c9c:	d2 01       	movw	r26, r4
     c9e:	6d 93       	st	X+, r22
     ca0:	7d 93       	st	X+, r23
     ca2:	8d 93       	st	X+, r24
     ca4:	9c 93       	st	X, r25
     ca6:	13 97       	sbiw	r26, 0x03	; 3

      mc_line(position, pl_data);
     ca8:	6f 85       	ldd	r22, Y+15	; 0x0f
     caa:	78 89       	ldd	r23, Y+16	; 0x10
     cac:	8d 85       	ldd	r24, Y+13	; 0x0d
     cae:	9e 85       	ldd	r25, Y+14	; 0x0e
     cb0:	09 dd       	rcall	.-1518   	; 0x6c4 <mc_line>

      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
     cb2:	80 91 1f 0c 	lds	r24, 0x0C1F	; 0x800c1f <sys+0x1>
     cb6:	81 11       	cpse	r24, r1
     cb8:	0c c0       	rjmp	.+24     	; 0xcd2 <mc_arc+0x58c>
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;

    for (i = 1; i<segments; i++) { // Increment (segments-1).
     cba:	bf ef       	ldi	r27, 0xFF	; 255
     cbc:	2b 1a       	sub	r2, r27
     cbe:	3b 0a       	sbc	r3, r27
     cc0:	62 14       	cp	r6, r2
     cc2:	73 04       	cpc	r7, r3
     cc4:	09 f0       	breq	.+2      	; 0xcc8 <mc_arc+0x582>
     cc6:	13 cf       	rjmp	.-474    	; 0xaee <mc_arc+0x3a8>
      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
    }
  }
  // Ensure last segment arrives at target location.
  mc_line(target, pl_data);
     cc8:	6f 85       	ldd	r22, Y+15	; 0x0f
     cca:	78 89       	ldd	r23, Y+16	; 0x10
     ccc:	89 a9       	ldd	r24, Y+49	; 0x31
     cce:	9a a9       	ldd	r25, Y+50	; 0x32
     cd0:	f9 dc       	rcall	.-1550   	; 0x6c4 <mc_line>
}
     cd2:	e2 96       	adiw	r28, 0x32	; 50
     cd4:	0f b6       	in	r0, 0x3f	; 63
     cd6:	f8 94       	cli
     cd8:	de bf       	out	0x3e, r29	; 62
     cda:	0f be       	out	0x3f, r0	; 63
     cdc:	cd bf       	out	0x3d, r28	; 61
     cde:	df 91       	pop	r29
     ce0:	cf 91       	pop	r28
     ce2:	1f 91       	pop	r17
     ce4:	0f 91       	pop	r16
     ce6:	ff 90       	pop	r15
     ce8:	ef 90       	pop	r14
     cea:	df 90       	pop	r13
     cec:	cf 90       	pop	r12
     cee:	bf 90       	pop	r11
     cf0:	af 90       	pop	r10
     cf2:	9f 90       	pop	r9
     cf4:	8f 90       	pop	r8
     cf6:	7f 90       	pop	r7
     cf8:	6f 90       	pop	r6
     cfa:	5f 90       	pop	r5
     cfc:	4f 90       	pop	r4
     cfe:	3f 90       	pop	r3
     d00:	2f 90       	pop	r2
     d02:	08 95       	ret

00000d04 <mc_dwell>:


// Execute dwell in seconds.
void mc_dwell(float seconds)
{
     d04:	cf 92       	push	r12
     d06:	df 92       	push	r13
     d08:	ef 92       	push	r14
     d0a:	ff 92       	push	r15
  if (sys.state == STATE_CHECK_MODE) { return; }
     d0c:	20 91 1e 0c 	lds	r18, 0x0C1E	; 0x800c1e <sys>
     d10:	22 30       	cpi	r18, 0x02	; 2
     d12:	49 f0       	breq	.+18     	; 0xd26 <mc_dwell+0x22>
     d14:	6b 01       	movw	r12, r22
     d16:	7c 01       	movw	r14, r24
  protocol_buffer_synchronize();
     d18:	0e 94 02 19 	call	0x3204	; 0x3204 <protocol_buffer_synchronize>
  delay_sec(seconds, DELAY_MODE_DWELL);
     d1c:	40 e0       	ldi	r20, 0x00	; 0
     d1e:	c7 01       	movw	r24, r14
     d20:	b6 01       	movw	r22, r12
     d22:	0e 94 c9 2e 	call	0x5d92	; 0x5d92 <delay_sec>
}
     d26:	ff 90       	pop	r15
     d28:	ef 90       	pop	r14
     d2a:	df 90       	pop	r13
     d2c:	cf 90       	pop	r12
     d2e:	08 95       	ret

00000d30 <mc_homing_cycle>:

// Perform homing cycle to locate and set machine zero. Only '$H' executes this command.
// NOTE: There should be no motions in the buffer and Grbl must be in an idle state before
// executing the homing cycle. This prevents incorrect buffered plans after homing.
void mc_homing_cycle(uint8_t cycle_mask)
{
     d30:	cf 93       	push	r28
     d32:	c8 2f       	mov	r28, r24
      system_set_exec_alarm(EXEC_ALARM_HARD_LIMIT);
      return;
    }
  #endif

  limits_disable(); // Disable hard limits pin change register for cycle duration
     d34:	0e 94 0f 30 	call	0x601e	; 0x601e <limits_disable>

  // -------------------------------------------------------------------------------------
  // Perform homing routine. NOTE: Special motion case. Only system reset works.
  
  #ifdef HOMING_SINGLE_AXIS_COMMANDS
    if (cycle_mask) { limits_go_home(cycle_mask); } // Perform homing cycle based on mask.
     d38:	cc 23       	and	r28, r28
     d3a:	21 f0       	breq	.+8      	; 0xd44 <mc_homing_cycle+0x14>
     d3c:	8c 2f       	mov	r24, r28
     d3e:	0e 94 d6 30 	call	0x61ac	; 0x61ac <limits_go_home>
     d42:	06 c0       	rjmp	.+12     	; 0xd50 <mc_homing_cycle+0x20>
    else
  #endif
  {
    // Search to engage all axes limit switches at faster homing seek rate.
    limits_go_home(HOMING_CYCLE_0);  // Homing cycle 0
     d44:	81 e0       	ldi	r24, 0x01	; 1
     d46:	0e 94 d6 30 	call	0x61ac	; 0x61ac <limits_go_home>
    #ifdef HOMING_CYCLE_1
      limits_go_home(HOMING_CYCLE_1);  // Homing cycle 1
     d4a:	84 e0       	ldi	r24, 0x04	; 4
     d4c:	0e 94 d6 30 	call	0x61ac	; 0x61ac <limits_go_home>
    #ifdef HOMING_CYCLE_2
      limits_go_home(HOMING_CYCLE_2);  // Homing cycle 2
    #endif
  }

  protocol_execute_realtime(); // Check for reset and set system abort.
     d50:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <protocol_execute_realtime>
  if (sys.abort) { return; } // Did not complete. Alarm state set by mc_alarm.
     d54:	80 91 1f 0c 	lds	r24, 0x0C1F	; 0x800c1f <sys+0x1>
     d58:	81 11       	cpse	r24, r1
     d5a:	05 c0       	rjmp	.+10     	; 0xd66 <mc_homing_cycle+0x36>

  // Homing cycle complete! Setup system for normal operation.
  // -------------------------------------------------------------------------------------

  // Sync gcode parser and planner positions to homed position.
  gc_sync_position();
     d5c:	b1 d0       	rcall	.+354    	; 0xec0 <gc_sync_position>
  plan_sync_position();
     d5e:	0e 94 dd 2d 	call	0x5bba	; 0x5bba <plan_sync_position>

  // If hard limits feature enabled, re-enable hard limits pin change register after homing cycle.
  limits_init();
     d62:	0e 94 1a 30 	call	0x6034	; 0x6034 <limits_init>
}
     d66:	cf 91       	pop	r28
     d68:	08 95       	ret

00000d6a <mc_probe_cycle>:


// Perform tool length probe cycle. Requires probe switch.
// NOTE: Upon probe failure, the program will be stopped and placed into ALARM state.
uint8_t mc_probe_cycle(float *target, plan_line_data_t *pl_data, uint8_t parser_flags)
{
     d6a:	df 92       	push	r13
     d6c:	ef 92       	push	r14
     d6e:	ff 92       	push	r15
     d70:	0f 93       	push	r16
     d72:	1f 93       	push	r17
     d74:	cf 93       	push	r28
     d76:	df 93       	push	r29
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return(GC_PROBE_CHECK_MODE); }
     d78:	20 91 1e 0c 	lds	r18, 0x0C1E	; 0x800c1e <sys>
     d7c:	22 30       	cpi	r18, 0x02	; 2
     d7e:	09 f4       	brne	.+2      	; 0xd82 <mc_probe_cycle+0x18>
     d80:	5c c0       	rjmp	.+184    	; 0xe3a <mc_probe_cycle+0xd0>
     d82:	d4 2e       	mov	r13, r20
     d84:	7b 01       	movw	r14, r22
     d86:	8c 01       	movw	r16, r24

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
     d88:	0e 94 02 19 	call	0x3204	; 0x3204 <protocol_buffer_synchronize>
  if (sys.abort) { return(GC_PROBE_ABORT); } // Return if system reset has been issued.
     d8c:	80 91 1f 0c 	lds	r24, 0x0C1F	; 0x800c1f <sys+0x1>
     d90:	81 11       	cpse	r24, r1
     d92:	55 c0       	rjmp	.+170    	; 0xe3e <mc_probe_cycle+0xd4>

  // Initialize probing control variables
  uint8_t is_probe_away = bit_istrue(parser_flags,GC_PARSER_PROBE_IS_AWAY);
  uint8_t is_no_error = bit_istrue(parser_flags,GC_PARSER_PROBE_IS_NO_ERROR);
  sys.probe_succeeded = false; // Re-initialize probe history before beginning cycle.
     d94:	10 92 23 0c 	sts	0x0C23, r1	; 0x800c23 <sys+0x5>
  probe_configure_invert_mask(is_probe_away);
     d98:	d3 fa       	bst	r13, 3
     d9a:	88 27       	eor	r24, r24
     d9c:	80 f9       	bld	r24, 0
     d9e:	0e 94 b2 34 	call	0x6964	; 0x6964 <probe_configure_invert_mask>

  // After syncing, check if probe is already triggered. If so, halt and issue alarm.
  // NOTE: This probe initialization error applies to all probing cycles.
  if ( probe_get_state() ) { // Check probe pin state.
     da2:	0e 94 d0 34 	call	0x69a0	; 0x69a0 <probe_get_state>
     da6:	88 23       	and	r24, r24
     da8:	51 f0       	breq	.+20     	; 0xdbe <mc_probe_cycle+0x54>
    system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_INITIAL);
     daa:	84 e0       	ldi	r24, 0x04	; 4
     dac:	0e 94 fd 3d 	call	0x7bfa	; 0x7bfa <system_set_exec_alarm>
    protocol_execute_realtime();
     db0:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <protocol_execute_realtime>
    probe_configure_invert_mask(false); // Re-initialize invert mask before returning.
     db4:	80 e0       	ldi	r24, 0x00	; 0
     db6:	0e 94 b2 34 	call	0x6964	; 0x6964 <probe_configure_invert_mask>
    return(GC_PROBE_FAIL_INIT); // Nothing else to do but bail.
     dba:	82 e0       	ldi	r24, 0x02	; 2
     dbc:	43 c0       	rjmp	.+134    	; 0xe44 <mc_probe_cycle+0xda>
  }

  // Setup and queue probing motion. Auto cycle-start should not start the cycle.
  mc_line(target, pl_data);
     dbe:	b7 01       	movw	r22, r14
     dc0:	c8 01       	movw	r24, r16
     dc2:	80 dc       	rcall	.-1792   	; 0x6c4 <mc_line>

  // Activate the probing state monitor in the stepper module.
  sys_probe_state = PROBE_ACTIVE;
     dc4:	81 e0       	ldi	r24, 0x01	; 1
     dc6:	80 93 32 0c 	sts	0x0C32, r24	; 0x800c32 <sys_probe_state>

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
     dca:	82 e0       	ldi	r24, 0x02	; 2
     dcc:	0e 94 95 3b 	call	0x772a	; 0x772a <system_set_exec_state_flag>
  do {
    protocol_execute_realtime();
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
     dd0:	ce e1       	ldi	r28, 0x1E	; 30
     dd2:	dc e0       	ldi	r29, 0x0C	; 12
  sys_probe_state = PROBE_ACTIVE;

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
  do {
    protocol_execute_realtime();
     dd4:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <protocol_execute_realtime>
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
     dd8:	89 81       	ldd	r24, Y+1	; 0x01
     dda:	81 11       	cpse	r24, r1
     ddc:	32 c0       	rjmp	.+100    	; 0xe42 <mc_probe_cycle+0xd8>
  } while (sys.state != STATE_IDLE);
     dde:	88 81       	ld	r24, Y
     de0:	81 11       	cpse	r24, r1
     de2:	f8 cf       	rjmp	.-16     	; 0xdd4 <mc_probe_cycle+0x6a>

  // Probing cycle complete!

  // Set state variables and error out, if the probe failed and cycle with error is enabled.
  if (sys_probe_state == PROBE_ACTIVE) {
     de4:	80 91 32 0c 	lds	r24, 0x0C32	; 0x800c32 <sys_probe_state>
     de8:	81 30       	cpi	r24, 0x01	; 1
     dea:	81 f4       	brne	.+32     	; 0xe0c <mc_probe_cycle+0xa2>
    if (is_no_error) { memcpy(sys_probe_position, sys_position, sizeof(sys_position)); }
     dec:	d4 fe       	sbrs	r13, 4
     dee:	0a c0       	rjmp	.+20     	; 0xe04 <mc_probe_cycle+0x9a>
     df0:	8c e0       	ldi	r24, 0x0C	; 12
     df2:	e3 e4       	ldi	r30, 0x43	; 67
     df4:	fc e0       	ldi	r31, 0x0C	; 12
     df6:	a7 e3       	ldi	r26, 0x37	; 55
     df8:	bc e0       	ldi	r27, 0x0C	; 12
     dfa:	01 90       	ld	r0, Z+
     dfc:	0d 92       	st	X+, r0
     dfe:	8a 95       	dec	r24
     e00:	e1 f7       	brne	.-8      	; 0xdfa <mc_probe_cycle+0x90>
     e02:	07 c0       	rjmp	.+14     	; 0xe12 <mc_probe_cycle+0xa8>
    else { system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_CONTACT); }
     e04:	85 e0       	ldi	r24, 0x05	; 5
     e06:	0e 94 fd 3d 	call	0x7bfa	; 0x7bfa <system_set_exec_alarm>
     e0a:	03 c0       	rjmp	.+6      	; 0xe12 <mc_probe_cycle+0xa8>
  } else {
    sys.probe_succeeded = true; // Indicate to system the probing cycle completed successfully.
     e0c:	81 e0       	ldi	r24, 0x01	; 1
     e0e:	80 93 23 0c 	sts	0x0C23, r24	; 0x800c23 <sys+0x5>
  }
  sys_probe_state = PROBE_OFF; // Ensure probe state monitor is disabled.
     e12:	10 92 32 0c 	sts	0x0C32, r1	; 0x800c32 <sys_probe_state>
  probe_configure_invert_mask(false); // Re-initialize invert mask.
     e16:	80 e0       	ldi	r24, 0x00	; 0
     e18:	0e 94 b2 34 	call	0x6964	; 0x6964 <probe_configure_invert_mask>
  protocol_execute_realtime();   // Check and execute run-time commands
     e1c:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <protocol_execute_realtime>

  // Reset the stepper and planner buffers to remove the remainder of the probe motion.
  st_reset(); // Reset step segment buffer.
     e20:	0e 94 af 1b 	call	0x375e	; 0x375e <st_reset>
  plan_reset(); // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
     e24:	0e 94 35 29 	call	0x526a	; 0x526a <plan_reset>
  plan_sync_position(); // Sync planner position to current machine position.
     e28:	0e 94 dd 2d 	call	0x5bba	; 0x5bba <plan_sync_position>
// Perform tool length probe cycle. Requires probe switch.
// NOTE: Upon probe failure, the program will be stopped and placed into ALARM state.
uint8_t mc_probe_cycle(float *target, plan_line_data_t *pl_data, uint8_t parser_flags)
{
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return(GC_PROBE_CHECK_MODE); }
     e2c:	81 e0       	ldi	r24, 0x01	; 1
     e2e:	90 91 23 0c 	lds	r25, 0x0C23	; 0x800c23 <sys+0x5>
     e32:	91 11       	cpse	r25, r1
     e34:	07 c0       	rjmp	.+14     	; 0xe44 <mc_probe_cycle+0xda>
     e36:	80 e0       	ldi	r24, 0x00	; 0
     e38:	05 c0       	rjmp	.+10     	; 0xe44 <mc_probe_cycle+0xda>
     e3a:	80 e0       	ldi	r24, 0x00	; 0
     e3c:	03 c0       	rjmp	.+6      	; 0xe44 <mc_probe_cycle+0xda>

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
  if (sys.abort) { return(GC_PROBE_ABORT); } // Return if system reset has been issued.
     e3e:	82 e0       	ldi	r24, 0x02	; 2
     e40:	01 c0       	rjmp	.+2      	; 0xe44 <mc_probe_cycle+0xda>

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
  do {
    protocol_execute_realtime();
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
     e42:	82 e0       	ldi	r24, 0x02	; 2
    report_probe_parameters();
  #endif

  if (sys.probe_succeeded) { return(GC_PROBE_FOUND); } // Successful probe cycle.
  else { return(GC_PROBE_FAIL_END); } // Failed to trigger probe within travel. With or without error.
}
     e44:	df 91       	pop	r29
     e46:	cf 91       	pop	r28
     e48:	1f 91       	pop	r17
     e4a:	0f 91       	pop	r16
     e4c:	ff 90       	pop	r15
     e4e:	ef 90       	pop	r14
     e50:	df 90       	pop	r13
     e52:	08 95       	ret

00000e54 <mc_reset>:
// lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
// realtime abort command and hard limits. So, keep to a minimum.
void mc_reset()
{
  // Only this function can set the system reset. Helps prevent multiple kill calls.
  if (bit_isfalse(sys_rt_exec_state, EXEC_RESET)) {
     e54:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
     e58:	84 fd       	sbrc	r24, 4
     e5a:	1f c0       	rjmp	.+62     	; 0xe9a <mc_reset+0x46>
    system_set_exec_state_flag(EXEC_RESET);
     e5c:	80 e1       	ldi	r24, 0x10	; 16
     e5e:	0e 94 95 3b 	call	0x772a	; 0x772a <system_set_exec_state_flag>

    // Kill spindle and coolant.
    spindle_stop();
     e62:	0e 94 57 12 	call	0x24ae	; 0x24ae <spindle_stop>
    coolant_stop();
     e66:	0e 94 9b 13 	call	0x2736	; 0x2736 <coolant_stop>

    // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
    // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
    // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
    // violated, by which, all bets are off.
    if ((sys.state & (STATE_CYCLE | STATE_HOMING | STATE_JOG)) ||
     e6a:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
     e6e:	98 2f       	mov	r25, r24
     e70:	9c 72       	andi	r25, 0x2C	; 44
     e72:	21 f4       	brne	.+8      	; 0xe7c <mc_reset+0x28>
     e74:	90 91 22 0c 	lds	r25, 0x0C22	; 0x800c22 <sys+0x4>
     e78:	96 70       	andi	r25, 0x06	; 6
     e7a:	79 f0       	breq	.+30     	; 0xe9a <mc_reset+0x46>
    		(sys.step_control & (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION))) {
      if (sys.state == STATE_HOMING) { 
     e7c:	84 30       	cpi	r24, 0x04	; 4
     e7e:	41 f4       	brne	.+16     	; 0xe90 <mc_reset+0x3c>
        if (!sys_rt_exec_alarm) {system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_RESET); }
     e80:	80 91 53 0c 	lds	r24, 0x0C53	; 0x800c53 <sys_rt_exec_alarm>
     e84:	81 11       	cpse	r24, r1
     e86:	07 c0       	rjmp	.+14     	; 0xe96 <mc_reset+0x42>
     e88:	86 e0       	ldi	r24, 0x06	; 6
     e8a:	0e 94 fd 3d 	call	0x7bfa	; 0x7bfa <system_set_exec_alarm>
     e8e:	03 c0       	rjmp	.+6      	; 0xe96 <mc_reset+0x42>
      } else { system_set_exec_alarm(EXEC_ALARM_ABORT_CYCLE); }
     e90:	83 e0       	ldi	r24, 0x03	; 3
     e92:	0e 94 fd 3d 	call	0x7bfa	; 0x7bfa <system_set_exec_alarm>
      st_go_idle(); // Force kill steppers. Position has likely been lost.
     e96:	0c 94 2d 19 	jmp	0x325a	; 0x325a <st_go_idle>
     e9a:	08 95       	ret

00000e9c <gc_init>:
#define FAIL(status) return(status);


void gc_init()
{
  memset(&gc_state, 0, sizeof(parser_state_t));
     e9c:	80 e4       	ldi	r24, 0x40	; 64
     e9e:	e6 e5       	ldi	r30, 0x56	; 86
     ea0:	fc e0       	ldi	r31, 0x0C	; 12
     ea2:	df 01       	movw	r26, r30
     ea4:	1d 92       	st	X+, r1
     ea6:	8a 95       	dec	r24
     ea8:	e9 f7       	brne	.-6      	; 0xea4 <gc_init+0x8>

  // Load default G54 coordinate system.
  if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) {
     eaa:	6a e7       	ldi	r22, 0x7A	; 122
     eac:	7c e0       	ldi	r23, 0x0C	; 12
     eae:	80 e0       	ldi	r24, 0x00	; 0
     eb0:	0e 94 f0 25 	call	0x4be0	; 0x4be0 <settings_read_coord_data>
     eb4:	81 11       	cpse	r24, r1
     eb6:	03 c0       	rjmp	.+6      	; 0xebe <gc_init+0x22>
    report_status_message(STATUS_SETTING_READ_FAIL);
     eb8:	87 e0       	ldi	r24, 0x07	; 7
     eba:	0c 94 34 35 	jmp	0x6a68	; 0x6a68 <report_status_message>
     ebe:	08 95       	ret

00000ec0 <gc_sync_position>:

// Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
// limit pull-off routines.
void gc_sync_position()
{
  system_convert_array_steps_to_mpos(gc_state.position,sys_position);
     ec0:	63 e4       	ldi	r22, 0x43	; 67
     ec2:	7c e0       	ldi	r23, 0x0C	; 12
     ec4:	8e e6       	ldi	r24, 0x6E	; 110
     ec6:	9c e0       	ldi	r25, 0x0C	; 12
     ec8:	0c 94 16 3b 	jmp	0x762c	; 0x762c <system_convert_array_steps_to_mpos>
     ecc:	08 95       	ret

00000ece <gc_execute_line>:
// characters and signed floating point values (no whitespace). Comments and block delete
// characters have been removed. In this function, all units and positions are converted and
// exported to grbl's internal functions in terms of (mm, mm/min) and absolute machine
// coordinates, respectively.
uint8_t gc_execute_line(char *line)
{
     ece:	2f 92       	push	r2
     ed0:	3f 92       	push	r3
     ed2:	4f 92       	push	r4
     ed4:	5f 92       	push	r5
     ed6:	6f 92       	push	r6
     ed8:	7f 92       	push	r7
     eda:	8f 92       	push	r8
     edc:	9f 92       	push	r9
     ede:	af 92       	push	r10
     ee0:	bf 92       	push	r11
     ee2:	cf 92       	push	r12
     ee4:	df 92       	push	r13
     ee6:	ef 92       	push	r14
     ee8:	ff 92       	push	r15
     eea:	0f 93       	push	r16
     eec:	1f 93       	push	r17
     eee:	cf 93       	push	r28
     ef0:	df 93       	push	r29
     ef2:	cd b7       	in	r28, 0x3d	; 61
     ef4:	de b7       	in	r29, 0x3e	; 62
     ef6:	e4 97       	sbiw	r28, 0x34	; 52
     ef8:	0f b6       	in	r0, 0x3f	; 63
     efa:	f8 94       	cli
     efc:	de bf       	out	0x3e, r29	; 62
     efe:	0f be       	out	0x3f, r0	; 63
     f00:	cd bf       	out	0x3d, r28	; 61
     f02:	8c 01       	movw	r16, r24
     updates these modes and commands as the block line is parser and will only be used and
     executed after successful error-checking. The parser block struct also contains a block
     values struct, word tracking variables, and a non-modal commands tracker for the new
     block. This struct contains all of the necessary information to execute the block. */

  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
     f04:	8a e3       	ldi	r24, 0x3A	; 58
     f06:	e6 e9       	ldi	r30, 0x96	; 150
     f08:	fc e0       	ldi	r31, 0x0C	; 12
     f0a:	df 01       	movw	r26, r30
     f0c:	1d 92       	st	X+, r1
     f0e:	8a 95       	dec	r24
     f10:	e9 f7       	brne	.-6      	; 0xf0c <gc_execute_line+0x3e>
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
     f12:	8b e0       	ldi	r24, 0x0B	; 11
     f14:	e6 e5       	ldi	r30, 0x56	; 86
     f16:	fc e0       	ldi	r31, 0x0C	; 12
     f18:	a7 e9       	ldi	r26, 0x97	; 151
     f1a:	bc e0       	ldi	r27, 0x0C	; 12
     f1c:	01 90       	ld	r0, Z+
     f1e:	0d 92       	st	X+, r0
     f20:	8a 95       	dec	r24
     f22:	e1 f7       	brne	.-8      	; 0xf1c <gc_execute_line+0x4e>
  uint16_t command_words = 0; // Tracks G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Tracks value words.
  uint8_t gc_parser_flags = GC_PARSER_NONE;

  // Determine if the line is a jogging motion or a normal g-code block.
  if (line[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
     f24:	f8 01       	movw	r30, r16
     f26:	80 81       	ld	r24, Z
     f28:	84 32       	cpi	r24, 0x24	; 36
     f2a:	11 f0       	breq	.+4      	; 0xf30 <gc_execute_line+0x62>
     f2c:	0c 94 f8 11 	jmp	0x23f0	; 0x23f0 <__stack+0x1f1>
    // Set G1 and G94 enforced modes to ensure accurate error checks.
    gc_parser_flags |= GC_PARSER_JOG_MOTION;
    gc_block.modal.motion = MOTION_MODE_LINEAR;
     f30:	e6 e9       	ldi	r30, 0x96	; 150
     f32:	fc e0       	ldi	r31, 0x0C	; 12
     f34:	81 e0       	ldi	r24, 0x01	; 1
     f36:	81 83       	std	Z+1, r24	; 0x01
    gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
     f38:	12 82       	std	Z+2, r1	; 0x02
  uint8_t char_counter;
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
     f3a:	83 e0       	ldi	r24, 0x03	; 3
     f3c:	89 83       	std	Y+1, r24	; 0x01
  uint8_t gc_parser_flags = GC_PARSER_NONE;

  // Determine if the line is a jogging motion or a normal g-code block.
  if (line[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
    // Set G1 and G94 enforced modes to ensure accurate error checks.
    gc_parser_flags |= GC_PARSER_JOG_MOTION;
     f3e:	f1 e0       	ldi	r31, 0x01	; 1
     f40:	f8 a7       	std	Y+40, r31	; 0x28
						if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
						gc_block.values.t = int_value;
						break;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
     f42:	21 2c       	mov	r2, r1
     f44:	31 2c       	mov	r3, r1
     f46:	e1 2c       	mov	r14, r1
     f48:	f1 2c       	mov	r15, r1
     f4a:	1f a2       	std	Y+39, r1	; 0x27
     f4c:	1d a2       	std	Y+37, r1	; 0x25
     f4e:	1e a2       	std	Y+38, r1	; 0x26
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
     f50:	cc 24       	eor	r12, r12
     f52:	c3 94       	inc	r12
     f54:	d1 2c       	mov	r13, r1

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
     f56:	0f 2e       	mov	r0, r31
     f58:	f1 e6       	ldi	r31, 0x61	; 97
     f5a:	8f 2e       	mov	r8, r31
     f5c:	f3 e0       	ldi	r31, 0x03	; 3
     f5e:	9f 2e       	mov	r9, r31
     f60:	f0 2d       	mov	r31, r0
     f62:	18 a3       	std	Y+32, r17	; 0x20
     f64:	0f 8f       	std	Y+31, r16	; 0x1f
     f66:	21 c2       	rjmp	.+1090   	; 0x13aa <gc_execute_line+0x4dc>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.

    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
     f68:	9f eb       	ldi	r25, 0xBF	; 191
     f6a:	91 0f       	add	r25, r17
     f6c:	9a 31       	cpi	r25, 0x1A	; 26
     f6e:	10 f0       	brcs	.+4      	; 0xf74 <gc_execute_line+0xa6>
     f70:	0c 94 8a 11 	jmp	0x2314	; 0x2314 <__stack+0x115>
    char_counter++;
     f74:	8f 5f       	subi	r24, 0xFF	; 255
     f76:	89 83       	std	Y+1, r24	; 0x01
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
     f78:	ae 01       	movw	r20, r28
     f7a:	4e 5f       	subi	r20, 0xFE	; 254
     f7c:	5f 4f       	sbci	r21, 0xFF	; 255
     f7e:	be 01       	movw	r22, r28
     f80:	6f 5f       	subi	r22, 0xFF	; 255
     f82:	7f 4f       	sbci	r23, 0xFF	; 255
     f84:	8f 8d       	ldd	r24, Y+31	; 0x1f
     f86:	98 a1       	ldd	r25, Y+32	; 0x20
     f88:	0e 94 03 2e 	call	0x5c06	; 0x5c06 <read_float>
     f8c:	88 23       	and	r24, r24
     f8e:	11 f4       	brne	.+4      	; 0xf94 <gc_execute_line+0xc6>
     f90:	0c 94 8c 11 	jmp	0x2318	; 0x2318 <__stack+0x119>
    // accurate than the NIST gcode requirement of x10 when used for commands, but not quite
    // accurate enough for value words that require integers to within 0.0001. This should be
    // a good enough comprimise and catch most all non-integer errors. To make it compliant,
    // we would simply need to change the mantissa to int16, but this add compiled flash space.
    // Maybe update this later.
    int_value = trunc(value);
     f94:	4a 80       	ldd	r4, Y+2	; 0x02
     f96:	5b 80       	ldd	r5, Y+3	; 0x03
     f98:	6c 80       	ldd	r6, Y+4	; 0x04
     f9a:	7d 80       	ldd	r7, Y+5	; 0x05
     f9c:	c3 01       	movw	r24, r6
     f9e:	b2 01       	movw	r22, r4
     fa0:	0e 94 71 42 	call	0x84e2	; 0x84e2 <trunc>
     fa4:	0e 94 d9 3f 	call	0x7fb2	; 0x7fb2 <__fixunssfsi>
     fa8:	a6 2e       	mov	r10, r22
    mantissa =  round(100*(value - int_value)); // Compute mantissa for Gxx.x commands.
     faa:	70 e0       	ldi	r23, 0x00	; 0
     fac:	80 e0       	ldi	r24, 0x00	; 0
     fae:	90 e0       	ldi	r25, 0x00	; 0
     fb0:	0e 94 07 40 	call	0x800e	; 0x800e <__floatsisf>
     fb4:	9b 01       	movw	r18, r22
     fb6:	ac 01       	movw	r20, r24
     fb8:	c3 01       	movw	r24, r6
     fba:	b2 01       	movw	r22, r4
     fbc:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
     fc0:	20 e0       	ldi	r18, 0x00	; 0
     fc2:	30 e0       	ldi	r19, 0x00	; 0
     fc4:	48 ec       	ldi	r20, 0xC8	; 200
     fc6:	52 e4       	ldi	r21, 0x42	; 66
     fc8:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
     fcc:	0e 94 06 42 	call	0x840c	; 0x840c <round>
     fd0:	0e 94 d9 3f 	call	0x7fb2	; 0x7fb2 <__fixunssfsi>
     fd4:	69 a3       	std	Y+33, r22	; 0x21
     fd6:	7a a3       	std	Y+34, r23	; 0x22
     fd8:	8b a3       	std	Y+35, r24	; 0x23
     fda:	9c a3       	std	Y+36, r25	; 0x24
     fdc:	49 a1       	ldd	r20, Y+33	; 0x21
     fde:	5a a1       	ldd	r21, Y+34	; 0x22
    // NOTE: Rounding must be used to catch small floating point errors.

    // Check if the g-code word is supported or errors due to modal group violations or has
    // been repeated in the g-code block. If ok, update the command or record its value.
    switch(letter) {
     fe0:	17 34       	cpi	r17, 0x47	; 71
     fe2:	21 f0       	breq	.+8      	; 0xfec <gc_execute_line+0x11e>
     fe4:	1d 34       	cpi	r17, 0x4D	; 77
     fe6:	09 f4       	brne	.+2      	; 0xfea <gc_execute_line+0x11c>
     fe8:	b0 c0       	rjmp	.+352    	; 0x114a <gc_execute_line+0x27c>
     fea:	17 c1       	rjmp	.+558    	; 0x121a <gc_execute_line+0x34c>
      /* 'G' and 'M' Command Words: Parse commands and check for modal group violations.
         NOTE: Modal group numbers are defined in Table 4 of NIST RS274-NGC v3, pg.20 */

      case 'G':
        // Determine 'G' command and its modal group
        switch(int_value) {
     fec:	8a 2d       	mov	r24, r10
     fee:	90 e0       	ldi	r25, 0x00	; 0
     ff0:	8f 35       	cpi	r24, 0x5F	; 95
     ff2:	91 05       	cpc	r25, r1
     ff4:	10 f0       	brcs	.+4      	; 0xffa <gc_execute_line+0x12c>
     ff6:	0c 94 8e 11 	jmp	0x231c	; 0x231c <__stack+0x11d>
     ffa:	fc 01       	movw	r30, r24
     ffc:	88 27       	eor	r24, r24
     ffe:	ee 58       	subi	r30, 0x8E	; 142
    1000:	ff 4f       	sbci	r31, 0xFF	; 255
    1002:	8f 4f       	sbci	r24, 0xFF	; 255
    1004:	0c 94 b2 42 	jmp	0x8564	; 0x8564 <__tablejump2__>
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
    1008:	45 2b       	or	r20, r21
    100a:	11 f0       	breq	.+4      	; 0x1010 <gc_execute_line+0x142>
    100c:	0c 94 fc 11 	jmp	0x23f8	; 0x23f8 <__stack+0x1f9>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    1010:	2e a1       	ldd	r18, Y+38	; 0x26
    1012:	22 23       	and	r18, r18
    1014:	11 f4       	brne	.+4      	; 0x101a <gc_execute_line+0x14c>
    1016:	0c 94 00 12 	jmp	0x2400	; 0x2400 <__stack+0x201>
    101a:	0c 94 90 11 	jmp	0x2320	; 0x2320 <__stack+0x121>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
    101e:	a6 e9       	ldi	r26, 0x96	; 150
    1020:	bc e0       	ldi	r27, 0x0C	; 12
    1022:	ac 92       	st	X, r10
            //if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
              //if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
              //gc_block.non_modal_command += mantissa;
              //mantissa = 0; // Set to zero to indicate valid non-integer G command.
            //}                
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G4.X G53.X not supported]
    1024:	45 2b       	or	r20, r21
    1026:	11 f0       	breq	.+4      	; 0x102c <gc_execute_line+0x15e>
    1028:	0c 94 92 11 	jmp	0x2324	; 0x2324 <__stack+0x125>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
    102c:	80 e0       	ldi	r24, 0x00	; 0
    102e:	7d c0       	rjmp	.+250    	; 0x112a <gc_execute_line+0x25c>
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G4.X G53.X not supported]
            break;
          case 0: case 1: case 2: case 3: case 38:
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    1030:	be a1       	ldd	r27, Y+38	; 0x26
    1032:	b1 11       	cpse	r27, r1
    1034:	0c 94 94 11 	jmp	0x2328	; 0x2328 <__stack+0x129>
            axis_command = AXIS_COMMAND_MOTION_MODE;
    1038:	e2 e0       	ldi	r30, 0x02	; 2
    103a:	ee a3       	std	Y+38, r30	; 0x26
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
            gc_block.modal.motion = int_value;
    103c:	a0 92 97 0c 	sts	0x0C97, r10	; 0x800c97 <gc_block+0x1>
            if (int_value == 38){
    1040:	f6 e2       	ldi	r31, 0x26	; 38
    1042:	af 12       	cpse	r10, r31
    1044:	6d c0       	rjmp	.+218    	; 0x1120 <gc_execute_line+0x252>
              if (!((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))) {
    1046:	44 31       	cpi	r20, 0x14	; 20
    1048:	51 05       	cpc	r21, r1
    104a:	59 f0       	breq	.+22     	; 0x1062 <gc_execute_line+0x194>
    104c:	4e 31       	cpi	r20, 0x1E	; 30
    104e:	51 05       	cpc	r21, r1
    1050:	41 f0       	breq	.+16     	; 0x1062 <gc_execute_line+0x194>
    1052:	48 32       	cpi	r20, 0x28	; 40
    1054:	51 05       	cpc	r21, r1
    1056:	29 f0       	breq	.+10     	; 0x1062 <gc_execute_line+0x194>
    1058:	42 33       	cpi	r20, 0x32	; 50
    105a:	51 05       	cpc	r21, r1
    105c:	11 f0       	breq	.+4      	; 0x1062 <gc_execute_line+0x194>
    105e:	0c 94 96 11 	jmp	0x232c	; 0x232c <__stack+0x12d>
                FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
              }
              gc_block.modal.motion += (mantissa/10)+100;
    1062:	29 a1       	ldd	r18, Y+33	; 0x21
    1064:	3a a1       	ldd	r19, Y+34	; 0x22
    1066:	ad ec       	ldi	r26, 0xCD	; 205
    1068:	bc ec       	ldi	r27, 0xCC	; 204
    106a:	0e 94 ba 42 	call	0x8574	; 0x8574 <__umulhisi3>
    106e:	96 95       	lsr	r25
    1070:	87 95       	ror	r24
    1072:	96 95       	lsr	r25
    1074:	87 95       	ror	r24
    1076:	96 95       	lsr	r25
    1078:	87 95       	ror	r24
    107a:	86 57       	subi	r24, 0x76	; 118
    107c:	80 93 97 0c 	sts	0x0C97, r24	; 0x800c97 <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE;
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
    1080:	81 e0       	ldi	r24, 0x01	; 1
    1082:	53 c0       	rjmp	.+166    	; 0x112a <gc_execute_line+0x25c>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
            }  
            break;
          case 17: case 18: case 19:
            word_bit = MODAL_GROUP_G2;
            gc_block.modal.plane_select = int_value - 17;
    1084:	8f ee       	ldi	r24, 0xEF	; 239
    1086:	8a 0d       	add	r24, r10
    1088:	80 93 9b 0c 	sts	0x0C9B, r24	; 0x800c9b <gc_block+0x5>
              gc_block.modal.motion += (mantissa/10)+100;
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
            }  
            break;
          case 17: case 18: case 19:
            word_bit = MODAL_GROUP_G2;
    108c:	82 e0       	ldi	r24, 0x02	; 2
            gc_block.modal.plane_select = int_value - 17;
            break;
    108e:	49 c0       	rjmp	.+146    	; 0x1122 <gc_execute_line+0x254>
          case 90: case 91:
            if (mantissa == 0) {
    1090:	41 15       	cp	r20, r1
    1092:	51 05       	cpc	r21, r1
    1094:	31 f4       	brne	.+12     	; 0x10a2 <gc_execute_line+0x1d4>
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
    1096:	86 ea       	ldi	r24, 0xA6	; 166
    1098:	8a 0d       	add	r24, r10
    109a:	80 93 9a 0c 	sts	0x0C9A, r24	; 0x800c9a <gc_block+0x4>
            word_bit = MODAL_GROUP_G2;
            gc_block.modal.plane_select = int_value - 17;
            break;
          case 90: case 91:
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
    109e:	83 e0       	ldi	r24, 0x03	; 3
    10a0:	44 c0       	rjmp	.+136    	; 0x112a <gc_execute_line+0x25c>
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
    10a2:	4a 30       	cpi	r20, 0x0A	; 10
    10a4:	51 05       	cpc	r21, r1
    10a6:	11 f0       	breq	.+4      	; 0x10ac <gc_execute_line+0x1de>
    10a8:	0c 94 98 11 	jmp	0x2330	; 0x2330 <__stack+0x131>
    10ac:	2a e5       	ldi	r18, 0x5A	; 90
    10ae:	a2 16       	cp	r10, r18
    10b0:	11 f4       	brne	.+4      	; 0x10b6 <gc_execute_line+0x1e8>
    10b2:	0c 94 9a 11 	jmp	0x2334	; 0x2334 <__stack+0x135>
          case 90: case 91:
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
    10b6:	84 e0       	ldi	r24, 0x04	; 4
    10b8:	38 c0       	rjmp	.+112    	; 0x112a <gc_execute_line+0x25c>
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
            gc_block.modal.feed_rate = 94 - int_value;
    10ba:	8e e5       	ldi	r24, 0x5E	; 94
    10bc:	8a 19       	sub	r24, r10
    10be:	80 93 98 0c 	sts	0x0C98, r24	; 0x800c98 <gc_block+0x2>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
    10c2:	85 e0       	ldi	r24, 0x05	; 5
            gc_block.modal.feed_rate = 94 - int_value;
            break;
    10c4:	2e c0       	rjmp	.+92     	; 0x1122 <gc_execute_line+0x254>
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
            gc_block.modal.units = 21 - int_value;
    10c6:	85 e1       	ldi	r24, 0x15	; 21
    10c8:	8a 19       	sub	r24, r10
    10ca:	80 93 99 0c 	sts	0x0C99, r24	; 0x800c99 <gc_block+0x3>
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
            gc_block.modal.feed_rate = 94 - int_value;
            break;
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
    10ce:	86 e0       	ldi	r24, 0x06	; 6
            gc_block.modal.units = 21 - int_value;
            break;
    10d0:	28 c0       	rjmp	.+80     	; 0x1122 <gc_execute_line+0x254>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
    10d2:	3e a1       	ldd	r19, Y+38	; 0x26
    10d4:	31 11       	cpse	r19, r1
    10d6:	0c 94 9c 11 	jmp	0x2338	; 0x2338 <__stack+0x139>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
    10da:	81 e3       	ldi	r24, 0x31	; 49
    10dc:	a8 12       	cpse	r10, r24
    10de:	06 c0       	rjmp	.+12     	; 0x10ec <gc_execute_line+0x21e>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
    10e0:	10 92 9c 0c 	sts	0x0C9C, r1	; 0x800c9c <gc_block+0x6>
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
    10e4:	88 e0       	ldi	r24, 0x08	; 8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
    10e6:	93 e0       	ldi	r25, 0x03	; 3
    10e8:	9e a3       	std	Y+38, r25	; 0x26
    10ea:	1f c0       	rjmp	.+62     	; 0x112a <gc_execute_line+0x25c>
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
            } else if (mantissa == 10) { // G43.1
    10ec:	4a 30       	cpi	r20, 0x0A	; 10
    10ee:	51 05       	cpc	r21, r1
    10f0:	11 f0       	breq	.+4      	; 0x10f6 <gc_execute_line+0x228>
    10f2:	0c 94 9e 11 	jmp	0x233c	; 0x233c <__stack+0x13d>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
    10f6:	a1 e0       	ldi	r26, 0x01	; 1
    10f8:	a0 93 9c 0c 	sts	0x0C9C, r26	; 0x800c9c <gc_block+0x6>
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
    10fc:	88 e0       	ldi	r24, 0x08	; 8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
    10fe:	b3 e0       	ldi	r27, 0x03	; 3
    1100:	be a3       	std	Y+38, r27	; 0x26
    1102:	13 c0       	rjmp	.+38     	; 0x112a <gc_execute_line+0x25c>
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59:
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
    1104:	8a ec       	ldi	r24, 0xCA	; 202
    1106:	8a 0d       	add	r24, r10
    1108:	80 93 9d 0c 	sts	0x0C9D, r24	; 0x800c9d <gc_block+0x7>
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59:
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
    110c:	89 e0       	ldi	r24, 0x09	; 9
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
            break;
    110e:	09 c0       	rjmp	.+18     	; 0x1122 <gc_execute_line+0x254>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
    1110:	45 2b       	or	r20, r21
    1112:	11 f0       	breq	.+4      	; 0x1118 <gc_execute_line+0x24a>
    1114:	0c 94 a0 11 	jmp	0x2340	; 0x2340 <__stack+0x141>
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
    1118:	8a e0       	ldi	r24, 0x0A	; 10
    111a:	07 c0       	rjmp	.+14     	; 0x112a <gc_execute_line+0x25c>
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
            gc_block.modal.units = 21 - int_value;
            break;
          case 40:
            word_bit = MODAL_GROUP_G7;
    111c:	87 e0       	ldi	r24, 0x07	; 7
    111e:	01 c0       	rjmp	.+2      	; 0x1122 <gc_execute_line+0x254>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE;
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
    1120:	81 e0       	ldi	r24, 0x01	; 1
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    1122:	45 2b       	or	r20, r21
    1124:	11 f0       	breq	.+4      	; 0x112a <gc_execute_line+0x25c>
    1126:	0c 94 a2 11 	jmp	0x2344	; 0x2344 <__stack+0x145>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    112a:	f6 01       	movw	r30, r12
    112c:	02 c0       	rjmp	.+4      	; 0x1132 <gc_execute_line+0x264>
    112e:	ee 0f       	add	r30, r30
    1130:	ff 1f       	adc	r31, r31
    1132:	8a 95       	dec	r24
    1134:	e2 f7       	brpl	.-8      	; 0x112e <gc_execute_line+0x260>
    1136:	97 01       	movw	r18, r14
    1138:	2e 23       	and	r18, r30
    113a:	3f 23       	and	r19, r31
    113c:	23 2b       	or	r18, r19
    113e:	11 f0       	breq	.+4      	; 0x1144 <gc_execute_line+0x276>
    1140:	0c 94 a4 11 	jmp	0x2348	; 0x2348 <__stack+0x149>
        command_words |= bit(word_bit);
    1144:	ee 2a       	or	r14, r30
    1146:	ff 2a       	or	r15, r31
        break;
    1148:	30 c1       	rjmp	.+608    	; 0x13aa <gc_execute_line+0x4dc>

      case 'M':

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    114a:	45 2b       	or	r20, r21
    114c:	11 f0       	breq	.+4      	; 0x1152 <gc_execute_line+0x284>
    114e:	0c 94 a6 11 	jmp	0x234c	; 0x234c <__stack+0x14d>
        switch(int_value) {
    1152:	8a 2d       	mov	r24, r10
    1154:	90 e0       	ldi	r25, 0x00	; 0
    1156:	8f 31       	cpi	r24, 0x1F	; 31
    1158:	91 05       	cpc	r25, r1
    115a:	10 f0       	brcs	.+4      	; 0x1160 <gc_execute_line+0x292>
    115c:	0c 94 a8 11 	jmp	0x2350	; 0x2350 <__stack+0x151>
    1160:	fc 01       	movw	r30, r24
    1162:	88 27       	eor	r24, r24
    1164:	ef 52       	subi	r30, 0x2F	; 47
    1166:	ff 4f       	sbci	r31, 0xFF	; 255
    1168:	8f 4f       	sbci	r24, 0xFF	; 255
    116a:	0c 94 b2 42 	jmp	0x8564	; 0x8564 <__tablejump2__>
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
            switch(int_value) {
    116e:	aa 20       	and	r10, r10
    1170:	21 f0       	breq	.+8      	; 0x117a <gc_execute_line+0x2ac>
    1172:	f1 e0       	ldi	r31, 0x01	; 1
    1174:	af 16       	cp	r10, r31
    1176:	e1 f1       	breq	.+120    	; 0x11f0 <gc_execute_line+0x322>
    1178:	05 c0       	rjmp	.+10     	; 0x1184 <gc_execute_line+0x2b6>
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
    117a:	23 e0       	ldi	r18, 0x03	; 3
    117c:	20 93 9e 0c 	sts	0x0C9E, r18	; 0x800c9e <gc_block+0x8>

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
    1180:	8b e0       	ldi	r24, 0x0B	; 11
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
    1182:	3b c0       	rjmp	.+118    	; 0x11fa <gc_execute_line+0x32c>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
    1184:	a0 92 9e 0c 	sts	0x0C9E, r10	; 0x800c9e <gc_block+0x8>

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
    1188:	8b e0       	ldi	r24, 0x0B	; 11
    118a:	37 c0       	rjmp	.+110    	; 0x11fa <gc_execute_line+0x32c>
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
            switch(int_value) {
    118c:	34 e0       	ldi	r19, 0x04	; 4
    118e:	a3 16       	cp	r10, r19
    1190:	59 f0       	breq	.+22     	; 0x11a8 <gc_execute_line+0x2da>
    1192:	45 e0       	ldi	r20, 0x05	; 5
    1194:	a4 16       	cp	r10, r20
    1196:	69 f0       	breq	.+26     	; 0x11b2 <gc_execute_line+0x2e4>
    1198:	83 e0       	ldi	r24, 0x03	; 3
    119a:	a8 12       	cpse	r10, r24
    119c:	2b c0       	rjmp	.+86     	; 0x11f4 <gc_execute_line+0x326>
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    119e:	80 e1       	ldi	r24, 0x10	; 16
    11a0:	80 93 a0 0c 	sts	0x0CA0, r24	; 0x800ca0 <gc_block+0xa>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
    11a4:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    11a6:	29 c0       	rjmp	.+82     	; 0x11fa <gc_execute_line+0x32c>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    11a8:	80 e2       	ldi	r24, 0x20	; 32
    11aa:	80 93 a0 0c 	sts	0x0CA0, r24	; 0x800ca0 <gc_block+0xa>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
    11ae:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    11b0:	24 c0       	rjmp	.+72     	; 0x11fa <gc_execute_line+0x32c>
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    11b2:	10 92 a0 0c 	sts	0x0CA0, r1	; 0x800ca0 <gc_block+0xa>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
    11b6:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    11b8:	20 c0       	rjmp	.+64     	; 0x11fa <gc_execute_line+0x32c>
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
            switch(int_value) {      
    11ba:	98 e0       	ldi	r25, 0x08	; 8
    11bc:	a9 16       	cp	r10, r25
    11be:	69 f0       	breq	.+26     	; 0x11da <gc_execute_line+0x30c>
    11c0:	a9 e0       	ldi	r26, 0x09	; 9
    11c2:	aa 16       	cp	r10, r26
    11c4:	89 f0       	breq	.+34     	; 0x11e8 <gc_execute_line+0x31a>
    11c6:	b7 e0       	ldi	r27, 0x07	; 7
    11c8:	ab 12       	cpse	r10, r27
    11ca:	16 c0       	rjmp	.+44     	; 0x11f8 <gc_execute_line+0x32a>
              case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
    11cc:	80 91 9f 0c 	lds	r24, 0x0C9F	; 0x800c9f <gc_block+0x9>
    11d0:	80 68       	ori	r24, 0x80	; 128
    11d2:	80 93 9f 0c 	sts	0x0C9F, r24	; 0x800c9f <gc_block+0x9>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    11d6:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {      
              case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
    11d8:	10 c0       	rjmp	.+32     	; 0x11fa <gc_execute_line+0x32c>
              case 8: gc_block.modal.coolant |= COOLANT_FLOOD_ENABLE; break;
    11da:	80 91 9f 0c 	lds	r24, 0x0C9F	; 0x800c9f <gc_block+0x9>
    11de:	80 64       	ori	r24, 0x40	; 64
    11e0:	80 93 9f 0c 	sts	0x0C9F, r24	; 0x800c9f <gc_block+0x9>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    11e4:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {      
              case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
              case 8: gc_block.modal.coolant |= COOLANT_FLOOD_ENABLE; break;
    11e6:	09 c0       	rjmp	.+18     	; 0x11fa <gc_execute_line+0x32c>
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break; // M9 disables both M7 and M8.
    11e8:	10 92 9f 0c 	sts	0x0C9F, r1	; 0x800c9f <gc_block+0x9>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    11ec:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {      
              case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
              case 8: gc_block.modal.coolant |= COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break; // M9 disables both M7 and M8.
    11ee:	05 c0       	rjmp	.+10     	; 0x11fa <gc_execute_line+0x32c>

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
    11f0:	8b e0       	ldi	r24, 0x0B	; 11
    11f2:	03 c0       	rjmp	.+6      	; 0x11fa <gc_execute_line+0x32c>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
    11f4:	8c e0       	ldi	r24, 0x0C	; 12
    11f6:	01 c0       	rjmp	.+2      	; 0x11fa <gc_execute_line+0x32c>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;            
          case 7: case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    11f8:	8d e0       	ldi	r24, 0x0D	; 13
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
        }

        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    11fa:	f6 01       	movw	r30, r12
    11fc:	02 c0       	rjmp	.+4      	; 0x1202 <gc_execute_line+0x334>
    11fe:	ee 0f       	add	r30, r30
    1200:	ff 1f       	adc	r31, r31
    1202:	8a 95       	dec	r24
    1204:	e2 f7       	brpl	.-8      	; 0x11fe <gc_execute_line+0x330>
    1206:	97 01       	movw	r18, r14
    1208:	2e 23       	and	r18, r30
    120a:	3f 23       	and	r19, r31
    120c:	23 2b       	or	r18, r19
    120e:	11 f0       	breq	.+4      	; 0x1214 <gc_execute_line+0x346>
    1210:	0c 94 aa 11 	jmp	0x2354	; 0x2354 <__stack+0x155>
        command_words |= bit(word_bit);
    1214:	ee 2a       	or	r14, r30
    1216:	ff 2a       	or	r15, r31
        break;
    1218:	c8 c0       	rjmp	.+400    	; 0x13aa <gc_execute_line+0x4dc>
      default:

        /* Non-Command Words: This initial parsing phase only checks for repeats of the remaining
           legal g-code words and stores their value. Error-checking is performed later since some
           words (I,J,K,L,P,R) have multiple connotations and/or depend on the issued commands. */
        switch(letter){
    121a:	81 2f       	mov	r24, r17
    121c:	90 e0       	ldi	r25, 0x00	; 0
    121e:	fc 01       	movw	r30, r24
    1220:	e6 54       	subi	r30, 0x46	; 70
    1222:	f1 09       	sbc	r31, r1
    1224:	e5 31       	cpi	r30, 0x15	; 21
    1226:	f1 05       	cpc	r31, r1
    1228:	10 f0       	brcs	.+4      	; 0x122e <gc_execute_line+0x360>
    122a:	0c 94 ac 11 	jmp	0x2358	; 0x2358 <__stack+0x159>
    122e:	88 27       	eor	r24, r24
    1230:	e0 51       	subi	r30, 0x10	; 16
    1232:	ff 4f       	sbci	r31, 0xFF	; 255
    1234:	8f 4f       	sbci	r24, 0xFF	; 255
    1236:	0c 94 b2 42 	jmp	0x8564	; 0x8564 <__tablejump2__>
          // case 'A': // Not supported
          // case 'B': // Not supported
          // case 'C': // Not supported
          // case 'D': // Not supported
          case 'F': word_bit = WORD_F; gc_block.values.f = value; break;
    123a:	40 92 a2 0c 	sts	0x0CA2, r4	; 0x800ca2 <gc_block+0xc>
    123e:	50 92 a3 0c 	sts	0x0CA3, r5	; 0x800ca3 <gc_block+0xd>
    1242:	60 92 a4 0c 	sts	0x0CA4, r6	; 0x800ca4 <gc_block+0xe>
    1246:	70 92 a5 0c 	sts	0x0CA5, r7	; 0x800ca5 <gc_block+0xf>
    124a:	80 e0       	ldi	r24, 0x00	; 0
    124c:	8d c0       	rjmp	.+282    	; 0x1368 <gc_execute_line+0x49a>
          // case 'H': // Not supported
          case 'I': word_bit = WORD_I; gc_block.values.ijk[X_AXIS] = value; ijk_words |= (1<<X_AXIS); break;
    124e:	40 92 a6 0c 	sts	0x0CA6, r4	; 0x800ca6 <gc_block+0x10>
    1252:	50 92 a7 0c 	sts	0x0CA7, r5	; 0x800ca7 <gc_block+0x11>
    1256:	60 92 a8 0c 	sts	0x0CA8, r6	; 0x800ca8 <gc_block+0x12>
    125a:	70 92 a9 0c 	sts	0x0CA9, r7	; 0x800ca9 <gc_block+0x13>
    125e:	ff a1       	ldd	r31, Y+39	; 0x27
    1260:	f1 60       	ori	r31, 0x01	; 1
    1262:	ff a3       	std	Y+39, r31	; 0x27
    1264:	81 e0       	ldi	r24, 0x01	; 1
    1266:	80 c0       	rjmp	.+256    	; 0x1368 <gc_execute_line+0x49a>
          case 'J': word_bit = WORD_J; gc_block.values.ijk[Y_AXIS] = value; ijk_words |= (1<<Y_AXIS); break;
    1268:	40 92 aa 0c 	sts	0x0CAA, r4	; 0x800caa <gc_block+0x14>
    126c:	50 92 ab 0c 	sts	0x0CAB, r5	; 0x800cab <gc_block+0x15>
    1270:	60 92 ac 0c 	sts	0x0CAC, r6	; 0x800cac <gc_block+0x16>
    1274:	70 92 ad 0c 	sts	0x0CAD, r7	; 0x800cad <gc_block+0x17>
    1278:	2f a1       	ldd	r18, Y+39	; 0x27
    127a:	22 60       	ori	r18, 0x02	; 2
    127c:	2f a3       	std	Y+39, r18	; 0x27
    127e:	82 e0       	ldi	r24, 0x02	; 2
    1280:	73 c0       	rjmp	.+230    	; 0x1368 <gc_execute_line+0x49a>
          case 'K': word_bit = WORD_K; gc_block.values.ijk[Z_AXIS] = value; ijk_words |= (1<<Z_AXIS); break;
    1282:	40 92 ae 0c 	sts	0x0CAE, r4	; 0x800cae <gc_block+0x18>
    1286:	50 92 af 0c 	sts	0x0CAF, r5	; 0x800caf <gc_block+0x19>
    128a:	60 92 b0 0c 	sts	0x0CB0, r6	; 0x800cb0 <gc_block+0x1a>
    128e:	70 92 b1 0c 	sts	0x0CB1, r7	; 0x800cb1 <gc_block+0x1b>
    1292:	3f a1       	ldd	r19, Y+39	; 0x27
    1294:	34 60       	ori	r19, 0x04	; 4
    1296:	3f a3       	std	Y+39, r19	; 0x27
    1298:	83 e0       	ldi	r24, 0x03	; 3
    129a:	66 c0       	rjmp	.+204    	; 0x1368 <gc_execute_line+0x49a>
          case 'L': word_bit = WORD_L; gc_block.values.l = int_value; break;
    129c:	a0 92 b2 0c 	sts	0x0CB2, r10	; 0x800cb2 <gc_block+0x1c>
    12a0:	84 e0       	ldi	r24, 0x04	; 4
    12a2:	62 c0       	rjmp	.+196    	; 0x1368 <gc_execute_line+0x49a>
          case 'N': word_bit = WORD_N; gc_block.values.n = trunc(value); break;
    12a4:	c3 01       	movw	r24, r6
    12a6:	b2 01       	movw	r22, r4
    12a8:	0e 94 d4 3f 	call	0x7fa8	; 0x7fa8 <__fixsfsi>
    12ac:	60 93 b3 0c 	sts	0x0CB3, r22	; 0x800cb3 <gc_block+0x1d>
    12b0:	70 93 b4 0c 	sts	0x0CB4, r23	; 0x800cb4 <gc_block+0x1e>
    12b4:	80 93 b5 0c 	sts	0x0CB5, r24	; 0x800cb5 <gc_block+0x1f>
    12b8:	90 93 b6 0c 	sts	0x0CB6, r25	; 0x800cb6 <gc_block+0x20>
    12bc:	85 e0       	ldi	r24, 0x05	; 5
    12be:	54 c0       	rjmp	.+168    	; 0x1368 <gc_execute_line+0x49a>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
    12c0:	40 92 b7 0c 	sts	0x0CB7, r4	; 0x800cb7 <gc_block+0x21>
    12c4:	50 92 b8 0c 	sts	0x0CB8, r5	; 0x800cb8 <gc_block+0x22>
    12c8:	60 92 b9 0c 	sts	0x0CB9, r6	; 0x800cb9 <gc_block+0x23>
    12cc:	70 92 ba 0c 	sts	0x0CBA, r7	; 0x800cba <gc_block+0x24>
    12d0:	86 e0       	ldi	r24, 0x06	; 6
    12d2:	4a c0       	rjmp	.+148    	; 0x1368 <gc_execute_line+0x49a>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
    12d4:	40 92 bb 0c 	sts	0x0CBB, r4	; 0x800cbb <gc_block+0x25>
    12d8:	50 92 bc 0c 	sts	0x0CBC, r5	; 0x800cbc <gc_block+0x26>
    12dc:	60 92 bd 0c 	sts	0x0CBD, r6	; 0x800cbd <gc_block+0x27>
    12e0:	70 92 be 0c 	sts	0x0CBE, r7	; 0x800cbe <gc_block+0x28>
    12e4:	87 e0       	ldi	r24, 0x07	; 7
    12e6:	40 c0       	rjmp	.+128    	; 0x1368 <gc_execute_line+0x49a>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
    12e8:	40 92 bf 0c 	sts	0x0CBF, r4	; 0x800cbf <gc_block+0x29>
    12ec:	50 92 c0 0c 	sts	0x0CC0, r5	; 0x800cc0 <gc_block+0x2a>
    12f0:	60 92 c1 0c 	sts	0x0CC1, r6	; 0x800cc1 <gc_block+0x2b>
    12f4:	70 92 c2 0c 	sts	0x0CC2, r7	; 0x800cc2 <gc_block+0x2c>
    12f8:	88 e0       	ldi	r24, 0x08	; 8
    12fa:	36 c0       	rjmp	.+108    	; 0x1368 <gc_execute_line+0x49a>
          case 'T': word_bit = WORD_T; 
						if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
    12fc:	20 e0       	ldi	r18, 0x00	; 0
    12fe:	30 e0       	ldi	r19, 0x00	; 0
    1300:	4f e7       	ldi	r20, 0x7F	; 127
    1302:	53 e4       	ldi	r21, 0x43	; 67
    1304:	c3 01       	movw	r24, r6
    1306:	b2 01       	movw	r22, r4
    1308:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    130c:	18 16       	cp	r1, r24
    130e:	14 f4       	brge	.+4      	; 0x1314 <gc_execute_line+0x446>
    1310:	0c 94 ae 11 	jmp	0x235c	; 0x235c <__stack+0x15d>
						gc_block.values.t = int_value;
    1314:	a0 92 c3 0c 	sts	0x0CC3, r10	; 0x800cc3 <gc_block+0x2d>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; 
    1318:	89 e0       	ldi	r24, 0x09	; 9
						if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
						gc_block.values.t = int_value;
						break;
    131a:	26 c0       	rjmp	.+76     	; 0x1368 <gc_execute_line+0x49a>
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
    131c:	40 92 c4 0c 	sts	0x0CC4, r4	; 0x800cc4 <gc_block+0x2e>
    1320:	50 92 c5 0c 	sts	0x0CC5, r5	; 0x800cc5 <gc_block+0x2f>
    1324:	60 92 c6 0c 	sts	0x0CC6, r6	; 0x800cc6 <gc_block+0x30>
    1328:	70 92 c7 0c 	sts	0x0CC7, r7	; 0x800cc7 <gc_block+0x31>
    132c:	4d a1       	ldd	r20, Y+37	; 0x25
    132e:	41 60       	ori	r20, 0x01	; 1
    1330:	4d a3       	std	Y+37, r20	; 0x25
    1332:	8a e0       	ldi	r24, 0x0A	; 10
    1334:	19 c0       	rjmp	.+50     	; 0x1368 <gc_execute_line+0x49a>
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
    1336:	40 92 c8 0c 	sts	0x0CC8, r4	; 0x800cc8 <gc_block+0x32>
    133a:	50 92 c9 0c 	sts	0x0CC9, r5	; 0x800cc9 <gc_block+0x33>
    133e:	60 92 ca 0c 	sts	0x0CCA, r6	; 0x800cca <gc_block+0x34>
    1342:	70 92 cb 0c 	sts	0x0CCB, r7	; 0x800ccb <gc_block+0x35>
    1346:	8d a1       	ldd	r24, Y+37	; 0x25
    1348:	82 60       	ori	r24, 0x02	; 2
    134a:	8d a3       	std	Y+37, r24	; 0x25
    134c:	8b e0       	ldi	r24, 0x0B	; 11
    134e:	0c c0       	rjmp	.+24     	; 0x1368 <gc_execute_line+0x49a>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
    1350:	40 92 cc 0c 	sts	0x0CCC, r4	; 0x800ccc <gc_block+0x36>
    1354:	50 92 cd 0c 	sts	0x0CCD, r5	; 0x800ccd <gc_block+0x37>
    1358:	60 92 ce 0c 	sts	0x0CCE, r6	; 0x800cce <gc_block+0x38>
    135c:	70 92 cf 0c 	sts	0x0CCF, r7	; 0x800ccf <gc_block+0x39>
    1360:	9d a1       	ldd	r25, Y+37	; 0x25
    1362:	94 60       	ori	r25, 0x04	; 4
    1364:	9d a3       	std	Y+37, r25	; 0x25
    1366:	8c e0       	ldi	r24, 0x0C	; 12
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        }

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    1368:	56 01       	movw	r10, r12
    136a:	08 2e       	mov	r0, r24
    136c:	02 c0       	rjmp	.+4      	; 0x1372 <gc_execute_line+0x4a4>
    136e:	aa 0c       	add	r10, r10
    1370:	bb 1c       	adc	r11, r11
    1372:	0a 94       	dec	r0
    1374:	e2 f7       	brpl	.-8      	; 0x136e <gc_execute_line+0x4a0>
    1376:	91 01       	movw	r18, r2
    1378:	2a 21       	and	r18, r10
    137a:	3b 21       	and	r19, r11
    137c:	23 2b       	or	r18, r19
    137e:	09 f0       	breq	.+2      	; 0x1382 <gc_execute_line+0x4b4>
    1380:	ef c7       	rjmp	.+4062   	; 0x2360 <__stack+0x161>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
    1382:	d4 01       	movw	r26, r8
    1384:	02 c0       	rjmp	.+4      	; 0x138a <gc_execute_line+0x4bc>
    1386:	b5 95       	asr	r27
    1388:	a7 95       	ror	r26
    138a:	8a 95       	dec	r24
    138c:	e2 f7       	brpl	.-8      	; 0x1386 <gc_execute_line+0x4b8>
    138e:	a0 ff       	sbrs	r26, 0
    1390:	0a c0       	rjmp	.+20     	; 0x13a6 <gc_execute_line+0x4d8>
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    1392:	20 e0       	ldi	r18, 0x00	; 0
    1394:	30 e0       	ldi	r19, 0x00	; 0
    1396:	a9 01       	movw	r20, r18
    1398:	c3 01       	movw	r24, r6
    139a:	b2 01       	movw	r22, r4
    139c:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    13a0:	88 23       	and	r24, r24
    13a2:	0c f4       	brge	.+2      	; 0x13a6 <gc_execute_line+0x4d8>
    13a4:	df c7       	rjmp	.+4030   	; 0x2364 <__stack+0x165>
        }
        value_words |= bit(word_bit); // Flag to indicate parameter assigned.
    13a6:	2a 28       	or	r2, r10
    13a8:	3b 28       	or	r3, r11
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
  else { char_counter = 0; }

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    13aa:	89 81       	ldd	r24, Y+1	; 0x01
    13ac:	ef 8d       	ldd	r30, Y+31	; 0x1f
    13ae:	f8 a1       	ldd	r31, Y+32	; 0x20
    13b0:	e8 0f       	add	r30, r24
    13b2:	f1 1d       	adc	r31, r1
    13b4:	10 81       	ld	r17, Z
    13b6:	11 11       	cpse	r17, r1
    13b8:	d7 cd       	rjmp	.-1106   	; 0xf68 <gc_execute_line+0x9a>

  // [0. Non-specific/common error-checks and miscellaneous setup]:

  // Determine implicit axis command conditions. Axis words have been passed, but no explicit axis
  // command has been sent. If so, set axis command to current motion mode.
  if (axis_words) {
    13ba:	bd a1       	ldd	r27, Y+37	; 0x25
    13bc:	bb 23       	and	r27, r27
    13be:	29 f0       	breq	.+10     	; 0x13ca <gc_execute_line+0x4fc>
    if (!axis_command) { axis_command = AXIS_COMMAND_MOTION_MODE; } // Assign implicit motion-mode
    13c0:	ee a1       	ldd	r30, Y+38	; 0x26
    13c2:	e1 11       	cpse	r30, r1
    13c4:	02 c0       	rjmp	.+4      	; 0x13ca <gc_execute_line+0x4fc>
    13c6:	f2 e0       	ldi	r31, 0x02	; 2
    13c8:	fe a3       	std	Y+38, r31	; 0x26
  }

  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    13ca:	25 fe       	sbrs	r2, 5
    13cc:	0e c0       	rjmp	.+28     	; 0x13ea <gc_execute_line+0x51c>
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    13ce:	80 91 b3 0c 	lds	r24, 0x0CB3	; 0x800cb3 <gc_block+0x1d>
    13d2:	90 91 b4 0c 	lds	r25, 0x0CB4	; 0x800cb4 <gc_block+0x1e>
    13d6:	a0 91 b5 0c 	lds	r26, 0x0CB5	; 0x800cb5 <gc_block+0x1f>
    13da:	b0 91 b6 0c 	lds	r27, 0x0CB6	; 0x800cb6 <gc_block+0x20>
    13de:	81 38       	cpi	r24, 0x81	; 129
    13e0:	96 49       	sbci	r25, 0x96	; 150
    13e2:	a8 49       	sbci	r26, 0x98	; 152
    13e4:	b1 05       	cpc	r27, r1
    13e6:	0c f0       	brlt	.+2      	; 0x13ea <gc_execute_line+0x51c>
    13e8:	bf c7       	rjmp	.+3966   	; 0x2368 <__stack+0x169>
  // [1. Comments ]: MSG's NOT SUPPORTED. Comment handling performed by protocol.

  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  // NOTE: For jogging, ignore prior feed rate mode. Enforce G94 and check for required F word.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    13ea:	38 a5       	ldd	r19, Y+40	; 0x28
    13ec:	33 23       	and	r19, r19
    13ee:	e1 f0       	breq	.+56     	; 0x1428 <gc_execute_line+0x55a>
    if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); }
    13f0:	20 fe       	sbrs	r2, 0
    13f2:	bc c7       	rjmp	.+3960   	; 0x236c <__stack+0x16d>
    if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    13f4:	80 91 99 0c 	lds	r24, 0x0C99	; 0x800c99 <gc_block+0x3>
    13f8:	81 30       	cpi	r24, 0x01	; 1
    13fa:	09 f0       	breq	.+2      	; 0x13fe <gc_execute_line+0x530>
    13fc:	54 c0       	rjmp	.+168    	; 0x14a6 <gc_execute_line+0x5d8>
    13fe:	06 e9       	ldi	r16, 0x96	; 150
    1400:	1c e0       	ldi	r17, 0x0C	; 12
    1402:	23 e3       	ldi	r18, 0x33	; 51
    1404:	33 e3       	ldi	r19, 0x33	; 51
    1406:	4b ec       	ldi	r20, 0xCB	; 203
    1408:	51 e4       	ldi	r21, 0x41	; 65
    140a:	d8 01       	movw	r26, r16
    140c:	1c 96       	adiw	r26, 0x0c	; 12
    140e:	6d 91       	ld	r22, X+
    1410:	7d 91       	ld	r23, X+
    1412:	8d 91       	ld	r24, X+
    1414:	9c 91       	ld	r25, X
    1416:	1f 97       	sbiw	r26, 0x0f	; 15
    1418:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    141c:	f8 01       	movw	r30, r16
    141e:	64 87       	std	Z+12, r22	; 0x0c
    1420:	75 87       	std	Z+13, r23	; 0x0d
    1422:	86 87       	std	Z+14, r24	; 0x0e
    1424:	97 87       	std	Z+15, r25	; 0x0f
    1426:	3f c0       	rjmp	.+126    	; 0x14a6 <gc_execute_line+0x5d8>
  } else {
    if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    1428:	80 91 98 0c 	lds	r24, 0x0C98	; 0x800c98 <gc_block+0x2>
    142c:	81 30       	cpi	r24, 0x01	; 1
    142e:	61 f4       	brne	.+24     	; 0x1448 <gc_execute_line+0x57a>
      // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
      if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    1430:	fe a1       	ldd	r31, Y+38	; 0x26
    1432:	f2 30       	cpi	r31, 0x02	; 2
    1434:	c1 f5       	brne	.+112    	; 0x14a6 <gc_execute_line+0x5d8>
        if ((gc_block.modal.motion != MOTION_MODE_NONE) && (gc_block.modal.motion != MOTION_MODE_SEEK)) {
    1436:	80 91 97 0c 	lds	r24, 0x0C97	; 0x800c97 <gc_block+0x1>
    143a:	80 35       	cpi	r24, 0x50	; 80
    143c:	a1 f1       	breq	.+104    	; 0x14a6 <gc_execute_line+0x5d8>
    143e:	88 23       	and	r24, r24
    1440:	91 f1       	breq	.+100    	; 0x14a6 <gc_execute_line+0x5d8>
          if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    1442:	20 fe       	sbrs	r2, 0
    1444:	95 c7       	rjmp	.+3882   	; 0x2370 <__stack+0x171>
    1446:	2f c0       	rjmp	.+94     	; 0x14a6 <gc_execute_line+0x5d8>
      // value in the block. If no F word is passed with a motion command that requires a feed rate, this will error
      // out in the motion modes error-checking. However, if no F word is passed with NO motion command that requires
      // a feed rate, we simply move on and the state feed rate value gets updated to zero and remains undefined.
    } else { // = G94
      // - In units per mm mode: If F word passed, ensure value is in mm/min, otherwise push last state value.
      if (gc_state.modal.feed_rate == FEED_RATE_MODE_UNITS_PER_MIN) { // Last state is also G94
    1448:	80 91 57 0c 	lds	r24, 0x0C57	; 0x800c57 <gc_state+0x1>
    144c:	81 11       	cpse	r24, r1
    144e:	2b c0       	rjmp	.+86     	; 0x14a6 <gc_execute_line+0x5d8>
        if (bit_istrue(value_words,bit(WORD_F))) {
    1450:	20 fe       	sbrs	r2, 0
    1452:	19 c0       	rjmp	.+50     	; 0x1486 <gc_execute_line+0x5b8>
          if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    1454:	80 91 99 0c 	lds	r24, 0x0C99	; 0x800c99 <gc_block+0x3>
    1458:	81 30       	cpi	r24, 0x01	; 1
    145a:	29 f5       	brne	.+74     	; 0x14a6 <gc_execute_line+0x5d8>
    145c:	06 e9       	ldi	r16, 0x96	; 150
    145e:	1c e0       	ldi	r17, 0x0C	; 12
    1460:	23 e3       	ldi	r18, 0x33	; 51
    1462:	33 e3       	ldi	r19, 0x33	; 51
    1464:	4b ec       	ldi	r20, 0xCB	; 203
    1466:	51 e4       	ldi	r21, 0x41	; 65
    1468:	d8 01       	movw	r26, r16
    146a:	1c 96       	adiw	r26, 0x0c	; 12
    146c:	6d 91       	ld	r22, X+
    146e:	7d 91       	ld	r23, X+
    1470:	8d 91       	ld	r24, X+
    1472:	9c 91       	ld	r25, X
    1474:	1f 97       	sbiw	r26, 0x0f	; 15
    1476:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    147a:	f8 01       	movw	r30, r16
    147c:	64 87       	std	Z+12, r22	; 0x0c
    147e:	75 87       	std	Z+13, r23	; 0x0d
    1480:	86 87       	std	Z+14, r24	; 0x0e
    1482:	97 87       	std	Z+15, r25	; 0x0f
    1484:	10 c0       	rjmp	.+32     	; 0x14a6 <gc_execute_line+0x5d8>
        } else {
          gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
    1486:	80 91 65 0c 	lds	r24, 0x0C65	; 0x800c65 <gc_state+0xf>
    148a:	90 91 66 0c 	lds	r25, 0x0C66	; 0x800c66 <gc_state+0x10>
    148e:	a0 91 67 0c 	lds	r26, 0x0C67	; 0x800c67 <gc_state+0x11>
    1492:	b0 91 68 0c 	lds	r27, 0x0C68	; 0x800c68 <gc_state+0x12>
    1496:	80 93 a2 0c 	sts	0x0CA2, r24	; 0x800ca2 <gc_block+0xc>
    149a:	90 93 a3 0c 	sts	0x0CA3, r25	; 0x800ca3 <gc_block+0xd>
    149e:	a0 93 a4 0c 	sts	0x0CA4, r26	; 0x800ca4 <gc_block+0xe>
    14a2:	b0 93 a5 0c 	sts	0x0CA5, r27	; 0x800ca5 <gc_block+0xf>
    }
  }
  // bit_false(value_words,bit(WORD_F)); // NOTE: Single-meaning value word. Set at end of error-checking.

  // [4. Set spindle speed ]: S is negative (done.)
  if (bit_isfalse(value_words,bit(WORD_S))) { gc_block.values.s = gc_state.spindle_speed; }
    14a6:	30 fc       	sbrc	r3, 0
    14a8:	10 c0       	rjmp	.+32     	; 0x14ca <gc_execute_line+0x5fc>
    14aa:	80 91 61 0c 	lds	r24, 0x0C61	; 0x800c61 <gc_state+0xb>
    14ae:	90 91 62 0c 	lds	r25, 0x0C62	; 0x800c62 <gc_state+0xc>
    14b2:	a0 91 63 0c 	lds	r26, 0x0C63	; 0x800c63 <gc_state+0xd>
    14b6:	b0 91 64 0c 	lds	r27, 0x0C64	; 0x800c64 <gc_state+0xe>
    14ba:	80 93 bf 0c 	sts	0x0CBF, r24	; 0x800cbf <gc_block+0x29>
    14be:	90 93 c0 0c 	sts	0x0CC0, r25	; 0x800cc0 <gc_block+0x2a>
    14c2:	a0 93 c1 0c 	sts	0x0CC1, r26	; 0x800cc1 <gc_block+0x2b>
    14c6:	b0 93 c2 0c 	sts	0x0CC2, r27	; 0x800cc2 <gc_block+0x2c>
      }
    }
  #endif

  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    14ca:	80 91 96 0c 	lds	r24, 0x0C96	; 0x800c96 <gc_block>
    14ce:	84 30       	cpi	r24, 0x04	; 4
    14d0:	21 f4       	brne	.+8      	; 0x14da <gc_execute_line+0x60c>
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    14d2:	26 fe       	sbrs	r2, 6
    14d4:	4f c7       	rjmp	.+3742   	; 0x2374 <__stack+0x175>
    bit_false(value_words,bit(WORD_P));
    14d6:	e8 94       	clt
    14d8:	26 f8       	bld	r2, 6
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    14da:	80 91 9b 0c 	lds	r24, 0x0C9B	; 0x800c9b <gc_block+0x5>
    14de:	88 23       	and	r24, r24
    14e0:	49 f0       	breq	.+18     	; 0x14f4 <gc_execute_line+0x626>
    14e2:	81 30       	cpi	r24, 0x01	; 1
    14e4:	09 f4       	brne	.+2      	; 0x14e8 <gc_execute_line+0x61a>
    14e6:	94 c7       	rjmp	.+3880   	; 0x2410 <__stack+0x211>
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
      axis_linear = X_AXIS;
    14e8:	1a aa       	std	Y+50, r1	; 0x32
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
    14ea:	f2 e0       	ldi	r31, 0x02	; 2
    14ec:	f9 a7       	std	Y+41, r31	; 0x29
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
    14ee:	21 e0       	ldi	r18, 0x01	; 1
    14f0:	29 a3       	std	Y+33, r18	; 0x21
    14f2:	93 c7       	rjmp	.+3878   	; 0x241a <__stack+0x21b>
  }

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    14f4:	80 91 99 0c 	lds	r24, 0x0C99	; 0x800c99 <gc_block+0x3>
    14f8:	81 30       	cpi	r24, 0x01	; 1
    14fa:	a1 f5       	brne	.+104    	; 0x1564 <gc_execute_line+0x696>
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    14fc:	32 e0       	ldi	r19, 0x02	; 2
    14fe:	3a ab       	std	Y+50, r19	; 0x32

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    1500:	41 e0       	ldi	r20, 0x01	; 1
    1502:	49 a7       	std	Y+41, r20	; 0x29
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    1504:	19 a2       	std	Y+33, r1	; 0x21
    1506:	0f 2e       	mov	r0, r31
    1508:	f6 e9       	ldi	r31, 0x96	; 150
    150a:	af 2e       	mov	r10, r31
    150c:	fc e0       	ldi	r31, 0x0C	; 12
    150e:	bf 2e       	mov	r11, r31
    1510:	f0 2d       	mov	r31, r0
    1512:	00 e0       	ldi	r16, 0x00	; 0
    1514:	10 e0       	ldi	r17, 0x00	; 0
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
      if (bit_istrue(axis_words,bit(idx)) ) {
    1516:	8d a1       	ldd	r24, Y+37	; 0x25
    1518:	c8 2e       	mov	r12, r24
    151a:	d1 2c       	mov	r13, r1
    151c:	c6 01       	movw	r24, r12
    151e:	00 2e       	mov	r0, r16
    1520:	02 c0       	rjmp	.+4      	; 0x1526 <gc_execute_line+0x658>
    1522:	95 95       	asr	r25
    1524:	87 95       	ror	r24
    1526:	0a 94       	dec	r0
    1528:	e2 f7       	brpl	.-8      	; 0x1522 <gc_execute_line+0x654>
    152a:	80 ff       	sbrs	r24, 0
    152c:	12 c0       	rjmp	.+36     	; 0x1552 <gc_execute_line+0x684>
        gc_block.values.xyz[idx] *= MM_PER_INCH;
    152e:	23 e3       	ldi	r18, 0x33	; 51
    1530:	33 e3       	ldi	r19, 0x33	; 51
    1532:	4b ec       	ldi	r20, 0xCB	; 203
    1534:	51 e4       	ldi	r21, 0x41	; 65
    1536:	d5 01       	movw	r26, r10
    1538:	9e 96       	adiw	r26, 0x2e	; 46
    153a:	6d 91       	ld	r22, X+
    153c:	7d 91       	ld	r23, X+
    153e:	8d 91       	ld	r24, X+
    1540:	9c 91       	ld	r25, X
    1542:	d1 97       	sbiw	r26, 0x31	; 49
    1544:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    1548:	f5 01       	movw	r30, r10
    154a:	66 a7       	std	Z+46, r22	; 0x2e
    154c:	77 a7       	std	Z+47, r23	; 0x2f
    154e:	80 ab       	std	Z+48, r24	; 0x30
    1550:	91 ab       	std	Z+49, r25	; 0x31
    1552:	0f 5f       	subi	r16, 0xFF	; 255
    1554:	1f 4f       	sbci	r17, 0xFF	; 255
    1556:	f4 e0       	ldi	r31, 0x04	; 4
    1558:	af 0e       	add	r10, r31
    155a:	b1 1c       	adc	r11, r1

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    155c:	03 30       	cpi	r16, 0x03	; 3
    155e:	11 05       	cpc	r17, r1
    1560:	e9 f6       	brne	.-70     	; 0x151c <gc_execute_line+0x64e>
    1562:	05 c0       	rjmp	.+10     	; 0x156e <gc_execute_line+0x6a0>
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    1564:	22 e0       	ldi	r18, 0x02	; 2
    1566:	2a ab       	std	Y+50, r18	; 0x32

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    1568:	31 e0       	ldi	r19, 0x01	; 1
    156a:	39 a7       	std	Y+41, r19	; 0x29
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    156c:	19 a2       	std	Y+33, r1	; 0x21
  // [14. Cutter length compensation ]: G43 NOT SUPPORTED, but G43.1 and G49 are.
  // [G43.1 Errors]: Motion command in same line.
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    156e:	4e a1       	ldd	r20, Y+38	; 0x26
    1570:	43 30       	cpi	r20, 0x03	; 3
    1572:	41 f4       	brne	.+16     	; 0x1584 <gc_execute_line+0x6b6>
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
    1574:	80 91 9c 0c 	lds	r24, 0x0C9C	; 0x800c9c <gc_block+0x6>
    1578:	81 30       	cpi	r24, 0x01	; 1
    157a:	21 f4       	brne	.+8      	; 0x1584 <gc_execute_line+0x6b6>
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    157c:	8d a1       	ldd	r24, Y+37	; 0x25
    157e:	84 30       	cpi	r24, 0x04	; 4
    1580:	09 f0       	breq	.+2      	; 0x1584 <gc_execute_line+0x6b6>
    1582:	fa c6       	rjmp	.+3572   	; 0x2378 <__stack+0x179>
  // TODO: An EEPROM read of the coordinate data may require a buffer sync when the cycle
  // is active. The read pauses the processor temporarily and may cause a rare crash. For
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  float block_coord_system[N_AXIS];
  memcpy(block_coord_system,gc_state.coord_system,sizeof(gc_state.coord_system));
    1584:	8c e0       	ldi	r24, 0x0C	; 12
    1586:	ea e7       	ldi	r30, 0x7A	; 122
    1588:	fc e0       	ldi	r31, 0x0C	; 12
    158a:	de 01       	movw	r26, r28
    158c:	16 96       	adiw	r26, 0x06	; 6
    158e:	01 90       	ld	r0, Z+
    1590:	0d 92       	st	X+, r0
    1592:	8a 95       	dec	r24
    1594:	e1 f7       	brne	.-8      	; 0x158e <gc_execute_line+0x6c0>
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    1596:	f1 fe       	sbrs	r15, 1
    1598:	11 c0       	rjmp	.+34     	; 0x15bc <gc_execute_line+0x6ee>
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    159a:	80 91 9d 0c 	lds	r24, 0x0C9D	; 0x800c9d <gc_block+0x7>
    159e:	87 30       	cpi	r24, 0x07	; 7
    15a0:	08 f0       	brcs	.+2      	; 0x15a4 <gc_execute_line+0x6d6>
    15a2:	ec c6       	rjmp	.+3544   	; 0x237c <__stack+0x17d>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    15a4:	90 91 5c 0c 	lds	r25, 0x0C5C	; 0x800c5c <gc_state+0x6>
    15a8:	89 17       	cp	r24, r25
    15aa:	41 f0       	breq	.+16     	; 0x15bc <gc_execute_line+0x6ee>
      if (!(settings_read_coord_data(gc_block.modal.coord_select,block_coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    15ac:	be 01       	movw	r22, r28
    15ae:	6a 5f       	subi	r22, 0xFA	; 250
    15b0:	7f 4f       	sbci	r23, 0xFF	; 255
    15b2:	0e 94 f0 25 	call	0x4be0	; 0x4be0 <settings_read_coord_data>
    15b6:	88 23       	and	r24, r24
    15b8:	09 f4       	brne	.+2      	; 0x15bc <gc_execute_line+0x6ee>
    15ba:	e2 c6       	rjmp	.+3524   	; 0x2380 <__stack+0x181>
  // [19. Remaining non-modal actions ]: Check go to predefined position, set G10, or set axis offsets.
  // NOTE: We need to separate the non-modal commands that are axis word-using (G10/G28/G30/G92), as these
  // commands all treat axis words differently. G10 as absolute offsets or computes current position as
  // the axis value, G92 similarly to G10 L20, and G28/30 as an intermediate target position that observes
  // all the current coordinate system and G92 offsets.
  switch (gc_block.non_modal_command) {
    15bc:	b0 90 96 0c 	lds	r11, 0x0C96	; 0x800c96 <gc_block>
    15c0:	9a e0       	ldi	r25, 0x0A	; 10
    15c2:	b9 16       	cp	r11, r25
    15c4:	29 f0       	breq	.+10     	; 0x15d0 <gc_execute_line+0x702>
    15c6:	ac e5       	ldi	r26, 0x5C	; 92
    15c8:	ba 16       	cp	r11, r26
    15ca:	09 f4       	brne	.+2      	; 0x15ce <gc_execute_line+0x700>
    15cc:	9a c0       	rjmp	.+308    	; 0x1702 <gc_execute_line+0x834>
    15ce:	0e c1       	rjmp	.+540    	; 0x17ec <gc_execute_line+0x91e>
    case NON_MODAL_SET_COORDINATE_DATA:
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    15d0:	bd a1       	ldd	r27, Y+37	; 0x25
    15d2:	bb 23       	and	r27, r27
    15d4:	09 f4       	brne	.+2      	; 0x15d8 <gc_execute_line+0x70a>
    15d6:	d6 c6       	rjmp	.+3500   	; 0x2384 <__stack+0x185>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    15d8:	c1 01       	movw	r24, r2
    15da:	80 75       	andi	r24, 0x50	; 80
    15dc:	99 27       	eor	r25, r25
    15de:	89 2b       	or	r24, r25
    15e0:	09 f4       	brne	.+2      	; 0x15e4 <gc_execute_line+0x716>
    15e2:	d2 c6       	rjmp	.+3492   	; 0x2388 <__stack+0x189>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
    15e4:	60 91 b7 0c 	lds	r22, 0x0CB7	; 0x800cb7 <gc_block+0x21>
    15e8:	70 91 b8 0c 	lds	r23, 0x0CB8	; 0x800cb8 <gc_block+0x22>
    15ec:	80 91 b9 0c 	lds	r24, 0x0CB9	; 0x800cb9 <gc_block+0x23>
    15f0:	90 91 ba 0c 	lds	r25, 0x0CBA	; 0x800cba <gc_block+0x24>
    15f4:	0e 94 71 42 	call	0x84e2	; 0x84e2 <trunc>
    15f8:	0e 94 d9 3f 	call	0x7fb2	; 0x7fb2 <__fixunssfsi>
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    15fc:	67 30       	cpi	r22, 0x07	; 7
    15fe:	08 f0       	brcs	.+2      	; 0x1602 <gc_execute_line+0x734>
    1600:	c5 c6       	rjmp	.+3466   	; 0x238c <__stack+0x18d>
      if (gc_block.values.l != 20) {
    1602:	80 91 b2 0c 	lds	r24, 0x0CB2	; 0x800cb2 <gc_block+0x1c>
    1606:	84 31       	cpi	r24, 0x14	; 20
    1608:	29 f0       	breq	.+10     	; 0x1614 <gc_execute_line+0x746>
        if (gc_block.values.l == 2) {
    160a:	82 30       	cpi	r24, 0x02	; 2
    160c:	09 f0       	breq	.+2      	; 0x1610 <gc_execute_line+0x742>
    160e:	c0 c6       	rjmp	.+3456   	; 0x2390 <__stack+0x191>
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    1610:	27 fc       	sbrc	r2, 7
    1612:	c0 c6       	rjmp	.+3456   	; 0x2394 <__stack+0x195>
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
      }
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
    1614:	ef ea       	ldi	r30, 0xAF	; 175
    1616:	2e 22       	and	r2, r30

      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
    1618:	66 23       	and	r22, r22
    161a:	19 f0       	breq	.+6      	; 0x1622 <gc_execute_line+0x754>
    161c:	61 50       	subi	r22, 0x01	; 1
    161e:	6f 8f       	std	Y+31, r22	; 0x1f
    1620:	03 c0       	rjmp	.+6      	; 0x1628 <gc_execute_line+0x75a>
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
    1622:	f0 91 9d 0c 	lds	r31, 0x0C9D	; 0x800c9d <gc_block+0x7>
    1626:	ff 8f       	std	Y+31, r31	; 0x1f
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    1628:	66 ea       	ldi	r22, 0xA6	; 166
    162a:	7c e0       	ldi	r23, 0x0C	; 12
    162c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    162e:	0e 94 f0 25 	call	0x4be0	; 0x4be0 <settings_read_coord_data>
    1632:	88 23       	and	r24, r24
    1634:	09 f4       	brne	.+2      	; 0x1638 <gc_execute_line+0x76a>
    1636:	b0 c6       	rjmp	.+3424   	; 0x2398 <__stack+0x199>

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
          if (gc_block.values.l == 20) {
    1638:	20 91 b2 0c 	lds	r18, 0x0CB2	; 0x800cb2 <gc_block+0x1c>
    163c:	2a a7       	std	Y+42, r18	; 0x2a
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            // WPos = MPos - WCS - G92 - TLO  ->  WCS = MPos - G92 - TLO - WPos
            gc_block.values.ijk[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.ijk[idx] -= gc_state.tool_length_offset; }
    163e:	40 90 92 0c 	lds	r4, 0x0C92	; 0x800c92 <gc_state+0x3c>
    1642:	50 90 93 0c 	lds	r5, 0x0C93	; 0x800c93 <gc_state+0x3d>
    1646:	60 90 94 0c 	lds	r6, 0x0C94	; 0x800c94 <gc_state+0x3e>
    164a:	70 90 95 0c 	lds	r7, 0x0C95	; 0x800c95 <gc_state+0x3f>
    164e:	06 e9       	ldi	r16, 0x96	; 150
    1650:	1c e0       	ldi	r17, 0x0C	; 12
    1652:	0f 2e       	mov	r0, r31
    1654:	f6 e5       	ldi	r31, 0x56	; 86
    1656:	cf 2e       	mov	r12, r31
    1658:	fc e0       	ldi	r31, 0x0C	; 12
    165a:	df 2e       	mov	r13, r31
    165c:	f0 2d       	mov	r31, r0
    165e:	a1 2c       	mov	r10, r1
    1660:	b1 2c       	mov	r11, r1
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
    1662:	3d a1       	ldd	r19, Y+37	; 0x25
    1664:	83 2e       	mov	r8, r19
    1666:	91 2c       	mov	r9, r1
    1668:	c4 01       	movw	r24, r8
    166a:	0a 2c       	mov	r0, r10
    166c:	02 c0       	rjmp	.+4      	; 0x1672 <gc_execute_line+0x7a4>
    166e:	95 95       	asr	r25
    1670:	87 95       	ror	r24
    1672:	0a 94       	dec	r0
    1674:	e2 f7       	brpl	.-8      	; 0x166e <gc_execute_line+0x7a0>
    1676:	80 ff       	sbrs	r24, 0
    1678:	36 c0       	rjmp	.+108    	; 0x16e6 <gc_execute_line+0x818>
          if (gc_block.values.l == 20) {
    167a:	4a a5       	ldd	r20, Y+42	; 0x2a
    167c:	44 31       	cpi	r20, 0x14	; 20
    167e:	51 f5       	brne	.+84     	; 0x16d4 <gc_execute_line+0x806>
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            // WPos = MPos - WCS - G92 - TLO  ->  WCS = MPos - G92 - TLO - WPos
            gc_block.values.ijk[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
    1680:	d6 01       	movw	r26, r12
    1682:	d0 96       	adiw	r26, 0x30	; 48
    1684:	2d 91       	ld	r18, X+
    1686:	3d 91       	ld	r19, X+
    1688:	4d 91       	ld	r20, X+
    168a:	5c 91       	ld	r21, X
    168c:	d3 97       	sbiw	r26, 0x33	; 51
    168e:	58 96       	adiw	r26, 0x18	; 24
    1690:	6d 91       	ld	r22, X+
    1692:	7d 91       	ld	r23, X+
    1694:	8d 91       	ld	r24, X+
    1696:	9c 91       	ld	r25, X
    1698:	5b 97       	sbiw	r26, 0x1b	; 27
    169a:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    169e:	f8 01       	movw	r30, r16
    16a0:	26 a5       	ldd	r18, Z+46	; 0x2e
    16a2:	37 a5       	ldd	r19, Z+47	; 0x2f
    16a4:	40 a9       	ldd	r20, Z+48	; 0x30
    16a6:	51 a9       	ldd	r21, Z+49	; 0x31
    16a8:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    16ac:	d8 01       	movw	r26, r16
    16ae:	50 96       	adiw	r26, 0x10	; 16
    16b0:	6d 93       	st	X+, r22
    16b2:	7d 93       	st	X+, r23
    16b4:	8d 93       	st	X+, r24
    16b6:	9c 93       	st	X, r25
    16b8:	53 97       	sbiw	r26, 0x13	; 19
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.ijk[idx] -= gc_state.tool_length_offset; }
    16ba:	b2 e0       	ldi	r27, 0x02	; 2
    16bc:	ab 12       	cpse	r10, r27
    16be:	13 c0       	rjmp	.+38     	; 0x16e6 <gc_execute_line+0x818>
    16c0:	a3 01       	movw	r20, r6
    16c2:	92 01       	movw	r18, r4
    16c4:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    16c8:	f8 01       	movw	r30, r16
    16ca:	60 8b       	std	Z+16, r22	; 0x10
    16cc:	71 8b       	std	Z+17, r23	; 0x11
    16ce:	82 8b       	std	Z+18, r24	; 0x12
    16d0:	93 8b       	std	Z+19, r25	; 0x13
    16d2:	09 c0       	rjmp	.+18     	; 0x16e6 <gc_execute_line+0x818>
          } else {
            // L2: Update coordinate system axis to programmed value.
            gc_block.values.ijk[idx] = gc_block.values.xyz[idx];
    16d4:	f8 01       	movw	r30, r16
    16d6:	86 a5       	ldd	r24, Z+46	; 0x2e
    16d8:	97 a5       	ldd	r25, Z+47	; 0x2f
    16da:	a0 a9       	ldd	r26, Z+48	; 0x30
    16dc:	b1 a9       	ldd	r27, Z+49	; 0x31
    16de:	80 8b       	std	Z+16, r24	; 0x10
    16e0:	91 8b       	std	Z+17, r25	; 0x11
    16e2:	a2 8b       	std	Z+18, r26	; 0x12
    16e4:	b3 8b       	std	Z+19, r27	; 0x13
    16e6:	ff ef       	ldi	r31, 0xFF	; 255
    16e8:	af 1a       	sub	r10, r31
    16ea:	bf 0a       	sbc	r11, r31
    16ec:	0c 5f       	subi	r16, 0xFC	; 252
    16ee:	1f 4f       	sbci	r17, 0xFF	; 255
    16f0:	24 e0       	ldi	r18, 0x04	; 4
    16f2:	c2 0e       	add	r12, r18
    16f4:	d1 1c       	adc	r13, r1
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    16f6:	33 e0       	ldi	r19, 0x03	; 3
    16f8:	a3 16       	cp	r10, r19
    16fa:	b1 04       	cpc	r11, r1
    16fc:	09 f0       	breq	.+2      	; 0x1700 <gc_execute_line+0x832>
    16fe:	b4 cf       	rjmp	.-152    	; 0x1668 <gc_execute_line+0x79a>
    1700:	9d c6       	rjmp	.+3386   	; 0x243c <__stack+0x23d>
        } // Else, keep current stored value.
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1702:	4d a1       	ldd	r20, Y+37	; 0x25
    1704:	44 23       	and	r20, r20
    1706:	09 f4       	brne	.+2      	; 0x170a <gc_execute_line+0x83c>
    1708:	49 c6       	rjmp	.+3218   	; 0x239c <__stack+0x19d>
    170a:	0f 2e       	mov	r0, r31
    170c:	f6 e5       	ldi	r31, 0x56	; 86
    170e:	af 2e       	mov	r10, r31
    1710:	fc e0       	ldi	r31, 0x0C	; 12
    1712:	bf 2e       	mov	r11, r31
    1714:	f0 2d       	mov	r31, r0
    1716:	4e 01       	movw	r8, r28
    1718:	86 e0       	ldi	r24, 0x06	; 6
    171a:	88 0e       	add	r8, r24
    171c:	91 1c       	adc	r9, r1
    171e:	06 e9       	ldi	r16, 0x96	; 150
    1720:	1c e0       	ldi	r17, 0x0C	; 12
    1722:	c1 2c       	mov	r12, r1
    1724:	d1 2c       	mov	r13, r1

      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
    1726:	64 2e       	mov	r6, r20
    1728:	71 2c       	mov	r7, r1
    172a:	c3 01       	movw	r24, r6
    172c:	0c 2c       	mov	r0, r12
    172e:	02 c0       	rjmp	.+4      	; 0x1734 <gc_execute_line+0x866>
    1730:	95 95       	asr	r25
    1732:	87 95       	ror	r24
    1734:	0a 94       	dec	r0
    1736:	e2 f7       	brpl	.-8      	; 0x1730 <gc_execute_line+0x862>
    1738:	80 ff       	sbrs	r24, 0
    173a:	3c c0       	rjmp	.+120    	; 0x17b4 <gc_execute_line+0x8e6>
          // WPos = MPos - WCS - G92 - TLO  ->  G92 = MPos - WCS - TLO - WPos
          gc_block.values.xyz[idx] = gc_state.position[idx]-block_coord_system[idx]-gc_block.values.xyz[idx];
    173c:	d4 01       	movw	r26, r8
    173e:	2d 91       	ld	r18, X+
    1740:	3d 91       	ld	r19, X+
    1742:	4d 91       	ld	r20, X+
    1744:	5c 91       	ld	r21, X
    1746:	f5 01       	movw	r30, r10
    1748:	60 8d       	ldd	r22, Z+24	; 0x18
    174a:	71 8d       	ldd	r23, Z+25	; 0x19
    174c:	82 8d       	ldd	r24, Z+26	; 0x1a
    174e:	93 8d       	ldd	r25, Z+27	; 0x1b
    1750:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    1754:	d8 01       	movw	r26, r16
    1756:	9e 96       	adiw	r26, 0x2e	; 46
    1758:	2d 91       	ld	r18, X+
    175a:	3d 91       	ld	r19, X+
    175c:	4d 91       	ld	r20, X+
    175e:	5c 91       	ld	r21, X
    1760:	d1 97       	sbiw	r26, 0x31	; 49
    1762:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    1766:	f8 01       	movw	r30, r16
    1768:	66 a7       	std	Z+46, r22	; 0x2e
    176a:	77 a7       	std	Z+47, r23	; 0x2f
    176c:	80 ab       	std	Z+48, r24	; 0x30
    176e:	91 ab       	std	Z+49, r25	; 0x31
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
    1770:	f2 e0       	ldi	r31, 0x02	; 2
    1772:	cf 12       	cpse	r12, r31
    1774:	29 c0       	rjmp	.+82     	; 0x17c8 <gc_execute_line+0x8fa>
    1776:	86 01       	movw	r16, r12
    1778:	00 0f       	add	r16, r16
    177a:	11 1f       	adc	r17, r17
    177c:	00 0f       	add	r16, r16
    177e:	11 1f       	adc	r17, r17
    1780:	0a 56       	subi	r16, 0x6A	; 106
    1782:	13 4f       	sbci	r17, 0xF3	; 243
    1784:	20 91 92 0c 	lds	r18, 0x0C92	; 0x800c92 <gc_state+0x3c>
    1788:	30 91 93 0c 	lds	r19, 0x0C93	; 0x800c93 <gc_state+0x3d>
    178c:	40 91 94 0c 	lds	r20, 0x0C94	; 0x800c94 <gc_state+0x3e>
    1790:	50 91 95 0c 	lds	r21, 0x0C95	; 0x800c95 <gc_state+0x3f>
    1794:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    1798:	d8 01       	movw	r26, r16
    179a:	9e 96       	adiw	r26, 0x2e	; 46
    179c:	6d 93       	st	X+, r22
    179e:	7d 93       	st	X+, r23
    17a0:	8d 93       	st	X+, r24
    17a2:	9c 93       	st	X, r25
    17a4:	d1 97       	sbiw	r26, 0x31	; 49
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    17a6:	10 91 97 0c 	lds	r17, 0x0C97	; 0x800c97 <gc_block+0x1>
    17aa:	10 35       	cpi	r17, 0x50	; 80
    17ac:	09 f4       	brne	.+2      	; 0x17b0 <gc_execute_line+0x8e2>
    17ae:	f8 c5       	rjmp	.+3056   	; 0x23a0 <__stack+0x1a1>
    17b0:	1f 8e       	std	Y+31, r1	; 0x1f
    17b2:	f8 c0       	rjmp	.+496    	; 0x19a4 <gc_execute_line+0xad6>
        if (bit_istrue(axis_words,bit(idx)) ) {
          // WPos = MPos - WCS - G92 - TLO  ->  G92 = MPos - WCS - TLO - WPos
          gc_block.values.xyz[idx] = gc_state.position[idx]-block_coord_system[idx]-gc_block.values.xyz[idx];
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
        } else {
          gc_block.values.xyz[idx] = gc_state.coord_offset[idx];
    17b4:	f5 01       	movw	r30, r10
    17b6:	80 a9       	ldd	r24, Z+48	; 0x30
    17b8:	91 a9       	ldd	r25, Z+49	; 0x31
    17ba:	a2 a9       	ldd	r26, Z+50	; 0x32
    17bc:	b3 a9       	ldd	r27, Z+51	; 0x33
    17be:	f8 01       	movw	r30, r16
    17c0:	86 a7       	std	Z+46, r24	; 0x2e
    17c2:	97 a7       	std	Z+47, r25	; 0x2f
    17c4:	a0 ab       	std	Z+48, r26	; 0x30
    17c6:	b1 ab       	std	Z+49, r27	; 0x31
    17c8:	ff ef       	ldi	r31, 0xFF	; 255
    17ca:	cf 1a       	sub	r12, r31
    17cc:	df 0a       	sbc	r13, r31
    17ce:	24 e0       	ldi	r18, 0x04	; 4
    17d0:	a2 0e       	add	r10, r18
    17d2:	b1 1c       	adc	r11, r1
    17d4:	34 e0       	ldi	r19, 0x04	; 4
    17d6:	83 0e       	add	r8, r19
    17d8:	91 1c       	adc	r9, r1
    17da:	0c 5f       	subi	r16, 0xFC	; 252
    17dc:	1f 4f       	sbci	r17, 0xFF	; 255
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]

      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    17de:	43 e0       	ldi	r20, 0x03	; 3
    17e0:	c4 16       	cp	r12, r20
    17e2:	d1 04       	cpc	r13, r1
    17e4:	09 f0       	breq	.+2      	; 0x17e8 <gc_execute_line+0x91a>
    17e6:	a1 cf       	rjmp	.-190    	; 0x172a <gc_execute_line+0x85c>
  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes

  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    17e8:	1f 8e       	std	Y+31, r1	; 0x1f
    17ea:	28 c6       	rjmp	.+3152   	; 0x243c <__stack+0x23d>

      // At this point, the rest of the explicit axis commands treat the axis values as the traditional
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
    17ec:	8e a1       	ldd	r24, Y+38	; 0x26
    17ee:	83 30       	cpi	r24, 0x03	; 3
    17f0:	09 f4       	brne	.+2      	; 0x17f4 <gc_execute_line+0x926>
    17f2:	90 c0       	rjmp	.+288    	; 0x1914 <gc_execute_line+0xa46>
        if (axis_words) {
    17f4:	9d a1       	ldd	r25, Y+37	; 0x25
    17f6:	99 23       	and	r25, r25
    17f8:	09 f4       	brne	.+2      	; 0x17fc <gc_execute_line+0x92e>
    17fa:	8c c0       	rjmp	.+280    	; 0x1914 <gc_execute_line+0xa46>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    17fc:	a0 90 9a 0c 	lds	r10, 0x0C9A	; 0x800c9a <gc_block+0x4>
    1800:	0f 2e       	mov	r0, r31
    1802:	f6 e5       	ldi	r31, 0x56	; 86
    1804:	cf 2e       	mov	r12, r31
    1806:	fc e0       	ldi	r31, 0x0C	; 12
    1808:	df 2e       	mov	r13, r31
    180a:	f0 2d       	mov	r31, r0
    180c:	06 e9       	ldi	r16, 0x96	; 150
    180e:	1c e0       	ldi	r17, 0x0C	; 12
    1810:	3e 01       	movw	r6, r28
    1812:	a6 e0       	ldi	r26, 0x06	; 6
    1814:	6a 0e       	add	r6, r26
    1816:	71 1c       	adc	r7, r1
    1818:	81 2c       	mov	r8, r1
    181a:	91 2c       	mov	r9, r1
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
            if ( bit_isfalse(axis_words,bit(idx)) ) {
    181c:	49 2e       	mov	r4, r25
    181e:	51 2c       	mov	r5, r1
    1820:	98 a2       	std	Y+32, r9	; 0x20
    1822:	8f 8e       	std	Y+31, r8	; 0x1f
    1824:	c2 01       	movw	r24, r4
    1826:	08 2c       	mov	r0, r8
    1828:	02 c0       	rjmp	.+4      	; 0x182e <gc_execute_line+0x960>
    182a:	95 95       	asr	r25
    182c:	87 95       	ror	r24
    182e:	0a 94       	dec	r0
    1830:	e2 f7       	brpl	.-8      	; 0x182a <gc_execute_line+0x95c>
    1832:	80 fd       	sbrc	r24, 0
    1834:	0b c0       	rjmp	.+22     	; 0x184c <gc_execute_line+0x97e>
              gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
    1836:	f6 01       	movw	r30, r12
    1838:	80 8d       	ldd	r24, Z+24	; 0x18
    183a:	91 8d       	ldd	r25, Z+25	; 0x19
    183c:	a2 8d       	ldd	r26, Z+26	; 0x1a
    183e:	b3 8d       	ldd	r27, Z+27	; 0x1b
    1840:	f8 01       	movw	r30, r16
    1842:	86 a7       	std	Z+46, r24	; 0x2e
    1844:	97 a7       	std	Z+47, r25	; 0x2f
    1846:	a0 ab       	std	Z+48, r26	; 0x30
    1848:	b1 ab       	std	Z+49, r27	; 0x31
    184a:	54 c0       	rjmp	.+168    	; 0x18f4 <gc_execute_line+0xa26>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
    184c:	f5 e3       	ldi	r31, 0x35	; 53
    184e:	bf 16       	cp	r11, r31
    1850:	09 f4       	brne	.+2      	; 0x1854 <gc_execute_line+0x986>
    1852:	50 c0       	rjmp	.+160    	; 0x18f4 <gc_execute_line+0xa26>
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    1854:	a1 10       	cpse	r10, r1
    1856:	3b c0       	rjmp	.+118    	; 0x18ce <gc_execute_line+0xa00>
                  gc_block.values.xyz[idx] += block_coord_system[idx] + gc_state.coord_offset[idx];
    1858:	d6 01       	movw	r26, r12
    185a:	d0 96       	adiw	r26, 0x30	; 48
    185c:	2d 91       	ld	r18, X+
    185e:	3d 91       	ld	r19, X+
    1860:	4d 91       	ld	r20, X+
    1862:	5c 91       	ld	r21, X
    1864:	d3 97       	sbiw	r26, 0x33	; 51
    1866:	f3 01       	movw	r30, r6
    1868:	60 81       	ld	r22, Z
    186a:	71 81       	ldd	r23, Z+1	; 0x01
    186c:	82 81       	ldd	r24, Z+2	; 0x02
    186e:	93 81       	ldd	r25, Z+3	; 0x03
    1870:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    1874:	d8 01       	movw	r26, r16
    1876:	9e 96       	adiw	r26, 0x2e	; 46
    1878:	2d 91       	ld	r18, X+
    187a:	3d 91       	ld	r19, X+
    187c:	4d 91       	ld	r20, X+
    187e:	5c 91       	ld	r21, X
    1880:	d1 97       	sbiw	r26, 0x31	; 49
    1882:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    1886:	9b 01       	movw	r18, r22
    1888:	ac 01       	movw	r20, r24
    188a:	f8 01       	movw	r30, r16
    188c:	66 a7       	std	Z+46, r22	; 0x2e
    188e:	77 a7       	std	Z+47, r23	; 0x2f
    1890:	80 ab       	std	Z+48, r24	; 0x30
    1892:	91 ab       	std	Z+49, r25	; 0x31
                  if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_length_offset; }
    1894:	f2 e0       	ldi	r31, 0x02	; 2
    1896:	8f 12       	cpse	r8, r31
    1898:	2d c0       	rjmp	.+90     	; 0x18f4 <gc_execute_line+0xa26>
    189a:	0f 8d       	ldd	r16, Y+31	; 0x1f
    189c:	18 a1       	ldd	r17, Y+32	; 0x20
    189e:	00 0f       	add	r16, r16
    18a0:	11 1f       	adc	r17, r17
    18a2:	00 0f       	add	r16, r16
    18a4:	11 1f       	adc	r17, r17
    18a6:	0a 56       	subi	r16, 0x6A	; 106
    18a8:	13 4f       	sbci	r17, 0xF3	; 243
    18aa:	60 91 92 0c 	lds	r22, 0x0C92	; 0x800c92 <gc_state+0x3c>
    18ae:	70 91 93 0c 	lds	r23, 0x0C93	; 0x800c93 <gc_state+0x3d>
    18b2:	80 91 94 0c 	lds	r24, 0x0C94	; 0x800c94 <gc_state+0x3e>
    18b6:	90 91 95 0c 	lds	r25, 0x0C95	; 0x800c95 <gc_state+0x3f>
    18ba:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    18be:	d8 01       	movw	r26, r16
    18c0:	9e 96       	adiw	r26, 0x2e	; 46
    18c2:	6d 93       	st	X+, r22
    18c4:	7d 93       	st	X+, r23
    18c6:	8d 93       	st	X+, r24
    18c8:	9c 93       	st	X, r25
    18ca:	d1 97       	sbiw	r26, 0x31	; 49
    18cc:	23 c0       	rjmp	.+70     	; 0x1914 <gc_execute_line+0xa46>
                } else {  // Incremental mode
                  gc_block.values.xyz[idx] += gc_state.position[idx];
    18ce:	f6 01       	movw	r30, r12
    18d0:	20 8d       	ldd	r18, Z+24	; 0x18
    18d2:	31 8d       	ldd	r19, Z+25	; 0x19
    18d4:	42 8d       	ldd	r20, Z+26	; 0x1a
    18d6:	53 8d       	ldd	r21, Z+27	; 0x1b
    18d8:	d8 01       	movw	r26, r16
    18da:	9e 96       	adiw	r26, 0x2e	; 46
    18dc:	6d 91       	ld	r22, X+
    18de:	7d 91       	ld	r23, X+
    18e0:	8d 91       	ld	r24, X+
    18e2:	9c 91       	ld	r25, X
    18e4:	d1 97       	sbiw	r26, 0x31	; 49
    18e6:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    18ea:	f8 01       	movw	r30, r16
    18ec:	66 a7       	std	Z+46, r22	; 0x2e
    18ee:	77 a7       	std	Z+47, r23	; 0x2f
    18f0:	80 ab       	std	Z+48, r24	; 0x30
    18f2:	91 ab       	std	Z+49, r25	; 0x31
    18f4:	ff ef       	ldi	r31, 0xFF	; 255
    18f6:	8f 1a       	sub	r8, r31
    18f8:	9f 0a       	sbc	r9, r31
    18fa:	24 e0       	ldi	r18, 0x04	; 4
    18fc:	c2 0e       	add	r12, r18
    18fe:	d1 1c       	adc	r13, r1
    1900:	0c 5f       	subi	r16, 0xFC	; 252
    1902:	1f 4f       	sbci	r17, 0xFF	; 255
    1904:	34 e0       	ldi	r19, 0x04	; 4
    1906:	63 0e       	add	r6, r19
    1908:	71 1c       	adc	r7, r1
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    190a:	43 e0       	ldi	r20, 0x03	; 3
    190c:	84 16       	cp	r8, r20
    190e:	91 04       	cpc	r9, r1
    1910:	09 f0       	breq	.+2      	; 0x1914 <gc_execute_line+0xa46>
    1912:	86 cf       	rjmp	.-244    	; 0x1820 <gc_execute_line+0x952>
          }
        }
      }

      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {
    1914:	8e e1       	ldi	r24, 0x1E	; 30
    1916:	b8 16       	cp	r11, r24
    1918:	31 f0       	breq	.+12     	; 0x1926 <gc_execute_line+0xa58>
    191a:	95 e3       	ldi	r25, 0x35	; 53
    191c:	b9 16       	cp	r11, r25
    191e:	99 f1       	breq	.+102    	; 0x1986 <gc_execute_line+0xab8>
    1920:	ac e1       	ldi	r26, 0x1C	; 28
    1922:	ba 12       	cpse	r11, r26
    1924:	35 c0       	rjmp	.+106    	; 0x1990 <gc_execute_line+0xac2>
        case NON_MODAL_GO_HOME_0: // G28
        case NON_MODAL_GO_HOME_1: // G30
          // [G28/30 Errors]: Cutter compensation is enabled.
          // Retreive G28/30 go-home position data (in machine coordinates) from EEPROM
          // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
    1926:	bc e1       	ldi	r27, 0x1C	; 28
    1928:	bb 12       	cpse	r11, r27
    192a:	09 c0       	rjmp	.+18     	; 0x193e <gc_execute_line+0xa70>
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    192c:	66 ea       	ldi	r22, 0xA6	; 166
    192e:	7c e0       	ldi	r23, 0x0C	; 12
    1930:	86 e0       	ldi	r24, 0x06	; 6
    1932:	0e 94 f0 25 	call	0x4be0	; 0x4be0 <settings_read_coord_data>
    1936:	88 23       	and	r24, r24
    1938:	09 f4       	brne	.+2      	; 0x193c <gc_execute_line+0xa6e>
    193a:	34 c5       	rjmp	.+2664   	; 0x23a4 <__stack+0x1a5>
    193c:	74 c5       	rjmp	.+2792   	; 0x2426 <__stack+0x227>
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    193e:	66 ea       	ldi	r22, 0xA6	; 166
    1940:	7c e0       	ldi	r23, 0x0C	; 12
    1942:	87 e0       	ldi	r24, 0x07	; 7
    1944:	0e 94 f0 25 	call	0x4be0	; 0x4be0 <settings_read_coord_data>
    1948:	88 23       	and	r24, r24
    194a:	09 f4       	brne	.+2      	; 0x194e <gc_execute_line+0xa80>
    194c:	2d c5       	rjmp	.+2650   	; 0x23a8 <__stack+0x1a9>
    194e:	6b c5       	rjmp	.+2774   	; 0x2426 <__stack+0x227>
          }
          if (axis_words) {
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
    1950:	a9 01       	movw	r20, r18
    1952:	08 2e       	mov	r0, r24
    1954:	02 c0       	rjmp	.+4      	; 0x195a <gc_execute_line+0xa8c>
    1956:	55 95       	asr	r21
    1958:	47 95       	ror	r20
    195a:	0a 94       	dec	r0
    195c:	e2 f7       	brpl	.-8      	; 0x1956 <gc_execute_line+0xa88>
    195e:	40 fd       	sbrc	r20, 0
    1960:	0a c0       	rjmp	.+20     	; 0x1976 <gc_execute_line+0xaa8>
    1962:	58 96       	adiw	r26, 0x18	; 24
    1964:	4d 91       	ld	r20, X+
    1966:	5d 91       	ld	r21, X+
    1968:	6d 91       	ld	r22, X+
    196a:	7c 91       	ld	r23, X
    196c:	5b 97       	sbiw	r26, 0x1b	; 27
    196e:	40 8b       	std	Z+16, r20	; 0x10
    1970:	51 8b       	std	Z+17, r21	; 0x11
    1972:	62 8b       	std	Z+18, r22	; 0x12
    1974:	73 8b       	std	Z+19, r23	; 0x13
    1976:	01 96       	adiw	r24, 0x01	; 1
    1978:	14 96       	adiw	r26, 0x04	; 4
    197a:	34 96       	adiw	r30, 0x04	; 4
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
          }
          if (axis_words) {
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
    197c:	83 30       	cpi	r24, 0x03	; 3
    197e:	91 05       	cpc	r25, r1
    1980:	39 f7       	brne	.-50     	; 0x1950 <gc_execute_line+0xa82>
  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes

  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    1982:	1f 8e       	std	Y+31, r1	; 0x1f
    1984:	5b c5       	rjmp	.+2742   	; 0x243c <__stack+0x23d>
          // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
    1986:	80 91 97 0c 	lds	r24, 0x0C97	; 0x800c97 <gc_block+0x1>
    198a:	82 30       	cpi	r24, 0x02	; 2
    198c:	08 f0       	brcs	.+2      	; 0x1990 <gc_execute_line+0xac2>
    198e:	0e c5       	rjmp	.+2588   	; 0x23ac <__stack+0x1ad>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    1990:	10 91 97 0c 	lds	r17, 0x0C97	; 0x800c97 <gc_block+0x1>
    1994:	10 35       	cpi	r17, 0x50	; 80
    1996:	29 f4       	brne	.+10     	; 0x19a2 <gc_execute_line+0xad4>
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    1998:	ed a1       	ldd	r30, Y+37	; 0x25
    199a:	e1 11       	cpse	r30, r1
    199c:	09 c5       	rjmp	.+2578   	; 0x23b0 <__stack+0x1b1>
    199e:	1f 8e       	std	Y+31, r1	; 0x1f
    19a0:	46 c2       	rjmp	.+1164   	; 0x1e2e <gc_execute_line+0xf60>
    19a2:	1f 8e       	std	Y+31, r1	; 0x1f

  // Check remaining motion modes, if axis word are implicit (exist and not used by G10/28/30/92), or
  // was explicitly commanded in the g-code block.
  } else if ( axis_command == AXIS_COMMAND_MOTION_MODE ) {
    19a4:	fe a1       	ldd	r31, Y+38	; 0x26
    19a6:	f2 30       	cpi	r31, 0x02	; 2
    19a8:	09 f0       	breq	.+2      	; 0x19ac <gc_execute_line+0xade>
    19aa:	41 c2       	rjmp	.+1154   	; 0x1e2e <gc_execute_line+0xf60>

    if (gc_block.modal.motion == MOTION_MODE_SEEK) {
    19ac:	11 11       	cpse	r17, r1
    19ae:	05 c0       	rjmp	.+10     	; 0x19ba <gc_execute_line+0xaec>
      // [G0 Errors]: Axis letter not configured or without real value (done.)
      // Axis words are optional. If missing, set axis command flag to ignore execution.
      if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    19b0:	2d a1       	ldd	r18, Y+37	; 0x25
    19b2:	21 11       	cpse	r18, r1
    19b4:	3c c2       	rjmp	.+1144   	; 0x1e2e <gc_execute_line+0xf60>
    19b6:	1e a2       	std	Y+38, r1	; 0x26
    19b8:	3a c2       	rjmp	.+1140   	; 0x1e2e <gc_execute_line+0xf60>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    19ba:	20 e0       	ldi	r18, 0x00	; 0
    19bc:	30 e0       	ldi	r19, 0x00	; 0
    19be:	a9 01       	movw	r20, r18
    19c0:	60 91 a2 0c 	lds	r22, 0x0CA2	; 0x800ca2 <gc_block+0xc>
    19c4:	70 91 a3 0c 	lds	r23, 0x0CA3	; 0x800ca3 <gc_block+0xd>
    19c8:	80 91 a4 0c 	lds	r24, 0x0CA4	; 0x800ca4 <gc_block+0xe>
    19cc:	90 91 a5 0c 	lds	r25, 0x0CA5	; 0x800ca5 <gc_block+0xf>
    19d0:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    19d4:	88 23       	and	r24, r24
    19d6:	09 f4       	brne	.+2      	; 0x19da <gc_execute_line+0xb0c>
    19d8:	ed c4       	rjmp	.+2522   	; 0x23b4 <__stack+0x1b5>

      switch (gc_block.modal.motion) {
    19da:	1c 38       	cpi	r17, 0x8C	; 140
    19dc:	09 f4       	brne	.+2      	; 0x19e0 <gc_execute_line+0xb12>
    19de:	0f c2       	rjmp	.+1054   	; 0x1dfe <gc_execute_line+0xf30>
    19e0:	40 f4       	brcc	.+16     	; 0x19f2 <gc_execute_line+0xb24>
    19e2:	12 30       	cpi	r17, 0x02	; 2
    19e4:	a1 f0       	breq	.+40     	; 0x1a0e <gc_execute_line+0xb40>
    19e6:	13 30       	cpi	r17, 0x03	; 3
    19e8:	a9 f0       	breq	.+42     	; 0x1a14 <gc_execute_line+0xb46>
    19ea:	11 30       	cpi	r17, 0x01	; 1
    19ec:	09 f0       	breq	.+2      	; 0x19f0 <gc_execute_line+0xb22>
    19ee:	1f c2       	rjmp	.+1086   	; 0x1e2e <gc_execute_line+0xf60>
    19f0:	09 c0       	rjmp	.+18     	; 0x1a04 <gc_execute_line+0xb36>
    19f2:	1e 38       	cpi	r17, 0x8E	; 142
    19f4:	09 f4       	brne	.+2      	; 0x19f8 <gc_execute_line+0xb2a>
    19f6:	03 c2       	rjmp	.+1030   	; 0x1dfe <gc_execute_line+0xf30>
    19f8:	08 f4       	brcc	.+2      	; 0x19fc <gc_execute_line+0xb2e>
    19fa:	fe c1       	rjmp	.+1020   	; 0x1df8 <gc_execute_line+0xf2a>
    19fc:	1f 38       	cpi	r17, 0x8F	; 143
    19fe:	09 f4       	brne	.+2      	; 0x1a02 <gc_execute_line+0xb34>
    1a00:	fb c1       	rjmp	.+1014   	; 0x1df8 <gc_execute_line+0xf2a>
    1a02:	15 c2       	rjmp	.+1066   	; 0x1e2e <gc_execute_line+0xf60>
        case MOTION_MODE_LINEAR:
          // [G1 Errors]: Feed rate undefined. Axis letter not configured or without real value.
          // Axis words are optional. If missing, set axis command flag to ignore execution.
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    1a04:	3d a1       	ldd	r19, Y+37	; 0x25
    1a06:	31 11       	cpse	r19, r1
    1a08:	12 c2       	rjmp	.+1060   	; 0x1e2e <gc_execute_line+0xf60>
    1a0a:	1e a2       	std	Y+38, r1	; 0x26
    1a0c:	10 c2       	rjmp	.+1056   	; 0x1e2e <gc_execute_line+0xf60>
          break;
        case MOTION_MODE_CW_ARC: 
          gc_parser_flags |= GC_PARSER_ARC_IS_CLOCKWISE; // No break intentional.
    1a0e:	48 a5       	ldd	r20, Y+40	; 0x28
    1a10:	44 60       	ori	r20, 0x04	; 4
    1a12:	48 a7       	std	Y+40, r20	; 0x28
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.

          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1a14:	8d a1       	ldd	r24, Y+37	; 0x25
    1a16:	88 23       	and	r24, r24
    1a18:	09 f4       	brne	.+2      	; 0x1a1c <gc_execute_line+0xb4e>
    1a1a:	ce c4       	rjmp	.+2460   	; 0x23b8 <__stack+0x1b9>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    1a1c:	b9 a1       	ldd	r27, Y+33	; 0x21
    1a1e:	ab 2f       	mov	r26, r27
    1a20:	b0 e0       	ldi	r27, 0x00	; 0
    1a22:	bc ab       	std	Y+52, r27	; 0x34
    1a24:	ab ab       	std	Y+51, r26	; 0x33
    1a26:	e9 a5       	ldd	r30, Y+41	; 0x29
    1a28:	ce 2e       	mov	r12, r30
    1a2a:	d1 2c       	mov	r13, r1
    1a2c:	81 e0       	ldi	r24, 0x01	; 1
    1a2e:	90 e0       	ldi	r25, 0x00	; 0
    1a30:	8c 01       	movw	r16, r24
    1a32:	09 a0       	ldd	r0, Y+33	; 0x21
    1a34:	02 c0       	rjmp	.+4      	; 0x1a3a <gc_execute_line+0xb6c>
    1a36:	00 0f       	add	r16, r16
    1a38:	11 1f       	adc	r17, r17
    1a3a:	0a 94       	dec	r0
    1a3c:	e2 f7       	brpl	.-8      	; 0x1a36 <gc_execute_line+0xb68>
    1a3e:	02 c0       	rjmp	.+4      	; 0x1a44 <gc_execute_line+0xb76>
    1a40:	88 0f       	add	r24, r24
    1a42:	99 1f       	adc	r25, r25
    1a44:	ea 95       	dec	r30
    1a46:	e2 f7       	brpl	.-8      	; 0x1a40 <gc_execute_line+0xb72>
    1a48:	08 2b       	or	r16, r24
    1a4a:	19 2b       	or	r17, r25
    1a4c:	fd a1       	ldd	r31, Y+37	; 0x25
    1a4e:	8f 2f       	mov	r24, r31
    1a50:	90 e0       	ldi	r25, 0x00	; 0
    1a52:	80 23       	and	r24, r16
    1a54:	91 23       	and	r25, r17
    1a56:	89 2b       	or	r24, r25
    1a58:	09 f4       	brne	.+2      	; 0x1a5c <gc_execute_line+0xb8e>
    1a5a:	b0 c4       	rjmp	.+2400   	; 0x23bc <__stack+0x1bd>

          // Calculate the change in position along each selected axis
          float x,y;
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
    1a5c:	fd 01       	movw	r30, r26
    1a5e:	ee 0f       	add	r30, r30
    1a60:	ff 1f       	adc	r31, r31
    1a62:	ee 0f       	add	r30, r30
    1a64:	ff 1f       	adc	r31, r31
    1a66:	ea 56       	subi	r30, 0x6A	; 106
    1a68:	f3 4f       	sbci	r31, 0xF3	; 243
    1a6a:	aa 0f       	add	r26, r26
    1a6c:	bb 1f       	adc	r27, r27
    1a6e:	aa 0f       	add	r26, r26
    1a70:	bb 1f       	adc	r27, r27
    1a72:	a2 59       	subi	r26, 0x92	; 146
    1a74:	b3 4f       	sbci	r27, 0xF3	; 243
    1a76:	2d 91       	ld	r18, X+
    1a78:	3d 91       	ld	r19, X+
    1a7a:	4d 91       	ld	r20, X+
    1a7c:	5c 91       	ld	r21, X
    1a7e:	66 a5       	ldd	r22, Z+46	; 0x2e
    1a80:	77 a5       	ldd	r23, Z+47	; 0x2f
    1a82:	80 a9       	ldd	r24, Z+48	; 0x30
    1a84:	91 a9       	ldd	r25, Z+49	; 0x31
    1a86:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    1a8a:	6a a7       	std	Y+42, r22	; 0x2a
    1a8c:	7b a7       	std	Y+43, r23	; 0x2b
    1a8e:	8c a7       	std	Y+44, r24	; 0x2c
    1a90:	9d a7       	std	Y+45, r25	; 0x2d
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target
    1a92:	f6 01       	movw	r30, r12
    1a94:	ee 0f       	add	r30, r30
    1a96:	ff 1f       	adc	r31, r31
    1a98:	ee 0f       	add	r30, r30
    1a9a:	ff 1f       	adc	r31, r31
    1a9c:	ea 56       	subi	r30, 0x6A	; 106
    1a9e:	f3 4f       	sbci	r31, 0xF3	; 243
    1aa0:	d6 01       	movw	r26, r12
    1aa2:	aa 0f       	add	r26, r26
    1aa4:	bb 1f       	adc	r27, r27
    1aa6:	aa 0f       	add	r26, r26
    1aa8:	bb 1f       	adc	r27, r27
    1aaa:	a2 59       	subi	r26, 0x92	; 146
    1aac:	b3 4f       	sbci	r27, 0xF3	; 243
    1aae:	2d 91       	ld	r18, X+
    1ab0:	3d 91       	ld	r19, X+
    1ab2:	4d 91       	ld	r20, X+
    1ab4:	5c 91       	ld	r21, X
    1ab6:	66 a5       	ldd	r22, Z+46	; 0x2e
    1ab8:	77 a5       	ldd	r23, Z+47	; 0x2f
    1aba:	80 a9       	ldd	r24, Z+48	; 0x30
    1abc:	91 a9       	ldd	r25, Z+49	; 0x31
    1abe:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    1ac2:	6e a7       	std	Y+46, r22	; 0x2e
    1ac4:	7f a7       	std	Y+47, r23	; 0x2f
    1ac6:	88 ab       	std	Y+48, r24	; 0x30
    1ac8:	99 ab       	std	Y+49, r25	; 0x31

          if (value_words & bit(WORD_R)) { // Arc Radius Mode
    1aca:	27 fe       	sbrs	r2, 7
    1acc:	ea c0       	rjmp	.+468    	; 0x1ca2 <gc_execute_line+0xdd4>
            bit_false(value_words,bit(WORD_R));
    1ace:	e8 94       	clt
    1ad0:	27 f8       	bld	r2, 7
            if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    1ad2:	4c e0       	ldi	r20, 0x0C	; 12
    1ad4:	50 e0       	ldi	r21, 0x00	; 0
    1ad6:	64 ec       	ldi	r22, 0xC4	; 196
    1ad8:	7c e0       	ldi	r23, 0x0C	; 12
    1ada:	8e e6       	ldi	r24, 0x6E	; 110
    1adc:	9c e0       	ldi	r25, 0x0C	; 12
    1ade:	0e 94 c9 42 	call	0x8592	; 0x8592 <memcmp>
    1ae2:	89 2b       	or	r24, r25
    1ae4:	09 f4       	brne	.+2      	; 0x1ae8 <gc_execute_line+0xc1a>
    1ae6:	6c c4       	rjmp	.+2264   	; 0x23c0 <__stack+0x1c1>

            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
    1ae8:	80 91 99 0c 	lds	r24, 0x0C99	; 0x800c99 <gc_block+0x3>
    1aec:	81 30       	cpi	r24, 0x01	; 1
    1aee:	a1 f4       	brne	.+40     	; 0x1b18 <gc_execute_line+0xc4a>
    1af0:	06 e9       	ldi	r16, 0x96	; 150
    1af2:	1c e0       	ldi	r17, 0x0C	; 12
    1af4:	23 e3       	ldi	r18, 0x33	; 51
    1af6:	33 e3       	ldi	r19, 0x33	; 51
    1af8:	4b ec       	ldi	r20, 0xCB	; 203
    1afa:	51 e4       	ldi	r21, 0x41	; 65
    1afc:	d8 01       	movw	r26, r16
    1afe:	95 96       	adiw	r26, 0x25	; 37
    1b00:	6d 91       	ld	r22, X+
    1b02:	7d 91       	ld	r23, X+
    1b04:	8d 91       	ld	r24, X+
    1b06:	9c 91       	ld	r25, X
    1b08:	98 97       	sbiw	r26, 0x28	; 40
    1b0a:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    1b0e:	f8 01       	movw	r30, r16
    1b10:	65 a3       	std	Z+37, r22	; 0x25
    1b12:	76 a3       	std	Z+38, r23	; 0x26
    1b14:	87 a3       	std	Z+39, r24	; 0x27
    1b16:	90 a7       	std	Z+40, r25	; 0x28
                j = (y + (x * h_x2_div_d))/2
            */

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;
    1b18:	80 90 bb 0c 	lds	r8, 0x0CBB	; 0x800cbb <gc_block+0x25>
    1b1c:	90 90 bc 0c 	lds	r9, 0x0CBC	; 0x800cbc <gc_block+0x26>
    1b20:	a0 90 bd 0c 	lds	r10, 0x0CBD	; 0x800cbd <gc_block+0x27>
    1b24:	b0 90 be 0c 	lds	r11, 0x0CBE	; 0x800cbe <gc_block+0x28>
    1b28:	20 e0       	ldi	r18, 0x00	; 0
    1b2a:	30 e0       	ldi	r19, 0x00	; 0
    1b2c:	40 e8       	ldi	r20, 0x80	; 128
    1b2e:	50 e4       	ldi	r21, 0x40	; 64
    1b30:	c5 01       	movw	r24, r10
    1b32:	b4 01       	movw	r22, r8
    1b34:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    1b38:	a5 01       	movw	r20, r10
    1b3a:	94 01       	movw	r18, r8
    1b3c:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    1b40:	4b 01       	movw	r8, r22
    1b42:	5c 01       	movw	r10, r24
    1b44:	2a a5       	ldd	r18, Y+42	; 0x2a
    1b46:	3b a5       	ldd	r19, Y+43	; 0x2b
    1b48:	4c a5       	ldd	r20, Y+44	; 0x2c
    1b4a:	5d a5       	ldd	r21, Y+45	; 0x2d
    1b4c:	ca 01       	movw	r24, r20
    1b4e:	b9 01       	movw	r22, r18
    1b50:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    1b54:	9b 01       	movw	r18, r22
    1b56:	ac 01       	movw	r20, r24
    1b58:	c5 01       	movw	r24, r10
    1b5a:	b4 01       	movw	r22, r8
    1b5c:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    1b60:	4b 01       	movw	r8, r22
    1b62:	5c 01       	movw	r10, r24
    1b64:	2e a5       	ldd	r18, Y+46	; 0x2e
    1b66:	3f a5       	ldd	r19, Y+47	; 0x2f
    1b68:	48 a9       	ldd	r20, Y+48	; 0x30
    1b6a:	59 a9       	ldd	r21, Y+49	; 0x31
    1b6c:	ca 01       	movw	r24, r20
    1b6e:	b9 01       	movw	r22, r18
    1b70:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    1b74:	9b 01       	movw	r18, r22
    1b76:	ac 01       	movw	r20, r24
    1b78:	c5 01       	movw	r24, r10
    1b7a:	b4 01       	movw	r22, r8
    1b7c:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    1b80:	4b 01       	movw	r8, r22
    1b82:	5c 01       	movw	r10, r24

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    1b84:	20 e0       	ldi	r18, 0x00	; 0
    1b86:	30 e0       	ldi	r19, 0x00	; 0
    1b88:	a9 01       	movw	r20, r18
    1b8a:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    1b8e:	88 23       	and	r24, r24
    1b90:	0c f4       	brge	.+2      	; 0x1b94 <gc_execute_line+0xcc6>
    1b92:	18 c4       	rjmp	.+2096   	; 0x23c4 <__stack+0x1c5>

            // Finish computing h_x2_div_d.
            h_x2_div_d = -sqrt(h_x2_div_d)/hypot_f(x,y); // == -(h * 2 / d)
    1b94:	c5 01       	movw	r24, r10
    1b96:	b4 01       	movw	r22, r8
    1b98:	0e 94 30 42 	call	0x8460	; 0x8460 <sqrt>
    1b9c:	4b 01       	movw	r8, r22
    1b9e:	5c 01       	movw	r10, r24
    1ba0:	2e a5       	ldd	r18, Y+46	; 0x2e
    1ba2:	3f a5       	ldd	r19, Y+47	; 0x2f
    1ba4:	48 a9       	ldd	r20, Y+48	; 0x30
    1ba6:	59 a9       	ldd	r21, Y+49	; 0x31
    1ba8:	6a a5       	ldd	r22, Y+42	; 0x2a
    1baa:	7b a5       	ldd	r23, Y+43	; 0x2b
    1bac:	8c a5       	ldd	r24, Y+44	; 0x2c
    1bae:	9d a5       	ldd	r25, Y+45	; 0x2d
    1bb0:	0e 94 11 2f 	call	0x5e22	; 0x5e22 <hypot_f>
    1bb4:	9b 01       	movw	r18, r22
    1bb6:	ac 01       	movw	r20, r24
    1bb8:	c5 01       	movw	r24, r10
    1bba:	b4 01       	movw	r22, r8
    1bbc:	90 58       	subi	r25, 0x80	; 128
    1bbe:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__divsf3>
    1bc2:	4b 01       	movw	r8, r22
    1bc4:	5c 01       	movw	r10, r24
            // Invert the sign of h_x2_div_d if the circle is counter clockwise (see sketch below)
            if (gc_block.modal.motion == MOTION_MODE_CCW_ARC) { h_x2_div_d = -h_x2_div_d; }
    1bc6:	80 91 97 0c 	lds	r24, 0x0C97	; 0x800c97 <gc_block+0x1>
    1bca:	83 30       	cpi	r24, 0x03	; 3
    1bcc:	21 f4       	brne	.+8      	; 0x1bd6 <gc_execute_line+0xd08>
    1bce:	b7 fa       	bst	r11, 7
    1bd0:	b0 94       	com	r11
    1bd2:	b7 f8       	bld	r11, 7
    1bd4:	b0 94       	com	r11
            */
            // Negative R is g-code-alese for "I want a circle with more than 180 degrees of travel" (go figure!),
            // even though it is advised against ever generating such circles in a single line of g-code. By
            // inverting the sign of h_x2_div_d the center of the circles is placed on the opposite side of the line of
            // travel and thus we get the unadvisably long arcs as prescribed.
            if (gc_block.values.r < 0) {
    1bd6:	40 90 bb 0c 	lds	r4, 0x0CBB	; 0x800cbb <gc_block+0x25>
    1bda:	50 90 bc 0c 	lds	r5, 0x0CBC	; 0x800cbc <gc_block+0x26>
    1bde:	60 90 bd 0c 	lds	r6, 0x0CBD	; 0x800cbd <gc_block+0x27>
    1be2:	70 90 be 0c 	lds	r7, 0x0CBE	; 0x800cbe <gc_block+0x28>
    1be6:	20 e0       	ldi	r18, 0x00	; 0
    1be8:	30 e0       	ldi	r19, 0x00	; 0
    1bea:	a9 01       	movw	r20, r18
    1bec:	c3 01       	movw	r24, r6
    1bee:	b2 01       	movw	r22, r4
    1bf0:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    1bf4:	88 23       	and	r24, r24
    1bf6:	84 f4       	brge	.+32     	; 0x1c18 <gc_execute_line+0xd4a>
                h_x2_div_d = -h_x2_div_d;
    1bf8:	b7 fa       	bst	r11, 7
    1bfa:	b0 94       	com	r11
    1bfc:	b7 f8       	bld	r11, 7
    1bfe:	b0 94       	com	r11
                gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
    1c00:	77 fa       	bst	r7, 7
    1c02:	70 94       	com	r7
    1c04:	77 f8       	bld	r7, 7
    1c06:	70 94       	com	r7
    1c08:	40 92 bb 0c 	sts	0x0CBB, r4	; 0x800cbb <gc_block+0x25>
    1c0c:	50 92 bc 0c 	sts	0x0CBC, r5	; 0x800cbc <gc_block+0x26>
    1c10:	60 92 bd 0c 	sts	0x0CBD, r6	; 0x800cbd <gc_block+0x27>
    1c14:	70 92 be 0c 	sts	0x0CBE, r7	; 0x800cbe <gc_block+0x28>
            }
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
    1c18:	0b a9       	ldd	r16, Y+51	; 0x33
    1c1a:	1c a9       	ldd	r17, Y+52	; 0x34
    1c1c:	00 0f       	add	r16, r16
    1c1e:	11 1f       	adc	r17, r17
    1c20:	00 0f       	add	r16, r16
    1c22:	11 1f       	adc	r17, r17
    1c24:	0a 55       	subi	r16, 0x5A	; 90
    1c26:	13 4f       	sbci	r17, 0xF3	; 243
    1c28:	2e a5       	ldd	r18, Y+46	; 0x2e
    1c2a:	3f a5       	ldd	r19, Y+47	; 0x2f
    1c2c:	48 a9       	ldd	r20, Y+48	; 0x30
    1c2e:	59 a9       	ldd	r21, Y+49	; 0x31
    1c30:	c5 01       	movw	r24, r10
    1c32:	b4 01       	movw	r22, r8
    1c34:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    1c38:	9b 01       	movw	r18, r22
    1c3a:	ac 01       	movw	r20, r24
    1c3c:	6a a5       	ldd	r22, Y+42	; 0x2a
    1c3e:	7b a5       	ldd	r23, Y+43	; 0x2b
    1c40:	8c a5       	ldd	r24, Y+44	; 0x2c
    1c42:	9d a5       	ldd	r25, Y+45	; 0x2d
    1c44:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    1c48:	20 e0       	ldi	r18, 0x00	; 0
    1c4a:	30 e0       	ldi	r19, 0x00	; 0
    1c4c:	40 e0       	ldi	r20, 0x00	; 0
    1c4e:	5f e3       	ldi	r21, 0x3F	; 63
    1c50:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    1c54:	d8 01       	movw	r26, r16
    1c56:	6d 93       	st	X+, r22
    1c58:	7d 93       	st	X+, r23
    1c5a:	8d 93       	st	X+, r24
    1c5c:	9c 93       	st	X, r25
    1c5e:	13 97       	sbiw	r26, 0x03	; 3
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
    1c60:	86 01       	movw	r16, r12
    1c62:	00 0f       	add	r16, r16
    1c64:	11 1f       	adc	r17, r17
    1c66:	00 0f       	add	r16, r16
    1c68:	11 1f       	adc	r17, r17
    1c6a:	0a 55       	subi	r16, 0x5A	; 90
    1c6c:	13 4f       	sbci	r17, 0xF3	; 243
    1c6e:	2a a5       	ldd	r18, Y+42	; 0x2a
    1c70:	3b a5       	ldd	r19, Y+43	; 0x2b
    1c72:	4c a5       	ldd	r20, Y+44	; 0x2c
    1c74:	5d a5       	ldd	r21, Y+45	; 0x2d
    1c76:	c5 01       	movw	r24, r10
    1c78:	b4 01       	movw	r22, r8
    1c7a:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    1c7e:	2e a5       	ldd	r18, Y+46	; 0x2e
    1c80:	3f a5       	ldd	r19, Y+47	; 0x2f
    1c82:	48 a9       	ldd	r20, Y+48	; 0x30
    1c84:	59 a9       	ldd	r21, Y+49	; 0x31
    1c86:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    1c8a:	20 e0       	ldi	r18, 0x00	; 0
    1c8c:	30 e0       	ldi	r19, 0x00	; 0
    1c8e:	40 e0       	ldi	r20, 0x00	; 0
    1c90:	5f e3       	ldi	r21, 0x3F	; 63
    1c92:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    1c96:	f8 01       	movw	r30, r16
    1c98:	60 83       	st	Z, r22
    1c9a:	71 83       	std	Z+1, r23	; 0x01
    1c9c:	82 83       	std	Z+2, r24	; 0x02
    1c9e:	93 83       	std	Z+3, r25	; 0x03
    1ca0:	c6 c0       	rjmp	.+396    	; 0x1e2e <gc_execute_line+0xf60>

          } else { // Arc Center Format Offset Mode
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    1ca2:	ff a1       	ldd	r31, Y+39	; 0x27
    1ca4:	8f 2e       	mov	r8, r31
    1ca6:	91 2c       	mov	r9, r1
    1ca8:	08 21       	and	r16, r8
    1caa:	19 21       	and	r17, r9
    1cac:	01 2b       	or	r16, r17
    1cae:	09 f4       	brne	.+2      	; 0x1cb2 <gc_execute_line+0xde4>
    1cb0:	8b c3       	rjmp	.+1814   	; 0x23c8 <__stack+0x1c9>
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));
    1cb2:	21 ef       	ldi	r18, 0xF1	; 241
    1cb4:	22 22       	and	r2, r18

            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
    1cb6:	80 91 99 0c 	lds	r24, 0x0C99	; 0x800c99 <gc_block+0x3>
    1cba:	81 30       	cpi	r24, 0x01	; 1
    1cbc:	41 f5       	brne	.+80     	; 0x1d0e <gc_execute_line+0xe40>
    1cbe:	06 e9       	ldi	r16, 0x96	; 150
    1cc0:	1c e0       	ldi	r17, 0x0C	; 12
    1cc2:	a1 2c       	mov	r10, r1
    1cc4:	b1 2c       	mov	r11, r1
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
    1cc6:	c4 01       	movw	r24, r8
    1cc8:	0a 2c       	mov	r0, r10
    1cca:	02 c0       	rjmp	.+4      	; 0x1cd0 <gc_execute_line+0xe02>
    1ccc:	95 95       	asr	r25
    1cce:	87 95       	ror	r24
    1cd0:	0a 94       	dec	r0
    1cd2:	e2 f7       	brpl	.-8      	; 0x1ccc <gc_execute_line+0xdfe>
    1cd4:	80 ff       	sbrs	r24, 0
    1cd6:	12 c0       	rjmp	.+36     	; 0x1cfc <gc_execute_line+0xe2e>
    1cd8:	23 e3       	ldi	r18, 0x33	; 51
    1cda:	33 e3       	ldi	r19, 0x33	; 51
    1cdc:	4b ec       	ldi	r20, 0xCB	; 203
    1cde:	51 e4       	ldi	r21, 0x41	; 65
    1ce0:	d8 01       	movw	r26, r16
    1ce2:	50 96       	adiw	r26, 0x10	; 16
    1ce4:	6d 91       	ld	r22, X+
    1ce6:	7d 91       	ld	r23, X+
    1ce8:	8d 91       	ld	r24, X+
    1cea:	9c 91       	ld	r25, X
    1cec:	53 97       	sbiw	r26, 0x13	; 19
    1cee:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    1cf2:	f8 01       	movw	r30, r16
    1cf4:	60 8b       	std	Z+16, r22	; 0x10
    1cf6:	71 8b       	std	Z+17, r23	; 0x11
    1cf8:	82 8b       	std	Z+18, r24	; 0x12
    1cfa:	93 8b       	std	Z+19, r25	; 0x13
    1cfc:	ff ef       	ldi	r31, 0xFF	; 255
    1cfe:	af 1a       	sub	r10, r31
    1d00:	bf 0a       	sbc	r11, r31
    1d02:	0c 5f       	subi	r16, 0xFC	; 252
    1d04:	1f 4f       	sbci	r17, 0xFF	; 255
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));

            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    1d06:	23 e0       	ldi	r18, 0x03	; 3
    1d08:	a2 16       	cp	r10, r18
    1d0a:	b1 04       	cpc	r11, r1
    1d0c:	e1 f6       	brne	.-72     	; 0x1cc6 <gc_execute_line+0xdf8>
              }
            }

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
    1d0e:	c6 01       	movw	r24, r12
    1d10:	88 0f       	add	r24, r24
    1d12:	99 1f       	adc	r25, r25
    1d14:	88 0f       	add	r24, r24
    1d16:	99 1f       	adc	r25, r25
    1d18:	dc 01       	movw	r26, r24
    1d1a:	aa 55       	subi	r26, 0x5A	; 90
    1d1c:	b3 4f       	sbci	r27, 0xF3	; 243
    1d1e:	6d 01       	movw	r12, r26
            float target_r = hypot_f(x,y);
    1d20:	2d 91       	ld	r18, X+
    1d22:	3d 91       	ld	r19, X+
    1d24:	4d 91       	ld	r20, X+
    1d26:	5c 91       	ld	r21, X
    1d28:	6e a5       	ldd	r22, Y+46	; 0x2e
    1d2a:	7f a5       	ldd	r23, Y+47	; 0x2f
    1d2c:	88 a9       	ldd	r24, Y+48	; 0x30
    1d2e:	99 a9       	ldd	r25, Y+49	; 0x31
    1d30:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    1d34:	4b 01       	movw	r8, r22
    1d36:	5c 01       	movw	r10, r24
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
              }
            }

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
    1d38:	0b a9       	ldd	r16, Y+51	; 0x33
    1d3a:	1c a9       	ldd	r17, Y+52	; 0x34
    1d3c:	00 0f       	add	r16, r16
    1d3e:	11 1f       	adc	r17, r17
    1d40:	00 0f       	add	r16, r16
    1d42:	11 1f       	adc	r17, r17
    1d44:	0a 55       	subi	r16, 0x5A	; 90
    1d46:	13 4f       	sbci	r17, 0xF3	; 243
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
            float target_r = hypot_f(x,y);
    1d48:	f8 01       	movw	r30, r16
    1d4a:	20 81       	ld	r18, Z
    1d4c:	31 81       	ldd	r19, Z+1	; 0x01
    1d4e:	42 81       	ldd	r20, Z+2	; 0x02
    1d50:	53 81       	ldd	r21, Z+3	; 0x03
    1d52:	6a a5       	ldd	r22, Y+42	; 0x2a
    1d54:	7b a5       	ldd	r23, Y+43	; 0x2b
    1d56:	8c a5       	ldd	r24, Y+44	; 0x2c
    1d58:	9d a5       	ldd	r25, Y+45	; 0x2d
    1d5a:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    1d5e:	a5 01       	movw	r20, r10
    1d60:	94 01       	movw	r18, r8
    1d62:	0e 94 11 2f 	call	0x5e22	; 0x5e22 <hypot_f>
    1d66:	4b 01       	movw	r8, r22
    1d68:	5c 01       	movw	r10, r24

            // Compute arc radius for mc_arc. Defined from current location to center.
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]);
    1d6a:	d6 01       	movw	r26, r12
    1d6c:	2d 91       	ld	r18, X+
    1d6e:	3d 91       	ld	r19, X+
    1d70:	4d 91       	ld	r20, X+
    1d72:	5c 91       	ld	r21, X
    1d74:	f8 01       	movw	r30, r16
    1d76:	60 81       	ld	r22, Z
    1d78:	71 81       	ldd	r23, Z+1	; 0x01
    1d7a:	82 81       	ldd	r24, Z+2	; 0x02
    1d7c:	93 81       	ldd	r25, Z+3	; 0x03
    1d7e:	0e 94 11 2f 	call	0x5e22	; 0x5e22 <hypot_f>
    1d82:	2b 01       	movw	r4, r22
    1d84:	3c 01       	movw	r6, r24
    1d86:	60 93 bb 0c 	sts	0x0CBB, r22	; 0x800cbb <gc_block+0x25>
    1d8a:	70 93 bc 0c 	sts	0x0CBC, r23	; 0x800cbc <gc_block+0x26>
    1d8e:	80 93 bd 0c 	sts	0x0CBD, r24	; 0x800cbd <gc_block+0x27>
    1d92:	90 93 be 0c 	sts	0x0CBE, r25	; 0x800cbe <gc_block+0x28>

            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
    1d96:	9b 01       	movw	r18, r22
    1d98:	ac 01       	movw	r20, r24
    1d9a:	c5 01       	movw	r24, r10
    1d9c:	b4 01       	movw	r22, r8
    1d9e:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    1da2:	4b 01       	movw	r8, r22
    1da4:	5c 01       	movw	r10, r24
    1da6:	e8 94       	clt
    1da8:	b7 f8       	bld	r11, 7
            if (delta_r > 0.005) {
    1daa:	2a e0       	ldi	r18, 0x0A	; 10
    1dac:	37 ed       	ldi	r19, 0xD7	; 215
    1dae:	43 ea       	ldi	r20, 0xA3	; 163
    1db0:	5b e3       	ldi	r21, 0x3B	; 59
    1db2:	c5 01       	movw	r24, r10
    1db4:	b4 01       	movw	r22, r8
    1db6:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    1dba:	18 16       	cp	r1, r24
    1dbc:	c4 f5       	brge	.+112    	; 0x1e2e <gc_execute_line+0xf60>
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    1dbe:	20 e0       	ldi	r18, 0x00	; 0
    1dc0:	30 e0       	ldi	r19, 0x00	; 0
    1dc2:	40 e0       	ldi	r20, 0x00	; 0
    1dc4:	5f e3       	ldi	r21, 0x3F	; 63
    1dc6:	c5 01       	movw	r24, r10
    1dc8:	b4 01       	movw	r22, r8
    1dca:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    1dce:	18 16       	cp	r1, r24
    1dd0:	0c f4       	brge	.+2      	; 0x1dd4 <gc_execute_line+0xf06>
    1dd2:	fc c2       	rjmp	.+1528   	; 0x23cc <__stack+0x1cd>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    1dd4:	2f e6       	ldi	r18, 0x6F	; 111
    1dd6:	32 e1       	ldi	r19, 0x12	; 18
    1dd8:	43 e8       	ldi	r20, 0x83	; 131
    1dda:	5a e3       	ldi	r21, 0x3A	; 58
    1ddc:	c3 01       	movw	r24, r6
    1dde:	b2 01       	movw	r22, r4
    1de0:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    1de4:	9b 01       	movw	r18, r22
    1de6:	ac 01       	movw	r20, r24
    1de8:	c5 01       	movw	r24, r10
    1dea:	b4 01       	movw	r22, r8
    1dec:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    1df0:	18 16       	cp	r1, r24
    1df2:	0c f4       	brge	.+2      	; 0x1df6 <gc_execute_line+0xf28>
    1df4:	ed c2       	rjmp	.+1498   	; 0x23d0 <__stack+0x1d1>
    1df6:	1b c0       	rjmp	.+54     	; 0x1e2e <gc_execute_line+0xf60>
            }
          }
          break;
        case MOTION_MODE_PROBE_TOWARD_NO_ERROR: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          gc_parser_flags |= GC_PARSER_PROBE_IS_NO_ERROR; // No break intentional.
    1df8:	f8 a5       	ldd	r31, Y+40	; 0x28
    1dfa:	f0 61       	ori	r31, 0x10	; 16
    1dfc:	f8 a7       	std	Y+40, r31	; 0x28
        case MOTION_MODE_PROBE_TOWARD: case MOTION_MODE_PROBE_AWAY:
          if ((gc_block.modal.motion == MOTION_MODE_PROBE_AWAY) || 
    1dfe:	1e 58       	subi	r17, 0x8E	; 142
    1e00:	12 30       	cpi	r17, 0x02	; 2
    1e02:	18 f4       	brcc	.+6      	; 0x1e0a <gc_execute_line+0xf3c>
              (gc_block.modal.motion == MOTION_MODE_PROBE_AWAY_NO_ERROR)) { gc_parser_flags |= GC_PARSER_PROBE_IS_AWAY; }
    1e04:	28 a5       	ldd	r18, Y+40	; 0x28
    1e06:	28 60       	ori	r18, 0x08	; 8
    1e08:	28 a7       	std	Y+40, r18	; 0x28
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1e0a:	3d a1       	ldd	r19, Y+37	; 0x25
    1e0c:	33 23       	and	r19, r19
    1e0e:	09 f4       	brne	.+2      	; 0x1e12 <gc_execute_line+0xf44>
    1e10:	e1 c2       	rjmp	.+1474   	; 0x23d4 <__stack+0x1d5>
          if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    1e12:	4c e0       	ldi	r20, 0x0C	; 12
    1e14:	50 e0       	ldi	r21, 0x00	; 0
    1e16:	64 ec       	ldi	r22, 0xC4	; 196
    1e18:	7c e0       	ldi	r23, 0x0C	; 12
    1e1a:	8e e6       	ldi	r24, 0x6E	; 110
    1e1c:	9c e0       	ldi	r25, 0x0C	; 12
    1e1e:	0e 94 c9 42 	call	0x8592	; 0x8592 <memcmp>
    1e22:	89 2b       	or	r24, r25
    1e24:	09 f4       	brne	.+2      	; 0x1e28 <gc_execute_line+0xf5a>
    1e26:	d8 c2       	rjmp	.+1456   	; 0x23d8 <__stack+0x1d9>
    1e28:	02 c0       	rjmp	.+4      	; 0x1e2e <gc_execute_line+0xf60>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    1e2a:	1f 8e       	std	Y+31, r1	; 0x1f
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
            }
          } else {
            axis_command = AXIS_COMMAND_NONE; // Set to none if no intermediate motion.
    1e2c:	1e a2       	std	Y+38, r1	; 0x26

  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    1e2e:	48 a5       	ldd	r20, Y+40	; 0x28
    1e30:	41 70       	andi	r20, 0x01	; 1
    1e32:	d4 2e       	mov	r13, r20
    1e34:	88 a5       	ldd	r24, Y+40	; 0x28
    1e36:	80 ff       	sbrs	r24, 0
    1e38:	03 c0       	rjmp	.+6      	; 0x1e40 <gc_execute_line+0xf72>
    // Jogging only uses the F feed rate and XYZ value words. N is valid, but S and T are invalid.
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)));
    1e3a:	c1 01       	movw	r24, r2
    1e3c:	8e 7d       	andi	r24, 0xDE	; 222
    1e3e:	03 c0       	rjmp	.+6      	; 0x1e46 <gc_execute_line+0xf78>
  } else {
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words.
    1e40:	c1 01       	movw	r24, r2
    1e42:	8e 7d       	andi	r24, 0xDE	; 222
    1e44:	9c 7f       	andi	r25, 0xFC	; 252
  }
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words.
    1e46:	ae a1       	ldd	r26, Y+38	; 0x26
    1e48:	a1 11       	cpse	r26, r1
    1e4a:	93 7e       	andi	r25, 0xE3	; 227
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    1e4c:	89 2b       	or	r24, r25
    1e4e:	09 f0       	breq	.+2      	; 0x1e52 <gc_execute_line+0xf84>
    1e50:	c5 c2       	rjmp	.+1418   	; 0x23dc <__stack+0x1dd>
  */

  // Initialize planner data struct for motion blocks.
  plan_line_data_t plan_data;
  plan_line_data_t *pl_data = &plan_data;
  memset(pl_data,0,sizeof(plan_line_data_t)); // Zero pl_data struct
    1e52:	fe 01       	movw	r30, r28
    1e54:	72 96       	adiw	r30, 0x12	; 18
    1e56:	8d e0       	ldi	r24, 0x0D	; 13
    1e58:	df 01       	movw	r26, r30
    1e5a:	1d 92       	st	X+, r1
    1e5c:	8a 95       	dec	r24
    1e5e:	e9 f7       	brne	.-6      	; 0x1e5a <gc_execute_line+0xf8c>

  // Intercept jog commands and complete error checking for valid jog commands and execute.
  // NOTE: G-code parser state is not updated, except the position to ensure sequential jog
  // targets are computed correctly. The final parser position after a jog is updated in
  // protocol_execute_realtime() when jogging completes or is canceled.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    1e60:	dd 20       	and	r13, r13
    1e62:	59 f1       	breq	.+86     	; 0x1eba <gc_execute_line+0xfec>
    // Only distance and unit modal commands and G53 absolute override command are allowed.
    // NOTE: Feed rate word and axis word checks have already been performed in STEP 3.
    if (command_words & ~(bit(MODAL_GROUP_G3) | bit(MODAL_GROUP_G6 | bit(MODAL_GROUP_G0))) ) { FAIL(STATUS_INVALID_JOG_COMMAND) };
    1e64:	b6 eb       	ldi	r27, 0xB6	; 182
    1e66:	eb 22       	and	r14, r27
    1e68:	ef 28       	or	r14, r15
    1e6a:	09 f0       	breq	.+2      	; 0x1e6e <gc_execute_line+0xfa0>
    1e6c:	b9 c2       	rjmp	.+1394   	; 0x23e0 <__stack+0x1e1>
    if (!(gc_block.non_modal_command == NON_MODAL_ABSOLUTE_OVERRIDE || gc_block.non_modal_command == NON_MODAL_NO_ACTION)) { FAIL(STATUS_INVALID_JOG_COMMAND); }
    1e6e:	80 91 96 0c 	lds	r24, 0x0C96	; 0x800c96 <gc_block>
    1e72:	85 33       	cpi	r24, 0x35	; 53
    1e74:	11 f0       	breq	.+4      	; 0x1e7a <gc_execute_line+0xfac>
    1e76:	81 11       	cpse	r24, r1
    1e78:	b5 c2       	rjmp	.+1386   	; 0x23e4 <__stack+0x1e5>

    // Initialize planner data to current spindle and coolant modal state.
    pl_data->spindle_speed = gc_state.spindle_speed;
    1e7a:	e6 e5       	ldi	r30, 0x56	; 86
    1e7c:	fc e0       	ldi	r31, 0x0C	; 12
    1e7e:	83 85       	ldd	r24, Z+11	; 0x0b
    1e80:	94 85       	ldd	r25, Z+12	; 0x0c
    1e82:	a5 85       	ldd	r26, Z+13	; 0x0d
    1e84:	b6 85       	ldd	r27, Z+14	; 0x0e
    1e86:	8e 8b       	std	Y+22, r24	; 0x16
    1e88:	9f 8b       	std	Y+23, r25	; 0x17
    1e8a:	a8 8f       	std	Y+24, r26	; 0x18
    1e8c:	b9 8f       	std	Y+25, r27	; 0x19
    plan_data.condition = (gc_state.modal.spindle | gc_state.modal.coolant);
    1e8e:	91 85       	ldd	r25, Z+9	; 0x09
    1e90:	80 85       	ldd	r24, Z+8	; 0x08
    1e92:	89 2b       	or	r24, r25
    1e94:	8e 8f       	std	Y+30, r24	; 0x1e

    uint8_t status = jog_execute(&plan_data, &gc_block);
    1e96:	66 e9       	ldi	r22, 0x96	; 150
    1e98:	7c e0       	ldi	r23, 0x0C	; 12
    1e9a:	ce 01       	movw	r24, r28
    1e9c:	42 96       	adiw	r24, 0x12	; 18
    1e9e:	0e 94 4a 3e 	call	0x7c94	; 0x7c94 <jog_execute>
    if (status == STATUS_OK) { memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); }
    1ea2:	81 11       	cpse	r24, r1
    1ea4:	d9 c2       	rjmp	.+1458   	; 0x2458 <__stack+0x259>
    1ea6:	9c e0       	ldi	r25, 0x0C	; 12
    1ea8:	e4 ec       	ldi	r30, 0xC4	; 196
    1eaa:	fc e0       	ldi	r31, 0x0C	; 12
    1eac:	ae e6       	ldi	r26, 0x6E	; 110
    1eae:	bc e0       	ldi	r27, 0x0C	; 12
    1eb0:	01 90       	ld	r0, Z+
    1eb2:	0d 92       	st	X+, r0
    1eb4:	9a 95       	dec	r25
    1eb6:	e1 f7       	brne	.-8      	; 0x1eb0 <gc_execute_line+0xfe2>
    1eb8:	cf c2       	rjmp	.+1438   	; 0x2458 <__stack+0x259>
    return(status);
  }
  
  // If in laser mode, setup laser power based on current and past parser conditions.
  if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    1eba:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    1ebe:	81 ff       	sbrs	r24, 1
    1ec0:	26 c0       	rjmp	.+76     	; 0x1f0e <gc_execute_line+0x1040>
    if ( !((gc_block.modal.motion == MOTION_MODE_LINEAR) || (gc_block.modal.motion == MOTION_MODE_CW_ARC) 
    1ec2:	80 91 97 0c 	lds	r24, 0x0C97	; 0x800c97 <gc_block+0x1>
    1ec6:	81 50       	subi	r24, 0x01	; 1
    1ec8:	83 30       	cpi	r24, 0x03	; 3
    1eca:	18 f0       	brcs	.+6      	; 0x1ed2 <gc_execute_line+0x1004>
        || (gc_block.modal.motion == MOTION_MODE_CCW_ARC)) ) {
      gc_parser_flags |= GC_PARSER_LASER_DISABLE;
    1ecc:	e8 a5       	ldd	r30, Y+40	; 0x28
    1ece:	e0 64       	ori	r30, 0x40	; 64
    1ed0:	e8 a7       	std	Y+40, r30	; 0x28
    }

    // Any motion mode with axis words is allowed to be passed from a spindle speed update. 
    // NOTE: G1 and G0 without axis words sets axis_command to none. G28/30 are intentionally omitted.
    // TODO: Check sync conditions for M3 enabled motions that don't enter the planner. (zero length).
    if (axis_words && (axis_command == AXIS_COMMAND_MOTION_MODE)) { 
    1ed2:	fd a1       	ldd	r31, Y+37	; 0x25
    1ed4:	ff 23       	and	r31, r31
    1ed6:	39 f0       	breq	.+14     	; 0x1ee6 <gc_execute_line+0x1018>
    1ed8:	2e a1       	ldd	r18, Y+38	; 0x26
    1eda:	22 30       	cpi	r18, 0x02	; 2
    1edc:	21 f4       	brne	.+8      	; 0x1ee6 <gc_execute_line+0x1018>
      gc_parser_flags |= GC_PARSER_LASER_ISMOTION; 
    1ede:	38 a5       	ldd	r19, Y+40	; 0x28
    1ee0:	30 68       	ori	r19, 0x80	; 128
    1ee2:	38 a7       	std	Y+40, r19	; 0x28
    1ee4:	14 c0       	rjmp	.+40     	; 0x1f0e <gc_execute_line+0x1040>
    } else {
      // M3 constant power laser requires planner syncs to update the laser when changing between
      // a G1/2/3 motion mode state and vice versa when there is no motion in the line.
      if (gc_state.modal.spindle == SPINDLE_ENABLE_CW) {
    1ee6:	80 91 5f 0c 	lds	r24, 0x0C5F	; 0x800c5f <gc_state+0x9>
    1eea:	80 31       	cpi	r24, 0x10	; 16
    1eec:	81 f4       	brne	.+32     	; 0x1f0e <gc_execute_line+0x1040>
        if ((gc_state.modal.motion == MOTION_MODE_LINEAR) || (gc_state.modal.motion == MOTION_MODE_CW_ARC) 
    1eee:	80 91 56 0c 	lds	r24, 0x0C56	; 0x800c56 <gc_state>
    1ef2:	81 50       	subi	r24, 0x01	; 1
    1ef4:	83 30       	cpi	r24, 0x03	; 3
    1ef6:	30 f4       	brcc	.+12     	; 0x1f04 <gc_execute_line+0x1036>
            || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
          if (bit_istrue(gc_parser_flags,GC_PARSER_LASER_DISABLE)) { 
    1ef8:	48 a5       	ldd	r20, Y+40	; 0x28
    1efa:	46 ff       	sbrs	r20, 6
    1efc:	08 c0       	rjmp	.+16     	; 0x1f0e <gc_execute_line+0x1040>
            gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC; // Change from G1/2/3 motion mode.
    1efe:	40 62       	ori	r20, 0x20	; 32
    1f00:	48 a7       	std	Y+40, r20	; 0x28
    1f02:	05 c0       	rjmp	.+10     	; 0x1f0e <gc_execute_line+0x1040>
          }
        } else {
          // When changing to a G1 motion mode without axis words from a non-G1/2/3 motion mode.
          if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_DISABLE)) { 
    1f04:	88 a5       	ldd	r24, Y+40	; 0x28
    1f06:	86 fd       	sbrc	r24, 6
    1f08:	02 c0       	rjmp	.+4      	; 0x1f0e <gc_execute_line+0x1040>
            gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC;
    1f0a:	80 62       	ori	r24, 0x20	; 32
    1f0c:	88 a7       	std	Y+40, r24	; 0x28
    }
  }

  // [0. Non-specific/common error-checks and miscellaneous setup]:
  // NOTE: If no line number is present, the value is zero.
  gc_state.line_number = gc_block.values.n;
    1f0e:	a6 e9       	ldi	r26, 0x96	; 150
    1f10:	bc e0       	ldi	r27, 0x0C	; 12
    1f12:	5d 96       	adiw	r26, 0x1d	; 29
    1f14:	4d 91       	ld	r20, X+
    1f16:	5d 91       	ld	r21, X+
    1f18:	6d 91       	ld	r22, X+
    1f1a:	7c 91       	ld	r23, X
    1f1c:	90 97       	sbiw	r26, 0x20	; 32
    1f1e:	e6 e5       	ldi	r30, 0x56	; 86
    1f20:	fc e0       	ldi	r31, 0x0C	; 12
    1f22:	44 8b       	std	Z+20, r20	; 0x14
    1f24:	55 8b       	std	Z+21, r21	; 0x15
    1f26:	66 8b       	std	Z+22, r22	; 0x16
    1f28:	77 8b       	std	Z+23, r23	; 0x17
  pl_data->line_number = gc_state.line_number; // Record data for planner use.
    1f2a:	4a 8f       	std	Y+26, r20	; 0x1a
    1f2c:	5b 8f       	std	Y+27, r21	; 0x1b
    1f2e:	6c 8f       	std	Y+28, r22	; 0x1c
    1f30:	7d 8f       	std	Y+29, r23	; 0x1d

  // [1. Comments feedback ]:  NOT SUPPORTED

  // [2. Set feed rate mode ]:
  gc_state.modal.feed_rate = gc_block.modal.feed_rate;
    1f32:	12 96       	adiw	r26, 0x02	; 2
    1f34:	8c 91       	ld	r24, X
    1f36:	81 83       	std	Z+1, r24	; 0x01
  if (gc_state.modal.feed_rate) { pl_data->condition |= PL_COND_FLAG_INVERSE_TIME; } // Set condition flag for planner use.
    1f38:	88 23       	and	r24, r24
    1f3a:	11 f0       	breq	.+4      	; 0x1f40 <gc_execute_line+0x1072>
    1f3c:	88 e0       	ldi	r24, 0x08	; 8
    1f3e:	8e 8f       	std	Y+30, r24	; 0x1e

  // [3. Set feed rate ]:
  gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
    1f40:	a6 e9       	ldi	r26, 0x96	; 150
    1f42:	bc e0       	ldi	r27, 0x0C	; 12
    1f44:	1c 96       	adiw	r26, 0x0c	; 12
    1f46:	4d 91       	ld	r20, X+
    1f48:	5d 91       	ld	r21, X+
    1f4a:	6d 91       	ld	r22, X+
    1f4c:	7c 91       	ld	r23, X
    1f4e:	1f 97       	sbiw	r26, 0x0f	; 15
    1f50:	e6 e5       	ldi	r30, 0x56	; 86
    1f52:	fc e0       	ldi	r31, 0x0C	; 12
    1f54:	47 87       	std	Z+15, r20	; 0x0f
    1f56:	50 8b       	std	Z+16, r21	; 0x10
    1f58:	61 8b       	std	Z+17, r22	; 0x11
    1f5a:	72 8b       	std	Z+18, r23	; 0x12
  pl_data->feed_rate = gc_state.feed_rate; // Record data for planner use.
    1f5c:	4a 8b       	std	Y+18, r20	; 0x12
    1f5e:	5b 8b       	std	Y+19, r21	; 0x13
    1f60:	6c 8b       	std	Y+20, r22	; 0x14
    1f62:	7d 8b       	std	Y+21, r23	; 0x15

  // [4. Set spindle speed ]:
  if ((gc_state.spindle_speed != gc_block.values.s) || bit_istrue(gc_parser_flags,GC_PARSER_LASER_FORCE_SYNC)) {
    1f64:	99 96       	adiw	r26, 0x29	; 41
    1f66:	8d 90       	ld	r8, X+
    1f68:	9d 90       	ld	r9, X+
    1f6a:	ad 90       	ld	r10, X+
    1f6c:	bc 90       	ld	r11, X
    1f6e:	9c 97       	sbiw	r26, 0x2c	; 44
    1f70:	a5 01       	movw	r20, r10
    1f72:	94 01       	movw	r18, r8
    1f74:	63 85       	ldd	r22, Z+11	; 0x0b
    1f76:	74 85       	ldd	r23, Z+12	; 0x0c
    1f78:	85 85       	ldd	r24, Z+13	; 0x0d
    1f7a:	96 85       	ldd	r25, Z+14	; 0x0e
    1f7c:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    1f80:	81 11       	cpse	r24, r1
    1f82:	03 c0       	rjmp	.+6      	; 0x1f8a <gc_execute_line+0x10bc>
    1f84:	98 a5       	ldd	r25, Y+40	; 0x28
    1f86:	95 ff       	sbrs	r25, 5
    1f88:	21 c0       	rjmp	.+66     	; 0x1fcc <gc_execute_line+0x10fe>
    if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
    1f8a:	80 91 5f 0c 	lds	r24, 0x0C5F	; 0x800c5f <gc_state+0x9>
    1f8e:	88 23       	and	r24, r24
    1f90:	69 f0       	breq	.+26     	; 0x1fac <gc_execute_line+0x10de>
      if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_ISMOTION)) {
    1f92:	a8 a5       	ldd	r26, Y+40	; 0x28
    1f94:	aa 23       	and	r26, r26
    1f96:	54 f0       	brlt	.+20     	; 0x1fac <gc_execute_line+0x10de>
        if (bit_istrue(gc_parser_flags,GC_PARSER_LASER_DISABLE)) {
    1f98:	a6 ff       	sbrs	r26, 6
    1f9a:	05 c0       	rjmp	.+10     	; 0x1fa6 <gc_execute_line+0x10d8>
           spindle_sync(gc_state.modal.spindle, 0.0);
    1f9c:	40 e0       	ldi	r20, 0x00	; 0
    1f9e:	50 e0       	ldi	r21, 0x00	; 0
    1fa0:	ba 01       	movw	r22, r20
    1fa2:	a6 d3       	rcall	.+1868   	; 0x26f0 <spindle_sync>
    1fa4:	03 c0       	rjmp	.+6      	; 0x1fac <gc_execute_line+0x10de>
        } else { spindle_sync(gc_state.modal.spindle, gc_block.values.s); }
    1fa6:	b5 01       	movw	r22, r10
    1fa8:	a4 01       	movw	r20, r8
    1faa:	a2 d3       	rcall	.+1860   	; 0x26f0 <spindle_sync>
      }
    }
    gc_state.spindle_speed = gc_block.values.s; // Update spindle speed state.
    1fac:	80 91 bf 0c 	lds	r24, 0x0CBF	; 0x800cbf <gc_block+0x29>
    1fb0:	90 91 c0 0c 	lds	r25, 0x0CC0	; 0x800cc0 <gc_block+0x2a>
    1fb4:	a0 91 c1 0c 	lds	r26, 0x0CC1	; 0x800cc1 <gc_block+0x2b>
    1fb8:	b0 91 c2 0c 	lds	r27, 0x0CC2	; 0x800cc2 <gc_block+0x2c>
    1fbc:	80 93 61 0c 	sts	0x0C61, r24	; 0x800c61 <gc_state+0xb>
    1fc0:	90 93 62 0c 	sts	0x0C62, r25	; 0x800c62 <gc_state+0xc>
    1fc4:	a0 93 63 0c 	sts	0x0C63, r26	; 0x800c63 <gc_state+0xd>
    1fc8:	b0 93 64 0c 	sts	0x0C64, r27	; 0x800c64 <gc_state+0xe>
  }
  // NOTE: Pass zero spindle speed for all restricted laser motions.
  if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_DISABLE)) {
    1fcc:	b8 a5       	ldd	r27, Y+40	; 0x28
    1fce:	b6 fd       	sbrc	r27, 6
    1fd0:	0c c0       	rjmp	.+24     	; 0x1fea <gc_execute_line+0x111c>
    pl_data->spindle_speed = gc_state.spindle_speed; // Record data for planner use. 
    1fd2:	80 91 61 0c 	lds	r24, 0x0C61	; 0x800c61 <gc_state+0xb>
    1fd6:	90 91 62 0c 	lds	r25, 0x0C62	; 0x800c62 <gc_state+0xc>
    1fda:	a0 91 63 0c 	lds	r26, 0x0C63	; 0x800c63 <gc_state+0xd>
    1fde:	b0 91 64 0c 	lds	r27, 0x0C64	; 0x800c64 <gc_state+0xe>
    1fe2:	8e 8b       	std	Y+22, r24	; 0x16
    1fe4:	9f 8b       	std	Y+23, r25	; 0x17
    1fe6:	a8 8f       	std	Y+24, r26	; 0x18
    1fe8:	b9 8f       	std	Y+25, r27	; 0x19
  } // else { pl_data->spindle_speed = 0.0; } // Initialized as zero already.
  
  // [5. Select tool ]: NOT SUPPORTED. Only tracks tool value.
  gc_state.tool = gc_block.values.t;
    1fea:	e6 e5       	ldi	r30, 0x56	; 86
    1fec:	fc e0       	ldi	r31, 0x0C	; 12
    1fee:	a6 e9       	ldi	r26, 0x96	; 150
    1ff0:	bc e0       	ldi	r27, 0x0C	; 12
    1ff2:	9d 96       	adiw	r26, 0x2d	; 45
    1ff4:	8c 91       	ld	r24, X
    1ff6:	9d 97       	sbiw	r26, 0x2d	; 45
    1ff8:	83 8b       	std	Z+19, r24	; 0x13

  // [6. Change tool ]: NOT SUPPORTED

  // [7. Spindle control ]:
  if (gc_state.modal.spindle != gc_block.modal.spindle) {
    1ffa:	1a 96       	adiw	r26, 0x0a	; 10
    1ffc:	8c 91       	ld	r24, X
    1ffe:	91 85       	ldd	r25, Z+9	; 0x09
    2000:	98 17       	cp	r25, r24
    2002:	49 f0       	breq	.+18     	; 0x2016 <gc_execute_line+0x1148>
    // Update spindle control and apply spindle speed when enabling it in this block.
    // NOTE: All spindle state changes are synced, even in laser mode. Also, pl_data,
    // rather than gc_state, is used to manage laser state for non-laser motions.
    spindle_sync(gc_block.modal.spindle, pl_data->spindle_speed);
    2004:	4e 89       	ldd	r20, Y+22	; 0x16
    2006:	5f 89       	ldd	r21, Y+23	; 0x17
    2008:	68 8d       	ldd	r22, Y+24	; 0x18
    200a:	79 8d       	ldd	r23, Y+25	; 0x19
    200c:	71 d3       	rcall	.+1762   	; 0x26f0 <spindle_sync>
    gc_state.modal.spindle = gc_block.modal.spindle;
    200e:	80 91 a0 0c 	lds	r24, 0x0CA0	; 0x800ca0 <gc_block+0xa>
    2012:	80 93 5f 0c 	sts	0x0C5F, r24	; 0x800c5f <gc_state+0x9>
  }
  pl_data->condition |= gc_state.modal.spindle; // Set condition flag for planner use.
    2016:	e6 e5       	ldi	r30, 0x56	; 86
    2018:	fc e0       	ldi	r31, 0x0C	; 12
    201a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    201c:	81 85       	ldd	r24, Z+9	; 0x09
    201e:	89 2b       	or	r24, r25
    2020:	8e 8f       	std	Y+30, r24	; 0x1e

  // [8. Coolant control ]:
  if (gc_state.modal.coolant != gc_block.modal.coolant) {
    2022:	80 91 9f 0c 	lds	r24, 0x0C9F	; 0x800c9f <gc_block+0x9>
    2026:	90 85       	ldd	r25, Z+8	; 0x08
    2028:	98 17       	cp	r25, r24
    // NOTE: Coolant M-codes are modal. Only one command per line is allowed. But, multiple states
    // can exist at the same time, while coolant disable clears all states.
    coolant_sync(gc_block.modal.coolant);
    202a:	29 f0       	breq	.+10     	; 0x2036 <gc_execute_line+0x1168>
    202c:	b8 d3       	rcall	.+1904   	; 0x279e <coolant_sync>
    gc_state.modal.coolant = gc_block.modal.coolant;
    202e:	80 91 9f 0c 	lds	r24, 0x0C9F	; 0x800c9f <gc_block+0x9>
    2032:	80 93 5e 0c 	sts	0x0C5E, r24	; 0x800c5e <gc_state+0x8>
  }
  pl_data->condition |= gc_state.modal.coolant; // Set condition flag for planner use.
    2036:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2038:	80 91 5e 0c 	lds	r24, 0x0C5E	; 0x800c5e <gc_state+0x8>
    203c:	89 2b       	or	r24, r25
    203e:	8e 8f       	std	Y+30, r24	; 0x1e
      mc_override_ctrl_update(gc_state.modal.override);
    }
  #endif

  // [10. Dwell ]:
  if (gc_block.non_modal_command == NON_MODAL_DWELL) { mc_dwell(gc_block.values.p); }
    2040:	80 91 96 0c 	lds	r24, 0x0C96	; 0x800c96 <gc_block>
    2044:	84 30       	cpi	r24, 0x04	; 4
    2046:	51 f4       	brne	.+20     	; 0x205c <gc_execute_line+0x118e>
    2048:	60 91 b7 0c 	lds	r22, 0x0CB7	; 0x800cb7 <gc_block+0x21>
    204c:	70 91 b8 0c 	lds	r23, 0x0CB8	; 0x800cb8 <gc_block+0x22>
    2050:	80 91 b9 0c 	lds	r24, 0x0CB9	; 0x800cb9 <gc_block+0x23>
    2054:	90 91 ba 0c 	lds	r25, 0x0CBA	; 0x800cba <gc_block+0x24>
    2058:	0e 94 82 06 	call	0xd04	; 0xd04 <mc_dwell>

  // [11. Set active plane ]:
  gc_state.modal.plane_select = gc_block.modal.plane_select;
    205c:	e6 e5       	ldi	r30, 0x56	; 86
    205e:	fc e0       	ldi	r31, 0x0C	; 12
    2060:	a6 e9       	ldi	r26, 0x96	; 150
    2062:	bc e0       	ldi	r27, 0x0C	; 12
    2064:	15 96       	adiw	r26, 0x05	; 5
    2066:	8c 91       	ld	r24, X
    2068:	15 97       	sbiw	r26, 0x05	; 5
    206a:	84 83       	std	Z+4, r24	; 0x04

  // [12. Set length units ]:
  gc_state.modal.units = gc_block.modal.units;
    206c:	13 96       	adiw	r26, 0x03	; 3
    206e:	8c 91       	ld	r24, X
    2070:	82 83       	std	Z+2, r24	; 0x02

  // [14. Cutter length compensation ]: G43.1 and G49 supported. G43 NOT SUPPORTED.
  // NOTE: If G43 were supported, its operation wouldn't be any different from G43.1 in terms
  // of execution. The error-checking step would simply load the offset value into the correct
  // axis of the block XYZ value array.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates a change.
    2072:	ee a1       	ldd	r30, Y+38	; 0x26
    2074:	e3 30       	cpi	r30, 0x03	; 3
    2076:	71 f5       	brne	.+92     	; 0x20d4 <gc_execute_line+0x1206>
    gc_state.modal.tool_length = gc_block.modal.tool_length;
    2078:	80 91 9c 0c 	lds	r24, 0x0C9C	; 0x800c9c <gc_block+0x6>
    207c:	80 93 5b 0c 	sts	0x0C5B, r24	; 0x800c5b <gc_state+0x5>
    if (gc_state.modal.tool_length == TOOL_LENGTH_OFFSET_CANCEL) { // G49
    2080:	81 11       	cpse	r24, r1
    2082:	08 c0       	rjmp	.+16     	; 0x2094 <gc_execute_line+0x11c6>
      gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] = 0.0;
    2084:	10 92 cc 0c 	sts	0x0CCC, r1	; 0x800ccc <gc_block+0x36>
    2088:	10 92 cd 0c 	sts	0x0CCD, r1	; 0x800ccd <gc_block+0x37>
    208c:	10 92 ce 0c 	sts	0x0CCE, r1	; 0x800cce <gc_block+0x38>
    2090:	10 92 cf 0c 	sts	0x0CCF, r1	; 0x800ccf <gc_block+0x39>
    } // else G43.1
    if ( gc_state.tool_length_offset != gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] ) {
    2094:	80 90 cc 0c 	lds	r8, 0x0CCC	; 0x800ccc <gc_block+0x36>
    2098:	90 90 cd 0c 	lds	r9, 0x0CCD	; 0x800ccd <gc_block+0x37>
    209c:	a0 90 ce 0c 	lds	r10, 0x0CCE	; 0x800cce <gc_block+0x38>
    20a0:	b0 90 cf 0c 	lds	r11, 0x0CCF	; 0x800ccf <gc_block+0x39>
    20a4:	a5 01       	movw	r20, r10
    20a6:	94 01       	movw	r18, r8
    20a8:	60 91 92 0c 	lds	r22, 0x0C92	; 0x800c92 <gc_state+0x3c>
    20ac:	70 91 93 0c 	lds	r23, 0x0C93	; 0x800c93 <gc_state+0x3d>
    20b0:	80 91 94 0c 	lds	r24, 0x0C94	; 0x800c94 <gc_state+0x3e>
    20b4:	90 91 95 0c 	lds	r25, 0x0C95	; 0x800c95 <gc_state+0x3f>
    20b8:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    20bc:	88 23       	and	r24, r24
    20be:	51 f0       	breq	.+20     	; 0x20d4 <gc_execute_line+0x1206>
      gc_state.tool_length_offset = gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS];
    20c0:	80 92 92 0c 	sts	0x0C92, r8	; 0x800c92 <gc_state+0x3c>
    20c4:	90 92 93 0c 	sts	0x0C93, r9	; 0x800c93 <gc_state+0x3d>
    20c8:	a0 92 94 0c 	sts	0x0C94, r10	; 0x800c94 <gc_state+0x3e>
    20cc:	b0 92 95 0c 	sts	0x0C95, r11	; 0x800c95 <gc_state+0x3f>
      system_flag_wco_change();
    20d0:	0e 94 f7 3a 	call	0x75ee	; 0x75ee <system_flag_wco_change>
    }
  }

  // [15. Coordinate system selection ]:
  if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    20d4:	80 91 9d 0c 	lds	r24, 0x0C9D	; 0x800c9d <gc_block+0x7>
    20d8:	90 91 5c 0c 	lds	r25, 0x0C5C	; 0x800c5c <gc_state+0x6>
    20dc:	98 17       	cp	r25, r24
    20de:	69 f0       	breq	.+26     	; 0x20fa <gc_execute_line+0x122c>
    gc_state.modal.coord_select = gc_block.modal.coord_select;
    20e0:	80 93 5c 0c 	sts	0x0C5C, r24	; 0x800c5c <gc_state+0x6>
    memcpy(gc_state.coord_system,block_coord_system,N_AXIS*sizeof(float));
    20e4:	8c e0       	ldi	r24, 0x0C	; 12
    20e6:	fe 01       	movw	r30, r28
    20e8:	36 96       	adiw	r30, 0x06	; 6
    20ea:	aa e7       	ldi	r26, 0x7A	; 122
    20ec:	bc e0       	ldi	r27, 0x0C	; 12
    20ee:	01 90       	ld	r0, Z+
    20f0:	0d 92       	st	X+, r0
    20f2:	8a 95       	dec	r24
    20f4:	e1 f7       	brne	.-8      	; 0x20ee <gc_execute_line+0x1220>
    system_flag_wco_change();
    20f6:	0e 94 f7 3a 	call	0x75ee	; 0x75ee <system_flag_wco_change>

  // [16. Set path control mode ]: G61.1/G64 NOT SUPPORTED
  // gc_state.modal.control = gc_block.modal.control; // NOTE: Always default.

  // [17. Set distance mode ]:
  gc_state.modal.distance = gc_block.modal.distance;
    20fa:	e6 e9       	ldi	r30, 0x96	; 150
    20fc:	fc e0       	ldi	r31, 0x0C	; 12
    20fe:	84 81       	ldd	r24, Z+4	; 0x04
    2100:	80 93 59 0c 	sts	0x0C59, r24	; 0x800c59 <gc_state+0x3>

  // [18. Set retract mode ]: NOT SUPPORTED

  // [19. Go to predefined position, Set G10, or Set axis offsets ]:
  switch(gc_block.non_modal_command) {
    2104:	80 81       	ld	r24, Z
    2106:	86 32       	cpi	r24, 0x26	; 38
    2108:	09 f4       	brne	.+2      	; 0x210c <gc_execute_line+0x123e>
    210a:	46 c0       	rjmp	.+140    	; 0x2198 <gc_execute_line+0x12ca>
    210c:	38 f4       	brcc	.+14     	; 0x211c <gc_execute_line+0x124e>
    210e:	8c 31       	cpi	r24, 0x1C	; 28
    2110:	29 f1       	breq	.+74     	; 0x215c <gc_execute_line+0x128e>
    2112:	8e 31       	cpi	r24, 0x1E	; 30
    2114:	19 f1       	breq	.+70     	; 0x215c <gc_execute_line+0x128e>
    2116:	8a 30       	cpi	r24, 0x0A	; 10
    2118:	59 f0       	breq	.+22     	; 0x2130 <gc_execute_line+0x1262>
    211a:	5f c0       	rjmp	.+190    	; 0x21da <gc_execute_line+0x130c>
    211c:	8c 35       	cpi	r24, 0x5C	; 92
    211e:	09 f4       	brne	.+2      	; 0x2122 <gc_execute_line+0x1254>
    2120:	47 c0       	rjmp	.+142    	; 0x21b0 <gc_execute_line+0x12e2>
    2122:	86 36       	cpi	r24, 0x66	; 102
    2124:	09 f4       	brne	.+2      	; 0x2128 <gc_execute_line+0x125a>
    2126:	50 c0       	rjmp	.+160    	; 0x21c8 <gc_execute_line+0x12fa>
    2128:	88 32       	cpi	r24, 0x28	; 40
    212a:	09 f0       	breq	.+2      	; 0x212e <gc_execute_line+0x1260>
    212c:	56 c0       	rjmp	.+172    	; 0x21da <gc_execute_line+0x130c>
    212e:	3a c0       	rjmp	.+116    	; 0x21a4 <gc_execute_line+0x12d6>
    case NON_MODAL_SET_COORDINATE_DATA:
      settings_write_coord_data(coord_select,gc_block.values.ijk);
    2130:	66 ea       	ldi	r22, 0xA6	; 166
    2132:	7c e0       	ldi	r23, 0x0C	; 12
    2134:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2136:	0e 94 4d 25 	call	0x4a9a	; 0x4a9a <settings_write_coord_data>
      // Update system coordinate system if currently active.
      if (gc_state.modal.coord_select == coord_select) {
    213a:	80 91 5c 0c 	lds	r24, 0x0C5C	; 0x800c5c <gc_state+0x6>
    213e:	ff 8d       	ldd	r31, Y+31	; 0x1f
    2140:	8f 13       	cpse	r24, r31
    2142:	4b c0       	rjmp	.+150    	; 0x21da <gc_execute_line+0x130c>
        memcpy(gc_state.coord_system,gc_block.values.ijk,N_AXIS*sizeof(float));
    2144:	8c e0       	ldi	r24, 0x0C	; 12
    2146:	e6 ea       	ldi	r30, 0xA6	; 166
    2148:	fc e0       	ldi	r31, 0x0C	; 12
    214a:	aa e7       	ldi	r26, 0x7A	; 122
    214c:	bc e0       	ldi	r27, 0x0C	; 12
    214e:	01 90       	ld	r0, Z+
    2150:	0d 92       	st	X+, r0
    2152:	8a 95       	dec	r24
    2154:	e1 f7       	brne	.-8      	; 0x214e <gc_execute_line+0x1280>
        system_flag_wco_change();
    2156:	0e 94 f7 3a 	call	0x75ee	; 0x75ee <system_flag_wco_change>
    215a:	3f c0       	rjmp	.+126    	; 0x21da <gc_execute_line+0x130c>
      }
      break;
    case NON_MODAL_GO_HOME_0: case NON_MODAL_GO_HOME_1:
      // Move to intermediate position before going home. Obeys current coordinate system and offsets
      // and absolute and incremental modes.
      pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
    215c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    215e:	81 60       	ori	r24, 0x01	; 1
    2160:	8e 8f       	std	Y+30, r24	; 0x1e
      if (axis_command) { mc_line(gc_block.values.xyz, pl_data); }
    2162:	2e a1       	ldd	r18, Y+38	; 0x26
    2164:	22 23       	and	r18, r18
    2166:	39 f0       	breq	.+14     	; 0x2176 <gc_execute_line+0x12a8>
    2168:	be 01       	movw	r22, r28
    216a:	6e 5e       	subi	r22, 0xEE	; 238
    216c:	7f 4f       	sbci	r23, 0xFF	; 255
    216e:	84 ec       	ldi	r24, 0xC4	; 196
    2170:	9c e0       	ldi	r25, 0x0C	; 12
    2172:	0e 94 62 03 	call	0x6c4	; 0x6c4 <mc_line>
      mc_line(gc_block.values.ijk, pl_data);
    2176:	be 01       	movw	r22, r28
    2178:	6e 5e       	subi	r22, 0xEE	; 238
    217a:	7f 4f       	sbci	r23, 0xFF	; 255
    217c:	86 ea       	ldi	r24, 0xA6	; 166
    217e:	9c e0       	ldi	r25, 0x0C	; 12
    2180:	0e 94 62 03 	call	0x6c4	; 0x6c4 <mc_line>
      memcpy(gc_state.position, gc_block.values.ijk, N_AXIS*sizeof(float));
    2184:	8c e0       	ldi	r24, 0x0C	; 12
    2186:	e6 ea       	ldi	r30, 0xA6	; 166
    2188:	fc e0       	ldi	r31, 0x0C	; 12
    218a:	ae e6       	ldi	r26, 0x6E	; 110
    218c:	bc e0       	ldi	r27, 0x0C	; 12
    218e:	01 90       	ld	r0, Z+
    2190:	0d 92       	st	X+, r0
    2192:	8a 95       	dec	r24
    2194:	e1 f7       	brne	.-8      	; 0x218e <gc_execute_line+0x12c0>
      break;
    2196:	21 c0       	rjmp	.+66     	; 0x21da <gc_execute_line+0x130c>
    case NON_MODAL_SET_HOME_0:
      settings_write_coord_data(SETTING_INDEX_G28,gc_state.position);
    2198:	6e e6       	ldi	r22, 0x6E	; 110
    219a:	7c e0       	ldi	r23, 0x0C	; 12
    219c:	86 e0       	ldi	r24, 0x06	; 6
    219e:	0e 94 4d 25 	call	0x4a9a	; 0x4a9a <settings_write_coord_data>
      break;
    21a2:	1b c0       	rjmp	.+54     	; 0x21da <gc_execute_line+0x130c>
    case NON_MODAL_SET_HOME_1:
      settings_write_coord_data(SETTING_INDEX_G30,gc_state.position);
    21a4:	6e e6       	ldi	r22, 0x6E	; 110
    21a6:	7c e0       	ldi	r23, 0x0C	; 12
    21a8:	87 e0       	ldi	r24, 0x07	; 7
    21aa:	0e 94 4d 25 	call	0x4a9a	; 0x4a9a <settings_write_coord_data>
      break;
    21ae:	15 c0       	rjmp	.+42     	; 0x21da <gc_execute_line+0x130c>
    case NON_MODAL_SET_COORDINATE_OFFSET:
      memcpy(gc_state.coord_offset,gc_block.values.xyz,sizeof(gc_block.values.xyz));
    21b0:	8c e0       	ldi	r24, 0x0C	; 12
    21b2:	e4 ec       	ldi	r30, 0xC4	; 196
    21b4:	fc e0       	ldi	r31, 0x0C	; 12
    21b6:	a6 e8       	ldi	r26, 0x86	; 134
    21b8:	bc e0       	ldi	r27, 0x0C	; 12
    21ba:	01 90       	ld	r0, Z+
    21bc:	0d 92       	st	X+, r0
    21be:	8a 95       	dec	r24
    21c0:	e1 f7       	brne	.-8      	; 0x21ba <gc_execute_line+0x12ec>
      system_flag_wco_change();
    21c2:	0e 94 f7 3a 	call	0x75ee	; 0x75ee <system_flag_wco_change>
      break;
    21c6:	09 c0       	rjmp	.+18     	; 0x21da <gc_execute_line+0x130c>
    case NON_MODAL_RESET_COORDINATE_OFFSET:
      clear_vector(gc_state.coord_offset); // Disable G92 offsets by zeroing offset vector.
    21c8:	8c e0       	ldi	r24, 0x0C	; 12
    21ca:	e6 e8       	ldi	r30, 0x86	; 134
    21cc:	fc e0       	ldi	r31, 0x0C	; 12
    21ce:	df 01       	movw	r26, r30
    21d0:	1d 92       	st	X+, r1
    21d2:	8a 95       	dec	r24
    21d4:	e9 f7       	brne	.-6      	; 0x21d0 <gc_execute_line+0x1302>
      system_flag_wco_change();
    21d6:	0e 94 f7 3a 	call	0x75ee	; 0x75ee <system_flag_wco_change>


  // [20. Motion modes ]:
  // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes.
  // Enter motion modes only if there are axis words or a motion mode command word in the block.
  gc_state.modal.motion = gc_block.modal.motion;
    21da:	80 91 97 0c 	lds	r24, 0x0C97	; 0x800c97 <gc_block+0x1>
    21de:	80 93 56 0c 	sts	0x0C56, r24	; 0x800c56 <gc_state>
  if (gc_state.modal.motion != MOTION_MODE_NONE) {
    21e2:	80 35       	cpi	r24, 0x50	; 80
    21e4:	09 f4       	brne	.+2      	; 0x21e8 <gc_execute_line+0x131a>
    21e6:	56 c0       	rjmp	.+172    	; 0x2294 <__stack+0x95>
    if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    21e8:	be a1       	ldd	r27, Y+38	; 0x26
    21ea:	b2 30       	cpi	r27, 0x02	; 2
    21ec:	09 f0       	breq	.+2      	; 0x21f0 <gc_execute_line+0x1322>
    21ee:	52 c0       	rjmp	.+164    	; 0x2294 <__stack+0x95>
      uint8_t gc_update_pos = GC_UPDATE_POS_TARGET;
      if (gc_state.modal.motion == MOTION_MODE_LINEAR) {
    21f0:	81 30       	cpi	r24, 0x01	; 1
    21f2:	41 f4       	brne	.+16     	; 0x2204 <__stack+0x5>
        mc_line(gc_block.values.xyz, pl_data);
    21f4:	be 01       	movw	r22, r28
    21f6:	6e 5e       	subi	r22, 0xEE	; 238
    21f8:	7f 4f       	sbci	r23, 0xFF	; 255
    21fa:	84 ec       	ldi	r24, 0xC4	; 196
    21fc:	9c e0       	ldi	r25, 0x0C	; 12
    21fe:	0e 94 62 03 	call	0x6c4	; 0x6c4 <mc_line>
    2202:	3a c0       	rjmp	.+116    	; 0x2278 <__stack+0x79>
      } else if (gc_state.modal.motion == MOTION_MODE_SEEK) {
    2204:	81 11       	cpse	r24, r1
    2206:	0b c0       	rjmp	.+22     	; 0x221e <__stack+0x1f>
        pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
    2208:	8e 8d       	ldd	r24, Y+30	; 0x1e
    220a:	81 60       	ori	r24, 0x01	; 1
    220c:	8e 8f       	std	Y+30, r24	; 0x1e
        mc_line(gc_block.values.xyz, pl_data);
    220e:	be 01       	movw	r22, r28
    2210:	6e 5e       	subi	r22, 0xEE	; 238
    2212:	7f 4f       	sbci	r23, 0xFF	; 255
    2214:	84 ec       	ldi	r24, 0xC4	; 196
    2216:	9c e0       	ldi	r25, 0x0C	; 12
    2218:	0e 94 62 03 	call	0x6c4	; 0x6c4 <mc_line>
    221c:	2d c0       	rjmp	.+90     	; 0x2278 <__stack+0x79>
      } else if ((gc_state.modal.motion == MOTION_MODE_CW_ARC) || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
    221e:	82 50       	subi	r24, 0x02	; 2
    2220:	82 30       	cpi	r24, 0x02	; 2
    2222:	e8 f4       	brcc	.+58     	; 0x225e <__stack+0x5f>
        mc_arc(gc_block.values.xyz, pl_data, gc_state.position, gc_block.values.ijk, gc_block.values.r,
    2224:	e0 90 bb 0c 	lds	r14, 0x0CBB	; 0x800cbb <gc_block+0x25>
    2228:	f0 90 bc 0c 	lds	r15, 0x0CBC	; 0x800cbc <gc_block+0x26>
    222c:	00 91 bd 0c 	lds	r16, 0x0CBD	; 0x800cbd <gc_block+0x27>
    2230:	10 91 be 0c 	lds	r17, 0x0CBE	; 0x800cbe <gc_block+0x28>
    2234:	e8 a5       	ldd	r30, Y+40	; 0x28
    2236:	e2 fb       	bst	r30, 2
    2238:	88 27       	eor	r24, r24
    223a:	80 f9       	bld	r24, 0
    223c:	8f 93       	push	r24
    223e:	8a a8       	ldd	r8, Y+50	; 0x32
    2240:	a9 a4       	ldd	r10, Y+41	; 0x29
    2242:	c9 a0       	ldd	r12, Y+33	; 0x21
    2244:	26 ea       	ldi	r18, 0xA6	; 166
    2246:	3c e0       	ldi	r19, 0x0C	; 12
    2248:	4e e6       	ldi	r20, 0x6E	; 110
    224a:	5c e0       	ldi	r21, 0x0C	; 12
    224c:	be 01       	movw	r22, r28
    224e:	6e 5e       	subi	r22, 0xEE	; 238
    2250:	7f 4f       	sbci	r23, 0xFF	; 255
    2252:	84 ec       	ldi	r24, 0xC4	; 196
    2254:	9c e0       	ldi	r25, 0x0C	; 12
    2256:	0e 94 a3 03 	call	0x746	; 0x746 <mc_arc>
    225a:	0f 90       	pop	r0
    225c:	0d c0       	rjmp	.+26     	; 0x2278 <__stack+0x79>
            axis_0, axis_1, axis_linear, bit_istrue(gc_parser_flags,GC_PARSER_ARC_IS_CLOCKWISE));
      } else {
        // NOTE: gc_block.values.xyz is returned from mc_probe_cycle with the updated position value. So
        // upon a successful probing cycle, the machine position and the returned value should be the same.
        #ifndef ALLOW_FEED_OVERRIDE_DURING_PROBE_CYCLES
          pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
    225e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2260:	84 60       	ori	r24, 0x04	; 4
    2262:	8e 8f       	std	Y+30, r24	; 0x1e
        #endif
        gc_update_pos = mc_probe_cycle(gc_block.values.xyz, pl_data, gc_parser_flags);
    2264:	48 a5       	ldd	r20, Y+40	; 0x28
    2266:	be 01       	movw	r22, r28
    2268:	6e 5e       	subi	r22, 0xEE	; 238
    226a:	7f 4f       	sbci	r23, 0xFF	; 255
    226c:	84 ec       	ldi	r24, 0xC4	; 196
    226e:	9c e0       	ldi	r25, 0x0C	; 12
    2270:	0e 94 b5 06 	call	0xd6a	; 0xd6a <mc_probe_cycle>
      }  
     
      // As far as the parser is concerned, the position is now == target. In reality the
      // motion control system might still be processing the action and the real tool position
      // in any intermediate location.
      if (gc_update_pos == GC_UPDATE_POS_TARGET) {
    2274:	81 11       	cpse	r24, r1
    2276:	0a c0       	rjmp	.+20     	; 0x228c <__stack+0x8d>
        memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); // gc_state.position[] = gc_block.values.xyz[]
    2278:	8c e0       	ldi	r24, 0x0C	; 12
    227a:	e4 ec       	ldi	r30, 0xC4	; 196
    227c:	fc e0       	ldi	r31, 0x0C	; 12
    227e:	ae e6       	ldi	r26, 0x6E	; 110
    2280:	bc e0       	ldi	r27, 0x0C	; 12
    2282:	01 90       	ld	r0, Z+
    2284:	0d 92       	st	X+, r0
    2286:	8a 95       	dec	r24
    2288:	e1 f7       	brne	.-8      	; 0x2282 <__stack+0x83>
    228a:	04 c0       	rjmp	.+8      	; 0x2294 <__stack+0x95>
      } else if (gc_update_pos == GC_UPDATE_POS_SYSTEM) {
    228c:	81 30       	cpi	r24, 0x01	; 1
    228e:	11 f4       	brne	.+4      	; 0x2294 <__stack+0x95>
        gc_sync_position(); // gc_state.position[] = sys_position
    2290:	0e 94 60 07 	call	0xec0	; 0xec0 <gc_sync_position>
  }

  // [21. Program flow ]:
  // M0,M1,M2,M30: Perform non-running program flow actions. During a program pause, the buffer may
  // refill and can only be resumed by the cycle start run-time command.
  gc_state.modal.program_flow = gc_block.modal.program_flow;
    2294:	80 91 9e 0c 	lds	r24, 0x0C9E	; 0x800c9e <gc_block+0x8>
    2298:	80 93 5d 0c 	sts	0x0C5D, r24	; 0x800c5d <gc_state+0x7>
  if (gc_state.modal.program_flow) {
    229c:	88 23       	and	r24, r24
    229e:	09 f4       	brne	.+2      	; 0x22a2 <__stack+0xa3>
    protocol_buffer_synchronize(); // Sync and finish all remaining buffered motions before moving on.
    22a0:	db c0       	rjmp	.+438    	; 0x2458 <__stack+0x259>
    22a2:	b0 d7       	rcall	.+3936   	; 0x3204 <protocol_buffer_synchronize>
    if (gc_state.modal.program_flow == PROGRAM_FLOW_PAUSED) {
    22a4:	80 91 5d 0c 	lds	r24, 0x0C5D	; 0x800c5d <gc_state+0x7>
    22a8:	83 30       	cpi	r24, 0x03	; 3
    22aa:	49 f4       	brne	.+18     	; 0x22be <__stack+0xbf>
      if (sys.state != STATE_CHECK_MODE) {
    22ac:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    22b0:	82 30       	cpi	r24, 0x02	; 2
        system_set_exec_state_flag(EXEC_FEED_HOLD); // Use feed hold for program pause.
    22b2:	61 f1       	breq	.+88     	; 0x230c <__stack+0x10d>
    22b4:	88 e0       	ldi	r24, 0x08	; 8
    22b6:	0e 94 95 3b 	call	0x772a	; 0x772a <system_set_exec_state_flag>
        protocol_execute_realtime(); // Execute suspend.
    22ba:	dc d5       	rcall	.+3000   	; 0x2e74 <protocol_execute_realtime>
    22bc:	27 c0       	rjmp	.+78     	; 0x230c <__stack+0x10d>
    } else { // == PROGRAM_FLOW_COMPLETED
      // Upon program complete, only a subset of g-codes reset to certain defaults, according to
      // LinuxCNC's program end descriptions and testing. Only modal groups [G-code 1,2,3,5,7,12]
      // and [M-code 7,8,9] reset to [G1,G17,G90,G94,G40,G54,M5,M9,M48]. The remaining modal groups
      // [G-code 4,6,8,10,13,14,15] and [M-code 4,5,6] and the modal words [F,S,T,H] do not reset.
      gc_state.modal.motion = MOTION_MODE_LINEAR;
    22be:	e6 e5       	ldi	r30, 0x56	; 86
    22c0:	fc e0       	ldi	r31, 0x0C	; 12
    22c2:	81 e0       	ldi	r24, 0x01	; 1
    22c4:	80 83       	st	Z, r24
      gc_state.modal.plane_select = PLANE_SELECT_XY;
    22c6:	14 82       	std	Z+4, r1	; 0x04
      gc_state.modal.distance = DISTANCE_MODE_ABSOLUTE;
    22c8:	13 82       	std	Z+3, r1	; 0x03
      gc_state.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
    22ca:	11 82       	std	Z+1, r1	; 0x01
      // gc_state.modal.cutter_comp = CUTTER_COMP_DISABLE; // Not supported.
      gc_state.modal.coord_select = 0; // G54
    22cc:	16 82       	std	Z+6, r1	; 0x06
      gc_state.modal.spindle = SPINDLE_DISABLE;
    22ce:	11 86       	std	Z+9, r1	; 0x09
      gc_state.modal.coolant = COOLANT_DISABLE;
    22d0:	10 86       	std	Z+8, r1	; 0x08
          gc_state.modal.override = OVERRIDE_PARKING_MOTION;
        #endif
      #endif

      #ifdef RESTORE_OVERRIDES_AFTER_PROGRAM_END
        sys.f_override = DEFAULT_FEED_OVERRIDE;
    22d2:	ee e1       	ldi	r30, 0x1E	; 30
    22d4:	fc e0       	ldi	r31, 0x0C	; 12
    22d6:	84 e6       	ldi	r24, 0x64	; 100
    22d8:	87 83       	std	Z+7, r24	; 0x07
        sys.r_override = DEFAULT_RAPID_OVERRIDE;
    22da:	80 87       	std	Z+8, r24	; 0x08
        sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE;
    22dc:	81 87       	std	Z+9, r24	; 0x09
      #endif

      // Execute coordinate change and spindle/coolant stop.
      if (sys.state != STATE_CHECK_MODE) {
    22de:	80 81       	ld	r24, Z
    22e0:	82 30       	cpi	r24, 0x02	; 2
    22e2:	89 f0       	breq	.+34     	; 0x2306 <__stack+0x107>
        if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    22e4:	6a e7       	ldi	r22, 0x7A	; 122
    22e6:	7c e0       	ldi	r23, 0x0C	; 12
    22e8:	80 e0       	ldi	r24, 0x00	; 0
    22ea:	0e 94 f0 25 	call	0x4be0	; 0x4be0 <settings_read_coord_data>
    22ee:	88 23       	and	r24, r24
    22f0:	09 f4       	brne	.+2      	; 0x22f4 <__stack+0xf5>
        system_flag_wco_change(); // Set to refresh immediately just in case something altered.
    22f2:	7a c0       	rjmp	.+244    	; 0x23e8 <__stack+0x1e9>
        spindle_set_state(SPINDLE_DISABLE,0.0);
    22f4:	0e 94 f7 3a 	call	0x75ee	; 0x75ee <system_flag_wco_change>
    22f8:	40 e0       	ldi	r20, 0x00	; 0
    22fa:	50 e0       	ldi	r21, 0x00	; 0
    22fc:	ba 01       	movw	r22, r20
    22fe:	80 e0       	ldi	r24, 0x00	; 0
        coolant_set_state(COOLANT_DISABLE);
    2300:	cd d1       	rcall	.+922    	; 0x269c <spindle_set_state>
    2302:	80 e0       	ldi	r24, 0x00	; 0
    2304:	2b d2       	rcall	.+1110   	; 0x275c <coolant_set_state>
      }
      report_feedback_message(MESSAGE_PROGRAM_END);
    2306:	88 e0       	ldi	r24, 0x08	; 8
    2308:	0e 94 ab 35 	call	0x6b56	; 0x6b56 <report_feedback_message>
    }
    gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; // Reset program flow.
    230c:	10 92 5d 0c 	sts	0x0C5D, r1	; 0x800c5d <gc_state+0x7>
  }

  // TODO: % to denote start of program.

  return(STATUS_OK);
    2310:	8d 2d       	mov	r24, r13
    2312:	a2 c0       	rjmp	.+324    	; 0x2458 <__stack+0x259>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.

    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
    2314:	81 e0       	ldi	r24, 0x01	; 1
    2316:	a0 c0       	rjmp	.+320    	; 0x2458 <__stack+0x259>
    char_counter++;
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
    2318:	82 e0       	ldi	r24, 0x02	; 2
    231a:	9e c0       	rjmp	.+316    	; 0x2458 <__stack+0x259>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
    231c:	84 e1       	ldi	r24, 0x14	; 20
    231e:	9c c0       	rjmp	.+312    	; 0x2458 <__stack+0x259>
        switch(int_value) {
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    2320:	88 e1       	ldi	r24, 0x18	; 24
    2322:	9a c0       	rjmp	.+308    	; 0x2458 <__stack+0x259>
            //if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
              //if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
              //gc_block.non_modal_command += mantissa;
              //mantissa = 0; // Set to zero to indicate valid non-integer G command.
            //}                
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G4.X G53.X not supported]
    2324:	84 e1       	ldi	r24, 0x14	; 20
    2326:	98 c0       	rjmp	.+304    	; 0x2458 <__stack+0x259>
            break;
          case 0: case 1: case 2: case 3: case 38:
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    2328:	88 e1       	ldi	r24, 0x18	; 24
    232a:	96 c0       	rjmp	.+300    	; 0x2458 <__stack+0x259>
          case 80:
            word_bit = MODAL_GROUP_G1;
            gc_block.modal.motion = int_value;
            if (int_value == 38){
              if (!((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))) {
                FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
    232c:	84 e1       	ldi	r24, 0x14	; 20
    232e:	94 c0       	rjmp	.+296    	; 0x2458 <__stack+0x259>
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
    2330:	84 e1       	ldi	r24, 0x14	; 20
    2332:	92 c0       	rjmp	.+292    	; 0x2458 <__stack+0x259>
    2334:	84 e1       	ldi	r24, 0x14	; 20
    2336:	90 c0       	rjmp	.+288    	; 0x2458 <__stack+0x259>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
    2338:	88 e1       	ldi	r24, 0x18	; 24
    233a:	8e c0       	rjmp	.+284    	; 0x2458 <__stack+0x259>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
            } else if (mantissa == 10) { // G43.1
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
    233c:	84 e1       	ldi	r24, 0x14	; 20
    233e:	8c c0       	rjmp	.+280    	; 0x2458 <__stack+0x259>
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
    2340:	84 e1       	ldi	r24, 0x14	; 20
    2342:	8a c0       	rjmp	.+276    	; 0x2458 <__stack+0x259>
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    2344:	87 e1       	ldi	r24, 0x17	; 23
    2346:	88 c0       	rjmp	.+272    	; 0x2458 <__stack+0x259>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    2348:	85 e1       	ldi	r24, 0x15	; 21
    234a:	86 c0       	rjmp	.+268    	; 0x2458 <__stack+0x259>
        break;

      case 'M':

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    234c:	87 e1       	ldi	r24, 0x17	; 23
    234e:	84 c0       	rjmp	.+264    	; 0x2458 <__stack+0x259>
            case 56:
              word_bit = MODAL_GROUP_M9;
              gc_block.modal.override = OVERRIDE_PARKING_MOTION;
              break;
          #endif
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
    2350:	84 e1       	ldi	r24, 0x14	; 20
    2352:	82 c0       	rjmp	.+260    	; 0x2458 <__stack+0x259>
        }

        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    2354:	85 e1       	ldi	r24, 0x15	; 21
    2356:	80 c0       	rjmp	.+256    	; 0x2458 <__stack+0x259>
						gc_block.values.t = int_value;
						break;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
    2358:	84 e1       	ldi	r24, 0x14	; 20
    235a:	7e c0       	rjmp	.+252    	; 0x2458 <__stack+0x259>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; 
						if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
    235c:	86 e2       	ldi	r24, 0x26	; 38
    235e:	7c c0       	rjmp	.+248    	; 0x2458 <__stack+0x259>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        }

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    2360:	89 e1       	ldi	r24, 0x19	; 25
    2362:	7a c0       	rjmp	.+244    	; 0x2458 <__stack+0x259>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    2364:	84 e0       	ldi	r24, 0x04	; 4
    2366:	78 c0       	rjmp	.+240    	; 0x2458 <__stack+0x259>
  }

  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    2368:	8b e1       	ldi	r24, 0x1B	; 27
    236a:	76 c0       	rjmp	.+236    	; 0x2458 <__stack+0x259>

  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  // NOTE: For jogging, ignore prior feed rate mode. Enforce G94 and check for required F word.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); }
    236c:	86 e1       	ldi	r24, 0x16	; 22
    236e:	74 c0       	rjmp	.+232    	; 0x2458 <__stack+0x259>
  } else {
    if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
      // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
      if (axis_command == AXIS_COMMAND_MOTION_MODE) {
        if ((gc_block.modal.motion != MOTION_MODE_NONE) && (gc_block.modal.motion != MOTION_MODE_SEEK)) {
          if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    2370:	86 e1       	ldi	r24, 0x16	; 22
    2372:	72 c0       	rjmp	.+228    	; 0x2458 <__stack+0x259>
    }
  #endif

  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    2374:	8c e1       	ldi	r24, 0x1C	; 28
    2376:	70 c0       	rjmp	.+224    	; 0x2458 <__stack+0x259>
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    2378:	85 e2       	ldi	r24, 0x25	; 37
    237a:	6e c0       	rjmp	.+220    	; 0x2458 <__stack+0x259>
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  float block_coord_system[N_AXIS];
  memcpy(block_coord_system,gc_state.coord_system,sizeof(gc_state.coord_system));
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    237c:	8d e1       	ldi	r24, 0x1D	; 29
    237e:	6c c0       	rjmp	.+216    	; 0x2458 <__stack+0x259>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
      if (!(settings_read_coord_data(gc_block.modal.coord_select,block_coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    2380:	87 e0       	ldi	r24, 0x07	; 7
    2382:	6a c0       	rjmp	.+212    	; 0x2458 <__stack+0x259>
  switch (gc_block.non_modal_command) {
    case NON_MODAL_SET_COORDINATE_DATA:
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    2384:	8a e1       	ldi	r24, 0x1A	; 26
    2386:	68 c0       	rjmp	.+208    	; 0x2458 <__stack+0x259>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    2388:	8c e1       	ldi	r24, 0x1C	; 28
    238a:	66 c0       	rjmp	.+204    	; 0x2458 <__stack+0x259>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    238c:	8d e1       	ldi	r24, 0x1D	; 29
    238e:	64 c0       	rjmp	.+200    	; 0x2458 <__stack+0x259>
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
    2390:	84 e1       	ldi	r24, 0x14	; 20
    2392:	62 c0       	rjmp	.+196    	; 0x2458 <__stack+0x259>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    2394:	84 e1       	ldi	r24, 0x14	; 20
    2396:	60 c0       	rjmp	.+192    	; 0x2458 <__stack+0x259>
      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    2398:	87 e0       	ldi	r24, 0x07	; 7
    239a:	5e c0       	rjmp	.+188    	; 0x2458 <__stack+0x259>
        } // Else, keep current stored value.
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    239c:	8a e1       	ldi	r24, 0x1A	; 26
    239e:	5c c0       	rjmp	.+184    	; 0x2458 <__stack+0x259>

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    23a0:	8f e1       	ldi	r24, 0x1F	; 31
    23a2:	5a c0       	rjmp	.+180    	; 0x2458 <__stack+0x259>
        case NON_MODAL_GO_HOME_1: // G30
          // [G28/30 Errors]: Cutter compensation is enabled.
          // Retreive G28/30 go-home position data (in machine coordinates) from EEPROM
          // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    23a4:	87 e0       	ldi	r24, 0x07	; 7
    23a6:	58 c0       	rjmp	.+176    	; 0x2458 <__stack+0x259>
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    23a8:	87 e0       	ldi	r24, 0x07	; 7
    23aa:	56 c0       	rjmp	.+172    	; 0x2458 <__stack+0x259>
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
            FAIL(STATUS_GCODE_G53_INVALID_MOTION_MODE); // [G53 G0/1 not active]
    23ac:	8e e1       	ldi	r24, 0x1E	; 30
    23ae:	54 c0       	rjmp	.+168    	; 0x2458 <__stack+0x259>

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    23b0:	8f e1       	ldi	r24, 0x1F	; 31
    23b2:	52 c0       	rjmp	.+164    	; 0x2458 <__stack+0x259>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    23b4:	86 e1       	ldi	r24, 0x16	; 22
    23b6:	50 c0       	rjmp	.+160    	; 0x2458 <__stack+0x259>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.

          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    23b8:	8a e1       	ldi	r24, 0x1A	; 26
    23ba:	4e c0       	rjmp	.+156    	; 0x2458 <__stack+0x259>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    23bc:	80 e2       	ldi	r24, 0x20	; 32
    23be:	4c c0       	rjmp	.+152    	; 0x2458 <__stack+0x259>
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target

          if (value_words & bit(WORD_R)) { // Arc Radius Mode
            bit_false(value_words,bit(WORD_R));
            if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    23c0:	81 e2       	ldi	r24, 0x21	; 33
    23c2:	4a c0       	rjmp	.+148    	; 0x2458 <__stack+0x259>

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    23c4:	82 e2       	ldi	r24, 0x22	; 34
    23c6:	48 c0       	rjmp	.+144    	; 0x2458 <__stack+0x259>
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));

          } else { // Arc Center Format Offset Mode
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    23c8:	83 e2       	ldi	r24, 0x23	; 35
    23ca:	46 c0       	rjmp	.+140    	; 0x2458 <__stack+0x259>
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]);

            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
            if (delta_r > 0.005) {
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    23cc:	81 e2       	ldi	r24, 0x21	; 33
    23ce:	44 c0       	rjmp	.+136    	; 0x2458 <__stack+0x259>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    23d0:	81 e2       	ldi	r24, 0x21	; 33
    23d2:	42 c0       	rjmp	.+132    	; 0x2458 <__stack+0x259>
              (gc_block.modal.motion == MOTION_MODE_PROBE_AWAY_NO_ERROR)) { gc_parser_flags |= GC_PARSER_PROBE_IS_AWAY; }
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    23d4:	8a e1       	ldi	r24, 0x1A	; 26
    23d6:	40 c0       	rjmp	.+128    	; 0x2458 <__stack+0x259>
          if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    23d8:	81 e2       	ldi	r24, 0x21	; 33
    23da:	3e c0       	rjmp	.+124    	; 0x2458 <__stack+0x259>
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)));
  } else {
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words.
  }
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words.
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    23dc:	84 e2       	ldi	r24, 0x24	; 36
    23de:	3c c0       	rjmp	.+120    	; 0x2458 <__stack+0x259>
  // targets are computed correctly. The final parser position after a jog is updated in
  // protocol_execute_realtime() when jogging completes or is canceled.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    // Only distance and unit modal commands and G53 absolute override command are allowed.
    // NOTE: Feed rate word and axis word checks have already been performed in STEP 3.
    if (command_words & ~(bit(MODAL_GROUP_G3) | bit(MODAL_GROUP_G6 | bit(MODAL_GROUP_G0))) ) { FAIL(STATUS_INVALID_JOG_COMMAND) };
    23e0:	80 e1       	ldi	r24, 0x10	; 16
    23e2:	3a c0       	rjmp	.+116    	; 0x2458 <__stack+0x259>
    if (!(gc_block.non_modal_command == NON_MODAL_ABSOLUTE_OVERRIDE || gc_block.non_modal_command == NON_MODAL_NO_ACTION)) { FAIL(STATUS_INVALID_JOG_COMMAND); }
    23e4:	80 e1       	ldi	r24, 0x10	; 16
    23e6:	38 c0       	rjmp	.+112    	; 0x2458 <__stack+0x259>
        sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE;
      #endif

      // Execute coordinate change and spindle/coolant stop.
      if (sys.state != STATE_CHECK_MODE) {
        if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    23e8:	87 e0       	ldi	r24, 0x07	; 7
    23ea:	36 c0       	rjmp	.+108    	; 0x2458 <__stack+0x259>

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    23ec:	8f e1       	ldi	r24, 0x1F	; 31
    23ee:	34 c0       	rjmp	.+104    	; 0x2458 <__stack+0x259>
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
  else { char_counter = 0; }
    23f0:	19 82       	std	Y+1, r1	; 0x01
  uint8_t ijk_words = 0; // IJK tracking

  // Initialize command and value words and parser flags variables.
  uint16_t command_words = 0; // Tracks G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Tracks value words.
  uint8_t gc_parser_flags = GC_PARSER_NONE;
    23f2:	18 a6       	std	Y+40, r1	; 0x28
    23f4:	0c 94 a1 07 	jmp	0xf42	; 0xf42 <gc_execute_line+0x74>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
    23f8:	a0 92 96 0c 	sts	0x0C96, r10	; 0x800c96 <gc_block>
            //if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
              //if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
              //gc_block.non_modal_command += mantissa;
              //mantissa = 0; // Set to zero to indicate valid non-integer G command.
            //}                
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G4.X G53.X not supported]
    23fc:	84 e1       	ldi	r24, 0x14	; 20
    23fe:	2c c0       	rjmp	.+88     	; 0x2458 <__stack+0x259>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
    2400:	a6 e9       	ldi	r26, 0x96	; 150
    2402:	bc e0       	ldi	r27, 0x0C	; 12
    2404:	ac 92       	st	X, r10
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
    2406:	80 e0       	ldi	r24, 0x00	; 0
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
    2408:	b1 e0       	ldi	r27, 0x01	; 1
    240a:	be a3       	std	Y+38, r27	; 0x26
    240c:	0c 94 95 08 	jmp	0x112a	; 0x112a <gc_execute_line+0x25c>
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
    2410:	e1 e0       	ldi	r30, 0x01	; 1
    2412:	ea ab       	std	Y+50, r30	; 0x32
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
    2414:	19 a6       	std	Y+41, r1	; 0x29
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
    2416:	f2 e0       	ldi	r31, 0x02	; 2
    2418:	f9 a3       	std	Y+33, r31	; 0x21
  }

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    241a:	80 91 99 0c 	lds	r24, 0x0C99	; 0x800c99 <gc_block+0x3>
    241e:	81 30       	cpi	r24, 0x01	; 1
    2420:	09 f0       	breq	.+2      	; 0x2424 <__stack+0x225>
    2422:	a5 c8       	rjmp	.-3766   	; 0x156e <gc_execute_line+0x6a0>
    2424:	70 c8       	rjmp	.-3872   	; 0x1506 <gc_execute_line+0x638>
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
          }
          if (axis_words) {
    2426:	2d a1       	ldd	r18, Y+37	; 0x25
    2428:	22 23       	and	r18, r18
    242a:	71 f0       	breq	.+28     	; 0x2448 <__stack+0x249>
    242c:	a6 e5       	ldi	r26, 0x56	; 86
    242e:	bc e0       	ldi	r27, 0x0C	; 12
    2430:	e6 e9       	ldi	r30, 0x96	; 150
    2432:	fc e0       	ldi	r31, 0x0C	; 12
    2434:	80 e0       	ldi	r24, 0x00	; 0
    2436:	90 e0       	ldi	r25, 0x00	; 0
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
    2438:	30 e0       	ldi	r19, 0x00	; 0
    243a:	8a ca       	rjmp	.-2796   	; 0x1950 <gc_execute_line+0xa82>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    243c:	10 91 97 0c 	lds	r17, 0x0C97	; 0x800c97 <gc_block+0x1>
    2440:	10 35       	cpi	r17, 0x50	; 80
    2442:	09 f0       	breq	.+2      	; 0x2446 <__stack+0x247>
    2444:	af ca       	rjmp	.-2722   	; 0x19a4 <gc_execute_line+0xad6>
    2446:	d2 cf       	rjmp	.-92     	; 0x23ec <__stack+0x1ed>
    2448:	10 91 97 0c 	lds	r17, 0x0C97	; 0x800c97 <gc_block+0x1>
    244c:	10 35       	cpi	r17, 0x50	; 80
    244e:	09 f4       	brne	.+2      	; 0x2452 <__stack+0x253>
    2450:	ec cc       	rjmp	.-1576   	; 0x1e2a <gc_execute_line+0xf5c>
    2452:	1f 8e       	std	Y+31, r1	; 0x1f
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
            }
          } else {
            axis_command = AXIS_COMMAND_NONE; // Set to none if no intermediate motion.
    2454:	1e a2       	std	Y+38, r1	; 0x26
    2456:	a6 ca       	rjmp	.-2740   	; 0x19a4 <gc_execute_line+0xad6>
  }

  // TODO: % to denote start of program.

  return(STATUS_OK);
}
    2458:	e4 96       	adiw	r28, 0x34	; 52
    245a:	0f b6       	in	r0, 0x3f	; 63
    245c:	f8 94       	cli
    245e:	de bf       	out	0x3e, r29	; 62
    2460:	0f be       	out	0x3f, r0	; 63
    2462:	cd bf       	out	0x3d, r28	; 61
    2464:	df 91       	pop	r29
    2466:	cf 91       	pop	r28
    2468:	1f 91       	pop	r17
    246a:	0f 91       	pop	r16
    246c:	ff 90       	pop	r15
    246e:	ef 90       	pop	r14
    2470:	df 90       	pop	r13
    2472:	cf 90       	pop	r12
    2474:	bf 90       	pop	r11
    2476:	af 90       	pop	r10
    2478:	9f 90       	pop	r9
    247a:	8f 90       	pop	r8
    247c:	7f 90       	pop	r7
    247e:	6f 90       	pop	r6
    2480:	5f 90       	pop	r5
    2482:	4f 90       	pop	r4
    2484:	3f 90       	pop	r3
    2486:	2f 90       	pop	r2
    2488:	08 95       	ret

0000248a <spindle_get_state>:
uint8_t spindle_get_state()
{
  #ifdef INVERT_SPINDLE_ENABLE_PIN
    if (bit_isfalse(SPINDLE_ENABLE_PORT,(1<<SPINDLE_ENABLE_BIT)) && (SPINDLE_TCCRA_REGISTER & (1<<SPINDLE_COMB_BIT))) {
  #else
    if (bit_istrue(SPINDLE_ENABLE_PORT,(1<<SPINDLE_ENABLE_BIT)) && (SPINDLE_TCCRA_REGISTER & (1<<SPINDLE_COMB_BIT))) {
    248a:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    248e:	89 2f       	mov	r24, r25
    2490:	88 70       	andi	r24, 0x08	; 8
    2492:	93 ff       	sbrs	r25, 3
    2494:	0b c0       	rjmp	.+22     	; 0x24ac <spindle_get_state+0x22>
    2496:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
    249a:	89 2f       	mov	r24, r25
    249c:	80 72       	andi	r24, 0x20	; 32
    249e:	95 ff       	sbrs	r25, 5
    24a0:	05 c0       	rjmp	.+10     	; 0x24ac <spindle_get_state+0x22>
  #endif
    if (SPINDLE_DIRECTION_PORT & (1<<SPINDLE_DIRECTION_BIT)) { return(SPINDLE_STATE_CCW); }
    24a2:	73 99       	sbic	0x0e, 3	; 14
    24a4:	02 c0       	rjmp	.+4      	; 0x24aa <spindle_get_state+0x20>
    else { return(SPINDLE_STATE_CW); }
    24a6:	81 e0       	ldi	r24, 0x01	; 1
    24a8:	08 95       	ret
  #ifdef INVERT_SPINDLE_ENABLE_PIN
    if (bit_isfalse(SPINDLE_ENABLE_PORT,(1<<SPINDLE_ENABLE_BIT)) && (SPINDLE_TCCRA_REGISTER & (1<<SPINDLE_COMB_BIT))) {
  #else
    if (bit_istrue(SPINDLE_ENABLE_PORT,(1<<SPINDLE_ENABLE_BIT)) && (SPINDLE_TCCRA_REGISTER & (1<<SPINDLE_COMB_BIT))) {
  #endif
    if (SPINDLE_DIRECTION_PORT & (1<<SPINDLE_DIRECTION_BIT)) { return(SPINDLE_STATE_CCW); }
    24aa:	82 e0       	ldi	r24, 0x02	; 2
    else { return(SPINDLE_STATE_CW); }
  }
	return(SPINDLE_STATE_DISABLE);
}
    24ac:	08 95       	ret

000024ae <spindle_stop>:
// Disables the spindle and sets PWM output to zero when PWM variable spindle speed is enabled.
// Called by various main program and ISR routines. Keep routine small, fast, and efficient.
// Called by spindle_init(), spindle_set_speed(), spindle_set_state(), and mc_reset().
void spindle_stop()
{
  SPINDLE_TCCRA_REGISTER &= ~(1<<SPINDLE_COMB_BIT); // Disable PWM. Output voltage is zero.
    24ae:	e0 ea       	ldi	r30, 0xA0	; 160
    24b0:	f0 e0       	ldi	r31, 0x00	; 0
    24b2:	80 81       	ld	r24, Z
    24b4:	8f 7d       	andi	r24, 0xDF	; 223
    24b6:	80 83       	st	Z, r24
  #ifdef INVERT_SPINDLE_ENABLE_PIN
    SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);  // Set pin to high
  #else
    SPINDLE_ENABLE_PORT &= ~(1<<SPINDLE_ENABLE_BIT); // Set pin to low
    24b8:	e2 e0       	ldi	r30, 0x02	; 2
    24ba:	f1 e0       	ldi	r31, 0x01	; 1
    24bc:	80 81       	ld	r24, Z
    24be:	87 7f       	andi	r24, 0xF7	; 247
    24c0:	80 83       	st	Z, r24
    24c2:	08 95       	ret

000024c4 <spindle_init>:


void spindle_init()
{    
  // Configure variable spindle PWM and enable pin, if required.
  SPINDLE_PWM_DDR |= (1<<SPINDLE_PWM_BIT); // Configure as PWM output pin.
    24c4:	e1 e0       	ldi	r30, 0x01	; 1
    24c6:	f1 e0       	ldi	r31, 0x01	; 1
    24c8:	80 81       	ld	r24, Z
    24ca:	80 61       	ori	r24, 0x10	; 16
    24cc:	80 83       	st	Z, r24
  SPINDLE_TCCRA_REGISTER = SPINDLE_TCCRA_INIT_MASK; // Configure PWM output compare timer
    24ce:	83 e0       	ldi	r24, 0x03	; 3
    24d0:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
  SPINDLE_TCCRB_REGISTER = SPINDLE_TCCRB_INIT_MASK;
    24d4:	8a e1       	ldi	r24, 0x1A	; 26
    24d6:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
  SPINDLE_OCRA_REGISTER = SPINDLE_OCRA_TOP_VALUE; // Set the top value for 16-bit fast PWM mode
    24da:	80 e0       	ldi	r24, 0x00	; 0
    24dc:	94 e0       	ldi	r25, 0x04	; 4
    24de:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
    24e2:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
  SPINDLE_ENABLE_DDR |= (1<<SPINDLE_ENABLE_BIT); // Configure as output pin.
    24e6:	80 81       	ld	r24, Z
    24e8:	88 60       	ori	r24, 0x08	; 8
    24ea:	80 83       	st	Z, r24
  SPINDLE_DIRECTION_DDR |= (1<<SPINDLE_DIRECTION_BIT); // Configure as output pin.
    24ec:	6b 9a       	sbi	0x0d, 3	; 13

  pwm_gradient = SPINDLE_PWM_RANGE/(settings.rpm_max-settings.rpm_min);
    24ee:	20 91 11 0f 	lds	r18, 0x0F11	; 0x800f11 <settings+0x41>
    24f2:	30 91 12 0f 	lds	r19, 0x0F12	; 0x800f12 <settings+0x42>
    24f6:	40 91 13 0f 	lds	r20, 0x0F13	; 0x800f13 <settings+0x43>
    24fa:	50 91 14 0f 	lds	r21, 0x0F14	; 0x800f14 <settings+0x44>
    24fe:	60 91 0d 0f 	lds	r22, 0x0F0D	; 0x800f0d <settings+0x3d>
    2502:	70 91 0e 0f 	lds	r23, 0x0F0E	; 0x800f0e <settings+0x3e>
    2506:	80 91 0f 0f 	lds	r24, 0x0F0F	; 0x800f0f <settings+0x3f>
    250a:	90 91 10 0f 	lds	r25, 0x0F10	; 0x800f10 <settings+0x40>
    250e:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    2512:	9b 01       	movw	r18, r22
    2514:	ac 01       	movw	r20, r24
    2516:	60 e0       	ldi	r22, 0x00	; 0
    2518:	70 ec       	ldi	r23, 0xC0	; 192
    251a:	8f e7       	ldi	r24, 0x7F	; 127
    251c:	94 e4       	ldi	r25, 0x44	; 68
    251e:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__divsf3>
    2522:	60 93 00 02 	sts	0x0200, r22	; 0x800200 <_edata>
    2526:	70 93 01 02 	sts	0x0201, r23	; 0x800201 <_edata+0x1>
    252a:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <_edata+0x2>
    252e:	90 93 03 02 	sts	0x0203, r25	; 0x800203 <_edata+0x3>
  spindle_stop();
    2532:	bd cf       	rjmp	.-134    	; 0x24ae <spindle_stop>
    2534:	08 95       	ret

00002536 <spindle_set_speed>:

// Sets spindle speed PWM output and enable pin, if configured. Called by spindle_set_state()
// and stepper ISR. Keep routine small and efficient.
void spindle_set_speed(uint16_t pwm_value)
{
  SPINDLE_OCR_REGISTER = pwm_value; // Set PWM output level.
    2536:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
    253a:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
      #else
        SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
      #endif
    }
  #else
    if (pwm_value == SPINDLE_PWM_OFF_VALUE) {
    253e:	89 2b       	or	r24, r25
    2540:	31 f4       	brne	.+12     	; 0x254e <spindle_set_speed+0x18>
      SPINDLE_TCCRA_REGISTER &= ~(1<<SPINDLE_COMB_BIT); // Disable PWM. Output voltage is zero.
    2542:	e0 ea       	ldi	r30, 0xA0	; 160
    2544:	f0 e0       	ldi	r31, 0x00	; 0
    2546:	80 81       	ld	r24, Z
    2548:	8f 7d       	andi	r24, 0xDF	; 223
    254a:	80 83       	st	Z, r24
    254c:	08 95       	ret
    } else {
      SPINDLE_TCCRA_REGISTER |= (1<<SPINDLE_COMB_BIT); // Ensure PWM output is enabled.
    254e:	e0 ea       	ldi	r30, 0xA0	; 160
    2550:	f0 e0       	ldi	r31, 0x00	; 0
    2552:	80 81       	ld	r24, Z
    2554:	80 62       	ori	r24, 0x20	; 32
    2556:	80 83       	st	Z, r24
    2558:	08 95       	ret

0000255a <spindle_compute_pwm_value>:

#else 

  // Called by spindle_set_state() and step segment generator. Keep routine small and efficient.
  uint16_t spindle_compute_pwm_value(float rpm) // Mega2560 PWM register is 16-bit.
  {
    255a:	4f 92       	push	r4
    255c:	5f 92       	push	r5
    255e:	6f 92       	push	r6
    2560:	7f 92       	push	r7
    2562:	8f 92       	push	r8
    2564:	9f 92       	push	r9
    2566:	af 92       	push	r10
    2568:	bf 92       	push	r11
    256a:	cf 92       	push	r12
    256c:	df 92       	push	r13
    256e:	ef 92       	push	r14
    2570:	ff 92       	push	r15
    2572:	2b 01       	movw	r4, r22
    2574:	3c 01       	movw	r6, r24
	uint16_t pwm_value;
	rpm *= (0.010*sys.spindle_speed_ovr); // Scale by spindle speed override value.
	// Calculate PWM register value based on rpm max/min settings and programmed rpm.
	if ((settings.rpm_min >= settings.rpm_max) || (rpm >= settings.rpm_max)) {
    2576:	80 90 11 0f 	lds	r8, 0x0F11	; 0x800f11 <settings+0x41>
    257a:	90 90 12 0f 	lds	r9, 0x0F12	; 0x800f12 <settings+0x42>
    257e:	a0 90 13 0f 	lds	r10, 0x0F13	; 0x800f13 <settings+0x43>
    2582:	b0 90 14 0f 	lds	r11, 0x0F14	; 0x800f14 <settings+0x44>
    2586:	c0 90 0d 0f 	lds	r12, 0x0F0D	; 0x800f0d <settings+0x3d>
    258a:	d0 90 0e 0f 	lds	r13, 0x0F0E	; 0x800f0e <settings+0x3e>
    258e:	e0 90 0f 0f 	lds	r14, 0x0F0F	; 0x800f0f <settings+0x3f>
    2592:	f0 90 10 0f 	lds	r15, 0x0F10	; 0x800f10 <settings+0x40>
    2596:	a7 01       	movw	r20, r14
    2598:	96 01       	movw	r18, r12
    259a:	c5 01       	movw	r24, r10
    259c:	b4 01       	movw	r22, r8
    259e:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    25a2:	88 23       	and	r24, r24
    25a4:	cc f4       	brge	.+50     	; 0x25d8 <spindle_compute_pwm_value+0x7e>

  // Called by spindle_set_state() and step segment generator. Keep routine small and efficient.
  uint16_t spindle_compute_pwm_value(float rpm) // Mega2560 PWM register is 16-bit.
  {
	uint16_t pwm_value;
	rpm *= (0.010*sys.spindle_speed_ovr); // Scale by spindle speed override value.
    25a6:	60 91 27 0c 	lds	r22, 0x0C27	; 0x800c27 <sys+0x9>
    25aa:	70 e0       	ldi	r23, 0x00	; 0
    25ac:	80 e0       	ldi	r24, 0x00	; 0
    25ae:	90 e0       	ldi	r25, 0x00	; 0
    25b0:	0e 94 07 40 	call	0x800e	; 0x800e <__floatsisf>
    25b4:	2a e0       	ldi	r18, 0x0A	; 10
    25b6:	37 ed       	ldi	r19, 0xD7	; 215
    25b8:	43 e2       	ldi	r20, 0x23	; 35
    25ba:	5c e3       	ldi	r21, 0x3C	; 60
    25bc:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    25c0:	a3 01       	movw	r20, r6
    25c2:	92 01       	movw	r18, r4
    25c4:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    25c8:	2b 01       	movw	r4, r22
    25ca:	3c 01       	movw	r6, r24
	// Calculate PWM register value based on rpm max/min settings and programmed rpm.
	if ((settings.rpm_min >= settings.rpm_max) || (rpm >= settings.rpm_max)) {
    25cc:	a7 01       	movw	r20, r14
    25ce:	96 01       	movw	r18, r12
    25d0:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    25d4:	88 23       	and	r24, r24
    25d6:	5c f0       	brlt	.+22     	; 0x25ee <spindle_compute_pwm_value+0x94>
	  // No PWM range possible. Set simple on/off spindle control pin state.
	  sys.spindle_speed = settings.rpm_max;
    25d8:	c0 92 2c 0c 	sts	0x0C2C, r12	; 0x800c2c <sys+0xe>
    25dc:	d0 92 2d 0c 	sts	0x0C2D, r13	; 0x800c2d <sys+0xf>
    25e0:	e0 92 2e 0c 	sts	0x0C2E, r14	; 0x800c2e <sys+0x10>
    25e4:	f0 92 2f 0c 	sts	0x0C2F, r15	; 0x800c2f <sys+0x11>
	  pwm_value = SPINDLE_PWM_MAX_VALUE;
    25e8:	80 e0       	ldi	r24, 0x00	; 0
    25ea:	94 e0       	ldi	r25, 0x04	; 4
    25ec:	4a c0       	rjmp	.+148    	; 0x2682 <spindle_compute_pwm_value+0x128>
	} else if (rpm <= settings.rpm_min) {
    25ee:	a5 01       	movw	r20, r10
    25f0:	94 01       	movw	r18, r8
    25f2:	c3 01       	movw	r24, r6
    25f4:	b2 01       	movw	r22, r4
    25f6:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    25fa:	18 16       	cp	r1, r24
    25fc:	fc f0       	brlt	.+62     	; 0x263c <spindle_compute_pwm_value+0xe2>
	  if (rpm == 0.0) { // S0 disables spindle
    25fe:	20 e0       	ldi	r18, 0x00	; 0
    2600:	30 e0       	ldi	r19, 0x00	; 0
    2602:	a9 01       	movw	r20, r18
    2604:	c3 01       	movw	r24, r6
    2606:	b2 01       	movw	r22, r4
    2608:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    260c:	81 11       	cpse	r24, r1
    260e:	0b c0       	rjmp	.+22     	; 0x2626 <spindle_compute_pwm_value+0xcc>
		sys.spindle_speed = 0.0;
    2610:	10 92 2c 0c 	sts	0x0C2C, r1	; 0x800c2c <sys+0xe>
    2614:	10 92 2d 0c 	sts	0x0C2D, r1	; 0x800c2d <sys+0xf>
    2618:	10 92 2e 0c 	sts	0x0C2E, r1	; 0x800c2e <sys+0x10>
    261c:	10 92 2f 0c 	sts	0x0C2F, r1	; 0x800c2f <sys+0x11>
		pwm_value = SPINDLE_PWM_OFF_VALUE;
    2620:	80 e0       	ldi	r24, 0x00	; 0
    2622:	90 e0       	ldi	r25, 0x00	; 0
    2624:	2e c0       	rjmp	.+92     	; 0x2682 <spindle_compute_pwm_value+0x128>
	  } else { // Set minimum PWM output
		sys.spindle_speed = settings.rpm_min;
    2626:	80 92 2c 0c 	sts	0x0C2C, r8	; 0x800c2c <sys+0xe>
    262a:	90 92 2d 0c 	sts	0x0C2D, r9	; 0x800c2d <sys+0xf>
    262e:	a0 92 2e 0c 	sts	0x0C2E, r10	; 0x800c2e <sys+0x10>
    2632:	b0 92 2f 0c 	sts	0x0C2F, r11	; 0x800c2f <sys+0x11>
		pwm_value = SPINDLE_PWM_MIN_VALUE;
    2636:	81 e0       	ldi	r24, 0x01	; 1
    2638:	90 e0       	ldi	r25, 0x00	; 0
    263a:	23 c0       	rjmp	.+70     	; 0x2682 <spindle_compute_pwm_value+0x128>
	  }
	} else { 
	  // Compute intermediate PWM value with linear spindle speed model.
	  // NOTE: A nonlinear model could be installed here, if required, but keep it VERY light-weight.
	  sys.spindle_speed = rpm;
    263c:	40 92 2c 0c 	sts	0x0C2C, r4	; 0x800c2c <sys+0xe>
    2640:	50 92 2d 0c 	sts	0x0C2D, r5	; 0x800c2d <sys+0xf>
    2644:	60 92 2e 0c 	sts	0x0C2E, r6	; 0x800c2e <sys+0x10>
    2648:	70 92 2f 0c 	sts	0x0C2F, r7	; 0x800c2f <sys+0x11>
	  pwm_value = floor((rpm-settings.rpm_min)*pwm_gradient) + SPINDLE_PWM_MIN_VALUE;
    264c:	a5 01       	movw	r20, r10
    264e:	94 01       	movw	r18, r8
    2650:	c3 01       	movw	r24, r6
    2652:	b2 01       	movw	r22, r4
    2654:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    2658:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <_edata>
    265c:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <_edata+0x1>
    2660:	40 91 02 02 	lds	r20, 0x0202	; 0x800202 <_edata+0x2>
    2664:	50 91 03 02 	lds	r21, 0x0203	; 0x800203 <_edata+0x3>
    2668:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    266c:	0e 94 42 40 	call	0x8084	; 0x8084 <floor>
    2670:	20 e0       	ldi	r18, 0x00	; 0
    2672:	30 e0       	ldi	r19, 0x00	; 0
    2674:	40 e8       	ldi	r20, 0x80	; 128
    2676:	5f e3       	ldi	r21, 0x3F	; 63
    2678:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    267c:	0e 94 d9 3f 	call	0x7fb2	; 0x7fb2 <__fixunssfsi>
    2680:	cb 01       	movw	r24, r22
	}
	return(pwm_value);
  }
    2682:	ff 90       	pop	r15
    2684:	ef 90       	pop	r14
    2686:	df 90       	pop	r13
    2688:	cf 90       	pop	r12
    268a:	bf 90       	pop	r11
    268c:	af 90       	pop	r10
    268e:	9f 90       	pop	r9
    2690:	8f 90       	pop	r8
    2692:	7f 90       	pop	r7
    2694:	6f 90       	pop	r6
    2696:	5f 90       	pop	r5
    2698:	4f 90       	pop	r4
    269a:	08 95       	ret

0000269c <spindle_set_state>:
// Immediately sets spindle running state with direction and spindle rpm via PWM, if enabled.
// Called by g-code parser spindle_sync(), parking retract and restore, g-code program end,
// sleep, and spindle stop override.
void spindle_set_state(uint8_t state, float rpm)
{
  if (sys.abort) { return; } // Block during abort.
    269c:	90 91 1f 0c 	lds	r25, 0x0C1F	; 0x800c1f <sys+0x1>
    26a0:	91 11       	cpse	r25, r1
    26a2:	25 c0       	rjmp	.+74     	; 0x26ee <spindle_set_state+0x52>
  if (state == SPINDLE_DISABLE) { // Halt or set spindle direction and rpm.
    26a4:	81 11       	cpse	r24, r1
    26a6:	0a c0       	rjmp	.+20     	; 0x26bc <spindle_set_state+0x20>
  
    sys.spindle_speed = 0.0;
    26a8:	10 92 2c 0c 	sts	0x0C2C, r1	; 0x800c2c <sys+0xe>
    26ac:	10 92 2d 0c 	sts	0x0C2D, r1	; 0x800c2d <sys+0xf>
    26b0:	10 92 2e 0c 	sts	0x0C2E, r1	; 0x800c2e <sys+0x10>
    26b4:	10 92 2f 0c 	sts	0x0C2F, r1	; 0x800c2f <sys+0x11>
    spindle_stop();
    26b8:	fa de       	rcall	.-524    	; 0x24ae <spindle_stop>
    26ba:	17 c0       	rjmp	.+46     	; 0x26ea <spindle_set_state+0x4e>
  
  } else {
  
    if (state == SPINDLE_ENABLE_CW) {
    26bc:	80 31       	cpi	r24, 0x10	; 16
    26be:	11 f4       	brne	.+4      	; 0x26c4 <spindle_set_state+0x28>
      SPINDLE_DIRECTION_PORT &= ~(1<<SPINDLE_DIRECTION_BIT);
    26c0:	73 98       	cbi	0x0e, 3	; 14
    26c2:	0a c0       	rjmp	.+20     	; 0x26d8 <spindle_set_state+0x3c>
    } else {
      SPINDLE_DIRECTION_PORT |= (1<<SPINDLE_DIRECTION_BIT);
    26c4:	73 9a       	sbi	0x0e, 3	; 14
    }

    // NOTE: Assumes all calls to this function is when Grbl is not moving or must remain off.
    if (settings.flags & BITFLAG_LASER_MODE) { 
    26c6:	90 91 15 0f 	lds	r25, 0x0F15	; 0x800f15 <settings+0x45>
    26ca:	91 ff       	sbrs	r25, 1
    26cc:	05 c0       	rjmp	.+10     	; 0x26d8 <spindle_set_state+0x3c>
      if (state == SPINDLE_ENABLE_CCW) { rpm = 0.0; } // TODO: May need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE);
    26ce:	80 32       	cpi	r24, 0x20	; 32
    26d0:	19 f4       	brne	.+6      	; 0x26d8 <spindle_set_state+0x3c>
    26d2:	40 e0       	ldi	r20, 0x00	; 0
    26d4:	50 e0       	ldi	r21, 0x00	; 0
    26d6:	ba 01       	movw	r22, r20
    }
    spindle_set_speed(spindle_compute_pwm_value(rpm));
    26d8:	cb 01       	movw	r24, r22
    26da:	ba 01       	movw	r22, r20
    26dc:	3e df       	rcall	.-388    	; 0x255a <spindle_compute_pwm_value>
    26de:	2b df       	rcall	.-426    	; 0x2536 <spindle_set_speed>

    #ifndef SPINDLE_ENABLE_OFF_WITH_ZERO_SPEED
      #ifdef INVERT_SPINDLE_ENABLE_PIN
        SPINDLE_ENABLE_PORT &= ~(1<<SPINDLE_ENABLE_BIT);
      #else
        SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
    26e0:	e2 e0       	ldi	r30, 0x02	; 2
    26e2:	f1 e0       	ldi	r31, 0x01	; 1
    26e4:	80 81       	ld	r24, Z
    26e6:	88 60       	ori	r24, 0x08	; 8
    26e8:	80 83       	st	Z, r24
      #endif   
    #endif
  
  }
  
  sys.report_ovr_counter = 0; // Set to report change immediately
    26ea:	10 92 29 0c 	sts	0x0C29, r1	; 0x800c29 <sys+0xb>
    26ee:	08 95       	ret

000026f0 <spindle_sync>:


// G-code parser entry-point for setting spindle state. Forces a planner buffer sync and bails 
// if an abort or check-mode is active.
void spindle_sync(uint8_t state, float rpm)
{
    26f0:	cf 92       	push	r12
    26f2:	df 92       	push	r13
    26f4:	ef 92       	push	r14
    26f6:	ff 92       	push	r15
    26f8:	cf 93       	push	r28
  if (sys.state == STATE_CHECK_MODE) { return; }
    26fa:	90 91 1e 0c 	lds	r25, 0x0C1E	; 0x800c1e <sys>
    26fe:	92 30       	cpi	r25, 0x02	; 2
    2700:	41 f0       	breq	.+16     	; 0x2712 <spindle_sync+0x22>
    2702:	6a 01       	movw	r12, r20
    2704:	7b 01       	movw	r14, r22
    2706:	c8 2f       	mov	r28, r24
  protocol_buffer_synchronize(); // Empty planner buffer to ensure spindle is set when programmed.
    2708:	7d d5       	rcall	.+2810   	; 0x3204 <protocol_buffer_synchronize>
  spindle_set_state(state,rpm);
    270a:	b7 01       	movw	r22, r14
    270c:	a6 01       	movw	r20, r12
    270e:	8c 2f       	mov	r24, r28
    2710:	c5 df       	rcall	.-118    	; 0x269c <spindle_set_state>
}
    2712:	cf 91       	pop	r28
    2714:	ff 90       	pop	r15
    2716:	ef 90       	pop	r14
    2718:	df 90       	pop	r13
    271a:	cf 90       	pop	r12
    271c:	08 95       	ret

0000271e <coolant_get_state>:
{
  uint8_t cl_state = COOLANT_STATE_DISABLE;
  #ifdef INVERT_COOLANT_FLOOD_PIN
    if (bit_isfalse(COOLANT_FLOOD_PORT,(1 << COOLANT_FLOOD_BIT))) {
  #else
    if (bit_istrue(COOLANT_FLOOD_PORT,(1 << COOLANT_FLOOD_BIT))) {
    271e:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2722:	85 ff       	sbrs	r24, 5
    2724:	02 c0       	rjmp	.+4      	; 0x272a <coolant_get_state+0xc>
  #endif
    cl_state |= COOLANT_STATE_FLOOD;
    2726:	80 e4       	ldi	r24, 0x40	; 64
    2728:	01 c0       	rjmp	.+2      	; 0x272c <coolant_get_state+0xe>


// Returns current coolant output state. Overrides may alter it from programmed state.
uint8_t coolant_get_state()
{
  uint8_t cl_state = COOLANT_STATE_DISABLE;
    272a:	80 e0       	ldi	r24, 0x00	; 0
    cl_state |= COOLANT_STATE_FLOOD;
  }
  #ifdef INVERT_COOLANT_MIST_PIN
    if (bit_isfalse(COOLANT_MIST_PORT,(1 << COOLANT_MIST_BIT))) {
  #else
    if (bit_istrue(COOLANT_MIST_PORT,(1 << COOLANT_MIST_BIT))) {
    272c:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2730:	96 fd       	sbrc	r25, 6
  #endif
    cl_state |= COOLANT_STATE_MIST;
    2732:	80 68       	ori	r24, 0x80	; 128
  }
  return(cl_state);
}
    2734:	08 95       	ret

00002736 <coolant_stop>:
void coolant_stop()
{
  #ifdef INVERT_COOLANT_FLOOD_PIN
    COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
  #else
    COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    2736:	e2 e0       	ldi	r30, 0x02	; 2
    2738:	f1 e0       	ldi	r31, 0x01	; 1
    273a:	80 81       	ld	r24, Z
    273c:	8f 7d       	andi	r24, 0xDF	; 223
    273e:	80 83       	st	Z, r24
  #endif
  #ifdef INVERT_COOLANT_MIST_PIN
    COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
  #else
    COOLANT_MIST_PORT &= ~(1 << COOLANT_MIST_BIT);
    2740:	80 81       	ld	r24, Z
    2742:	8f 7b       	andi	r24, 0xBF	; 191
    2744:	80 83       	st	Z, r24
    2746:	08 95       	ret

00002748 <coolant_init>:
#include "grbl.h"


void coolant_init()
{
  COOLANT_FLOOD_DDR |= (1 << COOLANT_FLOOD_BIT); // Configure as output pin.
    2748:	e1 e0       	ldi	r30, 0x01	; 1
    274a:	f1 e0       	ldi	r31, 0x01	; 1
    274c:	80 81       	ld	r24, Z
    274e:	80 62       	ori	r24, 0x20	; 32
    2750:	80 83       	st	Z, r24
  COOLANT_MIST_DDR |= (1 << COOLANT_MIST_BIT); // Configure as output pin.
    2752:	80 81       	ld	r24, Z
    2754:	80 64       	ori	r24, 0x40	; 64
    2756:	80 83       	st	Z, r24
  coolant_stop();
    2758:	ee cf       	rjmp	.-36     	; 0x2736 <coolant_stop>
    275a:	08 95       	ret

0000275c <coolant_set_state>:
// if enabled. Also sets a flag to report an update to a coolant state.
// Called by coolant toggle override, parking restore, parking retract, sleep mode, g-code
// parser program end, and g-code parser coolant_sync().
void coolant_set_state(uint8_t mode)
{
  if (sys.abort) { return; } // Block during abort.  
    275c:	90 91 1f 0c 	lds	r25, 0x0C1F	; 0x800c1f <sys+0x1>
    2760:	91 11       	cpse	r25, r1
    2762:	1c c0       	rjmp	.+56     	; 0x279c <coolant_set_state+0x40>
  
  if (mode & COOLANT_FLOOD_ENABLE) {
    2764:	86 ff       	sbrs	r24, 6
    2766:	06 c0       	rjmp	.+12     	; 0x2774 <coolant_set_state+0x18>
    #ifdef INVERT_COOLANT_FLOOD_PIN
      COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    #else
      COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
    2768:	e2 e0       	ldi	r30, 0x02	; 2
    276a:	f1 e0       	ldi	r31, 0x01	; 1
    276c:	90 81       	ld	r25, Z
    276e:	90 62       	ori	r25, 0x20	; 32
    2770:	90 83       	st	Z, r25
    2772:	05 c0       	rjmp	.+10     	; 0x277e <coolant_set_state+0x22>
    #endif
	} else {
	  #ifdef INVERT_COOLANT_FLOOD_PIN
			COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
		#else
			COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    2774:	e2 e0       	ldi	r30, 0x02	; 2
    2776:	f1 e0       	ldi	r31, 0x01	; 1
    2778:	90 81       	ld	r25, Z
    277a:	9f 7d       	andi	r25, 0xDF	; 223
    277c:	90 83       	st	Z, r25
		#endif
	}
  
	if (mode & COOLANT_MIST_ENABLE) {
    277e:	88 23       	and	r24, r24
    2780:	34 f4       	brge	.+12     	; 0x278e <coolant_set_state+0x32>
		#ifdef INVERT_COOLANT_MIST_PIN
			COOLANT_MIST_PORT &= ~(1 << COOLANT_MIST_BIT);
		#else
			COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
    2782:	e2 e0       	ldi	r30, 0x02	; 2
    2784:	f1 e0       	ldi	r31, 0x01	; 1
    2786:	80 81       	ld	r24, Z
    2788:	80 64       	ori	r24, 0x40	; 64
    278a:	80 83       	st	Z, r24
    278c:	05 c0       	rjmp	.+10     	; 0x2798 <coolant_set_state+0x3c>
		#endif
	} else {
		#ifdef INVERT_COOLANT_MIST_PIN
			COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
		#else
			COOLANT_MIST_PORT &= ~(1 << COOLANT_MIST_BIT);
    278e:	e2 e0       	ldi	r30, 0x02	; 2
    2790:	f1 e0       	ldi	r31, 0x01	; 1
    2792:	80 81       	ld	r24, Z
    2794:	8f 7b       	andi	r24, 0xBF	; 191
    2796:	80 83       	st	Z, r24
		#endif
	}
	
  sys.report_ovr_counter = 0; // Set to report change immediately
    2798:	10 92 29 0c 	sts	0x0C29, r1	; 0x800c29 <sys+0xb>
    279c:	08 95       	ret

0000279e <coolant_sync>:


// G-code parser entry-point for setting coolant state. Forces a planner buffer sync and bails 
// if an abort or check-mode is active.
void coolant_sync(uint8_t mode)
{
    279e:	cf 93       	push	r28
  if (sys.state == STATE_CHECK_MODE) { return; }
    27a0:	90 91 1e 0c 	lds	r25, 0x0C1E	; 0x800c1e <sys>
    27a4:	92 30       	cpi	r25, 0x02	; 2
    27a6:	21 f0       	breq	.+8      	; 0x27b0 <coolant_sync+0x12>
    27a8:	c8 2f       	mov	r28, r24
  protocol_buffer_synchronize(); // Ensure coolant turns on when specified in program.
    27aa:	2c d5       	rcall	.+2648   	; 0x3204 <protocol_buffer_synchronize>
  coolant_set_state(mode);
    27ac:	8c 2f       	mov	r24, r28
    27ae:	d6 df       	rcall	.-84     	; 0x275c <coolant_set_state>
}
    27b0:	cf 91       	pop	r28
    27b2:	08 95       	ret

000027b4 <serial_get_rx_buffer_available>:
uint8_t serial_get_tx_buffer_count()
{
  uint8_t ttail = serial_tx_buffer_tail; // Copy to limit multiple calls to volatile
  if (serial_tx_buffer_head >= ttail) { return(serial_tx_buffer_head-ttail); }
  return (TX_RING_BUFFER - (ttail-serial_tx_buffer_head));
}
    27b4:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <serial_rx_buffer_tail>
    27b8:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <serial_rx_buffer_head>
    27bc:	98 17       	cp	r25, r24
    27be:	20 f0       	brcs	.+8      	; 0x27c8 <serial_get_rx_buffer_available+0x14>
    27c0:	98 1b       	sub	r25, r24
    27c2:	89 2f       	mov	r24, r25
    27c4:	80 95       	com	r24
    27c6:	08 95       	ret
    27c8:	81 50       	subi	r24, 0x01	; 1
    27ca:	89 1b       	sub	r24, r25
    27cc:	08 95       	ret

000027ce <serial_init>:
  #if BAUD_RATE < 57600
    uint16_t UBRR0_value = ((F_CPU / (8L * BAUD_RATE)) - 1)/2 ;
    UCSR0A &= ~(1 << U2X0); // baud doubler off  - Only needed on Uno XXX
  #else
    uint16_t UBRR0_value = ((F_CPU / (4L * BAUD_RATE)) - 1)/2;
    UCSR0A |= (1 << U2X0);  // baud doubler on for high baud rates, i.e. 115200
    27ce:	e0 ec       	ldi	r30, 0xC0	; 192
    27d0:	f0 e0       	ldi	r31, 0x00	; 0
    27d2:	80 81       	ld	r24, Z
    27d4:	82 60       	ori	r24, 0x02	; 2
    27d6:	80 83       	st	Z, r24
  #endif
  UBRR0H = UBRR0_value >> 8;
    27d8:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
  UBRR0L = UBRR0_value;
    27dc:	80 e1       	ldi	r24, 0x10	; 16
    27de:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>

  // enable rx, tx, and interrupt on complete reception of a byte
  UCSR0B |= (1<<RXEN0 | 1<<TXEN0 | 1<<RXCIE0);
    27e2:	e1 ec       	ldi	r30, 0xC1	; 193
    27e4:	f0 e0       	ldi	r31, 0x00	; 0
    27e6:	80 81       	ld	r24, Z
    27e8:	88 69       	ori	r24, 0x98	; 152
    27ea:	80 83       	st	Z, r24
    27ec:	08 95       	ret

000027ee <serial_write>:


// Writes one byte to the TX serial buffer. Called by main program.
void serial_write(uint8_t data) {
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
    27ee:	e0 91 05 02 	lds	r30, 0x0205	; 0x800205 <serial_tx_buffer_head>
    27f2:	21 e0       	ldi	r18, 0x01	; 1
    27f4:	2e 0f       	add	r18, r30
  if (next_head == TX_RING_BUFFER) { next_head = 0; }

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) {
    27f6:	04 c0       	rjmp	.+8      	; 0x2800 <serial_write+0x12>
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.
    if (sys_rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
    27f8:	90 91 31 0c 	lds	r25, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    27fc:	94 fd       	sbrc	r25, 4
    27fe:	0f c0       	rjmp	.+30     	; 0x281e <serial_write+0x30>
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
  if (next_head == TX_RING_BUFFER) { next_head = 0; }

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) {
    2800:	90 91 04 02 	lds	r25, 0x0204	; 0x800204 <serial_tx_buffer_tail>
    2804:	29 17       	cp	r18, r25
    2806:	c1 f3       	breq	.-16     	; 0x27f8 <serial_write+0xa>
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.
    if (sys_rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
  }

  // Store data and advance head
  serial_tx_buffer[serial_tx_buffer_head] = data;
    2808:	f0 e0       	ldi	r31, 0x00	; 0
    280a:	e0 53       	subi	r30, 0x30	; 48
    280c:	f3 4f       	sbci	r31, 0xF3	; 243
    280e:	80 83       	st	Z, r24
  serial_tx_buffer_head = next_head;
    2810:	20 93 05 02 	sts	0x0205, r18	; 0x800205 <serial_tx_buffer_head>

  // Enable Data Register Empty Interrupt to make sure tx-streaming is running
  UCSR0B |=  (1 << UDRIE0);
    2814:	e1 ec       	ldi	r30, 0xC1	; 193
    2816:	f0 e0       	ldi	r31, 0x00	; 0
    2818:	80 81       	ld	r24, Z
    281a:	80 62       	ori	r24, 0x20	; 32
    281c:	80 83       	st	Z, r24
    281e:	08 95       	ret

00002820 <__vector_26>:
}


// Data Register Empty Interrupt handler
ISR(SERIAL_UDRE)
{
    2820:	1f 92       	push	r1
    2822:	0f 92       	push	r0
    2824:	0f b6       	in	r0, 0x3f	; 63
    2826:	0f 92       	push	r0
    2828:	11 24       	eor	r1, r1
    282a:	0b b6       	in	r0, 0x3b	; 59
    282c:	0f 92       	push	r0
    282e:	8f 93       	push	r24
    2830:	9f 93       	push	r25
    2832:	ef 93       	push	r30
    2834:	ff 93       	push	r31
  uint8_t tail = serial_tx_buffer_tail; // Temporary serial_tx_buffer_tail (to optimize for volatile)
    2836:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <serial_tx_buffer_tail>

  // Send a byte from the buffer
  UDR0 = serial_tx_buffer[tail];
    283a:	e8 2f       	mov	r30, r24
    283c:	f0 e0       	ldi	r31, 0x00	; 0
    283e:	e0 53       	subi	r30, 0x30	; 48
    2840:	f3 4f       	sbci	r31, 0xF3	; 243
    2842:	90 81       	ld	r25, Z
    2844:	90 93 c6 00 	sts	0x00C6, r25	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>

  // Update tail position
  tail++;
    2848:	8f 5f       	subi	r24, 0xFF	; 255
  if (tail == TX_RING_BUFFER) { tail = 0; }

  serial_tx_buffer_tail = tail;
    284a:	80 93 04 02 	sts	0x0204, r24	; 0x800204 <serial_tx_buffer_tail>

  // Turn off Data Register Empty Interrupt to stop tx-streaming if this concludes the transfer
  if (tail == serial_tx_buffer_head) { UCSR0B &= ~(1 << UDRIE0); }
    284e:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <serial_tx_buffer_head>
    2852:	89 13       	cpse	r24, r25
    2854:	05 c0       	rjmp	.+10     	; 0x2860 <__vector_26+0x40>
    2856:	e1 ec       	ldi	r30, 0xC1	; 193
    2858:	f0 e0       	ldi	r31, 0x00	; 0
    285a:	80 81       	ld	r24, Z
    285c:	8f 7d       	andi	r24, 0xDF	; 223
    285e:	80 83       	st	Z, r24
}
    2860:	ff 91       	pop	r31
    2862:	ef 91       	pop	r30
    2864:	9f 91       	pop	r25
    2866:	8f 91       	pop	r24
    2868:	0f 90       	pop	r0
    286a:	0b be       	out	0x3b, r0	; 59
    286c:	0f 90       	pop	r0
    286e:	0f be       	out	0x3f, r0	; 63
    2870:	0f 90       	pop	r0
    2872:	1f 90       	pop	r1
    2874:	18 95       	reti

00002876 <serial_read>:


// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
    2876:	90 91 06 02 	lds	r25, 0x0206	; 0x800206 <serial_rx_buffer_tail>
  if (serial_rx_buffer_head == tail) {
    287a:	80 91 07 02 	lds	r24, 0x0207	; 0x800207 <serial_rx_buffer_head>
    287e:	98 17       	cp	r25, r24
    2880:	49 f0       	breq	.+18     	; 0x2894 <serial_read+0x1e>
    return SERIAL_NO_DATA;
  } else {
    uint8_t data = serial_rx_buffer[tail];
    2882:	e9 2f       	mov	r30, r25
    2884:	f0 e0       	ldi	r31, 0x00	; 0
    2886:	e0 53       	subi	r30, 0x30	; 48
    2888:	f2 4f       	sbci	r31, 0xF2	; 242
    288a:	80 81       	ld	r24, Z

    tail++;
    288c:	9f 5f       	subi	r25, 0xFF	; 255
    if (tail == RX_RING_BUFFER) { tail = 0; }
    serial_rx_buffer_tail = tail;
    288e:	90 93 06 02 	sts	0x0206, r25	; 0x800206 <serial_rx_buffer_tail>

    return data;
    2892:	08 95       	ret
// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
  if (serial_rx_buffer_head == tail) {
    return SERIAL_NO_DATA;
    2894:	8f ef       	ldi	r24, 0xFF	; 255
    if (tail == RX_RING_BUFFER) { tail = 0; }
    serial_rx_buffer_tail = tail;

    return data;
  }
}
    2896:	08 95       	ret

00002898 <__vector_25>:


ISR(SERIAL_RX)
{
    2898:	1f 92       	push	r1
    289a:	0f 92       	push	r0
    289c:	0f b6       	in	r0, 0x3f	; 63
    289e:	0f 92       	push	r0
    28a0:	11 24       	eor	r1, r1
    28a2:	0b b6       	in	r0, 0x3b	; 59
    28a4:	0f 92       	push	r0
    28a6:	2f 93       	push	r18
    28a8:	3f 93       	push	r19
    28aa:	4f 93       	push	r20
    28ac:	5f 93       	push	r21
    28ae:	6f 93       	push	r22
    28b0:	7f 93       	push	r23
    28b2:	8f 93       	push	r24
    28b4:	9f 93       	push	r25
    28b6:	af 93       	push	r26
    28b8:	bf 93       	push	r27
    28ba:	ef 93       	push	r30
    28bc:	ff 93       	push	r31
  uint8_t data = UDR0;
    28be:	e0 91 c6 00 	lds	r30, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
  uint8_t next_head;

  // Pick off realtime command characters directly from the serial stream. These characters are
  // not passed into the main buffer, but these set system state flag bits for realtime execution.
  switch (data) {
    28c2:	e1 32       	cpi	r30, 0x21	; 33
    28c4:	a1 f0       	breq	.+40     	; 0x28ee <__vector_25+0x56>
    28c6:	18 f4       	brcc	.+6      	; 0x28ce <__vector_25+0x36>
    28c8:	e8 31       	cpi	r30, 0x18	; 24
    28ca:	31 f0       	breq	.+12     	; 0x28d8 <__vector_25+0x40>
    28cc:	14 c0       	rjmp	.+40     	; 0x28f6 <__vector_25+0x5e>
    28ce:	ef 33       	cpi	r30, 0x3F	; 63
    28d0:	31 f0       	breq	.+12     	; 0x28de <__vector_25+0x46>
    28d2:	ee 37       	cpi	r30, 0x7E	; 126
    28d4:	41 f0       	breq	.+16     	; 0x28e6 <__vector_25+0x4e>
    28d6:	0f c0       	rjmp	.+30     	; 0x28f6 <__vector_25+0x5e>
    case CMD_RESET:         mc_reset(); break; // Call motion control reset routine.
    28d8:	0e 94 2a 07 	call	0xe54	; 0xe54 <mc_reset>
    28dc:	81 c0       	rjmp	.+258    	; 0x29e0 <__vector_25+0x148>
    case CMD_STATUS_REPORT: system_set_exec_state_flag(EXEC_STATUS_REPORT); break; // Set as true
    28de:	81 e0       	ldi	r24, 0x01	; 1
    28e0:	0e 94 95 3b 	call	0x772a	; 0x772a <system_set_exec_state_flag>
    28e4:	7d c0       	rjmp	.+250    	; 0x29e0 <__vector_25+0x148>
    case CMD_CYCLE_START:   system_set_exec_state_flag(EXEC_CYCLE_START); break; // Set as true
    28e6:	82 e0       	ldi	r24, 0x02	; 2
    28e8:	0e 94 95 3b 	call	0x772a	; 0x772a <system_set_exec_state_flag>
    28ec:	79 c0       	rjmp	.+242    	; 0x29e0 <__vector_25+0x148>
    case CMD_FEED_HOLD:     system_set_exec_state_flag(EXEC_FEED_HOLD); break; // Set as true
    28ee:	88 e0       	ldi	r24, 0x08	; 8
    28f0:	0e 94 95 3b 	call	0x772a	; 0x772a <system_set_exec_state_flag>
    28f4:	75 c0       	rjmp	.+234    	; 0x29e0 <__vector_25+0x148>
    default :
      if (data > 0x7F) { // Real-time control characters are extended ACSII only.
    28f6:	ee 23       	and	r30, r30
    28f8:	0c f0       	brlt	.+2      	; 0x28fc <__vector_25+0x64>
    28fa:	64 c0       	rjmp	.+200    	; 0x29c4 <__vector_25+0x12c>
        switch(data) {
    28fc:	8e 2f       	mov	r24, r30
    28fe:	90 e0       	ldi	r25, 0x00	; 0
    2900:	fc 01       	movw	r30, r24
    2902:	e4 58       	subi	r30, 0x84	; 132
    2904:	f1 09       	sbc	r31, r1
    2906:	ee 31       	cpi	r30, 0x1E	; 30
    2908:	f1 05       	cpc	r31, r1
    290a:	08 f0       	brcs	.+2      	; 0x290e <__vector_25+0x76>
    290c:	69 c0       	rjmp	.+210    	; 0x29e0 <__vector_25+0x148>
    290e:	88 27       	eor	r24, r24
    2910:	eb 5f       	subi	r30, 0xFB	; 251
    2912:	fe 4f       	sbci	r31, 0xFE	; 254
    2914:	8f 4f       	sbci	r24, 0xFF	; 255
    2916:	0c 94 b2 42 	jmp	0x8564	; 0x8564 <__tablejump2__>
          case CMD_SAFETY_DOOR:   system_set_exec_state_flag(EXEC_SAFETY_DOOR); break; // Set as true
    291a:	80 e2       	ldi	r24, 0x20	; 32
    291c:	0e 94 95 3b 	call	0x772a	; 0x772a <system_set_exec_state_flag>
    2920:	5f c0       	rjmp	.+190    	; 0x29e0 <__vector_25+0x148>
          case CMD_JOG_CANCEL:   
            if (sys.state & STATE_JOG) { // Block all other states from invoking motion cancel.
    2922:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2926:	85 ff       	sbrs	r24, 5
    2928:	5b c0       	rjmp	.+182    	; 0x29e0 <__vector_25+0x148>
              system_set_exec_state_flag(EXEC_MOTION_CANCEL); 
    292a:	80 e4       	ldi	r24, 0x40	; 64
    292c:	0e 94 95 3b 	call	0x772a	; 0x772a <system_set_exec_state_flag>
    2930:	57 c0       	rjmp	.+174    	; 0x29e0 <__vector_25+0x148>
            }
            break; 
          #ifdef DEBUG
            case CMD_DEBUG_REPORT: {uint8_t sreg = SREG; cli(); bit_true(sys_rt_exec_debug,EXEC_DEBUG_REPORT); SREG = sreg;} break;
    2932:	9f b7       	in	r25, 0x3f	; 63
    2934:	f8 94       	cli
    2936:	80 91 54 0c 	lds	r24, 0x0C54	; 0x800c54 <sys_rt_exec_debug>
    293a:	81 60       	ori	r24, 0x01	; 1
    293c:	80 93 54 0c 	sts	0x0C54, r24	; 0x800c54 <sys_rt_exec_debug>
    2940:	9f bf       	out	0x3f, r25	; 63
    2942:	4e c0       	rjmp	.+156    	; 0x29e0 <__vector_25+0x148>
          #endif
          case CMD_FEED_OVR_RESET: system_set_exec_motion_override_flag(EXEC_FEED_OVR_RESET); break;
    2944:	81 e0       	ldi	r24, 0x01	; 1
    2946:	0e 94 09 3e 	call	0x7c12	; 0x7c12 <system_set_exec_motion_override_flag>
    294a:	4a c0       	rjmp	.+148    	; 0x29e0 <__vector_25+0x148>
          case CMD_FEED_OVR_COARSE_PLUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_COARSE_PLUS); break;
    294c:	82 e0       	ldi	r24, 0x02	; 2
    294e:	0e 94 09 3e 	call	0x7c12	; 0x7c12 <system_set_exec_motion_override_flag>
    2952:	46 c0       	rjmp	.+140    	; 0x29e0 <__vector_25+0x148>
          case CMD_FEED_OVR_COARSE_MINUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_COARSE_MINUS); break;
    2954:	84 e0       	ldi	r24, 0x04	; 4
    2956:	0e 94 09 3e 	call	0x7c12	; 0x7c12 <system_set_exec_motion_override_flag>
    295a:	42 c0       	rjmp	.+132    	; 0x29e0 <__vector_25+0x148>
          case CMD_FEED_OVR_FINE_PLUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_FINE_PLUS); break;
    295c:	88 e0       	ldi	r24, 0x08	; 8
    295e:	0e 94 09 3e 	call	0x7c12	; 0x7c12 <system_set_exec_motion_override_flag>
    2962:	3e c0       	rjmp	.+124    	; 0x29e0 <__vector_25+0x148>
          case CMD_FEED_OVR_FINE_MINUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_FINE_MINUS); break;
    2964:	80 e1       	ldi	r24, 0x10	; 16
    2966:	0e 94 09 3e 	call	0x7c12	; 0x7c12 <system_set_exec_motion_override_flag>
    296a:	3a c0       	rjmp	.+116    	; 0x29e0 <__vector_25+0x148>
          case CMD_RAPID_OVR_RESET: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_RESET); break;
    296c:	80 e2       	ldi	r24, 0x20	; 32
    296e:	0e 94 09 3e 	call	0x7c12	; 0x7c12 <system_set_exec_motion_override_flag>
    2972:	36 c0       	rjmp	.+108    	; 0x29e0 <__vector_25+0x148>
          case CMD_RAPID_OVR_MEDIUM: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_MEDIUM); break;
    2974:	80 e4       	ldi	r24, 0x40	; 64
    2976:	0e 94 09 3e 	call	0x7c12	; 0x7c12 <system_set_exec_motion_override_flag>
    297a:	32 c0       	rjmp	.+100    	; 0x29e0 <__vector_25+0x148>
          case CMD_RAPID_OVR_LOW: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_LOW); break;
    297c:	80 e8       	ldi	r24, 0x80	; 128
    297e:	0e 94 09 3e 	call	0x7c12	; 0x7c12 <system_set_exec_motion_override_flag>
    2982:	2e c0       	rjmp	.+92     	; 0x29e0 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_RESET: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_RESET); break;
    2984:	81 e0       	ldi	r24, 0x01	; 1
    2986:	0e 94 12 3e 	call	0x7c24	; 0x7c24 <system_set_exec_accessory_override_flag>
    298a:	2a c0       	rjmp	.+84     	; 0x29e0 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_COARSE_PLUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_COARSE_PLUS); break;
    298c:	82 e0       	ldi	r24, 0x02	; 2
    298e:	0e 94 12 3e 	call	0x7c24	; 0x7c24 <system_set_exec_accessory_override_flag>
    2992:	26 c0       	rjmp	.+76     	; 0x29e0 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_COARSE_MINUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_COARSE_MINUS); break;
    2994:	84 e0       	ldi	r24, 0x04	; 4
    2996:	0e 94 12 3e 	call	0x7c24	; 0x7c24 <system_set_exec_accessory_override_flag>
    299a:	22 c0       	rjmp	.+68     	; 0x29e0 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_FINE_PLUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_FINE_PLUS); break;
    299c:	88 e0       	ldi	r24, 0x08	; 8
    299e:	0e 94 12 3e 	call	0x7c24	; 0x7c24 <system_set_exec_accessory_override_flag>
    29a2:	1e c0       	rjmp	.+60     	; 0x29e0 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_FINE_MINUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_FINE_MINUS); break;
    29a4:	80 e1       	ldi	r24, 0x10	; 16
    29a6:	0e 94 12 3e 	call	0x7c24	; 0x7c24 <system_set_exec_accessory_override_flag>
    29aa:	1a c0       	rjmp	.+52     	; 0x29e0 <__vector_25+0x148>
          case CMD_SPINDLE_OVR_STOP: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP); break;
    29ac:	80 e2       	ldi	r24, 0x20	; 32
    29ae:	0e 94 12 3e 	call	0x7c24	; 0x7c24 <system_set_exec_accessory_override_flag>
    29b2:	16 c0       	rjmp	.+44     	; 0x29e0 <__vector_25+0x148>
          case CMD_COOLANT_FLOOD_OVR_TOGGLE: system_set_exec_accessory_override_flag(EXEC_COOLANT_FLOOD_OVR_TOGGLE); break;
    29b4:	80 e4       	ldi	r24, 0x40	; 64
    29b6:	0e 94 12 3e 	call	0x7c24	; 0x7c24 <system_set_exec_accessory_override_flag>
    29ba:	12 c0       	rjmp	.+36     	; 0x29e0 <__vector_25+0x148>
          case CMD_COOLANT_MIST_OVR_TOGGLE: system_set_exec_accessory_override_flag(EXEC_COOLANT_MIST_OVR_TOGGLE); break;
    29bc:	80 e8       	ldi	r24, 0x80	; 128
    29be:	0e 94 12 3e 	call	0x7c24	; 0x7c24 <system_set_exec_accessory_override_flag>
    29c2:	0e c0       	rjmp	.+28     	; 0x29e0 <__vector_25+0x148>
        }
        // Throw away any unfound extended-ASCII character by not passing it to the serial buffer.
      } else { // Write character to buffer
        next_head = serial_rx_buffer_head + 1;
    29c4:	a0 91 07 02 	lds	r26, 0x0207	; 0x800207 <serial_rx_buffer_head>
    29c8:	81 e0       	ldi	r24, 0x01	; 1
    29ca:	8a 0f       	add	r24, r26
        if (next_head == RX_RING_BUFFER) { next_head = 0; }

        // Write data to buffer unless it is full.
        if (next_head != serial_rx_buffer_tail) {
    29cc:	90 91 06 02 	lds	r25, 0x0206	; 0x800206 <serial_rx_buffer_tail>
    29d0:	89 17       	cp	r24, r25
    29d2:	31 f0       	breq	.+12     	; 0x29e0 <__vector_25+0x148>
          serial_rx_buffer[serial_rx_buffer_head] = data;
    29d4:	b0 e0       	ldi	r27, 0x00	; 0
    29d6:	a0 53       	subi	r26, 0x30	; 48
    29d8:	b2 4f       	sbci	r27, 0xF2	; 242
    29da:	ec 93       	st	X, r30
          serial_rx_buffer_head = next_head;
    29dc:	80 93 07 02 	sts	0x0207, r24	; 0x800207 <serial_rx_buffer_head>
        }
      }
  }
}
    29e0:	ff 91       	pop	r31
    29e2:	ef 91       	pop	r30
    29e4:	bf 91       	pop	r27
    29e6:	af 91       	pop	r26
    29e8:	9f 91       	pop	r25
    29ea:	8f 91       	pop	r24
    29ec:	7f 91       	pop	r23
    29ee:	6f 91       	pop	r22
    29f0:	5f 91       	pop	r21
    29f2:	4f 91       	pop	r20
    29f4:	3f 91       	pop	r19
    29f6:	2f 91       	pop	r18
    29f8:	0f 90       	pop	r0
    29fa:	0b be       	out	0x3b, r0	; 59
    29fc:	0f 90       	pop	r0
    29fe:	0f be       	out	0x3f, r0	; 63
    2a00:	0f 90       	pop	r0
    2a02:	1f 90       	pop	r1
    2a04:	18 95       	reti

00002a06 <serial_reset_read_buffer>:


void serial_reset_read_buffer()
{
  serial_rx_buffer_tail = serial_rx_buffer_head;
    2a06:	80 91 07 02 	lds	r24, 0x0207	; 0x800207 <serial_rx_buffer_head>
    2a0a:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <serial_rx_buffer_tail>
    2a0e:	08 95       	ret

00002a10 <protocol_auto_cycle_start>:
// when one of these conditions exist respectively: There are no more blocks sent (i.e. streaming
// is finished, single commands), a command that needs to wait for the motions in the buffer to
// execute calls a buffer sync, or the planner buffer is full and ready to go.
void protocol_auto_cycle_start()
{
  if (plan_get_current_block() != NULL) { // Check if there are any blocks in the buffer.
    2a10:	0e 94 5b 29 	call	0x52b6	; 0x52b6 <plan_get_current_block>
    2a14:	89 2b       	or	r24, r25
    2a16:	19 f0       	breq	.+6      	; 0x2a1e <protocol_auto_cycle_start+0xe>
    system_set_exec_state_flag(EXEC_CYCLE_START); // If so, execute them!
    2a18:	82 e0       	ldi	r24, 0x02	; 2
    2a1a:	0c 94 95 3b 	jmp	0x772a	; 0x772a <system_set_exec_state_flag>
    2a1e:	08 95       	ret

00002a20 <protocol_exec_rt_system>:

// Executes run-time commands, when required. This function primarily operates as Grbl's state
// machine and controls the various real-time features Grbl has to offer.
// NOTE: Do not alter this unless you know exactly what you are doing!
void protocol_exec_rt_system()
{
    2a20:	cf 93       	push	r28
    2a22:	df 93       	push	r29
  uint8_t rt_exec; // Temp variable to avoid calling volatile multiple times.
  rt_exec = sys_rt_exec_alarm; // Copy volatile sys_rt_exec_alarm.
    2a24:	c0 91 53 0c 	lds	r28, 0x0C53	; 0x800c53 <sys_rt_exec_alarm>
  if (rt_exec) { // Enter only if any bit flag is true
    2a28:	cc 23       	and	r28, r28
    2a2a:	a9 f0       	breq	.+42     	; 0x2a56 <protocol_exec_rt_system+0x36>
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
    2a2c:	81 e0       	ldi	r24, 0x01	; 1
    2a2e:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
    report_alarm_message(rt_exec);
    2a32:	8c 2f       	mov	r24, r28
    2a34:	0e 94 44 35 	call	0x6a88	; 0x6a88 <report_alarm_message>
    // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
    if ((rt_exec == EXEC_ALARM_HARD_LIMIT) || (rt_exec == EXEC_ALARM_SOFT_LIMIT)) {
    2a38:	c1 50       	subi	r28, 0x01	; 1
    2a3a:	c2 30       	cpi	r28, 0x02	; 2
    2a3c:	50 f4       	brcc	.+20     	; 0x2a52 <protocol_exec_rt_system+0x32>
      report_feedback_message(MESSAGE_CRITICAL_EVENT);
    2a3e:	81 e0       	ldi	r24, 0x01	; 1
    2a40:	0e 94 ab 35 	call	0x6b56	; 0x6b56 <report_feedback_message>
      system_clear_exec_state_flag(EXEC_RESET); // Disable any existing reset
    2a44:	80 e1       	ldi	r24, 0x10	; 16
    2a46:	0e 94 f3 3d 	call	0x7be6	; 0x7be6 <system_clear_exec_state_flag>
        // Block everything, except reset and status reports, until user issues reset or power
        // cycles. Hard limits typically occur while unattended or not paying attention. Gives
        // the user and a GUI time to do what is needed before resetting, like killing the
        // incoming stream. The same could be said about soft limits. While the position is not
        // lost, continued streaming could cause a serious crash if by chance it gets executed.
      } while (bit_isfalse(sys_rt_exec_state,EXEC_RESET));
    2a4a:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    2a4e:	84 ff       	sbrs	r24, 4
    2a50:	fc cf       	rjmp	.-8      	; 0x2a4a <protocol_exec_rt_system+0x2a>
    }
    system_clear_exec_alarm(); // Clear alarm
    2a52:	0e 94 03 3e 	call	0x7c06	; 0x7c06 <system_clear_exec_alarm>
  }

  rt_exec = sys_rt_exec_state; // Copy volatile sys_rt_exec_state.
    2a56:	c0 91 31 0c 	lds	r28, 0x0C31	; 0x800c31 <sys_rt_exec_state>
  if (rt_exec) {
    2a5a:	cc 23       	and	r28, r28
    2a5c:	09 f4       	brne	.+2      	; 0x2a60 <protocol_exec_rt_system+0x40>
    2a5e:	f4 c0       	rjmp	.+488    	; 0x2c48 <protocol_exec_rt_system+0x228>

    // Execute system abort.
    if (rt_exec & EXEC_RESET) {
    2a60:	c4 ff       	sbrs	r28, 4
    2a62:	04 c0       	rjmp	.+8      	; 0x2a6c <protocol_exec_rt_system+0x4c>
      sys.abort = true;  // Only place this is set true.
    2a64:	81 e0       	ldi	r24, 0x01	; 1
    2a66:	80 93 1f 0c 	sts	0x0C1F, r24	; 0x800c1f <sys+0x1>
      return; // Nothing else to do but exit.
    2a6a:	01 c2       	rjmp	.+1026   	; 0x2e6e <protocol_exec_rt_system+0x44e>
    }

    // Execute and serial print status
    if (rt_exec & EXEC_STATUS_REPORT) {
    2a6c:	c0 ff       	sbrs	r28, 0
    2a6e:	05 c0       	rjmp	.+10     	; 0x2a7a <protocol_exec_rt_system+0x5a>
      report_realtime_status();
    2a70:	0e 94 68 38 	call	0x70d0	; 0x70d0 <report_realtime_status>
      system_clear_exec_state_flag(EXEC_STATUS_REPORT);
    2a74:	81 e0       	ldi	r24, 0x01	; 1
    2a76:	0e 94 f3 3d 	call	0x7be6	; 0x7be6 <system_clear_exec_state_flag>
    }

    // NOTE: Once hold is initiated, the system immediately enters a suspend state to block all
    // main program processes until either reset or resumed. This ensures a hold completes safely.
    if (rt_exec & (EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR | EXEC_SLEEP)) {
    2a7a:	8c 2f       	mov	r24, r28
    2a7c:	88 7e       	andi	r24, 0xE8	; 232
    2a7e:	09 f4       	brne	.+2      	; 0x2a82 <protocol_exec_rt_system+0x62>
    2a80:	63 c0       	rjmp	.+198    	; 0x2b48 <protocol_exec_rt_system+0x128>

      // State check for allowable states for hold methods.
      if (!(sys.state & (STATE_ALARM | STATE_CHECK_MODE))) {
    2a82:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2a86:	98 2f       	mov	r25, r24
    2a88:	93 70       	andi	r25, 0x03	; 3
    2a8a:	09 f0       	breq	.+2      	; 0x2a8e <protocol_exec_rt_system+0x6e>
    2a8c:	4c c0       	rjmp	.+152    	; 0x2b26 <protocol_exec_rt_system+0x106>
      
        // If in CYCLE or JOG states, immediately initiate a motion HOLD.
        if (sys.state & (STATE_CYCLE | STATE_JOG)) {
    2a8e:	88 72       	andi	r24, 0x28	; 40
    2a90:	91 f0       	breq	.+36     	; 0x2ab6 <protocol_exec_rt_system+0x96>
          if (!(sys.suspend & (SUSPEND_MOTION_CANCEL | SUSPEND_JOG_CANCEL))) { // Block, if already holding.
    2a92:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2a96:	80 7c       	andi	r24, 0xC0	; 192
    2a98:	71 f4       	brne	.+28     	; 0x2ab6 <protocol_exec_rt_system+0x96>
            st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
    2a9a:	b4 d6       	rcall	.+3432   	; 0x3804 <st_update_plan_block_parameters>
            sys.step_control = STEP_CONTROL_EXECUTE_HOLD; // Initiate suspend state with active flag.
    2a9c:	ee e1       	ldi	r30, 0x1E	; 30
    2a9e:	fc e0       	ldi	r31, 0x0C	; 12
    2aa0:	82 e0       	ldi	r24, 0x02	; 2
    2aa2:	84 83       	std	Z+4, r24	; 0x04
            if (sys.state == STATE_JOG) { // Jog cancelled upon any hold event, except for sleeping.
    2aa4:	80 81       	ld	r24, Z
    2aa6:	80 32       	cpi	r24, 0x20	; 32
    2aa8:	31 f4       	brne	.+12     	; 0x2ab6 <protocol_exec_rt_system+0x96>
              if (!(rt_exec & EXEC_SLEEP)) { sys.suspend |= SUSPEND_JOG_CANCEL; } 
    2aaa:	cc 23       	and	r28, r28
    2aac:	bc f0       	brlt	.+46     	; 0x2adc <protocol_exec_rt_system+0xbc>
    2aae:	92 81       	ldd	r25, Z+2	; 0x02
    2ab0:	90 68       	ori	r25, 0x80	; 128
    2ab2:	92 83       	std	Z+2, r25	; 0x02
    2ab4:	13 c0       	rjmp	.+38     	; 0x2adc <protocol_exec_rt_system+0xbc>
            }
          }
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend state and hold is complete.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_HOLD_COMPLETE; }
    2ab6:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2aba:	81 11       	cpse	r24, r1
    2abc:	06 c0       	rjmp	.+12     	; 0x2aca <protocol_exec_rt_system+0xaa>
    2abe:	91 e0       	ldi	r25, 0x01	; 1
    2ac0:	90 93 20 0c 	sts	0x0C20, r25	; 0x800c20 <sys+0x2>

        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
    2ac4:	c6 fd       	sbrc	r28, 6
    2ac6:	05 c0       	rjmp	.+10     	; 0x2ad2 <protocol_exec_rt_system+0xb2>
    2ac8:	cf c1       	rjmp	.+926    	; 0x2e68 <protocol_exec_rt_system+0x448>
    2aca:	c6 ff       	sbrs	r28, 6
    2acc:	07 c0       	rjmp	.+14     	; 0x2adc <protocol_exec_rt_system+0xbc>
          // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiated beforehand
          // to hold the CYCLE. Motion cancel is valid for a single planner block motion only, while jog cancel
          // will handle and clear multiple planner block motions.
          if (!(sys.state & STATE_JOG)) { sys.suspend |= SUSPEND_MOTION_CANCEL; } // NOTE: State is STATE_CYCLE.
    2ace:	85 fd       	sbrc	r24, 5
    2ad0:	05 c0       	rjmp	.+10     	; 0x2adc <protocol_exec_rt_system+0xbc>
    2ad2:	ee e1       	ldi	r30, 0x1E	; 30
    2ad4:	fc e0       	ldi	r31, 0x0C	; 12
    2ad6:	92 81       	ldd	r25, Z+2	; 0x02
    2ad8:	90 64       	ori	r25, 0x40	; 64
    2ada:	92 83       	std	Z+2, r25	; 0x02
        }

        // Execute a feed hold with deceleration, if required. Then, suspend system.
        if (rt_exec & EXEC_FEED_HOLD) {
    2adc:	c3 ff       	sbrs	r28, 3
    2ade:	05 c0       	rjmp	.+10     	; 0x2aea <protocol_exec_rt_system+0xca>
          // Block SAFETY_DOOR, JOG, and SLEEP states from changing to HOLD state.
          if (!(sys.state & (STATE_SAFETY_DOOR | STATE_JOG | STATE_SLEEP))) { sys.state = STATE_HOLD; }
    2ae0:	80 7e       	andi	r24, 0xE0	; 224
    2ae2:	19 f4       	brne	.+6      	; 0x2aea <protocol_exec_rt_system+0xca>
    2ae4:	80 e1       	ldi	r24, 0x10	; 16
    2ae6:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
        }

        // Execute a safety door stop with a feed hold and disable spindle/coolant.
        // NOTE: Safety door differs from feed holds by stopping everything no matter state, disables powered
        // devices (spindle/coolant), and blocks resuming until switch is re-engaged.
        if (rt_exec & EXEC_SAFETY_DOOR) {
    2aea:	c5 ff       	sbrs	r28, 5
    2aec:	1c c0       	rjmp	.+56     	; 0x2b26 <protocol_exec_rt_system+0x106>
          report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR);
    2aee:	86 e0       	ldi	r24, 0x06	; 6
    2af0:	0e 94 ab 35 	call	0x6b56	; 0x6b56 <report_feedback_message>
          // If jogging, block safety door methods until jog cancel is complete. Just flag that it happened.
          if (!(sys.suspend & SUSPEND_JOG_CANCEL)) {
    2af4:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2af8:	88 23       	and	r24, r24
    2afa:	84 f0       	brlt	.+32     	; 0x2b1c <protocol_exec_rt_system+0xfc>
            // Check if the safety re-opened during a restore parking motion only. Ignore if
            // already retracting, parked or in sleep state.
            if (sys.state == STATE_SAFETY_DOOR) {
    2afc:	90 91 1e 0c 	lds	r25, 0x0C1E	; 0x800c1e <sys>
    2b00:	90 34       	cpi	r25, 0x40	; 64
    2b02:	39 f4       	brne	.+14     	; 0x2b12 <protocol_exec_rt_system+0xf2>
              if (sys.suspend & SUSPEND_INITIATE_RESTORE) { // Actively restoring
    2b04:	83 ff       	sbrs	r24, 3
    2b06:	07 c0       	rjmp	.+14     	; 0x2b16 <protocol_exec_rt_system+0xf6>
                    sys.step_control = (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION);
                    sys.suspend &= ~(SUSPEND_HOLD_COMPLETE);
                  } // else NO_MOTION is active.
                #endif
                sys.suspend &= ~(SUSPEND_RETRACT_COMPLETE | SUSPEND_INITIATE_RESTORE | SUSPEND_RESTORE_COMPLETE);
                sys.suspend |= SUSPEND_RESTART_RETRACT;
    2b08:	83 7e       	andi	r24, 0xE3	; 227
    2b0a:	82 60       	ori	r24, 0x02	; 2
    2b0c:	80 93 20 0c 	sts	0x0C20, r24	; 0x800c20 <sys+0x2>
    2b10:	02 c0       	rjmp	.+4      	; 0x2b16 <protocol_exec_rt_system+0xf6>
              }
            }
            if (sys.state != STATE_SLEEP) { sys.state = STATE_SAFETY_DOOR; }
    2b12:	90 38       	cpi	r25, 0x80	; 128
    2b14:	19 f0       	breq	.+6      	; 0x2b1c <protocol_exec_rt_system+0xfc>
    2b16:	80 e4       	ldi	r24, 0x40	; 64
    2b18:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
          }
          // NOTE: This flag doesn't change when the door closes, unlike sys.state. Ensures any parking motions
          // are executed if the door switch closes and the state returns to HOLD.
          sys.suspend |= SUSPEND_SAFETY_DOOR_AJAR;
    2b1c:	ee e1       	ldi	r30, 0x1E	; 30
    2b1e:	fc e0       	ldi	r31, 0x0C	; 12
    2b20:	82 81       	ldd	r24, Z+2	; 0x02
    2b22:	80 62       	ori	r24, 0x20	; 32
    2b24:	82 83       	std	Z+2, r24	; 0x02
        }
        
      }

      if (rt_exec & EXEC_SLEEP) {
    2b26:	cc 23       	and	r28, r28
    2b28:	64 f4       	brge	.+24     	; 0x2b42 <protocol_exec_rt_system+0x122>
        if (sys.state == STATE_ALARM) { sys.suspend |= (SUSPEND_RETRACT_COMPLETE|SUSPEND_HOLD_COMPLETE); }
    2b2a:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2b2e:	81 30       	cpi	r24, 0x01	; 1
    2b30:	29 f4       	brne	.+10     	; 0x2b3c <protocol_exec_rt_system+0x11c>
    2b32:	ee e1       	ldi	r30, 0x1E	; 30
    2b34:	fc e0       	ldi	r31, 0x0C	; 12
    2b36:	82 81       	ldd	r24, Z+2	; 0x02
    2b38:	85 60       	ori	r24, 0x05	; 5
    2b3a:	82 83       	std	Z+2, r24	; 0x02
        sys.state = STATE_SLEEP; 
    2b3c:	80 e8       	ldi	r24, 0x80	; 128
    2b3e:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
      }

      system_clear_exec_state_flag((EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR | EXEC_SLEEP));
    2b42:	88 ee       	ldi	r24, 0xE8	; 232
    2b44:	0e 94 f3 3d 	call	0x7be6	; 0x7be6 <system_clear_exec_state_flag>
    }

    // Execute a cycle start by starting the stepper interrupt to begin executing the blocks in queue.
    if (rt_exec & EXEC_CYCLE_START) {
    2b48:	c1 ff       	sbrs	r28, 1
    2b4a:	41 c0       	rjmp	.+130    	; 0x2bce <protocol_exec_rt_system+0x1ae>
      // Block if called at same time as the hold commands: feed hold, motion cancel, and safety door.
      // Ensures auto-cycle-start doesn't resume a hold without an explicit user-input.
      if (!(rt_exec & (EXEC_FEED_HOLD | EXEC_MOTION_CANCEL | EXEC_SAFETY_DOOR))) {
    2b4c:	8c 2f       	mov	r24, r28
    2b4e:	88 76       	andi	r24, 0x68	; 104
    2b50:	d9 f5       	brne	.+118    	; 0x2bc8 <protocol_exec_rt_system+0x1a8>
        // Resume door state when parking motion has retracted and door has been closed.
        if ((sys.state == STATE_SAFETY_DOOR) && !(sys.suspend & SUSPEND_SAFETY_DOOR_AJAR)) {
    2b52:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2b56:	80 34       	cpi	r24, 0x40	; 64
    2b58:	79 f4       	brne	.+30     	; 0x2b78 <protocol_exec_rt_system+0x158>
    2b5a:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2b5e:	85 fd       	sbrc	r24, 5
    2b60:	33 c0       	rjmp	.+102    	; 0x2bc8 <protocol_exec_rt_system+0x1a8>
          if (sys.suspend & SUSPEND_RESTORE_COMPLETE) {
    2b62:	84 ff       	sbrs	r24, 4
    2b64:	03 c0       	rjmp	.+6      	; 0x2b6c <protocol_exec_rt_system+0x14c>
            sys.state = STATE_IDLE; // Set to IDLE to immediately resume the cycle.
    2b66:	10 92 1e 0c 	sts	0x0C1E, r1	; 0x800c1e <sys>
    2b6a:	18 c0       	rjmp	.+48     	; 0x2b9c <protocol_exec_rt_system+0x17c>
          } else if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
    2b6c:	82 ff       	sbrs	r24, 2
    2b6e:	2c c0       	rjmp	.+88     	; 0x2bc8 <protocol_exec_rt_system+0x1a8>
            // Flag to re-energize powered components and restore original position, if disabled by SAFETY_DOOR.
            // NOTE: For a safety door to resume, the switch must be closed, as indicated by HOLD state, and
            // the retraction execution is complete, which implies the initial feed hold is not active. To
            // restore normal operation, the restore procedures must be initiated by the following flag. Once,
            // they are complete, it will call CYCLE_START automatically to resume and exit the suspend.
            sys.suspend |= SUSPEND_INITIATE_RESTORE;
    2b70:	88 60       	ori	r24, 0x08	; 8
    2b72:	80 93 20 0c 	sts	0x0C20, r24	; 0x800c20 <sys+0x2>
    2b76:	28 c0       	rjmp	.+80     	; 0x2bc8 <protocol_exec_rt_system+0x1a8>
          }
        }
        // Cycle start only when IDLE or when a hold is complete and ready to resume.
        if ((sys.state == STATE_IDLE) || ((sys.state & STATE_HOLD) && (sys.suspend & SUSPEND_HOLD_COMPLETE))) {
    2b78:	88 23       	and	r24, r24
    2b7a:	81 f0       	breq	.+32     	; 0x2b9c <protocol_exec_rt_system+0x17c>
    2b7c:	84 ff       	sbrs	r24, 4
    2b7e:	24 c0       	rjmp	.+72     	; 0x2bc8 <protocol_exec_rt_system+0x1a8>
    2b80:	90 91 20 0c 	lds	r25, 0x0C20	; 0x800c20 <sys+0x2>
    2b84:	90 ff       	sbrs	r25, 0
    2b86:	20 c0       	rjmp	.+64     	; 0x2bc8 <protocol_exec_rt_system+0x1a8>
          if (sys.state == STATE_HOLD && sys.spindle_stop_ovr) {
    2b88:	80 31       	cpi	r24, 0x10	; 16
    2b8a:	41 f4       	brne	.+16     	; 0x2b9c <protocol_exec_rt_system+0x17c>
    2b8c:	80 91 28 0c 	lds	r24, 0x0C28	; 0x800c28 <sys+0xa>
    2b90:	88 23       	and	r24, r24
    2b92:	21 f0       	breq	.+8      	; 0x2b9c <protocol_exec_rt_system+0x17c>
            sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE_CYCLE; // Set to restore in suspend routine and cycle start after.
    2b94:	88 60       	ori	r24, 0x08	; 8
    2b96:	80 93 28 0c 	sts	0x0C28, r24	; 0x800c28 <sys+0xa>
    2b9a:	16 c0       	rjmp	.+44     	; 0x2bc8 <protocol_exec_rt_system+0x1a8>
          } else {
            // Start cycle only if queued motions exist in planner buffer and the motion is not canceled.
            sys.step_control = STEP_CONTROL_NORMAL_OP; // Restore step control to normal operation
    2b9c:	10 92 22 0c 	sts	0x0C22, r1	; 0x800c22 <sys+0x4>
            if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
    2ba0:	0e 94 5b 29 	call	0x52b6	; 0x52b6 <plan_get_current_block>
    2ba4:	89 2b       	or	r24, r25
    2ba6:	61 f0       	breq	.+24     	; 0x2bc0 <protocol_exec_rt_system+0x1a0>
    2ba8:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2bac:	86 fd       	sbrc	r24, 6
    2bae:	08 c0       	rjmp	.+16     	; 0x2bc0 <protocol_exec_rt_system+0x1a0>
              sys.suspend = SUSPEND_DISABLE; // Break suspend state.
    2bb0:	ee e1       	ldi	r30, 0x1E	; 30
    2bb2:	fc e0       	ldi	r31, 0x0C	; 12
    2bb4:	12 82       	std	Z+2, r1	; 0x02
              sys.state = STATE_CYCLE;
    2bb6:	88 e0       	ldi	r24, 0x08	; 8
              st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
    2bb8:	80 83       	st	Z, r24
              st_wake_up();
    2bba:	44 d6       	rcall	.+3208   	; 0x3844 <st_prep_buffer>
    2bbc:	36 d3       	rcall	.+1644   	; 0x322a <st_wake_up>
    2bbe:	04 c0       	rjmp	.+8      	; 0x2bc8 <protocol_exec_rt_system+0x1a8>
            } else { // Otherwise, do nothing. Set and resume IDLE state.
              sys.suspend = SUSPEND_DISABLE; // Break suspend state.
    2bc0:	ee e1       	ldi	r30, 0x1E	; 30
    2bc2:	fc e0       	ldi	r31, 0x0C	; 12
    2bc4:	12 82       	std	Z+2, r1	; 0x02
              sys.state = STATE_IDLE;
    2bc6:	10 82       	st	Z, r1
            }
          }
        }
      }
      system_clear_exec_state_flag(EXEC_CYCLE_START);
    2bc8:	82 e0       	ldi	r24, 0x02	; 2
    2bca:	0e 94 f3 3d 	call	0x7be6	; 0x7be6 <system_clear_exec_state_flag>
    }

    if (rt_exec & EXEC_CYCLE_STOP) {
    2bce:	c2 ff       	sbrs	r28, 2
    2bd0:	3b c0       	rjmp	.+118    	; 0x2c48 <protocol_exec_rt_system+0x228>
      // Reinitializes the cycle plan and stepper system after a feed hold for a resume. Called by
      // realtime command execution in the main program, ensuring that the planner re-plans safely.
      // NOTE: Bresenham algorithm variables are still maintained through both the planner and stepper
      // cycle reinitializations. The stepper path should continue exactly as if nothing has happened.
      // NOTE: EXEC_CYCLE_STOP is set by the stepper subsystem when a cycle or feed hold completes.
      if ((sys.state & (STATE_HOLD|STATE_SAFETY_DOOR|STATE_SLEEP)) && !(sys.soft_limit) && !(sys.suspend & SUSPEND_JOG_CANCEL)) {
    2bd2:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2bd6:	80 7d       	andi	r24, 0xD0	; 208
    2bd8:	b9 f0       	breq	.+46     	; 0x2c08 <protocol_exec_rt_system+0x1e8>
    2bda:	80 91 21 0c 	lds	r24, 0x0C21	; 0x800c21 <sys+0x3>
    2bde:	81 11       	cpse	r24, r1
    2be0:	13 c0       	rjmp	.+38     	; 0x2c08 <protocol_exec_rt_system+0x1e8>
    2be2:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2be6:	88 23       	and	r24, r24
    2be8:	9c f0       	brlt	.+38     	; 0x2c10 <protocol_exec_rt_system+0x1f0>
        // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until user
        // has issued a resume command or reset.
        plan_cycle_reinitialize();
    2bea:	0e 94 fb 2d 	call	0x5bf6	; 0x5bf6 <plan_cycle_reinitialize>
        if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { sys.suspend |= SUSPEND_HOLD_COMPLETE; }
    2bee:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    2bf2:	81 ff       	sbrs	r24, 1
    2bf4:	05 c0       	rjmp	.+10     	; 0x2c00 <protocol_exec_rt_system+0x1e0>
    2bf6:	ee e1       	ldi	r30, 0x1E	; 30
    2bf8:	fc e0       	ldi	r31, 0x0C	; 12
    2bfa:	92 81       	ldd	r25, Z+2	; 0x02
    2bfc:	91 60       	ori	r25, 0x01	; 1
    2bfe:	92 83       	std	Z+2, r25	; 0x02
        bit_false(sys.step_control,(STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION));
    2c00:	89 7f       	andi	r24, 0xF9	; 249
    2c02:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <sys+0x4>
    2c06:	1d c0       	rjmp	.+58     	; 0x2c42 <protocol_exec_rt_system+0x222>
      } else {
        // Motion complete. Includes CYCLE/JOG/HOMING states and jog cancel/motion cancel/soft limit events.
        // NOTE: Motion and jog cancel both immediately return to idle after the hold completes.
        if (sys.suspend & SUSPEND_JOG_CANCEL) {   // For jog cancel, flush buffers and sync positions.
    2c08:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2c0c:	88 23       	and	r24, r24
    2c0e:	4c f4       	brge	.+18     	; 0x2c22 <protocol_exec_rt_system+0x202>
          sys.step_control = STEP_CONTROL_NORMAL_OP;
    2c10:	10 92 22 0c 	sts	0x0C22, r1	; 0x800c22 <sys+0x4>
          plan_reset();
    2c14:	0e 94 35 29 	call	0x526a	; 0x526a <plan_reset>
          st_reset();
    2c18:	a2 d5       	rcall	.+2884   	; 0x375e <st_reset>
          gc_sync_position();
    2c1a:	0e 94 60 07 	call	0xec0	; 0xec0 <gc_sync_position>
          plan_sync_position();
    2c1e:	0e 94 dd 2d 	call	0x5bba	; 0x5bba <plan_sync_position>
        }
        if (sys.suspend & SUSPEND_SAFETY_DOOR_AJAR) { // Only occurs when safety door opens during jog.
    2c22:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2c26:	85 ff       	sbrs	r24, 5
    2c28:	08 c0       	rjmp	.+16     	; 0x2c3a <protocol_exec_rt_system+0x21a>
          sys.suspend &= ~(SUSPEND_JOG_CANCEL);
          sys.suspend |= SUSPEND_HOLD_COMPLETE;
    2c2a:	ee e1       	ldi	r30, 0x1E	; 30
    2c2c:	fc e0       	ldi	r31, 0x0C	; 12
    2c2e:	8f 77       	andi	r24, 0x7F	; 127
    2c30:	81 60       	ori	r24, 0x01	; 1
    2c32:	82 83       	std	Z+2, r24	; 0x02
          sys.state = STATE_SAFETY_DOOR;
    2c34:	80 e4       	ldi	r24, 0x40	; 64
    2c36:	80 83       	st	Z, r24
    2c38:	04 c0       	rjmp	.+8      	; 0x2c42 <protocol_exec_rt_system+0x222>
        } else {
          sys.suspend = SUSPEND_DISABLE;
    2c3a:	ee e1       	ldi	r30, 0x1E	; 30
    2c3c:	fc e0       	ldi	r31, 0x0C	; 12
    2c3e:	12 82       	std	Z+2, r1	; 0x02
          sys.state = STATE_IDLE;
    2c40:	10 82       	st	Z, r1
        }
      }
      system_clear_exec_state_flag(EXEC_CYCLE_STOP);
    2c42:	84 e0       	ldi	r24, 0x04	; 4
    2c44:	0e 94 f3 3d 	call	0x7be6	; 0x7be6 <system_clear_exec_state_flag>
    }
  }

  // Execute overrides.
  rt_exec = sys_rt_exec_motion_override; // Copy volatile sys_rt_exec_motion_override
    2c48:	c0 91 19 0c 	lds	r28, 0x0C19	; 0x800c19 <sys_rt_exec_motion_override>
  if (rt_exec) {
    2c4c:	cc 23       	and	r28, r28
    2c4e:	81 f1       	breq	.+96     	; 0x2cb0 <protocol_exec_rt_system+0x290>
    system_clear_exec_motion_overrides(); // Clear all motion override flags.
    2c50:	0e 94 1b 3e 	call	0x7c36	; 0x7c36 <system_clear_exec_motion_overrides>

    uint8_t new_f_override =  sys.f_override;
    2c54:	20 91 25 0c 	lds	r18, 0x0C25	; 0x800c25 <sys+0x7>
    if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
    2c58:	c0 ff       	sbrs	r28, 0
    2c5a:	02 c0       	rjmp	.+4      	; 0x2c60 <protocol_exec_rt_system+0x240>
    2c5c:	84 e6       	ldi	r24, 0x64	; 100
    2c5e:	01 c0       	rjmp	.+2      	; 0x2c62 <protocol_exec_rt_system+0x242>
  // Execute overrides.
  rt_exec = sys_rt_exec_motion_override; // Copy volatile sys_rt_exec_motion_override
  if (rt_exec) {
    system_clear_exec_motion_overrides(); // Clear all motion override flags.

    uint8_t new_f_override =  sys.f_override;
    2c60:	82 2f       	mov	r24, r18
    if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
    if (rt_exec & EXEC_FEED_OVR_COARSE_PLUS) { new_f_override += FEED_OVERRIDE_COARSE_INCREMENT; }
    2c62:	c1 fd       	sbrc	r28, 1
    2c64:	86 5f       	subi	r24, 0xF6	; 246
    if (rt_exec & EXEC_FEED_OVR_COARSE_MINUS) { new_f_override -= FEED_OVERRIDE_COARSE_INCREMENT; }
    2c66:	c2 fd       	sbrc	r28, 2
    2c68:	8a 50       	subi	r24, 0x0A	; 10
    if (rt_exec & EXEC_FEED_OVR_FINE_PLUS) { new_f_override += FEED_OVERRIDE_FINE_INCREMENT; }
    2c6a:	c3 fd       	sbrc	r28, 3
    2c6c:	8f 5f       	subi	r24, 0xFF	; 255
    if (rt_exec & EXEC_FEED_OVR_FINE_MINUS) { new_f_override -= FEED_OVERRIDE_FINE_INCREMENT; }
    2c6e:	c4 fd       	sbrc	r28, 4
    2c70:	81 50       	subi	r24, 0x01	; 1
    new_f_override = min(new_f_override,MAX_FEED_RATE_OVERRIDE);
    2c72:	89 3c       	cpi	r24, 0xC9	; 201
    2c74:	08 f0       	brcs	.+2      	; 0x2c78 <protocol_exec_rt_system+0x258>
    2c76:	88 ec       	ldi	r24, 0xC8	; 200
    new_f_override = max(new_f_override,MIN_FEED_RATE_OVERRIDE);
    2c78:	8a 30       	cpi	r24, 0x0A	; 10
    2c7a:	08 f4       	brcc	.+2      	; 0x2c7e <protocol_exec_rt_system+0x25e>
    2c7c:	8a e0       	ldi	r24, 0x0A	; 10

    uint8_t new_r_override = sys.r_override;
    2c7e:	30 91 26 0c 	lds	r19, 0x0C26	; 0x800c26 <sys+0x8>
    if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
    2c82:	c5 ff       	sbrs	r28, 5
    2c84:	02 c0       	rjmp	.+4      	; 0x2c8a <protocol_exec_rt_system+0x26a>
    2c86:	94 e6       	ldi	r25, 0x64	; 100
    2c88:	01 c0       	rjmp	.+2      	; 0x2c8c <protocol_exec_rt_system+0x26c>
    if (rt_exec & EXEC_FEED_OVR_FINE_PLUS) { new_f_override += FEED_OVERRIDE_FINE_INCREMENT; }
    if (rt_exec & EXEC_FEED_OVR_FINE_MINUS) { new_f_override -= FEED_OVERRIDE_FINE_INCREMENT; }
    new_f_override = min(new_f_override,MAX_FEED_RATE_OVERRIDE);
    new_f_override = max(new_f_override,MIN_FEED_RATE_OVERRIDE);

    uint8_t new_r_override = sys.r_override;
    2c8a:	93 2f       	mov	r25, r19
    if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
    if (rt_exec & EXEC_RAPID_OVR_MEDIUM) { new_r_override = RAPID_OVERRIDE_MEDIUM; }
    2c8c:	c6 fd       	sbrc	r28, 6
    2c8e:	92 e3       	ldi	r25, 0x32	; 50
    if (rt_exec & EXEC_RAPID_OVR_LOW) { new_r_override = RAPID_OVERRIDE_LOW; }
    2c90:	cc 23       	and	r28, r28
    2c92:	0c f4       	brge	.+2      	; 0x2c96 <protocol_exec_rt_system+0x276>
    2c94:	99 e1       	ldi	r25, 0x19	; 25

    if ((new_f_override != sys.f_override) || (new_r_override != sys.r_override)) {
    2c96:	28 13       	cpse	r18, r24
    2c98:	02 c0       	rjmp	.+4      	; 0x2c9e <protocol_exec_rt_system+0x27e>
    2c9a:	93 17       	cp	r25, r19
    2c9c:	49 f0       	breq	.+18     	; 0x2cb0 <protocol_exec_rt_system+0x290>
      sys.f_override = new_f_override;
    2c9e:	ee e1       	ldi	r30, 0x1E	; 30
    2ca0:	fc e0       	ldi	r31, 0x0C	; 12
    2ca2:	87 83       	std	Z+7, r24	; 0x07
      sys.r_override = new_r_override;
    2ca4:	90 87       	std	Z+8, r25	; 0x08
      sys.report_ovr_counter = 0; // Set to report change immediately
    2ca6:	13 86       	std	Z+11, r1	; 0x0b
      plan_update_velocity_profile_parameters();
    2ca8:	0e 94 09 2a 	call	0x5412	; 0x5412 <plan_update_velocity_profile_parameters>
      plan_cycle_reinitialize();
    2cac:	0e 94 fb 2d 	call	0x5bf6	; 0x5bf6 <plan_cycle_reinitialize>
    }
  }

  rt_exec = sys_rt_exec_accessory_override;
    2cb0:	c0 91 30 0c 	lds	r28, 0x0C30	; 0x800c30 <sys_rt_exec_accessory_override>
  if (rt_exec) {
    2cb4:	cc 23       	and	r28, r28
    2cb6:	09 f4       	brne	.+2      	; 0x2cba <protocol_exec_rt_system+0x29a>
    2cb8:	60 c0       	rjmp	.+192    	; 0x2d7a <protocol_exec_rt_system+0x35a>
    system_clear_exec_accessory_overrides(); // Clear all accessory override flags.
    2cba:	0e 94 21 3e 	call	0x7c42	; 0x7c42 <system_clear_exec_accessory_overrides>

    // NOTE: Unlike motion overrides, spindle overrides do not require a planner reinitialization.
    uint8_t last_s_override =  sys.spindle_speed_ovr;
    2cbe:	90 91 27 0c 	lds	r25, 0x0C27	; 0x800c27 <sys+0x9>
    if (rt_exec & EXEC_SPINDLE_OVR_RESET) { last_s_override = DEFAULT_SPINDLE_SPEED_OVERRIDE; }
    2cc2:	c0 ff       	sbrs	r28, 0
    2cc4:	02 c0       	rjmp	.+4      	; 0x2cca <protocol_exec_rt_system+0x2aa>
    2cc6:	84 e6       	ldi	r24, 0x64	; 100
    2cc8:	01 c0       	rjmp	.+2      	; 0x2ccc <protocol_exec_rt_system+0x2ac>
  rt_exec = sys_rt_exec_accessory_override;
  if (rt_exec) {
    system_clear_exec_accessory_overrides(); // Clear all accessory override flags.

    // NOTE: Unlike motion overrides, spindle overrides do not require a planner reinitialization.
    uint8_t last_s_override =  sys.spindle_speed_ovr;
    2cca:	89 2f       	mov	r24, r25
    if (rt_exec & EXEC_SPINDLE_OVR_RESET) { last_s_override = DEFAULT_SPINDLE_SPEED_OVERRIDE; }
    if (rt_exec & EXEC_SPINDLE_OVR_COARSE_PLUS) { last_s_override += SPINDLE_OVERRIDE_COARSE_INCREMENT; }
    2ccc:	c1 fd       	sbrc	r28, 1
    2cce:	86 5f       	subi	r24, 0xF6	; 246
    if (rt_exec & EXEC_SPINDLE_OVR_COARSE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_COARSE_INCREMENT; }
    2cd0:	c2 fd       	sbrc	r28, 2
    2cd2:	8a 50       	subi	r24, 0x0A	; 10
    if (rt_exec & EXEC_SPINDLE_OVR_FINE_PLUS) { last_s_override += SPINDLE_OVERRIDE_FINE_INCREMENT; }
    2cd4:	c3 fd       	sbrc	r28, 3
    2cd6:	8f 5f       	subi	r24, 0xFF	; 255
    if (rt_exec & EXEC_SPINDLE_OVR_FINE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_FINE_INCREMENT; }
    2cd8:	c4 fd       	sbrc	r28, 4
    2cda:	81 50       	subi	r24, 0x01	; 1
    last_s_override = min(last_s_override,MAX_SPINDLE_SPEED_OVERRIDE);
    2cdc:	89 3c       	cpi	r24, 0xC9	; 201
    2cde:	08 f0       	brcs	.+2      	; 0x2ce2 <protocol_exec_rt_system+0x2c2>
    2ce0:	88 ec       	ldi	r24, 0xC8	; 200
    last_s_override = max(last_s_override,MIN_SPINDLE_SPEED_OVERRIDE);
    2ce2:	8a 30       	cpi	r24, 0x0A	; 10
    2ce4:	08 f4       	brcc	.+2      	; 0x2ce8 <protocol_exec_rt_system+0x2c8>
    2ce6:	8a e0       	ldi	r24, 0x0A	; 10

    if (last_s_override != sys.spindle_speed_ovr) {
    2ce8:	98 17       	cp	r25, r24
    2cea:	b1 f0       	breq	.+44     	; 0x2d18 <protocol_exec_rt_system+0x2f8>
      sys.spindle_speed_ovr = last_s_override;
    2cec:	ee e1       	ldi	r30, 0x1E	; 30
    2cee:	fc e0       	ldi	r31, 0x0C	; 12
    2cf0:	81 87       	std	Z+9, r24	; 0x09
      // NOTE: Spindle speed overrides during HOLD state are taken care of by suspend function.
      if (sys.state == STATE_IDLE) { spindle_set_state(gc_state.modal.spindle, gc_state.spindle_speed); }
    2cf2:	80 81       	ld	r24, Z
    2cf4:	81 11       	cpse	r24, r1
    2cf6:	09 c0       	rjmp	.+18     	; 0x2d0a <protocol_exec_rt_system+0x2ea>
    2cf8:	e6 e5       	ldi	r30, 0x56	; 86
    2cfa:	fc e0       	ldi	r31, 0x0C	; 12
    2cfc:	43 85       	ldd	r20, Z+11	; 0x0b
    2cfe:	54 85       	ldd	r21, Z+12	; 0x0c
    2d00:	65 85       	ldd	r22, Z+13	; 0x0d
    2d02:	76 85       	ldd	r23, Z+14	; 0x0e
    2d04:	81 85       	ldd	r24, Z+9	; 0x09
    2d06:	ca dc       	rcall	.-1644   	; 0x269c <spindle_set_state>
    2d08:	05 c0       	rjmp	.+10     	; 0x2d14 <protocol_exec_rt_system+0x2f4>
			else { bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM); }
    2d0a:	ee e1       	ldi	r30, 0x1E	; 30
    2d0c:	fc e0       	ldi	r31, 0x0C	; 12
    2d0e:	84 81       	ldd	r24, Z+4	; 0x04
    2d10:	88 60       	ori	r24, 0x08	; 8
    2d12:	84 83       	std	Z+4, r24	; 0x04
      sys.report_ovr_counter = 0; // Set to report change immediately
    2d14:	10 92 29 0c 	sts	0x0C29, r1	; 0x800c29 <sys+0xb>
    }

    if (rt_exec & EXEC_SPINDLE_OVR_STOP) {
    2d18:	c5 ff       	sbrs	r28, 5
    2d1a:	12 c0       	rjmp	.+36     	; 0x2d40 <protocol_exec_rt_system+0x320>
      // Spindle stop override allowed only while in HOLD state.
      // NOTE: Report counters are set in spindle_set_state() when spindle stop is executed.
      if (sys.state == STATE_HOLD) {
    2d1c:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2d20:	80 31       	cpi	r24, 0x10	; 16
    2d22:	71 f4       	brne	.+28     	; 0x2d40 <protocol_exec_rt_system+0x320>
        if (!(sys.spindle_stop_ovr)) { sys.spindle_stop_ovr = SPINDLE_STOP_OVR_INITIATE; }
    2d24:	80 91 28 0c 	lds	r24, 0x0C28	; 0x800c28 <sys+0xa>
    2d28:	81 11       	cpse	r24, r1
    2d2a:	04 c0       	rjmp	.+8      	; 0x2d34 <protocol_exec_rt_system+0x314>
    2d2c:	82 e0       	ldi	r24, 0x02	; 2
    2d2e:	80 93 28 0c 	sts	0x0C28, r24	; 0x800c28 <sys+0xa>
    2d32:	95 c0       	rjmp	.+298    	; 0x2e5e <protocol_exec_rt_system+0x43e>
        else if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_ENABLED) { sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE; }
    2d34:	80 ff       	sbrs	r24, 0
    2d36:	93 c0       	rjmp	.+294    	; 0x2e5e <protocol_exec_rt_system+0x43e>
    2d38:	84 60       	ori	r24, 0x04	; 4
    2d3a:	80 93 28 0c 	sts	0x0C28, r24	; 0x800c28 <sys+0xa>
    2d3e:	8f c0       	rjmp	.+286    	; 0x2e5e <protocol_exec_rt_system+0x43e>
    }

    // NOTE: Since coolant state always performs a planner sync whenever it changes, the current
    // run state can be determined by checking the parser state.
    // NOTE: Coolant overrides only operate during IDLE, CYCLE, HOLD, and JOG states. Ignored otherwise.																										
    if (rt_exec & (EXEC_COOLANT_FLOOD_OVR_TOGGLE | EXEC_COOLANT_MIST_OVR_TOGGLE)) {
    2d40:	8c 2f       	mov	r24, r28
    2d42:	80 7c       	andi	r24, 0xC0	; 192
    2d44:	d1 f0       	breq	.+52     	; 0x2d7a <protocol_exec_rt_system+0x35a>
      if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_JOG))) {
    2d46:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2d4a:	88 23       	and	r24, r24
    2d4c:	11 f0       	breq	.+4      	; 0x2d52 <protocol_exec_rt_system+0x332>
    2d4e:	88 73       	andi	r24, 0x38	; 56
    2d50:	a1 f0       	breq	.+40     	; 0x2d7a <protocol_exec_rt_system+0x35a>
        uint8_t coolant_state = gc_state.modal.coolant;
    2d52:	d0 91 5e 0c 	lds	r29, 0x0C5E	; 0x800c5e <gc_state+0x8>
        if (rt_exec & EXEC_COOLANT_MIST_OVR_TOGGLE) {
    2d56:	cc 23       	and	r28, r28
    2d58:	2c f4       	brge	.+10     	; 0x2d64 <protocol_exec_rt_system+0x344>
          if (coolant_state & COOLANT_MIST_ENABLE) { bit_false(coolant_state,COOLANT_MIST_ENABLE); }
    2d5a:	dd 23       	and	r29, r29
    2d5c:	14 f4       	brge	.+4      	; 0x2d62 <protocol_exec_rt_system+0x342>
    2d5e:	df 77       	andi	r29, 0x7F	; 127
    2d60:	01 c0       	rjmp	.+2      	; 0x2d64 <protocol_exec_rt_system+0x344>
          else { coolant_state |= COOLANT_MIST_ENABLE; }
    2d62:	d0 68       	ori	r29, 0x80	; 128
        }
        if (rt_exec & EXEC_COOLANT_FLOOD_OVR_TOGGLE) {
    2d64:	c6 ff       	sbrs	r28, 6
    2d66:	05 c0       	rjmp	.+10     	; 0x2d72 <protocol_exec_rt_system+0x352>
          if (coolant_state & COOLANT_FLOOD_ENABLE) { bit_false(coolant_state,COOLANT_FLOOD_ENABLE); }
    2d68:	d6 ff       	sbrs	r29, 6
    2d6a:	02 c0       	rjmp	.+4      	; 0x2d70 <protocol_exec_rt_system+0x350>
    2d6c:	df 7b       	andi	r29, 0xBF	; 191
          else { coolant_state |= COOLANT_FLOOD_ENABLE; }
    2d6e:	01 c0       	rjmp	.+2      	; 0x2d72 <protocol_exec_rt_system+0x352>
        }
        coolant_set_state(coolant_state); // Report counter set in coolant_set_state().
    2d70:	d0 64       	ori	r29, 0x40	; 64
    2d72:	8d 2f       	mov	r24, r29
    2d74:	f3 dc       	rcall	.-1562   	; 0x275c <coolant_set_state>
        gc_state.modal.coolant = coolant_state;
    2d76:	d0 93 5e 0c 	sts	0x0C5E, r29	; 0x800c5e <gc_state+0x8>
      }
    }
  }
  #ifdef LATHE		
  //processing spindle pulse and spindle synchronization pulse
   rt_exec = sys_sync_state;	//save the volatile value
    2d7a:	80 91 14 0c 	lds	r24, 0x0C14	; 0x800c14 <sys_sync_state>
   if (bit_istrue(rt_exec,EXEC_SPINDLE_SYNC)){
    2d7e:	81 ff       	sbrs	r24, 1
    2d80:	19 c0       	rjmp	.+50     	; 0x2db4 <protocol_exec_rt_system+0x394>
	   sys_synchronization_pulse_count++;
    2d82:	40 91 15 0c 	lds	r20, 0x0C15	; 0x800c15 <sys_synchronization_pulse_count>
    2d86:	50 91 16 0c 	lds	r21, 0x0C16	; 0x800c16 <sys_synchronization_pulse_count+0x1>
    2d8a:	60 91 17 0c 	lds	r22, 0x0C17	; 0x800c17 <sys_synchronization_pulse_count+0x2>
    2d8e:	70 91 18 0c 	lds	r23, 0x0C18	; 0x800c18 <sys_synchronization_pulse_count+0x3>
    2d92:	4f 5f       	subi	r20, 0xFF	; 255
    2d94:	5f 4f       	sbci	r21, 0xFF	; 255
    2d96:	6f 4f       	sbci	r22, 0xFF	; 255
    2d98:	7f 4f       	sbci	r23, 0xFF	; 255
    2d9a:	40 93 15 0c 	sts	0x0C15, r20	; 0x800c15 <sys_synchronization_pulse_count>
    2d9e:	50 93 16 0c 	sts	0x0C16, r21	; 0x800c16 <sys_synchronization_pulse_count+0x1>
    2da2:	60 93 17 0c 	sts	0x0C17, r22	; 0x800c17 <sys_synchronization_pulse_count+0x2>
    2da6:	70 93 18 0c 	sts	0x0C18, r23	; 0x800c18 <sys_synchronization_pulse_count+0x3>
	   bit_false(sys_sync_state,EXEC_SPINDLE_SYNC);
    2daa:	90 91 14 0c 	lds	r25, 0x0C14	; 0x800c14 <sys_sync_state>
    2dae:	9d 7f       	andi	r25, 0xFD	; 253
    2db0:	90 93 14 0c 	sts	0x0C14, r25	; 0x800c14 <sys_sync_state>
   }
   if (bit_istrue(rt_exec,EXEC_SPINDLE_INDEX)){
    2db4:	80 ff       	sbrs	r24, 0
    2db6:	45 c0       	rjmp	.+138    	; 0x2e42 <protocol_exec_rt_system+0x422>
	   sys_index_pulse_count++;
    2db8:	80 91 55 0c 	lds	r24, 0x0C55	; 0x800c55 <sys_index_pulse_count>
    2dbc:	8f 5f       	subi	r24, 0xFF	; 255
    2dbe:	80 93 55 0c 	sts	0x0C55, r24	; 0x800c55 <sys_index_pulse_count>
	   sys_sync_time=get_timer_ticks();
    2dc2:	0e 94 ef 02 	call	0x5de	; 0x5de <get_timer_ticks>
    2dc6:	60 93 4f 0c 	sts	0x0C4F, r22	; 0x800c4f <sys_sync_time>
    2dca:	70 93 50 0c 	sts	0x0C50, r23	; 0x800c50 <sys_sync_time+0x1>
    2dce:	80 93 51 0c 	sts	0x0C51, r24	; 0x800c51 <sys_sync_time+0x2>
    2dd2:	90 93 52 0c 	sts	0x0C52, r25	; 0x800c52 <sys_sync_time+0x3>
	   sys_sync_time_passed=sys_sync_time-sys_sync_Last_time;
    2dd6:	80 91 4f 0c 	lds	r24, 0x0C4F	; 0x800c4f <sys_sync_time>
    2dda:	90 91 50 0c 	lds	r25, 0x0C50	; 0x800c50 <sys_sync_time+0x1>
    2dde:	a0 91 51 0c 	lds	r26, 0x0C51	; 0x800c51 <sys_sync_time+0x2>
    2de2:	b0 91 52 0c 	lds	r27, 0x0C52	; 0x800c52 <sys_sync_time+0x3>
    2de6:	40 91 33 0c 	lds	r20, 0x0C33	; 0x800c33 <sys_sync_Last_time>
    2dea:	50 91 34 0c 	lds	r21, 0x0C34	; 0x800c34 <sys_sync_Last_time+0x1>
    2dee:	60 91 35 0c 	lds	r22, 0x0C35	; 0x800c35 <sys_sync_Last_time+0x2>
    2df2:	70 91 36 0c 	lds	r23, 0x0C36	; 0x800c36 <sys_sync_Last_time+0x3>
    2df6:	84 1b       	sub	r24, r20
    2df8:	95 0b       	sbc	r25, r21
    2dfa:	a6 0b       	sbc	r26, r22
    2dfc:	b7 0b       	sbc	r27, r23
    2dfe:	80 93 1a 0c 	sts	0x0C1A, r24	; 0x800c1a <sys_sync_time_passed>
    2e02:	90 93 1b 0c 	sts	0x0C1B, r25	; 0x800c1b <sys_sync_time_passed+0x1>
    2e06:	a0 93 1c 0c 	sts	0x0C1C, r26	; 0x800c1c <sys_sync_time_passed+0x2>
    2e0a:	b0 93 1d 0c 	sts	0x0C1D, r27	; 0x800c1d <sys_sync_time_passed+0x3>
	   sys_sync_Last_time=sys_sync_time;
    2e0e:	80 91 4f 0c 	lds	r24, 0x0C4F	; 0x800c4f <sys_sync_time>
    2e12:	90 91 50 0c 	lds	r25, 0x0C50	; 0x800c50 <sys_sync_time+0x1>
    2e16:	a0 91 51 0c 	lds	r26, 0x0C51	; 0x800c51 <sys_sync_time+0x2>
    2e1a:	b0 91 52 0c 	lds	r27, 0x0C52	; 0x800c52 <sys_sync_time+0x3>
    2e1e:	80 93 33 0c 	sts	0x0C33, r24	; 0x800c33 <sys_sync_Last_time>
    2e22:	90 93 34 0c 	sts	0x0C34, r25	; 0x800c34 <sys_sync_Last_time+0x1>
    2e26:	a0 93 35 0c 	sts	0x0C35, r26	; 0x800c35 <sys_sync_Last_time+0x2>
    2e2a:	b0 93 36 0c 	sts	0x0C36, r27	; 0x800c36 <sys_sync_Last_time+0x3>
		if (bit_istrue(settings.status_report_mask,BITFLAG_REPORT_SYNC_STATE)) {	//report on every index pulse
    2e2e:	80 91 04 0f 	lds	r24, 0x0F04	; 0x800f04 <settings+0x34>
    2e32:	83 fd       	sbrc	r24, 3
			report_synchronization_state();				
    2e34:	0e 94 7b 35 	call	0x6af6	; 0x6af6 <report_synchronization_state>
		}	
	   bit_false(sys_sync_state,EXEC_SPINDLE_INDEX);
    2e38:	80 91 14 0c 	lds	r24, 0x0C14	; 0x800c14 <sys_sync_state>
    2e3c:	8e 7f       	andi	r24, 0xFE	; 254
    2e3e:	80 93 14 0c 	sts	0x0C14, r24	; 0x800c14 <sys_sync_state>
   }   
  #endif
  
  #ifdef DEBUG
    if (sys_rt_exec_debug) {
    2e42:	80 91 54 0c 	lds	r24, 0x0C54	; 0x800c54 <sys_rt_exec_debug>
    2e46:	88 23       	and	r24, r24
    2e48:	21 f0       	breq	.+8      	; 0x2e52 <protocol_exec_rt_system+0x432>
      report_realtime_debug();
    2e4a:	0e 94 59 3a 	call	0x74b2	; 0x74b2 <report_realtime_debug>
      sys_rt_exec_debug = 0;
    2e4e:	10 92 54 0c 	sts	0x0C54, r1	; 0x800c54 <sys_rt_exec_debug>
    }
  #endif

  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_SAFETY_DOOR | STATE_HOMING | STATE_SLEEP| STATE_JOG)) {
    2e52:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    2e56:	8c 7f       	andi	r24, 0xFC	; 252
    st_prep_buffer();
    2e58:	51 f0       	breq	.+20     	; 0x2e6e <protocol_exec_rt_system+0x44e>
    2e5a:	f4 d4       	rcall	.+2536   	; 0x3844 <st_prep_buffer>
    2e5c:	08 c0       	rjmp	.+16     	; 0x2e6e <protocol_exec_rt_system+0x44e>
    }

    // NOTE: Since coolant state always performs a planner sync whenever it changes, the current
    // run state can be determined by checking the parser state.
    // NOTE: Coolant overrides only operate during IDLE, CYCLE, HOLD, and JOG states. Ignored otherwise.																										
    if (rt_exec & (EXEC_COOLANT_FLOOD_OVR_TOGGLE | EXEC_COOLANT_MIST_OVR_TOGGLE)) {
    2e5e:	8c 2f       	mov	r24, r28
    2e60:	80 7c       	andi	r24, 0xC0	; 192
    2e62:	09 f0       	breq	.+2      	; 0x2e66 <protocol_exec_rt_system+0x446>
    2e64:	76 cf       	rjmp	.-276    	; 0x2d52 <protocol_exec_rt_system+0x332>
    2e66:	89 cf       	rjmp	.-238    	; 0x2d7a <protocol_exec_rt_system+0x35a>
          // will handle and clear multiple planner block motions.
          if (!(sys.state & STATE_JOG)) { sys.suspend |= SUSPEND_MOTION_CANCEL; } // NOTE: State is STATE_CYCLE.
        }

        // Execute a feed hold with deceleration, if required. Then, suspend system.
        if (rt_exec & EXEC_FEED_HOLD) {
    2e68:	c3 fd       	sbrc	r28, 3
    2e6a:	3c ce       	rjmp	.-904    	; 0x2ae4 <protocol_exec_rt_system+0xc4>
    2e6c:	3e ce       	rjmp	.-900    	; 0x2aea <protocol_exec_rt_system+0xca>
  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_SAFETY_DOOR | STATE_HOMING | STATE_SLEEP| STATE_JOG)) {
    st_prep_buffer();
  }

}
    2e6e:	df 91       	pop	r29
    2e70:	cf 91       	pop	r28
    2e72:	08 95       	ret

00002e74 <protocol_execute_realtime>:
// also provides a controlled way to execute certain tasks without having two or more instances of
// the same task, such as the planner recalculating the buffer upon a feedhold or overrides.
// NOTE: The sys_rt_exec_state variable flags are set by any process, step or serial interrupts, pinouts,
// limit switches, or the main program.
void protocol_execute_realtime()
{
    2e74:	7f 92       	push	r7
    2e76:	8f 92       	push	r8
    2e78:	9f 92       	push	r9
    2e7a:	af 92       	push	r10
    2e7c:	bf 92       	push	r11
    2e7e:	cf 92       	push	r12
    2e80:	df 92       	push	r13
    2e82:	ef 92       	push	r14
    2e84:	ff 92       	push	r15
    2e86:	0f 93       	push	r16
    2e88:	1f 93       	push	r17
    2e8a:	cf 93       	push	r28
    2e8c:	df 93       	push	r29
  protocol_exec_rt_system();
    2e8e:	c8 dd       	rcall	.-1136   	; 0x2a20 <protocol_exec_rt_system>
  if (sys.suspend) { protocol_exec_rt_suspend(); }
    2e90:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    2e94:	88 23       	and	r24, r24
    2e96:	09 f4       	brne	.+2      	; 0x2e9a <protocol_execute_realtime+0x26>
    2e98:	f4 c0       	rjmp	.+488    	; 0x3082 <protocol_execute_realtime+0x20e>
    memset(pl_data,0,sizeof(plan_line_data_t));
    pl_data->condition = (PL_COND_FLAG_SYSTEM_MOTION|PL_COND_FLAG_NO_FEED_OVERRIDE);
    pl_data->line_number = PARKING_MOTION_LINE_NUMBER;
  #endif

  plan_block_t *block = plan_get_current_block();
    2e9a:	0e 94 5b 29 	call	0x52b6	; 0x52b6 <plan_get_current_block>
    2e9e:	ec 01       	movw	r28, r24
  uint8_t restore_condition;
  float restore_spindle_speed;
  if (block == NULL) {
    2ea0:	89 2b       	or	r24, r25
    2ea2:	51 f4       	brne	.+20     	; 0x2eb8 <protocol_execute_realtime+0x44>
    restore_condition = (gc_state.modal.spindle | gc_state.modal.coolant);
    2ea4:	e6 e5       	ldi	r30, 0x56	; 86
    2ea6:	fc e0       	ldi	r31, 0x0C	; 12
    2ea8:	d1 84       	ldd	r13, Z+9	; 0x09
    2eaa:	80 85       	ldd	r24, Z+8	; 0x08
    2eac:	d8 2a       	or	r13, r24
    restore_spindle_speed = gc_state.spindle_speed;
    2eae:	83 84       	ldd	r8, Z+11	; 0x0b
    2eb0:	94 84       	ldd	r9, Z+12	; 0x0c
    2eb2:	a5 84       	ldd	r10, Z+13	; 0x0d
    2eb4:	b6 84       	ldd	r11, Z+14	; 0x0e
    2eb6:	0a c0       	rjmp	.+20     	; 0x2ecc <protocol_execute_realtime+0x58>
  } else {
    restore_condition = (block->condition & PL_COND_SPINDLE_MASK) | coolant_get_state();
    2eb8:	89 89       	ldd	r24, Y+17	; 0x11
    2eba:	18 2f       	mov	r17, r24
    2ebc:	10 73       	andi	r17, 0x30	; 48
    2ebe:	2f dc       	rcall	.-1954   	; 0x271e <coolant_get_state>
    2ec0:	d8 2e       	mov	r13, r24
    2ec2:	d1 2a       	or	r13, r17
    restore_spindle_speed = block->spindle_speed;
    2ec4:	8a a8       	ldd	r8, Y+50	; 0x32
    2ec6:	9b a8       	ldd	r9, Y+51	; 0x33
    2ec8:	ac a8       	ldd	r10, Y+52	; 0x34
    2eca:	bd a8       	ldd	r11, Y+53	; 0x35
  }
  #ifdef DISABLE_LASER_DURING_HOLD
    if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) { 
    2ecc:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    2ed0:	81 ff       	sbrs	r24, 1
    2ed2:	03 c0       	rjmp	.+6      	; 0x2eda <protocol_execute_realtime+0x66>
      system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP);
    2ed4:	80 e2       	ldi	r24, 0x20	; 32
    2ed6:	0e 94 12 3e 	call	0x7c24	; 0x7c24 <system_set_exec_accessory_override_flag>
    }
  #endif

  while (sys.suspend) {
    2eda:	90 91 20 0c 	lds	r25, 0x0C20	; 0x800c20 <sys+0x2>
    2ede:	99 23       	and	r25, r25
    2ee0:	09 f4       	brne	.+2      	; 0x2ee4 <protocol_execute_realtime+0x70>
    2ee2:	cf c0       	rjmp	.+414    	; 0x3082 <protocol_execute_realtime+0x20e>

    if (sys.abort) { return; }
    2ee4:	80 91 1f 0c 	lds	r24, 0x0C1F	; 0x800c1f <sys+0x1>
    2ee8:	81 11       	cpse	r24, r1
    2eea:	cb c0       	rjmp	.+406    	; 0x3082 <protocol_execute_realtime+0x20e>
    // Block until initial hold is complete and the machine has stopped motion.
    if (sys.suspend & SUSPEND_HOLD_COMPLETE) {

      // Parking manager. Handles de/re-energizing, switch state checks, and parking motions for 
      // the safety door and sleep states.
      if (sys.state & (STATE_SAFETY_DOOR | STATE_SLEEP)) {
    2eec:	ce e1       	ldi	r28, 0x1E	; 30
    2eee:	dc e0       	ldi	r29, 0x0C	; 12
          }
        } else {
          // Handles spindle state during hold. NOTE: Spindle speed overrides may be altered during hold state.
          // NOTE: STEP_CONTROL_UPDATE_SPINDLE_PWM is automatically reset upon resume in step generator.
          if (bit_istrue(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
            spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    2ef0:	8d 2d       	mov	r24, r13
    2ef2:	80 73       	andi	r24, 0x30	; 48
    2ef4:	c8 2e       	mov	r12, r24
            } else {
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
            }
          // Handles restoring of spindle state
          } else if (sys.spindle_stop_ovr & (SPINDLE_STOP_OVR_RESTORE | SPINDLE_STOP_OVR_RESTORE_CYCLE)) {
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    2ef6:	06 e5       	ldi	r16, 0x56	; 86
    2ef8:	1c e0       	ldi	r17, 0x0C	; 12
              report_feedback_message(MESSAGE_SPINDLE_RESTORE);
              if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    2efa:	0f 2e       	mov	r0, r31
    2efc:	f5 e1       	ldi	r31, 0x15	; 21
    2efe:	ef 2e       	mov	r14, r31
    2f00:	ff e0       	ldi	r31, 0x0F	; 15
    2f02:	ff 2e       	mov	r15, r31
    2f04:	f0 2d       	mov	r31, r0
        if (sys.spindle_stop_ovr) {
          // Handles beginning of spindle stop
          if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_INITIATE) {
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
              spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_ENABLED; // Set stop override state to enabled, if de-energized.
    2f06:	77 24       	eor	r7, r7
    2f08:	73 94       	inc	r7
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
                // NOTE: Laser mode will honor this delay. An exhaust system is often controlled by this pin.
                coolant_set_state((restore_condition & (PL_COND_FLAG_COOLANT_FLOOD | PL_COND_FLAG_COOLANT_MIST)));
    2f0a:	ed 2d       	mov	r30, r13
    2f0c:	e0 7c       	andi	r30, 0xC0	; 192
    2f0e:	de 2e       	mov	r13, r30
    2f10:	03 c0       	rjmp	.+6      	; 0x2f18 <protocol_execute_realtime+0xa4>
    }
  #endif

  while (sys.suspend) {

    if (sys.abort) { return; }
    2f12:	29 81       	ldd	r18, Y+1	; 0x01
    2f14:	21 11       	cpse	r18, r1
    2f16:	b5 c0       	rjmp	.+362    	; 0x3082 <protocol_execute_realtime+0x20e>

    // Block until initial hold is complete and the machine has stopped motion.
    if (sys.suspend & SUSPEND_HOLD_COMPLETE) {
    2f18:	90 ff       	sbrs	r25, 0
    2f1a:	a7 c0       	rjmp	.+334    	; 0x306a <protocol_execute_realtime+0x1f6>

      // Parking manager. Handles de/re-energizing, switch state checks, and parking motions for 
      // the safety door and sleep states.
      if (sys.state & (STATE_SAFETY_DOOR | STATE_SLEEP)) {
    2f1c:	28 81       	ld	r18, Y
    2f1e:	32 2f       	mov	r19, r18
    2f20:	30 7c       	andi	r19, 0xC0	; 192
    2f22:	09 f4       	brne	.+2      	; 0x2f26 <protocol_execute_realtime+0xb2>
    2f24:	69 c0       	rjmp	.+210    	; 0x2ff8 <protocol_execute_realtime+0x184>
      
        // Handles retraction motions and de-energizing.
        if (bit_isfalse(sys.suspend,SUSPEND_RETRACT_COMPLETE)) {
    2f26:	92 fd       	sbrc	r25, 2
    2f28:	0d c0       	rjmp	.+26     	; 0x2f44 <protocol_execute_realtime+0xd0>

          // Ensure any prior spindle stop override is disabled at start of safety door routine.
          sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED;
    2f2a:	1a 86       	std	Y+10, r1	; 0x0a

          #ifndef PARKING_ENABLE

            spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
    2f2c:	40 e0       	ldi	r20, 0x00	; 0
    2f2e:	50 e0       	ldi	r21, 0x00	; 0
    2f30:	ba 01       	movw	r22, r20
    2f32:	80 e0       	ldi	r24, 0x00	; 0
            coolant_set_state(COOLANT_DISABLE);     // De-energize
    2f34:	b3 db       	rcall	.-2202   	; 0x269c <spindle_set_state>
    2f36:	80 e0       	ldi	r24, 0x00	; 0
    2f38:	11 dc       	rcall	.-2014   	; 0x275c <coolant_set_state>
            }

          #endif

          sys.suspend &= ~(SUSPEND_RESTART_RETRACT);
          sys.suspend |= SUSPEND_RETRACT_COMPLETE;
    2f3a:	8a 81       	ldd	r24, Y+2	; 0x02
    2f3c:	8d 7f       	andi	r24, 0xFD	; 253
    2f3e:	84 60       	ori	r24, 0x04	; 4
    2f40:	8a 83       	std	Y+2, r24	; 0x02
    2f42:	93 c0       	rjmp	.+294    	; 0x306a <protocol_execute_realtime+0x1f6>

        } else {

          
          if (sys.state == STATE_SLEEP) {
    2f44:	20 38       	cpi	r18, 0x80	; 128
    2f46:	b1 f4       	brne	.+44     	; 0x2f74 <protocol_execute_realtime+0x100>
            report_feedback_message(MESSAGE_SLEEP_MODE);
    2f48:	8b e0       	ldi	r24, 0x0B	; 11
    2f4a:	0e 94 ab 35 	call	0x6b56	; 0x6b56 <report_feedback_message>
            // Spindle and coolant should already be stopped, but do it again just to be sure.
            spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
    2f4e:	40 e0       	ldi	r20, 0x00	; 0
    2f50:	50 e0       	ldi	r21, 0x00	; 0
    2f52:	ba 01       	movw	r22, r20
            coolant_set_state(COOLANT_DISABLE); // De-energize
    2f54:	80 e0       	ldi	r24, 0x00	; 0
    2f56:	a2 db       	rcall	.-2236   	; 0x269c <spindle_set_state>
    2f58:	80 e0       	ldi	r24, 0x00	; 0
            st_go_idle(); // Disable steppers
    2f5a:	00 dc       	rcall	.-2048   	; 0x275c <coolant_set_state>
            while (!(sys.abort)) { protocol_exec_rt_system(); } // Do nothing until reset.
    2f5c:	7e d1       	rcall	.+764    	; 0x325a <st_go_idle>
    2f5e:	80 91 1f 0c 	lds	r24, 0x0C1F	; 0x800c1f <sys+0x1>
    2f62:	81 11       	cpse	r24, r1
    2f64:	8e c0       	rjmp	.+284    	; 0x3082 <protocol_execute_realtime+0x20e>
    2f66:	ce e1       	ldi	r28, 0x1E	; 30
    2f68:	dc e0       	ldi	r29, 0x0C	; 12
    2f6a:	5a dd       	rcall	.-1356   	; 0x2a20 <protocol_exec_rt_system>
    2f6c:	89 81       	ldd	r24, Y+1	; 0x01
    2f6e:	88 23       	and	r24, r24
    2f70:	e1 f3       	breq	.-8      	; 0x2f6a <protocol_execute_realtime+0xf6>
    2f72:	87 c0       	rjmp	.+270    	; 0x3082 <protocol_execute_realtime+0x20e>
            return; // Abort received. Return to re-initialize.
          }    
          
          // Allows resuming from parking/safety door. Actively checks if safety door is closed and ready to resume.
          if (sys.state == STATE_SAFETY_DOOR) {
    2f74:	20 34       	cpi	r18, 0x40	; 64
    2f76:	39 f4       	brne	.+14     	; 0x2f86 <protocol_execute_realtime+0x112>
            if (!(system_check_safety_door_ajar())) {
    2f78:	0e 94 d2 3a 	call	0x75a4	; 0x75a4 <system_check_safety_door_ajar>
    2f7c:	81 11       	cpse	r24, r1
    2f7e:	03 c0       	rjmp	.+6      	; 0x2f86 <protocol_execute_realtime+0x112>
              sys.suspend &= ~(SUSPEND_SAFETY_DOOR_AJAR); // Reset door ajar flag to denote ready to resume.
    2f80:	8a 81       	ldd	r24, Y+2	; 0x02
    2f82:	8f 7d       	andi	r24, 0xDF	; 223
    2f84:	8a 83       	std	Y+2, r24	; 0x02
            }
          }

          // Handles parking restore and safety door resume.
          if (sys.suspend & SUSPEND_INITIATE_RESTORE) {
    2f86:	8a 81       	ldd	r24, Y+2	; 0x02
    2f88:	83 ff       	sbrs	r24, 3
    2f8a:	6f c0       	rjmp	.+222    	; 0x306a <protocol_execute_realtime+0x1f6>
                }
              }
            #endif

            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    2f8c:	f8 01       	movw	r30, r16
    2f8e:	91 85       	ldd	r25, Z+9	; 0x09
    2f90:	99 23       	and	r25, r25
    2f92:	c9 f0       	breq	.+50     	; 0x2fc6 <protocol_execute_realtime+0x152>
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    2f94:	81 fd       	sbrc	r24, 1
    2f96:	6e c0       	rjmp	.+220    	; 0x3074 <protocol_execute_realtime+0x200>
                if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    2f98:	f7 01       	movw	r30, r14
    2f9a:	80 81       	ld	r24, Z
    2f9c:	81 ff       	sbrs	r24, 1
    2f9e:	08 c0       	rjmp	.+16     	; 0x2fb0 <protocol_execute_realtime+0x13c>
                  // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                  bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    2fa0:	8c 81       	ldd	r24, Y+4	; 0x04
    2fa2:	88 60       	ori	r24, 0x08	; 8
    2fa4:	8c 83       	std	Y+4, r24	; 0x04
                  spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
                  delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
                }
              }
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
    2fa6:	f8 01       	movw	r30, r16
    2fa8:	80 85       	ldd	r24, Z+8	; 0x08
    2faa:	81 11       	cpse	r24, r1
    2fac:	13 c0       	rjmp	.+38     	; 0x2fd4 <protocol_execute_realtime+0x160>
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
                if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
                  // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                  bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
                } else {
                  spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    2fae:	67 c0       	rjmp	.+206    	; 0x307e <protocol_execute_realtime+0x20a>
    2fb0:	b5 01       	movw	r22, r10
    2fb2:	a4 01       	movw	r20, r8
    2fb4:	8c 2d       	mov	r24, r12
    2fb6:	72 db       	rcall	.-2332   	; 0x269c <spindle_set_state>
                  delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
    2fb8:	47 2d       	mov	r20, r7
    2fba:	60 e0       	ldi	r22, 0x00	; 0
    2fbc:	70 e0       	ldi	r23, 0x00	; 0
    2fbe:	80 e8       	ldi	r24, 0x80	; 128
    2fc0:	90 e4       	ldi	r25, 0x40	; 64
    2fc2:	0e 94 c9 2e 	call	0x5d92	; 0x5d92 <delay_sec>
                }
              }
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
    2fc6:	f8 01       	movw	r30, r16
    2fc8:	80 85       	ldd	r24, Z+8	; 0x08
    2fca:	88 23       	and	r24, r24
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    2fcc:	61 f0       	breq	.+24     	; 0x2fe6 <protocol_execute_realtime+0x172>
    2fce:	8a 81       	ldd	r24, Y+2	; 0x02
    2fd0:	81 fd       	sbrc	r24, 1
                // NOTE: Laser mode will honor this delay. An exhaust system is often controlled by this pin.
                coolant_set_state((restore_condition & (PL_COND_FLAG_COOLANT_FLOOD | PL_COND_FLAG_COOLANT_MIST)));
    2fd2:	4b c0       	rjmp	.+150    	; 0x306a <protocol_execute_realtime+0x1f6>
    2fd4:	8d 2d       	mov	r24, r13
    2fd6:	c2 db       	rcall	.-2172   	; 0x275c <coolant_set_state>
                delay_sec(SAFETY_DOOR_COOLANT_DELAY, DELAY_MODE_SYS_SUSPEND);
    2fd8:	47 2d       	mov	r20, r7
    2fda:	60 e0       	ldi	r22, 0x00	; 0
    2fdc:	70 e0       	ldi	r23, 0x00	; 0
    2fde:	80 e8       	ldi	r24, 0x80	; 128
    2fe0:	9f e3       	ldi	r25, 0x3F	; 63
    2fe2:	0e 94 c9 2e 	call	0x5d92	; 0x5d92 <delay_sec>
                  mc_parking_motion(restore_target, pl_data);
                }
              }
            #endif

            if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    2fe6:	8a 81       	ldd	r24, Y+2	; 0x02
    2fe8:	81 fd       	sbrc	r24, 1
    2fea:	3f c0       	rjmp	.+126    	; 0x306a <protocol_execute_realtime+0x1f6>
              sys.suspend |= SUSPEND_RESTORE_COMPLETE;
    2fec:	80 61       	ori	r24, 0x10	; 16
    2fee:	8a 83       	std	Y+2, r24	; 0x02
              system_set_exec_state_flag(EXEC_CYCLE_START); // Set to resume program.
    2ff0:	82 e0       	ldi	r24, 0x02	; 2
    2ff2:	0e 94 95 3b 	call	0x772a	; 0x772a <system_set_exec_state_flag>
    2ff6:	39 c0       	rjmp	.+114    	; 0x306a <protocol_execute_realtime+0x1f6>

      } else {

        // Feed hold manager. Controls spindle stop override states.
        // NOTE: Hold ensured as completed by condition check at the beginning of suspend routine.
        if (sys.spindle_stop_ovr) {
    2ff8:	9a 85       	ldd	r25, Y+10	; 0x0a
    2ffa:	99 23       	and	r25, r25
    2ffc:	61 f1       	breq	.+88     	; 0x3056 <protocol_execute_realtime+0x1e2>
          // Handles beginning of spindle stop
          if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_INITIATE) {
    2ffe:	91 ff       	sbrs	r25, 1
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    3000:	0d c0       	rjmp	.+26     	; 0x301c <protocol_execute_realtime+0x1a8>
    3002:	f8 01       	movw	r30, r16
    3004:	81 85       	ldd	r24, Z+9	; 0x09
    3006:	88 23       	and	r24, r24
              spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
    3008:	39 f0       	breq	.+14     	; 0x3018 <protocol_execute_realtime+0x1a4>
    300a:	40 e0       	ldi	r20, 0x00	; 0
    300c:	50 e0       	ldi	r21, 0x00	; 0
    300e:	ba 01       	movw	r22, r20
    3010:	80 e0       	ldi	r24, 0x00	; 0
    3012:	44 db       	rcall	.-2424   	; 0x269c <spindle_set_state>
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_ENABLED; // Set stop override state to enabled, if de-energized.
    3014:	7a 86       	std	Y+10, r7	; 0x0a
    3016:	29 c0       	rjmp	.+82     	; 0x306a <protocol_execute_realtime+0x1f6>
            } else {
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
    3018:	1a 86       	std	Y+10, r1	; 0x0a
    301a:	27 c0       	rjmp	.+78     	; 0x306a <protocol_execute_realtime+0x1f6>
            }
          // Handles restoring of spindle state
          } else if (sys.spindle_stop_ovr & (SPINDLE_STOP_OVR_RESTORE | SPINDLE_STOP_OVR_RESTORE_CYCLE)) {
    301c:	9c 70       	andi	r25, 0x0C	; 12
    301e:	29 f1       	breq	.+74     	; 0x306a <protocol_execute_realtime+0x1f6>
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    3020:	f8 01       	movw	r30, r16
    3022:	81 85       	ldd	r24, Z+9	; 0x09
    3024:	88 23       	and	r24, r24
    3026:	79 f0       	breq	.+30     	; 0x3046 <protocol_execute_realtime+0x1d2>
              report_feedback_message(MESSAGE_SPINDLE_RESTORE);
    3028:	8a e0       	ldi	r24, 0x0A	; 10
    302a:	0e 94 ab 35 	call	0x6b56	; 0x6b56 <report_feedback_message>
              if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    302e:	f7 01       	movw	r30, r14
    3030:	80 81       	ld	r24, Z
    3032:	81 ff       	sbrs	r24, 1
                // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    3034:	04 c0       	rjmp	.+8      	; 0x303e <protocol_execute_realtime+0x1ca>
    3036:	8c 81       	ldd	r24, Y+4	; 0x04
    3038:	88 60       	ori	r24, 0x08	; 8
    303a:	8c 83       	std	Y+4, r24	; 0x04
              } else {
                spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    303c:	04 c0       	rjmp	.+8      	; 0x3046 <protocol_execute_realtime+0x1d2>
    303e:	b5 01       	movw	r22, r10
    3040:	a4 01       	movw	r20, r8
    3042:	8c 2d       	mov	r24, r12
    3044:	2b db       	rcall	.-2474   	; 0x269c <spindle_set_state>
              }
            }
            if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_RESTORE_CYCLE) {
    3046:	8a 85       	ldd	r24, Y+10	; 0x0a
    3048:	83 ff       	sbrs	r24, 3
              system_set_exec_state_flag(EXEC_CYCLE_START);  // Set to resume program.
    304a:	03 c0       	rjmp	.+6      	; 0x3052 <protocol_execute_realtime+0x1de>
    304c:	82 e0       	ldi	r24, 0x02	; 2
    304e:	0e 94 95 3b 	call	0x772a	; 0x772a <system_set_exec_state_flag>
            sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
          }
        } else {
          // Handles spindle state during hold. NOTE: Spindle speed overrides may be altered during hold state.
          // NOTE: STEP_CONTROL_UPDATE_SPINDLE_PWM is automatically reset upon resume in step generator.
          if (bit_istrue(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
    3052:	1a 86       	std	Y+10, r1	; 0x0a
    3054:	0a c0       	rjmp	.+20     	; 0x306a <protocol_execute_realtime+0x1f6>
    3056:	8c 81       	ldd	r24, Y+4	; 0x04
            spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    3058:	83 ff       	sbrs	r24, 3
    305a:	07 c0       	rjmp	.+14     	; 0x306a <protocol_execute_realtime+0x1f6>
    305c:	b5 01       	movw	r22, r10
    305e:	a4 01       	movw	r20, r8
    3060:	8c 2d       	mov	r24, r12
            bit_false(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    3062:	1c db       	rcall	.-2504   	; 0x269c <spindle_set_state>
    3064:	8c 81       	ldd	r24, Y+4	; 0x04
    3066:	87 7f       	andi	r24, 0xF7	; 247
      // Sleep is valid for both hold and door states, if the spindle or coolant are on or
      // set to be re-enabled.
      sleep_check();
    #endif

    protocol_exec_rt_system();
    3068:	8c 83       	std	Y+4, r24	; 0x04
    306a:	da dc       	rcall	.-1612   	; 0x2a20 <protocol_exec_rt_system>
    if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) { 
      system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP);
    }
  #endif

  while (sys.suspend) {
    306c:	9a 81       	ldd	r25, Y+2	; 0x02
    306e:	91 11       	cpse	r25, r1
    3070:	50 cf       	rjmp	.-352    	; 0x2f12 <protocol_execute_realtime+0x9e>
    3072:	07 c0       	rjmp	.+14     	; 0x3082 <protocol_execute_realtime+0x20e>
                  spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
                  delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
                }
              }
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
    3074:	f8 01       	movw	r30, r16
    3076:	80 85       	ldd	r24, Z+8	; 0x08
    3078:	81 11       	cpse	r24, r1
    307a:	f7 cf       	rjmp	.-18     	; 0x306a <protocol_execute_realtime+0x1f6>
    307c:	b4 cf       	rjmp	.-152    	; 0x2fe6 <protocol_execute_realtime+0x172>
                  mc_parking_motion(restore_target, pl_data);
                }
              }
            #endif

            if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    307e:	8a 81       	ldd	r24, Y+2	; 0x02
    3080:	b5 cf       	rjmp	.-150    	; 0x2fec <protocol_execute_realtime+0x178>
// limit switches, or the main program.
void protocol_execute_realtime()
{
  protocol_exec_rt_system();
  if (sys.suspend) { protocol_exec_rt_suspend(); }
}
    3082:	df 91       	pop	r29
    3084:	cf 91       	pop	r28
    3086:	1f 91       	pop	r17
    3088:	0f 91       	pop	r16
    308a:	ff 90       	pop	r15
    308c:	ef 90       	pop	r14
    308e:	df 90       	pop	r13
    3090:	cf 90       	pop	r12
    3092:	bf 90       	pop	r11
    3094:	af 90       	pop	r10
    3096:	9f 90       	pop	r9
    3098:	8f 90       	pop	r8
    309a:	7f 90       	pop	r7
    309c:	08 95       	ret

0000309e <protocol_main_loop>:

/*
  GRBL PRIMARY LOOP:
*/
void protocol_main_loop()
{
    309e:	df 92       	push	r13
    30a0:	ef 92       	push	r14
    30a2:	ff 92       	push	r15
    30a4:	0f 93       	push	r16
    30a6:	1f 93       	push	r17
    30a8:	cf 93       	push	r28
    30aa:	df 93       	push	r29
  // Perform some machine checks to make sure everything is good to go.
  #ifdef CHECK_LIMITS_AT_INIT
    if (bit_istrue(settings.flags, BITFLAG_HARD_LIMIT_ENABLE)) {
    30ac:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    30b0:	83 ff       	sbrs	r24, 3
    30b2:	0a c0       	rjmp	.+20     	; 0x30c8 <protocol_main_loop+0x2a>
      if (limits_get_state()) {
    30b4:	0e 94 3b 30 	call	0x6076	; 0x6076 <limits_get_state>
    30b8:	88 23       	and	r24, r24
    30ba:	31 f0       	breq	.+12     	; 0x30c8 <protocol_main_loop+0x2a>
        sys.state = STATE_ALARM; // Ensure alarm state is active.
    30bc:	81 e0       	ldi	r24, 0x01	; 1
    30be:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
        report_feedback_message(MESSAGE_CHECK_LIMITS);
    30c2:	87 e0       	ldi	r24, 0x07	; 7
    30c4:	0e 94 ab 35 	call	0x6b56	; 0x6b56 <report_feedback_message>
    }
  #endif
  // Check for and report alarm state after a reset, error, or an initial power up.
  // NOTE: Sleep mode disables the stepper drivers and position can't be guaranteed.
  // Re-initialize the sleep state as an ALARM mode to ensure user homes or acknowledges.
  if (sys.state & (STATE_ALARM | STATE_SLEEP)) {
    30c8:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    30cc:	81 78       	andi	r24, 0x81	; 129
    30ce:	71 f0       	breq	.+28     	; 0x30ec <protocol_main_loop+0x4e>
    report_feedback_message(MESSAGE_ALARM_LOCK);
    30d0:	82 e0       	ldi	r24, 0x02	; 2
    30d2:	0e 94 ab 35 	call	0x6b56	; 0x6b56 <report_feedback_message>
    sys.state = STATE_ALARM; // Ensure alarm state is set.
    30d6:	81 e0       	ldi	r24, 0x01	; 1
    30d8:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
          } else if (c == '(') {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            line_flags |= LINE_FLAG_COMMENT_PARENTHESES;
    30dc:	f1 2c       	mov	r15, r1
    30de:	e1 2c       	mov	r14, r1
    // this indicates that g-code streaming has either filled the planner buffer or has
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();

    protocol_execute_realtime();  // Runtime command check point.
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    30e0:	ce e1       	ldi	r28, 0x1E	; 30
    30e2:	dc e0       	ldi	r29, 0x0C	; 12

        // Direct and execute one line of formatted input, and report status of execution.
        if (line_flags & LINE_FLAG_OVERFLOW) {
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
        } else if (line[0] == 0) {
    30e4:	08 e0       	ldi	r16, 0x08	; 8
    30e6:	12 e0       	ldi	r17, 0x02	; 2
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    30e8:	d1 2c       	mov	r13, r1
    30ea:	7b c0       	rjmp	.+246    	; 0x31e2 <protocol_main_loop+0x144>
  if (sys.state & (STATE_ALARM | STATE_SLEEP)) {
    report_feedback_message(MESSAGE_ALARM_LOCK);
    sys.state = STATE_ALARM; // Ensure alarm state is set.
  } else {
    // Check if the safety door is open.
    sys.state = STATE_IDLE;
    30ec:	10 92 1e 0c 	sts	0x0C1E, r1	; 0x800c1e <sys>
    if (system_check_safety_door_ajar()) {
    30f0:	0e 94 d2 3a 	call	0x75a4	; 0x75a4 <system_check_safety_door_ajar>
    30f4:	88 23       	and	r24, r24
    30f6:	31 f0       	breq	.+12     	; 0x3104 <protocol_main_loop+0x66>
      bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
    30f8:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    30fc:	80 62       	ori	r24, 0x20	; 32
    30fe:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <sys_rt_exec_state>
      protocol_execute_realtime(); // Enter safety door mode. Should return as IDLE state.
    3102:	b8 de       	rcall	.-656    	; 0x2e74 <protocol_execute_realtime>
    }
    // All systems go!
    system_execute_startup(line); // Execute startup script.
    3104:	88 e0       	ldi	r24, 0x08	; 8
    3106:	92 e0       	ldi	r25, 0x02	; 2
    3108:	0e 94 d5 3a 	call	0x75aa	; 0x75aa <system_execute_startup>
    310c:	e7 cf       	rjmp	.-50     	; 0x30dc <protocol_main_loop+0x3e>
  for (;;) {

    // Process one line of incoming serial data, as the data becomes available. Performs an
    // initial filtering by removing spaces and comments and capitalizing all letters.
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
    310e:	8a 30       	cpi	r24, 0x0A	; 10
    3110:	11 f0       	breq	.+4      	; 0x3116 <protocol_main_loop+0x78>
    3112:	8d 30       	cpi	r24, 0x0D	; 13

        protocol_execute_realtime(); // Runtime command check point.
    3114:	b1 f5       	brne	.+108    	; 0x3182 <protocol_main_loop+0xe4>
    3116:	ae de       	rcall	.-676    	; 0x2e74 <protocol_execute_realtime>
        if (sys.abort) { return; } // Bail to calling function upon system abort
    3118:	89 81       	ldd	r24, Y+1	; 0x01
    311a:	81 11       	cpse	r24, r1
    311c:	6b c0       	rjmp	.+214    	; 0x31f4 <protocol_main_loop+0x156>

        line[char_counter] = 0; // Set string termination character.
    311e:	ef 2d       	mov	r30, r15
    3120:	f0 e0       	ldi	r31, 0x00	; 0
    3122:	e8 5f       	subi	r30, 0xF8	; 248
    3124:	fd 4f       	sbci	r31, 0xFD	; 253
    3126:	10 82       	st	Z, r1
        #ifdef REPORT_ECHO_LINE_RECEIVED
          report_echo_line_received(line);
        #endif

        // Direct and execute one line of formatted input, and report status of execution.
        if (line_flags & LINE_FLAG_OVERFLOW) {
    3128:	e0 fe       	sbrs	r14, 0
    312a:	06 c0       	rjmp	.+12     	; 0x3138 <protocol_main_loop+0x9a>
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
    312c:	8b e0       	ldi	r24, 0x0B	; 11
    312e:	0e 94 34 35 	call	0x6a68	; 0x6a68 <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    3132:	fd 2c       	mov	r15, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    3134:	e1 2c       	mov	r14, r1
    3136:	55 c0       	rjmp	.+170    	; 0x31e2 <protocol_main_loop+0x144>

        // Direct and execute one line of formatted input, and report status of execution.
        if (line_flags & LINE_FLAG_OVERFLOW) {
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
        } else if (line[0] == 0) {
    3138:	f8 01       	movw	r30, r16
    313a:	80 81       	ld	r24, Z
    313c:	81 11       	cpse	r24, r1
    313e:	06 c0       	rjmp	.+12     	; 0x314c <protocol_main_loop+0xae>
          // Empty or comment line. For syncing purposes.
          report_status_message(STATUS_OK);
    3140:	8d 2d       	mov	r24, r13
    3142:	0e 94 34 35 	call	0x6a68	; 0x6a68 <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    3146:	fd 2c       	mov	r15, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    3148:	e1 2c       	mov	r14, r1
    314a:	4b c0       	rjmp	.+150    	; 0x31e2 <protocol_main_loop+0x144>
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
        } else if (line[0] == 0) {
          // Empty or comment line. For syncing purposes.
          report_status_message(STATUS_OK);
        } else if (line[0] == '$') {
    314c:	84 32       	cpi	r24, 0x24	; 36
    314e:	41 f4       	brne	.+16     	; 0x3160 <protocol_main_loop+0xc2>
          // Grbl '$' system command
          report_status_message(system_execute_line(line));
    3150:	c8 01       	movw	r24, r16
    3152:	0e 94 9e 3b 	call	0x773c	; 0x773c <system_execute_line>
    3156:	0e 94 34 35 	call	0x6a68	; 0x6a68 <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    315a:	fd 2c       	mov	r15, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    315c:	e1 2c       	mov	r14, r1
    315e:	41 c0       	rjmp	.+130    	; 0x31e2 <protocol_main_loop+0x144>
          // Empty or comment line. For syncing purposes.
          report_status_message(STATUS_OK);
        } else if (line[0] == '$') {
          // Grbl '$' system command
          report_status_message(system_execute_line(line));
        } else if (sys.state & (STATE_ALARM | STATE_JOG)) {
    3160:	88 81       	ld	r24, Y
    3162:	81 72       	andi	r24, 0x21	; 33
    3164:	31 f0       	breq	.+12     	; 0x3172 <protocol_main_loop+0xd4>
          // Everything else is gcode. Block if in alarm or jog mode.
          report_status_message(STATUS_SYSTEM_GC_LOCK);
    3166:	89 e0       	ldi	r24, 0x09	; 9
    3168:	0e 94 34 35 	call	0x6a68	; 0x6a68 <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    316c:	fd 2c       	mov	r15, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    316e:	e1 2c       	mov	r14, r1
    3170:	38 c0       	rjmp	.+112    	; 0x31e2 <protocol_main_loop+0x144>
        } else if (sys.state & (STATE_ALARM | STATE_JOG)) {
          // Everything else is gcode. Block if in alarm or jog mode.
          report_status_message(STATUS_SYSTEM_GC_LOCK);
        } else {
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
    3172:	c8 01       	movw	r24, r16
    3174:	0e 94 67 07 	call	0xece	; 0xece <gc_execute_line>
    3178:	0e 94 34 35 	call	0x6a68	; 0x6a68 <report_status_message>
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    317c:	fd 2c       	mov	r15, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    317e:	e1 2c       	mov	r14, r1
    3180:	30 c0       	rjmp	.+96     	; 0x31e2 <protocol_main_loop+0x144>
        char_counter = 0;

      } else {

        if (line_flags) {
    3182:	ee 20       	and	r14, r14
    3184:	31 f0       	breq	.+12     	; 0x3192 <protocol_main_loop+0xf4>
          // Throw away all (except EOL) comment characters and overflow characters.
          if (c == ')') {
    3186:	89 32       	cpi	r24, 0x29	; 41
    3188:	61 f5       	brne	.+88     	; 0x31e2 <protocol_main_loop+0x144>
            // End of '()' comment. Resume line allowed.
            if (line_flags & LINE_FLAG_COMMENT_PARENTHESES) { line_flags &= ~(LINE_FLAG_COMMENT_PARENTHESES); }
    318a:	fe 2d       	mov	r31, r14
    318c:	fd 7f       	andi	r31, 0xFD	; 253
    318e:	ef 2e       	mov	r14, r31
    3190:	28 c0       	rjmp	.+80     	; 0x31e2 <protocol_main_loop+0x144>
          }
        } else {
          if (c <= ' ') {
    3192:	81 32       	cpi	r24, 0x21	; 33
    3194:	30 f1       	brcs	.+76     	; 0x31e2 <protocol_main_loop+0x144>
            // Throw away whitepace and control characters
          } else if (c == '/') {
    3196:	8f 32       	cpi	r24, 0x2F	; 47
    3198:	21 f1       	breq	.+72     	; 0x31e2 <protocol_main_loop+0x144>
            // Block delete NOT SUPPORTED. Ignore character.
            // NOTE: If supported, would simply need to check the system if block delete is enabled.
          } else if (c == '(') {
    319a:	88 32       	cpi	r24, 0x28	; 40
    319c:	c1 f0       	breq	.+48     	; 0x31ce <protocol_main_loop+0x130>
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            line_flags |= LINE_FLAG_COMMENT_PARENTHESES;
          } else if (c == ';') {
    319e:	8b 33       	cpi	r24, 0x3B	; 59
    31a0:	d1 f0       	breq	.+52     	; 0x31d6 <protocol_main_loop+0x138>
            // Program start-end percent sign NOT SUPPORTED.
            // NOTE: This maybe installed to tell Grbl when a program is running vs manual input,
            // where, during a program, the system auto-cycle start will continue to execute
            // everything until the next '%' sign. This will help fix resuming issues with certain
            // functions that empty the planner buffer to execute its task on-time.
          } else if (char_counter >= (LINE_BUFFER_SIZE-1)) {
    31a2:	9f ef       	ldi	r25, 0xFF	; 255
    31a4:	f9 16       	cp	r15, r25
    31a6:	d9 f0       	breq	.+54     	; 0x31de <protocol_main_loop+0x140>
            // Detect line buffer overflow and set flag.
            line_flags |= LINE_FLAG_OVERFLOW;
          } else if (c >= 'a' && c <= 'z') { // Upcase lowercase
    31a8:	9f e9       	ldi	r25, 0x9F	; 159
    31aa:	98 0f       	add	r25, r24
    31ac:	9a 31       	cpi	r25, 0x1A	; 26
    31ae:	40 f4       	brcc	.+16     	; 0x31c0 <protocol_main_loop+0x122>
            line[char_counter++] = c-'a'+'A';
    31b0:	ef 2d       	mov	r30, r15
    31b2:	f0 e0       	ldi	r31, 0x00	; 0
    31b4:	e8 5f       	subi	r30, 0xF8	; 248
    31b6:	fd 4f       	sbci	r31, 0xFD	; 253
    31b8:	80 52       	subi	r24, 0x20	; 32
    31ba:	80 83       	st	Z, r24
    31bc:	f3 94       	inc	r15
    31be:	11 c0       	rjmp	.+34     	; 0x31e2 <protocol_main_loop+0x144>
          } else {
            line[char_counter++] = c;
    31c0:	ef 2d       	mov	r30, r15
    31c2:	f0 e0       	ldi	r31, 0x00	; 0
    31c4:	e8 5f       	subi	r30, 0xF8	; 248
    31c6:	fd 4f       	sbci	r31, 0xFD	; 253
    31c8:	80 83       	st	Z, r24
    31ca:	f3 94       	inc	r15
    31cc:	0a c0       	rjmp	.+20     	; 0x31e2 <protocol_main_loop+0x144>
          } else if (c == '(') {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            line_flags |= LINE_FLAG_COMMENT_PARENTHESES;
    31ce:	68 94       	set
    31d0:	ee 24       	eor	r14, r14
    31d2:	e1 f8       	bld	r14, 1
    31d4:	06 c0       	rjmp	.+12     	; 0x31e2 <protocol_main_loop+0x144>
          } else if (c == ';') {
            // NOTE: ';' comment to EOL is a LinuxCNC definition. Not NIST.
            line_flags |= LINE_FLAG_COMMENT_SEMICOLON;
    31d6:	68 94       	set
    31d8:	ee 24       	eor	r14, r14
    31da:	e2 f8       	bld	r14, 2
    31dc:	02 c0       	rjmp	.+4      	; 0x31e2 <protocol_main_loop+0x144>
            // where, during a program, the system auto-cycle start will continue to execute
            // everything until the next '%' sign. This will help fix resuming issues with certain
            // functions that empty the planner buffer to execute its task on-time.
          } else if (char_counter >= (LINE_BUFFER_SIZE-1)) {
            // Detect line buffer overflow and set flag.
            line_flags |= LINE_FLAG_OVERFLOW;
    31de:	ee 24       	eor	r14, r14
  uint8_t c;
  for (;;) {

    // Process one line of incoming serial data, as the data becomes available. Performs an
    // initial filtering by removing spaces and comments and capitalizing all letters.
    while((c = serial_read()) != SERIAL_NO_DATA) {
    31e0:	e3 94       	inc	r14
    31e2:	49 db       	rcall	.-2414   	; 0x2876 <serial_read>
    31e4:	8f 3f       	cpi	r24, 0xFF	; 255
    }

    // If there are no more characters in the serial read buffer to be processed and executed,
    // this indicates that g-code streaming has either filled the planner buffer or has
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();
    31e6:	09 f0       	breq	.+2      	; 0x31ea <protocol_main_loop+0x14c>
    31e8:	92 cf       	rjmp	.-220    	; 0x310e <protocol_main_loop+0x70>

    protocol_execute_realtime();  // Runtime command check point.
    31ea:	12 dc       	rcall	.-2012   	; 0x2a10 <protocol_auto_cycle_start>
    31ec:	43 de       	rcall	.-890    	; 0x2e74 <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    31ee:	89 81       	ldd	r24, Y+1	; 0x01
    31f0:	88 23       	and	r24, r24
    31f2:	b9 f3       	breq	.-18     	; 0x31e2 <protocol_main_loop+0x144>
      sleep_check();    
    #endif
  }

  return; /* Never reached */
}
    31f4:	df 91       	pop	r29
    31f6:	cf 91       	pop	r28
    31f8:	1f 91       	pop	r17
    31fa:	0f 91       	pop	r16
    31fc:	ff 90       	pop	r15
    31fe:	ef 90       	pop	r14
    3200:	df 90       	pop	r13
    3202:	08 95       	ret

00003204 <protocol_buffer_synchronize>:


// Block until all buffered steps are executed or in a cycle state. Works with feed hold
// during a synchronize call, if it should happen. Also, waits for clean cycle end.
void protocol_buffer_synchronize()
{
    3204:	cf 93       	push	r28
    3206:	df 93       	push	r29
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
    3208:	03 dc       	rcall	.-2042   	; 0x2a10 <protocol_auto_cycle_start>
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    if (sys.abort) { return; } // Check for system abort
    320a:	ce e1       	ldi	r28, 0x1E	; 30
void protocol_buffer_synchronize()
{
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    320c:	dc e0       	ldi	r29, 0x0C	; 12
    320e:	32 de       	rcall	.-924    	; 0x2e74 <protocol_execute_realtime>
    if (sys.abort) { return; } // Check for system abort
    3210:	89 81       	ldd	r24, Y+1	; 0x01
    3212:	81 11       	cpse	r24, r1
    3214:	07 c0       	rjmp	.+14     	; 0x3224 <protocol_buffer_synchronize+0x20>
  } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
    3216:	0e 94 5b 29 	call	0x52b6	; 0x52b6 <plan_get_current_block>
    321a:	89 2b       	or	r24, r25
    321c:	c1 f7       	brne	.-16     	; 0x320e <protocol_buffer_synchronize+0xa>
    321e:	88 81       	ld	r24, Y
    3220:	88 30       	cpi	r24, 0x08	; 8
    3222:	a9 f3       	breq	.-22     	; 0x320e <protocol_buffer_synchronize+0xa>
}
    3224:	df 91       	pop	r29
    3226:	cf 91       	pop	r28
    3228:	08 95       	ret

0000322a <st_wake_up>:
    // Initialize stepper output bits to ensure first ISR call does not step.
    for (idx = 0; idx < N_AXIS; idx++) {
      st.step_outbits[idx] = step_port_invert_mask[idx];
    }
  #else
    if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    322a:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    322e:	82 ff       	sbrs	r24, 2
    3230:	02 c0       	rjmp	.+4      	; 0x3236 <st_wake_up+0xc>
    3232:	2f 9a       	sbi	0x05, 7	; 5
    3234:	01 c0       	rjmp	.+2      	; 0x3238 <st_wake_up+0xe>
    else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    3236:	2f 98       	cbi	0x05, 7	; 5
    // Initialize stepper output bits to ensure first ISR call does not step.
    st.step_outbits = step_port_invert_mask;
    3238:	e3 e4       	ldi	r30, 0x43	; 67
    323a:	f3 e0       	ldi	r31, 0x03	; 3
    323c:	80 91 3f 03 	lds	r24, 0x033F	; 0x80033f <step_port_invert_mask>
    3240:	86 87       	std	Z+14, r24	; 0x0e
    st.step_pulse_time = -(((settings.pulse_microseconds+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND) >> 3);
    // Set delay between direction pin write and step command.
    OCR0A = -(((settings.pulse_microseconds)*TICKS_PER_MICROSECOND) >> 3);
  #else // Normal operation
    // Set step pulse time. Ad hoc computation from oscilloscope. Uses two's complement.
    st.step_pulse_time = -(((settings.pulse_microseconds-2)*TICKS_PER_MICROSECOND) >> 3);
    3242:	80 91 00 0f 	lds	r24, 0x0F00	; 0x800f00 <settings+0x30>
    3246:	88 0f       	add	r24, r24
    3248:	84 50       	subi	r24, 0x04	; 4
    324a:	81 95       	neg	r24
    324c:	85 87       	std	Z+13, r24	; 0x0d
  #endif

  // Enable Stepper Driver Interrupt
  TIMSK1 |= (1<<OCIE1A);
    324e:	ef e6       	ldi	r30, 0x6F	; 111
    3250:	f0 e0       	ldi	r31, 0x00	; 0
    3252:	80 81       	ld	r24, Z
    3254:	82 60       	ori	r24, 0x02	; 2
    3256:	80 83       	st	Z, r24
    3258:	08 95       	ret

0000325a <st_go_idle>:

// Stepper shutdown
void st_go_idle()
{
  // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.
  TIMSK1 &= ~(1<<OCIE1A); // Disable Timer1 interrupt
    325a:	ef e6       	ldi	r30, 0x6F	; 111
    325c:	f0 e0       	ldi	r31, 0x00	; 0
    325e:	80 81       	ld	r24, Z
    3260:	8d 7f       	andi	r24, 0xFD	; 253
    3262:	80 83       	st	Z, r24
  TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Reset clock to no prescaling.
    3264:	e1 e8       	ldi	r30, 0x81	; 129
    3266:	f0 e0       	ldi	r31, 0x00	; 0
    3268:	80 81       	ld	r24, Z
    326a:	88 7f       	andi	r24, 0xF8	; 248
    326c:	81 60       	ori	r24, 0x01	; 1
    326e:	80 83       	st	Z, r24
  busy = false;
    3270:	10 92 3d 03 	sts	0x033D, r1	; 0x80033d <busy>

  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
  if (((settings.stepper_idle_lock_time != 0xff) || sys_rt_exec_alarm || sys.state == STATE_SLEEP) && sys.state != STATE_HOMING) {
    3274:	80 91 03 0f 	lds	r24, 0x0F03	; 0x800f03 <settings+0x33>
    3278:	8f 3f       	cpi	r24, 0xFF	; 255
    327a:	49 f4       	brne	.+18     	; 0x328e <st_go_idle+0x34>
    327c:	90 91 53 0c 	lds	r25, 0x0C53	; 0x800c53 <sys_rt_exec_alarm>
    3280:	91 11       	cpse	r25, r1
    3282:	05 c0       	rjmp	.+10     	; 0x328e <st_go_idle+0x34>
    3284:	90 91 1e 0c 	lds	r25, 0x0C1E	; 0x800c1e <sys>
    3288:	90 38       	cpi	r25, 0x80	; 128
    328a:	81 f4       	brne	.+32     	; 0x32ac <st_go_idle+0x52>
    328c:	04 c0       	rjmp	.+8      	; 0x3296 <st_go_idle+0x3c>
    328e:	90 91 1e 0c 	lds	r25, 0x0C1E	; 0x800c1e <sys>
    3292:	94 30       	cpi	r25, 0x04	; 4
    3294:	59 f0       	breq	.+22     	; 0x32ac <st_go_idle+0x52>
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    3296:	90 e0       	ldi	r25, 0x00	; 0
    3298:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <delay_ms>
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    329c:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    32a0:	82 fd       	sbrc	r24, 2
    32a2:	02 c0       	rjmp	.+4      	; 0x32a8 <st_go_idle+0x4e>
      STEPPER_DISABLE_PORT(0) &= ~(1 << STEPPER_DISABLE_BIT(0));
      STEPPER_DISABLE_PORT(1) &= ~(1 << STEPPER_DISABLE_BIT(1));
      STEPPER_DISABLE_PORT(2) &= ~(1 << STEPPER_DISABLE_BIT(2));
    }
  #else
    if (pin_state) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    32a4:	2f 9a       	sbi	0x05, 7	; 5
    32a6:	08 95       	ret
    else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    32a8:	2f 98       	cbi	0x05, 7	; 5
  #endif // Ramps Board
}
    32aa:	08 95       	ret
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    32ac:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    32b0:	82 ff       	sbrs	r24, 2
    32b2:	fa cf       	rjmp	.-12     	; 0x32a8 <st_go_idle+0x4e>
    32b4:	f7 cf       	rjmp	.-18     	; 0x32a4 <st_go_idle+0x4a>

000032b6 <__vector_17>:
*/
// TODO: Replace direct updating of the int32 position counters in the ISR somehow. Perhaps use smaller
// int8 variables and update position counters only when a segment completes. This can get complicated
// with probing and homing cycles that require true real-time positions.
ISR(TIMER1_COMPA_vect)
{
    32b6:	1f 92       	push	r1
    32b8:	0f 92       	push	r0
    32ba:	0f b6       	in	r0, 0x3f	; 63
    32bc:	0f 92       	push	r0
    32be:	11 24       	eor	r1, r1
    32c0:	0b b6       	in	r0, 0x3b	; 59
    32c2:	0f 92       	push	r0
    32c4:	2f 93       	push	r18
    32c6:	3f 93       	push	r19
    32c8:	4f 93       	push	r20
    32ca:	5f 93       	push	r21
    32cc:	6f 93       	push	r22
    32ce:	7f 93       	push	r23
    32d0:	8f 93       	push	r24
    32d2:	9f 93       	push	r25
    32d4:	af 93       	push	r26
    32d6:	bf 93       	push	r27
    32d8:	cf 93       	push	r28
    32da:	df 93       	push	r29
    32dc:	ef 93       	push	r30
    32de:	ff 93       	push	r31
  #ifdef DEFAULTS_RAMPS_BOARD
    int i;
  #endif // Ramps Board

  if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
    32e0:	80 91 3d 03 	lds	r24, 0x033D	; 0x80033d <busy>
    32e4:	81 11       	cpse	r24, r1
    32e6:	d0 c1       	rjmp	.+928    	; 0x3688 <__vector_17+0x3d2>
  #ifdef DEFAULTS_RAMPS_BOARD
    DIRECTION_PORT(0) = (DIRECTION_PORT(0) & ~(1 << DIRECTION_BIT(0))) | st.dir_outbits[0];
    DIRECTION_PORT(1) = (DIRECTION_PORT(1) & ~(1 << DIRECTION_BIT(1))) | st.dir_outbits[1];
    DIRECTION_PORT(2) = (DIRECTION_PORT(2) & ~(1 << DIRECTION_BIT(2))) | st.dir_outbits[2];
  #else
    DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK);
    32e8:	88 b1       	in	r24, 0x08	; 8
    32ea:	e3 e4       	ldi	r30, 0x43	; 67
    32ec:	f3 e0       	ldi	r31, 0x03	; 3
    32ee:	97 85       	ldd	r25, Z+15	; 0x0f
    32f0:	90 7e       	andi	r25, 0xE0	; 224
    32f2:	8f 71       	andi	r24, 0x1F	; 31
    32f4:	89 2b       	or	r24, r25
    32f6:	88 b9       	out	0x08, r24	; 8
    #endif
  #else  
    #ifdef STEP_PULSE_DELAY
      st.step_bits = (STEP_PORT & ~STEP_MASK) | st.step_outbits; // Store out_bits to prevent overwriting.
    #else  // Normal operation
      STEP_PORT = (STEP_PORT & ~STEP_MASK) | st.step_outbits;
    32f8:	82 b1       	in	r24, 0x02	; 2
    32fa:	83 7e       	andi	r24, 0xE3	; 227
    32fc:	96 85       	ldd	r25, Z+14	; 0x0e
    32fe:	89 2b       	or	r24, r25
    3300:	82 b9       	out	0x02, r24	; 2
    #endif
  #endif // Ramps Board

  // Enable step pulse reset timer so that The Stepper Port Reset Interrupt can reset the signal after
  // exactly settings.pulse_microseconds microseconds, independent of the main Timer1 prescaler.
  TCNT0 = st.step_pulse_time; // Reload Timer0 counter
    3302:	85 85       	ldd	r24, Z+13	; 0x0d
    3304:	86 bd       	out	0x26, r24	; 38
  TCCR0B = (1<<CS01); // Begin Timer0. Full speed, 1/8 prescaler
    3306:	82 e0       	ldi	r24, 0x02	; 2
    3308:	85 bd       	out	0x25, r24	; 37

  busy = true;
    330a:	81 e0       	ldi	r24, 0x01	; 1
    330c:	80 93 3d 03 	sts	0x033D, r24	; 0x80033d <busy>
  sei(); // Re-enable interrupts to allow Stepper Port Reset Interrupt to fire on-time.
    3310:	78 94       	sei
         // NOTE: The remaining code in this ISR will finish before returning to main program.

  // If there is no step segment, attempt to pop one from the stepper buffer
  if (st.exec_segment == NULL) {
    3312:	81 a1       	ldd	r24, Z+33	; 0x21
    3314:	92 a1       	ldd	r25, Z+34	; 0x22
    3316:	89 2b       	or	r24, r25
    3318:	09 f0       	breq	.+2      	; 0x331c <__vector_17+0x66>
    331a:	a9 c0       	rjmp	.+338    	; 0x346e <__vector_17+0x1b8>
    // Anything in the buffer? If so, load and initialize next step segment.
    if (segment_buffer_head != segment_buffer_tail) {
    331c:	80 91 42 03 	lds	r24, 0x0342	; 0x800342 <segment_buffer_tail>
    3320:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <segment_buffer_head>
    3324:	98 17       	cp	r25, r24
    3326:	09 f4       	brne	.+2      	; 0x332a <__vector_17+0x74>
    3328:	93 c0       	rjmp	.+294    	; 0x3450 <__vector_17+0x19a>
      // Initialize new step segment and load number of steps to execute
      st.exec_segment = &segment_buffer[segment_buffer_tail];
    332a:	e0 91 42 03 	lds	r30, 0x0342	; 0x800342 <segment_buffer_tail>
    332e:	f0 e0       	ldi	r31, 0x00	; 0
    3330:	a3 e4       	ldi	r26, 0x43	; 67
    3332:	b3 e0       	ldi	r27, 0x03	; 3
    3334:	ee 0f       	add	r30, r30
    3336:	ff 1f       	adc	r31, r31
    3338:	ee 0f       	add	r30, r30
    333a:	ff 1f       	adc	r31, r31
    333c:	ee 0f       	add	r30, r30
    333e:	ff 1f       	adc	r31, r31
    3340:	ea 59       	subi	r30, 0x9A	; 154
    3342:	fc 4f       	sbci	r31, 0xFC	; 252
    3344:	92 96       	adiw	r26, 0x22	; 34
    3346:	fc 93       	st	X, r31
    3348:	ee 93       	st	-X, r30
    334a:	91 97       	sbiw	r26, 0x21	; 33
        // With AMASS is disabled, set timer prescaler for segments with slow step frequencies (< 250Hz).
        TCCR1B = (TCCR1B & ~(0x07<<CS10)) | (st.exec_segment->prescaler<<CS10);
      #endif

      // Initialize step segment timing per step and load number of steps to execute.
      OCR1A = st.exec_segment->cycles_per_tick;
    334c:	82 81       	ldd	r24, Z+2	; 0x02
    334e:	93 81       	ldd	r25, Z+3	; 0x03
    3350:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    3354:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
      st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
    3358:	80 81       	ld	r24, Z
    335a:	91 81       	ldd	r25, Z+1	; 0x01
    335c:	5d 96       	adiw	r26, 0x1d	; 29
    335e:	9c 93       	st	X, r25
    3360:	8e 93       	st	-X, r24
    3362:	5c 97       	sbiw	r26, 0x1c	; 28
      // If the new segment starts a new planner block, initialize stepper variables and counters.
      // NOTE: When the segment data index changes, this indicates a new planner block.
      if ( st.exec_block_index != st.exec_segment->st_block_index ) {
    3364:	84 81       	ldd	r24, Z+4	; 0x04
    3366:	5e 96       	adiw	r26, 0x1e	; 30
    3368:	9c 91       	ld	r25, X
    336a:	5e 97       	sbiw	r26, 0x1e	; 30
    336c:	98 17       	cp	r25, r24
    336e:	49 f1       	breq	.+82     	; 0x33c2 <__vector_17+0x10c>
        st.exec_block_index = st.exec_segment->st_block_index;
    3370:	ed 01       	movw	r28, r26
    3372:	8e 8f       	std	Y+30, r24	; 0x1e
        st.exec_block = &st_block_buffer[st.exec_block_index];
    3374:	90 e0       	ldi	r25, 0x00	; 0
    3376:	88 0f       	add	r24, r24
    3378:	99 1f       	adc	r25, r25
    337a:	dc 01       	movw	r26, r24
    337c:	aa 0f       	add	r26, r26
    337e:	bb 1f       	adc	r27, r27
    3380:	aa 0f       	add	r26, r26
    3382:	bb 1f       	adc	r27, r27
    3384:	aa 0f       	add	r26, r26
    3386:	bb 1f       	adc	r27, r27
    3388:	8a 0f       	add	r24, r26
    338a:	9b 1f       	adc	r25, r27
    338c:	dc 01       	movw	r26, r24
    338e:	aa 54       	subi	r26, 0x4A	; 74
    3390:	bc 4f       	sbci	r27, 0xFC	; 252
    3392:	b8 a3       	std	Y+32, r27	; 0x20
    3394:	af 8f       	std	Y+31, r26	; 0x1f

        // Initialize Bresenham line and distance counters
        st.counter_x = st.counter_y = st.counter_z = (st.exec_block->step_event_count >> 1);
    3396:	1c 96       	adiw	r26, 0x0c	; 12
    3398:	8d 91       	ld	r24, X+
    339a:	9d 91       	ld	r25, X+
    339c:	0d 90       	ld	r0, X+
    339e:	bc 91       	ld	r27, X
    33a0:	a0 2d       	mov	r26, r0
    33a2:	b6 95       	lsr	r27
    33a4:	a7 95       	ror	r26
    33a6:	97 95       	ror	r25
    33a8:	87 95       	ror	r24
    33aa:	88 87       	std	Y+8, r24	; 0x08
    33ac:	99 87       	std	Y+9, r25	; 0x09
    33ae:	aa 87       	std	Y+10, r26	; 0x0a
    33b0:	bb 87       	std	Y+11, r27	; 0x0b
    33b2:	8c 83       	std	Y+4, r24	; 0x04
    33b4:	9d 83       	std	Y+5, r25	; 0x05
    33b6:	ae 83       	std	Y+6, r26	; 0x06
    33b8:	bf 83       	std	Y+7, r27	; 0x07
    33ba:	88 83       	st	Y, r24
    33bc:	99 83       	std	Y+1, r25	; 0x01
    33be:	aa 83       	std	Y+2, r26	; 0x02
    33c0:	bb 83       	std	Y+3, r27	; 0x03
      }
      #ifdef DEFAULTS_RAMPS_BOARD
        for (i = 0; i < N_AXIS; i++)
          st.dir_outbits[i] = st.exec_block->direction_bits[i] ^ dir_port_invert_mask[i];
      #else
        st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask;
    33c2:	a3 e4       	ldi	r26, 0x43	; 67
    33c4:	b3 e0       	ldi	r27, 0x03	; 3
    33c6:	5f 96       	adiw	r26, 0x1f	; 31
    33c8:	cd 91       	ld	r28, X+
    33ca:	dc 91       	ld	r29, X
    33cc:	90 97       	sbiw	r26, 0x20	; 32
    33ce:	98 89       	ldd	r25, Y+16	; 0x10
    33d0:	80 91 3e 03 	lds	r24, 0x033E	; 0x80033e <dir_port_invert_mask>
    33d4:	89 27       	eor	r24, r25
    33d6:	1f 96       	adiw	r26, 0x0f	; 15
    33d8:	8c 93       	st	X, r24
    33da:	1f 97       	sbiw	r26, 0x0f	; 15
      #endif // Ramps Board

      #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
        // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
        st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.exec_segment->amass_level;
    33dc:	48 81       	ld	r20, Y
    33de:	59 81       	ldd	r21, Y+1	; 0x01
    33e0:	6a 81       	ldd	r22, Y+2	; 0x02
    33e2:	7b 81       	ldd	r23, Y+3	; 0x03
    33e4:	05 80       	ldd	r0, Z+5	; 0x05
    33e6:	04 c0       	rjmp	.+8      	; 0x33f0 <__vector_17+0x13a>
    33e8:	76 95       	lsr	r23
    33ea:	67 95       	ror	r22
    33ec:	57 95       	ror	r21
    33ee:	47 95       	ror	r20
    33f0:	0a 94       	dec	r0
    33f2:	d2 f7       	brpl	.-12     	; 0x33e8 <__vector_17+0x132>
    33f4:	50 96       	adiw	r26, 0x10	; 16
    33f6:	4d 93       	st	X+, r20
    33f8:	5d 93       	st	X+, r21
    33fa:	6d 93       	st	X+, r22
    33fc:	7c 93       	st	X, r23
    33fe:	53 97       	sbiw	r26, 0x13	; 19
        st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.exec_segment->amass_level;
    3400:	4c 81       	ldd	r20, Y+4	; 0x04
    3402:	5d 81       	ldd	r21, Y+5	; 0x05
    3404:	6e 81       	ldd	r22, Y+6	; 0x06
    3406:	7f 81       	ldd	r23, Y+7	; 0x07
    3408:	05 80       	ldd	r0, Z+5	; 0x05
    340a:	04 c0       	rjmp	.+8      	; 0x3414 <__vector_17+0x15e>
    340c:	76 95       	lsr	r23
    340e:	67 95       	ror	r22
    3410:	57 95       	ror	r21
    3412:	47 95       	ror	r20
    3414:	0a 94       	dec	r0
    3416:	d2 f7       	brpl	.-12     	; 0x340c <__vector_17+0x156>
    3418:	54 96       	adiw	r26, 0x14	; 20
    341a:	4d 93       	st	X+, r20
    341c:	5d 93       	st	X+, r21
    341e:	6d 93       	st	X+, r22
    3420:	7c 93       	st	X, r23
    3422:	57 97       	sbiw	r26, 0x17	; 23
        st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
    3424:	48 85       	ldd	r20, Y+8	; 0x08
    3426:	59 85       	ldd	r21, Y+9	; 0x09
    3428:	6a 85       	ldd	r22, Y+10	; 0x0a
    342a:	7b 85       	ldd	r23, Y+11	; 0x0b
    342c:	05 80       	ldd	r0, Z+5	; 0x05
    342e:	04 c0       	rjmp	.+8      	; 0x3438 <__vector_17+0x182>
    3430:	76 95       	lsr	r23
    3432:	67 95       	ror	r22
    3434:	57 95       	ror	r21
    3436:	47 95       	ror	r20
    3438:	0a 94       	dec	r0
    343a:	d2 f7       	brpl	.-12     	; 0x3430 <__vector_17+0x17a>
    343c:	58 96       	adiw	r26, 0x18	; 24
    343e:	4d 93       	st	X+, r20
    3440:	5d 93       	st	X+, r21
    3442:	6d 93       	st	X+, r22
    3444:	7c 93       	st	X, r23
    3446:	5b 97       	sbiw	r26, 0x1b	; 27
      #endif

      // Set real-time spindle output as segment is loaded, just prior to the first step.
      spindle_set_speed(st.exec_segment->spindle_pwm);
    3448:	86 81       	ldd	r24, Z+6	; 0x06
    344a:	97 81       	ldd	r25, Z+7	; 0x07
    344c:	74 d8       	rcall	.-3864   	; 0x2536 <spindle_set_speed>
    344e:	0f c0       	rjmp	.+30     	; 0x346e <__vector_17+0x1b8>

    } else {
      // Segment buffer empty. Shutdown.
      st_go_idle();
    3450:	04 df       	rcall	.-504    	; 0x325a <st_go_idle>
      // Ensure pwm is set properly upon completion of rate-controlled motion.
      if (st.exec_block->is_pwm_rate_adjusted) { spindle_set_speed(SPINDLE_PWM_OFF_VALUE); }
    3452:	e0 91 62 03 	lds	r30, 0x0362	; 0x800362 <st+0x1f>
    3456:	f0 91 63 03 	lds	r31, 0x0363	; 0x800363 <st+0x20>
    345a:	81 89       	ldd	r24, Z+17	; 0x11
    345c:	88 23       	and	r24, r24
    345e:	19 f0       	breq	.+6      	; 0x3466 <__vector_17+0x1b0>
    3460:	80 e0       	ldi	r24, 0x00	; 0
    3462:	90 e0       	ldi	r25, 0x00	; 0
    3464:	68 d8       	rcall	.-3888   	; 0x2536 <spindle_set_speed>
      system_set_exec_state_flag(EXEC_CYCLE_STOP); // Flag main program for cycle end
    3466:	84 e0       	ldi	r24, 0x04	; 4
    3468:	0e 94 95 3b 	call	0x772a	; 0x772a <system_set_exec_state_flag>
      return; // Nothing to do but exit.
    346c:	0d c1       	rjmp	.+538    	; 0x3688 <__vector_17+0x3d2>
    }
  }


  // Check probing state.
  if (sys_probe_state == PROBE_ACTIVE) { probe_state_monitor(); }
    346e:	80 91 32 0c 	lds	r24, 0x0C32	; 0x800c32 <sys_probe_state>
    3472:	81 30       	cpi	r24, 0x01	; 1
    3474:	11 f4       	brne	.+4      	; 0x347a <__vector_17+0x1c4>
    3476:	0e 94 d7 34 	call	0x69ae	; 0x69ae <probe_state_monitor>
  // Reset step out bits.
  #ifdef DEFAULTS_RAMPS_BOARD
    for (i = 0; i < N_AXIS; i++)
      st.step_outbits[i] = 0;
  #else
    st.step_outbits = 0;
    347a:	e3 e4       	ldi	r30, 0x43	; 67
    347c:	f3 e0       	ldi	r31, 0x03	; 3
    347e:	16 86       	std	Z+14, r1	; 0x0e
  #endif // Ramps Board

  // Execute step displacement profile by Bresenham line algorithm
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_x += st.steps[X_AXIS];
    3480:	40 81       	ld	r20, Z
    3482:	51 81       	ldd	r21, Z+1	; 0x01
    3484:	62 81       	ldd	r22, Z+2	; 0x02
    3486:	73 81       	ldd	r23, Z+3	; 0x03
    3488:	80 89       	ldd	r24, Z+16	; 0x10
    348a:	91 89       	ldd	r25, Z+17	; 0x11
    348c:	a2 89       	ldd	r26, Z+18	; 0x12
    348e:	b3 89       	ldd	r27, Z+19	; 0x13
    3490:	84 0f       	add	r24, r20
    3492:	95 1f       	adc	r25, r21
    3494:	a6 1f       	adc	r26, r22
    3496:	b7 1f       	adc	r27, r23
    3498:	80 83       	st	Z, r24
    349a:	91 83       	std	Z+1, r25	; 0x01
    349c:	a2 83       	std	Z+2, r26	; 0x02
    349e:	b3 83       	std	Z+3, r27	; 0x03
      st.counter_x -= st.exec_block->step_event_count;
      if (st.exec_block->direction_bits[X_AXIS] & (1<<DIRECTION_BIT(X_AXIS))) { sys_position[X_AXIS]--; }
      else { sys_position[X_AXIS]++; }
    }
  #else
    if (st.counter_x > st.exec_block->step_event_count) {
    34a0:	07 8c       	ldd	r0, Z+31	; 0x1f
    34a2:	f0 a1       	ldd	r31, Z+32	; 0x20
    34a4:	e0 2d       	mov	r30, r0
    34a6:	44 85       	ldd	r20, Z+12	; 0x0c
    34a8:	55 85       	ldd	r21, Z+13	; 0x0d
    34aa:	66 85       	ldd	r22, Z+14	; 0x0e
    34ac:	77 85       	ldd	r23, Z+15	; 0x0f
    34ae:	48 17       	cp	r20, r24
    34b0:	59 07       	cpc	r21, r25
    34b2:	6a 07       	cpc	r22, r26
    34b4:	7b 07       	cpc	r23, r27
    34b6:	70 f5       	brcc	.+92     	; 0x3514 <__vector_17+0x25e>
      st.step_outbits |= (1<<X_STEP_BIT);
    34b8:	c3 e4       	ldi	r28, 0x43	; 67
    34ba:	d3 e0       	ldi	r29, 0x03	; 3
    34bc:	24 e0       	ldi	r18, 0x04	; 4
    34be:	2e 87       	std	Y+14, r18	; 0x0e
      st.counter_x -= st.exec_block->step_event_count;
    34c0:	44 85       	ldd	r20, Z+12	; 0x0c
    34c2:	55 85       	ldd	r21, Z+13	; 0x0d
    34c4:	66 85       	ldd	r22, Z+14	; 0x0e
    34c6:	77 85       	ldd	r23, Z+15	; 0x0f
    34c8:	84 1b       	sub	r24, r20
    34ca:	95 0b       	sbc	r25, r21
    34cc:	a6 0b       	sbc	r26, r22
    34ce:	b7 0b       	sbc	r27, r23
    34d0:	88 83       	st	Y, r24
    34d2:	99 83       	std	Y+1, r25	; 0x01
    34d4:	aa 83       	std	Y+2, r26	; 0x02
    34d6:	bb 83       	std	Y+3, r27	; 0x03
      if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys_position[X_AXIS]--; }
    34d8:	80 89       	ldd	r24, Z+16	; 0x10
    34da:	88 23       	and	r24, r24
    34dc:	74 f4       	brge	.+28     	; 0x34fa <__vector_17+0x244>
    34de:	c3 e4       	ldi	r28, 0x43	; 67
    34e0:	dc e0       	ldi	r29, 0x0C	; 12
    34e2:	88 81       	ld	r24, Y
    34e4:	99 81       	ldd	r25, Y+1	; 0x01
    34e6:	aa 81       	ldd	r26, Y+2	; 0x02
    34e8:	bb 81       	ldd	r27, Y+3	; 0x03
    34ea:	01 97       	sbiw	r24, 0x01	; 1
    34ec:	a1 09       	sbc	r26, r1
    34ee:	b1 09       	sbc	r27, r1
    34f0:	88 83       	st	Y, r24
    34f2:	99 83       	std	Y+1, r25	; 0x01
    34f4:	aa 83       	std	Y+2, r26	; 0x02
    34f6:	bb 83       	std	Y+3, r27	; 0x03
    34f8:	0d c0       	rjmp	.+26     	; 0x3514 <__vector_17+0x25e>
      else { sys_position[X_AXIS]++; }
    34fa:	c3 e4       	ldi	r28, 0x43	; 67
    34fc:	dc e0       	ldi	r29, 0x0C	; 12
    34fe:	88 81       	ld	r24, Y
    3500:	99 81       	ldd	r25, Y+1	; 0x01
    3502:	aa 81       	ldd	r26, Y+2	; 0x02
    3504:	bb 81       	ldd	r27, Y+3	; 0x03
    3506:	01 96       	adiw	r24, 0x01	; 1
    3508:	a1 1d       	adc	r26, r1
    350a:	b1 1d       	adc	r27, r1
    350c:	88 83       	st	Y, r24
    350e:	99 83       	std	Y+1, r25	; 0x01
    3510:	aa 83       	std	Y+2, r26	; 0x02
    3512:	bb 83       	std	Y+3, r27	; 0x03
    }
  #endif // Ramps Board

  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_y += st.steps[Y_AXIS];
    3514:	c3 e4       	ldi	r28, 0x43	; 67
    3516:	d3 e0       	ldi	r29, 0x03	; 3
    3518:	4c 81       	ldd	r20, Y+4	; 0x04
    351a:	5d 81       	ldd	r21, Y+5	; 0x05
    351c:	6e 81       	ldd	r22, Y+6	; 0x06
    351e:	7f 81       	ldd	r23, Y+7	; 0x07
    3520:	8c 89       	ldd	r24, Y+20	; 0x14
    3522:	9d 89       	ldd	r25, Y+21	; 0x15
    3524:	ae 89       	ldd	r26, Y+22	; 0x16
    3526:	bf 89       	ldd	r27, Y+23	; 0x17
    3528:	84 0f       	add	r24, r20
    352a:	95 1f       	adc	r25, r21
    352c:	a6 1f       	adc	r26, r22
    352e:	b7 1f       	adc	r27, r23
    3530:	8c 83       	std	Y+4, r24	; 0x04
    3532:	9d 83       	std	Y+5, r25	; 0x05
    3534:	ae 83       	std	Y+6, r26	; 0x06
    3536:	bf 83       	std	Y+7, r27	; 0x07
      st.counter_y -= st.exec_block->step_event_count;
      if (st.exec_block->direction_bits[Y_AXIS] & (1<<DIRECTION_BIT(Y_AXIS))) { sys_position[Y_AXIS]--; }
      else { sys_position[Y_AXIS]++; }
    }
  #else
    if (st.counter_y > st.exec_block->step_event_count) {
    3538:	44 85       	ldd	r20, Z+12	; 0x0c
    353a:	55 85       	ldd	r21, Z+13	; 0x0d
    353c:	66 85       	ldd	r22, Z+14	; 0x0e
    353e:	77 85       	ldd	r23, Z+15	; 0x0f
    3540:	48 17       	cp	r20, r24
    3542:	59 07       	cpc	r21, r25
    3544:	6a 07       	cpc	r22, r26
    3546:	7b 07       	cpc	r23, r27
    3548:	68 f5       	brcc	.+90     	; 0x35a4 <__vector_17+0x2ee>
      st.step_outbits |= (1<<Y_STEP_BIT);
    354a:	2e 85       	ldd	r18, Y+14	; 0x0e
    354c:	28 60       	ori	r18, 0x08	; 8
    354e:	2e 87       	std	Y+14, r18	; 0x0e
      st.counter_y -= st.exec_block->step_event_count;
    3550:	44 85       	ldd	r20, Z+12	; 0x0c
    3552:	55 85       	ldd	r21, Z+13	; 0x0d
    3554:	66 85       	ldd	r22, Z+14	; 0x0e
    3556:	77 85       	ldd	r23, Z+15	; 0x0f
    3558:	84 1b       	sub	r24, r20
    355a:	95 0b       	sbc	r25, r21
    355c:	a6 0b       	sbc	r26, r22
    355e:	b7 0b       	sbc	r27, r23
    3560:	8c 83       	std	Y+4, r24	; 0x04
    3562:	9d 83       	std	Y+5, r25	; 0x05
    3564:	ae 83       	std	Y+6, r26	; 0x06
    3566:	bf 83       	std	Y+7, r27	; 0x07
      if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys_position[Y_AXIS]--; }
    3568:	80 89       	ldd	r24, Z+16	; 0x10
    356a:	86 ff       	sbrs	r24, 6
    356c:	0e c0       	rjmp	.+28     	; 0x358a <__vector_17+0x2d4>
    356e:	c3 e4       	ldi	r28, 0x43	; 67
    3570:	dc e0       	ldi	r29, 0x0C	; 12
    3572:	8c 81       	ldd	r24, Y+4	; 0x04
    3574:	9d 81       	ldd	r25, Y+5	; 0x05
    3576:	ae 81       	ldd	r26, Y+6	; 0x06
    3578:	bf 81       	ldd	r27, Y+7	; 0x07
    357a:	01 97       	sbiw	r24, 0x01	; 1
    357c:	a1 09       	sbc	r26, r1
    357e:	b1 09       	sbc	r27, r1
    3580:	8c 83       	std	Y+4, r24	; 0x04
    3582:	9d 83       	std	Y+5, r25	; 0x05
    3584:	ae 83       	std	Y+6, r26	; 0x06
    3586:	bf 83       	std	Y+7, r27	; 0x07
    3588:	0d c0       	rjmp	.+26     	; 0x35a4 <__vector_17+0x2ee>
      else { sys_position[Y_AXIS]++; }
    358a:	c3 e4       	ldi	r28, 0x43	; 67
    358c:	dc e0       	ldi	r29, 0x0C	; 12
    358e:	8c 81       	ldd	r24, Y+4	; 0x04
    3590:	9d 81       	ldd	r25, Y+5	; 0x05
    3592:	ae 81       	ldd	r26, Y+6	; 0x06
    3594:	bf 81       	ldd	r27, Y+7	; 0x07
    3596:	01 96       	adiw	r24, 0x01	; 1
    3598:	a1 1d       	adc	r26, r1
    359a:	b1 1d       	adc	r27, r1
    359c:	8c 83       	std	Y+4, r24	; 0x04
    359e:	9d 83       	std	Y+5, r25	; 0x05
    35a0:	ae 83       	std	Y+6, r26	; 0x06
    35a2:	bf 83       	std	Y+7, r27	; 0x07
    }
  #endif // Ramps Board
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_z += st.steps[Z_AXIS];
    35a4:	c3 e4       	ldi	r28, 0x43	; 67
    35a6:	d3 e0       	ldi	r29, 0x03	; 3
    35a8:	48 85       	ldd	r20, Y+8	; 0x08
    35aa:	59 85       	ldd	r21, Y+9	; 0x09
    35ac:	6a 85       	ldd	r22, Y+10	; 0x0a
    35ae:	7b 85       	ldd	r23, Y+11	; 0x0b
    35b0:	88 8d       	ldd	r24, Y+24	; 0x18
    35b2:	99 8d       	ldd	r25, Y+25	; 0x19
    35b4:	aa 8d       	ldd	r26, Y+26	; 0x1a
    35b6:	bb 8d       	ldd	r27, Y+27	; 0x1b
    35b8:	84 0f       	add	r24, r20
    35ba:	95 1f       	adc	r25, r21
    35bc:	a6 1f       	adc	r26, r22
    35be:	b7 1f       	adc	r27, r23
    35c0:	88 87       	std	Y+8, r24	; 0x08
    35c2:	99 87       	std	Y+9, r25	; 0x09
    35c4:	aa 87       	std	Y+10, r26	; 0x0a
    35c6:	bb 87       	std	Y+11, r27	; 0x0b
      st.counter_z -= st.exec_block->step_event_count;
      if (st.exec_block->direction_bits[Z_AXIS] & (1<<DIRECTION_BIT(Z_AXIS))) { sys_position[Z_AXIS]--; }
      else { sys_position[Z_AXIS]++; }
    }
  #else
    if (st.counter_z > st.exec_block->step_event_count) {
    35c8:	44 85       	ldd	r20, Z+12	; 0x0c
    35ca:	55 85       	ldd	r21, Z+13	; 0x0d
    35cc:	66 85       	ldd	r22, Z+14	; 0x0e
    35ce:	77 85       	ldd	r23, Z+15	; 0x0f
    35d0:	48 17       	cp	r20, r24
    35d2:	59 07       	cpc	r21, r25
    35d4:	6a 07       	cpc	r22, r26
    35d6:	7b 07       	cpc	r23, r27
    35d8:	68 f5       	brcc	.+90     	; 0x3634 <__vector_17+0x37e>
      st.step_outbits |= (1<<Z_STEP_BIT);
    35da:	2e 85       	ldd	r18, Y+14	; 0x0e
    35dc:	20 61       	ori	r18, 0x10	; 16
    35de:	2e 87       	std	Y+14, r18	; 0x0e
      st.counter_z -= st.exec_block->step_event_count;
    35e0:	44 85       	ldd	r20, Z+12	; 0x0c
    35e2:	55 85       	ldd	r21, Z+13	; 0x0d
    35e4:	66 85       	ldd	r22, Z+14	; 0x0e
    35e6:	77 85       	ldd	r23, Z+15	; 0x0f
    35e8:	84 1b       	sub	r24, r20
    35ea:	95 0b       	sbc	r25, r21
    35ec:	a6 0b       	sbc	r26, r22
    35ee:	b7 0b       	sbc	r27, r23
    35f0:	88 87       	std	Y+8, r24	; 0x08
    35f2:	99 87       	std	Y+9, r25	; 0x09
    35f4:	aa 87       	std	Y+10, r26	; 0x0a
    35f6:	bb 87       	std	Y+11, r27	; 0x0b
      if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys_position[Z_AXIS]--; }
    35f8:	80 89       	ldd	r24, Z+16	; 0x10
    35fa:	85 ff       	sbrs	r24, 5
    35fc:	0e c0       	rjmp	.+28     	; 0x361a <__vector_17+0x364>
    35fe:	e3 e4       	ldi	r30, 0x43	; 67
    3600:	fc e0       	ldi	r31, 0x0C	; 12
    3602:	80 85       	ldd	r24, Z+8	; 0x08
    3604:	91 85       	ldd	r25, Z+9	; 0x09
    3606:	a2 85       	ldd	r26, Z+10	; 0x0a
    3608:	b3 85       	ldd	r27, Z+11	; 0x0b
    360a:	01 97       	sbiw	r24, 0x01	; 1
    360c:	a1 09       	sbc	r26, r1
    360e:	b1 09       	sbc	r27, r1
    3610:	80 87       	std	Z+8, r24	; 0x08
    3612:	91 87       	std	Z+9, r25	; 0x09
    3614:	a2 87       	std	Z+10, r26	; 0x0a
    3616:	b3 87       	std	Z+11, r27	; 0x0b
    3618:	0d c0       	rjmp	.+26     	; 0x3634 <__vector_17+0x37e>
      else { sys_position[Z_AXIS]++; }
    361a:	e3 e4       	ldi	r30, 0x43	; 67
    361c:	fc e0       	ldi	r31, 0x0C	; 12
    361e:	80 85       	ldd	r24, Z+8	; 0x08
    3620:	91 85       	ldd	r25, Z+9	; 0x09
    3622:	a2 85       	ldd	r26, Z+10	; 0x0a
    3624:	b3 85       	ldd	r27, Z+11	; 0x0b
    3626:	01 96       	adiw	r24, 0x01	; 1
    3628:	a1 1d       	adc	r26, r1
    362a:	b1 1d       	adc	r27, r1
    362c:	80 87       	std	Z+8, r24	; 0x08
    362e:	91 87       	std	Z+9, r25	; 0x09
    3630:	a2 87       	std	Z+10, r26	; 0x0a
    3632:	b3 87       	std	Z+11, r27	; 0x0b
  // During a homing cycle, lock out and prevent desired axes from moving.
  #ifdef DEFAULTS_RAMPS_BOARD
    for (i = 0; i < N_AXIS; i++)
    if (sys.state == STATE_HOMING) { st.step_outbits[i] &= sys.homing_axis_lock[i]; }
  #else
    if (sys.state == STATE_HOMING) { st.step_outbits &= sys.homing_axis_lock; }
    3634:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    3638:	84 30       	cpi	r24, 0x04	; 4
    363a:	39 f4       	brne	.+14     	; 0x364a <__vector_17+0x394>
    363c:	e3 e4       	ldi	r30, 0x43	; 67
    363e:	f3 e0       	ldi	r31, 0x03	; 3
    3640:	96 85       	ldd	r25, Z+14	; 0x0e
    3642:	80 91 24 0c 	lds	r24, 0x0C24	; 0x800c24 <sys+0x6>
    3646:	89 23       	and	r24, r25
    3648:	86 87       	std	Z+14, r24	; 0x0e
  #endif // Ramps Board
  st.step_count--; // Decrement step events count
    364a:	e3 e4       	ldi	r30, 0x43	; 67
    364c:	f3 e0       	ldi	r31, 0x03	; 3
    364e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3650:	95 8d       	ldd	r25, Z+29	; 0x1d
    3652:	01 97       	sbiw	r24, 0x01	; 1
    3654:	95 8f       	std	Z+29, r25	; 0x1d
    3656:	84 8f       	std	Z+28, r24	; 0x1c
  if (st.step_count == 0) {
    3658:	89 2b       	or	r24, r25
    365a:	69 f4       	brne	.+26     	; 0x3676 <__vector_17+0x3c0>
    // Segment is complete. Discard current segment and advance segment indexing.
    st.exec_segment = NULL;
    365c:	10 92 65 03 	sts	0x0365, r1	; 0x800365 <st+0x22>
    3660:	10 92 64 03 	sts	0x0364, r1	; 0x800364 <st+0x21>
    if ( ++segment_buffer_tail == SEGMENT_BUFFER_SIZE) { segment_buffer_tail = 0; }
    3664:	80 91 42 03 	lds	r24, 0x0342	; 0x800342 <segment_buffer_tail>
    3668:	8f 5f       	subi	r24, 0xFF	; 255
    366a:	80 93 42 03 	sts	0x0342, r24	; 0x800342 <segment_buffer_tail>
    366e:	8a 30       	cpi	r24, 0x0A	; 10
    3670:	11 f4       	brne	.+4      	; 0x3676 <__vector_17+0x3c0>
    3672:	10 92 42 03 	sts	0x0342, r1	; 0x800342 <segment_buffer_tail>
  }
  #ifdef DEFAULTS_RAMPS_BOARD
    for (i = 0; i < N_AXIS; i++)
      st.step_outbits[i] ^= step_port_invert_mask[i];  // Apply step port invert mask
  #else
    st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask
    3676:	e3 e4       	ldi	r30, 0x43	; 67
    3678:	f3 e0       	ldi	r31, 0x03	; 3
    367a:	96 85       	ldd	r25, Z+14	; 0x0e
    367c:	80 91 3f 03 	lds	r24, 0x033F	; 0x80033f <step_port_invert_mask>
    3680:	89 27       	eor	r24, r25
    3682:	86 87       	std	Z+14, r24	; 0x0e
  #endif // Ramps Board
  busy = false;
    3684:	10 92 3d 03 	sts	0x033D, r1	; 0x80033d <busy>
}
    3688:	ff 91       	pop	r31
    368a:	ef 91       	pop	r30
    368c:	df 91       	pop	r29
    368e:	cf 91       	pop	r28
    3690:	bf 91       	pop	r27
    3692:	af 91       	pop	r26
    3694:	9f 91       	pop	r25
    3696:	8f 91       	pop	r24
    3698:	7f 91       	pop	r23
    369a:	6f 91       	pop	r22
    369c:	5f 91       	pop	r21
    369e:	4f 91       	pop	r20
    36a0:	3f 91       	pop	r19
    36a2:	2f 91       	pop	r18
    36a4:	0f 90       	pop	r0
    36a6:	0b be       	out	0x3b, r0	; 59
    36a8:	0f 90       	pop	r0
    36aa:	0f be       	out	0x3f, r0	; 63
    36ac:	0f 90       	pop	r0
    36ae:	1f 90       	pop	r1
    36b0:	18 95       	reti

000036b2 <__vector_23>:
*/
// This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute
// a step. This ISR resets the motor port after a short period (settings.pulse_microseconds)
// completing one step cycle.
ISR(TIMER0_OVF_vect)
{
    36b2:	1f 92       	push	r1
    36b4:	0f 92       	push	r0
    36b6:	0f b6       	in	r0, 0x3f	; 63
    36b8:	0f 92       	push	r0
    36ba:	11 24       	eor	r1, r1
    36bc:	8f 93       	push	r24
    36be:	9f 93       	push	r25
  #ifdef DEFAULTS_RAMPS_BOARD
    STEP_PORT(0) = (STEP_PORT(0) & ~(1 << STEP_BIT(0))) | step_port_invert_mask[0];
    STEP_PORT(1) = (STEP_PORT(1) & ~(1 << STEP_BIT(1))) | step_port_invert_mask[1];
    STEP_PORT(2) = (STEP_PORT(2) & ~(1 << STEP_BIT(2))) | step_port_invert_mask[2];
  #else
    STEP_PORT = (STEP_PORT & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK);
    36c0:	82 b1       	in	r24, 0x02	; 2
    36c2:	90 91 3f 03 	lds	r25, 0x033F	; 0x80033f <step_port_invert_mask>
    36c6:	9c 71       	andi	r25, 0x1C	; 28
    36c8:	83 7e       	andi	r24, 0xE3	; 227
    36ca:	89 2b       	or	r24, r25
    36cc:	82 b9       	out	0x02, r24	; 2
  #endif // Ramps Board
  TCCR0B = 0; // Disable Timer0 to prevent re-entering this interrupt when it's not needed.
    36ce:	15 bc       	out	0x25, r1	; 37
}
    36d0:	9f 91       	pop	r25
    36d2:	8f 91       	pop	r24
    36d4:	0f 90       	pop	r0
    36d6:	0f be       	out	0x3f, r0	; 63
    36d8:	0f 90       	pop	r0
    36da:	1f 90       	pop	r1
    36dc:	18 95       	reti

000036de <st_generate_step_dir_invert_masks>:
#endif


// Generates the step and direction port invert masks used in the Stepper Interrupt Driver.
void st_generate_step_dir_invert_masks()
{
    36de:	ef 92       	push	r14
    36e0:	ff 92       	push	r15
    36e2:	0f 93       	push	r16
    36e4:	1f 93       	push	r17
    36e6:	cf 93       	push	r28
    36e8:	df 93       	push	r29

      if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask[idx] = get_direction_pin_mask(idx); }
      else { dir_port_invert_mask[idx] = 0; }
    }
  #else
    step_port_invert_mask = 0;
    36ea:	10 92 3f 03 	sts	0x033F, r1	; 0x80033f <step_port_invert_mask>
    dir_port_invert_mask = 0;
    36ee:	10 92 3e 03 	sts	0x033E, r1	; 0x80033e <dir_port_invert_mask>
    36f2:	c0 e0       	ldi	r28, 0x00	; 0
    36f4:	d0 e0       	ldi	r29, 0x00	; 0
    for (idx=0; idx<N_AXIS; idx++) {
      if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    36f6:	00 ed       	ldi	r16, 0xD0	; 208
    36f8:	1e e0       	ldi	r17, 0x0E	; 14
    36fa:	ec 2e       	mov	r14, r28
    36fc:	fc 2e       	mov	r15, r28
    36fe:	f8 01       	movw	r30, r16
    3700:	81 a9       	ldd	r24, Z+49	; 0x31
    3702:	90 e0       	ldi	r25, 0x00	; 0
    3704:	0c 2e       	mov	r0, r28
    3706:	02 c0       	rjmp	.+4      	; 0x370c <st_generate_step_dir_invert_masks+0x2e>
    3708:	95 95       	asr	r25
    370a:	87 95       	ror	r24
    370c:	0a 94       	dec	r0
    370e:	e2 f7       	brpl	.-8      	; 0x3708 <st_generate_step_dir_invert_masks+0x2a>
    3710:	80 ff       	sbrs	r24, 0
    3712:	08 c0       	rjmp	.+16     	; 0x3724 <st_generate_step_dir_invert_masks+0x46>
    3714:	8c 2f       	mov	r24, r28
    3716:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <get_step_pin_mask>
    371a:	90 91 3f 03 	lds	r25, 0x033F	; 0x80033f <step_port_invert_mask>
    371e:	89 2b       	or	r24, r25
    3720:	80 93 3f 03 	sts	0x033F, r24	; 0x80033f <step_port_invert_mask>
      if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    3724:	f8 01       	movw	r30, r16
    3726:	82 a9       	ldd	r24, Z+50	; 0x32
    3728:	90 e0       	ldi	r25, 0x00	; 0
    372a:	02 c0       	rjmp	.+4      	; 0x3730 <st_generate_step_dir_invert_masks+0x52>
    372c:	95 95       	asr	r25
    372e:	87 95       	ror	r24
    3730:	fa 94       	dec	r15
    3732:	e2 f7       	brpl	.-8      	; 0x372c <st_generate_step_dir_invert_masks+0x4e>
    3734:	80 ff       	sbrs	r24, 0
    3736:	08 c0       	rjmp	.+16     	; 0x3748 <st_generate_step_dir_invert_masks+0x6a>
    3738:	8e 2d       	mov	r24, r14
    373a:	0e 94 b1 27 	call	0x4f62	; 0x4f62 <get_direction_pin_mask>
    373e:	90 91 3e 03 	lds	r25, 0x033E	; 0x80033e <dir_port_invert_mask>
    3742:	89 2b       	or	r24, r25
    3744:	80 93 3e 03 	sts	0x033E, r24	; 0x80033e <dir_port_invert_mask>
    3748:	21 96       	adiw	r28, 0x01	; 1
      else { dir_port_invert_mask[idx] = 0; }
    }
  #else
    step_port_invert_mask = 0;
    dir_port_invert_mask = 0;
    for (idx=0; idx<N_AXIS; idx++) {
    374a:	c3 30       	cpi	r28, 0x03	; 3
    374c:	d1 05       	cpc	r29, r1
    374e:	a9 f6       	brne	.-86     	; 0x36fa <st_generate_step_dir_invert_masks+0x1c>
      if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
      if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    }
  #endif // Ramps Board
}
    3750:	df 91       	pop	r29
    3752:	cf 91       	pop	r28
    3754:	1f 91       	pop	r17
    3756:	0f 91       	pop	r16
    3758:	ff 90       	pop	r15
    375a:	ef 90       	pop	r14
    375c:	08 95       	ret

0000375e <st_reset>:


// Reset and clear stepper subsystem variables
void st_reset()
{
    375e:	cf 93       	push	r28
    3760:	df 93       	push	r29
  #ifdef DEFAULTS_RAMPS_BOARD
    uint8_t idx;
  #endif // Ramps Board

  // Initialize stepper driver idle state.
  st_go_idle();
    3762:	7b dd       	rcall	.-1290   	; 0x325a <st_go_idle>

  // Initialize stepper algorithm variables.
  memset(&prep, 0, sizeof(st_prep_t));
    3764:	81 e3       	ldi	r24, 0x31	; 49
    3766:	e8 e0       	ldi	r30, 0x08	; 8
    3768:	f3 e0       	ldi	r31, 0x03	; 3
    376a:	df 01       	movw	r26, r30
    376c:	1d 92       	st	X+, r1
    376e:	8a 95       	dec	r24
    3770:	e9 f7       	brne	.-6      	; 0x376c <st_reset+0xe>
  memset(&st, 0, sizeof(stepper_t));
    3772:	c3 e4       	ldi	r28, 0x43	; 67
    3774:	d3 e0       	ldi	r29, 0x03	; 3
    3776:	83 e2       	ldi	r24, 0x23	; 35
    3778:	fe 01       	movw	r30, r28
    377a:	11 92       	st	Z+, r1
    377c:	8a 95       	dec	r24
    377e:	e9 f7       	brne	.-6      	; 0x377a <st_reset+0x1c>
  st.exec_segment = NULL;
  pl_block = NULL;  // Planner block pointer used by segment buffer
    3780:	10 92 3c 03 	sts	0x033C, r1	; 0x80033c <pl_block+0x1>
    3784:	10 92 3b 03 	sts	0x033B, r1	; 0x80033b <pl_block>
  segment_buffer_tail = 0;
    3788:	10 92 42 03 	sts	0x0342, r1	; 0x800342 <segment_buffer_tail>
  segment_buffer_head = 0; // empty = tail
    378c:	10 92 41 03 	sts	0x0341, r1	; 0x800341 <segment_buffer_head>
  segment_next_head = 1;
    3790:	81 e0       	ldi	r24, 0x01	; 1
    3792:	80 93 40 03 	sts	0x0340, r24	; 0x800340 <segment_next_head>
  busy = false;
    3796:	10 92 3d 03 	sts	0x033D, r1	; 0x80033d <busy>

  st_generate_step_dir_invert_masks();
    379a:	a1 df       	rcall	.-190    	; 0x36de <st_generate_step_dir_invert_masks>
    DIRECTION_PORT(1) = (DIRECTION_PORT(1) & ~(1 << DIRECTION_BIT(1))) | dir_port_invert_mask[1];
  
    STEP_PORT(2) = (STEP_PORT(2) & ~(1 << STEP_BIT(2))) | step_port_invert_mask[2];
    DIRECTION_PORT(2) = (DIRECTION_PORT(2) & ~(1 << DIRECTION_BIT(2))) | dir_port_invert_mask[2];
  #else
    st.dir_outbits = dir_port_invert_mask; // Initialize direction bits to default.
    379c:	80 91 3e 03 	lds	r24, 0x033E	; 0x80033e <dir_port_invert_mask>
    37a0:	8f 87       	std	Y+15, r24	; 0x0f

    // Initialize step and direction port pins.
    STEP_PORT = (STEP_PORT & ~STEP_MASK) | step_port_invert_mask;
    37a2:	82 b1       	in	r24, 0x02	; 2
    37a4:	83 7e       	andi	r24, 0xE3	; 227
    37a6:	90 91 3f 03 	lds	r25, 0x033F	; 0x80033f <step_port_invert_mask>
    37aa:	89 2b       	or	r24, r25
    37ac:	82 b9       	out	0x02, r24	; 2
    DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | dir_port_invert_mask;
    37ae:	88 b1       	in	r24, 0x08	; 8
    37b0:	8f 71       	andi	r24, 0x1F	; 31
    37b2:	90 91 3e 03 	lds	r25, 0x033E	; 0x80033e <dir_port_invert_mask>
    37b6:	89 2b       	or	r24, r25
    37b8:	88 b9       	out	0x08, r24	; 8
  #endif // Ramps Board
}
    37ba:	df 91       	pop	r29
    37bc:	cf 91       	pop	r28
    37be:	08 95       	ret

000037c0 <stepper_init>:
  
    DIRECTION_DDR(0) |= 1<<DIRECTION_BIT(0);
    DIRECTION_DDR(1) |= 1<<DIRECTION_BIT(1);
    DIRECTION_DDR(2) |= 1<<DIRECTION_BIT(2);
  #else
    STEP_DDR |= STEP_MASK;
    37c0:	81 b1       	in	r24, 0x01	; 1
    37c2:	8c 61       	ori	r24, 0x1C	; 28
    37c4:	81 b9       	out	0x01, r24	; 1
    STEPPERS_DISABLE_DDR |= 1<<STEPPERS_DISABLE_BIT;
    37c6:	27 9a       	sbi	0x04, 7	; 4
    DIRECTION_DDR |= DIRECTION_MASK;
    37c8:	87 b1       	in	r24, 0x07	; 7
    37ca:	80 6e       	ori	r24, 0xE0	; 224
    37cc:	87 b9       	out	0x07, r24	; 7
  #endif // Ramps Board

  // Configure Timer 1: Stepper Driver Interrupt
  TCCR1B &= ~(1<<WGM13); // waveform generation = 0100 = CTC
    37ce:	e1 e8       	ldi	r30, 0x81	; 129
    37d0:	f0 e0       	ldi	r31, 0x00	; 0
    37d2:	80 81       	ld	r24, Z
    37d4:	8f 7e       	andi	r24, 0xEF	; 239
    37d6:	80 83       	st	Z, r24
  TCCR1B |=  (1<<WGM12);
    37d8:	80 81       	ld	r24, Z
    37da:	88 60       	ori	r24, 0x08	; 8
    37dc:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<WGM11) | (1<<WGM10));
    37de:	e0 e8       	ldi	r30, 0x80	; 128
    37e0:	f0 e0       	ldi	r31, 0x00	; 0
    37e2:	80 81       	ld	r24, Z
    37e4:	8c 7f       	andi	r24, 0xFC	; 252
    37e6:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<COM1A1) | (1<<COM1A0) | (1<<COM1B1) | (1<<COM1B0)); // Disconnect OC1 output
    37e8:	80 81       	ld	r24, Z
    37ea:	8f 70       	andi	r24, 0x0F	; 15
    37ec:	80 83       	st	Z, r24
  // TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Set in st_go_idle().
  // TIMSK1 &= ~(1<<OCIE1A);  // Set in st_go_idle().

  // Configure Timer 0: Stepper Port Reset Interrupt
  TIMSK0 &= ~((1<<OCIE0B) | (1<<OCIE0A) | (1<<TOIE0)); // Disconnect OC0 outputs and OVF interrupt.
    37ee:	ee e6       	ldi	r30, 0x6E	; 110
    37f0:	f0 e0       	ldi	r31, 0x00	; 0
    37f2:	80 81       	ld	r24, Z
    37f4:	88 7f       	andi	r24, 0xF8	; 248
    37f6:	80 83       	st	Z, r24
  TCCR0A = 0; // Normal operation
    37f8:	14 bc       	out	0x24, r1	; 36
  TCCR0B = 0; // Disable Timer0 until needed
    37fa:	15 bc       	out	0x25, r1	; 37
  TIMSK0 |= (1<<TOIE0); // Enable Timer0 overflow interrupt
    37fc:	80 81       	ld	r24, Z
    37fe:	81 60       	ori	r24, 0x01	; 1
    3800:	80 83       	st	Z, r24
    3802:	08 95       	ret

00003804 <st_update_plan_block_parameters>:
}


// Called by planner_recalculate() when the executing block is updated by the new plan.
void st_update_plan_block_parameters()
{
    3804:	cf 93       	push	r28
    3806:	df 93       	push	r29
  if (pl_block != NULL) { // Ignore if at start of a new block.
    3808:	c0 91 3b 03 	lds	r28, 0x033B	; 0x80033b <pl_block>
    380c:	d0 91 3c 03 	lds	r29, 0x033C	; 0x80033c <pl_block+0x1>
    3810:	20 97       	sbiw	r28, 0x00	; 0
    3812:	a9 f0       	breq	.+42     	; 0x383e <st_update_plan_block_parameters+0x3a>
    prep.recalculate_flag |= PREP_FLAG_RECALCULATE;
    3814:	e8 e0       	ldi	r30, 0x08	; 8
    3816:	f3 e0       	ldi	r31, 0x03	; 3
    3818:	81 81       	ldd	r24, Z+1	; 0x01
    381a:	81 60       	ori	r24, 0x01	; 1
    381c:	81 83       	std	Z+1, r24	; 0x01
    pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
    381e:	67 89       	ldd	r22, Z+23	; 0x17
    3820:	70 8d       	ldd	r23, Z+24	; 0x18
    3822:	81 8d       	ldd	r24, Z+25	; 0x19
    3824:	92 8d       	ldd	r25, Z+26	; 0x1a
    3826:	9b 01       	movw	r18, r22
    3828:	ac 01       	movw	r20, r24
    382a:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    382e:	6e 8b       	std	Y+22, r22	; 0x16
    3830:	7f 8b       	std	Y+23, r23	; 0x17
    3832:	88 8f       	std	Y+24, r24	; 0x18
    3834:	99 8f       	std	Y+25, r25	; 0x19
    pl_block = NULL; // Flag st_prep_segment() to load and check active velocity profile.
    3836:	10 92 3c 03 	sts	0x033C, r1	; 0x80033c <pl_block+0x1>
    383a:	10 92 3b 03 	sts	0x033B, r1	; 0x80033b <pl_block>
  }
}
    383e:	df 91       	pop	r29
    3840:	cf 91       	pop	r28
    3842:	08 95       	ret

00003844 <st_prep_buffer>:
   longer than the time it takes the stepper algorithm to empty it before refilling it.
   Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer()
{
    3844:	2f 92       	push	r2
    3846:	3f 92       	push	r3
    3848:	4f 92       	push	r4
    384a:	5f 92       	push	r5
    384c:	6f 92       	push	r6
    384e:	7f 92       	push	r7
    3850:	8f 92       	push	r8
    3852:	9f 92       	push	r9
    3854:	af 92       	push	r10
    3856:	bf 92       	push	r11
    3858:	cf 92       	push	r12
    385a:	df 92       	push	r13
    385c:	ef 92       	push	r14
    385e:	ff 92       	push	r15
    3860:	0f 93       	push	r16
    3862:	1f 93       	push	r17
    3864:	cf 93       	push	r28
    3866:	df 93       	push	r29
    3868:	cd b7       	in	r28, 0x3d	; 61
    386a:	de b7       	in	r29, 0x3e	; 62
    386c:	ec 97       	sbiw	r28, 0x3c	; 60
    386e:	0f b6       	in	r0, 0x3f	; 63
    3870:	f8 94       	cli
    3872:	de bf       	out	0x3e, r29	; 62
    3874:	0f be       	out	0x3f, r0	; 63
    3876:	cd bf       	out	0x3d, r28	; 61
  // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }
    3878:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    387c:	80 ff       	sbrs	r24, 0
    387e:	02 c0       	rjmp	.+4      	; 0x3884 <st_prep_buffer+0x40>
    3880:	0c 94 52 24 	jmp	0x48a4	; 0x48a4 <st_prep_buffer+0x1060>
      if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) { pl_block = plan_get_system_motion_block(); }
      else { pl_block = plan_get_current_block(); }
      if (pl_block == NULL) { return; } // No planner blocks. Exit.

      // Check if we need to only recompute the velocity profile or load a new block.
      if (prep.recalculate_flag & PREP_FLAG_RECALCULATE) {
    3884:	0f 2e       	mov	r0, r31
    3886:	f8 e0       	ldi	r31, 0x08	; 8
    3888:	6f 2e       	mov	r6, r31
    388a:	f3 e0       	ldi	r31, 0x03	; 3
    388c:	7f 2e       	mov	r7, r31
    388e:	f0 2d       	mov	r31, r0
          mm_var = mm_remaining - prep.maximum_speed*time_var;
          if (mm_var < prep.decelerate_after) { // End of cruise.
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
    3890:	22 e0       	ldi	r18, 0x02	; 2
    3892:	2a af       	std	Y+58, r18	; 0x3a
    3894:	29 af       	std	Y+57, r18	; 0x39
    3896:	cd c7       	rjmp	.+3994   	; 0x4832 <st_prep_buffer+0xfee>
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }

  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.

    // Determine if we need to load a new planner block or if the block needs to be recomputed.
    if (pl_block == NULL) {
    3898:	80 91 3b 03 	lds	r24, 0x033B	; 0x80033b <pl_block>
    389c:	90 91 3c 03 	lds	r25, 0x033C	; 0x80033c <pl_block+0x1>
    38a0:	89 2b       	or	r24, r25
    38a2:	09 f0       	breq	.+2      	; 0x38a6 <st_prep_buffer+0x62>
    38a4:	11 c3       	rjmp	.+1570   	; 0x3ec8 <st_prep_buffer+0x684>

      // Query planner for a queued block
      if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) { pl_block = plan_get_system_motion_block(); }
    38a6:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    38aa:	82 ff       	sbrs	r24, 2
    38ac:	07 c0       	rjmp	.+14     	; 0x38bc <st_prep_buffer+0x78>
    38ae:	0e 94 52 29 	call	0x52a4	; 0x52a4 <plan_get_system_motion_block>
    38b2:	90 93 3c 03 	sts	0x033C, r25	; 0x80033c <pl_block+0x1>
    38b6:	80 93 3b 03 	sts	0x033B, r24	; 0x80033b <pl_block>
    38ba:	06 c0       	rjmp	.+12     	; 0x38c8 <st_prep_buffer+0x84>
      else { pl_block = plan_get_current_block(); }
    38bc:	0e 94 5b 29 	call	0x52b6	; 0x52b6 <plan_get_current_block>
    38c0:	90 93 3c 03 	sts	0x033C, r25	; 0x80033c <pl_block+0x1>
    38c4:	80 93 3b 03 	sts	0x033B, r24	; 0x80033b <pl_block>
      if (pl_block == NULL) { return; } // No planner blocks. Exit.
    38c8:	e0 90 3b 03 	lds	r14, 0x033B	; 0x80033b <pl_block>
    38cc:	f0 90 3c 03 	lds	r15, 0x033C	; 0x80033c <pl_block+0x1>
    38d0:	e1 14       	cp	r14, r1
    38d2:	f1 04       	cpc	r15, r1
    38d4:	09 f4       	brne	.+2      	; 0x38d8 <st_prep_buffer+0x94>
    38d6:	e6 c7       	rjmp	.+4044   	; 0x48a4 <st_prep_buffer+0x1060>

      // Check if we need to only recompute the velocity profile or load a new block.
      if (prep.recalculate_flag & PREP_FLAG_RECALCULATE) {
    38d8:	d3 01       	movw	r26, r6
    38da:	11 96       	adiw	r26, 0x01	; 1
    38dc:	1c 91       	ld	r17, X
    38de:	11 97       	sbiw	r26, 0x01	; 1
    38e0:	81 2f       	mov	r24, r17
    38e2:	81 70       	andi	r24, 0x01	; 1
    38e4:	10 ff       	sbrs	r17, 0
    38e6:	03 c0       	rjmp	.+6      	; 0x38ee <st_prep_buffer+0xaa>

        #ifdef PARKING_ENABLE
          if (prep.recalculate_flag & PREP_FLAG_PARKING) { prep.recalculate_flag &= ~(PREP_FLAG_RECALCULATE); }
          else { prep.recalculate_flag = false; }
        #else
          prep.recalculate_flag = false;
    38e8:	11 96       	adiw	r26, 0x01	; 1
    38ea:	1c 92       	st	X, r1
    38ec:	eb c0       	rjmp	.+470    	; 0x3ac4 <st_prep_buffer+0x280>


// Increments the step segment buffer block data ring buffer.
static uint8_t st_next_block_index(uint8_t block_index)
{
  block_index++;
    38ee:	f3 01       	movw	r30, r6
    38f0:	90 81       	ld	r25, Z
    38f2:	9f 5f       	subi	r25, 0xFF	; 255
  if ( block_index == (SEGMENT_BUFFER_SIZE-1) ) { return(0); }
    38f4:	99 30       	cpi	r25, 0x09	; 9
    38f6:	09 f0       	breq	.+2      	; 0x38fa <st_prep_buffer+0xb6>
  return(block_index);
    38f8:	89 2f       	mov	r24, r25
        #endif

      } else {

        // Load the Bresenham stepping data for the block.
        prep.st_block_index = st_next_block_index(prep.st_block_index);
    38fa:	d3 01       	movw	r26, r6
    38fc:	8c 93       	st	X, r24

        // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
        // when the segment buffer completes the planner block, it may be discarded when the
        // segment buffer finishes the prepped block, but the stepper ISR is still executing it.
        st_prep_block = &st_block_buffer[prep.st_block_index];
    38fe:	90 e0       	ldi	r25, 0x00	; 0
    3900:	fc 01       	movw	r30, r24
    3902:	ee 0f       	add	r30, r30
    3904:	ff 1f       	adc	r31, r31
    3906:	9f 01       	movw	r18, r30
    3908:	22 0f       	add	r18, r18
    390a:	33 1f       	adc	r19, r19
    390c:	22 0f       	add	r18, r18
    390e:	33 1f       	adc	r19, r19
    3910:	22 0f       	add	r18, r18
    3912:	33 1f       	adc	r19, r19
    3914:	e2 0f       	add	r30, r18
    3916:	f3 1f       	adc	r31, r19
    3918:	ea 54       	subi	r30, 0x4A	; 74
    391a:	fc 4f       	sbci	r31, 0xFC	; 252
    391c:	f0 93 3a 03 	sts	0x033A, r31	; 0x80033a <st_prep_block+0x1>
    3920:	e0 93 39 03 	sts	0x0339, r30	; 0x800339 <st_prep_block>
        #ifdef DEFAULTS_RAMPS_BOARD
          for (idx=0; idx<N_AXIS; idx++) {
            st_prep_block->direction_bits[idx] = pl_block->direction_bits[idx];
          }
        #else
          st_prep_block->direction_bits = pl_block->direction_bits;
    3924:	d7 01       	movw	r26, r14
    3926:	50 96       	adiw	r26, 0x10	; 16
    3928:	2c 91       	ld	r18, X
    392a:	50 97       	sbiw	r26, 0x10	; 16
    392c:	20 8b       	std	Z+16, r18	; 0x10
    392e:	97 01       	movw	r18, r14
    3930:	24 5f       	subi	r18, 0xF4	; 244
    3932:	3f 4f       	sbci	r19, 0xFF	; 255
    3934:	fa 82       	std	Y+2, r15	; 0x02
    3936:	e9 82       	std	Y+1, r14	; 0x01
          st_prep_block->step_event_count = (pl_block->step_event_count << 1);
        #else
          // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS
          // level, such that we never divide beyond the original data anywhere in the algorithm.
          // If the original data is divided, we can lose a step from integer roundoff.
          for (idx=0; idx<N_AXIS; idx++) { st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_AMASS_LEVEL; }
    3938:	4d 91       	ld	r20, X+
    393a:	5d 91       	ld	r21, X+
    393c:	6d 91       	ld	r22, X+
    393e:	7d 91       	ld	r23, X+
    3940:	44 0f       	add	r20, r20
    3942:	55 1f       	adc	r21, r21
    3944:	66 1f       	adc	r22, r22
    3946:	77 1f       	adc	r23, r23
    3948:	44 0f       	add	r20, r20
    394a:	55 1f       	adc	r21, r21
    394c:	66 1f       	adc	r22, r22
    394e:	77 1f       	adc	r23, r23
    3950:	44 0f       	add	r20, r20
    3952:	55 1f       	adc	r21, r21
    3954:	66 1f       	adc	r22, r22
    3956:	77 1f       	adc	r23, r23
    3958:	41 93       	st	Z+, r20
    395a:	51 93       	st	Z+, r21
    395c:	61 93       	st	Z+, r22
    395e:	71 93       	st	Z+, r23
    3960:	a2 17       	cp	r26, r18
    3962:	b3 07       	cpc	r27, r19
    3964:	49 f7       	brne	.-46     	; 0x3938 <st_prep_buffer+0xf4>
    3966:	e9 80       	ldd	r14, Y+1	; 0x01
    3968:	fa 80       	ldd	r15, Y+2	; 0x02
          st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
    396a:	88 0f       	add	r24, r24
    396c:	99 1f       	adc	r25, r25
    396e:	fc 01       	movw	r30, r24
    3970:	ee 0f       	add	r30, r30
    3972:	ff 1f       	adc	r31, r31
    3974:	ee 0f       	add	r30, r30
    3976:	ff 1f       	adc	r31, r31
    3978:	ee 0f       	add	r30, r30
    397a:	ff 1f       	adc	r31, r31
    397c:	8e 0f       	add	r24, r30
    397e:	9f 1f       	adc	r25, r31
    3980:	9c 01       	movw	r18, r24
    3982:	2a 54       	subi	r18, 0x4A	; 74
    3984:	3c 4f       	sbci	r19, 0xFC	; 252
    3986:	f7 01       	movw	r30, r14
    3988:	84 85       	ldd	r24, Z+12	; 0x0c
    398a:	95 85       	ldd	r25, Z+13	; 0x0d
    398c:	a6 85       	ldd	r26, Z+14	; 0x0e
    398e:	b7 85       	ldd	r27, Z+15	; 0x0f
    3990:	88 0f       	add	r24, r24
    3992:	99 1f       	adc	r25, r25
    3994:	aa 1f       	adc	r26, r26
    3996:	bb 1f       	adc	r27, r27
    3998:	88 0f       	add	r24, r24
    399a:	99 1f       	adc	r25, r25
    399c:	aa 1f       	adc	r26, r26
    399e:	bb 1f       	adc	r27, r27
    39a0:	88 0f       	add	r24, r24
    39a2:	99 1f       	adc	r25, r25
    39a4:	aa 1f       	adc	r26, r26
    39a6:	bb 1f       	adc	r27, r27
    39a8:	f9 01       	movw	r30, r18
    39aa:	84 87       	std	Z+12, r24	; 0x0c
    39ac:	95 87       	std	Z+13, r25	; 0x0d
    39ae:	a6 87       	std	Z+14, r26	; 0x0e
    39b0:	b7 87       	std	Z+15, r27	; 0x0f
        #endif

        // Initialize segment buffer data for generating the segments.
        prep.steps_remaining = (float)pl_block->step_event_count;
    39b2:	d7 01       	movw	r26, r14
    39b4:	1c 96       	adiw	r26, 0x0c	; 12
    39b6:	6d 91       	ld	r22, X+
    39b8:	7d 91       	ld	r23, X+
    39ba:	8d 91       	ld	r24, X+
    39bc:	9c 91       	ld	r25, X
    39be:	1f 97       	sbiw	r26, 0x0f	; 15
    39c0:	0e 94 05 40 	call	0x800a	; 0x800a <__floatunsisf>
    39c4:	f3 01       	movw	r30, r6
    39c6:	66 83       	std	Z+6, r22	; 0x06
    39c8:	77 83       	std	Z+7, r23	; 0x07
    39ca:	80 87       	std	Z+8, r24	; 0x08
    39cc:	91 87       	std	Z+9, r25	; 0x09
        prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
    39ce:	d7 01       	movw	r26, r14
    39d0:	92 96       	adiw	r26, 0x22	; 34
    39d2:	2d 91       	ld	r18, X+
    39d4:	3d 91       	ld	r19, X+
    39d6:	4d 91       	ld	r20, X+
    39d8:	5c 91       	ld	r21, X
    39da:	95 97       	sbiw	r26, 0x25	; 37
    39dc:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__divsf3>
    39e0:	9b 01       	movw	r18, r22
    39e2:	ac 01       	movw	r20, r24
    39e4:	f3 01       	movw	r30, r6
    39e6:	62 87       	std	Z+10, r22	; 0x0a
    39e8:	73 87       	std	Z+11, r23	; 0x0b
    39ea:	84 87       	std	Z+12, r24	; 0x0c
    39ec:	95 87       	std	Z+13, r25	; 0x0d
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
    39ee:	60 e0       	ldi	r22, 0x00	; 0
    39f0:	70 e0       	ldi	r23, 0x00	; 0
    39f2:	80 ea       	ldi	r24, 0xA0	; 160
    39f4:	9f e3       	ldi	r25, 0x3F	; 63
    39f6:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__divsf3>
    39fa:	d3 01       	movw	r26, r6
    39fc:	1e 96       	adiw	r26, 0x0e	; 14
    39fe:	6d 93       	st	X+, r22
    3a00:	7d 93       	st	X+, r23
    3a02:	8d 93       	st	X+, r24
    3a04:	9c 93       	st	X, r25
    3a06:	51 97       	sbiw	r26, 0x11	; 17
        prep.dt_remainder = 0.0; // Reset for new segment block
    3a08:	f3 01       	movw	r30, r6
    3a0a:	12 82       	std	Z+2, r1	; 0x02
    3a0c:	13 82       	std	Z+3, r1	; 0x03
    3a0e:	14 82       	std	Z+4, r1	; 0x04
    3a10:	15 82       	std	Z+5, r1	; 0x05

        if ((sys.step_control & STEP_CONTROL_EXECUTE_HOLD) || (prep.recalculate_flag & PREP_FLAG_DECEL_OVERRIDE)) {
    3a12:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    3a16:	81 fd       	sbrc	r24, 1
    3a18:	02 c0       	rjmp	.+4      	; 0x3a1e <st_prep_buffer+0x1da>
    3a1a:	13 ff       	sbrs	r17, 3
    3a1c:	1b c0       	rjmp	.+54     	; 0x3a54 <st_prep_buffer+0x210>
          // New block loaded mid-hold. Override planner block entry speed to enforce deceleration.
          prep.current_speed = prep.exit_speed;
    3a1e:	d3 01       	movw	r26, r6
    3a20:	5f 96       	adiw	r26, 0x1f	; 31
    3a22:	6d 91       	ld	r22, X+
    3a24:	7d 91       	ld	r23, X+
    3a26:	8d 91       	ld	r24, X+
    3a28:	9c 91       	ld	r25, X
    3a2a:	92 97       	sbiw	r26, 0x22	; 34
    3a2c:	f3 01       	movw	r30, r6
    3a2e:	67 8b       	std	Z+23, r22	; 0x17
    3a30:	70 8f       	std	Z+24, r23	; 0x18
    3a32:	81 8f       	std	Z+25, r24	; 0x19
    3a34:	92 8f       	std	Z+26, r25	; 0x1a
          pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed;
    3a36:	9b 01       	movw	r18, r22
    3a38:	ac 01       	movw	r20, r24
    3a3a:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    3a3e:	d7 01       	movw	r26, r14
    3a40:	56 96       	adiw	r26, 0x16	; 22
    3a42:	6d 93       	st	X+, r22
    3a44:	7d 93       	st	X+, r23
    3a46:	8d 93       	st	X+, r24
    3a48:	9c 93       	st	X, r25
    3a4a:	59 97       	sbiw	r26, 0x19	; 25
          prep.recalculate_flag &= ~(PREP_FLAG_DECEL_OVERRIDE);
    3a4c:	17 7f       	andi	r17, 0xF7	; 247
    3a4e:	f3 01       	movw	r30, r6
    3a50:	11 83       	std	Z+1, r17	; 0x01
    3a52:	0e c0       	rjmp	.+28     	; 0x3a70 <st_prep_buffer+0x22c>
        } else {
          prep.current_speed = sqrt(pl_block->entry_speed_sqr);
    3a54:	d7 01       	movw	r26, r14
    3a56:	56 96       	adiw	r26, 0x16	; 22
    3a58:	6d 91       	ld	r22, X+
    3a5a:	7d 91       	ld	r23, X+
    3a5c:	8d 91       	ld	r24, X+
    3a5e:	9c 91       	ld	r25, X
    3a60:	59 97       	sbiw	r26, 0x19	; 25
    3a62:	0e 94 30 42 	call	0x8460	; 0x8460 <sqrt>
    3a66:	f3 01       	movw	r30, r6
    3a68:	67 8b       	std	Z+23, r22	; 0x17
    3a6a:	70 8f       	std	Z+24, r23	; 0x18
    3a6c:	81 8f       	std	Z+25, r24	; 0x19
    3a6e:	92 8f       	std	Z+26, r25	; 0x1a
        }
        
        // Setup laser mode variables. PWM rate adjusted motions will always complete a motion with the
        // spindle off. 
        st_prep_block->is_pwm_rate_adjusted = false;
    3a70:	20 91 39 03 	lds	r18, 0x0339	; 0x800339 <st_prep_block>
    3a74:	30 91 3a 03 	lds	r19, 0x033A	; 0x80033a <st_prep_block+0x1>
    3a78:	3a 83       	std	Y+2, r19	; 0x02
    3a7a:	29 83       	std	Y+1, r18	; 0x01
    3a7c:	d9 01       	movw	r26, r18
    3a7e:	51 96       	adiw	r26, 0x11	; 17
    3a80:	1c 92       	st	X, r1
        if (settings.flags & BITFLAG_LASER_MODE) {
    3a82:	e5 e1       	ldi	r30, 0x15	; 21
    3a84:	ff e0       	ldi	r31, 0x0F	; 15
    3a86:	80 81       	ld	r24, Z
    3a88:	81 ff       	sbrs	r24, 1
    3a8a:	1c c0       	rjmp	.+56     	; 0x3ac4 <st_prep_buffer+0x280>
          if (pl_block->condition & PL_COND_FLAG_SPINDLE_CCW) { 
    3a8c:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    3a90:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    3a94:	81 89       	ldd	r24, Z+17	; 0x11
    3a96:	85 ff       	sbrs	r24, 5
    3a98:	15 c0       	rjmp	.+42     	; 0x3ac4 <st_prep_buffer+0x280>
            // Pre-compute inverse programmed rate to speed up PWM updating per step segment.
            prep.inv_rate = 1.0/pl_block->programmed_rate;
    3a9a:	26 a5       	ldd	r18, Z+46	; 0x2e
    3a9c:	37 a5       	ldd	r19, Z+47	; 0x2f
    3a9e:	40 a9       	ldd	r20, Z+48	; 0x30
    3aa0:	51 a9       	ldd	r21, Z+49	; 0x31
    3aa2:	60 e0       	ldi	r22, 0x00	; 0
    3aa4:	70 e0       	ldi	r23, 0x00	; 0
    3aa6:	80 e8       	ldi	r24, 0x80	; 128
    3aa8:	9f e3       	ldi	r25, 0x3F	; 63
    3aaa:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__divsf3>
    3aae:	d3 01       	movw	r26, r6
    3ab0:	9b 96       	adiw	r26, 0x2b	; 43
    3ab2:	6d 93       	st	X+, r22
    3ab4:	7d 93       	st	X+, r23
    3ab6:	8d 93       	st	X+, r24
    3ab8:	9c 93       	st	X, r25
    3aba:	9e 97       	sbiw	r26, 0x2e	; 46
            st_prep_block->is_pwm_rate_adjusted = true; 
    3abc:	21 e0       	ldi	r18, 0x01	; 1
    3abe:	e9 81       	ldd	r30, Y+1	; 0x01
    3ac0:	fa 81       	ldd	r31, Y+2	; 0x02
    3ac2:	21 8b       	std	Z+17, r18	; 0x11
			 Compute the velocity profile of a new planner block based on its entry and exit
			 speeds, or recompute the profile of a partially-completed planner block if the
			 planner has updated it. For a commanded forced-deceleration, such as from a feed
			 hold, override the planner velocities and decelerate to the target exit speed.
			*/
			prep.mm_complete = 0.0; // Default velocity profile complete at 0.0mm from end of block.
    3ac4:	d3 01       	movw	r26, r6
    3ac6:	53 96       	adiw	r26, 0x13	; 19
    3ac8:	1d 92       	st	X+, r1
    3aca:	1d 92       	st	X+, r1
    3acc:	1d 92       	st	X+, r1
    3ace:	1c 92       	st	X, r1
    3ad0:	56 97       	sbiw	r26, 0x16	; 22
			float inv_2_accel = 0.5/pl_block->acceleration;
    3ad2:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    3ad6:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    3ada:	fe 83       	std	Y+6, r31	; 0x06
    3adc:	ed 83       	std	Y+5, r30	; 0x05
    3ade:	86 8c       	ldd	r8, Z+30	; 0x1e
    3ae0:	97 8c       	ldd	r9, Z+31	; 0x1f
    3ae2:	a0 a0       	ldd	r10, Z+32	; 0x20
    3ae4:	b1 a0       	ldd	r11, Z+33	; 0x21
    3ae6:	a5 01       	movw	r20, r10
    3ae8:	94 01       	movw	r18, r8
    3aea:	60 e0       	ldi	r22, 0x00	; 0
    3aec:	70 e0       	ldi	r23, 0x00	; 0
    3aee:	80 e0       	ldi	r24, 0x00	; 0
    3af0:	9f e3       	ldi	r25, 0x3F	; 63
    3af2:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__divsf3>
    3af6:	69 83       	std	Y+1, r22	; 0x01
    3af8:	7a 83       	std	Y+2, r23	; 0x02
    3afa:	8b 83       	std	Y+3, r24	; 0x03
    3afc:	9c 83       	std	Y+4, r25	; 0x04
			if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { // [Forced Deceleration to Zero Velocity]
    3afe:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    3b02:	81 ff       	sbrs	r24, 1
    3b04:	54 c0       	rjmp	.+168    	; 0x3bae <st_prep_buffer+0x36a>
				// Compute velocity profile parameters for a feed hold in-progress. This profile overrides
				// the planner block profile, enforcing a deceleration to zero speed.
				prep.ramp_type = RAMP_DECEL;
    3b06:	e2 e0       	ldi	r30, 0x02	; 2
    3b08:	d3 01       	movw	r26, r6
    3b0a:	52 96       	adiw	r26, 0x12	; 18
    3b0c:	ec 93       	st	X, r30
				// Compute decelerate distance relative to end of block.
				float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
    3b0e:	ad 81       	ldd	r26, Y+5	; 0x05
    3b10:	be 81       	ldd	r27, Y+6	; 0x06
    3b12:	92 96       	adiw	r26, 0x22	; 34
    3b14:	2d 90       	ld	r2, X+
    3b16:	3d 90       	ld	r3, X+
    3b18:	4d 90       	ld	r4, X+
    3b1a:	5c 90       	ld	r5, X
    3b1c:	95 97       	sbiw	r26, 0x25	; 37
    3b1e:	56 96       	adiw	r26, 0x16	; 22
    3b20:	cd 90       	ld	r12, X+
    3b22:	dd 90       	ld	r13, X+
    3b24:	ed 90       	ld	r14, X+
    3b26:	fc 90       	ld	r15, X
    3b28:	59 97       	sbiw	r26, 0x19	; 25
    3b2a:	a7 01       	movw	r20, r14
    3b2c:	96 01       	movw	r18, r12
    3b2e:	69 81       	ldd	r22, Y+1	; 0x01
    3b30:	7a 81       	ldd	r23, Y+2	; 0x02
    3b32:	8b 81       	ldd	r24, Y+3	; 0x03
    3b34:	9c 81       	ldd	r25, Y+4	; 0x04
    3b36:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    3b3a:	9b 01       	movw	r18, r22
    3b3c:	ac 01       	movw	r20, r24
    3b3e:	c2 01       	movw	r24, r4
    3b40:	b1 01       	movw	r22, r2
    3b42:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    3b46:	69 83       	std	Y+1, r22	; 0x01
    3b48:	7a 83       	std	Y+2, r23	; 0x02
    3b4a:	8b 83       	std	Y+3, r24	; 0x03
    3b4c:	9c 83       	std	Y+4, r25	; 0x04
				if (decel_dist < 0.0) {
    3b4e:	20 e0       	ldi	r18, 0x00	; 0
    3b50:	30 e0       	ldi	r19, 0x00	; 0
    3b52:	a9 01       	movw	r20, r18
    3b54:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    3b58:	88 23       	and	r24, r24
    3b5a:	c4 f4       	brge	.+48     	; 0x3b8c <st_prep_buffer+0x348>
					// Deceleration through entire planner block. End of feed hold is not in this block.
					prep.exit_speed = sqrt(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);
    3b5c:	a5 01       	movw	r20, r10
    3b5e:	94 01       	movw	r18, r8
    3b60:	c5 01       	movw	r24, r10
    3b62:	b4 01       	movw	r22, r8
    3b64:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    3b68:	a2 01       	movw	r20, r4
    3b6a:	91 01       	movw	r18, r2
    3b6c:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    3b70:	9b 01       	movw	r18, r22
    3b72:	ac 01       	movw	r20, r24
    3b74:	c7 01       	movw	r24, r14
    3b76:	b6 01       	movw	r22, r12
    3b78:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    3b7c:	0e 94 30 42 	call	0x8460	; 0x8460 <sqrt>
    3b80:	f3 01       	movw	r30, r6
    3b82:	67 8f       	std	Z+31, r22	; 0x1f
    3b84:	70 a3       	std	Z+32, r23	; 0x20
    3b86:	81 a3       	std	Z+33, r24	; 0x21
    3b88:	92 a3       	std	Z+34, r25	; 0x22
    3b8a:	99 c1       	rjmp	.+818    	; 0x3ebe <st_prep_buffer+0x67a>
				} else {
					prep.mm_complete = decel_dist; // End of feed hold.
    3b8c:	29 81       	ldd	r18, Y+1	; 0x01
    3b8e:	3a 81       	ldd	r19, Y+2	; 0x02
    3b90:	4b 81       	ldd	r20, Y+3	; 0x03
    3b92:	5c 81       	ldd	r21, Y+4	; 0x04
    3b94:	d3 01       	movw	r26, r6
    3b96:	53 96       	adiw	r26, 0x13	; 19
    3b98:	2d 93       	st	X+, r18
    3b9a:	3d 93       	st	X+, r19
    3b9c:	4d 93       	st	X+, r20
    3b9e:	5c 93       	st	X, r21
    3ba0:	56 97       	sbiw	r26, 0x16	; 22
					prep.exit_speed = 0.0;
    3ba2:	f3 01       	movw	r30, r6
    3ba4:	17 8e       	std	Z+31, r1	; 0x1f
    3ba6:	10 a2       	std	Z+32, r1	; 0x20
    3ba8:	11 a2       	std	Z+33, r1	; 0x21
    3baa:	12 a2       	std	Z+34, r1	; 0x22
    3bac:	88 c1       	rjmp	.+784    	; 0x3ebe <st_prep_buffer+0x67a>
				}
			} else { // [Normal Operation]
				// Compute or recompute velocity profile parameters of the prepped planner block.
				prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
    3bae:	d3 01       	movw	r26, r6
    3bb0:	52 96       	adiw	r26, 0x12	; 18
    3bb2:	1c 92       	st	X, r1
    3bb4:	52 97       	sbiw	r26, 0x12	; 18
				prep.accelerate_until = pl_block->millimeters;
    3bb6:	ed 81       	ldd	r30, Y+5	; 0x05
    3bb8:	fe 81       	ldd	r31, Y+6	; 0x06
    3bba:	42 a1       	ldd	r20, Z+34	; 0x22
    3bbc:	53 a1       	ldd	r21, Z+35	; 0x23
    3bbe:	64 a1       	ldd	r22, Z+36	; 0x24
    3bc0:	75 a1       	ldd	r23, Z+37	; 0x25
    3bc2:	93 96       	adiw	r26, 0x23	; 35
    3bc4:	4d 93       	st	X+, r20
    3bc6:	5d 93       	st	X+, r21
    3bc8:	6d 93       	st	X+, r22
    3bca:	7c 93       	st	X, r23
    3bcc:	96 97       	sbiw	r26, 0x26	; 38

				float exit_speed_sqr;
				float nominal_speed;
        if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
    3bce:	82 ff       	sbrs	r24, 2
    3bd0:	0a c0       	rjmp	.+20     	; 0x3be6 <st_prep_buffer+0x3a2>
          prep.exit_speed = exit_speed_sqr = 0.0; // Enforce stop at end of system motion.
    3bd2:	f3 01       	movw	r30, r6
    3bd4:	17 8e       	std	Z+31, r1	; 0x1f
    3bd6:	10 a2       	std	Z+32, r1	; 0x20
    3bd8:	11 a2       	std	Z+33, r1	; 0x21
    3bda:	12 a2       	std	Z+34, r1	; 0x22
    3bdc:	19 86       	std	Y+9, r1	; 0x09
    3bde:	1a 86       	std	Y+10, r1	; 0x0a
    3be0:	1b 86       	std	Y+11, r1	; 0x0b
    3be2:	1c 86       	std	Y+12, r1	; 0x0c
    3be4:	0f c0       	rjmp	.+30     	; 0x3c04 <st_prep_buffer+0x3c0>
        } else {
          exit_speed_sqr = plan_get_exec_block_exit_speed_sqr();
    3be6:	0e 94 6b 29 	call	0x52d6	; 0x52d6 <plan_get_exec_block_exit_speed_sqr>
    3bea:	69 87       	std	Y+9, r22	; 0x09
    3bec:	7a 87       	std	Y+10, r23	; 0x0a
    3bee:	8b 87       	std	Y+11, r24	; 0x0b
    3bf0:	9c 87       	std	Y+12, r25	; 0x0c
          prep.exit_speed = sqrt(exit_speed_sqr);
    3bf2:	0e 94 30 42 	call	0x8460	; 0x8460 <sqrt>
    3bf6:	d3 01       	movw	r26, r6
    3bf8:	5f 96       	adiw	r26, 0x1f	; 31
    3bfa:	6d 93       	st	X+, r22
    3bfc:	7d 93       	st	X+, r23
    3bfe:	8d 93       	st	X+, r24
    3c00:	9c 93       	st	X, r25
    3c02:	92 97       	sbiw	r26, 0x22	; 34
        }

        nominal_speed = plan_compute_profile_nominal_speed(pl_block);
    3c04:	80 91 3b 03 	lds	r24, 0x033B	; 0x80033b <pl_block>
    3c08:	90 91 3c 03 	lds	r25, 0x033C	; 0x80033c <pl_block+0x1>
    3c0c:	0e 94 8c 29 	call	0x5318	; 0x5318 <plan_compute_profile_nominal_speed>
    3c10:	4b 01       	movw	r8, r22
    3c12:	5c 01       	movw	r10, r24
				float nominal_speed_sqr = nominal_speed*nominal_speed;
    3c14:	9b 01       	movw	r18, r22
    3c16:	ac 01       	movw	r20, r24
    3c18:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    3c1c:	6d 83       	std	Y+5, r22	; 0x05
    3c1e:	7e 83       	std	Y+6, r23	; 0x06
    3c20:	8f 83       	std	Y+7, r24	; 0x07
    3c22:	98 87       	std	Y+8, r25	; 0x08
				float intersect_distance =
								0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
    3c24:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    3c28:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    3c2c:	fe 87       	std	Y+14, r31	; 0x0e
    3c2e:	ed 87       	std	Y+13, r30	; 0x0d
    3c30:	c2 a0       	ldd	r12, Z+34	; 0x22
    3c32:	d3 a0       	ldd	r13, Z+35	; 0x23
    3c34:	e4 a0       	ldd	r14, Z+36	; 0x24
    3c36:	f5 a0       	ldd	r15, Z+37	; 0x25
    3c38:	26 88       	ldd	r2, Z+22	; 0x16
    3c3a:	37 88       	ldd	r3, Z+23	; 0x17
    3c3c:	40 8c       	ldd	r4, Z+24	; 0x18
    3c3e:	51 8c       	ldd	r5, Z+25	; 0x19

        if (pl_block->entry_speed_sqr > nominal_speed_sqr) { // Only occurs during override reductions.
    3c40:	a2 01       	movw	r20, r4
    3c42:	91 01       	movw	r18, r2
    3c44:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    3c48:	88 23       	and	r24, r24
    3c4a:	0c f0       	brlt	.+2      	; 0x3c4e <st_prep_buffer+0x40a>
    3c4c:	71 c0       	rjmp	.+226    	; 0x3d30 <st_prep_buffer+0x4ec>
          prep.accelerate_until = pl_block->millimeters - inv_2_accel*(pl_block->entry_speed_sqr-nominal_speed_sqr);
    3c4e:	2d 81       	ldd	r18, Y+5	; 0x05
    3c50:	3e 81       	ldd	r19, Y+6	; 0x06
    3c52:	4f 81       	ldd	r20, Y+7	; 0x07
    3c54:	58 85       	ldd	r21, Y+8	; 0x08
    3c56:	c2 01       	movw	r24, r4
    3c58:	b1 01       	movw	r22, r2
    3c5a:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    3c5e:	29 81       	ldd	r18, Y+1	; 0x01
    3c60:	3a 81       	ldd	r19, Y+2	; 0x02
    3c62:	4b 81       	ldd	r20, Y+3	; 0x03
    3c64:	5c 81       	ldd	r21, Y+4	; 0x04
    3c66:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    3c6a:	9b 01       	movw	r18, r22
    3c6c:	ac 01       	movw	r20, r24
    3c6e:	c7 01       	movw	r24, r14
    3c70:	b6 01       	movw	r22, r12
    3c72:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    3c76:	d3 01       	movw	r26, r6
    3c78:	93 96       	adiw	r26, 0x23	; 35
    3c7a:	6d 93       	st	X+, r22
    3c7c:	7d 93       	st	X+, r23
    3c7e:	8d 93       	st	X+, r24
    3c80:	9c 93       	st	X, r25
    3c82:	96 97       	sbiw	r26, 0x26	; 38
          if (prep.accelerate_until <= 0.0) { // Deceleration-only.
    3c84:	20 e0       	ldi	r18, 0x00	; 0
    3c86:	30 e0       	ldi	r19, 0x00	; 0
    3c88:	a9 01       	movw	r20, r18
    3c8a:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    3c8e:	18 16       	cp	r1, r24
    3c90:	84 f1       	brlt	.+96     	; 0x3cf2 <st_prep_buffer+0x4ae>
            prep.ramp_type = RAMP_DECEL;
    3c92:	22 e0       	ldi	r18, 0x02	; 2
    3c94:	f3 01       	movw	r30, r6
    3c96:	22 8b       	std	Z+18, r18	; 0x12
            // prep.decelerate_after = pl_block->millimeters;
            // prep.maximum_speed = prep.current_speed;

            // Compute override block exit speed since it doesn't match the planner exit speed.
            prep.exit_speed = sqrt(pl_block->entry_speed_sqr - 2*pl_block->acceleration*pl_block->millimeters);
    3c98:	ad 85       	ldd	r26, Y+13	; 0x0d
    3c9a:	be 85       	ldd	r27, Y+14	; 0x0e
    3c9c:	5e 96       	adiw	r26, 0x1e	; 30
    3c9e:	cd 90       	ld	r12, X+
    3ca0:	dd 90       	ld	r13, X+
    3ca2:	ed 90       	ld	r14, X+
    3ca4:	fc 90       	ld	r15, X
    3ca6:	91 97       	sbiw	r26, 0x21	; 33
    3ca8:	a7 01       	movw	r20, r14
    3caa:	96 01       	movw	r18, r12
    3cac:	c7 01       	movw	r24, r14
    3cae:	b6 01       	movw	r22, r12
    3cb0:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    3cb4:	ed 85       	ldd	r30, Y+13	; 0x0d
    3cb6:	fe 85       	ldd	r31, Y+14	; 0x0e
    3cb8:	22 a1       	ldd	r18, Z+34	; 0x22
    3cba:	33 a1       	ldd	r19, Z+35	; 0x23
    3cbc:	44 a1       	ldd	r20, Z+36	; 0x24
    3cbe:	55 a1       	ldd	r21, Z+37	; 0x25
    3cc0:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    3cc4:	9b 01       	movw	r18, r22
    3cc6:	ac 01       	movw	r20, r24
    3cc8:	ad 85       	ldd	r26, Y+13	; 0x0d
    3cca:	be 85       	ldd	r27, Y+14	; 0x0e
    3ccc:	56 96       	adiw	r26, 0x16	; 22
    3cce:	6d 91       	ld	r22, X+
    3cd0:	7d 91       	ld	r23, X+
    3cd2:	8d 91       	ld	r24, X+
    3cd4:	9c 91       	ld	r25, X
    3cd6:	59 97       	sbiw	r26, 0x19	; 25
    3cd8:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    3cdc:	0e 94 30 42 	call	0x8460	; 0x8460 <sqrt>
    3ce0:	f3 01       	movw	r30, r6
    3ce2:	67 8f       	std	Z+31, r22	; 0x1f
    3ce4:	70 a3       	std	Z+32, r23	; 0x20
    3ce6:	81 a3       	std	Z+33, r24	; 0x21
    3ce8:	92 a3       	std	Z+34, r25	; 0x22
            prep.recalculate_flag |= PREP_FLAG_DECEL_OVERRIDE; // Flag to load next block as deceleration override.
    3cea:	81 81       	ldd	r24, Z+1	; 0x01
    3cec:	88 60       	ori	r24, 0x08	; 8
    3cee:	81 83       	std	Z+1, r24	; 0x01
    3cf0:	e6 c0       	rjmp	.+460    	; 0x3ebe <st_prep_buffer+0x67a>
            // Can be tricky since entry speed will be current speed, as in feed holds.
            // Also, look into near-zero speed handling issues with this.

          } else {
            // Decelerate to cruise or cruise-decelerate types. Guaranteed to intersect updated plan.
            prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
    3cf2:	29 85       	ldd	r18, Y+9	; 0x09
    3cf4:	3a 85       	ldd	r19, Y+10	; 0x0a
    3cf6:	4b 85       	ldd	r20, Y+11	; 0x0b
    3cf8:	5c 85       	ldd	r21, Y+12	; 0x0c
    3cfa:	6d 81       	ldd	r22, Y+5	; 0x05
    3cfc:	7e 81       	ldd	r23, Y+6	; 0x06
    3cfe:	8f 81       	ldd	r24, Y+7	; 0x07
    3d00:	98 85       	ldd	r25, Y+8	; 0x08
    3d02:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    3d06:	29 81       	ldd	r18, Y+1	; 0x01
    3d08:	3a 81       	ldd	r19, Y+2	; 0x02
    3d0a:	4b 81       	ldd	r20, Y+3	; 0x03
    3d0c:	5c 81       	ldd	r21, Y+4	; 0x04
    3d0e:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    3d12:	d3 01       	movw	r26, r6
    3d14:	97 96       	adiw	r26, 0x27	; 39
    3d16:	6d 93       	st	X+, r22
    3d18:	7d 93       	st	X+, r23
    3d1a:	8d 93       	st	X+, r24
    3d1c:	9c 93       	st	X, r25
    3d1e:	9a 97       	sbiw	r26, 0x2a	; 42
            prep.maximum_speed = nominal_speed;
    3d20:	f3 01       	movw	r30, r6
    3d22:	83 8e       	std	Z+27, r8	; 0x1b
    3d24:	94 8e       	std	Z+28, r9	; 0x1c
    3d26:	a5 8e       	std	Z+29, r10	; 0x1d
    3d28:	b6 8e       	std	Z+30, r11	; 0x1e
            prep.ramp_type = RAMP_DECEL_OVERRIDE;
    3d2a:	23 e0       	ldi	r18, 0x03	; 3
    3d2c:	22 8b       	std	Z+18, r18	; 0x12
    3d2e:	c7 c0       	rjmp	.+398    	; 0x3ebe <st_prep_buffer+0x67a>
          prep.exit_speed = sqrt(exit_speed_sqr);
        }

        nominal_speed = plan_compute_profile_nominal_speed(pl_block);
				float nominal_speed_sqr = nominal_speed*nominal_speed;
				float intersect_distance =
    3d30:	29 85       	ldd	r18, Y+9	; 0x09
    3d32:	3a 85       	ldd	r19, Y+10	; 0x0a
    3d34:	4b 85       	ldd	r20, Y+11	; 0x0b
    3d36:	5c 85       	ldd	r21, Y+12	; 0x0c
    3d38:	c2 01       	movw	r24, r4
    3d3a:	b1 01       	movw	r22, r2
    3d3c:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    3d40:	29 81       	ldd	r18, Y+1	; 0x01
    3d42:	3a 81       	ldd	r19, Y+2	; 0x02
    3d44:	4b 81       	ldd	r20, Y+3	; 0x03
    3d46:	5c 81       	ldd	r21, Y+4	; 0x04
    3d48:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    3d4c:	a7 01       	movw	r20, r14
    3d4e:	96 01       	movw	r18, r12
    3d50:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    3d54:	20 e0       	ldi	r18, 0x00	; 0
    3d56:	30 e0       	ldi	r19, 0x00	; 0
    3d58:	40 e0       	ldi	r20, 0x00	; 0
    3d5a:	5f e3       	ldi	r21, 0x3F	; 63
    3d5c:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    3d60:	1b 01       	movw	r2, r22
    3d62:	2c 01       	movw	r4, r24
            // Decelerate to cruise or cruise-decelerate types. Guaranteed to intersect updated plan.
            prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
            prep.maximum_speed = nominal_speed;
            prep.ramp_type = RAMP_DECEL_OVERRIDE;
          }
				} else if (intersect_distance > 0.0) {
    3d64:	20 e0       	ldi	r18, 0x00	; 0
    3d66:	30 e0       	ldi	r19, 0x00	; 0
    3d68:	a9 01       	movw	r20, r18
    3d6a:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    3d6e:	18 16       	cp	r1, r24
    3d70:	0c f0       	brlt	.+2      	; 0x3d74 <st_prep_buffer+0x530>
    3d72:	93 c0       	rjmp	.+294    	; 0x3e9a <st_prep_buffer+0x656>
					if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
    3d74:	a2 01       	movw	r20, r4
    3d76:	91 01       	movw	r18, r2
    3d78:	c7 01       	movw	r24, r14
    3d7a:	b6 01       	movw	r22, r12
    3d7c:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    3d80:	18 16       	cp	r1, r24
    3d82:	0c f0       	brlt	.+2      	; 0x3d86 <st_prep_buffer+0x542>
    3d84:	85 c0       	rjmp	.+266    	; 0x3e90 <st_prep_buffer+0x64c>
						// NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
						prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
    3d86:	29 85       	ldd	r18, Y+9	; 0x09
    3d88:	3a 85       	ldd	r19, Y+10	; 0x0a
    3d8a:	4b 85       	ldd	r20, Y+11	; 0x0b
    3d8c:	5c 85       	ldd	r21, Y+12	; 0x0c
    3d8e:	6d 81       	ldd	r22, Y+5	; 0x05
    3d90:	7e 81       	ldd	r23, Y+6	; 0x06
    3d92:	8f 81       	ldd	r24, Y+7	; 0x07
    3d94:	98 85       	ldd	r25, Y+8	; 0x08
    3d96:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    3d9a:	29 81       	ldd	r18, Y+1	; 0x01
    3d9c:	3a 81       	ldd	r19, Y+2	; 0x02
    3d9e:	4b 81       	ldd	r20, Y+3	; 0x03
    3da0:	5c 81       	ldd	r21, Y+4	; 0x04
    3da2:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    3da6:	9b 01       	movw	r18, r22
    3da8:	ac 01       	movw	r20, r24
    3daa:	d3 01       	movw	r26, r6
    3dac:	97 96       	adiw	r26, 0x27	; 39
    3dae:	6d 93       	st	X+, r22
    3db0:	7d 93       	st	X+, r23
    3db2:	8d 93       	st	X+, r24
    3db4:	9c 93       	st	X, r25
    3db6:	9a 97       	sbiw	r26, 0x2a	; 42
						if (prep.decelerate_after < intersect_distance) { // Trapezoid type
    3db8:	c2 01       	movw	r24, r4
    3dba:	b1 01       	movw	r22, r2
    3dbc:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    3dc0:	18 16       	cp	r1, r24
    3dc2:	d4 f5       	brge	.+116    	; 0x3e38 <st_prep_buffer+0x5f4>
							prep.maximum_speed = nominal_speed;
    3dc4:	f3 01       	movw	r30, r6
    3dc6:	83 8e       	std	Z+27, r8	; 0x1b
    3dc8:	94 8e       	std	Z+28, r9	; 0x1c
    3dca:	a5 8e       	std	Z+29, r10	; 0x1d
    3dcc:	b6 8e       	std	Z+30, r11	; 0x1e
							if (pl_block->entry_speed_sqr == nominal_speed_sqr) {
    3dce:	ad 85       	ldd	r26, Y+13	; 0x0d
    3dd0:	be 85       	ldd	r27, Y+14	; 0x0e
    3dd2:	56 96       	adiw	r26, 0x16	; 22
    3dd4:	2d 90       	ld	r2, X+
    3dd6:	3d 90       	ld	r3, X+
    3dd8:	4d 90       	ld	r4, X+
    3dda:	5c 90       	ld	r5, X
    3ddc:	59 97       	sbiw	r26, 0x19	; 25
    3dde:	a2 01       	movw	r20, r4
    3de0:	91 01       	movw	r18, r2
    3de2:	6d 81       	ldd	r22, Y+5	; 0x05
    3de4:	7e 81       	ldd	r23, Y+6	; 0x06
    3de6:	8f 81       	ldd	r24, Y+7	; 0x07
    3de8:	98 85       	ldd	r25, Y+8	; 0x08
    3dea:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    3dee:	81 11       	cpse	r24, r1
    3df0:	04 c0       	rjmp	.+8      	; 0x3dfa <st_prep_buffer+0x5b6>
								// Cruise-deceleration or cruise-only type.
								prep.ramp_type = RAMP_CRUISE;
    3df2:	21 e0       	ldi	r18, 0x01	; 1
    3df4:	f3 01       	movw	r30, r6
    3df6:	22 8b       	std	Z+18, r18	; 0x12
    3df8:	62 c0       	rjmp	.+196    	; 0x3ebe <st_prep_buffer+0x67a>
							} else {
								// Full-trapezoid or acceleration-cruise types
								prep.accelerate_until -= inv_2_accel*(nominal_speed_sqr-pl_block->entry_speed_sqr);
    3dfa:	a2 01       	movw	r20, r4
    3dfc:	91 01       	movw	r18, r2
    3dfe:	6d 81       	ldd	r22, Y+5	; 0x05
    3e00:	7e 81       	ldd	r23, Y+6	; 0x06
    3e02:	8f 81       	ldd	r24, Y+7	; 0x07
    3e04:	98 85       	ldd	r25, Y+8	; 0x08
    3e06:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    3e0a:	29 81       	ldd	r18, Y+1	; 0x01
    3e0c:	3a 81       	ldd	r19, Y+2	; 0x02
    3e0e:	4b 81       	ldd	r20, Y+3	; 0x03
    3e10:	5c 81       	ldd	r21, Y+4	; 0x04
    3e12:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    3e16:	9b 01       	movw	r18, r22
    3e18:	ac 01       	movw	r20, r24
    3e1a:	d3 01       	movw	r26, r6
    3e1c:	93 96       	adiw	r26, 0x23	; 35
    3e1e:	6d 91       	ld	r22, X+
    3e20:	7d 91       	ld	r23, X+
    3e22:	8d 91       	ld	r24, X+
    3e24:	9c 91       	ld	r25, X
    3e26:	96 97       	sbiw	r26, 0x26	; 38
    3e28:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    3e2c:	f3 01       	movw	r30, r6
    3e2e:	63 a3       	std	Z+35, r22	; 0x23
    3e30:	74 a3       	std	Z+36, r23	; 0x24
    3e32:	85 a3       	std	Z+37, r24	; 0x25
    3e34:	96 a3       	std	Z+38, r25	; 0x26
    3e36:	43 c0       	rjmp	.+134    	; 0x3ebe <st_prep_buffer+0x67a>
							}
						} else { // Triangle type
							prep.accelerate_until = intersect_distance;
    3e38:	d3 01       	movw	r26, r6
    3e3a:	93 96       	adiw	r26, 0x23	; 35
    3e3c:	2d 92       	st	X+, r2
    3e3e:	3d 92       	st	X+, r3
    3e40:	4d 92       	st	X+, r4
    3e42:	5c 92       	st	X, r5
    3e44:	96 97       	sbiw	r26, 0x26	; 38
							prep.decelerate_after = intersect_distance;
    3e46:	f3 01       	movw	r30, r6
    3e48:	27 a2       	std	Z+39, r2	; 0x27
    3e4a:	30 a6       	std	Z+40, r3	; 0x28
    3e4c:	41 a6       	std	Z+41, r4	; 0x29
    3e4e:	52 a6       	std	Z+42, r5	; 0x2a
							prep.maximum_speed = sqrt(2.0*pl_block->acceleration*intersect_distance+exit_speed_sqr);
    3e50:	ad 85       	ldd	r26, Y+13	; 0x0d
    3e52:	be 85       	ldd	r27, Y+14	; 0x0e
    3e54:	5e 96       	adiw	r26, 0x1e	; 30
    3e56:	cd 90       	ld	r12, X+
    3e58:	dd 90       	ld	r13, X+
    3e5a:	ed 90       	ld	r14, X+
    3e5c:	fc 90       	ld	r15, X
    3e5e:	91 97       	sbiw	r26, 0x21	; 33
    3e60:	a7 01       	movw	r20, r14
    3e62:	96 01       	movw	r18, r12
    3e64:	c7 01       	movw	r24, r14
    3e66:	b6 01       	movw	r22, r12
    3e68:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    3e6c:	a2 01       	movw	r20, r4
    3e6e:	91 01       	movw	r18, r2
    3e70:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    3e74:	29 85       	ldd	r18, Y+9	; 0x09
    3e76:	3a 85       	ldd	r19, Y+10	; 0x0a
    3e78:	4b 85       	ldd	r20, Y+11	; 0x0b
    3e7a:	5c 85       	ldd	r21, Y+12	; 0x0c
    3e7c:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    3e80:	0e 94 30 42 	call	0x8460	; 0x8460 <sqrt>
    3e84:	f3 01       	movw	r30, r6
    3e86:	63 8f       	std	Z+27, r22	; 0x1b
    3e88:	74 8f       	std	Z+28, r23	; 0x1c
    3e8a:	85 8f       	std	Z+29, r24	; 0x1d
    3e8c:	96 8f       	std	Z+30, r25	; 0x1e
    3e8e:	17 c0       	rjmp	.+46     	; 0x3ebe <st_prep_buffer+0x67a>
						}
					} else { // Deceleration-only type
            prep.ramp_type = RAMP_DECEL;
    3e90:	e2 e0       	ldi	r30, 0x02	; 2
    3e92:	d3 01       	movw	r26, r6
    3e94:	52 96       	adiw	r26, 0x12	; 18
    3e96:	ec 93       	st	X, r30
    3e98:	12 c0       	rjmp	.+36     	; 0x3ebe <st_prep_buffer+0x67a>
            // prep.decelerate_after = pl_block->millimeters;
            // prep.maximum_speed = prep.current_speed;
					}
				} else { // Acceleration-only type
					prep.accelerate_until = 0.0;
    3e9a:	d3 01       	movw	r26, r6
    3e9c:	93 96       	adiw	r26, 0x23	; 35
    3e9e:	1d 92       	st	X+, r1
    3ea0:	1d 92       	st	X+, r1
    3ea2:	1d 92       	st	X+, r1
    3ea4:	1c 92       	st	X, r1
    3ea6:	96 97       	sbiw	r26, 0x26	; 38
					// prep.decelerate_after = 0.0;
					prep.maximum_speed = prep.exit_speed;
    3ea8:	5f 96       	adiw	r26, 0x1f	; 31
    3eaa:	8d 91       	ld	r24, X+
    3eac:	9d 91       	ld	r25, X+
    3eae:	0d 90       	ld	r0, X+
    3eb0:	bc 91       	ld	r27, X
    3eb2:	a0 2d       	mov	r26, r0
    3eb4:	f3 01       	movw	r30, r6
    3eb6:	83 8f       	std	Z+27, r24	; 0x1b
    3eb8:	94 8f       	std	Z+28, r25	; 0x1c
    3eba:	a5 8f       	std	Z+29, r26	; 0x1d
    3ebc:	b6 8f       	std	Z+30, r27	; 0x1e
				}
			}
      
      bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM); // Force update whenever updating block.
    3ebe:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    3ec2:	88 60       	ori	r24, 0x08	; 8
    3ec4:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <sys+0x4>
    }
    
    // Initialize new segment
    segment_t *prep_segment = &segment_buffer[segment_buffer_head];
    3ec8:	e0 91 41 03 	lds	r30, 0x0341	; 0x800341 <segment_buffer_head>
    3ecc:	2e 2f       	mov	r18, r30
    3ece:	30 e0       	ldi	r19, 0x00	; 0
    3ed0:	3b ab       	std	Y+51, r19	; 0x33
    3ed2:	2a ab       	std	Y+50, r18	; 0x32

    // Set new segment to point to the current segment data block.
    prep_segment->st_block_index = prep.st_block_index;
    3ed4:	f9 01       	movw	r30, r18
    3ed6:	ee 0f       	add	r30, r30
    3ed8:	ff 1f       	adc	r31, r31
    3eda:	ee 0f       	add	r30, r30
    3edc:	ff 1f       	adc	r31, r31
    3ede:	ee 0f       	add	r30, r30
    3ee0:	ff 1f       	adc	r31, r31
    3ee2:	ea 59       	subi	r30, 0x9A	; 154
    3ee4:	fc 4f       	sbci	r31, 0xFC	; 252
    3ee6:	d3 01       	movw	r26, r6
    3ee8:	8c 91       	ld	r24, X
    3eea:	84 83       	std	Z+4, r24	; 0x04
    float dt_max = DT_SEGMENT; // Maximum segment time
    float dt = 0.0; // Initialize segment time
    float time_var = dt_max; // Time worker variable
    float mm_var; // mm-Distance worker variable
    float speed_var; // Speed worker variable
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    3eec:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    3ef0:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    3ef4:	fb 8f       	std	Y+27, r31	; 0x1b
    3ef6:	ea 8f       	std	Y+26, r30	; 0x1a
    3ef8:	f2 a1       	ldd	r31, Z+34	; 0x22
    3efa:	fa a7       	std	Y+42, r31	; 0x2a
    3efc:	aa 8d       	ldd	r26, Y+26	; 0x1a
    3efe:	bb 8d       	ldd	r27, Y+27	; 0x1b
    3f00:	93 96       	adiw	r26, 0x23	; 35
    3f02:	bc 91       	ld	r27, X
    3f04:	bb a7       	std	Y+43, r27	; 0x2b
    3f06:	ea 8d       	ldd	r30, Y+26	; 0x1a
    3f08:	fb 8d       	ldd	r31, Y+27	; 0x1b
    3f0a:	f4 a1       	ldd	r31, Z+36	; 0x24
    3f0c:	fc a7       	std	Y+44, r31	; 0x2c
    3f0e:	aa 8d       	ldd	r26, Y+26	; 0x1a
    3f10:	bb 8d       	ldd	r27, Y+27	; 0x1b
    3f12:	95 96       	adiw	r26, 0x25	; 37
    3f14:	bc 91       	ld	r27, X
    3f16:	bd a7       	std	Y+45, r27	; 0x2d
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    3f18:	f3 01       	movw	r30, r6
    3f1a:	26 85       	ldd	r18, Z+14	; 0x0e
    3f1c:	37 85       	ldd	r19, Z+15	; 0x0f
    3f1e:	40 89       	ldd	r20, Z+16	; 0x10
    3f20:	51 89       	ldd	r21, Z+17	; 0x11
    3f22:	6a a5       	ldd	r22, Y+42	; 0x2a
    3f24:	7b a5       	ldd	r23, Y+43	; 0x2b
    3f26:	8c a5       	ldd	r24, Y+44	; 0x2c
    3f28:	9b 2f       	mov	r25, r27
    3f2a:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    3f2e:	6a a3       	std	Y+34, r22	; 0x22
    3f30:	7b a3       	std	Y+35, r23	; 0x23
    3f32:	8c a3       	std	Y+36, r24	; 0x24
    3f34:	9d a3       	std	Y+37, r25	; 0x25
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }
    3f36:	20 e0       	ldi	r18, 0x00	; 0
    3f38:	30 e0       	ldi	r19, 0x00	; 0
    3f3a:	a9 01       	movw	r20, r18
    3f3c:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    3f40:	88 23       	and	r24, r24
    3f42:	24 f4       	brge	.+8      	; 0x3f4c <st_prep_buffer+0x708>
    3f44:	1a a2       	std	Y+34, r1	; 0x22
    3f46:	1b a2       	std	Y+35, r1	; 0x23
    3f48:	1c a2       	std	Y+36, r1	; 0x24
    3f4a:	1d a2       	std	Y+37, r1	; 0x25

    do {
      switch (prep.ramp_type) {
        case RAMP_DECEL_OVERRIDE:
          speed_var = pl_block->acceleration*time_var;
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
    3f4c:	d3 01       	movw	r26, r6
    3f4e:	5b 96       	adiw	r26, 0x1b	; 27
    3f50:	bc 91       	ld	r27, X
    3f52:	be 8b       	std	Y+22, r27	; 0x16
    3f54:	f3 01       	movw	r30, r6
    3f56:	f4 8d       	ldd	r31, Z+28	; 0x1c
    3f58:	ff 8b       	std	Y+23, r31	; 0x17
    3f5a:	d3 01       	movw	r26, r6
    3f5c:	5d 96       	adiw	r26, 0x1d	; 29
    3f5e:	bc 91       	ld	r27, X
    3f60:	b8 8f       	std	Y+24, r27	; 0x18
    3f62:	f3 01       	movw	r30, r6
    3f64:	f6 8d       	ldd	r31, Z+30	; 0x1e
    3f66:	f9 8f       	std	Y+25, r31	; 0x19
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
    3f68:	d3 01       	movw	r26, r6
    3f6a:	93 96       	adiw	r26, 0x23	; 35
    3f6c:	bc 91       	ld	r27, X
    3f6e:	be 8f       	std	Y+30, r27	; 0x1e
    3f70:	f3 01       	movw	r30, r6
    3f72:	f4 a1       	ldd	r31, Z+36	; 0x24
    3f74:	ff 8f       	std	Y+31, r31	; 0x1f
    3f76:	d3 01       	movw	r26, r6
    3f78:	95 96       	adiw	r26, 0x25	; 37
    3f7a:	bc 91       	ld	r27, X
    3f7c:	b8 a3       	std	Y+32, r27	; 0x20
    3f7e:	f3 01       	movw	r30, r6
    3f80:	f6 a1       	ldd	r31, Z+38	; 0x26
    3f82:	f9 a3       	std	Y+33, r31	; 0x21
    3f84:	d3 01       	movw	r26, r6
    3f86:	57 96       	adiw	r26, 0x17	; 23
    3f88:	bc 91       	ld	r27, X
    3f8a:	b9 83       	std	Y+1, r27	; 0x01
    3f8c:	f3 01       	movw	r30, r6
    3f8e:	f0 8d       	ldd	r31, Z+24	; 0x18
    3f90:	fd 83       	std	Y+5, r31	; 0x05
    3f92:	d3 01       	movw	r26, r6
    3f94:	59 96       	adiw	r26, 0x19	; 25
    3f96:	bc 91       	ld	r27, X
    3f98:	b9 87       	std	Y+9, r27	; 0x09
    3f9a:	f3 01       	movw	r30, r6
    3f9c:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3f9e:	f9 8b       	std	Y+17, r31	; 0x11
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    3fa0:	d3 01       	movw	r26, r6
    3fa2:	97 96       	adiw	r26, 0x27	; 39
    3fa4:	bc 91       	ld	r27, X
    3fa6:	be a3       	std	Y+38, r27	; 0x26
    3fa8:	f3 01       	movw	r30, r6
    3faa:	f0 a5       	ldd	r31, Z+40	; 0x28
    3fac:	ff a3       	std	Y+39, r31	; 0x27
    3fae:	d3 01       	movw	r26, r6
    3fb0:	99 96       	adiw	r26, 0x29	; 41
    3fb2:	bc 91       	ld	r27, X
    3fb4:	b8 a7       	std	Y+40, r27	; 0x28
    3fb6:	f3 01       	movw	r30, r6
    3fb8:	f2 a5       	ldd	r31, Z+42	; 0x2a
    3fba:	f9 a7       	std	Y+41, r31	; 0x29
    3fbc:	d3 01       	movw	r26, r6
    3fbe:	52 96       	adiw	r26, 0x12	; 18
    3fc0:	bc 91       	ld	r27, X
    3fc2:	bd 8f       	std	Y+29, r27	; 0x1d
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
    3fc4:	f3 01       	movw	r30, r6
    3fc6:	f3 89       	ldd	r31, Z+19	; 0x13
    3fc8:	fa 8b       	std	Y+18, r31	; 0x12
    3fca:	d3 01       	movw	r26, r6
    3fcc:	54 96       	adiw	r26, 0x14	; 20
    3fce:	bc 91       	ld	r27, X
    3fd0:	bb 8b       	std	Y+19, r27	; 0x13
    3fd2:	f3 01       	movw	r30, r6
    3fd4:	f5 89       	ldd	r31, Z+21	; 0x15
    3fd6:	fc 8b       	std	Y+20, r31	; 0x14
    3fd8:	d3 01       	movw	r26, r6
    3fda:	56 96       	adiw	r26, 0x16	; 22
    3fdc:	bc 91       	ld	r27, X
    3fde:	bd 8b       	std	Y+21, r27	; 0x15
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    3fe0:	f3 01       	movw	r30, r6
    3fe2:	f7 8d       	ldd	r31, Z+31	; 0x1f
    3fe4:	fe a7       	std	Y+46, r31	; 0x2e
    3fe6:	d3 01       	movw	r26, r6
    3fe8:	90 96       	adiw	r26, 0x20	; 32
    3fea:	bc 91       	ld	r27, X
    3fec:	bf a7       	std	Y+47, r27	; 0x2f
    3fee:	f3 01       	movw	r30, r6
    3ff0:	f1 a1       	ldd	r31, Z+33	; 0x21
    3ff2:	f8 ab       	std	Y+48, r31	; 0x30
    3ff4:	d3 01       	movw	r26, r6
    3ff6:	92 96       	adiw	r26, 0x22	; 34
    3ff8:	bc 91       	ld	r27, X
    3ffa:	b9 ab       	std	Y+49, r27	; 0x31
    3ffc:	2e a1       	ldd	r18, Y+38	; 0x26
    3ffe:	3f a1       	ldd	r19, Y+39	; 0x27
    4000:	48 a5       	ldd	r20, Y+40	; 0x28
    4002:	59 a5       	ldd	r21, Y+41	; 0x29
    4004:	6e 8d       	ldd	r22, Y+30	; 0x1e
    4006:	7f 8d       	ldd	r23, Y+31	; 0x1f
    4008:	88 a1       	ldd	r24, Y+32	; 0x20
    400a:	99 a1       	ldd	r25, Y+33	; 0x21
    400c:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    4010:	81 11       	cpse	r24, r1
    4012:	02 c0       	rjmp	.+4      	; 0x4018 <st_prep_buffer+0x7d4>
    4014:	8a ad       	ldd	r24, Y+58	; 0x3a
    4016:	01 c0       	rjmp	.+2      	; 0x401a <st_prep_buffer+0x7d6>
    4018:	81 e0       	ldi	r24, 0x01	; 1
    401a:	5a a4       	ldd	r5, Y+42	; 0x2a
    401c:	1b a5       	ldd	r17, Y+43	; 0x2b
    401e:	0c a5       	ldd	r16, Y+44	; 0x2c
    4020:	ed a5       	ldd	r30, Y+45	; 0x2d
    4022:	ec 8f       	std	Y+28, r30	; 0x1c
    4024:	0f 2e       	mov	r0, r31
    4026:	fe e3       	ldi	r31, 0x3E	; 62
    4028:	4f 2e       	mov	r4, r31
    402a:	f0 2d       	mov	r31, r0
    402c:	0f 2e       	mov	r0, r31
    402e:	f3 ec       	ldi	r31, 0xC3	; 195
    4030:	3f 2e       	mov	r3, r31
    4032:	f0 2d       	mov	r31, r0
    4034:	0f 2e       	mov	r0, r31
    4036:	fe e2       	ldi	r31, 0x2E	; 46
    4038:	2f 2e       	mov	r2, r31
    403a:	f0 2d       	mov	r31, r0
    403c:	0f 2e       	mov	r0, r31
    403e:	f9 e3       	ldi	r31, 0x39	; 57
    4040:	ff 2e       	mov	r15, r31
    4042:	f0 2d       	mov	r31, r0
    4044:	81 2c       	mov	r8, r1
    4046:	91 2c       	mov	r9, r1
    4048:	54 01       	movw	r10, r8
    404a:	0f 2e       	mov	r0, r31
    404c:	fe e3       	ldi	r31, 0x3E	; 62
    404e:	cf 2e       	mov	r12, r31
    4050:	f0 2d       	mov	r31, r0
    4052:	0f 2e       	mov	r0, r31
    4054:	f3 ec       	ldi	r31, 0xC3	; 195
    4056:	df 2e       	mov	r13, r31
    4058:	f0 2d       	mov	r31, r0
    405a:	0f 2e       	mov	r0, r31
    405c:	fe e2       	ldi	r31, 0x2E	; 46
    405e:	ef 2e       	mov	r14, r31
    4060:	f0 2d       	mov	r31, r0
    4062:	f9 e3       	ldi	r31, 0x39	; 57
    4064:	fd 87       	std	Y+13, r31	; 0x0d
    4066:	8d ab       	std	Y+53, r24	; 0x35
    4068:	2d 8d       	ldd	r18, Y+29	; 0x1d
    406a:	2c af       	std	Y+60, r18	; 0x3c
    406c:	7f aa       	std	Y+55, r7	; 0x37
    406e:	6e aa       	std	Y+54, r6	; 0x36
    4070:	7c 2c       	mov	r7, r12
    4072:	81 2f       	mov	r24, r17
    4074:	1e 2d       	mov	r17, r14
    4076:	e5 2c       	mov	r14, r5
    4078:	5d 2c       	mov	r5, r13
    407a:	c0 2e       	mov	r12, r16
    407c:	09 e3       	ldi	r16, 0x39	; 57
    407e:	fb ae       	std	Y+59, r15	; 0x3b
    4080:	fe 2e       	mov	r15, r30
    4082:	d8 2e       	mov	r13, r24
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }

    do {
      switch (prep.ramp_type) {
    4084:	3c ad       	ldd	r19, Y+60	; 0x3c
    4086:	31 30       	cpi	r19, 0x01	; 1
    4088:	09 f4       	brne	.+2      	; 0x408c <st_prep_buffer+0x848>
    408a:	0f c1       	rjmp	.+542    	; 0x42aa <st_prep_buffer+0xa66>
    408c:	08 f4       	brcc	.+2      	; 0x4090 <st_prep_buffer+0x84c>
    408e:	8f c0       	rjmp	.+286    	; 0x41ae <st_prep_buffer+0x96a>
    4090:	33 30       	cpi	r19, 0x03	; 3
    4092:	09 f0       	breq	.+2      	; 0x4096 <st_prep_buffer+0x852>
    4094:	48 c1       	rjmp	.+656    	; 0x4326 <st_prep_buffer+0xae2>
        case RAMP_DECEL_OVERRIDE:
          speed_var = pl_block->acceleration*time_var;
    4096:	aa 8d       	ldd	r26, Y+26	; 0x1a
    4098:	bb 8d       	ldd	r27, Y+27	; 0x1b
    409a:	5e 96       	adiw	r26, 0x1e	; 30
    409c:	2d 91       	ld	r18, X+
    409e:	3d 91       	ld	r19, X+
    40a0:	4d 91       	ld	r20, X+
    40a2:	5c 91       	ld	r21, X
    40a4:	91 97       	sbiw	r26, 0x21	; 33
    40a6:	64 2d       	mov	r22, r4
    40a8:	73 2d       	mov	r23, r3
    40aa:	82 2d       	mov	r24, r2
    40ac:	9b ad       	ldd	r25, Y+59	; 0x3b
    40ae:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    40b2:	6d 87       	std	Y+13, r22	; 0x0d
    40b4:	7e 87       	std	Y+14, r23	; 0x0e
    40b6:	8f 87       	std	Y+15, r24	; 0x0f
    40b8:	98 8b       	std	Y+16, r25	; 0x10
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
    40ba:	2e 89       	ldd	r18, Y+22	; 0x16
    40bc:	3f 89       	ldd	r19, Y+23	; 0x17
    40be:	48 8d       	ldd	r20, Y+24	; 0x18
    40c0:	59 8d       	ldd	r21, Y+25	; 0x19
    40c2:	69 81       	ldd	r22, Y+1	; 0x01
    40c4:	7d 81       	ldd	r23, Y+5	; 0x05
    40c6:	89 85       	ldd	r24, Y+9	; 0x09
    40c8:	99 89       	ldd	r25, Y+17	; 0x11
    40ca:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    40ce:	9b 01       	movw	r18, r22
    40d0:	ac 01       	movw	r20, r24
    40d2:	6d 85       	ldd	r22, Y+13	; 0x0d
    40d4:	7e 85       	ldd	r23, Y+14	; 0x0e
    40d6:	8f 85       	ldd	r24, Y+15	; 0x0f
    40d8:	98 89       	ldd	r25, Y+16	; 0x10
    40da:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    40de:	88 23       	and	r24, r24
    40e0:	9c f1       	brlt	.+102    	; 0x4148 <st_prep_buffer+0x904>
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    40e2:	2e 8d       	ldd	r18, Y+30	; 0x1e
    40e4:	3f 8d       	ldd	r19, Y+31	; 0x1f
    40e6:	48 a1       	ldd	r20, Y+32	; 0x20
    40e8:	59 a1       	ldd	r21, Y+33	; 0x21
    40ea:	6a a5       	ldd	r22, Y+42	; 0x2a
    40ec:	7b a5       	ldd	r23, Y+43	; 0x2b
    40ee:	8c a5       	ldd	r24, Y+44	; 0x2c
    40f0:	9d a5       	ldd	r25, Y+45	; 0x2d
    40f2:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    40f6:	9b 01       	movw	r18, r22
    40f8:	ac 01       	movw	r20, r24
    40fa:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    40fe:	6b 01       	movw	r12, r22
    4100:	7c 01       	movw	r14, r24
    4102:	29 81       	ldd	r18, Y+1	; 0x01
    4104:	3d 81       	ldd	r19, Y+5	; 0x05
    4106:	49 85       	ldd	r20, Y+9	; 0x09
    4108:	59 89       	ldd	r21, Y+17	; 0x11
    410a:	6e 89       	ldd	r22, Y+22	; 0x16
    410c:	7f 89       	ldd	r23, Y+23	; 0x17
    410e:	88 8d       	ldd	r24, Y+24	; 0x18
    4110:	99 8d       	ldd	r25, Y+25	; 0x19
    4112:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    4116:	9b 01       	movw	r18, r22
    4118:	ac 01       	movw	r20, r24
    411a:	c7 01       	movw	r24, r14
    411c:	b6 01       	movw	r22, r12
    411e:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__divsf3>
    4122:	46 2e       	mov	r4, r22
    4124:	37 2e       	mov	r3, r23
    4126:	28 2e       	mov	r2, r24
    4128:	9b af       	std	Y+59, r25	; 0x3b
            prep.ramp_type = RAMP_CRUISE;
            prep.current_speed = prep.maximum_speed;
    412a:	be 89       	ldd	r27, Y+22	; 0x16
    412c:	b9 83       	std	Y+1, r27	; 0x01
    412e:	ef 89       	ldd	r30, Y+23	; 0x17
    4130:	ed 83       	std	Y+5, r30	; 0x05
    4132:	f8 8d       	ldd	r31, Y+24	; 0x18
    4134:	f9 87       	std	Y+9, r31	; 0x09
    4136:	29 8d       	ldd	r18, Y+25	; 0x19
    4138:	29 8b       	std	Y+17, r18	; 0x11
      switch (prep.ramp_type) {
        case RAMP_DECEL_OVERRIDE:
          speed_var = pl_block->acceleration*time_var;
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
    413a:	ee 8c       	ldd	r14, Y+30	; 0x1e
    413c:	df 8c       	ldd	r13, Y+31	; 0x1f
    413e:	c8 a0       	ldd	r12, Y+32	; 0x20
    4140:	f9 a0       	ldd	r15, Y+33	; 0x21
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            prep.ramp_type = RAMP_CRUISE;
    4142:	38 ad       	ldd	r19, Y+56	; 0x38
    4144:	3c af       	std	Y+60, r19	; 0x3c
    4146:	80 c1       	rjmp	.+768    	; 0x4448 <st_prep_buffer+0xc04>
            prep.current_speed = prep.maximum_speed;
          } else { // Mid-deceleration override ramp.
            mm_remaining -= time_var*(prep.current_speed - 0.5*speed_var);
    4148:	20 e0       	ldi	r18, 0x00	; 0
    414a:	30 e0       	ldi	r19, 0x00	; 0
    414c:	40 e0       	ldi	r20, 0x00	; 0
    414e:	5f e3       	ldi	r21, 0x3F	; 63
    4150:	6d 85       	ldd	r22, Y+13	; 0x0d
    4152:	7e 85       	ldd	r23, Y+14	; 0x0e
    4154:	8f 85       	ldd	r24, Y+15	; 0x0f
    4156:	98 89       	ldd	r25, Y+16	; 0x10
    4158:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    415c:	9b 01       	movw	r18, r22
    415e:	ac 01       	movw	r20, r24
    4160:	69 81       	ldd	r22, Y+1	; 0x01
    4162:	7d 81       	ldd	r23, Y+5	; 0x05
    4164:	89 85       	ldd	r24, Y+9	; 0x09
    4166:	99 89       	ldd	r25, Y+17	; 0x11
    4168:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    416c:	24 2d       	mov	r18, r4
    416e:	33 2d       	mov	r19, r3
    4170:	42 2d       	mov	r20, r2
    4172:	5b ad       	ldd	r21, Y+59	; 0x3b
    4174:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    4178:	9b 01       	movw	r18, r22
    417a:	ac 01       	movw	r20, r24
    417c:	6e 2d       	mov	r22, r14
    417e:	7d 2d       	mov	r23, r13
    4180:	8c 2d       	mov	r24, r12
    4182:	9f 2d       	mov	r25, r15
    4184:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    4188:	e6 2e       	mov	r14, r22
    418a:	d7 2e       	mov	r13, r23
    418c:	c8 2e       	mov	r12, r24
    418e:	f9 2e       	mov	r15, r25
            prep.current_speed -= speed_var;
    4190:	2d 85       	ldd	r18, Y+13	; 0x0d
    4192:	3e 85       	ldd	r19, Y+14	; 0x0e
    4194:	4f 85       	ldd	r20, Y+15	; 0x0f
    4196:	58 89       	ldd	r21, Y+16	; 0x10
    4198:	69 81       	ldd	r22, Y+1	; 0x01
    419a:	7d 81       	ldd	r23, Y+5	; 0x05
    419c:	89 85       	ldd	r24, Y+9	; 0x09
    419e:	99 89       	ldd	r25, Y+17	; 0x11
    41a0:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    41a4:	69 83       	std	Y+1, r22	; 0x01
    41a6:	7d 83       	std	Y+5, r23	; 0x05
    41a8:	89 87       	std	Y+9, r24	; 0x09
    41aa:	99 8b       	std	Y+17, r25	; 0x11
    41ac:	4d c1       	rjmp	.+666    	; 0x4448 <st_prep_buffer+0xc04>
          }
          break;
        case RAMP_ACCEL:
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
    41ae:	aa 8d       	ldd	r26, Y+26	; 0x1a
    41b0:	bb 8d       	ldd	r27, Y+27	; 0x1b
    41b2:	5e 96       	adiw	r26, 0x1e	; 30
    41b4:	2d 91       	ld	r18, X+
    41b6:	3d 91       	ld	r19, X+
    41b8:	4d 91       	ld	r20, X+
    41ba:	5c 91       	ld	r21, X
    41bc:	91 97       	sbiw	r26, 0x21	; 33
    41be:	64 2d       	mov	r22, r4
    41c0:	73 2d       	mov	r23, r3
    41c2:	82 2d       	mov	r24, r2
    41c4:	9b ad       	ldd	r25, Y+59	; 0x3b
    41c6:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    41ca:	6d 87       	std	Y+13, r22	; 0x0d
    41cc:	7e 87       	std	Y+14, r23	; 0x0e
    41ce:	8f 87       	std	Y+15, r24	; 0x0f
    41d0:	98 8b       	std	Y+16, r25	; 0x10
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
    41d2:	20 e0       	ldi	r18, 0x00	; 0
    41d4:	30 e0       	ldi	r19, 0x00	; 0
    41d6:	40 e0       	ldi	r20, 0x00	; 0
    41d8:	5f e3       	ldi	r21, 0x3F	; 63
    41da:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    41de:	29 81       	ldd	r18, Y+1	; 0x01
    41e0:	3d 81       	ldd	r19, Y+5	; 0x05
    41e2:	49 85       	ldd	r20, Y+9	; 0x09
    41e4:	59 89       	ldd	r21, Y+17	; 0x11
    41e6:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    41ea:	24 2d       	mov	r18, r4
    41ec:	33 2d       	mov	r19, r3
    41ee:	42 2d       	mov	r20, r2
    41f0:	5b ad       	ldd	r21, Y+59	; 0x3b
    41f2:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    41f6:	9b 01       	movw	r18, r22
    41f8:	ac 01       	movw	r20, r24
    41fa:	6e 2d       	mov	r22, r14
    41fc:	7d 2d       	mov	r23, r13
    41fe:	8c 2d       	mov	r24, r12
    4200:	9f 2d       	mov	r25, r15
    4202:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    4206:	e6 2e       	mov	r14, r22
    4208:	d7 2e       	mov	r13, r23
    420a:	c8 2e       	mov	r12, r24
    420c:	f9 2e       	mov	r15, r25
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    420e:	26 2f       	mov	r18, r22
    4210:	37 2f       	mov	r19, r23
    4212:	48 2f       	mov	r20, r24
    4214:	59 2f       	mov	r21, r25
    4216:	6e 8d       	ldd	r22, Y+30	; 0x1e
    4218:	7f 8d       	ldd	r23, Y+31	; 0x1f
    421a:	88 a1       	ldd	r24, Y+32	; 0x20
    421c:	99 a1       	ldd	r25, Y+33	; 0x21
    421e:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    4222:	18 16       	cp	r1, r24
    4224:	9c f5       	brge	.+102    	; 0x428c <st_prep_buffer+0xa48>
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    4226:	2e 8d       	ldd	r18, Y+30	; 0x1e
    4228:	3f 8d       	ldd	r19, Y+31	; 0x1f
    422a:	48 a1       	ldd	r20, Y+32	; 0x20
    422c:	59 a1       	ldd	r21, Y+33	; 0x21
    422e:	6a a5       	ldd	r22, Y+42	; 0x2a
    4230:	7b a5       	ldd	r23, Y+43	; 0x2b
    4232:	8c a5       	ldd	r24, Y+44	; 0x2c
    4234:	9d a5       	ldd	r25, Y+45	; 0x2d
    4236:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    423a:	9b 01       	movw	r18, r22
    423c:	ac 01       	movw	r20, r24
    423e:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    4242:	6b 01       	movw	r12, r22
    4244:	7c 01       	movw	r14, r24
    4246:	29 81       	ldd	r18, Y+1	; 0x01
    4248:	3d 81       	ldd	r19, Y+5	; 0x05
    424a:	49 85       	ldd	r20, Y+9	; 0x09
    424c:	59 89       	ldd	r21, Y+17	; 0x11
    424e:	6e 89       	ldd	r22, Y+22	; 0x16
    4250:	7f 89       	ldd	r23, Y+23	; 0x17
    4252:	88 8d       	ldd	r24, Y+24	; 0x18
    4254:	99 8d       	ldd	r25, Y+25	; 0x19
    4256:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    425a:	9b 01       	movw	r18, r22
    425c:	ac 01       	movw	r20, r24
    425e:	c7 01       	movw	r24, r14
    4260:	b6 01       	movw	r22, r12
    4262:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__divsf3>
    4266:	46 2e       	mov	r4, r22
    4268:	37 2e       	mov	r3, r23
    426a:	28 2e       	mov	r2, r24
    426c:	9b af       	std	Y+59, r25	; 0x3b
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
    426e:	be 89       	ldd	r27, Y+22	; 0x16
    4270:	b9 83       	std	Y+1, r27	; 0x01
    4272:	ef 89       	ldd	r30, Y+23	; 0x17
    4274:	ed 83       	std	Y+5, r30	; 0x05
    4276:	f8 8d       	ldd	r31, Y+24	; 0x18
    4278:	f9 87       	std	Y+9, r31	; 0x09
    427a:	29 8d       	ldd	r18, Y+25	; 0x19
    427c:	29 8b       	std	Y+17, r18	; 0x11
    427e:	3d a9       	ldd	r19, Y+53	; 0x35
    4280:	3c af       	std	Y+60, r19	; 0x3c
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
    4282:	ee 8c       	ldd	r14, Y+30	; 0x1e
    4284:	df 8c       	ldd	r13, Y+31	; 0x1f
    4286:	c8 a0       	ldd	r12, Y+32	; 0x20
    4288:	f9 a0       	ldd	r15, Y+33	; 0x21
    428a:	de c0       	rjmp	.+444    	; 0x4448 <st_prep_buffer+0xc04>
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
          } else { // Acceleration only.
            prep.current_speed += speed_var;
    428c:	2d 85       	ldd	r18, Y+13	; 0x0d
    428e:	3e 85       	ldd	r19, Y+14	; 0x0e
    4290:	4f 85       	ldd	r20, Y+15	; 0x0f
    4292:	58 89       	ldd	r21, Y+16	; 0x10
    4294:	69 81       	ldd	r22, Y+1	; 0x01
    4296:	7d 81       	ldd	r23, Y+5	; 0x05
    4298:	89 85       	ldd	r24, Y+9	; 0x09
    429a:	99 89       	ldd	r25, Y+17	; 0x11
    429c:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    42a0:	69 83       	std	Y+1, r22	; 0x01
    42a2:	7d 83       	std	Y+5, r23	; 0x05
    42a4:	89 87       	std	Y+9, r24	; 0x09
    42a6:	99 8b       	std	Y+17, r25	; 0x11
    42a8:	cf c0       	rjmp	.+414    	; 0x4448 <st_prep_buffer+0xc04>
          break;
        case RAMP_CRUISE:
          // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
          // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To
          //   prevent this, simply enforce a minimum speed threshold in the planner.
          mm_var = mm_remaining - prep.maximum_speed*time_var;
    42aa:	2e 89       	ldd	r18, Y+22	; 0x16
    42ac:	3f 89       	ldd	r19, Y+23	; 0x17
    42ae:	48 8d       	ldd	r20, Y+24	; 0x18
    42b0:	59 8d       	ldd	r21, Y+25	; 0x19
    42b2:	64 2d       	mov	r22, r4
    42b4:	73 2d       	mov	r23, r3
    42b6:	82 2d       	mov	r24, r2
    42b8:	9b ad       	ldd	r25, Y+59	; 0x3b
    42ba:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    42be:	9b 01       	movw	r18, r22
    42c0:	ac 01       	movw	r20, r24
    42c2:	6e 2d       	mov	r22, r14
    42c4:	7d 2d       	mov	r23, r13
    42c6:	8c 2d       	mov	r24, r12
    42c8:	9f 2d       	mov	r25, r15
    42ca:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    42ce:	6d 87       	std	Y+13, r22	; 0x0d
    42d0:	7c 8f       	std	Y+28, r23	; 0x1c
    42d2:	8d 8f       	std	Y+29, r24	; 0x1d
    42d4:	69 2e       	mov	r6, r25
          if (mm_var < prep.decelerate_after) { // End of cruise.
    42d6:	26 2f       	mov	r18, r22
    42d8:	37 2f       	mov	r19, r23
    42da:	48 2f       	mov	r20, r24
    42dc:	59 2f       	mov	r21, r25
    42de:	6e a1       	ldd	r22, Y+38	; 0x26
    42e0:	7f a1       	ldd	r23, Y+39	; 0x27
    42e2:	88 a5       	ldd	r24, Y+40	; 0x28
    42e4:	99 a5       	ldd	r25, Y+41	; 0x29
    42e6:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    42ea:	18 16       	cp	r1, r24
    42ec:	0c f0       	brlt	.+2      	; 0x42f0 <st_prep_buffer+0xaac>
    42ee:	a8 c0       	rjmp	.+336    	; 0x4440 <st_prep_buffer+0xbfc>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
    42f0:	2e a1       	ldd	r18, Y+38	; 0x26
    42f2:	3f a1       	ldd	r19, Y+39	; 0x27
    42f4:	48 a5       	ldd	r20, Y+40	; 0x28
    42f6:	59 a5       	ldd	r21, Y+41	; 0x29
    42f8:	6e 2d       	mov	r22, r14
    42fa:	7d 2d       	mov	r23, r13
    42fc:	8c 2d       	mov	r24, r12
    42fe:	9f 2d       	mov	r25, r15
    4300:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    4304:	2e 89       	ldd	r18, Y+22	; 0x16
    4306:	3f 89       	ldd	r19, Y+23	; 0x17
    4308:	48 8d       	ldd	r20, Y+24	; 0x18
    430a:	59 8d       	ldd	r21, Y+25	; 0x19
    430c:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__divsf3>
    4310:	46 2e       	mov	r4, r22
    4312:	37 2e       	mov	r3, r23
    4314:	28 2e       	mov	r2, r24
    4316:	9b af       	std	Y+59, r25	; 0x3b
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
    4318:	ee a0       	ldd	r14, Y+38	; 0x26
    431a:	df a0       	ldd	r13, Y+39	; 0x27
    431c:	c8 a4       	ldd	r12, Y+40	; 0x28
    431e:	f9 a4       	ldd	r15, Y+41	; 0x29
            prep.ramp_type = RAMP_DECEL;
    4320:	49 ad       	ldd	r20, Y+57	; 0x39
    4322:	4c af       	std	Y+60, r20	; 0x3c
    4324:	91 c0       	rjmp	.+290    	; 0x4448 <st_prep_buffer+0xc04>
            mm_remaining = mm_var;
          }
          break;
        default: // case RAMP_DECEL:
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
    4326:	aa 8d       	ldd	r26, Y+26	; 0x1a
    4328:	bb 8d       	ldd	r27, Y+27	; 0x1b
    432a:	5e 96       	adiw	r26, 0x1e	; 30
    432c:	2d 91       	ld	r18, X+
    432e:	3d 91       	ld	r19, X+
    4330:	4d 91       	ld	r20, X+
    4332:	5c 91       	ld	r21, X
    4334:	91 97       	sbiw	r26, 0x21	; 33
    4336:	64 2d       	mov	r22, r4
    4338:	73 2d       	mov	r23, r3
    433a:	82 2d       	mov	r24, r2
    433c:	9b ad       	ldd	r25, Y+59	; 0x3b
    433e:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    4342:	6d 87       	std	Y+13, r22	; 0x0d
    4344:	7e 87       	std	Y+14, r23	; 0x0e
    4346:	8f 87       	std	Y+15, r24	; 0x0f
    4348:	98 8b       	std	Y+16, r25	; 0x10
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
    434a:	9b 01       	movw	r18, r22
    434c:	ac 01       	movw	r20, r24
    434e:	69 81       	ldd	r22, Y+1	; 0x01
    4350:	7d 81       	ldd	r23, Y+5	; 0x05
    4352:	89 85       	ldd	r24, Y+9	; 0x09
    4354:	99 89       	ldd	r25, Y+17	; 0x11
    4356:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    435a:	18 16       	cp	r1, r24
    435c:	0c f0       	brlt	.+2      	; 0x4360 <st_prep_buffer+0xb1c>
    435e:	3f c0       	rjmp	.+126    	; 0x43de <st_prep_buffer+0xb9a>
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
    4360:	20 e0       	ldi	r18, 0x00	; 0
    4362:	30 e0       	ldi	r19, 0x00	; 0
    4364:	40 e0       	ldi	r20, 0x00	; 0
    4366:	5f e3       	ldi	r21, 0x3F	; 63
    4368:	6d 85       	ldd	r22, Y+13	; 0x0d
    436a:	7e 85       	ldd	r23, Y+14	; 0x0e
    436c:	8f 85       	ldd	r24, Y+15	; 0x0f
    436e:	98 89       	ldd	r25, Y+16	; 0x10
    4370:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    4374:	9b 01       	movw	r18, r22
    4376:	ac 01       	movw	r20, r24
    4378:	69 81       	ldd	r22, Y+1	; 0x01
    437a:	7d 81       	ldd	r23, Y+5	; 0x05
    437c:	89 85       	ldd	r24, Y+9	; 0x09
    437e:	99 89       	ldd	r25, Y+17	; 0x11
    4380:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    4384:	24 2d       	mov	r18, r4
    4386:	33 2d       	mov	r19, r3
    4388:	42 2d       	mov	r20, r2
    438a:	5b ad       	ldd	r21, Y+59	; 0x3b
    438c:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    4390:	9b 01       	movw	r18, r22
    4392:	ac 01       	movw	r20, r24
    4394:	6e 2d       	mov	r22, r14
    4396:	7d 2d       	mov	r23, r13
    4398:	8c 2d       	mov	r24, r12
    439a:	9f 2d       	mov	r25, r15
    439c:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    43a0:	6c 8f       	std	Y+28, r22	; 0x1c
    43a2:	7d 8f       	std	Y+29, r23	; 0x1d
    43a4:	8c ab       	std	Y+52, r24	; 0x34
    43a6:	69 2e       	mov	r6, r25
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
    43a8:	2a 89       	ldd	r18, Y+18	; 0x12
    43aa:	3b 89       	ldd	r19, Y+19	; 0x13
    43ac:	4c 89       	ldd	r20, Y+20	; 0x14
    43ae:	5d 89       	ldd	r21, Y+21	; 0x15
    43b0:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    43b4:	18 16       	cp	r1, r24
    43b6:	9c f4       	brge	.+38     	; 0x43de <st_prep_buffer+0xb9a>
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
    43b8:	2d 85       	ldd	r18, Y+13	; 0x0d
    43ba:	3e 85       	ldd	r19, Y+14	; 0x0e
    43bc:	4f 85       	ldd	r20, Y+15	; 0x0f
    43be:	58 89       	ldd	r21, Y+16	; 0x10
    43c0:	69 81       	ldd	r22, Y+1	; 0x01
    43c2:	7d 81       	ldd	r23, Y+5	; 0x05
    43c4:	89 85       	ldd	r24, Y+9	; 0x09
    43c6:	99 89       	ldd	r25, Y+17	; 0x11
    43c8:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    43cc:	69 83       	std	Y+1, r22	; 0x01
    43ce:	7d 83       	std	Y+5, r23	; 0x05
    43d0:	89 87       	std	Y+9, r24	; 0x09
    43d2:	99 8b       	std	Y+17, r25	; 0x11
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
              mm_remaining = mm_var;
    43d4:	ec 8c       	ldd	r14, Y+28	; 0x1c
    43d6:	dd 8c       	ldd	r13, Y+29	; 0x1d
    43d8:	cc a8       	ldd	r12, Y+52	; 0x34
    43da:	f6 2c       	mov	r15, r6
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
    43dc:	35 c0       	rjmp	.+106    	; 0x4448 <st_prep_buffer+0xc04>
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    43de:	2a 89       	ldd	r18, Y+18	; 0x12
    43e0:	3b 89       	ldd	r19, Y+19	; 0x13
    43e2:	4c 89       	ldd	r20, Y+20	; 0x14
    43e4:	5d 89       	ldd	r21, Y+21	; 0x15
    43e6:	6e 2d       	mov	r22, r14
    43e8:	7d 2d       	mov	r23, r13
    43ea:	8c 2d       	mov	r24, r12
    43ec:	9f 2d       	mov	r25, r15
    43ee:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    43f2:	9b 01       	movw	r18, r22
    43f4:	ac 01       	movw	r20, r24
    43f6:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    43fa:	6b 01       	movw	r12, r22
    43fc:	7c 01       	movw	r14, r24
    43fe:	2e a5       	ldd	r18, Y+46	; 0x2e
    4400:	3f a5       	ldd	r19, Y+47	; 0x2f
    4402:	48 a9       	ldd	r20, Y+48	; 0x30
    4404:	59 a9       	ldd	r21, Y+49	; 0x31
    4406:	69 81       	ldd	r22, Y+1	; 0x01
    4408:	7d 81       	ldd	r23, Y+5	; 0x05
    440a:	89 85       	ldd	r24, Y+9	; 0x09
    440c:	99 89       	ldd	r25, Y+17	; 0x11
    440e:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    4412:	9b 01       	movw	r18, r22
    4414:	ac 01       	movw	r20, r24
    4416:	c7 01       	movw	r24, r14
    4418:	b6 01       	movw	r22, r12
    441a:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__divsf3>
    441e:	46 2e       	mov	r4, r22
    4420:	37 2e       	mov	r3, r23
    4422:	28 2e       	mov	r2, r24
    4424:	9b af       	std	Y+59, r25	; 0x3b
          mm_remaining = prep.mm_complete;
          prep.current_speed = prep.exit_speed;
    4426:	be a5       	ldd	r27, Y+46	; 0x2e
    4428:	b9 83       	std	Y+1, r27	; 0x01
    442a:	ef a5       	ldd	r30, Y+47	; 0x2f
    442c:	ed 83       	std	Y+5, r30	; 0x05
    442e:	f8 a9       	ldd	r31, Y+48	; 0x30
    4430:	f9 87       	std	Y+9, r31	; 0x09
    4432:	29 a9       	ldd	r18, Y+49	; 0x31
    4434:	29 8b       	std	Y+17, r18	; 0x11
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete;
    4436:	ea 88       	ldd	r14, Y+18	; 0x12
    4438:	db 88       	ldd	r13, Y+19	; 0x13
    443a:	cc 88       	ldd	r12, Y+20	; 0x14
    443c:	fd 88       	ldd	r15, Y+21	; 0x15
    443e:	04 c0       	rjmp	.+8      	; 0x4448 <st_prep_buffer+0xc04>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
          } else { // Cruising only.
            mm_remaining = mm_var;
    4440:	ed 84       	ldd	r14, Y+13	; 0x0d
    4442:	dc 8c       	ldd	r13, Y+28	; 0x1c
    4444:	cd 8c       	ldd	r12, Y+29	; 0x1d
    4446:	f6 2c       	mov	r15, r6
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete;
          prep.current_speed = prep.exit_speed;
      }
      dt += time_var; // Add computed ramp time to total segment time.
    4448:	24 2d       	mov	r18, r4
    444a:	33 2d       	mov	r19, r3
    444c:	42 2d       	mov	r20, r2
    444e:	5b ad       	ldd	r21, Y+59	; 0x3b
    4450:	c5 01       	movw	r24, r10
    4452:	b4 01       	movw	r22, r8
    4454:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    4458:	4b 01       	movw	r8, r22
    445a:	5c 01       	movw	r10, r24
      if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
    445c:	9b 01       	movw	r18, r22
    445e:	ac 01       	movw	r20, r24
    4460:	67 2d       	mov	r22, r7
    4462:	75 2d       	mov	r23, r5
    4464:	81 2f       	mov	r24, r17
    4466:	90 2f       	mov	r25, r16
    4468:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    446c:	18 16       	cp	r1, r24
    446e:	6c f4       	brge	.+26     	; 0x448a <st_prep_buffer+0xc46>
    4470:	a5 01       	movw	r20, r10
    4472:	94 01       	movw	r18, r8
    4474:	67 2d       	mov	r22, r7
    4476:	75 2d       	mov	r23, r5
    4478:	81 2f       	mov	r24, r17
    447a:	90 2f       	mov	r25, r16
    447c:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    4480:	46 2e       	mov	r4, r22
    4482:	37 2e       	mov	r3, r23
    4484:	28 2e       	mov	r2, r24
    4486:	9b af       	std	Y+59, r25	; 0x3b
    4488:	36 c0       	rjmp	.+108    	; 0x44f6 <st_prep_buffer+0xcb2>
      else {
        if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
    448a:	2a a1       	ldd	r18, Y+34	; 0x22
    448c:	3b a1       	ldd	r19, Y+35	; 0x23
    448e:	4c a1       	ldd	r20, Y+36	; 0x24
    4490:	5d a1       	ldd	r21, Y+37	; 0x25
    4492:	6e 2d       	mov	r22, r14
    4494:	7d 2d       	mov	r23, r13
    4496:	8c 2d       	mov	r24, r12
    4498:	9f 2d       	mov	r25, r15
    449a:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    449e:	18 16       	cp	r1, r24
    44a0:	a4 f0       	brlt	.+40     	; 0x44ca <st_prep_buffer+0xc86>
    44a2:	3c ad       	ldd	r19, Y+60	; 0x3c
    44a4:	6e a8       	ldd	r6, Y+54	; 0x36
    44a6:	7f a8       	ldd	r7, Y+55	; 0x37
    44a8:	5e 2c       	mov	r5, r14
    44aa:	1d 2d       	mov	r17, r13
    44ac:	0c 2d       	mov	r16, r12
    44ae:	fc 8e       	std	Y+28, r15	; 0x1c
    44b0:	d3 01       	movw	r26, r6
    44b2:	52 96       	adiw	r26, 0x12	; 18
    44b4:	3c 93       	st	X, r19
    44b6:	89 81       	ldd	r24, Y+1	; 0x01
    44b8:	9d 81       	ldd	r25, Y+5	; 0x05
    44ba:	a9 85       	ldd	r26, Y+9	; 0x09
    44bc:	b9 89       	ldd	r27, Y+17	; 0x11
    44be:	f3 01       	movw	r30, r6
    44c0:	87 8b       	std	Z+23, r24	; 0x17
    44c2:	90 8f       	std	Z+24, r25	; 0x18
    44c4:	a1 8f       	std	Z+25, r26	; 0x19
    44c6:	b2 8f       	std	Z+26, r27	; 0x1a
    44c8:	37 c0       	rjmp	.+110    	; 0x4538 <st_prep_buffer+0xcf4>
          // Increase segment time to ensure at least one step in segment. Override and loop
          // through distance calculations until minimum_mm or mm_complete.
          dt_max += DT_SEGMENT;
    44ca:	2e e3       	ldi	r18, 0x3E	; 62
    44cc:	33 ec       	ldi	r19, 0xC3	; 195
    44ce:	4e e2       	ldi	r20, 0x2E	; 46
    44d0:	59 e3       	ldi	r21, 0x39	; 57
    44d2:	67 2d       	mov	r22, r7
    44d4:	75 2d       	mov	r23, r5
    44d6:	81 2f       	mov	r24, r17
    44d8:	90 2f       	mov	r25, r16
    44da:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    44de:	76 2e       	mov	r7, r22
    44e0:	57 2e       	mov	r5, r23
    44e2:	18 2f       	mov	r17, r24
    44e4:	09 2f       	mov	r16, r25
          time_var = dt_max - dt;
    44e6:	a5 01       	movw	r20, r10
    44e8:	94 01       	movw	r18, r8
    44ea:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    44ee:	46 2e       	mov	r4, r22
    44f0:	37 2e       	mov	r3, r23
    44f2:	28 2e       	mov	r2, r24
    44f4:	9b af       	std	Y+59, r25	; 0x3b
        } else {
          break; // **Complete** Exit loop. Segment execution time maxed.
        }
      }
    } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
    44f6:	2a 89       	ldd	r18, Y+18	; 0x12
    44f8:	3b 89       	ldd	r19, Y+19	; 0x13
    44fa:	4c 89       	ldd	r20, Y+20	; 0x14
    44fc:	5d 89       	ldd	r21, Y+21	; 0x15
    44fe:	6e 2d       	mov	r22, r14
    4500:	7d 2d       	mov	r23, r13
    4502:	8c 2d       	mov	r24, r12
    4504:	9f 2d       	mov	r25, r15
    4506:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    450a:	18 16       	cp	r1, r24
    450c:	0c f4       	brge	.+2      	; 0x4510 <st_prep_buffer+0xccc>
    450e:	ba cd       	rjmp	.-1164   	; 0x4084 <st_prep_buffer+0x840>
    4510:	fc ad       	ldd	r31, Y+60	; 0x3c
    4512:	fd 8f       	std	Y+29, r31	; 0x1d
    4514:	6e a8       	ldd	r6, Y+54	; 0x36
    4516:	7f a8       	ldd	r7, Y+55	; 0x37
    4518:	5e 2c       	mov	r5, r14
    451a:	1d 2d       	mov	r17, r13
    451c:	0c 2d       	mov	r16, r12
    451e:	fc 8e       	std	Y+28, r15	; 0x1c
    4520:	d3 01       	movw	r26, r6
    4522:	52 96       	adiw	r26, 0x12	; 18
    4524:	fc 93       	st	X, r31
    4526:	89 81       	ldd	r24, Y+1	; 0x01
    4528:	9d 81       	ldd	r25, Y+5	; 0x05
    452a:	a9 85       	ldd	r26, Y+9	; 0x09
    452c:	b9 89       	ldd	r27, Y+17	; 0x11
    452e:	f3 01       	movw	r30, r6
    4530:	87 8b       	std	Z+23, r24	; 0x17
    4532:	90 8f       	std	Z+24, r25	; 0x18
    4534:	a1 8f       	std	Z+25, r26	; 0x19
    4536:	b2 8f       	std	Z+26, r27	; 0x1a

    /* -----------------------------------------------------------------------------------
      Compute spindle speed PWM output for step segment
    */
    
    if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
    4538:	e0 91 39 03 	lds	r30, 0x0339	; 0x800339 <st_prep_block>
    453c:	f0 91 3a 03 	lds	r31, 0x033A	; 0x80033a <st_prep_block+0x1>
    4540:	81 89       	ldd	r24, Z+17	; 0x11
    4542:	81 11       	cpse	r24, r1
    4544:	99 c1       	rjmp	.+818    	; 0x4878 <st_prep_buffer+0x1034>
    4546:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    454a:	83 fd       	sbrc	r24, 3
    454c:	a5 c1       	rjmp	.+842    	; 0x4898 <st_prep_buffer+0x1054>
    454e:	18 c0       	rjmp	.+48     	; 0x4580 <st_prep_buffer+0xd3c>
        float rpm = pl_block->spindle_speed;
        // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.        
        if (st_prep_block->is_pwm_rate_adjusted) { rpm *= (prep.current_speed * prep.inv_rate); }
        // If current_speed is zero, then may need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE)
        // but this would be instantaneous only and during a motion. May not matter at all.
        prep.current_spindle_pwm = spindle_compute_pwm_value(rpm);
    4550:	0e 94 ad 12 	call	0x255a	; 0x255a <spindle_compute_pwm_value>
    4554:	d3 01       	movw	r26, r6
    4556:	d0 96       	adiw	r26, 0x30	; 48
    4558:	9c 93       	st	X, r25
    455a:	8e 93       	st	-X, r24
    455c:	9f 97       	sbiw	r26, 0x2f	; 47
    455e:	0b c0       	rjmp	.+22     	; 0x4576 <st_prep_buffer+0xd32>
      } else { 
        sys.spindle_speed = 0.0;
    4560:	10 92 2c 0c 	sts	0x0C2C, r1	; 0x800c2c <sys+0xe>
    4564:	10 92 2d 0c 	sts	0x0C2D, r1	; 0x800c2d <sys+0xf>
    4568:	10 92 2e 0c 	sts	0x0C2E, r1	; 0x800c2e <sys+0x10>
    456c:	10 92 2f 0c 	sts	0x0C2F, r1	; 0x800c2f <sys+0x11>
        prep.current_spindle_pwm = SPINDLE_PWM_OFF_VALUE;
    4570:	f3 01       	movw	r30, r6
    4572:	10 aa       	std	Z+48, r1	; 0x30
    4574:	17 a6       	std	Z+47, r1	; 0x2f
      }
      bit_false(sys.step_control,STEP_CONTROL_UPDATE_SPINDLE_PWM);
    4576:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    457a:	87 7f       	andi	r24, 0xF7	; 247
    457c:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <sys+0x4>
    }
    prep_segment->spindle_pwm = prep.current_spindle_pwm; // Reload segment PWM value
    4580:	8a a9       	ldd	r24, Y+50	; 0x32
    4582:	9b a9       	ldd	r25, Y+51	; 0x33
    4584:	88 0f       	add	r24, r24
    4586:	99 1f       	adc	r25, r25
    4588:	88 0f       	add	r24, r24
    458a:	99 1f       	adc	r25, r25
    458c:	88 0f       	add	r24, r24
    458e:	99 1f       	adc	r25, r25
    4590:	9c 01       	movw	r18, r24
    4592:	2a 59       	subi	r18, 0x9A	; 154
    4594:	3c 4f       	sbci	r19, 0xFC	; 252
    4596:	19 01       	movw	r2, r18
    4598:	d3 01       	movw	r26, r6
    459a:	9f 96       	adiw	r26, 0x2f	; 47
    459c:	8d 91       	ld	r24, X+
    459e:	9c 91       	ld	r25, X
    45a0:	d0 97       	sbiw	r26, 0x30	; 48
    45a2:	f9 01       	movw	r30, r18
    45a4:	97 83       	std	Z+7, r25	; 0x07
    45a6:	86 83       	std	Z+6, r24	; 0x06
       However, since floats have only 7.2 significant digits, long moves with extremely
       high step counts can exceed the precision of floats, which can lead to lost steps.
       Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
       supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    */
    float step_dist_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
    45a8:	1a 96       	adiw	r26, 0x0a	; 10
    45aa:	2d 91       	ld	r18, X+
    45ac:	3d 91       	ld	r19, X+
    45ae:	4d 91       	ld	r20, X+
    45b0:	5c 91       	ld	r21, X
    45b2:	1d 97       	sbiw	r26, 0x0d	; 13
    45b4:	65 2d       	mov	r22, r5
    45b6:	71 2f       	mov	r23, r17
    45b8:	80 2f       	mov	r24, r16
    45ba:	9c 8d       	ldd	r25, Y+28	; 0x1c
    45bc:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    45c0:	69 83       	std	Y+1, r22	; 0x01
    45c2:	7a 83       	std	Y+2, r23	; 0x02
    45c4:	8b 83       	std	Y+3, r24	; 0x03
    45c6:	9c 83       	std	Y+4, r25	; 0x04
    float n_steps_remaining = ceil(step_dist_remaining); // Round-up current steps remaining
    45c8:	0e 94 52 3f 	call	0x7ea4	; 0x7ea4 <ceil>
    45cc:	6d 83       	std	Y+5, r22	; 0x05
    45ce:	7e 83       	std	Y+6, r23	; 0x06
    45d0:	8f 83       	std	Y+7, r24	; 0x07
    45d2:	98 87       	std	Y+8, r25	; 0x08
    float last_n_steps_remaining = ceil(prep.steps_remaining); // Round-up last steps remaining
    45d4:	d3 01       	movw	r26, r6
    45d6:	16 96       	adiw	r26, 0x06	; 6
    45d8:	6d 91       	ld	r22, X+
    45da:	7d 91       	ld	r23, X+
    45dc:	8d 91       	ld	r24, X+
    45de:	9c 91       	ld	r25, X
    45e0:	19 97       	sbiw	r26, 0x09	; 9
    45e2:	0e 94 52 3f 	call	0x7ea4	; 0x7ea4 <ceil>
    45e6:	69 87       	std	Y+9, r22	; 0x09
    45e8:	7a 87       	std	Y+10, r23	; 0x0a
    45ea:	8b 87       	std	Y+11, r24	; 0x0b
    45ec:	9c 87       	std	Y+12, r25	; 0x0c
    prep_segment->n_step = last_n_steps_remaining-n_steps_remaining; // Compute number of steps to execute.
    45ee:	2d 81       	ldd	r18, Y+5	; 0x05
    45f0:	3e 81       	ldd	r19, Y+6	; 0x06
    45f2:	4f 81       	ldd	r20, Y+7	; 0x07
    45f4:	58 85       	ldd	r21, Y+8	; 0x08
    45f6:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    45fa:	0e 94 d9 3f 	call	0x7fb2	; 0x7fb2 <__fixunssfsi>
    45fe:	6b 01       	movw	r12, r22
    4600:	7c 01       	movw	r14, r24
    4602:	f1 01       	movw	r30, r2
    4604:	71 83       	std	Z+1, r23	; 0x01
    4606:	60 83       	st	Z, r22

    // Bail if we are at the end of a feed hold and don't have a step to execute.
    if (prep_segment->n_step == 0) {
    4608:	67 2b       	or	r22, r23
    460a:	41 f4       	brne	.+16     	; 0x461c <st_prep_buffer+0xdd8>
      if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) {
    460c:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    4610:	81 ff       	sbrs	r24, 1
    4612:	04 c0       	rjmp	.+8      	; 0x461c <st_prep_buffer+0xdd8>
        // Less than one step to decelerate to zero speed, but already very close. AMASS
        // requires full steps to execute. So, just bail.
        bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    4614:	81 60       	ori	r24, 0x01	; 1
    4616:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <sys+0x4>
        #ifdef PARKING_ENABLE
          if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
        #endif
        return; // Segment not generated, but current step data still retained.
    461a:	44 c1       	rjmp	.+648    	; 0x48a4 <st_prep_buffer+0x1060>
    // apply it with the partial step distance to the current segment, so that it minutely
    // adjusts the whole segment rate to keep step output exact. These rate adjustments are
    // typically very small and do not adversely effect performance, but ensures that Grbl
    // outputs the exact acceleration and velocity profiles as computed by the planner.
    dt += prep.dt_remainder; // Apply previous segment partial step execute time
    float inv_rate = dt/(last_n_steps_remaining - step_dist_remaining); // Compute adjusted step rate inverse
    461c:	d3 01       	movw	r26, r6
    461e:	12 96       	adiw	r26, 0x02	; 2
    4620:	2d 91       	ld	r18, X+
    4622:	3d 91       	ld	r19, X+
    4624:	4d 91       	ld	r20, X+
    4626:	5c 91       	ld	r21, X
    4628:	15 97       	sbiw	r26, 0x05	; 5
    462a:	c5 01       	movw	r24, r10
    462c:	b4 01       	movw	r22, r8
    462e:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    4632:	4b 01       	movw	r8, r22
    4634:	5c 01       	movw	r10, r24
    4636:	29 81       	ldd	r18, Y+1	; 0x01
    4638:	3a 81       	ldd	r19, Y+2	; 0x02
    463a:	4b 81       	ldd	r20, Y+3	; 0x03
    463c:	5c 81       	ldd	r21, Y+4	; 0x04
    463e:	69 85       	ldd	r22, Y+9	; 0x09
    4640:	7a 85       	ldd	r23, Y+10	; 0x0a
    4642:	8b 85       	ldd	r24, Y+11	; 0x0b
    4644:	9c 85       	ldd	r25, Y+12	; 0x0c
    4646:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    464a:	9b 01       	movw	r18, r22
    464c:	ac 01       	movw	r20, r24
    464e:	c5 01       	movw	r24, r10
    4650:	b4 01       	movw	r22, r8
    4652:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__divsf3>
    4656:	4b 01       	movw	r8, r22
    4658:	5c 01       	movw	r10, r24

    // Compute CPU cycles per step for the prepped segment.
    uint32_t cycles = ceil( (TICKS_PER_MICROSECOND*1000000*60)*inv_rate ); // (cycles/step)
    465a:	20 ec       	ldi	r18, 0xC0	; 192
    465c:	31 ee       	ldi	r19, 0xE1	; 225
    465e:	44 e6       	ldi	r20, 0x64	; 100
    4660:	5e e4       	ldi	r21, 0x4E	; 78
    4662:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    4666:	0e 94 52 3f 	call	0x7ea4	; 0x7ea4 <ceil>
    466a:	0e 94 d9 3f 	call	0x7fb2	; 0x7fb2 <__fixunssfsi>

    #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
      // Compute step timing and multi-axis smoothing level.
      // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
      if (cycles < AMASS_LEVEL1) { prep_segment->amass_level = 0; }
    466e:	60 3d       	cpi	r22, 0xD0	; 208
    4670:	b7 e0       	ldi	r27, 0x07	; 7
    4672:	7b 07       	cpc	r23, r27
    4674:	81 05       	cpc	r24, r1
    4676:	91 05       	cpc	r25, r1
    4678:	60 f4       	brcc	.+24     	; 0x4692 <st_prep_buffer+0xe4e>
    467a:	ea a9       	ldd	r30, Y+50	; 0x32
    467c:	fb a9       	ldd	r31, Y+51	; 0x33
    467e:	ee 0f       	add	r30, r30
    4680:	ff 1f       	adc	r31, r31
    4682:	ee 0f       	add	r30, r30
    4684:	ff 1f       	adc	r31, r31
    4686:	ee 0f       	add	r30, r30
    4688:	ff 1f       	adc	r31, r31
    468a:	ea 59       	subi	r30, 0x9A	; 154
    468c:	fc 4f       	sbci	r31, 0xFC	; 252
    468e:	15 82       	std	Z+5, r1	; 0x05
    4690:	4d c0       	rjmp	.+154    	; 0x472c <st_prep_buffer+0xee8>
      else {
        if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }
    4692:	60 3a       	cpi	r22, 0xA0	; 160
    4694:	ef e0       	ldi	r30, 0x0F	; 15
    4696:	7e 07       	cpc	r23, r30
    4698:	81 05       	cpc	r24, r1
    469a:	91 05       	cpc	r25, r1
    469c:	68 f4       	brcc	.+26     	; 0x46b8 <st_prep_buffer+0xe74>
    469e:	ea a9       	ldd	r30, Y+50	; 0x32
    46a0:	fb a9       	ldd	r31, Y+51	; 0x33
    46a2:	ee 0f       	add	r30, r30
    46a4:	ff 1f       	adc	r31, r31
    46a6:	ee 0f       	add	r30, r30
    46a8:	ff 1f       	adc	r31, r31
    46aa:	ee 0f       	add	r30, r30
    46ac:	ff 1f       	adc	r31, r31
    46ae:	ea 59       	subi	r30, 0x9A	; 154
    46b0:	fc 4f       	sbci	r31, 0xFC	; 252
    46b2:	21 e0       	ldi	r18, 0x01	; 1
    46b4:	25 83       	std	Z+5, r18	; 0x05
    46b6:	1f c0       	rjmp	.+62     	; 0x46f6 <st_prep_buffer+0xeb2>
        else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }
    46b8:	60 34       	cpi	r22, 0x40	; 64
    46ba:	3f e1       	ldi	r19, 0x1F	; 31
    46bc:	73 07       	cpc	r23, r19
    46be:	81 05       	cpc	r24, r1
    46c0:	91 05       	cpc	r25, r1
    46c2:	68 f4       	brcc	.+26     	; 0x46de <st_prep_buffer+0xe9a>
    46c4:	ea a9       	ldd	r30, Y+50	; 0x32
    46c6:	fb a9       	ldd	r31, Y+51	; 0x33
    46c8:	ee 0f       	add	r30, r30
    46ca:	ff 1f       	adc	r31, r31
    46cc:	ee 0f       	add	r30, r30
    46ce:	ff 1f       	adc	r31, r31
    46d0:	ee 0f       	add	r30, r30
    46d2:	ff 1f       	adc	r31, r31
    46d4:	ea 59       	subi	r30, 0x9A	; 154
    46d6:	fc 4f       	sbci	r31, 0xFC	; 252
    46d8:	42 e0       	ldi	r20, 0x02	; 2
    46da:	45 83       	std	Z+5, r20	; 0x05
    46dc:	0c c0       	rjmp	.+24     	; 0x46f6 <st_prep_buffer+0xeb2>
        else { prep_segment->amass_level = 3; }
    46de:	ea a9       	ldd	r30, Y+50	; 0x32
    46e0:	fb a9       	ldd	r31, Y+51	; 0x33
    46e2:	ee 0f       	add	r30, r30
    46e4:	ff 1f       	adc	r31, r31
    46e6:	ee 0f       	add	r30, r30
    46e8:	ff 1f       	adc	r31, r31
    46ea:	ee 0f       	add	r30, r30
    46ec:	ff 1f       	adc	r31, r31
    46ee:	ea 59       	subi	r30, 0x9A	; 154
    46f0:	fc 4f       	sbci	r31, 0xFC	; 252
    46f2:	53 e0       	ldi	r21, 0x03	; 3
    46f4:	55 83       	std	Z+5, r21	; 0x05
        cycles >>= prep_segment->amass_level;
    46f6:	ea a9       	ldd	r30, Y+50	; 0x32
    46f8:	fb a9       	ldd	r31, Y+51	; 0x33
    46fa:	ee 0f       	add	r30, r30
    46fc:	ff 1f       	adc	r31, r31
    46fe:	ee 0f       	add	r30, r30
    4700:	ff 1f       	adc	r31, r31
    4702:	ee 0f       	add	r30, r30
    4704:	ff 1f       	adc	r31, r31
    4706:	ea 59       	subi	r30, 0x9A	; 154
    4708:	fc 4f       	sbci	r31, 0xFC	; 252
    470a:	25 81       	ldd	r18, Z+5	; 0x05
    470c:	02 2e       	mov	r0, r18
    470e:	04 c0       	rjmp	.+8      	; 0x4718 <st_prep_buffer+0xed4>
    4710:	96 95       	lsr	r25
    4712:	87 95       	ror	r24
    4714:	77 95       	ror	r23
    4716:	67 95       	ror	r22
    4718:	0a 94       	dec	r0
    471a:	d2 f7       	brpl	.-12     	; 0x4710 <st_prep_buffer+0xecc>
        prep_segment->n_step <<= prep_segment->amass_level;
    471c:	d6 01       	movw	r26, r12
    471e:	02 c0       	rjmp	.+4      	; 0x4724 <st_prep_buffer+0xee0>
    4720:	aa 0f       	add	r26, r26
    4722:	bb 1f       	adc	r27, r27
    4724:	2a 95       	dec	r18
    4726:	e2 f7       	brpl	.-8      	; 0x4720 <st_prep_buffer+0xedc>
    4728:	b1 83       	std	Z+1, r27	; 0x01
    472a:	a0 83       	st	Z, r26
      }
      if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)
    472c:	61 15       	cp	r22, r1
    472e:	71 05       	cpc	r23, r1
    4730:	b1 e0       	ldi	r27, 0x01	; 1
    4732:	8b 07       	cpc	r24, r27
    4734:	91 05       	cpc	r25, r1
    4736:	68 f4       	brcc	.+26     	; 0x4752 <st_prep_buffer+0xf0e>
    4738:	ea a9       	ldd	r30, Y+50	; 0x32
    473a:	fb a9       	ldd	r31, Y+51	; 0x33
    473c:	ee 0f       	add	r30, r30
    473e:	ff 1f       	adc	r31, r31
    4740:	ee 0f       	add	r30, r30
    4742:	ff 1f       	adc	r31, r31
    4744:	ee 0f       	add	r30, r30
    4746:	ff 1f       	adc	r31, r31
    4748:	ea 59       	subi	r30, 0x9A	; 154
    474a:	fc 4f       	sbci	r31, 0xFC	; 252
    474c:	73 83       	std	Z+3, r23	; 0x03
    474e:	62 83       	std	Z+2, r22	; 0x02
    4750:	0e c0       	rjmp	.+28     	; 0x476e <st_prep_buffer+0xf2a>
      else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
    4752:	ea a9       	ldd	r30, Y+50	; 0x32
    4754:	fb a9       	ldd	r31, Y+51	; 0x33
    4756:	ee 0f       	add	r30, r30
    4758:	ff 1f       	adc	r31, r31
    475a:	ee 0f       	add	r30, r30
    475c:	ff 1f       	adc	r31, r31
    475e:	ee 0f       	add	r30, r30
    4760:	ff 1f       	adc	r31, r31
    4762:	ea 59       	subi	r30, 0x9A	; 154
    4764:	fc 4f       	sbci	r31, 0xFC	; 252
    4766:	2f ef       	ldi	r18, 0xFF	; 255
    4768:	3f ef       	ldi	r19, 0xFF	; 255
    476a:	33 83       	std	Z+3, r19	; 0x03
    476c:	22 83       	std	Z+2, r18	; 0x02
        }
      }
    #endif

    // Segment complete! Increment segment buffer indices, so stepper ISR can immediately execute it.
    segment_buffer_head = segment_next_head;
    476e:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <segment_next_head>
    4772:	80 93 41 03 	sts	0x0341, r24	; 0x800341 <segment_buffer_head>
    if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
    4776:	8f 5f       	subi	r24, 0xFF	; 255
    4778:	8a 30       	cpi	r24, 0x0A	; 10
    477a:	19 f0       	breq	.+6      	; 0x4782 <st_prep_buffer+0xf3e>
    477c:	80 93 40 03 	sts	0x0340, r24	; 0x800340 <segment_next_head>
    4780:	02 c0       	rjmp	.+4      	; 0x4786 <st_prep_buffer+0xf42>
    4782:	10 92 40 03 	sts	0x0340, r1	; 0x800340 <segment_next_head>

    // Update the appropriate planner and segment data.
    pl_block->millimeters = mm_remaining;
    4786:	e0 91 3b 03 	lds	r30, 0x033B	; 0x80033b <pl_block>
    478a:	f0 91 3c 03 	lds	r31, 0x033C	; 0x80033c <pl_block+0x1>
    478e:	85 2d       	mov	r24, r5
    4790:	91 2f       	mov	r25, r17
    4792:	a0 2f       	mov	r26, r16
    4794:	bc 8d       	ldd	r27, Y+28	; 0x1c
    4796:	82 a3       	std	Z+34, r24	; 0x22
    4798:	93 a3       	std	Z+35, r25	; 0x23
    479a:	a4 a3       	std	Z+36, r26	; 0x24
    479c:	b5 a3       	std	Z+37, r27	; 0x25
    prep.steps_remaining = n_steps_remaining;
    479e:	8d 81       	ldd	r24, Y+5	; 0x05
    47a0:	9e 81       	ldd	r25, Y+6	; 0x06
    47a2:	af 81       	ldd	r26, Y+7	; 0x07
    47a4:	b8 85       	ldd	r27, Y+8	; 0x08
    47a6:	f3 01       	movw	r30, r6
    47a8:	86 83       	std	Z+6, r24	; 0x06
    47aa:	97 83       	std	Z+7, r25	; 0x07
    47ac:	a0 87       	std	Z+8, r26	; 0x08
    47ae:	b1 87       	std	Z+9, r27	; 0x09
    prep.dt_remainder = (n_steps_remaining - step_dist_remaining)*inv_rate;
    47b0:	29 81       	ldd	r18, Y+1	; 0x01
    47b2:	3a 81       	ldd	r19, Y+2	; 0x02
    47b4:	4b 81       	ldd	r20, Y+3	; 0x03
    47b6:	5c 81       	ldd	r21, Y+4	; 0x04
    47b8:	bc 01       	movw	r22, r24
    47ba:	cd 01       	movw	r24, r26
    47bc:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    47c0:	a5 01       	movw	r20, r10
    47c2:	94 01       	movw	r18, r8
    47c4:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    47c8:	d3 01       	movw	r26, r6
    47ca:	12 96       	adiw	r26, 0x02	; 2
    47cc:	6d 93       	st	X+, r22
    47ce:	7d 93       	st	X+, r23
    47d0:	8d 93       	st	X+, r24
    47d2:	9c 93       	st	X, r25
    47d4:	15 97       	sbiw	r26, 0x05	; 5

    // Check for exit conditions and flag to load next planner block.
    if (mm_remaining == prep.mm_complete) {
    47d6:	53 96       	adiw	r26, 0x13	; 19
    47d8:	2d 91       	ld	r18, X+
    47da:	3d 91       	ld	r19, X+
    47dc:	4d 91       	ld	r20, X+
    47de:	5c 91       	ld	r21, X
    47e0:	56 97       	sbiw	r26, 0x16	; 22
    47e2:	65 2d       	mov	r22, r5
    47e4:	71 2f       	mov	r23, r17
    47e6:	80 2f       	mov	r24, r16
    47e8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    47ea:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    47ee:	81 11       	cpse	r24, r1
    47f0:	22 c0       	rjmp	.+68     	; 0x4836 <st_prep_buffer+0xff2>
    47f2:	45 2c       	mov	r4, r5
    47f4:	2c 8c       	ldd	r2, Y+28	; 0x1c
      // End of planner block or forced-termination. No more distance to be executed.
      if (mm_remaining > 0.0) { // At end of forced-termination.
    47f6:	20 e0       	ldi	r18, 0x00	; 0
    47f8:	30 e0       	ldi	r19, 0x00	; 0
    47fa:	a9 01       	movw	r20, r18
    47fc:	64 2d       	mov	r22, r4
    47fe:	71 2f       	mov	r23, r17
    4800:	80 2f       	mov	r24, r16
    4802:	92 2d       	mov	r25, r2
    4804:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    4808:	18 16       	cp	r1, r24
    480a:	34 f4       	brge	.+12     	; 0x4818 <st_prep_buffer+0xfd4>
        // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
        // the segment queue, where realtime protocol will set new state upon receiving the
        // cycle stop flag from the ISR. Prep_segment is blocked until then.
        bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    480c:	ee e1       	ldi	r30, 0x1E	; 30
    480e:	fc e0       	ldi	r31, 0x0C	; 12
    4810:	84 81       	ldd	r24, Z+4	; 0x04
    4812:	81 60       	ori	r24, 0x01	; 1
    4814:	84 83       	std	Z+4, r24	; 0x04
        #ifdef PARKING_ENABLE
          if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
        #endif
        return; // Bail!
    4816:	46 c0       	rjmp	.+140    	; 0x48a4 <st_prep_buffer+0x1060>
      } else { // End of planner block
        // The planner block is complete. All steps are set to be executed in the segment buffer.
        if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
    4818:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <sys+0x4>
    481c:	82 ff       	sbrs	r24, 2
    481e:	04 c0       	rjmp	.+8      	; 0x4828 <st_prep_buffer+0xfe4>
          bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    4820:	81 60       	ori	r24, 0x01	; 1
    4822:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <sys+0x4>
          return;
    4826:	3e c0       	rjmp	.+124    	; 0x48a4 <st_prep_buffer+0x1060>
        }
        pl_block = NULL; // Set pointer to indicate check and load next planner block.
    4828:	10 92 3c 03 	sts	0x033C, r1	; 0x80033c <pl_block+0x1>
    482c:	10 92 3b 03 	sts	0x033B, r1	; 0x80033b <pl_block>
        plan_discard_current_block();
    4830:	25 d5       	rcall	.+2634   	; 0x527c <plan_discard_current_block>
          speed_var = pl_block->acceleration*time_var;
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            prep.ramp_type = RAMP_CRUISE;
    4832:	b1 e0       	ldi	r27, 0x01	; 1
    4834:	b8 af       	std	Y+56, r27	; 0x38
void st_prep_buffer()
{
  // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }

  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
    4836:	90 91 42 03 	lds	r25, 0x0342	; 0x800342 <segment_buffer_tail>
    483a:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <segment_next_head>
    483e:	98 13       	cpse	r25, r24
    4840:	2b c8       	rjmp	.-4010   	; 0x3898 <st_prep_buffer+0x54>
    4842:	30 c0       	rjmp	.+96     	; 0x48a4 <st_prep_buffer+0x1060>
      Compute spindle speed PWM output for step segment
    */
    
    if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
      if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
        float rpm = pl_block->spindle_speed;
    4844:	ea 8d       	ldd	r30, Y+26	; 0x1a
    4846:	fb 8d       	ldd	r31, Y+27	; 0x1b
    4848:	c2 a8       	ldd	r12, Z+50	; 0x32
    484a:	d3 a8       	ldd	r13, Z+51	; 0x33
    484c:	e4 a8       	ldd	r14, Z+52	; 0x34
    484e:	f5 a8       	ldd	r15, Z+53	; 0x35
        // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.        
        if (st_prep_block->is_pwm_rate_adjusted) { rpm *= (prep.current_speed * prep.inv_rate); }
    4850:	d3 01       	movw	r26, r6
    4852:	9b 96       	adiw	r26, 0x2b	; 43
    4854:	2d 91       	ld	r18, X+
    4856:	3d 91       	ld	r19, X+
    4858:	4d 91       	ld	r20, X+
    485a:	5c 91       	ld	r21, X
    485c:	9e 97       	sbiw	r26, 0x2e	; 46
    485e:	57 96       	adiw	r26, 0x17	; 23
    4860:	6d 91       	ld	r22, X+
    4862:	7d 91       	ld	r23, X+
    4864:	8d 91       	ld	r24, X+
    4866:	9c 91       	ld	r25, X
    4868:	5a 97       	sbiw	r26, 0x1a	; 26
    486a:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    486e:	a7 01       	movw	r20, r14
    4870:	96 01       	movw	r18, r12
    4872:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    4876:	6c ce       	rjmp	.-808    	; 0x4550 <st_prep_buffer+0xd0c>
    /* -----------------------------------------------------------------------------------
      Compute spindle speed PWM output for step segment
    */
    
    if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
      if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
    4878:	ea 8d       	ldd	r30, Y+26	; 0x1a
    487a:	fb 8d       	ldd	r31, Y+27	; 0x1b
    487c:	81 89       	ldd	r24, Z+17	; 0x11
    487e:	80 73       	andi	r24, 0x30	; 48
    4880:	09 f4       	brne	.+2      	; 0x4884 <st_prep_buffer+0x1040>
    4882:	6e ce       	rjmp	.-804    	; 0x4560 <st_prep_buffer+0xd1c>
    4884:	df cf       	rjmp	.-66     	; 0x4844 <st_prep_buffer+0x1000>
        float rpm = pl_block->spindle_speed;
    4886:	aa 8d       	ldd	r26, Y+26	; 0x1a
    4888:	bb 8d       	ldd	r27, Y+27	; 0x1b
    488a:	d2 96       	adiw	r26, 0x32	; 50
    488c:	6d 91       	ld	r22, X+
    488e:	7d 91       	ld	r23, X+
    4890:	8d 91       	ld	r24, X+
    4892:	9c 91       	ld	r25, X
    4894:	d5 97       	sbiw	r26, 0x35	; 53
    4896:	5c ce       	rjmp	.-840    	; 0x4550 <st_prep_buffer+0xd0c>
    /* -----------------------------------------------------------------------------------
      Compute spindle speed PWM output for step segment
    */
    
    if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
      if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
    4898:	ea 8d       	ldd	r30, Y+26	; 0x1a
    489a:	fb 8d       	ldd	r31, Y+27	; 0x1b
    489c:	81 89       	ldd	r24, Z+17	; 0x11
    489e:	80 73       	andi	r24, 0x30	; 48
    48a0:	91 f7       	brne	.-28     	; 0x4886 <st_prep_buffer+0x1042>
    48a2:	5e ce       	rjmp	.-836    	; 0x4560 <st_prep_buffer+0xd1c>
        plan_discard_current_block();
      }
    }

  }
}
    48a4:	ec 96       	adiw	r28, 0x3c	; 60
    48a6:	0f b6       	in	r0, 0x3f	; 63
    48a8:	f8 94       	cli
    48aa:	de bf       	out	0x3e, r29	; 62
    48ac:	0f be       	out	0x3f, r0	; 63
    48ae:	cd bf       	out	0x3d, r28	; 61
    48b0:	df 91       	pop	r29
    48b2:	cf 91       	pop	r28
    48b4:	1f 91       	pop	r17
    48b6:	0f 91       	pop	r16
    48b8:	ff 90       	pop	r15
    48ba:	ef 90       	pop	r14
    48bc:	df 90       	pop	r13
    48be:	cf 90       	pop	r12
    48c0:	bf 90       	pop	r11
    48c2:	af 90       	pop	r10
    48c4:	9f 90       	pop	r9
    48c6:	8f 90       	pop	r8
    48c8:	7f 90       	pop	r7
    48ca:	6f 90       	pop	r6
    48cc:	5f 90       	pop	r5
    48ce:	4f 90       	pop	r4
    48d0:	3f 90       	pop	r3
    48d2:	2f 90       	pop	r2
    48d4:	08 95       	ret

000048d6 <st_get_realtime_rate>:
// however is not exactly the current speed, but the speed computed in the last step segment
// in the segment buffer. It will always be behind by up to the number of segment blocks (-1)
// divided by the ACCELERATION TICKS PER SECOND in seconds.
float st_get_realtime_rate()
{
  if (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)){
    48d6:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    48da:	8c 77       	andi	r24, 0x7C	; 124
    48dc:	49 f0       	breq	.+18     	; 0x48f0 <st_get_realtime_rate+0x1a>
    return prep.current_speed;
    48de:	60 91 1f 03 	lds	r22, 0x031F	; 0x80031f <prep+0x17>
    48e2:	70 91 20 03 	lds	r23, 0x0320	; 0x800320 <prep+0x18>
    48e6:	80 91 21 03 	lds	r24, 0x0321	; 0x800321 <prep+0x19>
    48ea:	90 91 22 03 	lds	r25, 0x0322	; 0x800322 <prep+0x1a>
    48ee:	08 95       	ret
  }
  return 0.0f;
    48f0:	60 e0       	ldi	r22, 0x00	; 0
    48f2:	70 e0       	ldi	r23, 0x00	; 0
    48f4:	cb 01       	movw	r24, r22
}
    48f6:	08 95       	ret

000048f8 <eeprom_get_char>:
 *  \param  addr  EEPROM address to read from.
 *  \return  The byte read from the EEPROM address.
 */
unsigned char eeprom_get_char( unsigned int addr )
{
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    48f8:	f9 99       	sbic	0x1f, 1	; 31
    48fa:	fe cf       	rjmp	.-4      	; 0x48f8 <eeprom_get_char>
	EEAR = addr; // Set EEPROM address register.
    48fc:	92 bd       	out	0x22, r25	; 34
    48fe:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    4900:	81 e0       	ldi	r24, 0x01	; 1
    4902:	8f bb       	out	0x1f, r24	; 31
	return EEDR; // Return the byte read from EEPROM.
    4904:	80 b5       	in	r24, 0x20	; 32
}
    4906:	08 95       	ret

00004908 <eeprom_put_char>:
void eeprom_put_char( unsigned int addr, unsigned char new_value )
{
	char old_value; // Old EEPROM value.
	char diff_mask; // Difference mask, i.e. old value XOR new value.

	cli(); // Ensure atomic operation for the write operation.
    4908:	f8 94       	cli
	
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    490a:	f9 99       	sbic	0x1f, 1	; 31
    490c:	fe cf       	rjmp	.-4      	; 0x490a <eeprom_put_char+0x2>
	#ifndef EEPROM_IGNORE_SELFPROG
	do {} while( SPMCSR & (1<<SELFPRGEN) ); // Wait for completion of SPM.
	#endif
	
	EEAR = addr; // Set EEPROM address register.
    490e:	92 bd       	out	0x22, r25	; 34
    4910:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    4912:	81 e0       	ldi	r24, 0x01	; 1
    4914:	8f bb       	out	0x1f, r24	; 31
	old_value = EEDR; // Get old EEPROM value.
    4916:	80 b5       	in	r24, 0x20	; 32
	diff_mask = old_value ^ new_value; // Get bit differences.
    4918:	86 27       	eor	r24, r22
	
	// Check if any bits are changed to '1' in the new value.
	if( diff_mask & new_value ) {
    491a:	96 2f       	mov	r25, r22
    491c:	98 23       	and	r25, r24
    491e:	59 f0       	breq	.+22     	; 0x4936 <eeprom_put_char+0x2e>
		// Now we know that _some_ bits need to be erased to '1'.
		
		// Check if any bits in the new value are '0'.
		if( new_value != 0xff ) {
    4920:	6f 3f       	cpi	r22, 0xFF	; 255
    4922:	29 f0       	breq	.+10     	; 0x492e <eeprom_put_char+0x26>
			// Now we know that some bits need to be programmed to '0' also.
			
			EEDR = new_value; // Set EEPROM data register.
    4924:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    4926:	84 e0       	ldi	r24, 0x04	; 4
    4928:	8f bb       	out	0x1f, r24	; 31
			       (0<<EEPM1) | (0<<EEPM0); // ...and Erase+Write mode.
			EECR |= (1<<EEPE);  // Start Erase+Write operation.
    492a:	f9 9a       	sbi	0x1f, 1	; 31
    492c:	0a c0       	rjmp	.+20     	; 0x4942 <eeprom_put_char+0x3a>
		} else {
			// Now we know that all bits should be erased.

			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    492e:	84 e1       	ldi	r24, 0x14	; 20
    4930:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM0);  // ...and Erase-only mode.
			EECR |= (1<<EEPE);  // Start Erase-only operation.
    4932:	f9 9a       	sbi	0x1f, 1	; 31
    4934:	06 c0       	rjmp	.+12     	; 0x4942 <eeprom_put_char+0x3a>
		}
	} else {
		// Now we know that _no_ bits need to be erased to '1'.
		
		// Check if any bits are changed from '1' in the old value.
		if( diff_mask ) {
    4936:	88 23       	and	r24, r24
    4938:	21 f0       	breq	.+8      	; 0x4942 <eeprom_put_char+0x3a>
			// Now we know that _some_ bits need to the programmed to '0'.
			
			EEDR = new_value;   // Set EEPROM data register.
    493a:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    493c:	84 e2       	ldi	r24, 0x24	; 36
    493e:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM1);  // ...and Write-only mode.
			EECR |= (1<<EEPE);  // Start Write-only operation.
    4940:	f9 9a       	sbi	0x1f, 1	; 31
		}
	}
	
	sei(); // Restore interrupt flag state.
    4942:	78 94       	sei
    4944:	08 95       	ret

00004946 <memcpy_to_eeprom_with_checksum>:
}

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
    4946:	8f 92       	push	r8
    4948:	9f 92       	push	r9
    494a:	af 92       	push	r10
    494c:	bf 92       	push	r11
    494e:	cf 92       	push	r12
    4950:	df 92       	push	r13
    4952:	ef 92       	push	r14
    4954:	ff 92       	push	r15
    4956:	0f 93       	push	r16
    4958:	1f 93       	push	r17
    495a:	cf 93       	push	r28
    495c:	df 93       	push	r29
    495e:	7c 01       	movw	r14, r24
    4960:	8b 01       	movw	r16, r22
    4962:	6a 01       	movw	r12, r20
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    4964:	41 15       	cp	r20, r1
    4966:	51 05       	cpc	r21, r1
    4968:	01 f1       	breq	.+64     	; 0x49aa <memcpy_to_eeprom_with_checksum+0x64>
    496a:	5a 01       	movw	r10, r20
    496c:	c0 e0       	ldi	r28, 0x00	; 0
    checksum = (checksum << 1) || (checksum >> 7);
    496e:	d1 e0       	ldi	r29, 0x01	; 1
    4970:	01 c0       	rjmp	.+2      	; 0x4974 <memcpy_to_eeprom_with_checksum+0x2e>
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
    4972:	c4 01       	movw	r24, r8


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    4974:	c1 11       	cpse	r28, r1
    4976:	08 c0       	rjmp	.+16     	; 0x4988 <memcpy_to_eeprom_with_checksum+0x42>
    4978:	6c 2f       	mov	r22, r28
    497a:	cc 0f       	add	r28, r28
    497c:	77 0b       	sbc	r23, r23
    497e:	c7 2f       	mov	r28, r23
    4980:	cc 1f       	adc	r28, r28
    4982:	cc 27       	eor	r28, r28
    4984:	cc 1f       	adc	r28, r28
    4986:	01 c0       	rjmp	.+2      	; 0x498a <memcpy_to_eeprom_with_checksum+0x44>
    4988:	cd 2f       	mov	r28, r29
    checksum += *source;
    498a:	f8 01       	movw	r30, r16
    498c:	61 91       	ld	r22, Z+
    498e:	8f 01       	movw	r16, r30
    4990:	c6 0f       	add	r28, r22
    eeprom_put_char(destination++, *(source++)); 
    4992:	4c 01       	movw	r8, r24
    4994:	ff ef       	ldi	r31, 0xFF	; 255
    4996:	8f 1a       	sub	r8, r31
    4998:	9f 0a       	sbc	r9, r31
    499a:	b6 df       	rcall	.-148    	; 0x4908 <eeprom_put_char>
// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    499c:	21 e0       	ldi	r18, 0x01	; 1
    499e:	a2 1a       	sub	r10, r18
    49a0:	b1 08       	sbc	r11, r1
    49a2:	39 f7       	brne	.-50     	; 0x4972 <memcpy_to_eeprom_with_checksum+0x2c>
    49a4:	ec 0c       	add	r14, r12
    49a6:	fd 1c       	adc	r15, r13
    49a8:	01 c0       	rjmp	.+2      	; 0x49ac <memcpy_to_eeprom_with_checksum+0x66>

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
    49aa:	c0 e0       	ldi	r28, 0x00	; 0
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
  }
  eeprom_put_char(destination, checksum);
    49ac:	6c 2f       	mov	r22, r28
    49ae:	c7 01       	movw	r24, r14
    49b0:	ab df       	rcall	.-170    	; 0x4908 <eeprom_put_char>
}
    49b2:	df 91       	pop	r29
    49b4:	cf 91       	pop	r28
    49b6:	1f 91       	pop	r17
    49b8:	0f 91       	pop	r16
    49ba:	ff 90       	pop	r15
    49bc:	ef 90       	pop	r14
    49be:	df 90       	pop	r13
    49c0:	cf 90       	pop	r12
    49c2:	bf 90       	pop	r11
    49c4:	af 90       	pop	r10
    49c6:	9f 90       	pop	r9
    49c8:	8f 90       	pop	r8
    49ca:	08 95       	ret

000049cc <memcpy_from_eeprom_with_checksum>:

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
    49cc:	8f 92       	push	r8
    49ce:	9f 92       	push	r9
    49d0:	af 92       	push	r10
    49d2:	bf 92       	push	r11
    49d4:	cf 92       	push	r12
    49d6:	df 92       	push	r13
    49d8:	ef 92       	push	r14
    49da:	ff 92       	push	r15
    49dc:	0f 93       	push	r16
    49de:	1f 93       	push	r17
    49e0:	cf 93       	push	r28
    49e2:	df 93       	push	r29
    49e4:	7b 01       	movw	r14, r22
    49e6:	6a 01       	movw	r12, r20
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    49e8:	41 15       	cp	r20, r1
    49ea:	51 05       	cpc	r21, r1
    49ec:	09 f1       	breq	.+66     	; 0x4a30 <memcpy_from_eeprom_with_checksum+0x64>
    49ee:	c8 2f       	mov	r28, r24
    49f0:	d9 2f       	mov	r29, r25
    49f2:	5a 01       	movw	r10, r20
    49f4:	cb 01       	movw	r24, r22
    49f6:	91 2c       	mov	r9, r1
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    49f8:	88 24       	eor	r8, r8
    49fa:	83 94       	inc	r8
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    data = eeprom_get_char(source++);
    49fc:	8c 01       	movw	r16, r24
    49fe:	0f 5f       	subi	r16, 0xFF	; 255
    4a00:	1f 4f       	sbci	r17, 0xFF	; 255
    4a02:	7a df       	rcall	.-268    	; 0x48f8 <eeprom_get_char>
    checksum = (checksum << 1) || (checksum >> 7);
    4a04:	91 10       	cpse	r9, r1
    4a06:	08 c0       	rjmp	.+16     	; 0x4a18 <memcpy_from_eeprom_with_checksum+0x4c>
    4a08:	29 2d       	mov	r18, r9
    4a0a:	99 0c       	add	r9, r9
    4a0c:	33 0b       	sbc	r19, r19
    4a0e:	23 2f       	mov	r18, r19
    4a10:	22 1f       	adc	r18, r18
    4a12:	22 27       	eor	r18, r18
    4a14:	22 1f       	adc	r18, r18
    4a16:	01 c0       	rjmp	.+2      	; 0x4a1a <memcpy_from_eeprom_with_checksum+0x4e>
    4a18:	28 2d       	mov	r18, r8
    checksum += data;    
    4a1a:	98 2e       	mov	r9, r24
    4a1c:	92 0e       	add	r9, r18
    *(destination++) = data; 
    4a1e:	89 93       	st	Y+, r24
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    4a20:	81 e0       	ldi	r24, 0x01	; 1
    4a22:	a8 1a       	sub	r10, r24
    4a24:	b1 08       	sbc	r11, r1
    data = eeprom_get_char(source++);
    4a26:	c8 01       	movw	r24, r16
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    4a28:	49 f7       	brne	.-46     	; 0x49fc <memcpy_from_eeprom_with_checksum+0x30>
    4a2a:	ec 0c       	add	r14, r12
    4a2c:	fd 1c       	adc	r15, r13
    4a2e:	01 c0       	rjmp	.+2      	; 0x4a32 <memcpy_from_eeprom_with_checksum+0x66>
  }
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
    4a30:	91 2c       	mov	r9, r1
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += data;    
    *(destination++) = data; 
  }
  return(checksum == eeprom_get_char(source));
    4a32:	c7 01       	movw	r24, r14
    4a34:	61 df       	rcall	.-318    	; 0x48f8 <eeprom_get_char>
    4a36:	21 e0       	ldi	r18, 0x01	; 1
    4a38:	30 e0       	ldi	r19, 0x00	; 0
    4a3a:	89 15       	cp	r24, r9
    4a3c:	11 f0       	breq	.+4      	; 0x4a42 <memcpy_from_eeprom_with_checksum+0x76>
    4a3e:	20 e0       	ldi	r18, 0x00	; 0
    4a40:	30 e0       	ldi	r19, 0x00	; 0
}
    4a42:	c9 01       	movw	r24, r18
    4a44:	df 91       	pop	r29
    4a46:	cf 91       	pop	r28
    4a48:	1f 91       	pop	r17
    4a4a:	0f 91       	pop	r16
    4a4c:	ff 90       	pop	r15
    4a4e:	ef 90       	pop	r14
    4a50:	df 90       	pop	r13
    4a52:	cf 90       	pop	r12
    4a54:	bf 90       	pop	r11
    4a56:	af 90       	pop	r10
    4a58:	9f 90       	pop	r9
    4a5a:	8f 90       	pop	r8
    4a5c:	08 95       	ret

00004a5e <settings_store_startup_line>:
    .max_travel[Z_AXIS] = (-DEFAULT_Z_MAX_TRAVEL)};


// Method to store startup lines into EEPROM
void settings_store_startup_line(uint8_t n, char *line)
{
    4a5e:	1f 93       	push	r17
    4a60:	cf 93       	push	r28
    4a62:	df 93       	push	r29
    4a64:	18 2f       	mov	r17, r24
    4a66:	eb 01       	movw	r28, r22
  #ifdef FORCE_BUFFER_SYNC_DURING_EEPROM_WRITE
    protocol_buffer_synchronize(); // A startup line may contain a motion and be executing. 
    4a68:	0e 94 02 19 	call	0x3204	; 0x3204 <protocol_buffer_synchronize>
  #endif
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
  memcpy_to_eeprom_with_checksum(addr,(char*)line, LINE_BUFFER_SIZE);
    4a6c:	21 e0       	ldi	r18, 0x01	; 1
    4a6e:	31 e0       	ldi	r19, 0x01	; 1
    4a70:	12 9f       	mul	r17, r18
    4a72:	c0 01       	movw	r24, r0
    4a74:	13 9f       	mul	r17, r19
    4a76:	90 0d       	add	r25, r0
    4a78:	11 24       	eor	r1, r1
    4a7a:	40 e0       	ldi	r20, 0x00	; 0
    4a7c:	51 e0       	ldi	r21, 0x01	; 1
    4a7e:	be 01       	movw	r22, r28
    4a80:	9d 5f       	subi	r25, 0xFD	; 253
    4a82:	61 df       	rcall	.-318    	; 0x4946 <memcpy_to_eeprom_with_checksum>
}
    4a84:	df 91       	pop	r29
    4a86:	cf 91       	pop	r28
    4a88:	1f 91       	pop	r17
    4a8a:	08 95       	ret

00004a8c <settings_store_build_info>:
// Method to store build info into EEPROM
// NOTE: This function can only be called in IDLE state.
void settings_store_build_info(char *line)
{
  // Build info can only be stored when state is IDLE.
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_BUILD_INFO,(char*)line, LINE_BUFFER_SIZE);
    4a8c:	40 e0       	ldi	r20, 0x00	; 0
    4a8e:	51 e0       	ldi	r21, 0x01	; 1
    4a90:	bc 01       	movw	r22, r24
    4a92:	8e ea       	ldi	r24, 0xAE	; 174
    4a94:	93 e0       	ldi	r25, 0x03	; 3
    4a96:	57 cf       	rjmp	.-338    	; 0x4946 <memcpy_to_eeprom_with_checksum>
    4a98:	08 95       	ret

00004a9a <settings_write_coord_data>:
}


// Method to store coord data parameters into EEPROM
void settings_write_coord_data(uint8_t coord_select, float *coord_data)
{
    4a9a:	0f 93       	push	r16
    4a9c:	1f 93       	push	r17
    4a9e:	cf 93       	push	r28
    4aa0:	c8 2f       	mov	r28, r24
    4aa2:	8b 01       	movw	r16, r22
  #ifdef FORCE_BUFFER_SYNC_DURING_EEPROM_WRITE
    protocol_buffer_synchronize();
    4aa4:	0e 94 02 19 	call	0x3204	; 0x3204 <protocol_buffer_synchronize>
  #endif
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
  memcpy_to_eeprom_with_checksum(addr,(char*)coord_data, sizeof(float)*N_AXIS);
    4aa8:	2d e0       	ldi	r18, 0x0D	; 13
    4aaa:	c2 9f       	mul	r28, r18
    4aac:	c0 01       	movw	r24, r0
    4aae:	11 24       	eor	r1, r1
    4ab0:	4c e0       	ldi	r20, 0x0C	; 12
    4ab2:	50 e0       	ldi	r21, 0x00	; 0
    4ab4:	b8 01       	movw	r22, r16
    4ab6:	9e 5f       	subi	r25, 0xFE	; 254
    4ab8:	46 df       	rcall	.-372    	; 0x4946 <memcpy_to_eeprom_with_checksum>
}
    4aba:	cf 91       	pop	r28
    4abc:	1f 91       	pop	r17
    4abe:	0f 91       	pop	r16
    4ac0:	08 95       	ret

00004ac2 <write_global_settings>:

// Method to store Grbl global settings struct and version number into EEPROM
// NOTE: This function can only be called in IDLE state.
void write_global_settings()
{
  eeprom_put_char(0, SETTINGS_VERSION);
    4ac2:	6a e0       	ldi	r22, 0x0A	; 10
    4ac4:	80 e0       	ldi	r24, 0x00	; 0
    4ac6:	90 e0       	ldi	r25, 0x00	; 0
    4ac8:	1f df       	rcall	.-450    	; 0x4908 <eeprom_put_char>
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_GLOBAL, (char*)&settings, sizeof(settings_t));
    4aca:	45 e5       	ldi	r20, 0x55	; 85
    4acc:	50 e0       	ldi	r21, 0x00	; 0
    4ace:	60 ed       	ldi	r22, 0xD0	; 208
    4ad0:	7e e0       	ldi	r23, 0x0E	; 14
    4ad2:	81 e0       	ldi	r24, 0x01	; 1
    4ad4:	90 e0       	ldi	r25, 0x00	; 0
    4ad6:	37 cf       	rjmp	.-402    	; 0x4946 <memcpy_to_eeprom_with_checksum>
    4ad8:	08 95       	ret

00004ada <settings_restore>:
}


// Method to restore EEPROM-saved Grbl global settings back to defaults.
void settings_restore(uint8_t restore_flag) {
    4ada:	0f 93       	push	r16
    4adc:	1f 93       	push	r17
    4ade:	cf 93       	push	r28
    4ae0:	df 93       	push	r29
    4ae2:	cd b7       	in	r28, 0x3d	; 61
    4ae4:	de b7       	in	r29, 0x3e	; 62
    4ae6:	2c 97       	sbiw	r28, 0x0c	; 12
    4ae8:	0f b6       	in	r0, 0x3f	; 63
    4aea:	f8 94       	cli
    4aec:	de bf       	out	0x3e, r29	; 62
    4aee:	0f be       	out	0x3f, r0	; 63
    4af0:	cd bf       	out	0x3d, r28	; 61
    4af2:	08 2f       	mov	r16, r24
  if (restore_flag & SETTINGS_RESTORE_DEFAULTS) {
    4af4:	80 ff       	sbrs	r24, 0
    4af6:	0a c0       	rjmp	.+20     	; 0x4b0c <settings_restore+0x32>
    settings = defaults;
    4af8:	85 e5       	ldi	r24, 0x55	; 85
    4afa:	ea ee       	ldi	r30, 0xEA	; 234
    4afc:	f2 e0       	ldi	r31, 0x02	; 2
    4afe:	a0 ed       	ldi	r26, 0xD0	; 208
    4b00:	be e0       	ldi	r27, 0x0E	; 14
    4b02:	05 90       	lpm	r0, Z+
    4b04:	0d 92       	st	X+, r0
    4b06:	8a 95       	dec	r24
    4b08:	e1 f7       	brne	.-8      	; 0x4b02 <settings_restore+0x28>
    write_global_settings();
    4b0a:	db df       	rcall	.-74     	; 0x4ac2 <write_global_settings>
  }

  if (restore_flag & SETTINGS_RESTORE_PARAMETERS) {
    4b0c:	01 ff       	sbrs	r16, 1
    4b0e:	10 c0       	rjmp	.+32     	; 0x4b30 <settings_restore+0x56>
    uint8_t idx;
    float coord_data[N_AXIS];
    memset(&coord_data, 0, sizeof(coord_data));
    4b10:	fe 01       	movw	r30, r28
    4b12:	31 96       	adiw	r30, 0x01	; 1
    4b14:	8c e0       	ldi	r24, 0x0C	; 12
    4b16:	df 01       	movw	r26, r30
    4b18:	1d 92       	st	X+, r1
    4b1a:	8a 95       	dec	r24
    4b1c:	e9 f7       	brne	.-6      	; 0x4b18 <settings_restore+0x3e>
    for (idx=0; idx <= SETTING_INDEX_NCOORD; idx++) { settings_write_coord_data(idx, coord_data); }
    4b1e:	10 e0       	ldi	r17, 0x00	; 0
    4b20:	be 01       	movw	r22, r28
    4b22:	6f 5f       	subi	r22, 0xFF	; 255
    4b24:	7f 4f       	sbci	r23, 0xFF	; 255
    4b26:	81 2f       	mov	r24, r17
    4b28:	b8 df       	rcall	.-144    	; 0x4a9a <settings_write_coord_data>
    4b2a:	1f 5f       	subi	r17, 0xFF	; 255
    4b2c:	18 30       	cpi	r17, 0x08	; 8
    4b2e:	c1 f7       	brne	.-16     	; 0x4b20 <settings_restore+0x46>
  }

  if (restore_flag & SETTINGS_RESTORE_STARTUP_LINES) {
    4b30:	02 ff       	sbrs	r16, 2
    4b32:	10 c0       	rjmp	.+32     	; 0x4b54 <settings_restore+0x7a>
    #if N_STARTUP_LINE > 0
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK, 0);
    4b34:	60 e0       	ldi	r22, 0x00	; 0
    4b36:	80 e0       	ldi	r24, 0x00	; 0
    4b38:	93 e0       	ldi	r25, 0x03	; 3
    4b3a:	e6 de       	rcall	.-564    	; 0x4908 <eeprom_put_char>
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+1, 0); // Checksum
    4b3c:	60 e0       	ldi	r22, 0x00	; 0
    4b3e:	81 e0       	ldi	r24, 0x01	; 1
    4b40:	93 e0       	ldi	r25, 0x03	; 3
    4b42:	e2 de       	rcall	.-572    	; 0x4908 <eeprom_put_char>
    #endif
    #if N_STARTUP_LINE > 1
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+1), 0);
    4b44:	60 e0       	ldi	r22, 0x00	; 0
    4b46:	81 e0       	ldi	r24, 0x01	; 1
    4b48:	94 e0       	ldi	r25, 0x04	; 4
    4b4a:	de de       	rcall	.-580    	; 0x4908 <eeprom_put_char>
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+2), 0); // Checksum
    4b4c:	60 e0       	ldi	r22, 0x00	; 0
    4b4e:	82 e0       	ldi	r24, 0x02	; 2
    4b50:	94 e0       	ldi	r25, 0x04	; 4
    4b52:	da de       	rcall	.-588    	; 0x4908 <eeprom_put_char>
    #endif
  }

  if (restore_flag & SETTINGS_RESTORE_BUILD_INFO) {
    4b54:	03 ff       	sbrs	r16, 3
    4b56:	08 c0       	rjmp	.+16     	; 0x4b68 <settings_restore+0x8e>
    eeprom_put_char(EEPROM_ADDR_BUILD_INFO , 0);
    4b58:	60 e0       	ldi	r22, 0x00	; 0
    4b5a:	8e ea       	ldi	r24, 0xAE	; 174
    4b5c:	93 e0       	ldi	r25, 0x03	; 3
    4b5e:	d4 de       	rcall	.-600    	; 0x4908 <eeprom_put_char>
    eeprom_put_char(EEPROM_ADDR_BUILD_INFO+1 , 0); // Checksum
    4b60:	60 e0       	ldi	r22, 0x00	; 0
    4b62:	8f ea       	ldi	r24, 0xAF	; 175
    4b64:	93 e0       	ldi	r25, 0x03	; 3
    4b66:	d0 de       	rcall	.-608    	; 0x4908 <eeprom_put_char>
    4b68:	2c 96       	adiw	r28, 0x0c	; 12
  }
}
    4b6a:	0f b6       	in	r0, 0x3f	; 63
    4b6c:	f8 94       	cli
    4b6e:	de bf       	out	0x3e, r29	; 62
    4b70:	0f be       	out	0x3f, r0	; 63
    4b72:	cd bf       	out	0x3d, r28	; 61
    4b74:	df 91       	pop	r29
    4b76:	cf 91       	pop	r28
    4b78:	1f 91       	pop	r17
    4b7a:	0f 91       	pop	r16
    4b7c:	08 95       	ret

00004b7e <settings_read_startup_line>:
    4b7e:	1f 93       	push	r17


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_startup_line(uint8_t n, char *line)
{
    4b80:	cf 93       	push	r28
    4b82:	df 93       	push	r29
    4b84:	18 2f       	mov	r17, r24
    4b86:	eb 01       	movw	r28, r22
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
  if (!(memcpy_from_eeprom_with_checksum((char*)line, addr, LINE_BUFFER_SIZE))) {
    4b88:	81 e0       	ldi	r24, 0x01	; 1
    4b8a:	91 e0       	ldi	r25, 0x01	; 1
    4b8c:	18 9f       	mul	r17, r24
    4b8e:	b0 01       	movw	r22, r0
    4b90:	19 9f       	mul	r17, r25
    4b92:	70 0d       	add	r23, r0
    4b94:	11 24       	eor	r1, r1
    4b96:	7d 5f       	subi	r23, 0xFD	; 253
    4b98:	40 e0       	ldi	r20, 0x00	; 0
    4b9a:	51 e0       	ldi	r21, 0x01	; 1
    4b9c:	ce 01       	movw	r24, r28
    4b9e:	16 df       	rcall	.-468    	; 0x49cc <memcpy_from_eeprom_with_checksum>
    4ba0:	89 2b       	or	r24, r25
    4ba2:	31 f4       	brne	.+12     	; 0x4bb0 <settings_read_startup_line+0x32>
    // Reset line with default value
    line[0] = 0; // Empty line
    4ba4:	18 82       	st	Y, r1
    settings_store_startup_line(n, line);
    4ba6:	be 01       	movw	r22, r28
    4ba8:	81 2f       	mov	r24, r17
    4baa:	59 df       	rcall	.-334    	; 0x4a5e <settings_store_startup_line>
    return(false);
    4bac:	80 e0       	ldi	r24, 0x00	; 0
    4bae:	01 c0       	rjmp	.+2      	; 0x4bb2 <settings_read_startup_line+0x34>
  }
  return(true);
    4bb0:	81 e0       	ldi	r24, 0x01	; 1
}
    4bb2:	df 91       	pop	r29
    4bb4:	cf 91       	pop	r28
    4bb6:	1f 91       	pop	r17
    4bb8:	08 95       	ret

00004bba <settings_read_build_info>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_build_info(char *line)
{
    4bba:	cf 93       	push	r28
    4bbc:	df 93       	push	r29
    4bbe:	ec 01       	movw	r28, r24
  if (!(memcpy_from_eeprom_with_checksum((char*)line, EEPROM_ADDR_BUILD_INFO, LINE_BUFFER_SIZE))) {
    4bc0:	40 e0       	ldi	r20, 0x00	; 0
    4bc2:	51 e0       	ldi	r21, 0x01	; 1
    4bc4:	6e ea       	ldi	r22, 0xAE	; 174
    4bc6:	73 e0       	ldi	r23, 0x03	; 3
    4bc8:	01 df       	rcall	.-510    	; 0x49cc <memcpy_from_eeprom_with_checksum>
    4bca:	89 2b       	or	r24, r25
    4bcc:	29 f4       	brne	.+10     	; 0x4bd8 <settings_read_build_info+0x1e>
    // Reset line with default value
    line[0] = 0; // Empty line
    4bce:	18 82       	st	Y, r1
    settings_store_build_info(line);
    4bd0:	ce 01       	movw	r24, r28
    4bd2:	5c df       	rcall	.-328    	; 0x4a8c <settings_store_build_info>
    return(false);
    4bd4:	80 e0       	ldi	r24, 0x00	; 0
    4bd6:	01 c0       	rjmp	.+2      	; 0x4bda <settings_read_build_info+0x20>
  }
  return(true);
    4bd8:	81 e0       	ldi	r24, 0x01	; 1
}
    4bda:	df 91       	pop	r29
    4bdc:	cf 91       	pop	r28
    4bde:	08 95       	ret

00004be0 <settings_read_coord_data>:


// Read selected coordinate data from EEPROM. Updates pointed coord_data value.
uint8_t settings_read_coord_data(uint8_t coord_select, float *coord_data)
{
    4be0:	1f 93       	push	r17
    4be2:	cf 93       	push	r28
    4be4:	df 93       	push	r29
    4be6:	18 2f       	mov	r17, r24
    4be8:	eb 01       	movw	r28, r22
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
  if (!(memcpy_from_eeprom_with_checksum((char*)coord_data, addr, sizeof(float)*N_AXIS))) {
    4bea:	8d e0       	ldi	r24, 0x0D	; 13
    4bec:	18 9f       	mul	r17, r24
    4bee:	b0 01       	movw	r22, r0
    4bf0:	11 24       	eor	r1, r1
    4bf2:	7e 5f       	subi	r23, 0xFE	; 254
    4bf4:	4c e0       	ldi	r20, 0x0C	; 12
    4bf6:	50 e0       	ldi	r21, 0x00	; 0
    4bf8:	ce 01       	movw	r24, r28
    4bfa:	e8 de       	rcall	.-560    	; 0x49cc <memcpy_from_eeprom_with_checksum>
    4bfc:	89 2b       	or	r24, r25
    4bfe:	51 f4       	brne	.+20     	; 0x4c14 <settings_read_coord_data+0x34>
    // Reset with default zero vector
    clear_vector_float(coord_data);
    4c00:	8c e0       	ldi	r24, 0x0C	; 12
    4c02:	fe 01       	movw	r30, r28
    4c04:	11 92       	st	Z+, r1
    4c06:	8a 95       	dec	r24
    4c08:	e9 f7       	brne	.-6      	; 0x4c04 <settings_read_coord_data+0x24>
    settings_write_coord_data(coord_select,coord_data);
    4c0a:	be 01       	movw	r22, r28
    4c0c:	81 2f       	mov	r24, r17
    4c0e:	45 df       	rcall	.-374    	; 0x4a9a <settings_write_coord_data>
    return(false);
    4c10:	80 e0       	ldi	r24, 0x00	; 0
    4c12:	01 c0       	rjmp	.+2      	; 0x4c16 <settings_read_coord_data+0x36>
  }
  return(true);
    4c14:	81 e0       	ldi	r24, 0x01	; 1
}
    4c16:	df 91       	pop	r29
    4c18:	cf 91       	pop	r28
    4c1a:	1f 91       	pop	r17
    4c1c:	08 95       	ret

00004c1e <read_global_settings>:


// Reads Grbl global settings struct from EEPROM.
uint8_t read_global_settings() {
  // Check version-byte of eeprom
  uint8_t version = eeprom_get_char(0);
    4c1e:	80 e0       	ldi	r24, 0x00	; 0
    4c20:	90 e0       	ldi	r25, 0x00	; 0
    4c22:	6a de       	rcall	.-812    	; 0x48f8 <eeprom_get_char>
  if (version == SETTINGS_VERSION) {
    4c24:	8a 30       	cpi	r24, 0x0A	; 10
    4c26:	61 f4       	brne	.+24     	; 0x4c40 <read_global_settings+0x22>
    // Read settings-record and check checksum
    if (!(memcpy_from_eeprom_with_checksum((char*)&settings, EEPROM_ADDR_GLOBAL, sizeof(settings_t)))) {
    4c28:	45 e5       	ldi	r20, 0x55	; 85
    4c2a:	50 e0       	ldi	r21, 0x00	; 0
    4c2c:	61 e0       	ldi	r22, 0x01	; 1
    4c2e:	70 e0       	ldi	r23, 0x00	; 0
    4c30:	80 ed       	ldi	r24, 0xD0	; 208
    4c32:	9e e0       	ldi	r25, 0x0E	; 14
    4c34:	cb de       	rcall	.-618    	; 0x49cc <memcpy_from_eeprom_with_checksum>
      return(false);
    4c36:	21 e0       	ldi	r18, 0x01	; 1
    4c38:	89 2b       	or	r24, r25
    4c3a:	19 f4       	brne	.+6      	; 0x4c42 <read_global_settings+0x24>
    4c3c:	20 e0       	ldi	r18, 0x00	; 0
    4c3e:	01 c0       	rjmp	.+2      	; 0x4c42 <read_global_settings+0x24>
    }
  } else {
    return(false);
    4c40:	20 e0       	ldi	r18, 0x00	; 0
  }
  return(true);
}
    4c42:	82 2f       	mov	r24, r18
    4c44:	08 95       	ret

00004c46 <settings_store_global_setting>:


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
    4c46:	cf 92       	push	r12
    4c48:	df 92       	push	r13
    4c4a:	ef 92       	push	r14
    4c4c:	ff 92       	push	r15
    4c4e:	cf 93       	push	r28
    4c50:	df 93       	push	r29
    4c52:	c8 2f       	mov	r28, r24
    4c54:	6a 01       	movw	r12, r20
    4c56:	7b 01       	movw	r14, r22
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); }
    4c58:	20 e0       	ldi	r18, 0x00	; 0
    4c5a:	30 e0       	ldi	r19, 0x00	; 0
    4c5c:	a9 01       	movw	r20, r18
    4c5e:	c7 01       	movw	r24, r14
    4c60:	b6 01       	movw	r22, r12
    4c62:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    4c66:	88 23       	and	r24, r24
    4c68:	0c f4       	brge	.+2      	; 0x4c6c <settings_store_global_setting+0x26>
    4c6a:	07 c1       	rjmp	.+526    	; 0x4e7a <settings_store_global_setting+0x234>
  if (parameter >= AXIS_SETTINGS_START_VAL) {
    4c6c:	c4 36       	cpi	r28, 0x64	; 100
    4c6e:	a0 f0       	brcs	.+40     	; 0x4c98 <settings_store_global_setting+0x52>
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    4c70:	ec e9       	ldi	r30, 0x9C	; 156
    4c72:	ec 0f       	add	r30, r28
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    4c74:	e3 30       	cpi	r30, 0x03	; 3
    4c76:	20 f0       	brcs	.+8      	; 0x4c80 <settings_store_global_setting+0x3a>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4c78:	ea 30       	cpi	r30, 0x0A	; 10
    4c7a:	08 f0       	brcs	.+2      	; 0x4c7e <settings_store_global_setting+0x38>
    4c7c:	0c c1       	rjmp	.+536    	; 0x4e96 <settings_store_global_setting+0x250>
    4c7e:	ff c0       	rjmp	.+510    	; 0x4e7e <settings_store_global_setting+0x238>
        switch (set_idx) {
          case 0:
            #ifdef MAX_STEP_RATE_HZ
              if (value*settings.max_rate[parameter] > (MAX_STEP_RATE_HZ*60.0)) { return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            #endif
            settings.steps_per_mm[parameter] = value;
    4c80:	f0 e0       	ldi	r31, 0x00	; 0
    4c82:	ee 0f       	add	r30, r30
    4c84:	ff 1f       	adc	r31, r31
    4c86:	ee 0f       	add	r30, r30
    4c88:	ff 1f       	adc	r31, r31
    4c8a:	e0 53       	subi	r30, 0x30	; 48
    4c8c:	f1 4f       	sbci	r31, 0xF1	; 241
    4c8e:	c0 82       	st	Z, r12
    4c90:	d1 82       	std	Z+1, r13	; 0x01
    4c92:	e2 82       	std	Z+2, r14	; 0x02
    4c94:	f3 82       	std	Z+3, r15	; 0x03
            break;
    4c96:	ee c0       	rjmp	.+476    	; 0x4e74 <settings_store_global_setting+0x22e>
        parameter -= AXIS_SETTINGS_INCREMENT;
      }
    }
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    4c98:	c7 01       	movw	r24, r14
    4c9a:	b6 01       	movw	r22, r12
    4c9c:	0e 94 71 42 	call	0x84e2	; 0x84e2 <trunc>
    4ca0:	0e 94 d9 3f 	call	0x7fb2	; 0x7fb2 <__fixunssfsi>
    switch(parameter) {
    4ca4:	8c 2f       	mov	r24, r28
    4ca6:	90 e0       	ldi	r25, 0x00	; 0
    4ca8:	81 32       	cpi	r24, 0x21	; 33
    4caa:	91 05       	cpc	r25, r1
    4cac:	08 f0       	brcs	.+2      	; 0x4cb0 <settings_store_global_setting+0x6a>
    4cae:	e9 c0       	rjmp	.+466    	; 0x4e82 <settings_store_global_setting+0x23c>
    4cb0:	fc 01       	movw	r30, r24
    4cb2:	88 27       	eor	r24, r24
    4cb4:	ed 5d       	subi	r30, 0xDD	; 221
    4cb6:	fe 4f       	sbci	r31, 0xFE	; 254
    4cb8:	8f 4f       	sbci	r24, 0xFF	; 255
    4cba:	0c 94 b2 42 	jmp	0x8564	; 0x8564 <__tablejump2__>
      case 0:
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    4cbe:	63 30       	cpi	r22, 0x03	; 3
    4cc0:	08 f4       	brcc	.+2      	; 0x4cc4 <settings_store_global_setting+0x7e>
    4cc2:	e1 c0       	rjmp	.+450    	; 0x4e86 <settings_store_global_setting+0x240>
        settings.pulse_microseconds = int_value; break;
    4cc4:	60 93 00 0f 	sts	0x0F00, r22	; 0x800f00 <settings+0x30>
    4cc8:	d5 c0       	rjmp	.+426    	; 0x4e74 <settings_store_global_setting+0x22e>
      case 1: settings.stepper_idle_lock_time = int_value; break;
    4cca:	60 93 03 0f 	sts	0x0F03, r22	; 0x800f03 <settings+0x33>
    4cce:	d2 c0       	rjmp	.+420    	; 0x4e74 <settings_store_global_setting+0x22e>
      case 2:
        settings.step_invert_mask = int_value;
    4cd0:	60 93 01 0f 	sts	0x0F01, r22	; 0x800f01 <settings+0x31>
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    4cd4:	0e 94 6f 1b 	call	0x36de	; 0x36de <st_generate_step_dir_invert_masks>
        break;
    4cd8:	cd c0       	rjmp	.+410    	; 0x4e74 <settings_store_global_setting+0x22e>
      case 3:
        settings.dir_invert_mask = int_value;
    4cda:	60 93 02 0f 	sts	0x0F02, r22	; 0x800f02 <settings+0x32>
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    4cde:	0e 94 6f 1b 	call	0x36de	; 0x36de <st_generate_step_dir_invert_masks>
        break;
    4ce2:	c8 c0       	rjmp	.+400    	; 0x4e74 <settings_store_global_setting+0x22e>
      case 4: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }
    4ce4:	66 23       	and	r22, r22
    4ce6:	31 f0       	breq	.+12     	; 0x4cf4 <settings_store_global_setting+0xae>
    4ce8:	e5 e1       	ldi	r30, 0x15	; 21
    4cea:	ff e0       	ldi	r31, 0x0F	; 15
    4cec:	80 81       	ld	r24, Z
    4cee:	84 60       	ori	r24, 0x04	; 4
    4cf0:	80 83       	st	Z, r24
    4cf2:	c0 c0       	rjmp	.+384    	; 0x4e74 <settings_store_global_setting+0x22e>
        else { settings.flags &= ~BITFLAG_INVERT_ST_ENABLE; }
    4cf4:	e5 e1       	ldi	r30, 0x15	; 21
    4cf6:	ff e0       	ldi	r31, 0x0F	; 15
    4cf8:	80 81       	ld	r24, Z
    4cfa:	8b 7f       	andi	r24, 0xFB	; 251
    4cfc:	80 83       	st	Z, r24
    4cfe:	ba c0       	rjmp	.+372    	; 0x4e74 <settings_store_global_setting+0x22e>
        break;
      case 5: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
    4d00:	66 23       	and	r22, r22
    4d02:	31 f0       	breq	.+12     	; 0x4d10 <settings_store_global_setting+0xca>
    4d04:	e5 e1       	ldi	r30, 0x15	; 21
    4d06:	ff e0       	ldi	r31, 0x0F	; 15
    4d08:	80 81       	ld	r24, Z
    4d0a:	80 64       	ori	r24, 0x40	; 64
    4d0c:	80 83       	st	Z, r24
    4d0e:	b2 c0       	rjmp	.+356    	; 0x4e74 <settings_store_global_setting+0x22e>
        else { settings.flags &= ~BITFLAG_INVERT_LIMIT_PINS; }
    4d10:	e5 e1       	ldi	r30, 0x15	; 21
    4d12:	ff e0       	ldi	r31, 0x0F	; 15
    4d14:	80 81       	ld	r24, Z
    4d16:	8f 7b       	andi	r24, 0xBF	; 191
    4d18:	80 83       	st	Z, r24
    4d1a:	ac c0       	rjmp	.+344    	; 0x4e74 <settings_store_global_setting+0x22e>
        break;
      case 6: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_PROBE_PIN; }
    4d1c:	66 23       	and	r22, r22
    4d1e:	31 f0       	breq	.+12     	; 0x4d2c <settings_store_global_setting+0xe6>
    4d20:	e5 e1       	ldi	r30, 0x15	; 21
    4d22:	ff e0       	ldi	r31, 0x0F	; 15
    4d24:	80 81       	ld	r24, Z
    4d26:	80 68       	ori	r24, 0x80	; 128
    4d28:	80 83       	st	Z, r24
    4d2a:	05 c0       	rjmp	.+10     	; 0x4d36 <settings_store_global_setting+0xf0>
        else { settings.flags &= ~BITFLAG_INVERT_PROBE_PIN; }
    4d2c:	e5 e1       	ldi	r30, 0x15	; 21
    4d2e:	ff e0       	ldi	r31, 0x0F	; 15
    4d30:	80 81       	ld	r24, Z
    4d32:	8f 77       	andi	r24, 0x7F	; 127
    4d34:	80 83       	st	Z, r24
        probe_configure_invert_mask(false);
    4d36:	80 e0       	ldi	r24, 0x00	; 0
    4d38:	0e 94 b2 34 	call	0x6964	; 0x6964 <probe_configure_invert_mask>
        break;
    4d3c:	9b c0       	rjmp	.+310    	; 0x4e74 <settings_store_global_setting+0x22e>
      case 10: settings.status_report_mask = int_value; break;
    4d3e:	60 93 04 0f 	sts	0x0F04, r22	; 0x800f04 <settings+0x34>
    4d42:	98 c0       	rjmp	.+304    	; 0x4e74 <settings_store_global_setting+0x22e>
      case 11: settings.junction_deviation = value; break;
    4d44:	c0 92 05 0f 	sts	0x0F05, r12	; 0x800f05 <settings+0x35>
    4d48:	d0 92 06 0f 	sts	0x0F06, r13	; 0x800f06 <settings+0x36>
    4d4c:	e0 92 07 0f 	sts	0x0F07, r14	; 0x800f07 <settings+0x37>
    4d50:	f0 92 08 0f 	sts	0x0F08, r15	; 0x800f08 <settings+0x38>
    4d54:	8f c0       	rjmp	.+286    	; 0x4e74 <settings_store_global_setting+0x22e>
      case 12: settings.arc_tolerance = value; break;
    4d56:	c0 92 09 0f 	sts	0x0F09, r12	; 0x800f09 <settings+0x39>
    4d5a:	d0 92 0a 0f 	sts	0x0F0A, r13	; 0x800f0a <settings+0x3a>
    4d5e:	e0 92 0b 0f 	sts	0x0F0B, r14	; 0x800f0b <settings+0x3b>
    4d62:	f0 92 0c 0f 	sts	0x0F0C, r15	; 0x800f0c <settings+0x3c>
    4d66:	86 c0       	rjmp	.+268    	; 0x4e74 <settings_store_global_setting+0x22e>
      case 13:
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
    4d68:	66 23       	and	r22, r22
    4d6a:	31 f0       	breq	.+12     	; 0x4d78 <settings_store_global_setting+0x132>
    4d6c:	e5 e1       	ldi	r30, 0x15	; 21
    4d6e:	ff e0       	ldi	r31, 0x0F	; 15
    4d70:	80 81       	ld	r24, Z
    4d72:	81 60       	ori	r24, 0x01	; 1
    4d74:	80 83       	st	Z, r24
    4d76:	05 c0       	rjmp	.+10     	; 0x4d82 <settings_store_global_setting+0x13c>
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
    4d78:	e5 e1       	ldi	r30, 0x15	; 21
    4d7a:	ff e0       	ldi	r31, 0x0F	; 15
    4d7c:	80 81       	ld	r24, Z
    4d7e:	8e 7f       	andi	r24, 0xFE	; 254
    4d80:	80 83       	st	Z, r24
        system_flag_wco_change(); // Make sure WCO is immediately updated.
    4d82:	0e 94 f7 3a 	call	0x75ee	; 0x75ee <system_flag_wco_change>
        break;
    4d86:	76 c0       	rjmp	.+236    	; 0x4e74 <settings_store_global_setting+0x22e>
      case 20:
        if (int_value) {
    4d88:	66 23       	and	r22, r22
    4d8a:	41 f0       	breq	.+16     	; 0x4d9c <settings_store_global_setting+0x156>
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    4d8c:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    4d90:	84 ff       	sbrs	r24, 4
    4d92:	7b c0       	rjmp	.+246    	; 0x4e8a <settings_store_global_setting+0x244>
          settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE;
    4d94:	80 62       	ori	r24, 0x20	; 32
    4d96:	80 93 15 0f 	sts	0x0F15, r24	; 0x800f15 <settings+0x45>
    4d9a:	6c c0       	rjmp	.+216    	; 0x4e74 <settings_store_global_setting+0x22e>
        } else { settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; }
    4d9c:	e5 e1       	ldi	r30, 0x15	; 21
    4d9e:	ff e0       	ldi	r31, 0x0F	; 15
    4da0:	80 81       	ld	r24, Z
    4da2:	8f 7d       	andi	r24, 0xDF	; 223
    4da4:	80 83       	st	Z, r24
    4da6:	66 c0       	rjmp	.+204    	; 0x4e74 <settings_store_global_setting+0x22e>
        break;
      case 21:
        if (int_value) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
    4da8:	66 23       	and	r22, r22
    4daa:	31 f0       	breq	.+12     	; 0x4db8 <settings_store_global_setting+0x172>
    4dac:	e5 e1       	ldi	r30, 0x15	; 21
    4dae:	ff e0       	ldi	r31, 0x0F	; 15
    4db0:	80 81       	ld	r24, Z
    4db2:	88 60       	ori	r24, 0x08	; 8
    4db4:	80 83       	st	Z, r24
    4db6:	05 c0       	rjmp	.+10     	; 0x4dc2 <settings_store_global_setting+0x17c>
        else { settings.flags &= ~BITFLAG_HARD_LIMIT_ENABLE; }
    4db8:	e5 e1       	ldi	r30, 0x15	; 21
    4dba:	ff e0       	ldi	r31, 0x0F	; 15
    4dbc:	80 81       	ld	r24, Z
    4dbe:	87 7f       	andi	r24, 0xF7	; 247
    4dc0:	80 83       	st	Z, r24
        limits_init(); // Re-init to immediately change. NOTE: Nice to have but could be problematic later.
    4dc2:	0e 94 1a 30 	call	0x6034	; 0x6034 <limits_init>
        break;
    4dc6:	56 c0       	rjmp	.+172    	; 0x4e74 <settings_store_global_setting+0x22e>
      case 22:
        if (int_value) { settings.flags |= BITFLAG_HOMING_ENABLE; }
    4dc8:	66 23       	and	r22, r22
    4dca:	31 f0       	breq	.+12     	; 0x4dd8 <settings_store_global_setting+0x192>
    4dcc:	e5 e1       	ldi	r30, 0x15	; 21
    4dce:	ff e0       	ldi	r31, 0x0F	; 15
    4dd0:	80 81       	ld	r24, Z
    4dd2:	80 61       	ori	r24, 0x10	; 16
    4dd4:	80 83       	st	Z, r24
    4dd6:	4e c0       	rjmp	.+156    	; 0x4e74 <settings_store_global_setting+0x22e>
        else {
          settings.flags &= ~BITFLAG_HOMING_ENABLE;
          settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; // Force disable soft-limits.
    4dd8:	e5 e1       	ldi	r30, 0x15	; 21
    4dda:	ff e0       	ldi	r31, 0x0F	; 15
    4ddc:	80 81       	ld	r24, Z
    4dde:	8f 7c       	andi	r24, 0xCF	; 207
    4de0:	80 83       	st	Z, r24
    4de2:	48 c0       	rjmp	.+144    	; 0x4e74 <settings_store_global_setting+0x22e>
        }
        break;
      case 23: settings.homing_dir_mask = int_value; break;
    4de4:	60 93 16 0f 	sts	0x0F16, r22	; 0x800f16 <settings+0x46>
    4de8:	45 c0       	rjmp	.+138    	; 0x4e74 <settings_store_global_setting+0x22e>
      case 24: settings.homing_feed_rate = value; break;
    4dea:	c0 92 17 0f 	sts	0x0F17, r12	; 0x800f17 <settings+0x47>
    4dee:	d0 92 18 0f 	sts	0x0F18, r13	; 0x800f18 <settings+0x48>
    4df2:	e0 92 19 0f 	sts	0x0F19, r14	; 0x800f19 <settings+0x49>
    4df6:	f0 92 1a 0f 	sts	0x0F1A, r15	; 0x800f1a <settings+0x4a>
    4dfa:	3c c0       	rjmp	.+120    	; 0x4e74 <settings_store_global_setting+0x22e>
      case 25: settings.homing_seek_rate = value; break;
    4dfc:	c0 92 1b 0f 	sts	0x0F1B, r12	; 0x800f1b <settings+0x4b>
    4e00:	d0 92 1c 0f 	sts	0x0F1C, r13	; 0x800f1c <settings+0x4c>
    4e04:	e0 92 1d 0f 	sts	0x0F1D, r14	; 0x800f1d <settings+0x4d>
    4e08:	f0 92 1e 0f 	sts	0x0F1E, r15	; 0x800f1e <settings+0x4e>
    4e0c:	33 c0       	rjmp	.+102    	; 0x4e74 <settings_store_global_setting+0x22e>
      case 26: settings.homing_debounce_delay = int_value; break;
    4e0e:	86 2f       	mov	r24, r22
    4e10:	90 e0       	ldi	r25, 0x00	; 0
    4e12:	90 93 20 0f 	sts	0x0F20, r25	; 0x800f20 <settings+0x50>
    4e16:	80 93 1f 0f 	sts	0x0F1F, r24	; 0x800f1f <settings+0x4f>
    4e1a:	2c c0       	rjmp	.+88     	; 0x4e74 <settings_store_global_setting+0x22e>
      case 27: settings.homing_pulloff = value; break;
    4e1c:	c0 92 21 0f 	sts	0x0F21, r12	; 0x800f21 <settings+0x51>
    4e20:	d0 92 22 0f 	sts	0x0F22, r13	; 0x800f22 <settings+0x52>
    4e24:	e0 92 23 0f 	sts	0x0F23, r14	; 0x800f23 <settings+0x53>
    4e28:	f0 92 24 0f 	sts	0x0F24, r15	; 0x800f24 <settings+0x54>
    4e2c:	23 c0       	rjmp	.+70     	; 0x4e74 <settings_store_global_setting+0x22e>
      case 30: settings.rpm_max = value; spindle_init(); break; // Re-initialize spindle rpm calibration
    4e2e:	c0 92 0d 0f 	sts	0x0F0D, r12	; 0x800f0d <settings+0x3d>
    4e32:	d0 92 0e 0f 	sts	0x0F0E, r13	; 0x800f0e <settings+0x3e>
    4e36:	e0 92 0f 0f 	sts	0x0F0F, r14	; 0x800f0f <settings+0x3f>
    4e3a:	f0 92 10 0f 	sts	0x0F10, r15	; 0x800f10 <settings+0x40>
    4e3e:	0e 94 62 12 	call	0x24c4	; 0x24c4 <spindle_init>
    4e42:	18 c0       	rjmp	.+48     	; 0x4e74 <settings_store_global_setting+0x22e>
      case 31: settings.rpm_min = value; spindle_init(); break; // Re-initialize spindle rpm calibration
    4e44:	c0 92 11 0f 	sts	0x0F11, r12	; 0x800f11 <settings+0x41>
    4e48:	d0 92 12 0f 	sts	0x0F12, r13	; 0x800f12 <settings+0x42>
    4e4c:	e0 92 13 0f 	sts	0x0F13, r14	; 0x800f13 <settings+0x43>
    4e50:	f0 92 14 0f 	sts	0x0F14, r15	; 0x800f14 <settings+0x44>
    4e54:	0e 94 62 12 	call	0x24c4	; 0x24c4 <spindle_init>
    4e58:	0d c0       	rjmp	.+26     	; 0x4e74 <settings_store_global_setting+0x22e>
      case 32:
        if (int_value) { settings.flags |= BITFLAG_LASER_MODE; }
    4e5a:	66 23       	and	r22, r22
    4e5c:	31 f0       	breq	.+12     	; 0x4e6a <settings_store_global_setting+0x224>
    4e5e:	e5 e1       	ldi	r30, 0x15	; 21
    4e60:	ff e0       	ldi	r31, 0x0F	; 15
    4e62:	80 81       	ld	r24, Z
    4e64:	82 60       	ori	r24, 0x02	; 2
    4e66:	80 83       	st	Z, r24
    4e68:	05 c0       	rjmp	.+10     	; 0x4e74 <settings_store_global_setting+0x22e>
        else { settings.flags &= ~BITFLAG_LASER_MODE; }
    4e6a:	e5 e1       	ldi	r30, 0x15	; 21
    4e6c:	ff e0       	ldi	r31, 0x0F	; 15
    4e6e:	80 81       	ld	r24, Z
    4e70:	8d 7f       	andi	r24, 0xFD	; 253
    4e72:	80 83       	st	Z, r24
        break;
      default:
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
    4e74:	26 de       	rcall	.-948    	; 0x4ac2 <write_global_settings>
  return(STATUS_OK);
    4e76:	80 e0       	ldi	r24, 0x00	; 0
    4e78:	58 c0       	rjmp	.+176    	; 0x4f2a <settings_store_global_setting+0x2e4>
}


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); }
    4e7a:	84 e0       	ldi	r24, 0x04	; 4
    4e7c:	56 c0       	rjmp	.+172    	; 0x4f2a <settings_store_global_setting+0x2e4>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4e7e:	83 e0       	ldi	r24, 0x03	; 3
    4e80:	54 c0       	rjmp	.+168    	; 0x4f2a <settings_store_global_setting+0x2e4>
      case 32:
        if (int_value) { settings.flags |= BITFLAG_LASER_MODE; }
        else { settings.flags &= ~BITFLAG_LASER_MODE; }
        break;
      default:
        return(STATUS_INVALID_STATEMENT);
    4e82:	83 e0       	ldi	r24, 0x03	; 3
    4e84:	52 c0       	rjmp	.+164    	; 0x4f2a <settings_store_global_setting+0x2e4>
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    switch(parameter) {
      case 0:
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    4e86:	86 e0       	ldi	r24, 0x06	; 6
    4e88:	50 c0       	rjmp	.+160    	; 0x4f2a <settings_store_global_setting+0x2e4>
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
        system_flag_wco_change(); // Make sure WCO is immediately updated.
        break;
      case 20:
        if (int_value) {
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    4e8a:	8a e0       	ldi	r24, 0x0A	; 10
    4e8c:	4e c0       	rjmp	.+156    	; 0x4f2a <settings_store_global_setting+0x2e4>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4e8e:	83 e0       	ldi	r24, 0x03	; 3
    4e90:	4c c0       	rjmp	.+152    	; 0x4f2a <settings_store_global_setting+0x2e4>
    4e92:	83 e0       	ldi	r24, 0x03	; 3
    4e94:	4a c0       	rjmp	.+148    	; 0x4f2a <settings_store_global_setting+0x2e4>
        parameter -= AXIS_SETTINGS_INCREMENT;
    4e96:	e2 e9       	ldi	r30, 0x92	; 146
    4e98:	ec 0f       	add	r30, r28
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    4e9a:	e3 30       	cpi	r30, 0x03	; 3
    4e9c:	70 f0       	brcs	.+28     	; 0x4eba <settings_store_global_setting+0x274>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4e9e:	ea 30       	cpi	r30, 0x0A	; 10
    4ea0:	b0 f3       	brcs	.-20     	; 0x4e8e <settings_store_global_setting+0x248>
        parameter -= AXIS_SETTINGS_INCREMENT;
    4ea2:	88 e8       	ldi	r24, 0x88	; 136
    4ea4:	8c 0f       	add	r24, r28
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    4ea6:	83 30       	cpi	r24, 0x03	; 3
    4ea8:	a0 f0       	brcs	.+40     	; 0x4ed2 <settings_store_global_setting+0x28c>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4eaa:	8a 30       	cpi	r24, 0x0A	; 10
    4eac:	90 f3       	brcs	.-28     	; 0x4e92 <settings_store_global_setting+0x24c>
        parameter -= AXIS_SETTINGS_INCREMENT;
    4eae:	8e e7       	ldi	r24, 0x7E	; 126
    4eb0:	8c 0f       	add	r24, r28
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    4eb2:	83 30       	cpi	r24, 0x03	; 3
    4eb4:	48 f1       	brcs	.+82     	; 0x4f08 <settings_store_global_setting+0x2c2>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    4eb6:	83 e0       	ldi	r24, 0x03	; 3
    4eb8:	38 c0       	rjmp	.+112    	; 0x4f2a <settings_store_global_setting+0x2e4>
            break;
          case 1:
            #ifdef MAX_STEP_RATE_HZ
              if (value*settings.steps_per_mm[parameter] > (MAX_STEP_RATE_HZ*60.0)) {  return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            #endif
            settings.max_rate[parameter] = value;
    4eba:	f0 e0       	ldi	r31, 0x00	; 0
    4ebc:	ee 0f       	add	r30, r30
    4ebe:	ff 1f       	adc	r31, r31
    4ec0:	ee 0f       	add	r30, r30
    4ec2:	ff 1f       	adc	r31, r31
    4ec4:	e4 52       	subi	r30, 0x24	; 36
    4ec6:	f1 4f       	sbci	r31, 0xF1	; 241
    4ec8:	c0 82       	st	Z, r12
    4eca:	d1 82       	std	Z+1, r13	; 0x01
    4ecc:	e2 82       	std	Z+2, r14	; 0x02
    4ece:	f3 82       	std	Z+3, r15	; 0x03
            break;
    4ed0:	d1 cf       	rjmp	.-94     	; 0x4e74 <settings_store_global_setting+0x22e>
          case 2: settings.acceleration[parameter] = value*60*60; break; // Convert to mm/min^2 for grbl internal use.
    4ed2:	c8 2f       	mov	r28, r24
    4ed4:	d0 e0       	ldi	r29, 0x00	; 0
    4ed6:	cc 0f       	add	r28, r28
    4ed8:	dd 1f       	adc	r29, r29
    4eda:	cc 0f       	add	r28, r28
    4edc:	dd 1f       	adc	r29, r29
    4ede:	c8 51       	subi	r28, 0x18	; 24
    4ee0:	d1 4f       	sbci	r29, 0xF1	; 241
    4ee2:	20 e0       	ldi	r18, 0x00	; 0
    4ee4:	30 e0       	ldi	r19, 0x00	; 0
    4ee6:	40 e7       	ldi	r20, 0x70	; 112
    4ee8:	52 e4       	ldi	r21, 0x42	; 66
    4eea:	c7 01       	movw	r24, r14
    4eec:	b6 01       	movw	r22, r12
    4eee:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    4ef2:	20 e0       	ldi	r18, 0x00	; 0
    4ef4:	30 e0       	ldi	r19, 0x00	; 0
    4ef6:	40 e7       	ldi	r20, 0x70	; 112
    4ef8:	52 e4       	ldi	r21, 0x42	; 66
    4efa:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    4efe:	68 83       	st	Y, r22
    4f00:	79 83       	std	Y+1, r23	; 0x01
    4f02:	8a 83       	std	Y+2, r24	; 0x02
    4f04:	9b 83       	std	Y+3, r25	; 0x03
    4f06:	b6 cf       	rjmp	.-148    	; 0x4e74 <settings_store_global_setting+0x22e>
          case 3: settings.max_travel[parameter] = -value; break;  // Store as negative for grbl internal use.
    4f08:	e8 2f       	mov	r30, r24
    4f0a:	f0 e0       	ldi	r31, 0x00	; 0
    4f0c:	ee 0f       	add	r30, r30
    4f0e:	ff 1f       	adc	r31, r31
    4f10:	ee 0f       	add	r30, r30
    4f12:	ff 1f       	adc	r31, r31
    4f14:	ec 50       	subi	r30, 0x0C	; 12
    4f16:	f1 4f       	sbci	r31, 0xF1	; 241
    4f18:	f7 fa       	bst	r15, 7
    4f1a:	f0 94       	com	r15
    4f1c:	f7 f8       	bld	r15, 7
    4f1e:	f0 94       	com	r15
    4f20:	c0 82       	st	Z, r12
    4f22:	d1 82       	std	Z+1, r13	; 0x01
    4f24:	e2 82       	std	Z+2, r14	; 0x02
    4f26:	f3 82       	std	Z+3, r15	; 0x03
    4f28:	a5 cf       	rjmp	.-182    	; 0x4e74 <settings_store_global_setting+0x22e>
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
  return(STATUS_OK);
}
    4f2a:	df 91       	pop	r29
    4f2c:	cf 91       	pop	r28
    4f2e:	ff 90       	pop	r15
    4f30:	ef 90       	pop	r14
    4f32:	df 90       	pop	r13
    4f34:	cf 90       	pop	r12
    4f36:	08 95       	ret

00004f38 <settings_init>:


// Initialize the config subsystem
void settings_init() {
  if(!read_global_settings()) {
    4f38:	72 de       	rcall	.-796    	; 0x4c1e <read_global_settings>
    4f3a:	81 11       	cpse	r24, r1
    4f3c:	07 c0       	rjmp	.+14     	; 0x4f4c <settings_init+0x14>
    report_status_message(STATUS_SETTING_READ_FAIL);
    4f3e:	87 e0       	ldi	r24, 0x07	; 7
    4f40:	0e 94 34 35 	call	0x6a68	; 0x6a68 <report_status_message>
    settings_restore(SETTINGS_RESTORE_ALL); // Force restore all EEPROM data.
    4f44:	8f ef       	ldi	r24, 0xFF	; 255
    4f46:	c9 dd       	rcall	.-1134   	; 0x4ada <settings_restore>
    report_grbl_settings();
    4f48:	0c 94 f3 35 	jmp	0x6be6	; 0x6be6 <report_grbl_settings>
    4f4c:	08 95       	ret

00004f4e <get_step_pin_mask>:
  #ifdef DEFAULTS_RAMPS_BOARD
    if ( axis_idx == X_AXIS ) { return((1<<STEP_BIT(X_AXIS))); }
    if ( axis_idx == Y_AXIS ) { return((1<<STEP_BIT(Y_AXIS))); }
    return((1<<STEP_BIT(Z_AXIS)));
  #else
    if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    4f4e:	88 23       	and	r24, r24
    4f50:	21 f0       	breq	.+8      	; 0x4f5a <get_step_pin_mask+0xc>
    if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    4f52:	81 30       	cpi	r24, 0x01	; 1
    4f54:	21 f0       	breq	.+8      	; 0x4f5e <get_step_pin_mask+0x10>
    return((1<<Z_STEP_BIT));
    4f56:	80 e1       	ldi	r24, 0x10	; 16
    4f58:	08 95       	ret
  #ifdef DEFAULTS_RAMPS_BOARD
    if ( axis_idx == X_AXIS ) { return((1<<STEP_BIT(X_AXIS))); }
    if ( axis_idx == Y_AXIS ) { return((1<<STEP_BIT(Y_AXIS))); }
    return((1<<STEP_BIT(Z_AXIS)));
  #else
    if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    4f5a:	84 e0       	ldi	r24, 0x04	; 4
    4f5c:	08 95       	ret
    if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    4f5e:	88 e0       	ldi	r24, 0x08	; 8
    return((1<<Z_STEP_BIT));
  #endif // DEFAULTS_RAMPS_BOARD
}
    4f60:	08 95       	ret

00004f62 <get_direction_pin_mask>:
  #ifdef DEFAULTS_RAMPS_BOARD
    if ( axis_idx == X_AXIS ) { return((1<<DIRECTION_BIT(X_AXIS))); }
    if ( axis_idx == Y_AXIS ) { return((1<<DIRECTION_BIT(Y_AXIS))); }
    return((1<<DIRECTION_BIT(Z_AXIS)));
  #else
    if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    4f62:	88 23       	and	r24, r24
    4f64:	21 f0       	breq	.+8      	; 0x4f6e <get_direction_pin_mask+0xc>
    if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    4f66:	81 30       	cpi	r24, 0x01	; 1
    4f68:	21 f0       	breq	.+8      	; 0x4f72 <get_direction_pin_mask+0x10>
    return((1<<Z_DIRECTION_BIT));
    4f6a:	80 e2       	ldi	r24, 0x20	; 32
    4f6c:	08 95       	ret
  #ifdef DEFAULTS_RAMPS_BOARD
    if ( axis_idx == X_AXIS ) { return((1<<DIRECTION_BIT(X_AXIS))); }
    if ( axis_idx == Y_AXIS ) { return((1<<DIRECTION_BIT(Y_AXIS))); }
    return((1<<DIRECTION_BIT(Z_AXIS)));
  #else
    if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    4f6e:	80 e8       	ldi	r24, 0x80	; 128
    4f70:	08 95       	ret
    if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    4f72:	80 e4       	ldi	r24, 0x40	; 64
    return((1<<Z_DIRECTION_BIT));
  #endif // DEFAULTS_RAMPS_BOARD
}
    4f74:	08 95       	ret

00004f76 <get_limit_pin_mask>:
     return((1<<MAX_LIMIT_BIT(Z_AXIS)));
  }
#else
  uint8_t get_limit_pin_mask(uint8_t axis_idx)
  {
    if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    4f76:	88 23       	and	r24, r24
    4f78:	21 f0       	breq	.+8      	; 0x4f82 <get_limit_pin_mask+0xc>
    if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    4f7a:	81 30       	cpi	r24, 0x01	; 1
    4f7c:	21 f0       	breq	.+8      	; 0x4f86 <get_limit_pin_mask+0x10>
    return((1<<Z_LIMIT_BIT));
    4f7e:	80 e4       	ldi	r24, 0x40	; 64
    4f80:	08 95       	ret
     return((1<<MAX_LIMIT_BIT(Z_AXIS)));
  }
#else
  uint8_t get_limit_pin_mask(uint8_t axis_idx)
  {
    if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    4f82:	80 e1       	ldi	r24, 0x10	; 16
    4f84:	08 95       	ret
    if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    4f86:	80 e2       	ldi	r24, 0x20	; 32
    return((1<<Z_LIMIT_BIT));
  }
    4f88:	08 95       	ret

00004f8a <planner_recalculate>:
// NOTE: Deprecated. Not used unless classic status reports are enabled in config.h
uint8_t plan_get_block_buffer_count()
{
  if (block_buffer_head >= block_buffer_tail) { return(block_buffer_head-block_buffer_tail); }
  return(BLOCK_BUFFER_SIZE - (block_buffer_tail-block_buffer_head));
}
    4f8a:	2f 92       	push	r2
    4f8c:	3f 92       	push	r3
    4f8e:	4f 92       	push	r4
    4f90:	5f 92       	push	r5
    4f92:	6f 92       	push	r6
    4f94:	7f 92       	push	r7
    4f96:	8f 92       	push	r8
    4f98:	9f 92       	push	r9
    4f9a:	af 92       	push	r10
    4f9c:	bf 92       	push	r11
    4f9e:	cf 92       	push	r12
    4fa0:	df 92       	push	r13
    4fa2:	ef 92       	push	r14
    4fa4:	ff 92       	push	r15
    4fa6:	0f 93       	push	r16
    4fa8:	1f 93       	push	r17
    4faa:	cf 93       	push	r28
    4fac:	df 93       	push	r29
    4fae:	c0 91 76 04 	lds	r28, 0x0476	; 0x800476 <block_buffer_head>
    4fb2:	c1 11       	cpse	r28, r1
    4fb4:	01 c0       	rjmp	.+2      	; 0x4fb8 <planner_recalculate+0x2e>
    4fb6:	c4 e2       	ldi	r28, 0x24	; 36
    4fb8:	c1 50       	subi	r28, 0x01	; 1
    4fba:	d0 91 74 04 	lds	r29, 0x0474	; 0x800474 <block_buffer_planned>
    4fbe:	dc 17       	cp	r29, r28
    4fc0:	09 f4       	brne	.+2      	; 0x4fc4 <planner_recalculate+0x3a>
    4fc2:	36 c1       	rjmp	.+620    	; 0x5230 <planner_recalculate+0x2a6>
    4fc4:	0c 2f       	mov	r16, r28
    4fc6:	10 e0       	ldi	r17, 0x00	; 0
    4fc8:	26 e3       	ldi	r18, 0x36	; 54
    4fca:	c2 9f       	mul	r28, r18
    4fcc:	c0 01       	movw	r24, r0
    4fce:	11 24       	eor	r1, r1
    4fd0:	fc 01       	movw	r30, r24
    4fd2:	e8 58       	subi	r30, 0x88	; 136
    4fd4:	fb 4f       	sbci	r31, 0xFB	; 251
    4fd6:	6f 01       	movw	r12, r30
    4fd8:	e2 8c       	ldd	r14, Z+26	; 0x1a
    4fda:	f3 8c       	ldd	r15, Z+27	; 0x1b
    4fdc:	94 8c       	ldd	r9, Z+28	; 0x1c
    4fde:	85 8c       	ldd	r8, Z+29	; 0x1d
    4fe0:	66 8d       	ldd	r22, Z+30	; 0x1e
    4fe2:	77 8d       	ldd	r23, Z+31	; 0x1f
    4fe4:	80 a1       	ldd	r24, Z+32	; 0x20
    4fe6:	91 a1       	ldd	r25, Z+33	; 0x21
    4fe8:	9b 01       	movw	r18, r22
    4fea:	ac 01       	movw	r20, r24
    4fec:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    4ff0:	f6 01       	movw	r30, r12
    4ff2:	22 a1       	ldd	r18, Z+34	; 0x22
    4ff4:	33 a1       	ldd	r19, Z+35	; 0x23
    4ff6:	44 a1       	ldd	r20, Z+36	; 0x24
    4ff8:	55 a1       	ldd	r21, Z+37	; 0x25
    4ffa:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    4ffe:	a6 2e       	mov	r10, r22
    5000:	b7 2e       	mov	r11, r23
    5002:	c8 2e       	mov	r12, r24
    5004:	d9 2e       	mov	r13, r25
    5006:	26 2f       	mov	r18, r22
    5008:	37 2f       	mov	r19, r23
    500a:	48 2f       	mov	r20, r24
    500c:	59 2f       	mov	r21, r25
    500e:	6e 2d       	mov	r22, r14
    5010:	7f 2d       	mov	r23, r15
    5012:	89 2d       	mov	r24, r9
    5014:	98 2d       	mov	r25, r8
    5016:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    501a:	88 23       	and	r24, r24
    501c:	24 f0       	brlt	.+8      	; 0x5026 <planner_recalculate+0x9c>
    501e:	ea 2c       	mov	r14, r10
    5020:	fb 2c       	mov	r15, r11
    5022:	9c 2c       	mov	r9, r12
    5024:	8d 2c       	mov	r8, r13
    5026:	86 e3       	ldi	r24, 0x36	; 54
    5028:	80 9f       	mul	r24, r16
    502a:	f0 01       	movw	r30, r0
    502c:	81 9f       	mul	r24, r17
    502e:	f0 0d       	add	r31, r0
    5030:	11 24       	eor	r1, r1
    5032:	e8 58       	subi	r30, 0x88	; 136
    5034:	fb 4f       	sbci	r31, 0xFB	; 251
    5036:	8e 2d       	mov	r24, r14
    5038:	9f 2d       	mov	r25, r15
    503a:	a9 2d       	mov	r26, r9
    503c:	b8 2d       	mov	r27, r8
    503e:	86 8b       	std	Z+22, r24	; 0x16
    5040:	97 8b       	std	Z+23, r25	; 0x17
    5042:	a0 8f       	std	Z+24, r26	; 0x18
    5044:	b1 8f       	std	Z+25, r27	; 0x19
    5046:	c1 11       	cpse	r28, r1
    5048:	01 c0       	rjmp	.+2      	; 0x504c <planner_recalculate+0xc2>
    504a:	c4 e2       	ldi	r28, 0x24	; 36
    504c:	c1 50       	subi	r28, 0x01	; 1
    504e:	dc 13       	cpse	r29, r28
    5050:	07 c0       	rjmp	.+14     	; 0x5060 <planner_recalculate+0xd6>
    5052:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    5056:	d8 13       	cpse	r29, r24
    5058:	7c c0       	rjmp	.+248    	; 0x5152 <planner_recalculate+0x1c8>
    505a:	0e 94 02 1c 	call	0x3804	; 0x3804 <st_update_plan_block_parameters>
    505e:	79 c0       	rjmp	.+242    	; 0x5152 <planner_recalculate+0x1c8>
    5060:	26 e3       	ldi	r18, 0x36	; 54
    5062:	20 9f       	mul	r18, r16
    5064:	c0 01       	movw	r24, r0
    5066:	21 9f       	mul	r18, r17
    5068:	90 0d       	add	r25, r0
    506a:	11 24       	eor	r1, r1
    506c:	9c 01       	movw	r18, r24
    506e:	28 58       	subi	r18, 0x88	; 136
    5070:	3b 4f       	sbci	r19, 0xFB	; 251
    5072:	69 01       	movw	r12, r18
    5074:	d6 e3       	ldi	r29, 0x36	; 54
    5076:	ec 2e       	mov	r14, r28
    5078:	f1 2c       	mov	r15, r1
    507a:	de 9d       	mul	r29, r14
    507c:	80 01       	movw	r16, r0
    507e:	df 9d       	mul	r29, r15
    5080:	10 0d       	add	r17, r0
    5082:	11 24       	eor	r1, r1
    5084:	08 58       	subi	r16, 0x88	; 136
    5086:	1b 4f       	sbci	r17, 0xFB	; 251
    5088:	c1 11       	cpse	r28, r1
    508a:	01 c0       	rjmp	.+2      	; 0x508e <planner_recalculate+0x104>
    508c:	c4 e2       	ldi	r28, 0x24	; 36
    508e:	c1 50       	subi	r28, 0x01	; 1
    5090:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    5094:	8c 13       	cpse	r24, r28
    5096:	02 c0       	rjmp	.+4      	; 0x509c <planner_recalculate+0x112>
    5098:	0e 94 02 1c 	call	0x3804	; 0x3804 <st_update_plan_block_parameters>
    509c:	de 9d       	mul	r29, r14
    509e:	f0 01       	movw	r30, r0
    50a0:	df 9d       	mul	r29, r15
    50a2:	f0 0d       	add	r31, r0
    50a4:	11 24       	eor	r1, r1
    50a6:	e8 58       	subi	r30, 0x88	; 136
    50a8:	fb 4f       	sbci	r31, 0xFB	; 251
    50aa:	42 8c       	ldd	r4, Z+26	; 0x1a
    50ac:	53 8c       	ldd	r5, Z+27	; 0x1b
    50ae:	64 8c       	ldd	r6, Z+28	; 0x1c
    50b0:	75 8c       	ldd	r7, Z+29	; 0x1d
    50b2:	a3 01       	movw	r20, r6
    50b4:	92 01       	movw	r18, r4
    50b6:	66 89       	ldd	r22, Z+22	; 0x16
    50b8:	77 89       	ldd	r23, Z+23	; 0x17
    50ba:	80 8d       	ldd	r24, Z+24	; 0x18
    50bc:	91 8d       	ldd	r25, Z+25	; 0x19
    50be:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    50c2:	88 23       	and	r24, r24
    50c4:	09 f4       	brne	.+2      	; 0x50c8 <planner_recalculate+0x13e>
    50c6:	40 c0       	rjmp	.+128    	; 0x5148 <planner_recalculate+0x1be>
    50c8:	de 9d       	mul	r29, r14
    50ca:	c0 01       	movw	r24, r0
    50cc:	df 9d       	mul	r29, r15
    50ce:	90 0d       	add	r25, r0
    50d0:	11 24       	eor	r1, r1
    50d2:	fc 01       	movw	r30, r24
    50d4:	e8 58       	subi	r30, 0x88	; 136
    50d6:	fb 4f       	sbci	r31, 0xFB	; 251
    50d8:	5f 01       	movw	r10, r30
    50da:	66 8d       	ldd	r22, Z+30	; 0x1e
    50dc:	77 8d       	ldd	r23, Z+31	; 0x1f
    50de:	80 a1       	ldd	r24, Z+32	; 0x20
    50e0:	91 a1       	ldd	r25, Z+33	; 0x21
    50e2:	9b 01       	movw	r18, r22
    50e4:	ac 01       	movw	r20, r24
    50e6:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    50ea:	f5 01       	movw	r30, r10
    50ec:	22 a1       	ldd	r18, Z+34	; 0x22
    50ee:	33 a1       	ldd	r19, Z+35	; 0x23
    50f0:	44 a1       	ldd	r20, Z+36	; 0x24
    50f2:	55 a1       	ldd	r21, Z+37	; 0x25
    50f4:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    50f8:	f6 01       	movw	r30, r12
    50fa:	26 89       	ldd	r18, Z+22	; 0x16
    50fc:	37 89       	ldd	r19, Z+23	; 0x17
    50fe:	40 8d       	ldd	r20, Z+24	; 0x18
    5100:	51 8d       	ldd	r21, Z+25	; 0x19
    5102:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    5106:	4b 01       	movw	r8, r22
    5108:	5c 01       	movw	r10, r24
    510a:	9b 01       	movw	r18, r22
    510c:	ac 01       	movw	r20, r24
    510e:	c3 01       	movw	r24, r6
    5110:	b2 01       	movw	r22, r4
    5112:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    5116:	18 16       	cp	r1, r24
    5118:	64 f4       	brge	.+24     	; 0x5132 <planner_recalculate+0x1a8>
    511a:	de 9d       	mul	r29, r14
    511c:	f0 01       	movw	r30, r0
    511e:	df 9d       	mul	r29, r15
    5120:	f0 0d       	add	r31, r0
    5122:	11 24       	eor	r1, r1
    5124:	e8 58       	subi	r30, 0x88	; 136
    5126:	fb 4f       	sbci	r31, 0xFB	; 251
    5128:	86 8a       	std	Z+22, r8	; 0x16
    512a:	97 8a       	std	Z+23, r9	; 0x17
    512c:	a0 8e       	std	Z+24, r10	; 0x18
    512e:	b1 8e       	std	Z+25, r11	; 0x19
    5130:	0b c0       	rjmp	.+22     	; 0x5148 <planner_recalculate+0x1be>
    5132:	de 9d       	mul	r29, r14
    5134:	f0 01       	movw	r30, r0
    5136:	df 9d       	mul	r29, r15
    5138:	f0 0d       	add	r31, r0
    513a:	11 24       	eor	r1, r1
    513c:	e8 58       	subi	r30, 0x88	; 136
    513e:	fb 4f       	sbci	r31, 0xFB	; 251
    5140:	46 8a       	std	Z+22, r4	; 0x16
    5142:	57 8a       	std	Z+23, r5	; 0x17
    5144:	60 8e       	std	Z+24, r6	; 0x18
    5146:	71 8e       	std	Z+25, r7	; 0x19
    5148:	68 01       	movw	r12, r16
    514a:	80 91 74 04 	lds	r24, 0x0474	; 0x800474 <block_buffer_planned>
    514e:	8c 13       	cpse	r24, r28
    5150:	92 cf       	rjmp	.-220    	; 0x5076 <planner_recalculate+0xec>
    5152:	20 90 74 04 	lds	r2, 0x0474	; 0x800474 <block_buffer_planned>
    5156:	f6 e3       	ldi	r31, 0x36	; 54
    5158:	2f 9e       	mul	r2, r31
    515a:	c0 01       	movw	r24, r0
    515c:	11 24       	eor	r1, r1
    515e:	9c 01       	movw	r18, r24
    5160:	28 58       	subi	r18, 0x88	; 136
    5162:	3b 4f       	sbci	r19, 0xFB	; 251
    5164:	79 01       	movw	r14, r18
    5166:	c1 e0       	ldi	r28, 0x01	; 1
    5168:	c2 0d       	add	r28, r2
    516a:	c4 32       	cpi	r28, 0x24	; 36
    516c:	09 f4       	brne	.+2      	; 0x5170 <planner_recalculate+0x1e6>
    516e:	c0 e0       	ldi	r28, 0x00	; 0
    5170:	30 90 76 04 	lds	r3, 0x0476	; 0x800476 <block_buffer_head>
    5174:	d6 e3       	ldi	r29, 0x36	; 54
    5176:	58 c0       	rjmp	.+176    	; 0x5228 <planner_recalculate+0x29e>
    5178:	cc 2e       	mov	r12, r28
    517a:	d1 2c       	mov	r13, r1
    517c:	dc 9d       	mul	r29, r12
    517e:	80 01       	movw	r16, r0
    5180:	dd 9d       	mul	r29, r13
    5182:	10 0d       	add	r17, r0
    5184:	11 24       	eor	r1, r1
    5186:	08 58       	subi	r16, 0x88	; 136
    5188:	1b 4f       	sbci	r17, 0xFB	; 251
    518a:	f7 01       	movw	r30, r14
    518c:	46 88       	ldd	r4, Z+22	; 0x16
    518e:	57 88       	ldd	r5, Z+23	; 0x17
    5190:	60 8c       	ldd	r6, Z+24	; 0x18
    5192:	71 8c       	ldd	r7, Z+25	; 0x19
    5194:	f8 01       	movw	r30, r16
    5196:	86 88       	ldd	r8, Z+22	; 0x16
    5198:	97 88       	ldd	r9, Z+23	; 0x17
    519a:	a0 8c       	ldd	r10, Z+24	; 0x18
    519c:	b1 8c       	ldd	r11, Z+25	; 0x19
    519e:	a5 01       	movw	r20, r10
    51a0:	94 01       	movw	r18, r8
    51a2:	c3 01       	movw	r24, r6
    51a4:	b2 01       	movw	r22, r4
    51a6:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    51aa:	88 23       	and	r24, r24
    51ac:	24 f5       	brge	.+72     	; 0x51f6 <planner_recalculate+0x26c>
    51ae:	f7 01       	movw	r30, r14
    51b0:	66 8d       	ldd	r22, Z+30	; 0x1e
    51b2:	77 8d       	ldd	r23, Z+31	; 0x1f
    51b4:	80 a1       	ldd	r24, Z+32	; 0x20
    51b6:	91 a1       	ldd	r25, Z+33	; 0x21
    51b8:	9b 01       	movw	r18, r22
    51ba:	ac 01       	movw	r20, r24
    51bc:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    51c0:	f7 01       	movw	r30, r14
    51c2:	22 a1       	ldd	r18, Z+34	; 0x22
    51c4:	33 a1       	ldd	r19, Z+35	; 0x23
    51c6:	44 a1       	ldd	r20, Z+36	; 0x24
    51c8:	55 a1       	ldd	r21, Z+37	; 0x25
    51ca:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    51ce:	a3 01       	movw	r20, r6
    51d0:	92 01       	movw	r18, r4
    51d2:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    51d6:	2b 01       	movw	r4, r22
    51d8:	3c 01       	movw	r6, r24
    51da:	9b 01       	movw	r18, r22
    51dc:	ac 01       	movw	r20, r24
    51de:	c5 01       	movw	r24, r10
    51e0:	b4 01       	movw	r22, r8
    51e2:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    51e6:	18 16       	cp	r1, r24
    51e8:	34 f4       	brge	.+12     	; 0x51f6 <planner_recalculate+0x26c>
    51ea:	f8 01       	movw	r30, r16
    51ec:	46 8a       	std	Z+22, r4	; 0x16
    51ee:	57 8a       	std	Z+23, r5	; 0x17
    51f0:	60 8e       	std	Z+24, r6	; 0x18
    51f2:	71 8e       	std	Z+25, r7	; 0x19
    51f4:	2c 2e       	mov	r2, r28
    51f6:	dc 9d       	mul	r29, r12
    51f8:	f0 01       	movw	r30, r0
    51fa:	dd 9d       	mul	r29, r13
    51fc:	f0 0d       	add	r31, r0
    51fe:	11 24       	eor	r1, r1
    5200:	e8 58       	subi	r30, 0x88	; 136
    5202:	fb 4f       	sbci	r31, 0xFB	; 251
    5204:	22 8d       	ldd	r18, Z+26	; 0x1a
    5206:	33 8d       	ldd	r19, Z+27	; 0x1b
    5208:	44 8d       	ldd	r20, Z+28	; 0x1c
    520a:	55 8d       	ldd	r21, Z+29	; 0x1d
    520c:	66 89       	ldd	r22, Z+22	; 0x16
    520e:	77 89       	ldd	r23, Z+23	; 0x17
    5210:	80 8d       	ldd	r24, Z+24	; 0x18
    5212:	91 8d       	ldd	r25, Z+25	; 0x19
    5214:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    5218:	81 11       	cpse	r24, r1
    521a:	01 c0       	rjmp	.+2      	; 0x521e <planner_recalculate+0x294>
    521c:	2c 2e       	mov	r2, r28
    521e:	cf 5f       	subi	r28, 0xFF	; 255
    5220:	c4 32       	cpi	r28, 0x24	; 36
    5222:	09 f4       	brne	.+2      	; 0x5226 <planner_recalculate+0x29c>
    5224:	c0 e0       	ldi	r28, 0x00	; 0
    5226:	78 01       	movw	r14, r16
    5228:	c3 11       	cpse	r28, r3
    522a:	a6 cf       	rjmp	.-180    	; 0x5178 <planner_recalculate+0x1ee>
    522c:	20 92 74 04 	sts	0x0474, r2	; 0x800474 <block_buffer_planned>
    5230:	df 91       	pop	r29
    5232:	cf 91       	pop	r28
    5234:	1f 91       	pop	r17
    5236:	0f 91       	pop	r16
    5238:	ff 90       	pop	r15
    523a:	ef 90       	pop	r14
    523c:	df 90       	pop	r13
    523e:	cf 90       	pop	r12
    5240:	bf 90       	pop	r11
    5242:	af 90       	pop	r10
    5244:	9f 90       	pop	r9
    5246:	8f 90       	pop	r8
    5248:	7f 90       	pop	r7
    524a:	6f 90       	pop	r6
    524c:	5f 90       	pop	r5
    524e:	4f 90       	pop	r4
    5250:	3f 90       	pop	r3
    5252:	2f 90       	pop	r2
    5254:	08 95       	ret

00005256 <plan_reset_buffer>:
    5256:	10 92 77 04 	sts	0x0477, r1	; 0x800477 <block_buffer_tail>
    525a:	10 92 76 04 	sts	0x0476, r1	; 0x800476 <block_buffer_head>
    525e:	81 e0       	ldi	r24, 0x01	; 1
    5260:	80 93 75 04 	sts	0x0475, r24	; 0x800475 <next_buffer_head>
    5264:	10 92 74 04 	sts	0x0474, r1	; 0x800474 <block_buffer_planned>
    5268:	08 95       	ret

0000526a <plan_reset>:
    526a:	8c e1       	ldi	r24, 0x1C	; 28
    526c:	e8 e5       	ldi	r30, 0x58	; 88
    526e:	f4 e0       	ldi	r31, 0x04	; 4
    5270:	df 01       	movw	r26, r30
    5272:	1d 92       	st	X+, r1
    5274:	8a 95       	dec	r24
    5276:	e9 f7       	brne	.-6      	; 0x5272 <plan_reset+0x8>
    5278:	ee cf       	rjmp	.-36     	; 0x5256 <plan_reset_buffer>
    527a:	08 95       	ret

0000527c <plan_discard_current_block>:
    527c:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    5280:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <block_buffer_head>
    5284:	98 17       	cp	r25, r24
    5286:	69 f0       	breq	.+26     	; 0x52a2 <plan_discard_current_block+0x26>
    5288:	91 e0       	ldi	r25, 0x01	; 1
    528a:	98 0f       	add	r25, r24
    528c:	94 32       	cpi	r25, 0x24	; 36
    528e:	09 f4       	brne	.+2      	; 0x5292 <plan_discard_current_block+0x16>
    5290:	90 e0       	ldi	r25, 0x00	; 0
    5292:	20 91 74 04 	lds	r18, 0x0474	; 0x800474 <block_buffer_planned>
    5296:	82 13       	cpse	r24, r18
    5298:	02 c0       	rjmp	.+4      	; 0x529e <plan_discard_current_block+0x22>
    529a:	90 93 74 04 	sts	0x0474, r25	; 0x800474 <block_buffer_planned>
    529e:	90 93 77 04 	sts	0x0477, r25	; 0x800477 <block_buffer_tail>
    52a2:	08 95       	ret

000052a4 <plan_get_system_motion_block>:
    52a4:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <block_buffer_head>
    52a8:	26 e3       	ldi	r18, 0x36	; 54
    52aa:	82 9f       	mul	r24, r18
    52ac:	c0 01       	movw	r24, r0
    52ae:	11 24       	eor	r1, r1
    52b0:	88 58       	subi	r24, 0x88	; 136
    52b2:	9b 4f       	sbci	r25, 0xFB	; 251
    52b4:	08 95       	ret

000052b6 <plan_get_current_block>:
    52b6:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    52ba:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <block_buffer_head>
    52be:	98 17       	cp	r25, r24
    52c0:	39 f0       	breq	.+14     	; 0x52d0 <plan_get_current_block+0x1a>
    52c2:	26 e3       	ldi	r18, 0x36	; 54
    52c4:	82 9f       	mul	r24, r18
    52c6:	c0 01       	movw	r24, r0
    52c8:	11 24       	eor	r1, r1
    52ca:	88 58       	subi	r24, 0x88	; 136
    52cc:	9b 4f       	sbci	r25, 0xFB	; 251
    52ce:	08 95       	ret
    52d0:	80 e0       	ldi	r24, 0x00	; 0
    52d2:	90 e0       	ldi	r25, 0x00	; 0
    52d4:	08 95       	ret

000052d6 <plan_get_exec_block_exit_speed_sqr>:
    52d6:	e0 91 77 04 	lds	r30, 0x0477	; 0x800477 <block_buffer_tail>
    52da:	ef 5f       	subi	r30, 0xFF	; 255
    52dc:	e4 32       	cpi	r30, 0x24	; 36
    52de:	09 f4       	brne	.+2      	; 0x52e2 <plan_get_exec_block_exit_speed_sqr+0xc>
    52e0:	e0 e0       	ldi	r30, 0x00	; 0
    52e2:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <block_buffer_head>
    52e6:	8e 17       	cp	r24, r30
    52e8:	59 f0       	breq	.+22     	; 0x5300 <plan_get_exec_block_exit_speed_sqr+0x2a>
    52ea:	86 e3       	ldi	r24, 0x36	; 54
    52ec:	e8 9f       	mul	r30, r24
    52ee:	f0 01       	movw	r30, r0
    52f0:	11 24       	eor	r1, r1
    52f2:	e8 58       	subi	r30, 0x88	; 136
    52f4:	fb 4f       	sbci	r31, 0xFB	; 251
    52f6:	66 89       	ldd	r22, Z+22	; 0x16
    52f8:	77 89       	ldd	r23, Z+23	; 0x17
    52fa:	80 8d       	ldd	r24, Z+24	; 0x18
    52fc:	91 8d       	ldd	r25, Z+25	; 0x19
    52fe:	08 95       	ret
    5300:	60 e0       	ldi	r22, 0x00	; 0
    5302:	70 e0       	ldi	r23, 0x00	; 0
    5304:	cb 01       	movw	r24, r22
    5306:	08 95       	ret

00005308 <plan_check_full_buffer>:
    5308:	81 e0       	ldi	r24, 0x01	; 1
    530a:	20 91 77 04 	lds	r18, 0x0477	; 0x800477 <block_buffer_tail>
    530e:	90 91 75 04 	lds	r25, 0x0475	; 0x800475 <next_buffer_head>
    5312:	29 13       	cpse	r18, r25
    5314:	80 e0       	ldi	r24, 0x00	; 0
    5316:	08 95       	ret

00005318 <plan_compute_profile_nominal_speed>:
    5318:	af 92       	push	r10
    531a:	bf 92       	push	r11
    531c:	cf 92       	push	r12
    531e:	df 92       	push	r13
    5320:	ef 92       	push	r14
    5322:	ff 92       	push	r15
    5324:	0f 93       	push	r16
    5326:	1f 93       	push	r17
    5328:	cf 93       	push	r28
    532a:	df 93       	push	r29
    532c:	ec 01       	movw	r28, r24
    532e:	1e a5       	ldd	r17, Y+46	; 0x2e
    5330:	af a4       	ldd	r10, Y+47	; 0x2f
    5332:	e8 a8       	ldd	r14, Y+48	; 0x30
    5334:	09 a9       	ldd	r16, Y+49	; 0x31
    5336:	89 89       	ldd	r24, Y+17	; 0x11
    5338:	80 ff       	sbrs	r24, 0
    533a:	1a c0       	rjmp	.+52     	; 0x5370 <plan_compute_profile_nominal_speed+0x58>
    533c:	60 91 26 0c 	lds	r22, 0x0C26	; 0x800c26 <sys+0x8>
    5340:	70 e0       	ldi	r23, 0x00	; 0
    5342:	80 e0       	ldi	r24, 0x00	; 0
    5344:	90 e0       	ldi	r25, 0x00	; 0
    5346:	0e 94 07 40 	call	0x800e	; 0x800e <__floatsisf>
    534a:	2a e0       	ldi	r18, 0x0A	; 10
    534c:	37 ed       	ldi	r19, 0xD7	; 215
    534e:	43 e2       	ldi	r20, 0x23	; 35
    5350:	5c e3       	ldi	r21, 0x3C	; 60
    5352:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    5356:	9b 01       	movw	r18, r22
    5358:	ac 01       	movw	r20, r24
    535a:	61 2f       	mov	r22, r17
    535c:	7a 2d       	mov	r23, r10
    535e:	8e 2d       	mov	r24, r14
    5360:	90 2f       	mov	r25, r16
    5362:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    5366:	16 2f       	mov	r17, r22
    5368:	a7 2e       	mov	r10, r23
    536a:	e8 2e       	mov	r14, r24
    536c:	09 2f       	mov	r16, r25
    536e:	2f c0       	rjmp	.+94     	; 0x53ce <plan_compute_profile_nominal_speed+0xb6>
    5370:	82 fd       	sbrc	r24, 2
    5372:	19 c0       	rjmp	.+50     	; 0x53a6 <plan_compute_profile_nominal_speed+0x8e>
    5374:	60 91 25 0c 	lds	r22, 0x0C25	; 0x800c25 <sys+0x7>
    5378:	70 e0       	ldi	r23, 0x00	; 0
    537a:	80 e0       	ldi	r24, 0x00	; 0
    537c:	90 e0       	ldi	r25, 0x00	; 0
    537e:	0e 94 07 40 	call	0x800e	; 0x800e <__floatsisf>
    5382:	2a e0       	ldi	r18, 0x0A	; 10
    5384:	37 ed       	ldi	r19, 0xD7	; 215
    5386:	43 e2       	ldi	r20, 0x23	; 35
    5388:	5c e3       	ldi	r21, 0x3C	; 60
    538a:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    538e:	9b 01       	movw	r18, r22
    5390:	ac 01       	movw	r20, r24
    5392:	61 2f       	mov	r22, r17
    5394:	7a 2d       	mov	r23, r10
    5396:	8e 2d       	mov	r24, r14
    5398:	90 2f       	mov	r25, r16
    539a:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    539e:	16 2f       	mov	r17, r22
    53a0:	a7 2e       	mov	r10, r23
    53a2:	e8 2e       	mov	r14, r24
    53a4:	09 2f       	mov	r16, r25
    53a6:	ba a4       	ldd	r11, Y+42	; 0x2a
    53a8:	cb a4       	ldd	r12, Y+43	; 0x2b
    53aa:	dc a4       	ldd	r13, Y+44	; 0x2c
    53ac:	fd a4       	ldd	r15, Y+45	; 0x2d
    53ae:	2b 2d       	mov	r18, r11
    53b0:	3c 2d       	mov	r19, r12
    53b2:	4d 2d       	mov	r20, r13
    53b4:	5f 2d       	mov	r21, r15
    53b6:	61 2f       	mov	r22, r17
    53b8:	7a 2d       	mov	r23, r10
    53ba:	8e 2d       	mov	r24, r14
    53bc:	90 2f       	mov	r25, r16
    53be:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    53c2:	18 16       	cp	r1, r24
    53c4:	24 f4       	brge	.+8      	; 0x53ce <plan_compute_profile_nominal_speed+0xb6>
    53c6:	1b 2d       	mov	r17, r11
    53c8:	ac 2c       	mov	r10, r12
    53ca:	ed 2c       	mov	r14, r13
    53cc:	0f 2d       	mov	r16, r15
    53ce:	20 e0       	ldi	r18, 0x00	; 0
    53d0:	30 e0       	ldi	r19, 0x00	; 0
    53d2:	40 e8       	ldi	r20, 0x80	; 128
    53d4:	5f e3       	ldi	r21, 0x3F	; 63
    53d6:	61 2f       	mov	r22, r17
    53d8:	7a 2d       	mov	r23, r10
    53da:	8e 2d       	mov	r24, r14
    53dc:	90 2f       	mov	r25, r16
    53de:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    53e2:	18 16       	cp	r1, r24
    53e4:	1c f4       	brge	.+6      	; 0x53ec <plan_compute_profile_nominal_speed+0xd4>
    53e6:	da 2d       	mov	r29, r10
    53e8:	ce 2d       	mov	r28, r14
    53ea:	04 c0       	rjmp	.+8      	; 0x53f4 <plan_compute_profile_nominal_speed+0xdc>
    53ec:	10 e0       	ldi	r17, 0x00	; 0
    53ee:	d0 e0       	ldi	r29, 0x00	; 0
    53f0:	c0 e8       	ldi	r28, 0x80	; 128
    53f2:	0f e3       	ldi	r16, 0x3F	; 63
    53f4:	61 2f       	mov	r22, r17
    53f6:	7d 2f       	mov	r23, r29
    53f8:	8c 2f       	mov	r24, r28
    53fa:	90 2f       	mov	r25, r16
    53fc:	df 91       	pop	r29
    53fe:	cf 91       	pop	r28
    5400:	1f 91       	pop	r17
    5402:	0f 91       	pop	r16
    5404:	ff 90       	pop	r15
    5406:	ef 90       	pop	r14
    5408:	df 90       	pop	r13
    540a:	cf 90       	pop	r12
    540c:	bf 90       	pop	r11
    540e:	af 90       	pop	r10
    5410:	08 95       	ret

00005412 <plan_update_velocity_profile_parameters>:
    5412:	5f 92       	push	r5
    5414:	6f 92       	push	r6
    5416:	7f 92       	push	r7
    5418:	8f 92       	push	r8
    541a:	9f 92       	push	r9
    541c:	af 92       	push	r10
    541e:	bf 92       	push	r11
    5420:	cf 92       	push	r12
    5422:	df 92       	push	r13
    5424:	ef 92       	push	r14
    5426:	ff 92       	push	r15
    5428:	0f 93       	push	r16
    542a:	1f 93       	push	r17
    542c:	cf 93       	push	r28
    542e:	df 93       	push	r29
    5430:	10 91 77 04 	lds	r17, 0x0477	; 0x800477 <block_buffer_tail>
    5434:	50 90 76 04 	lds	r5, 0x0476	; 0x800476 <block_buffer_head>
    5438:	0f 2e       	mov	r0, r31
    543a:	f9 e9       	ldi	r31, 0x99	; 153
    543c:	9f 2e       	mov	r9, r31
    543e:	f0 2d       	mov	r31, r0
    5440:	0f 2e       	mov	r0, r31
    5442:	f6 e7       	ldi	r31, 0x76	; 118
    5444:	8f 2e       	mov	r8, r31
    5446:	f0 2d       	mov	r31, r0
    5448:	0f 2e       	mov	r0, r31
    544a:	f6 e9       	ldi	r31, 0x96	; 150
    544c:	7f 2e       	mov	r7, r31
    544e:	f0 2d       	mov	r31, r0
    5450:	0f 2e       	mov	r0, r31
    5452:	fe e7       	ldi	r31, 0x7E	; 126
    5454:	6f 2e       	mov	r6, r31
    5456:	f0 2d       	mov	r31, r0
    5458:	0f 2e       	mov	r0, r31
    545a:	f6 e3       	ldi	r31, 0x36	; 54
    545c:	cf 2e       	mov	r12, r31
    545e:	f0 2d       	mov	r31, r0
    5460:	73 c0       	rjmp	.+230    	; 0x5548 <plan_update_velocity_profile_parameters+0x136>
    5462:	c1 2f       	mov	r28, r17
    5464:	d0 e0       	ldi	r29, 0x00	; 0
    5466:	cc 9e       	mul	r12, r28
    5468:	c0 01       	movw	r24, r0
    546a:	cd 9e       	mul	r12, r29
    546c:	90 0d       	add	r25, r0
    546e:	11 24       	eor	r1, r1
    5470:	88 58       	subi	r24, 0x88	; 136
    5472:	9b 4f       	sbci	r25, 0xFB	; 251
    5474:	51 df       	rcall	.-350    	; 0x5318 <plan_compute_profile_nominal_speed>
    5476:	06 2f       	mov	r16, r22
    5478:	f7 2e       	mov	r15, r23
    547a:	e8 2e       	mov	r14, r24
    547c:	d9 2e       	mov	r13, r25
    547e:	26 2f       	mov	r18, r22
    5480:	37 2f       	mov	r19, r23
    5482:	48 2f       	mov	r20, r24
    5484:	59 2f       	mov	r21, r25
    5486:	69 2d       	mov	r22, r9
    5488:	78 2d       	mov	r23, r8
    548a:	87 2d       	mov	r24, r7
    548c:	96 2d       	mov	r25, r6
    548e:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    5492:	88 23       	and	r24, r24
    5494:	cc f4       	brge	.+50     	; 0x54c8 <plan_update_velocity_profile_parameters+0xb6>
    5496:	cc 9e       	mul	r12, r28
    5498:	c0 01       	movw	r24, r0
    549a:	cd 9e       	mul	r12, r29
    549c:	90 0d       	add	r25, r0
    549e:	11 24       	eor	r1, r1
    54a0:	9c 01       	movw	r18, r24
    54a2:	28 58       	subi	r18, 0x88	; 136
    54a4:	3b 4f       	sbci	r19, 0xFB	; 251
    54a6:	59 01       	movw	r10, r18
    54a8:	29 2d       	mov	r18, r9
    54aa:	38 2d       	mov	r19, r8
    54ac:	47 2d       	mov	r20, r7
    54ae:	56 2d       	mov	r21, r6
    54b0:	69 2d       	mov	r22, r9
    54b2:	78 2d       	mov	r23, r8
    54b4:	87 2d       	mov	r24, r7
    54b6:	96 2d       	mov	r25, r6
    54b8:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    54bc:	f5 01       	movw	r30, r10
    54be:	62 8f       	std	Z+26, r22	; 0x1a
    54c0:	73 8f       	std	Z+27, r23	; 0x1b
    54c2:	84 8f       	std	Z+28, r24	; 0x1c
    54c4:	95 8f       	std	Z+29, r25	; 0x1d
    54c6:	18 c0       	rjmp	.+48     	; 0x54f8 <plan_update_velocity_profile_parameters+0xe6>
    54c8:	cc 9e       	mul	r12, r28
    54ca:	c0 01       	movw	r24, r0
    54cc:	cd 9e       	mul	r12, r29
    54ce:	90 0d       	add	r25, r0
    54d0:	11 24       	eor	r1, r1
    54d2:	9c 01       	movw	r18, r24
    54d4:	28 58       	subi	r18, 0x88	; 136
    54d6:	3b 4f       	sbci	r19, 0xFB	; 251
    54d8:	59 01       	movw	r10, r18
    54da:	20 2f       	mov	r18, r16
    54dc:	3f 2d       	mov	r19, r15
    54de:	4e 2d       	mov	r20, r14
    54e0:	5d 2d       	mov	r21, r13
    54e2:	60 2f       	mov	r22, r16
    54e4:	7f 2d       	mov	r23, r15
    54e6:	8e 2d       	mov	r24, r14
    54e8:	9d 2d       	mov	r25, r13
    54ea:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    54ee:	f5 01       	movw	r30, r10
    54f0:	62 8f       	std	Z+26, r22	; 0x1a
    54f2:	73 8f       	std	Z+27, r23	; 0x1b
    54f4:	84 8f       	std	Z+28, r24	; 0x1c
    54f6:	95 8f       	std	Z+29, r25	; 0x1d
    54f8:	cc 9e       	mul	r12, r28
    54fa:	f0 01       	movw	r30, r0
    54fc:	cd 9e       	mul	r12, r29
    54fe:	f0 0d       	add	r31, r0
    5500:	11 24       	eor	r1, r1
    5502:	e8 58       	subi	r30, 0x88	; 136
    5504:	fb 4f       	sbci	r31, 0xFB	; 251
    5506:	86 a0       	ldd	r8, Z+38	; 0x26
    5508:	97 a0       	ldd	r9, Z+39	; 0x27
    550a:	a0 a4       	ldd	r10, Z+40	; 0x28
    550c:	b1 a4       	ldd	r11, Z+41	; 0x29
    550e:	a5 01       	movw	r20, r10
    5510:	94 01       	movw	r18, r8
    5512:	62 8d       	ldd	r22, Z+26	; 0x1a
    5514:	73 8d       	ldd	r23, Z+27	; 0x1b
    5516:	84 8d       	ldd	r24, Z+28	; 0x1c
    5518:	95 8d       	ldd	r25, Z+29	; 0x1d
    551a:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    551e:	18 16       	cp	r1, r24
    5520:	5c f4       	brge	.+22     	; 0x5538 <plan_update_velocity_profile_parameters+0x126>
    5522:	cc 9e       	mul	r12, r28
    5524:	f0 01       	movw	r30, r0
    5526:	cd 9e       	mul	r12, r29
    5528:	f0 0d       	add	r31, r0
    552a:	11 24       	eor	r1, r1
    552c:	e8 58       	subi	r30, 0x88	; 136
    552e:	fb 4f       	sbci	r31, 0xFB	; 251
    5530:	82 8e       	std	Z+26, r8	; 0x1a
    5532:	93 8e       	std	Z+27, r9	; 0x1b
    5534:	a4 8e       	std	Z+28, r10	; 0x1c
    5536:	b5 8e       	std	Z+29, r11	; 0x1d
    5538:	1f 5f       	subi	r17, 0xFF	; 255
    553a:	14 32       	cpi	r17, 0x24	; 36
    553c:	09 f4       	brne	.+2      	; 0x5540 <plan_update_velocity_profile_parameters+0x12e>
    553e:	10 e0       	ldi	r17, 0x00	; 0
    5540:	90 2e       	mov	r9, r16
    5542:	8f 2c       	mov	r8, r15
    5544:	7e 2c       	mov	r7, r14
    5546:	6d 2c       	mov	r6, r13
    5548:	15 11       	cpse	r17, r5
    554a:	8b cf       	rjmp	.-234    	; 0x5462 <plan_update_velocity_profile_parameters+0x50>
    554c:	89 2d       	mov	r24, r9
    554e:	98 2d       	mov	r25, r8
    5550:	a7 2d       	mov	r26, r7
    5552:	b6 2d       	mov	r27, r6
    5554:	80 93 70 04 	sts	0x0470, r24	; 0x800470 <pl+0x18>
    5558:	90 93 71 04 	sts	0x0471, r25	; 0x800471 <pl+0x19>
    555c:	a0 93 72 04 	sts	0x0472, r26	; 0x800472 <pl+0x1a>
    5560:	b0 93 73 04 	sts	0x0473, r27	; 0x800473 <pl+0x1b>
    5564:	df 91       	pop	r29
    5566:	cf 91       	pop	r28
    5568:	1f 91       	pop	r17
    556a:	0f 91       	pop	r16
    556c:	ff 90       	pop	r15
    556e:	ef 90       	pop	r14
    5570:	df 90       	pop	r13
    5572:	cf 90       	pop	r12
    5574:	bf 90       	pop	r11
    5576:	af 90       	pop	r10
    5578:	9f 90       	pop	r9
    557a:	8f 90       	pop	r8
    557c:	7f 90       	pop	r7
    557e:	6f 90       	pop	r6
    5580:	5f 90       	pop	r5
    5582:	08 95       	ret

00005584 <plan_buffer_line>:
    5584:	2f 92       	push	r2
    5586:	3f 92       	push	r3
    5588:	4f 92       	push	r4
    558a:	5f 92       	push	r5
    558c:	6f 92       	push	r6
    558e:	7f 92       	push	r7
    5590:	8f 92       	push	r8
    5592:	9f 92       	push	r9
    5594:	af 92       	push	r10
    5596:	bf 92       	push	r11
    5598:	cf 92       	push	r12
    559a:	df 92       	push	r13
    559c:	ef 92       	push	r14
    559e:	ff 92       	push	r15
    55a0:	0f 93       	push	r16
    55a2:	1f 93       	push	r17
    55a4:	cf 93       	push	r28
    55a6:	df 93       	push	r29
    55a8:	cd b7       	in	r28, 0x3d	; 61
    55aa:	de b7       	in	r29, 0x3e	; 62
    55ac:	c6 54       	subi	r28, 0x46	; 70
    55ae:	d1 09       	sbc	r29, r1
    55b0:	0f b6       	in	r0, 0x3f	; 63
    55b2:	f8 94       	cli
    55b4:	de bf       	out	0x3e, r29	; 62
    55b6:	0f be       	out	0x3f, r0	; 63
    55b8:	cd bf       	out	0x3d, r28	; 61
    55ba:	23 96       	adiw	r28, 0x03	; 3
    55bc:	7f af       	std	Y+63, r23	; 0x3f
    55be:	6e af       	std	Y+62, r22	; 0x3e
    55c0:	23 97       	sbiw	r28, 0x03	; 3
    55c2:	20 90 76 04 	lds	r2, 0x0476	; 0x800476 <block_buffer_head>
    55c6:	a2 2c       	mov	r10, r2
    55c8:	b1 2c       	mov	r11, r1
    55ca:	26 e3       	ldi	r18, 0x36	; 54
    55cc:	2a 9d       	mul	r18, r10
    55ce:	a0 01       	movw	r20, r0
    55d0:	2b 9d       	mul	r18, r11
    55d2:	50 0d       	add	r21, r0
    55d4:	11 24       	eor	r1, r1
    55d6:	ba 01       	movw	r22, r20
    55d8:	68 58       	subi	r22, 0x88	; 136
    55da:	7b 4f       	sbci	r23, 0xFB	; 251
    55dc:	21 96       	adiw	r28, 0x01	; 1
    55de:	7f af       	std	Y+63, r23	; 0x3f
    55e0:	6e af       	std	Y+62, r22	; 0x3e
    55e2:	21 97       	sbiw	r28, 0x01	; 1
    55e4:	fb 01       	movw	r30, r22
    55e6:	11 92       	st	Z+, r1
    55e8:	2a 95       	dec	r18
    55ea:	e9 f7       	brne	.-6      	; 0x55e6 <plan_buffer_line+0x62>
    55ec:	23 96       	adiw	r28, 0x03	; 3
    55ee:	ee ad       	ldd	r30, Y+62	; 0x3e
    55f0:	ff ad       	ldd	r31, Y+63	; 0x3f
    55f2:	23 97       	sbiw	r28, 0x03	; 3
    55f4:	24 85       	ldd	r18, Z+12	; 0x0c
    55f6:	fb 01       	movw	r30, r22
    55f8:	21 8b       	std	Z+17, r18	; 0x11
    55fa:	23 96       	adiw	r28, 0x03	; 3
    55fc:	ee ad       	ldd	r30, Y+62	; 0x3e
    55fe:	ff ad       	ldd	r31, Y+63	; 0x3f
    5600:	23 97       	sbiw	r28, 0x03	; 3
    5602:	44 81       	ldd	r20, Z+4	; 0x04
    5604:	55 81       	ldd	r21, Z+5	; 0x05
    5606:	66 81       	ldd	r22, Z+6	; 0x06
    5608:	77 81       	ldd	r23, Z+7	; 0x07
    560a:	21 96       	adiw	r28, 0x01	; 1
    560c:	ee ad       	ldd	r30, Y+62	; 0x3e
    560e:	ff ad       	ldd	r31, Y+63	; 0x3f
    5610:	21 97       	sbiw	r28, 0x01	; 1
    5612:	42 ab       	std	Z+50, r20	; 0x32
    5614:	53 ab       	std	Z+51, r21	; 0x33
    5616:	64 ab       	std	Z+52, r22	; 0x34
    5618:	75 ab       	std	Z+53, r23	; 0x35
    561a:	23 96       	adiw	r28, 0x03	; 3
    561c:	ee ad       	ldd	r30, Y+62	; 0x3e
    561e:	ff ad       	ldd	r31, Y+63	; 0x3f
    5620:	23 97       	sbiw	r28, 0x03	; 3
    5622:	40 85       	ldd	r20, Z+8	; 0x08
    5624:	51 85       	ldd	r21, Z+9	; 0x09
    5626:	62 85       	ldd	r22, Z+10	; 0x0a
    5628:	73 85       	ldd	r23, Z+11	; 0x0b
    562a:	21 96       	adiw	r28, 0x01	; 1
    562c:	ee ad       	ldd	r30, Y+62	; 0x3e
    562e:	ff ad       	ldd	r31, Y+63	; 0x3f
    5630:	21 97       	sbiw	r28, 0x01	; 1
    5632:	42 8b       	std	Z+18, r20	; 0x12
    5634:	53 8b       	std	Z+19, r21	; 0x13
    5636:	64 8b       	std	Z+20, r22	; 0x14
    5638:	75 8b       	std	Z+21, r23	; 0x15
    563a:	21 ff       	sbrs	r18, 1
    563c:	0a c0       	rjmp	.+20     	; 0x5652 <plan_buffer_line+0xce>
    563e:	2c e0       	ldi	r18, 0x0C	; 12
    5640:	e3 e4       	ldi	r30, 0x43	; 67
    5642:	fc e0       	ldi	r31, 0x0C	; 12
    5644:	de 01       	movw	r26, r28
    5646:	1d 96       	adiw	r26, 0x0d	; 13
    5648:	01 90       	ld	r0, Z+
    564a:	0d 92       	st	X+, r0
    564c:	2a 95       	dec	r18
    564e:	e1 f7       	brne	.-8      	; 0x5648 <plan_buffer_line+0xc4>
    5650:	65 c2       	rjmp	.+1226   	; 0x5b1c <plan_buffer_line+0x598>
    5652:	2c e0       	ldi	r18, 0x0C	; 12
    5654:	e8 e5       	ldi	r30, 0x58	; 88
    5656:	f4 e0       	ldi	r31, 0x04	; 4
    5658:	de 01       	movw	r26, r28
    565a:	1d 96       	adiw	r26, 0x0d	; 13
    565c:	01 90       	ld	r0, Z+
    565e:	0d 92       	st	X+, r0
    5660:	2a 95       	dec	r18
    5662:	e1 f7       	brne	.-8      	; 0x565c <plan_buffer_line+0xd8>
    5664:	5b c2       	rjmp	.+1206   	; 0x5b1c <plan_buffer_line+0x598>
    5666:	e9 ad       	ldd	r30, Y+57	; 0x39
    5668:	fa ad       	ldd	r31, Y+58	; 0x3a
    566a:	61 91       	ld	r22, Z+
    566c:	71 91       	ld	r23, Z+
    566e:	81 91       	ld	r24, Z+
    5670:	91 91       	ld	r25, Z+
    5672:	fa af       	std	Y+58, r31	; 0x3a
    5674:	e9 af       	std	Y+57, r30	; 0x39
    5676:	eb ad       	ldd	r30, Y+59	; 0x3b
    5678:	fc ad       	ldd	r31, Y+60	; 0x3c
    567a:	21 91       	ld	r18, Z+
    567c:	31 91       	ld	r19, Z+
    567e:	41 91       	ld	r20, Z+
    5680:	51 91       	ld	r21, Z+
    5682:	fc af       	std	Y+60, r31	; 0x3c
    5684:	eb af       	std	Y+59, r30	; 0x3b
    5686:	2d ab       	std	Y+53, r18	; 0x35
    5688:	3e ab       	std	Y+54, r19	; 0x36
    568a:	4f ab       	std	Y+55, r20	; 0x37
    568c:	58 af       	std	Y+56, r21	; 0x38
    568e:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    5692:	0e 94 73 41 	call	0x82e6	; 0x82e6 <lround>
    5696:	f4 01       	movw	r30, r8
    5698:	61 93       	st	Z+, r22
    569a:	71 93       	st	Z+, r23
    569c:	81 93       	st	Z+, r24
    569e:	91 93       	st	Z+, r25
    56a0:	4f 01       	movw	r8, r30
    56a2:	f6 01       	movw	r30, r12
    56a4:	01 91       	ld	r16, Z+
    56a6:	11 91       	ld	r17, Z+
    56a8:	21 91       	ld	r18, Z+
    56aa:	31 91       	ld	r19, Z+
    56ac:	6f 01       	movw	r12, r30
    56ae:	60 1b       	sub	r22, r16
    56b0:	71 0b       	sbc	r23, r17
    56b2:	82 0b       	sbc	r24, r18
    56b4:	93 0b       	sbc	r25, r19
    56b6:	8b 01       	movw	r16, r22
    56b8:	9c 01       	movw	r18, r24
    56ba:	3a f4       	brpl	.+14     	; 0x56ca <plan_buffer_line+0x146>
    56bc:	00 27       	eor	r16, r16
    56be:	11 27       	eor	r17, r17
    56c0:	98 01       	movw	r18, r16
    56c2:	06 1b       	sub	r16, r22
    56c4:	17 0b       	sbc	r17, r23
    56c6:	28 0b       	sbc	r18, r24
    56c8:	39 0b       	sbc	r19, r25
    56ca:	f1 01       	movw	r30, r2
    56cc:	01 93       	st	Z+, r16
    56ce:	11 93       	st	Z+, r17
    56d0:	21 93       	st	Z+, r18
    56d2:	31 93       	st	Z+, r19
    56d4:	1f 01       	movw	r2, r30
    56d6:	f7 01       	movw	r30, r14
    56d8:	40 80       	ld	r4, Z
    56da:	51 80       	ldd	r5, Z+1	; 0x01
    56dc:	62 80       	ldd	r6, Z+2	; 0x02
    56de:	73 80       	ldd	r7, Z+3	; 0x03
    56e0:	40 16       	cp	r4, r16
    56e2:	51 06       	cpc	r5, r17
    56e4:	62 06       	cpc	r6, r18
    56e6:	73 06       	cpc	r7, r19
    56e8:	10 f4       	brcc	.+4      	; 0x56ee <plan_buffer_line+0x16a>
    56ea:	28 01       	movw	r4, r16
    56ec:	39 01       	movw	r6, r18
    56ee:	f7 01       	movw	r30, r14
    56f0:	40 82       	st	Z, r4
    56f2:	51 82       	std	Z+1, r5	; 0x01
    56f4:	62 82       	std	Z+2, r6	; 0x02
    56f6:	73 82       	std	Z+3, r7	; 0x03
    56f8:	0e 94 07 40 	call	0x800e	; 0x800e <__floatsisf>
    56fc:	2d a9       	ldd	r18, Y+53	; 0x35
    56fe:	3e a9       	ldd	r19, Y+54	; 0x36
    5700:	4f a9       	ldd	r20, Y+55	; 0x37
    5702:	58 ad       	ldd	r21, Y+56	; 0x38
    5704:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__divsf3>
    5708:	ed ad       	ldd	r30, Y+61	; 0x3d
    570a:	fe ad       	ldd	r31, Y+62	; 0x3e
    570c:	61 93       	st	Z+, r22
    570e:	71 93       	st	Z+, r23
    5710:	81 93       	st	Z+, r24
    5712:	91 93       	st	Z+, r25
    5714:	fe af       	std	Y+62, r31	; 0x3e
    5716:	ed af       	std	Y+61, r30	; 0x3d
    5718:	20 e0       	ldi	r18, 0x00	; 0
    571a:	30 e0       	ldi	r19, 0x00	; 0
    571c:	a9 01       	movw	r20, r18
    571e:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    5722:	88 23       	and	r24, r24
    5724:	4c f4       	brge	.+18     	; 0x5738 <plan_buffer_line+0x1b4>
    5726:	89 a9       	ldd	r24, Y+49	; 0x31
    5728:	1c dc       	rcall	.-1992   	; 0x4f62 <get_direction_pin_mask>
    572a:	27 96       	adiw	r28, 0x07	; 7
    572c:	ee ad       	ldd	r30, Y+62	; 0x3e
    572e:	ff ad       	ldd	r31, Y+63	; 0x3f
    5730:	27 97       	sbiw	r28, 0x07	; 7
    5732:	90 81       	ld	r25, Z
    5734:	89 2b       	or	r24, r25
    5736:	80 83       	st	Z, r24
    5738:	f9 a9       	ldd	r31, Y+49	; 0x31
    573a:	ff 5f       	subi	r31, 0xFF	; 255
    573c:	f9 ab       	std	Y+49, r31	; 0x31
    573e:	f3 30       	cpi	r31, 0x03	; 3
    5740:	09 f0       	breq	.+2      	; 0x5744 <plan_buffer_line+0x1c0>
    5742:	91 cf       	rjmp	.-222    	; 0x5666 <plan_buffer_line+0xe2>
    5744:	86 e3       	ldi	r24, 0x36	; 54
    5746:	8a 9d       	mul	r24, r10
    5748:	f0 01       	movw	r30, r0
    574a:	8b 9d       	mul	r24, r11
    574c:	f0 0d       	add	r31, r0
    574e:	11 24       	eor	r1, r1
    5750:	e8 58       	subi	r30, 0x88	; 136
    5752:	fb 4f       	sbci	r31, 0xFB	; 251
    5754:	84 85       	ldd	r24, Z+12	; 0x0c
    5756:	95 85       	ldd	r25, Z+13	; 0x0d
    5758:	a6 85       	ldd	r26, Z+14	; 0x0e
    575a:	b7 85       	ldd	r27, Z+15	; 0x0f
    575c:	89 2b       	or	r24, r25
    575e:	8a 2b       	or	r24, r26
    5760:	8b 2b       	or	r24, r27
    5762:	09 f4       	brne	.+2      	; 0x5766 <plan_buffer_line+0x1e2>
    5764:	d7 c1       	rjmp	.+942    	; 0x5b14 <plan_buffer_line+0x590>
    5766:	ce 01       	movw	r24, r28
    5768:	49 96       	adiw	r24, 0x19	; 25
    576a:	8e d3       	rcall	.+1820   	; 0x5e88 <convert_delta_vector_to_unit_vector>
    576c:	26 e3       	ldi	r18, 0x36	; 54
    576e:	2a 9d       	mul	r18, r10
    5770:	80 01       	movw	r16, r0
    5772:	2b 9d       	mul	r18, r11
    5774:	10 0d       	add	r17, r0
    5776:	11 24       	eor	r1, r1
    5778:	08 58       	subi	r16, 0x88	; 136
    577a:	1b 4f       	sbci	r17, 0xFB	; 251
    577c:	f8 01       	movw	r30, r16
    577e:	62 a3       	std	Z+34, r22	; 0x22
    5780:	73 a3       	std	Z+35, r23	; 0x23
    5782:	84 a3       	std	Z+36, r24	; 0x24
    5784:	95 a3       	std	Z+37, r25	; 0x25
    5786:	be 01       	movw	r22, r28
    5788:	67 5e       	subi	r22, 0xE7	; 231
    578a:	7f 4f       	sbci	r23, 0xFF	; 255
    578c:	88 ee       	ldi	r24, 0xE8	; 232
    578e:	9e e0       	ldi	r25, 0x0E	; 14
    5790:	e2 d3       	rcall	.+1988   	; 0x5f56 <limit_value_by_axis_maximum>
    5792:	f8 01       	movw	r30, r16
    5794:	66 8f       	std	Z+30, r22	; 0x1e
    5796:	77 8f       	std	Z+31, r23	; 0x1f
    5798:	80 a3       	std	Z+32, r24	; 0x20
    579a:	91 a3       	std	Z+33, r25	; 0x21
    579c:	be 01       	movw	r22, r28
    579e:	67 5e       	subi	r22, 0xE7	; 231
    57a0:	7f 4f       	sbci	r23, 0xFF	; 255
    57a2:	8c ed       	ldi	r24, 0xDC	; 220
    57a4:	9e e0       	ldi	r25, 0x0E	; 14
    57a6:	d7 d3       	rcall	.+1966   	; 0x5f56 <limit_value_by_axis_maximum>
    57a8:	f8 01       	movw	r30, r16
    57aa:	62 a7       	std	Z+42, r22	; 0x2a
    57ac:	73 a7       	std	Z+43, r23	; 0x2b
    57ae:	84 a7       	std	Z+44, r24	; 0x2c
    57b0:	95 a7       	std	Z+45, r25	; 0x2d
    57b2:	11 89       	ldd	r17, Z+17	; 0x11
    57b4:	10 ff       	sbrs	r17, 0
    57b6:	0d c0       	rjmp	.+26     	; 0x57d2 <plan_buffer_line+0x24e>
    57b8:	26 e3       	ldi	r18, 0x36	; 54
    57ba:	2a 9d       	mul	r18, r10
    57bc:	f0 01       	movw	r30, r0
    57be:	2b 9d       	mul	r18, r11
    57c0:	f0 0d       	add	r31, r0
    57c2:	11 24       	eor	r1, r1
    57c4:	e8 58       	subi	r30, 0x88	; 136
    57c6:	fb 4f       	sbci	r31, 0xFB	; 251
    57c8:	66 a7       	std	Z+46, r22	; 0x2e
    57ca:	77 a7       	std	Z+47, r23	; 0x2f
    57cc:	80 ab       	std	Z+48, r24	; 0x30
    57ce:	91 ab       	std	Z+49, r25	; 0x31
    57d0:	22 c0       	rjmp	.+68     	; 0x5816 <plan_buffer_line+0x292>
    57d2:	23 96       	adiw	r28, 0x03	; 3
    57d4:	ee ad       	ldd	r30, Y+62	; 0x3e
    57d6:	ff ad       	ldd	r31, Y+63	; 0x3f
    57d8:	23 97       	sbiw	r28, 0x03	; 3
    57da:	20 81       	ld	r18, Z
    57dc:	31 81       	ldd	r19, Z+1	; 0x01
    57de:	42 81       	ldd	r20, Z+2	; 0x02
    57e0:	53 81       	ldd	r21, Z+3	; 0x03
    57e2:	86 e3       	ldi	r24, 0x36	; 54
    57e4:	8a 9d       	mul	r24, r10
    57e6:	f0 01       	movw	r30, r0
    57e8:	8b 9d       	mul	r24, r11
    57ea:	f0 0d       	add	r31, r0
    57ec:	11 24       	eor	r1, r1
    57ee:	e8 58       	subi	r30, 0x88	; 136
    57f0:	fb 4f       	sbci	r31, 0xFB	; 251
    57f2:	26 a7       	std	Z+46, r18	; 0x2e
    57f4:	37 a7       	std	Z+47, r19	; 0x2f
    57f6:	40 ab       	std	Z+48, r20	; 0x30
    57f8:	51 ab       	std	Z+49, r21	; 0x31
    57fa:	13 ff       	sbrs	r17, 3
    57fc:	0c c0       	rjmp	.+24     	; 0x5816 <plan_buffer_line+0x292>
    57fe:	7f 01       	movw	r14, r30
    5800:	62 a1       	ldd	r22, Z+34	; 0x22
    5802:	73 a1       	ldd	r23, Z+35	; 0x23
    5804:	84 a1       	ldd	r24, Z+36	; 0x24
    5806:	95 a1       	ldd	r25, Z+37	; 0x25
    5808:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    580c:	f7 01       	movw	r30, r14
    580e:	66 a7       	std	Z+46, r22	; 0x2e
    5810:	77 a7       	std	Z+47, r23	; 0x2f
    5812:	80 ab       	std	Z+48, r24	; 0x30
    5814:	91 ab       	std	Z+49, r25	; 0x31
    5816:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <block_buffer_head>
    581a:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    581e:	98 17       	cp	r25, r24
    5820:	11 f0       	breq	.+4      	; 0x5826 <plan_buffer_line+0x2a2>
    5822:	11 ff       	sbrs	r17, 1
    5824:	11 c0       	rjmp	.+34     	; 0x5848 <plan_buffer_line+0x2c4>
    5826:	86 e3       	ldi	r24, 0x36	; 54
    5828:	8a 9d       	mul	r24, r10
    582a:	f0 01       	movw	r30, r0
    582c:	8b 9d       	mul	r24, r11
    582e:	f0 0d       	add	r31, r0
    5830:	11 24       	eor	r1, r1
    5832:	e8 58       	subi	r30, 0x88	; 136
    5834:	fb 4f       	sbci	r31, 0xFB	; 251
    5836:	16 8a       	std	Z+22, r1	; 0x16
    5838:	17 8a       	std	Z+23, r1	; 0x17
    583a:	10 8e       	std	Z+24, r1	; 0x18
    583c:	11 8e       	std	Z+25, r1	; 0x19
    583e:	16 a2       	std	Z+38, r1	; 0x26
    5840:	17 a2       	std	Z+39, r1	; 0x27
    5842:	10 a6       	std	Z+40, r1	; 0x28
    5844:	11 a6       	std	Z+41, r1	; 0x29
    5846:	d6 c0       	rjmp	.+428    	; 0x59f4 <plan_buffer_line+0x470>
    5848:	04 e6       	ldi	r16, 0x64	; 100
    584a:	14 e0       	ldi	r17, 0x04	; 4
    584c:	1e 01       	movw	r2, r28
    584e:	f5 e2       	ldi	r31, 0x25	; 37
    5850:	2f 0e       	add	r2, r31
    5852:	31 1c       	adc	r3, r1
    5854:	41 01       	movw	r8, r2
    5856:	19 aa       	std	Y+49, r1	; 0x31
    5858:	1a aa       	std	Y+50, r1	; 0x32
    585a:	1b aa       	std	Y+51, r1	; 0x33
    585c:	1c aa       	std	Y+52, r1	; 0x34
    585e:	f8 01       	movw	r30, r16
    5860:	c1 90       	ld	r12, Z+
    5862:	d1 90       	ld	r13, Z+
    5864:	e1 90       	ld	r14, Z+
    5866:	f1 90       	ld	r15, Z+
    5868:	8f 01       	movw	r16, r30
    586a:	25 96       	adiw	r28, 0x05	; 5
    586c:	ee ad       	ldd	r30, Y+62	; 0x3e
    586e:	ff ad       	ldd	r31, Y+63	; 0x3f
    5870:	25 97       	sbiw	r28, 0x05	; 5
    5872:	41 90       	ld	r4, Z+
    5874:	51 90       	ld	r5, Z+
    5876:	61 90       	ld	r6, Z+
    5878:	71 90       	ld	r7, Z+
    587a:	25 96       	adiw	r28, 0x05	; 5
    587c:	ff af       	std	Y+63, r31	; 0x3f
    587e:	ee af       	std	Y+62, r30	; 0x3e
    5880:	25 97       	sbiw	r28, 0x05	; 5
    5882:	a3 01       	movw	r20, r6
    5884:	92 01       	movw	r18, r4
    5886:	c7 01       	movw	r24, r14
    5888:	b6 01       	movw	r22, r12
    588a:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    588e:	9b 01       	movw	r18, r22
    5890:	ac 01       	movw	r20, r24
    5892:	69 a9       	ldd	r22, Y+49	; 0x31
    5894:	7a a9       	ldd	r23, Y+50	; 0x32
    5896:	8b a9       	ldd	r24, Y+51	; 0x33
    5898:	9c a9       	ldd	r25, Y+52	; 0x34
    589a:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    589e:	69 ab       	std	Y+49, r22	; 0x31
    58a0:	7a ab       	std	Y+50, r23	; 0x32
    58a2:	8b ab       	std	Y+51, r24	; 0x33
    58a4:	9c ab       	std	Y+52, r25	; 0x34
    58a6:	a7 01       	movw	r20, r14
    58a8:	96 01       	movw	r18, r12
    58aa:	c3 01       	movw	r24, r6
    58ac:	b2 01       	movw	r22, r4
    58ae:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    58b2:	f1 01       	movw	r30, r2
    58b4:	61 93       	st	Z+, r22
    58b6:	71 93       	st	Z+, r23
    58b8:	81 93       	st	Z+, r24
    58ba:	91 93       	st	Z+, r25
    58bc:	1f 01       	movw	r2, r30
    58be:	25 96       	adiw	r28, 0x05	; 5
    58c0:	2e ad       	ldd	r18, Y+62	; 0x3e
    58c2:	3f ad       	ldd	r19, Y+63	; 0x3f
    58c4:	25 97       	sbiw	r28, 0x05	; 5
    58c6:	28 15       	cp	r18, r8
    58c8:	39 05       	cpc	r19, r9
    58ca:	49 f6       	brne	.-110    	; 0x585e <plan_buffer_line+0x2da>
    58cc:	2f ee       	ldi	r18, 0xEF	; 239
    58ce:	3f ef       	ldi	r19, 0xFF	; 255
    58d0:	4f e7       	ldi	r20, 0x7F	; 127
    58d2:	5f e3       	ldi	r21, 0x3F	; 63
    58d4:	69 a9       	ldd	r22, Y+49	; 0x31
    58d6:	7a a9       	ldd	r23, Y+50	; 0x32
    58d8:	8b a9       	ldd	r24, Y+51	; 0x33
    58da:	9c a9       	ldd	r25, Y+52	; 0x34
    58dc:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    58e0:	18 16       	cp	r1, r24
    58e2:	6c f4       	brge	.+26     	; 0x58fe <plan_buffer_line+0x37a>
    58e4:	86 e3       	ldi	r24, 0x36	; 54
    58e6:	8a 9d       	mul	r24, r10
    58e8:	f0 01       	movw	r30, r0
    58ea:	8b 9d       	mul	r24, r11
    58ec:	f0 0d       	add	r31, r0
    58ee:	11 24       	eor	r1, r1
    58f0:	e8 58       	subi	r30, 0x88	; 136
    58f2:	fb 4f       	sbci	r31, 0xFB	; 251
    58f4:	16 a2       	std	Z+38, r1	; 0x26
    58f6:	17 a2       	std	Z+39, r1	; 0x27
    58f8:	10 a6       	std	Z+40, r1	; 0x28
    58fa:	11 a6       	std	Z+41, r1	; 0x29
    58fc:	7b c0       	rjmp	.+246    	; 0x59f4 <plan_buffer_line+0x470>
    58fe:	2f ee       	ldi	r18, 0xEF	; 239
    5900:	3f ef       	ldi	r19, 0xFF	; 255
    5902:	4f e7       	ldi	r20, 0x7F	; 127
    5904:	5f eb       	ldi	r21, 0xBF	; 191
    5906:	69 a9       	ldd	r22, Y+49	; 0x31
    5908:	7a a9       	ldd	r23, Y+50	; 0x32
    590a:	8b a9       	ldd	r24, Y+51	; 0x33
    590c:	9c a9       	ldd	r25, Y+52	; 0x34
    590e:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    5912:	88 23       	and	r24, r24
    5914:	8c f4       	brge	.+34     	; 0x5938 <plan_buffer_line+0x3b4>
    5916:	86 e3       	ldi	r24, 0x36	; 54
    5918:	8a 9d       	mul	r24, r10
    591a:	f0 01       	movw	r30, r0
    591c:	8b 9d       	mul	r24, r11
    591e:	f0 0d       	add	r31, r0
    5920:	11 24       	eor	r1, r1
    5922:	e8 58       	subi	r30, 0x88	; 136
    5924:	fb 4f       	sbci	r31, 0xFB	; 251
    5926:	89 e9       	ldi	r24, 0x99	; 153
    5928:	96 e7       	ldi	r25, 0x76	; 118
    592a:	a6 e9       	ldi	r26, 0x96	; 150
    592c:	be e7       	ldi	r27, 0x7E	; 126
    592e:	86 a3       	std	Z+38, r24	; 0x26
    5930:	97 a3       	std	Z+39, r25	; 0x27
    5932:	a0 a7       	std	Z+40, r26	; 0x28
    5934:	b1 a7       	std	Z+41, r27	; 0x29
    5936:	5e c0       	rjmp	.+188    	; 0x59f4 <plan_buffer_line+0x470>
    5938:	ce 01       	movw	r24, r28
    593a:	85 96       	adiw	r24, 0x25	; 37
    593c:	a5 d2       	rcall	.+1354   	; 0x5e88 <convert_delta_vector_to_unit_vector>
    593e:	be 01       	movw	r22, r28
    5940:	6b 5d       	subi	r22, 0xDB	; 219
    5942:	7f 4f       	sbci	r23, 0xFF	; 255
    5944:	88 ee       	ldi	r24, 0xE8	; 232
    5946:	9e e0       	ldi	r25, 0x0E	; 14
    5948:	06 d3       	rcall	.+1548   	; 0x5f56 <limit_value_by_axis_maximum>
    594a:	6b 01       	movw	r12, r22
    594c:	7c 01       	movw	r14, r24
    594e:	29 a9       	ldd	r18, Y+49	; 0x31
    5950:	3a a9       	ldd	r19, Y+50	; 0x32
    5952:	4b a9       	ldd	r20, Y+51	; 0x33
    5954:	5c a9       	ldd	r21, Y+52	; 0x34
    5956:	60 e0       	ldi	r22, 0x00	; 0
    5958:	70 e0       	ldi	r23, 0x00	; 0
    595a:	80 e8       	ldi	r24, 0x80	; 128
    595c:	9f e3       	ldi	r25, 0x3F	; 63
    595e:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    5962:	20 e0       	ldi	r18, 0x00	; 0
    5964:	30 e0       	ldi	r19, 0x00	; 0
    5966:	40 e0       	ldi	r20, 0x00	; 0
    5968:	5f e3       	ldi	r21, 0x3F	; 63
    596a:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    596e:	0e 94 30 42 	call	0x8460	; 0x8460 <sqrt>
    5972:	2b 01       	movw	r4, r22
    5974:	3c 01       	movw	r6, r24
    5976:	20 91 05 0f 	lds	r18, 0x0F05	; 0x800f05 <settings+0x35>
    597a:	30 91 06 0f 	lds	r19, 0x0F06	; 0x800f06 <settings+0x36>
    597e:	40 91 07 0f 	lds	r20, 0x0F07	; 0x800f07 <settings+0x37>
    5982:	50 91 08 0f 	lds	r21, 0x0F08	; 0x800f08 <settings+0x38>
    5986:	c7 01       	movw	r24, r14
    5988:	b6 01       	movw	r22, r12
    598a:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    598e:	a3 01       	movw	r20, r6
    5990:	92 01       	movw	r18, r4
    5992:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    5996:	6b 01       	movw	r12, r22
    5998:	7c 01       	movw	r14, r24
    599a:	a3 01       	movw	r20, r6
    599c:	92 01       	movw	r18, r4
    599e:	60 e0       	ldi	r22, 0x00	; 0
    59a0:	70 e0       	ldi	r23, 0x00	; 0
    59a2:	80 e8       	ldi	r24, 0x80	; 128
    59a4:	9f e3       	ldi	r25, 0x3F	; 63
    59a6:	0e 94 8b 3e 	call	0x7d16	; 0x7d16 <__subsf3>
    59aa:	9b 01       	movw	r18, r22
    59ac:	ac 01       	movw	r20, r24
    59ae:	c7 01       	movw	r24, r14
    59b0:	b6 01       	movw	r22, r12
    59b2:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__divsf3>
    59b6:	e6 2e       	mov	r14, r22
    59b8:	f7 2e       	mov	r15, r23
    59ba:	08 2f       	mov	r16, r24
    59bc:	19 2f       	mov	r17, r25
    59be:	20 e0       	ldi	r18, 0x00	; 0
    59c0:	30 e0       	ldi	r19, 0x00	; 0
    59c2:	a9 01       	movw	r20, r18
    59c4:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    59c8:	88 23       	and	r24, r24
    59ca:	24 f4       	brge	.+8      	; 0x59d4 <plan_buffer_line+0x450>
    59cc:	e1 2c       	mov	r14, r1
    59ce:	f1 2c       	mov	r15, r1
    59d0:	00 e0       	ldi	r16, 0x00	; 0
    59d2:	10 e0       	ldi	r17, 0x00	; 0
    59d4:	86 e3       	ldi	r24, 0x36	; 54
    59d6:	8a 9d       	mul	r24, r10
    59d8:	f0 01       	movw	r30, r0
    59da:	8b 9d       	mul	r24, r11
    59dc:	f0 0d       	add	r31, r0
    59de:	11 24       	eor	r1, r1
    59e0:	e8 58       	subi	r30, 0x88	; 136
    59e2:	fb 4f       	sbci	r31, 0xFB	; 251
    59e4:	4e 2d       	mov	r20, r14
    59e6:	5f 2d       	mov	r21, r15
    59e8:	60 2f       	mov	r22, r16
    59ea:	71 2f       	mov	r23, r17
    59ec:	46 a3       	std	Z+38, r20	; 0x26
    59ee:	57 a3       	std	Z+39, r21	; 0x27
    59f0:	60 a7       	std	Z+40, r22	; 0x28
    59f2:	71 a7       	std	Z+41, r23	; 0x29
    59f4:	86 e3       	ldi	r24, 0x36	; 54
    59f6:	8a 9d       	mul	r24, r10
    59f8:	f0 01       	movw	r30, r0
    59fa:	8b 9d       	mul	r24, r11
    59fc:	f0 0d       	add	r31, r0
    59fe:	11 24       	eor	r1, r1
    5a00:	e8 58       	subi	r30, 0x88	; 136
    5a02:	fb 4f       	sbci	r31, 0xFB	; 251
    5a04:	81 89       	ldd	r24, Z+17	; 0x11
    5a06:	81 fd       	sbrc	r24, 1
    5a08:	87 c0       	rjmp	.+270    	; 0x5b18 <plan_buffer_line+0x594>
    5a0a:	21 96       	adiw	r28, 0x01	; 1
    5a0c:	8e ad       	ldd	r24, Y+62	; 0x3e
    5a0e:	9f ad       	ldd	r25, Y+63	; 0x3f
    5a10:	21 97       	sbiw	r28, 0x01	; 1
    5a12:	82 dc       	rcall	.-1788   	; 0x5318 <plan_compute_profile_nominal_speed>
    5a14:	6b 01       	movw	r12, r22
    5a16:	7c 01       	movw	r14, r24
    5a18:	40 90 70 04 	lds	r4, 0x0470	; 0x800470 <pl+0x18>
    5a1c:	50 90 71 04 	lds	r5, 0x0471	; 0x800471 <pl+0x19>
    5a20:	60 90 72 04 	lds	r6, 0x0472	; 0x800472 <pl+0x1a>
    5a24:	70 90 73 04 	lds	r7, 0x0473	; 0x800473 <pl+0x1b>
    5a28:	a3 01       	movw	r20, r6
    5a2a:	92 01       	movw	r18, r4
    5a2c:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    5a30:	18 16       	cp	r1, r24
    5a32:	a4 f4       	brge	.+40     	; 0x5a5c <plan_buffer_line+0x4d8>
    5a34:	86 e3       	ldi	r24, 0x36	; 54
    5a36:	8a 9d       	mul	r24, r10
    5a38:	80 01       	movw	r16, r0
    5a3a:	8b 9d       	mul	r24, r11
    5a3c:	10 0d       	add	r17, r0
    5a3e:	11 24       	eor	r1, r1
    5a40:	08 58       	subi	r16, 0x88	; 136
    5a42:	1b 4f       	sbci	r17, 0xFB	; 251
    5a44:	a3 01       	movw	r20, r6
    5a46:	92 01       	movw	r18, r4
    5a48:	c3 01       	movw	r24, r6
    5a4a:	b2 01       	movw	r22, r4
    5a4c:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    5a50:	f8 01       	movw	r30, r16
    5a52:	62 8f       	std	Z+26, r22	; 0x1a
    5a54:	73 8f       	std	Z+27, r23	; 0x1b
    5a56:	84 8f       	std	Z+28, r24	; 0x1c
    5a58:	95 8f       	std	Z+29, r25	; 0x1d
    5a5a:	13 c0       	rjmp	.+38     	; 0x5a82 <plan_buffer_line+0x4fe>
    5a5c:	86 e3       	ldi	r24, 0x36	; 54
    5a5e:	8a 9d       	mul	r24, r10
    5a60:	80 01       	movw	r16, r0
    5a62:	8b 9d       	mul	r24, r11
    5a64:	10 0d       	add	r17, r0
    5a66:	11 24       	eor	r1, r1
    5a68:	08 58       	subi	r16, 0x88	; 136
    5a6a:	1b 4f       	sbci	r17, 0xFB	; 251
    5a6c:	a7 01       	movw	r20, r14
    5a6e:	96 01       	movw	r18, r12
    5a70:	c7 01       	movw	r24, r14
    5a72:	b6 01       	movw	r22, r12
    5a74:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    5a78:	f8 01       	movw	r30, r16
    5a7a:	62 8f       	std	Z+26, r22	; 0x1a
    5a7c:	73 8f       	std	Z+27, r23	; 0x1b
    5a7e:	84 8f       	std	Z+28, r24	; 0x1c
    5a80:	95 8f       	std	Z+29, r25	; 0x1d
    5a82:	86 e3       	ldi	r24, 0x36	; 54
    5a84:	8a 9d       	mul	r24, r10
    5a86:	f0 01       	movw	r30, r0
    5a88:	8b 9d       	mul	r24, r11
    5a8a:	f0 0d       	add	r31, r0
    5a8c:	11 24       	eor	r1, r1
    5a8e:	e8 58       	subi	r30, 0x88	; 136
    5a90:	fb 4f       	sbci	r31, 0xFB	; 251
    5a92:	46 a0       	ldd	r4, Z+38	; 0x26
    5a94:	57 a0       	ldd	r5, Z+39	; 0x27
    5a96:	60 a4       	ldd	r6, Z+40	; 0x28
    5a98:	71 a4       	ldd	r7, Z+41	; 0x29
    5a9a:	a3 01       	movw	r20, r6
    5a9c:	92 01       	movw	r18, r4
    5a9e:	62 8d       	ldd	r22, Z+26	; 0x1a
    5aa0:	73 8d       	ldd	r23, Z+27	; 0x1b
    5aa2:	84 8d       	ldd	r24, Z+28	; 0x1c
    5aa4:	95 8d       	ldd	r25, Z+29	; 0x1d
    5aa6:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    5aaa:	18 16       	cp	r1, r24
    5aac:	64 f4       	brge	.+24     	; 0x5ac6 <plan_buffer_line+0x542>
    5aae:	86 e3       	ldi	r24, 0x36	; 54
    5ab0:	8a 9d       	mul	r24, r10
    5ab2:	f0 01       	movw	r30, r0
    5ab4:	8b 9d       	mul	r24, r11
    5ab6:	f0 0d       	add	r31, r0
    5ab8:	11 24       	eor	r1, r1
    5aba:	e8 58       	subi	r30, 0x88	; 136
    5abc:	fb 4f       	sbci	r31, 0xFB	; 251
    5abe:	42 8e       	std	Z+26, r4	; 0x1a
    5ac0:	53 8e       	std	Z+27, r5	; 0x1b
    5ac2:	64 8e       	std	Z+28, r6	; 0x1c
    5ac4:	75 8e       	std	Z+29, r7	; 0x1d
    5ac6:	c0 92 70 04 	sts	0x0470, r12	; 0x800470 <pl+0x18>
    5aca:	d0 92 71 04 	sts	0x0471, r13	; 0x800471 <pl+0x19>
    5ace:	e0 92 72 04 	sts	0x0472, r14	; 0x800472 <pl+0x1a>
    5ad2:	f0 92 73 04 	sts	0x0473, r15	; 0x800473 <pl+0x1b>
    5ad6:	8c e0       	ldi	r24, 0x0C	; 12
    5ad8:	fe 01       	movw	r30, r28
    5ada:	79 96       	adiw	r30, 0x19	; 25
    5adc:	a4 e6       	ldi	r26, 0x64	; 100
    5ade:	b4 e0       	ldi	r27, 0x04	; 4
    5ae0:	01 90       	ld	r0, Z+
    5ae2:	0d 92       	st	X+, r0
    5ae4:	8a 95       	dec	r24
    5ae6:	e1 f7       	brne	.-8      	; 0x5ae0 <plan_buffer_line+0x55c>
    5ae8:	8c e0       	ldi	r24, 0x0C	; 12
    5aea:	fe 01       	movw	r30, r28
    5aec:	31 96       	adiw	r30, 0x01	; 1
    5aee:	a8 e5       	ldi	r26, 0x58	; 88
    5af0:	b4 e0       	ldi	r27, 0x04	; 4
    5af2:	01 90       	ld	r0, Z+
    5af4:	0d 92       	st	X+, r0
    5af6:	8a 95       	dec	r24
    5af8:	e1 f7       	brne	.-8      	; 0x5af2 <plan_buffer_line+0x56e>
    5afa:	80 91 75 04 	lds	r24, 0x0475	; 0x800475 <next_buffer_head>
    5afe:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <block_buffer_head>
    5b02:	8f 5f       	subi	r24, 0xFF	; 255
    5b04:	84 32       	cpi	r24, 0x24	; 36
    5b06:	09 f4       	brne	.+2      	; 0x5b0a <plan_buffer_line+0x586>
    5b08:	80 e0       	ldi	r24, 0x00	; 0
    5b0a:	80 93 75 04 	sts	0x0475, r24	; 0x800475 <next_buffer_head>
    5b0e:	3d da       	rcall	.-2950   	; 0x4f8a <planner_recalculate>
    5b10:	81 e0       	ldi	r24, 0x01	; 1
    5b12:	39 c0       	rjmp	.+114    	; 0x5b86 <plan_buffer_line+0x602>
    5b14:	80 e0       	ldi	r24, 0x00	; 0
    5b16:	37 c0       	rjmp	.+110    	; 0x5b86 <plan_buffer_line+0x602>
    5b18:	81 e0       	ldi	r24, 0x01	; 1
    5b1a:	35 c0       	rjmp	.+106    	; 0x5b86 <plan_buffer_line+0x602>
    5b1c:	89 af       	std	Y+57, r24	; 0x39
    5b1e:	9a af       	std	Y+58, r25	; 0x3a
    5b20:	20 ed       	ldi	r18, 0xD0	; 208
    5b22:	3e e0       	ldi	r19, 0x0E	; 14
    5b24:	3c af       	std	Y+60, r19	; 0x3c
    5b26:	2b af       	std	Y+59, r18	; 0x3b
    5b28:	ae 01       	movw	r20, r28
    5b2a:	4f 5f       	subi	r20, 0xFF	; 255
    5b2c:	5f 4f       	sbci	r21, 0xFF	; 255
    5b2e:	4a 01       	movw	r8, r20
    5b30:	6e 01       	movw	r12, r28
    5b32:	5d e0       	ldi	r21, 0x0D	; 13
    5b34:	c5 0e       	add	r12, r21
    5b36:	d1 1c       	adc	r13, r1
    5b38:	66 e3       	ldi	r22, 0x36	; 54
    5b3a:	26 9e       	mul	r2, r22
    5b3c:	c0 01       	movw	r24, r0
    5b3e:	11 24       	eor	r1, r1
    5b40:	fc 01       	movw	r30, r24
    5b42:	e8 58       	subi	r30, 0x88	; 136
    5b44:	fb 4f       	sbci	r31, 0xFB	; 251
    5b46:	1f 01       	movw	r2, r30
    5b48:	9e 01       	movw	r18, r28
    5b4a:	27 5e       	subi	r18, 0xE7	; 231
    5b4c:	3f 4f       	sbci	r19, 0xFF	; 255
    5b4e:	25 96       	adiw	r28, 0x05	; 5
    5b50:	3f af       	std	Y+63, r19	; 0x3f
    5b52:	2e af       	std	Y+62, r18	; 0x3e
    5b54:	25 97       	sbiw	r28, 0x05	; 5
    5b56:	3e af       	std	Y+62, r19	; 0x3e
    5b58:	2d af       	std	Y+61, r18	; 0x3d
    5b5a:	10 e0       	ldi	r17, 0x00	; 0
    5b5c:	26 e3       	ldi	r18, 0x36	; 54
    5b5e:	2a 9d       	mul	r18, r10
    5b60:	c0 01       	movw	r24, r0
    5b62:	2b 9d       	mul	r18, r11
    5b64:	90 0d       	add	r25, r0
    5b66:	11 24       	eor	r1, r1
    5b68:	88 58       	subi	r24, 0x88	; 136
    5b6a:	9b 4f       	sbci	r25, 0xFB	; 251
    5b6c:	7c 01       	movw	r14, r24
    5b6e:	3c e0       	ldi	r19, 0x0C	; 12
    5b70:	e3 0e       	add	r14, r19
    5b72:	f1 1c       	adc	r15, r1
    5b74:	ac 01       	movw	r20, r24
    5b76:	40 5f       	subi	r20, 0xF0	; 240
    5b78:	5f 4f       	sbci	r21, 0xFF	; 255
    5b7a:	27 96       	adiw	r28, 0x07	; 7
    5b7c:	5f af       	std	Y+63, r21	; 0x3f
    5b7e:	4e af       	std	Y+62, r20	; 0x3e
    5b80:	27 97       	sbiw	r28, 0x07	; 7
    5b82:	19 ab       	std	Y+49, r17	; 0x31
    5b84:	70 cd       	rjmp	.-1312   	; 0x5666 <plan_buffer_line+0xe2>
    5b86:	ca 5b       	subi	r28, 0xBA	; 186
    5b88:	df 4f       	sbci	r29, 0xFF	; 255
    5b8a:	0f b6       	in	r0, 0x3f	; 63
    5b8c:	f8 94       	cli
    5b8e:	de bf       	out	0x3e, r29	; 62
    5b90:	0f be       	out	0x3f, r0	; 63
    5b92:	cd bf       	out	0x3d, r28	; 61
    5b94:	df 91       	pop	r29
    5b96:	cf 91       	pop	r28
    5b98:	1f 91       	pop	r17
    5b9a:	0f 91       	pop	r16
    5b9c:	ff 90       	pop	r15
    5b9e:	ef 90       	pop	r14
    5ba0:	df 90       	pop	r13
    5ba2:	cf 90       	pop	r12
    5ba4:	bf 90       	pop	r11
    5ba6:	af 90       	pop	r10
    5ba8:	9f 90       	pop	r9
    5baa:	8f 90       	pop	r8
    5bac:	7f 90       	pop	r7
    5bae:	6f 90       	pop	r6
    5bb0:	5f 90       	pop	r5
    5bb2:	4f 90       	pop	r4
    5bb4:	3f 90       	pop	r3
    5bb6:	2f 90       	pop	r2
    5bb8:	08 95       	ret

00005bba <plan_sync_position>:
    5bba:	e3 e4       	ldi	r30, 0x43	; 67
    5bbc:	fc e0       	ldi	r31, 0x0C	; 12
    5bbe:	a8 e5       	ldi	r26, 0x58	; 88
    5bc0:	b4 e0       	ldi	r27, 0x04	; 4
    5bc2:	8f e4       	ldi	r24, 0x4F	; 79
    5bc4:	9c e0       	ldi	r25, 0x0C	; 12
    5bc6:	41 91       	ld	r20, Z+
    5bc8:	51 91       	ld	r21, Z+
    5bca:	61 91       	ld	r22, Z+
    5bcc:	71 91       	ld	r23, Z+
    5bce:	4d 93       	st	X+, r20
    5bd0:	5d 93       	st	X+, r21
    5bd2:	6d 93       	st	X+, r22
    5bd4:	7d 93       	st	X+, r23
    5bd6:	e8 17       	cp	r30, r24
    5bd8:	f9 07       	cpc	r31, r25
    5bda:	a9 f7       	brne	.-22     	; 0x5bc6 <plan_sync_position+0xc>
    5bdc:	08 95       	ret

00005bde <plan_get_block_buffer_available>:
    5bde:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <block_buffer_head>
    5be2:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    5be6:	98 17       	cp	r25, r24
    5be8:	18 f0       	brcs	.+6      	; 0x5bf0 <plan_get_block_buffer_available+0x12>
    5bea:	8d 5d       	subi	r24, 0xDD	; 221
    5bec:	89 1b       	sub	r24, r25
    5bee:	08 95       	ret
    5bf0:	81 50       	subi	r24, 0x01	; 1
    5bf2:	89 1b       	sub	r24, r25
    5bf4:	08 95       	ret

00005bf6 <plan_cycle_reinitialize>:
// Re-initialize buffer plan with a partially completed block, assumed to exist at the buffer tail.
// Called after a steppers have come to a complete stop for a feed hold and the cycle is stopped.
void plan_cycle_reinitialize()
{
  // Re-plan from a complete stop. Reset planner entry speeds and buffer planned pointer.
  st_update_plan_block_parameters();
    5bf6:	0e 94 02 1c 	call	0x3804	; 0x3804 <st_update_plan_block_parameters>
  block_buffer_planned = block_buffer_tail;
    5bfa:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <block_buffer_tail>
    5bfe:	80 93 74 04 	sts	0x0474, r24	; 0x800474 <block_buffer_planned>
  planner_recalculate();
    5c02:	c3 c9       	rjmp	.-3194   	; 0x4f8a <planner_recalculate>
    5c04:	08 95       	ret

00005c06 <read_float>:
// Delays variable defined microseconds. Compiler compatibility fix for _delay_us(),
// which only accepts constants in future compiler releases. Written to perform more
// efficiently with larger delays, as the counter adds parasitic time in each iteration.
void delay_us(uint32_t us)
{
  while (us) {
    5c06:	4f 92       	push	r4
    5c08:	5f 92       	push	r5
    5c0a:	6f 92       	push	r6
    5c0c:	7f 92       	push	r7
    5c0e:	8f 92       	push	r8
    5c10:	9f 92       	push	r9
    5c12:	af 92       	push	r10
    5c14:	bf 92       	push	r11
    5c16:	cf 92       	push	r12
    5c18:	df 92       	push	r13
    5c1a:	ef 92       	push	r14
    5c1c:	ff 92       	push	r15
    5c1e:	0f 93       	push	r16
    5c20:	1f 93       	push	r17
    5c22:	cf 93       	push	r28
    5c24:	df 93       	push	r29
    5c26:	dc 01       	movw	r26, r24
    5c28:	fb 01       	movw	r30, r22
    5c2a:	c0 81       	ld	r28, Z
    5c2c:	d0 e0       	ldi	r29, 0x00	; 0
    5c2e:	fc 01       	movw	r30, r24
    5c30:	ec 0f       	add	r30, r28
    5c32:	fd 1f       	adc	r31, r29
    5c34:	90 81       	ld	r25, Z
    5c36:	9d 32       	cpi	r25, 0x2D	; 45
    5c38:	29 f4       	brne	.+10     	; 0x5c44 <read_float+0x3e>
    5c3a:	ef 01       	movw	r28, r30
    5c3c:	22 96       	adiw	r28, 0x02	; 2
    5c3e:	91 81       	ldd	r25, Z+1	; 0x01
    5c40:	01 e0       	ldi	r16, 0x01	; 1
    5c42:	0b c0       	rjmp	.+22     	; 0x5c5a <read_float+0x54>
    5c44:	9b 32       	cpi	r25, 0x2B	; 43
    5c46:	29 f0       	breq	.+10     	; 0x5c52 <read_float+0x4c>
    5c48:	21 96       	adiw	r28, 0x01	; 1
    5c4a:	ca 0f       	add	r28, r26
    5c4c:	db 1f       	adc	r29, r27
    5c4e:	00 e0       	ldi	r16, 0x00	; 0
    5c50:	04 c0       	rjmp	.+8      	; 0x5c5a <read_float+0x54>
    5c52:	ef 01       	movw	r28, r30
    5c54:	22 96       	adiw	r28, 0x02	; 2
    5c56:	91 81       	ldd	r25, Z+1	; 0x01
    5c58:	00 e0       	ldi	r16, 0x00	; 0
    5c5a:	80 e0       	ldi	r24, 0x00	; 0
    5c5c:	20 e0       	ldi	r18, 0x00	; 0
    5c5e:	10 e0       	ldi	r17, 0x00	; 0
    5c60:	41 2c       	mov	r4, r1
    5c62:	51 2c       	mov	r5, r1
    5c64:	32 01       	movw	r6, r4
    5c66:	31 e0       	ldi	r19, 0x01	; 1
    5c68:	fe 01       	movw	r30, r28
    5c6a:	90 53       	subi	r25, 0x30	; 48
    5c6c:	9a 30       	cpi	r25, 0x0A	; 10
    5c6e:	10 f5       	brcc	.+68     	; 0x5cb4 <read_float+0xae>
    5c70:	2f 5f       	subi	r18, 0xFF	; 255
    5c72:	29 30       	cpi	r18, 0x09	; 9
    5c74:	d8 f4       	brcc	.+54     	; 0x5cac <read_float+0xa6>
    5c76:	81 11       	cpse	r24, r1
    5c78:	11 50       	subi	r17, 0x01	; 1
    5c7a:	53 01       	movw	r10, r6
    5c7c:	42 01       	movw	r8, r4
    5c7e:	88 0c       	add	r8, r8
    5c80:	99 1c       	adc	r9, r9
    5c82:	aa 1c       	adc	r10, r10
    5c84:	bb 1c       	adc	r11, r11
    5c86:	88 0c       	add	r8, r8
    5c88:	99 1c       	adc	r9, r9
    5c8a:	aa 1c       	adc	r10, r10
    5c8c:	bb 1c       	adc	r11, r11
    5c8e:	84 0c       	add	r8, r4
    5c90:	95 1c       	adc	r9, r5
    5c92:	a6 1c       	adc	r10, r6
    5c94:	b7 1c       	adc	r11, r7
    5c96:	88 0c       	add	r8, r8
    5c98:	99 1c       	adc	r9, r9
    5c9a:	aa 1c       	adc	r10, r10
    5c9c:	bb 1c       	adc	r11, r11
    5c9e:	24 01       	movw	r4, r8
    5ca0:	35 01       	movw	r6, r10
    5ca2:	49 0e       	add	r4, r25
    5ca4:	51 1c       	adc	r5, r1
    5ca6:	61 1c       	adc	r6, r1
    5ca8:	71 1c       	adc	r7, r1
    5caa:	09 c0       	rjmp	.+18     	; 0x5cbe <read_float+0xb8>
    5cac:	81 11       	cpse	r24, r1
    5cae:	07 c0       	rjmp	.+14     	; 0x5cbe <read_float+0xb8>
    5cb0:	1f 5f       	subi	r17, 0xFF	; 255
    5cb2:	05 c0       	rjmp	.+10     	; 0x5cbe <read_float+0xb8>
    5cb4:	9e 3f       	cpi	r25, 0xFE	; 254
    5cb6:	31 f4       	brne	.+12     	; 0x5cc4 <read_float+0xbe>
    5cb8:	81 11       	cpse	r24, r1
    5cba:	04 c0       	rjmp	.+8      	; 0x5cc4 <read_float+0xbe>
    5cbc:	83 2f       	mov	r24, r19
    5cbe:	90 81       	ld	r25, Z
    5cc0:	21 96       	adiw	r28, 0x01	; 1
    5cc2:	d2 cf       	rjmp	.-92     	; 0x5c68 <read_float+0x62>
    5cc4:	22 23       	and	r18, r18
    5cc6:	09 f4       	brne	.+2      	; 0x5cca <read_float+0xc4>
    5cc8:	52 c0       	rjmp	.+164    	; 0x5d6e <read_float+0x168>
    5cca:	6a 01       	movw	r12, r20
    5ccc:	7b 01       	movw	r14, r22
    5cce:	5d 01       	movw	r10, r26
    5cd0:	c3 01       	movw	r24, r6
    5cd2:	b2 01       	movw	r22, r4
    5cd4:	0e 94 05 40 	call	0x800a	; 0x800a <__floatunsisf>
    5cd8:	2b 01       	movw	r4, r22
    5cda:	3c 01       	movw	r6, r24
    5cdc:	20 e0       	ldi	r18, 0x00	; 0
    5cde:	30 e0       	ldi	r19, 0x00	; 0
    5ce0:	a9 01       	movw	r20, r18
    5ce2:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    5ce6:	88 23       	and	r24, r24
    5ce8:	51 f1       	breq	.+84     	; 0x5d3e <read_float+0x138>
    5cea:	1f 3f       	cpi	r17, 0xFF	; 255
    5cec:	6c f4       	brge	.+26     	; 0x5d08 <read_float+0x102>
    5cee:	2a e0       	ldi	r18, 0x0A	; 10
    5cf0:	37 ed       	ldi	r19, 0xD7	; 215
    5cf2:	43 e2       	ldi	r20, 0x23	; 35
    5cf4:	5c e3       	ldi	r21, 0x3C	; 60
    5cf6:	c3 01       	movw	r24, r6
    5cf8:	b2 01       	movw	r22, r4
    5cfa:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    5cfe:	2b 01       	movw	r4, r22
    5d00:	3c 01       	movw	r6, r24
    5d02:	1e 5f       	subi	r17, 0xFE	; 254
    5d04:	1f 3f       	cpi	r17, 0xFF	; 255
    5d06:	9c f3       	brlt	.-26     	; 0x5cee <read_float+0xe8>
    5d08:	11 23       	and	r17, r17
    5d0a:	5c f4       	brge	.+22     	; 0x5d22 <read_float+0x11c>
    5d0c:	2d ec       	ldi	r18, 0xCD	; 205
    5d0e:	3c ec       	ldi	r19, 0xCC	; 204
    5d10:	4c ec       	ldi	r20, 0xCC	; 204
    5d12:	5d e3       	ldi	r21, 0x3D	; 61
    5d14:	c3 01       	movw	r24, r6
    5d16:	b2 01       	movw	r22, r4
    5d18:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    5d1c:	2b 01       	movw	r4, r22
    5d1e:	3c 01       	movw	r6, r24
    5d20:	0e c0       	rjmp	.+28     	; 0x5d3e <read_float+0x138>
    5d22:	11 16       	cp	r1, r17
    5d24:	64 f4       	brge	.+24     	; 0x5d3e <read_float+0x138>
    5d26:	20 e0       	ldi	r18, 0x00	; 0
    5d28:	30 e0       	ldi	r19, 0x00	; 0
    5d2a:	40 e2       	ldi	r20, 0x20	; 32
    5d2c:	51 e4       	ldi	r21, 0x41	; 65
    5d2e:	c3 01       	movw	r24, r6
    5d30:	b2 01       	movw	r22, r4
    5d32:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    5d36:	2b 01       	movw	r4, r22
    5d38:	3c 01       	movw	r6, r24
    5d3a:	11 50       	subi	r17, 0x01	; 1
    5d3c:	a1 f7       	brne	.-24     	; 0x5d26 <read_float+0x120>
    5d3e:	00 23       	and	r16, r16
    5d40:	51 f0       	breq	.+20     	; 0x5d56 <read_float+0x150>
    5d42:	77 fa       	bst	r7, 7
    5d44:	70 94       	com	r7
    5d46:	77 f8       	bld	r7, 7
    5d48:	70 94       	com	r7
    5d4a:	f6 01       	movw	r30, r12
    5d4c:	40 82       	st	Z, r4
    5d4e:	51 82       	std	Z+1, r5	; 0x01
    5d50:	62 82       	std	Z+2, r6	; 0x02
    5d52:	73 82       	std	Z+3, r7	; 0x03
    5d54:	05 c0       	rjmp	.+10     	; 0x5d60 <read_float+0x15a>
    5d56:	f6 01       	movw	r30, r12
    5d58:	40 82       	st	Z, r4
    5d5a:	51 82       	std	Z+1, r5	; 0x01
    5d5c:	62 82       	std	Z+2, r6	; 0x02
    5d5e:	73 82       	std	Z+3, r7	; 0x03
    5d60:	ca 19       	sub	r28, r10
    5d62:	db 09       	sbc	r29, r11
    5d64:	c1 50       	subi	r28, 0x01	; 1
    5d66:	f7 01       	movw	r30, r14
    5d68:	c0 83       	st	Z, r28
    5d6a:	81 e0       	ldi	r24, 0x01	; 1
    5d6c:	01 c0       	rjmp	.+2      	; 0x5d70 <read_float+0x16a>
    5d6e:	80 e0       	ldi	r24, 0x00	; 0
    5d70:	df 91       	pop	r29
    5d72:	cf 91       	pop	r28
    5d74:	1f 91       	pop	r17
    5d76:	0f 91       	pop	r16
    5d78:	ff 90       	pop	r15
    5d7a:	ef 90       	pop	r14
    5d7c:	df 90       	pop	r13
    5d7e:	cf 90       	pop	r12
    5d80:	bf 90       	pop	r11
    5d82:	af 90       	pop	r10
    5d84:	9f 90       	pop	r9
    5d86:	8f 90       	pop	r8
    5d88:	7f 90       	pop	r7
    5d8a:	6f 90       	pop	r6
    5d8c:	5f 90       	pop	r5
    5d8e:	4f 90       	pop	r4
    5d90:	08 95       	ret

00005d92 <delay_sec>:
    5d92:	ff 92       	push	r15
    5d94:	0f 93       	push	r16
    5d96:	1f 93       	push	r17
    5d98:	cf 93       	push	r28
    5d9a:	df 93       	push	r29
    5d9c:	f4 2e       	mov	r15, r20
    5d9e:	20 e0       	ldi	r18, 0x00	; 0
    5da0:	30 e0       	ldi	r19, 0x00	; 0
    5da2:	40 ea       	ldi	r20, 0xA0	; 160
    5da4:	51 e4       	ldi	r21, 0x41	; 65
    5da6:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    5daa:	0e 94 52 3f 	call	0x7ea4	; 0x7ea4 <ceil>
    5dae:	0e 94 d9 3f 	call	0x7fb2	; 0x7fb2 <__fixunssfsi>
    5db2:	61 15       	cp	r22, r1
    5db4:	71 05       	cpc	r23, r1
    5db6:	21 f1       	breq	.+72     	; 0x5e00 <delay_sec+0x6e>
    5db8:	20 91 1f 0c 	lds	r18, 0x0C1F	; 0x800c1f <sys+0x1>
    5dbc:	21 11       	cpse	r18, r1
    5dbe:	20 c0       	rjmp	.+64     	; 0x5e00 <delay_sec+0x6e>
    5dc0:	eb 01       	movw	r28, r22
    5dc2:	0e e1       	ldi	r16, 0x1E	; 30
    5dc4:	1c e0       	ldi	r17, 0x0C	; 12
    5dc6:	05 c0       	rjmp	.+10     	; 0x5dd2 <delay_sec+0x40>
    5dc8:	21 97       	sbiw	r28, 0x01	; 1
    5dca:	f8 01       	movw	r30, r16
    5dcc:	81 81       	ldd	r24, Z+1	; 0x01
    5dce:	81 11       	cpse	r24, r1
    5dd0:	17 c0       	rjmp	.+46     	; 0x5e00 <delay_sec+0x6e>
    5dd2:	f1 10       	cpse	r15, r1
    5dd4:	03 c0       	rjmp	.+6      	; 0x5ddc <delay_sec+0x4a>
    5dd6:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <protocol_execute_realtime>
    5dda:	06 c0       	rjmp	.+12     	; 0x5de8 <delay_sec+0x56>
    5ddc:	0e 94 10 15 	call	0x2a20	; 0x2a20 <protocol_exec_rt_system>
    5de0:	f8 01       	movw	r30, r16
    5de2:	82 81       	ldd	r24, Z+2	; 0x02
    5de4:	81 fd       	sbrc	r24, 1
    5de6:	0c c0       	rjmp	.+24     	; 0x5e00 <delay_sec+0x6e>
    5de8:	ff ef       	ldi	r31, 0xFF	; 255
    5dea:	20 e7       	ldi	r18, 0x70	; 112
    5dec:	82 e0       	ldi	r24, 0x02	; 2
    5dee:	f1 50       	subi	r31, 0x01	; 1
    5df0:	20 40       	sbci	r18, 0x00	; 0
    5df2:	80 40       	sbci	r24, 0x00	; 0
    5df4:	e1 f7       	brne	.-8      	; 0x5dee <delay_sec+0x5c>
    5df6:	00 c0       	rjmp	.+0      	; 0x5df8 <delay_sec+0x66>
    5df8:	00 00       	nop
    5dfa:	c1 30       	cpi	r28, 0x01	; 1
    5dfc:	d1 05       	cpc	r29, r1
    5dfe:	21 f7       	brne	.-56     	; 0x5dc8 <delay_sec+0x36>
    5e00:	df 91       	pop	r29
    5e02:	cf 91       	pop	r28
    5e04:	1f 91       	pop	r17
    5e06:	0f 91       	pop	r16
    5e08:	ff 90       	pop	r15
    5e0a:	08 95       	ret

00005e0c <delay_ms>:
    5e0c:	00 97       	sbiw	r24, 0x00	; 0
    5e0e:	41 f0       	breq	.+16     	; 0x5e20 <delay_ms+0x14>
    5e10:	ef e9       	ldi	r30, 0x9F	; 159
    5e12:	ff e0       	ldi	r31, 0x0F	; 15
    5e14:	31 97       	sbiw	r30, 0x01	; 1
    5e16:	f1 f7       	brne	.-4      	; 0x5e14 <delay_ms+0x8>
    5e18:	00 c0       	rjmp	.+0      	; 0x5e1a <delay_ms+0xe>
    5e1a:	00 00       	nop
    5e1c:	01 97       	sbiw	r24, 0x01	; 1
    5e1e:	c1 f7       	brne	.-16     	; 0x5e10 <delay_ms+0x4>
    5e20:	08 95       	ret

00005e22 <hypot_f>:
  }
}


// Simple hypotenuse computation function.
float hypot_f(float x, float y) { return(sqrt(x*x + y*y)); }
    5e22:	4f 92       	push	r4
    5e24:	5f 92       	push	r5
    5e26:	6f 92       	push	r6
    5e28:	7f 92       	push	r7
    5e2a:	8f 92       	push	r8
    5e2c:	9f 92       	push	r9
    5e2e:	af 92       	push	r10
    5e30:	bf 92       	push	r11
    5e32:	cf 92       	push	r12
    5e34:	df 92       	push	r13
    5e36:	ef 92       	push	r14
    5e38:	ff 92       	push	r15
    5e3a:	4b 01       	movw	r8, r22
    5e3c:	5c 01       	movw	r10, r24
    5e3e:	69 01       	movw	r12, r18
    5e40:	7a 01       	movw	r14, r20
    5e42:	a5 01       	movw	r20, r10
    5e44:	94 01       	movw	r18, r8
    5e46:	c5 01       	movw	r24, r10
    5e48:	b4 01       	movw	r22, r8
    5e4a:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    5e4e:	4b 01       	movw	r8, r22
    5e50:	5c 01       	movw	r10, r24
    5e52:	a7 01       	movw	r20, r14
    5e54:	96 01       	movw	r18, r12
    5e56:	c7 01       	movw	r24, r14
    5e58:	b6 01       	movw	r22, r12
    5e5a:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    5e5e:	9b 01       	movw	r18, r22
    5e60:	ac 01       	movw	r20, r24
    5e62:	c5 01       	movw	r24, r10
    5e64:	b4 01       	movw	r22, r8
    5e66:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    5e6a:	0e 94 30 42 	call	0x8460	; 0x8460 <sqrt>
    5e6e:	ff 90       	pop	r15
    5e70:	ef 90       	pop	r14
    5e72:	df 90       	pop	r13
    5e74:	cf 90       	pop	r12
    5e76:	bf 90       	pop	r11
    5e78:	af 90       	pop	r10
    5e7a:	9f 90       	pop	r9
    5e7c:	8f 90       	pop	r8
    5e7e:	7f 90       	pop	r7
    5e80:	6f 90       	pop	r6
    5e82:	5f 90       	pop	r5
    5e84:	4f 90       	pop	r4
    5e86:	08 95       	ret

00005e88 <convert_delta_vector_to_unit_vector>:


float convert_delta_vector_to_unit_vector(float *vector)
{
    5e88:	4f 92       	push	r4
    5e8a:	5f 92       	push	r5
    5e8c:	6f 92       	push	r6
    5e8e:	7f 92       	push	r7
    5e90:	af 92       	push	r10
    5e92:	bf 92       	push	r11
    5e94:	cf 92       	push	r12
    5e96:	df 92       	push	r13
    5e98:	ef 92       	push	r14
    5e9a:	ff 92       	push	r15
    5e9c:	0f 93       	push	r16
    5e9e:	1f 93       	push	r17
    5ea0:	cf 93       	push	r28
    5ea2:	df 93       	push	r29
    5ea4:	ec 01       	movw	r28, r24
    5ea6:	5c 01       	movw	r10, r24
    5ea8:	8c e0       	ldi	r24, 0x0C	; 12
    5eaa:	a8 0e       	add	r10, r24
    5eac:	b1 1c       	adc	r11, r1
    5eae:	8e 01       	movw	r16, r28
  uint8_t idx;
  float magnitude = 0.0;
    5eb0:	41 2c       	mov	r4, r1
    5eb2:	51 2c       	mov	r5, r1
    5eb4:	32 01       	movw	r6, r4
  for (idx=0; idx<N_AXIS; idx++) {
    if (vector[idx] != 0.0) {
    5eb6:	f8 01       	movw	r30, r16
    5eb8:	c1 90       	ld	r12, Z+
    5eba:	d1 90       	ld	r13, Z+
    5ebc:	e1 90       	ld	r14, Z+
    5ebe:	f1 90       	ld	r15, Z+
    5ec0:	8f 01       	movw	r16, r30
    5ec2:	20 e0       	ldi	r18, 0x00	; 0
    5ec4:	30 e0       	ldi	r19, 0x00	; 0
    5ec6:	a9 01       	movw	r20, r18
    5ec8:	c7 01       	movw	r24, r14
    5eca:	b6 01       	movw	r22, r12
    5ecc:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    5ed0:	88 23       	and	r24, r24
    5ed2:	71 f0       	breq	.+28     	; 0x5ef0 <convert_delta_vector_to_unit_vector+0x68>
      magnitude += vector[idx]*vector[idx];
    5ed4:	a7 01       	movw	r20, r14
    5ed6:	96 01       	movw	r18, r12
    5ed8:	c7 01       	movw	r24, r14
    5eda:	b6 01       	movw	r22, r12
    5edc:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    5ee0:	9b 01       	movw	r18, r22
    5ee2:	ac 01       	movw	r20, r24
    5ee4:	c3 01       	movw	r24, r6
    5ee6:	b2 01       	movw	r22, r4
    5ee8:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    5eec:	2b 01       	movw	r4, r22
    5eee:	3c 01       	movw	r6, r24

float convert_delta_vector_to_unit_vector(float *vector)
{
  uint8_t idx;
  float magnitude = 0.0;
  for (idx=0; idx<N_AXIS; idx++) {
    5ef0:	0a 15       	cp	r16, r10
    5ef2:	1b 05       	cpc	r17, r11
    5ef4:	01 f7       	brne	.-64     	; 0x5eb6 <convert_delta_vector_to_unit_vector+0x2e>
    if (vector[idx] != 0.0) {
      magnitude += vector[idx]*vector[idx];
    }
  }
  magnitude = sqrt(magnitude);
    5ef6:	c3 01       	movw	r24, r6
    5ef8:	b2 01       	movw	r22, r4
    5efa:	0e 94 30 42 	call	0x8460	; 0x8460 <sqrt>
    5efe:	2b 01       	movw	r4, r22
    5f00:	3c 01       	movw	r6, r24
  float inv_magnitude = 1.0/magnitude;
    5f02:	9b 01       	movw	r18, r22
    5f04:	ac 01       	movw	r20, r24
    5f06:	60 e0       	ldi	r22, 0x00	; 0
    5f08:	70 e0       	ldi	r23, 0x00	; 0
    5f0a:	80 e8       	ldi	r24, 0x80	; 128
    5f0c:	9f e3       	ldi	r25, 0x3F	; 63
    5f0e:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__divsf3>
    5f12:	6b 01       	movw	r12, r22
    5f14:	7c 01       	movw	r14, r24
  for (idx=0; idx<N_AXIS; idx++) { vector[idx] *= inv_magnitude; }
    5f16:	a7 01       	movw	r20, r14
    5f18:	96 01       	movw	r18, r12
    5f1a:	68 81       	ld	r22, Y
    5f1c:	79 81       	ldd	r23, Y+1	; 0x01
    5f1e:	8a 81       	ldd	r24, Y+2	; 0x02
    5f20:	9b 81       	ldd	r25, Y+3	; 0x03
    5f22:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    5f26:	69 93       	st	Y+, r22
    5f28:	79 93       	st	Y+, r23
    5f2a:	89 93       	st	Y+, r24
    5f2c:	99 93       	st	Y+, r25
    5f2e:	ca 15       	cp	r28, r10
    5f30:	db 05       	cpc	r29, r11
    5f32:	89 f7       	brne	.-30     	; 0x5f16 <convert_delta_vector_to_unit_vector+0x8e>
  return(magnitude);
}
    5f34:	c3 01       	movw	r24, r6
    5f36:	b2 01       	movw	r22, r4
    5f38:	df 91       	pop	r29
    5f3a:	cf 91       	pop	r28
    5f3c:	1f 91       	pop	r17
    5f3e:	0f 91       	pop	r16
    5f40:	ff 90       	pop	r15
    5f42:	ef 90       	pop	r14
    5f44:	df 90       	pop	r13
    5f46:	cf 90       	pop	r12
    5f48:	bf 90       	pop	r11
    5f4a:	af 90       	pop	r10
    5f4c:	7f 90       	pop	r7
    5f4e:	6f 90       	pop	r6
    5f50:	5f 90       	pop	r5
    5f52:	4f 90       	pop	r4
    5f54:	08 95       	ret

00005f56 <limit_value_by_axis_maximum>:


float limit_value_by_axis_maximum(float *max_value, float *unit_vec)
{
    5f56:	6f 92       	push	r6
    5f58:	7f 92       	push	r7
    5f5a:	8f 92       	push	r8
    5f5c:	9f 92       	push	r9
    5f5e:	af 92       	push	r10
    5f60:	bf 92       	push	r11
    5f62:	cf 92       	push	r12
    5f64:	df 92       	push	r13
    5f66:	ef 92       	push	r14
    5f68:	ff 92       	push	r15
    5f6a:	0f 93       	push	r16
    5f6c:	1f 93       	push	r17
    5f6e:	cf 93       	push	r28
    5f70:	df 93       	push	r29
    5f72:	eb 01       	movw	r28, r22
    5f74:	8c 01       	movw	r16, r24
    5f76:	7b 01       	movw	r14, r22
    5f78:	8c e0       	ldi	r24, 0x0C	; 12
    5f7a:	e8 0e       	add	r14, r24
    5f7c:	f1 1c       	adc	r15, r1
  uint8_t idx;
  float limit_value = SOME_LARGE_VALUE;
    5f7e:	0f 2e       	mov	r0, r31
    5f80:	f9 e9       	ldi	r31, 0x99	; 153
    5f82:	7f 2e       	mov	r7, r31
    5f84:	f0 2d       	mov	r31, r0
    5f86:	0f 2e       	mov	r0, r31
    5f88:	f6 e7       	ldi	r31, 0x76	; 118
    5f8a:	cf 2e       	mov	r12, r31
    5f8c:	f0 2d       	mov	r31, r0
    5f8e:	0f 2e       	mov	r0, r31
    5f90:	f6 e9       	ldi	r31, 0x96	; 150
    5f92:	df 2e       	mov	r13, r31
    5f94:	f0 2d       	mov	r31, r0
    5f96:	0f 2e       	mov	r0, r31
    5f98:	fe e7       	ldi	r31, 0x7E	; 126
    5f9a:	6f 2e       	mov	r6, r31
    5f9c:	f0 2d       	mov	r31, r0
  for (idx=0; idx<N_AXIS; idx++) {
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
    5f9e:	89 90       	ld	r8, Y+
    5fa0:	99 90       	ld	r9, Y+
    5fa2:	a9 90       	ld	r10, Y+
    5fa4:	b9 90       	ld	r11, Y+
    5fa6:	20 e0       	ldi	r18, 0x00	; 0
    5fa8:	30 e0       	ldi	r19, 0x00	; 0
    5faa:	a9 01       	movw	r20, r18
    5fac:	c5 01       	movw	r24, r10
    5fae:	b4 01       	movw	r22, r8
    5fb0:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    5fb4:	88 23       	and	r24, r24
    5fb6:	d9 f0       	breq	.+54     	; 0x5fee <limit_value_by_axis_maximum+0x98>
      limit_value = min(limit_value,fabs(max_value[idx]/unit_vec[idx]));
    5fb8:	a5 01       	movw	r20, r10
    5fba:	94 01       	movw	r18, r8
    5fbc:	f8 01       	movw	r30, r16
    5fbe:	60 81       	ld	r22, Z
    5fc0:	71 81       	ldd	r23, Z+1	; 0x01
    5fc2:	82 81       	ldd	r24, Z+2	; 0x02
    5fc4:	93 81       	ldd	r25, Z+3	; 0x03
    5fc6:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__divsf3>
    5fca:	4b 01       	movw	r8, r22
    5fcc:	5c 01       	movw	r10, r24
    5fce:	e8 94       	clt
    5fd0:	b7 f8       	bld	r11, 7
    5fd2:	27 2d       	mov	r18, r7
    5fd4:	3c 2d       	mov	r19, r12
    5fd6:	4d 2d       	mov	r20, r13
    5fd8:	56 2d       	mov	r21, r6
    5fda:	c5 01       	movw	r24, r10
    5fdc:	b4 01       	movw	r22, r8
    5fde:	0e 94 68 41 	call	0x82d0	; 0x82d0 <__gesf2>
    5fe2:	18 16       	cp	r1, r24
    5fe4:	24 f0       	brlt	.+8      	; 0x5fee <limit_value_by_axis_maximum+0x98>
    5fe6:	78 2c       	mov	r7, r8
    5fe8:	c9 2c       	mov	r12, r9
    5fea:	da 2c       	mov	r13, r10
    5fec:	6b 2c       	mov	r6, r11
    5fee:	0c 5f       	subi	r16, 0xFC	; 252
    5ff0:	1f 4f       	sbci	r17, 0xFF	; 255

float limit_value_by_axis_maximum(float *max_value, float *unit_vec)
{
  uint8_t idx;
  float limit_value = SOME_LARGE_VALUE;
  for (idx=0; idx<N_AXIS; idx++) {
    5ff2:	ce 15       	cp	r28, r14
    5ff4:	df 05       	cpc	r29, r15
    5ff6:	99 f6       	brne	.-90     	; 0x5f9e <limit_value_by_axis_maximum+0x48>
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
      limit_value = min(limit_value,fabs(max_value[idx]/unit_vec[idx]));
    }
  }
  return(limit_value);
}
    5ff8:	67 2d       	mov	r22, r7
    5ffa:	7c 2d       	mov	r23, r12
    5ffc:	8d 2d       	mov	r24, r13
    5ffe:	96 2d       	mov	r25, r6
    6000:	df 91       	pop	r29
    6002:	cf 91       	pop	r28
    6004:	1f 91       	pop	r17
    6006:	0f 91       	pop	r16
    6008:	ff 90       	pop	r15
    600a:	ef 90       	pop	r14
    600c:	df 90       	pop	r13
    600e:	cf 90       	pop	r12
    6010:	bf 90       	pop	r11
    6012:	af 90       	pop	r10
    6014:	9f 90       	pop	r9
    6016:	8f 90       	pop	r8
    6018:	7f 90       	pop	r7
    601a:	6f 90       	pop	r6
    601c:	08 95       	ret

0000601e <limits_disable>:
    #ifndef DISABLE_HW_LIMITS
     LIMIT_PCMSK &= ~LIMIT_MASK;  // Disable specific pins of the Pin Change Interrupt
     PCICR &= ~(1 << LIMIT_INT);  // Disable Pin Change Interrupt
    #endif
  #else
    LIMIT_PCMSK &= ~LIMIT_MASK;  // Disable specific pins of the Pin Change Interrupt
    601e:	eb e6       	ldi	r30, 0x6B	; 107
    6020:	f0 e0       	ldi	r31, 0x00	; 0
    6022:	80 81       	ld	r24, Z
    6024:	8f 78       	andi	r24, 0x8F	; 143
    6026:	80 83       	st	Z, r24
    PCICR &= ~(1 << LIMIT_INT);  // Disable Pin Change Interrupt
    6028:	e8 e6       	ldi	r30, 0x68	; 104
    602a:	f0 e0       	ldi	r31, 0x00	; 0
    602c:	80 81       	ld	r24, Z
    602e:	8e 7f       	andi	r24, 0xFE	; 254
    6030:	80 83       	st	Z, r24
    6032:	08 95       	ret

00006034 <limits_init>:
        WDTCSR |= (1<<WDCE) | (1<<WDE);
        WDTCSR = (1<<WDP0); // Set time-out at ~32msec.
      #endif
    #endif // DISABLE_HW_LIMITS
  #else
    LIMIT_DDR &= ~(LIMIT_MASK); // Set as input pins
    6034:	84 b1       	in	r24, 0x04	; 4
    6036:	8f 78       	andi	r24, 0x8F	; 143
    6038:	84 b9       	out	0x04, r24	; 4

    #ifdef DISABLE_LIMIT_PIN_PULL_UP
      LIMIT_PORT &= ~(LIMIT_MASK); // Normal low operation. Requires external pull-down.
    #else
      LIMIT_PORT |= (LIMIT_MASK);  // Enable internal pull-up resistors. Normal high operation.
    603a:	85 b1       	in	r24, 0x05	; 5
    603c:	80 67       	ori	r24, 0x70	; 112
    603e:	85 b9       	out	0x05, r24	; 5
    #endif

    if (bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE)) {
    6040:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    6044:	83 ff       	sbrs	r24, 3
    6046:	0b c0       	rjmp	.+22     	; 0x605e <limits_init+0x2a>
      LIMIT_PCMSK |= LIMIT_MASK; // Enable specific pins of the Pin Change Interrupt
    6048:	eb e6       	ldi	r30, 0x6B	; 107
    604a:	f0 e0       	ldi	r31, 0x00	; 0
    604c:	80 81       	ld	r24, Z
    604e:	80 67       	ori	r24, 0x70	; 112
    6050:	80 83       	st	Z, r24
      PCICR |= (1 << LIMIT_INT); // Enable Pin Change Interrupt
    6052:	e8 e6       	ldi	r30, 0x68	; 104
    6054:	f0 e0       	ldi	r31, 0x00	; 0
    6056:	80 81       	ld	r24, Z
    6058:	81 60       	ori	r24, 0x01	; 1
    605a:	80 83       	st	Z, r24
    605c:	01 c0       	rjmp	.+2      	; 0x6060 <limits_init+0x2c>
    } else {
      limits_disable();
    605e:	df df       	rcall	.-66     	; 0x601e <limits_disable>
    }
  
    #ifdef ENABLE_SOFTWARE_DEBOUNCE
      MCUSR &= ~(1<<WDRF);
    6060:	84 b7       	in	r24, 0x34	; 52
    6062:	87 7f       	andi	r24, 0xF7	; 247
    6064:	84 bf       	out	0x34, r24	; 52
      WDTCSR |= (1<<WDCE) | (1<<WDE);
    6066:	e0 e6       	ldi	r30, 0x60	; 96
    6068:	f0 e0       	ldi	r31, 0x00	; 0
    606a:	80 81       	ld	r24, Z
    606c:	88 61       	ori	r24, 0x18	; 24
    606e:	80 83       	st	Z, r24
      WDTCSR = (1<<WDP0); // Set time-out at ~32msec.
    6070:	81 e0       	ldi	r24, 0x01	; 1
    6072:	80 83       	st	Z, r24
    6074:	08 95       	ret

00006076 <limits_get_state>:

// Returns limit state as a bit-wise uint8 variable. Each bit indicates an axis limit, where 
// triggered is 1 and not triggered is 0. Invert mask is applied. Axes are defined by their
// number in bit position, i.e. Z_AXIS is (1<<2) or bit 2, and Y_AXIS is (1<<1) or bit 1.
uint8_t limits_get_state()
{
    6076:	ef 92       	push	r14
    6078:	ff 92       	push	r15
    607a:	0f 93       	push	r16
    607c:	1f 93       	push	r17
    607e:	cf 93       	push	r28
    6080:	df 93       	push	r29
      if (pin)
        limit_state |= (1 << idx);
    } 
    //return(limit_state);
  #else
    uint8_t pin = (LIMIT_PIN & LIMIT_MASK);
    6082:	c3 b1       	in	r28, 0x03	; 3
    6084:	c0 77       	andi	r28, 0x70	; 112
    #ifdef INVERT_LIMIT_PIN_MASK
      pin ^= INVERT_LIMIT_PIN_MASK;
    #endif
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
    6086:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    608a:	86 fd       	sbrc	r24, 6
    608c:	2b c0       	rjmp	.+86     	; 0x60e4 <limits_get_state+0x6e>
    608e:	80 e7       	ldi	r24, 0x70	; 112
    6090:	c8 27       	eor	r28, r24
    6092:	28 c0       	rjmp	.+80     	; 0x60e4 <limits_get_state+0x6e>
    if (pin) {  
    6094:	00 e0       	ldi	r16, 0x00	; 0
    6096:	10 e0       	ldi	r17, 0x00	; 0
    6098:	d0 e0       	ldi	r29, 0x00	; 0
      uint8_t idx;
      for (idx=0; idx<N_AXIS; idx++) {
        if (pin & get_limit_pin_mask(idx)) { limit_state |= (1 << idx); }
    609a:	ee 24       	eor	r14, r14
    609c:	e3 94       	inc	r14
    609e:	f1 2c       	mov	r15, r1
    60a0:	80 2f       	mov	r24, r16
    60a2:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <get_limit_pin_mask>
    60a6:	8c 23       	and	r24, r28
    60a8:	41 f0       	breq	.+16     	; 0x60ba <limits_get_state+0x44>
    60aa:	c7 01       	movw	r24, r14
    60ac:	00 2e       	mov	r0, r16
    60ae:	02 c0       	rjmp	.+4      	; 0x60b4 <limits_get_state+0x3e>
    60b0:	88 0f       	add	r24, r24
    60b2:	99 1f       	adc	r25, r25
    60b4:	0a 94       	dec	r0
    60b6:	e2 f7       	brpl	.-8      	; 0x60b0 <limits_get_state+0x3a>
    60b8:	d8 2b       	or	r29, r24
    60ba:	0f 5f       	subi	r16, 0xFF	; 255
    60bc:	1f 4f       	sbci	r17, 0xFF	; 255
      pin ^= INVERT_LIMIT_PIN_MASK;
    #endif
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
    if (pin) {  
      uint8_t idx;
      for (idx=0; idx<N_AXIS; idx++) {
    60be:	03 30       	cpi	r16, 0x03	; 3
    60c0:	11 05       	cpc	r17, r1
    60c2:	71 f7       	brne	.-36     	; 0x60a0 <limits_get_state+0x2a>
    }
    //return(limit_state);
  #endif //DEFAULTS_RAMPS_BOARD
//Ignore Hardware Limit triggers on the Y-Axis (Spindle Index Pulse) when LATHE is defined and not Homing, signal index pulse received when not homing
  #ifdef LATHE
	if (sys.state!=STATE_HOMING) {						//when not homing
    60c4:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    60c8:	84 30       	cpi	r24, 0x04	; 4
    60ca:	81 f0       	breq	.+32     	; 0x60ec <limits_get_state+0x76>
	  limit_state &= ~(1<<Y_AXIS);						//Clear state to avoid limit triggered alarm
    60cc:	dd 7f       	andi	r29, 0xFD	; 253
      if (pin & get_limit_pin_mask(Y_AXIS))				//If the limit input is set
    60ce:	81 e0       	ldi	r24, 0x01	; 1
    60d0:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <get_limit_pin_mask>
    60d4:	8c 23       	and	r24, r28
    60d6:	51 f0       	breq	.+20     	; 0x60ec <limits_get_state+0x76>
	    bit_true(sys_sync_state, EXEC_SPINDLE_INDEX);	//Signal the receive of a spindle index pulse
    60d8:	80 91 14 0c 	lds	r24, 0x0C14	; 0x800c14 <sys_sync_state>
    60dc:	81 60       	ori	r24, 0x01	; 1
    60de:	80 93 14 0c 	sts	0x0C14, r24	; 0x800c14 <sys_sync_state>
	}
  #endif
  return(limit_state);
    60e2:	04 c0       	rjmp	.+8      	; 0x60ec <limits_get_state+0x76>
    uint8_t pin = (LIMIT_PIN & LIMIT_MASK);
    #ifdef INVERT_LIMIT_PIN_MASK
      pin ^= INVERT_LIMIT_PIN_MASK;
    #endif
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
    if (pin) {  
    60e4:	c1 11       	cpse	r28, r1
    60e6:	d6 cf       	rjmp	.-84     	; 0x6094 <limits_get_state+0x1e>
// Returns limit state as a bit-wise uint8 variable. Each bit indicates an axis limit, where 
// triggered is 1 and not triggered is 0. Invert mask is applied. Axes are defined by their
// number in bit position, i.e. Z_AXIS is (1<<2) or bit 2, and Y_AXIS is (1<<1) or bit 1.
uint8_t limits_get_state()
{
  uint8_t limit_state = 0;
    60e8:	d0 e0       	ldi	r29, 0x00	; 0
    60ea:	ec cf       	rjmp	.-40     	; 0x60c4 <limits_get_state+0x4e>
      if (pin & get_limit_pin_mask(Y_AXIS))				//If the limit input is set
	    bit_true(sys_sync_state, EXEC_SPINDLE_INDEX);	//Signal the receive of a spindle index pulse
	}
  #endif
  return(limit_state);
}
    60ec:	8d 2f       	mov	r24, r29
    60ee:	df 91       	pop	r29
    60f0:	cf 91       	pop	r28
    60f2:	1f 91       	pop	r17
    60f4:	0f 91       	pop	r16
    60f6:	ff 90       	pop	r15
    60f8:	ef 90       	pop	r14
    60fa:	08 95       	ret

000060fc <__vector_9>:
        }
      }
    }  
  #else // OPTIONAL: Software debounce limit pin routine.
    // Upon limit pin change, enable watchdog timer to create a short delay. 
    ISR(LIMIT_INT_vect) { if (!(WDTCSR & (1<<WDIE))) { WDTCSR |= (1<<WDIE); } }
    60fc:	1f 92       	push	r1
    60fe:	0f 92       	push	r0
    6100:	0f b6       	in	r0, 0x3f	; 63
    6102:	0f 92       	push	r0
    6104:	11 24       	eor	r1, r1
    6106:	0b b6       	in	r0, 0x3b	; 59
    6108:	0f 92       	push	r0
    610a:	8f 93       	push	r24
    610c:	ef 93       	push	r30
    610e:	ff 93       	push	r31
    6110:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    6114:	86 fd       	sbrc	r24, 6
    6116:	05 c0       	rjmp	.+10     	; 0x6122 <__vector_9+0x26>
    6118:	e0 e6       	ldi	r30, 0x60	; 96
    611a:	f0 e0       	ldi	r31, 0x00	; 0
    611c:	80 81       	ld	r24, Z
    611e:	80 64       	ori	r24, 0x40	; 64
    6120:	80 83       	st	Z, r24
    6122:	ff 91       	pop	r31
    6124:	ef 91       	pop	r30
    6126:	8f 91       	pop	r24
    6128:	0f 90       	pop	r0
    612a:	0b be       	out	0x3b, r0	; 59
    612c:	0f 90       	pop	r0
    612e:	0f be       	out	0x3f, r0	; 63
    6130:	0f 90       	pop	r0
    6132:	1f 90       	pop	r1
    6134:	18 95       	reti

00006136 <__vector_12>:
    ISR(WDT_vect) // Watchdog timer ISR
    {
    6136:	1f 92       	push	r1
    6138:	0f 92       	push	r0
    613a:	0f b6       	in	r0, 0x3f	; 63
    613c:	0f 92       	push	r0
    613e:	11 24       	eor	r1, r1
    6140:	0b b6       	in	r0, 0x3b	; 59
    6142:	0f 92       	push	r0
    6144:	2f 93       	push	r18
    6146:	3f 93       	push	r19
    6148:	4f 93       	push	r20
    614a:	5f 93       	push	r21
    614c:	6f 93       	push	r22
    614e:	7f 93       	push	r23
    6150:	8f 93       	push	r24
    6152:	9f 93       	push	r25
    6154:	af 93       	push	r26
    6156:	bf 93       	push	r27
    6158:	ef 93       	push	r30
    615a:	ff 93       	push	r31
      WDTCSR &= ~(1<<WDIE); // Disable watchdog timer. 
    615c:	e0 e6       	ldi	r30, 0x60	; 96
    615e:	f0 e0       	ldi	r31, 0x00	; 0
    6160:	80 81       	ld	r24, Z
    6162:	8f 7b       	andi	r24, 0xBF	; 191
    6164:	80 83       	st	Z, r24
      if (sys.state != STATE_ALARM) {  // Ignore if already in alarm state. 
    6166:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    616a:	81 30       	cpi	r24, 0x01	; 1
    616c:	61 f0       	breq	.+24     	; 0x6186 <__vector_12+0x50>
        if (!(sys_rt_exec_alarm)) {
    616e:	80 91 53 0c 	lds	r24, 0x0C53	; 0x800c53 <sys_rt_exec_alarm>
    6172:	81 11       	cpse	r24, r1
    6174:	08 c0       	rjmp	.+16     	; 0x6186 <__vector_12+0x50>
          // Check limit pin state. 
          if (limits_get_state()) {
    6176:	7f df       	rcall	.-258    	; 0x6076 <limits_get_state>
    6178:	88 23       	and	r24, r24
    617a:	29 f0       	breq	.+10     	; 0x6186 <__vector_12+0x50>
            mc_reset(); // Initiate system kill.
    617c:	0e 94 2a 07 	call	0xe54	; 0xe54 <mc_reset>
            system_set_exec_alarm(EXEC_ALARM_HARD_LIMIT); // Indicate hard limit critical event
    6180:	81 e0       	ldi	r24, 0x01	; 1
    6182:	0e 94 fd 3d 	call	0x7bfa	; 0x7bfa <system_set_exec_alarm>
          }
        }  
      }
    }
    6186:	ff 91       	pop	r31
    6188:	ef 91       	pop	r30
    618a:	bf 91       	pop	r27
    618c:	af 91       	pop	r26
    618e:	9f 91       	pop	r25
    6190:	8f 91       	pop	r24
    6192:	7f 91       	pop	r23
    6194:	6f 91       	pop	r22
    6196:	5f 91       	pop	r21
    6198:	4f 91       	pop	r20
    619a:	3f 91       	pop	r19
    619c:	2f 91       	pop	r18
    619e:	0f 90       	pop	r0
    61a0:	0b be       	out	0x3b, r0	; 59
    61a2:	0f 90       	pop	r0
    61a4:	0f be       	out	0x3f, r0	; 63
    61a6:	0f 90       	pop	r0
    61a8:	1f 90       	pop	r1
    61aa:	18 95       	reti

000061ac <limits_go_home>:
// mask, which prevents the stepper algorithm from executing step pulses. Homing motions typically
// circumvent the processes for executing motions in normal operation.
// NOTE: Only the abort realtime command can interrupt this process.
// TODO: Move limit pin-specific calls to a general function for portability.
void limits_go_home(uint8_t cycle_mask)
{
    61ac:	2f 92       	push	r2
    61ae:	3f 92       	push	r3
    61b0:	4f 92       	push	r4
    61b2:	5f 92       	push	r5
    61b4:	6f 92       	push	r6
    61b6:	7f 92       	push	r7
    61b8:	8f 92       	push	r8
    61ba:	9f 92       	push	r9
    61bc:	af 92       	push	r10
    61be:	bf 92       	push	r11
    61c0:	cf 92       	push	r12
    61c2:	df 92       	push	r13
    61c4:	ef 92       	push	r14
    61c6:	ff 92       	push	r15
    61c8:	0f 93       	push	r16
    61ca:	1f 93       	push	r17
    61cc:	cf 93       	push	r28
    61ce:	df 93       	push	r29
    61d0:	cd b7       	in	r28, 0x3d	; 61
    61d2:	de b7       	in	r29, 0x3e	; 62
    61d4:	a9 97       	sbiw	r28, 0x29	; 41
    61d6:	0f b6       	in	r0, 0x3f	; 63
    61d8:	f8 94       	cli
    61da:	de bf       	out	0x3e, r29	; 62
    61dc:	0f be       	out	0x3f, r0	; 63
    61de:	cd bf       	out	0x3d, r28	; 61
  if (sys.abort) { return; } // Block if system reset has been issued.
    61e0:	90 91 1f 0c 	lds	r25, 0x0C1F	; 0x800c1f <sys+0x1>
    61e4:	91 11       	cpse	r25, r1
    61e6:	e1 c1       	rjmp	.+962    	; 0x65aa <limits_go_home+0x3fe>
    61e8:	8f a3       	std	Y+39, r24	; 0x27

  // Initialize plan data struct for homing motion. Spindle and coolant are disabled.
  plan_line_data_t plan_data;
  plan_line_data_t *pl_data = &plan_data;
  memset(pl_data,0,sizeof(plan_line_data_t));
    61ea:	fe 01       	movw	r30, r28
    61ec:	31 96       	adiw	r30, 0x01	; 1
    61ee:	8d e0       	ldi	r24, 0x0D	; 13
    61f0:	df 01       	movw	r26, r30
    61f2:	1d 92       	st	X+, r1
    61f4:	8a 95       	dec	r24
    61f6:	e9 f7       	brne	.-6      	; 0x61f2 <limits_go_home+0x46>
  pl_data->condition = (PL_COND_FLAG_SYSTEM_MOTION|PL_COND_FLAG_NO_FEED_OVERRIDE);
    61f8:	86 e0       	ldi	r24, 0x06	; 6
    61fa:	8d 87       	std	Y+13, r24	; 0x0d
    61fc:	e0 ed       	ldi	r30, 0xD0	; 208
    61fe:	fe e0       	ldi	r31, 0x0E	; 14
    6200:	fc a3       	std	Y+36, r31	; 0x24
    6202:	eb a3       	std	Y+35, r30	; 0x23
    6204:	7f 01       	movw	r14, r30
    6206:	9e 01       	movw	r18, r28
    6208:	22 5f       	subi	r18, 0xF2	; 242
    620a:	3f 4f       	sbci	r19, 0xFF	; 255
    620c:	59 01       	movw	r10, r18
    620e:	00 e0       	ldi	r16, 0x00	; 0
    6210:	10 e0       	ldi	r17, 0x00	; 0

  // Initialize variables used for homing computations.
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  uint8_t step_pin[N_AXIS];
  float target[N_AXIS];
  float max_travel = 0.0;
    6212:	41 2c       	mov	r4, r1
    6214:	51 2c       	mov	r5, r1
    6216:	32 01       	movw	r6, r4
    step_pin[idx] = get_step_pin_mask(idx);
    #ifdef COREXY
      if ((idx==A_MOTOR)||(idx==B_MOTOR)) { step_pin[idx] = (get_step_pin_mask(X_AXIS)|get_step_pin_mask(Y_AXIS)); }
    #endif

    if (bit_istrue(cycle_mask,bit(idx))) {
    6218:	3f a1       	ldd	r19, Y+39	; 0x27
    621a:	c3 2e       	mov	r12, r19
    621c:	d1 2c       	mov	r13, r1
  float target[N_AXIS];
  float max_travel = 0.0;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    // Initialize step pin masks
    step_pin[idx] = get_step_pin_mask(idx);
    621e:	80 2f       	mov	r24, r16
    6220:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <get_step_pin_mask>
    6224:	d5 01       	movw	r26, r10
    6226:	8d 93       	st	X+, r24
    6228:	5d 01       	movw	r10, r26
    #ifdef COREXY
      if ((idx==A_MOTOR)||(idx==B_MOTOR)) { step_pin[idx] = (get_step_pin_mask(X_AXIS)|get_step_pin_mask(Y_AXIS)); }
    #endif

    if (bit_istrue(cycle_mask,bit(idx))) {
    622a:	de 8e       	std	Y+30, r13	; 0x1e
    622c:	cd 8e       	std	Y+29, r12	; 0x1d
    622e:	c6 01       	movw	r24, r12
    6230:	00 2e       	mov	r0, r16
    6232:	02 c0       	rjmp	.+4      	; 0x6238 <limits_go_home+0x8c>
    6234:	95 95       	asr	r25
    6236:	87 95       	ror	r24
    6238:	0a 94       	dec	r0
    623a:	e2 f7       	brpl	.-8      	; 0x6234 <limits_go_home+0x88>
    623c:	80 ff       	sbrs	r24, 0
    623e:	19 c0       	rjmp	.+50     	; 0x6272 <limits_go_home+0xc6>
      // Set target based on max_travel setting. Ensure homing switches engaged with search scalar.
      // NOTE: settings.max_travel[] is stored as a negative value.
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    6240:	20 e0       	ldi	r18, 0x00	; 0
    6242:	30 e0       	ldi	r19, 0x00	; 0
    6244:	40 ec       	ldi	r20, 0xC0	; 192
    6246:	5f eb       	ldi	r21, 0xBF	; 191
    6248:	f7 01       	movw	r30, r14
    624a:	64 a1       	ldd	r22, Z+36	; 0x24
    624c:	75 a1       	ldd	r23, Z+37	; 0x25
    624e:	86 a1       	ldd	r24, Z+38	; 0x26
    6250:	97 a1       	ldd	r25, Z+39	; 0x27
    6252:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    6256:	86 2e       	mov	r8, r22
    6258:	97 2e       	mov	r9, r23
    625a:	28 2e       	mov	r2, r24
    625c:	39 2e       	mov	r3, r25
    625e:	a3 01       	movw	r20, r6
    6260:	92 01       	movw	r18, r4
    6262:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    6266:	88 23       	and	r24, r24
    6268:	24 f0       	brlt	.+8      	; 0x6272 <limits_go_home+0xc6>
    626a:	48 2c       	mov	r4, r8
    626c:	59 2c       	mov	r5, r9
    626e:	62 2c       	mov	r6, r2
    6270:	73 2c       	mov	r7, r3
    6272:	0f 5f       	subi	r16, 0xFF	; 255
    6274:	1f 4f       	sbci	r17, 0xFF	; 255
    6276:	f4 e0       	ldi	r31, 0x04	; 4
    6278:	ef 0e       	add	r14, r31
    627a:	f1 1c       	adc	r15, r1
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  uint8_t step_pin[N_AXIS];
  float target[N_AXIS];
  float max_travel = 0.0;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    627c:	03 30       	cpi	r16, 0x03	; 3
    627e:	11 05       	cpc	r17, r1
    6280:	71 f6       	brne	.-100    	; 0x621e <limits_go_home+0x72>
    6282:	2d 8c       	ldd	r2, Y+29	; 0x1d
    6284:	3e 8c       	ldd	r3, Y+30	; 0x1e
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    }
  }
  // Set search mode with approach at seek rate to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
  float homing_rate = settings.homing_seek_rate;
    6286:	80 91 1b 0f 	lds	r24, 0x0F1B	; 0x800f1b <settings+0x4b>
    628a:	90 91 1c 0f 	lds	r25, 0x0F1C	; 0x800f1c <settings+0x4c>
    628e:	a0 91 1d 0f 	lds	r26, 0x0F1D	; 0x800f1d <settings+0x4d>
    6292:	b0 91 1e 0f 	lds	r27, 0x0F1E	; 0x800f1e <settings+0x4e>
    6296:	8f 8f       	std	Y+31, r24	; 0x1f
    6298:	98 a3       	std	Y+32, r25	; 0x20
    629a:	a9 a3       	std	Y+33, r26	; 0x21
    629c:	ba a3       	std	Y+34, r27	; 0x22
    629e:	94 e0       	ldi	r25, 0x04	; 4
    62a0:	9d 8f       	std	Y+29, r25	; 0x1d
      // NOTE: settings.max_travel[] is stored as a negative value.
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    }
  }
  // Set search mode with approach at seek rate to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
    62a2:	01 e0       	ldi	r16, 0x01	; 1
          axislock |= step_pin[idx];
        }

      }
      homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
      sys.homing_axis_lock = axislock;
    62a4:	0f 2e       	mov	r0, r31
    62a6:	fe e1       	ldi	r31, 0x1E	; 30
    62a8:	cf 2e       	mov	r12, r31
    62aa:	fc e0       	ldi	r31, 0x0C	; 12
    62ac:	df 2e       	mov	r13, r31
    62ae:	f0 2d       	mov	r31, r0
    } while (n_cycle-- > 0);
  #else
    uint8_t limit_state, axislock, n_active_axis;
    do {

      system_convert_array_steps_to_mpos(target,sys_position);
    62b0:	63 e4       	ldi	r22, 0x43	; 67
    62b2:	7c e0       	ldi	r23, 0x0C	; 12
    62b4:	ce 01       	movw	r24, r28
    62b6:	41 96       	adiw	r24, 0x11	; 17
    62b8:	0e 94 16 3b 	call	0x762c	; 0x762c <system_convert_array_steps_to_mpos>
          #else
            sys_position[idx] = 0;
          #endif
          // Set target direction based on cycle mask and homing cycle approach state.
          // NOTE: This happens to compile smaller than any other implementation tried.
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
    62bc:	a6 e1       	ldi	r26, 0x16	; 22
    62be:	bf e0       	ldi	r27, 0x0F	; 15
    62c0:	ec 90       	ld	r14, X
    62c2:	f1 2c       	mov	r15, r1
    62c4:	ae 01       	movw	r20, r28
    62c6:	4f 5e       	subi	r20, 0xEF	; 239
    62c8:	5f 4f       	sbci	r21, 0xFF	; 255
    62ca:	e3 e4       	ldi	r30, 0x43	; 67
    62cc:	fc e0       	ldi	r31, 0x0C	; 12
    62ce:	fe a3       	std	Y+38, r31	; 0x26
    62d0:	ed a3       	std	Y+37, r30	; 0x25
    62d2:	de 01       	movw	r26, r28
    62d4:	1e 96       	adiw	r26, 0x0e	; 14
    62d6:	80 e0       	ldi	r24, 0x00	; 0
    62d8:	90 e0       	ldi	r25, 0x00	; 0

      system_convert_array_steps_to_mpos(target,sys_position);

      // Initialize and declare variables needed for homing routine.
      axislock = 0;
      n_active_axis = 0;
    62da:	60 e0       	ldi	r22, 0x00	; 0
    do {

      system_convert_array_steps_to_mpos(target,sys_position);

      // Initialize and declare variables needed for homing routine.
      axislock = 0;
    62dc:	10 e0       	ldi	r17, 0x00	; 0
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
            if (approach) { target[idx] = -max_travel; }
            else { target[idx] = max_travel; }
          } else {
            if (approach) { target[idx] = max_travel; }
            else { target[idx] = -max_travel; }
    62de:	53 01       	movw	r10, r6
    62e0:	42 01       	movw	r8, r4
    62e2:	b7 fa       	bst	r11, 7
    62e4:	b0 94       	com	r11
    62e6:	b7 f8       	bld	r11, 7
    62e8:	b0 94       	com	r11
    62ea:	b9 a7       	std	Y+41, r27	; 0x29
    62ec:	a8 a7       	std	Y+40, r26	; 0x28
      // Initialize and declare variables needed for homing routine.
      axislock = 0;
      n_active_axis = 0;
      for (idx=0; idx<N_AXIS; idx++) {
        // Set target location for active axes and setup computation for homing rate.
        if (bit_istrue(cycle_mask,bit(idx))) {
    62ee:	91 01       	movw	r18, r2
    62f0:	08 2e       	mov	r0, r24
    62f2:	02 c0       	rjmp	.+4      	; 0x62f8 <limits_go_home+0x14c>
    62f4:	35 95       	asr	r19
    62f6:	27 95       	ror	r18
    62f8:	0a 94       	dec	r0
    62fa:	e2 f7       	brpl	.-8      	; 0x62f4 <limits_go_home+0x148>
    62fc:	20 ff       	sbrs	r18, 0
    62fe:	31 c0       	rjmp	.+98     	; 0x6362 <limits_go_home+0x1b6>
          n_active_axis++;
    6300:	6f 5f       	subi	r22, 0xFF	; 255
              sys_position[A_MOTOR] = sys_position[B_MOTOR] = axis_position;
            } else {
              sys_position[Z_AXIS] = 0;
            }
          #else
            sys_position[idx] = 0;
    6302:	10 82       	st	Z, r1
    6304:	11 82       	std	Z+1, r1	; 0x01
    6306:	12 82       	std	Z+2, r1	; 0x02
    6308:	13 82       	std	Z+3, r1	; 0x03
          #endif
          // Set target direction based on cycle mask and homing cycle approach state.
          // NOTE: This happens to compile smaller than any other implementation tried.
          if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
    630a:	97 01       	movw	r18, r14
    630c:	08 2e       	mov	r0, r24
    630e:	02 c0       	rjmp	.+4      	; 0x6314 <limits_go_home+0x168>
    6310:	35 95       	asr	r19
    6312:	27 95       	ror	r18
    6314:	0a 94       	dec	r0
    6316:	e2 f7       	brpl	.-8      	; 0x6310 <limits_go_home+0x164>
    6318:	20 ff       	sbrs	r18, 0
    631a:	10 c0       	rjmp	.+32     	; 0x633c <limits_go_home+0x190>
            if (approach) { target[idx] = -max_travel; }
    631c:	00 23       	and	r16, r16
    631e:	39 f0       	breq	.+14     	; 0x632e <limits_go_home+0x182>
    6320:	da 01       	movw	r26, r20
    6322:	8d 92       	st	X+, r8
    6324:	9d 92       	st	X+, r9
    6326:	ad 92       	st	X+, r10
    6328:	bc 92       	st	X, r11
    632a:	13 97       	sbiw	r26, 0x03	; 3
    632c:	16 c0       	rjmp	.+44     	; 0x635a <limits_go_home+0x1ae>
            else { target[idx] = max_travel; }
    632e:	da 01       	movw	r26, r20
    6330:	4d 92       	st	X+, r4
    6332:	5d 92       	st	X+, r5
    6334:	6d 92       	st	X+, r6
    6336:	7c 92       	st	X, r7
    6338:	13 97       	sbiw	r26, 0x03	; 3
    633a:	0f c0       	rjmp	.+30     	; 0x635a <limits_go_home+0x1ae>
          } else {
            if (approach) { target[idx] = max_travel; }
    633c:	00 23       	and	r16, r16
    633e:	39 f0       	breq	.+14     	; 0x634e <limits_go_home+0x1a2>
    6340:	da 01       	movw	r26, r20
    6342:	4d 92       	st	X+, r4
    6344:	5d 92       	st	X+, r5
    6346:	6d 92       	st	X+, r6
    6348:	7c 92       	st	X, r7
    634a:	13 97       	sbiw	r26, 0x03	; 3
    634c:	06 c0       	rjmp	.+12     	; 0x635a <limits_go_home+0x1ae>
            else { target[idx] = -max_travel; }
    634e:	da 01       	movw	r26, r20
    6350:	8d 92       	st	X+, r8
    6352:	9d 92       	st	X+, r9
    6354:	ad 92       	st	X+, r10
    6356:	bc 92       	st	X, r11
    6358:	13 97       	sbiw	r26, 0x03	; 3
          }
          // Apply axislock to the step port pins active in this cycle.
          axislock |= step_pin[idx];
    635a:	a8 a5       	ldd	r26, Y+40	; 0x28
    635c:	b9 a5       	ldd	r27, Y+41	; 0x29
    635e:	2c 91       	ld	r18, X
    6360:	12 2b       	or	r17, r18
    6362:	01 96       	adiw	r24, 0x01	; 1
    6364:	28 a5       	ldd	r18, Y+40	; 0x28
    6366:	39 a5       	ldd	r19, Y+41	; 0x29
    6368:	2f 5f       	subi	r18, 0xFF	; 255
    636a:	3f 4f       	sbci	r19, 0xFF	; 255
    636c:	39 a7       	std	Y+41, r19	; 0x29
    636e:	28 a7       	std	Y+40, r18	; 0x28
    6370:	4c 5f       	subi	r20, 0xFC	; 252
    6372:	5f 4f       	sbci	r21, 0xFF	; 255
    6374:	34 96       	adiw	r30, 0x04	; 4
      system_convert_array_steps_to_mpos(target,sys_position);

      // Initialize and declare variables needed for homing routine.
      axislock = 0;
      n_active_axis = 0;
      for (idx=0; idx<N_AXIS; idx++) {
    6376:	83 30       	cpi	r24, 0x03	; 3
    6378:	91 05       	cpc	r25, r1
    637a:	09 f0       	breq	.+2      	; 0x637e <limits_go_home+0x1d2>
    637c:	b8 cf       	rjmp	.-144    	; 0x62ee <limits_go_home+0x142>
          // Apply axislock to the step port pins active in this cycle.
          axislock |= step_pin[idx];
        }

      }
      homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
    637e:	46 2e       	mov	r4, r22
    6380:	51 2c       	mov	r5, r1
    6382:	61 2c       	mov	r6, r1
    6384:	71 2c       	mov	r7, r1
    6386:	c3 01       	movw	r24, r6
    6388:	b2 01       	movw	r22, r4
    638a:	0e 94 05 40 	call	0x800a	; 0x800a <__floatunsisf>
    638e:	0e 94 30 42 	call	0x8460	; 0x8460 <sqrt>
    6392:	9b 01       	movw	r18, r22
    6394:	ac 01       	movw	r20, r24
      sys.homing_axis_lock = axislock;
    6396:	d6 01       	movw	r26, r12
    6398:	16 96       	adiw	r26, 0x06	; 6
    639a:	1c 93       	st	X, r17

      // Perform homing cycle. Planner buffer should be empty, as required to initiate the homing cycle.
      pl_data->feed_rate = homing_rate; // Set current homing rate.
    639c:	6f 8d       	ldd	r22, Y+31	; 0x1f
    639e:	78 a1       	ldd	r23, Y+32	; 0x20
    63a0:	89 a1       	ldd	r24, Y+33	; 0x21
    63a2:	9a a1       	ldd	r25, Y+34	; 0x22
    63a4:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    63a8:	69 83       	std	Y+1, r22	; 0x01
    63aa:	7a 83       	std	Y+2, r23	; 0x02
    63ac:	8b 83       	std	Y+3, r24	; 0x03
    63ae:	9c 83       	std	Y+4, r25	; 0x04
      plan_buffer_line(target, pl_data); // Bypass mc_line(). Directly plan homing motion.
    63b0:	be 01       	movw	r22, r28
    63b2:	6f 5f       	subi	r22, 0xFF	; 255
    63b4:	7f 4f       	sbci	r23, 0xFF	; 255
    63b6:	ce 01       	movw	r24, r28
    63b8:	41 96       	adiw	r24, 0x11	; 17
    63ba:	e4 d8       	rcall	.-3640   	; 0x5584 <plan_buffer_line>

      sys.step_control = STEP_CONTROL_EXECUTE_SYS_MOTION; // Set to execute homing motion and clear existing flags.
    63bc:	24 e0       	ldi	r18, 0x04	; 4
    63be:	f6 01       	movw	r30, r12
    63c0:	24 83       	std	Z+4, r18	; 0x04
      st_prep_buffer(); // Prep and fill segment buffer from newly planned block.
    63c2:	0e 94 22 1c 	call	0x3844	; 0x3844 <st_prep_buffer>
      st_wake_up(); // Initiate motion
    63c6:	0e 94 15 19 	call	0x322a	; 0x322a <st_wake_up>
      do {
        if (approach) {
    63ca:	00 23       	and	r16, r16
    63cc:	f1 f0       	breq	.+60     	; 0x640a <limits_go_home+0x25e>
          // Check limit state. Lock out cycle axes when they change.
          limit_state = limits_get_state();
    63ce:	53 de       	rcall	.-858    	; 0x6076 <limits_get_state>
    63d0:	fe 01       	movw	r30, r28
    63d2:	3e 96       	adiw	r30, 0x0e	; 14
    63d4:	20 e0       	ldi	r18, 0x00	; 0
    63d6:	30 e0       	ldi	r19, 0x00	; 0
          for (idx=0; idx<N_AXIS; idx++) {
            if (axislock & step_pin[idx]) {
              if (limit_state & (1 << idx)) {
    63d8:	68 2f       	mov	r22, r24
    63da:	70 e0       	ldi	r23, 0x00	; 0
      do {
        if (approach) {
          // Check limit state. Lock out cycle axes when they change.
          limit_state = limits_get_state();
          for (idx=0; idx<N_AXIS; idx++) {
            if (axislock & step_pin[idx]) {
    63dc:	81 91       	ld	r24, Z+
    63de:	98 2f       	mov	r25, r24
    63e0:	91 23       	and	r25, r17
    63e2:	59 f0       	breq	.+22     	; 0x63fa <limits_go_home+0x24e>
              if (limit_state & (1 << idx)) {
    63e4:	ab 01       	movw	r20, r22
    63e6:	02 2e       	mov	r0, r18
    63e8:	02 c0       	rjmp	.+4      	; 0x63ee <limits_go_home+0x242>
    63ea:	55 95       	asr	r21
    63ec:	47 95       	ror	r20
    63ee:	0a 94       	dec	r0
    63f0:	e2 f7       	brpl	.-8      	; 0x63ea <limits_go_home+0x23e>
    63f2:	40 ff       	sbrs	r20, 0
    63f4:	02 c0       	rjmp	.+4      	; 0x63fa <limits_go_home+0x24e>
                #ifdef COREXY
                  if (idx==Z_AXIS) { axislock &= ~(step_pin[Z_AXIS]); }
                  else { axislock &= ~(step_pin[A_MOTOR]|step_pin[B_MOTOR]); }
                #else
                  axislock &= ~(step_pin[idx]);
    63f6:	80 95       	com	r24
    63f8:	18 23       	and	r17, r24
    63fa:	2f 5f       	subi	r18, 0xFF	; 255
    63fc:	3f 4f       	sbci	r19, 0xFF	; 255
      st_wake_up(); // Initiate motion
      do {
        if (approach) {
          // Check limit state. Lock out cycle axes when they change.
          limit_state = limits_get_state();
          for (idx=0; idx<N_AXIS; idx++) {
    63fe:	23 30       	cpi	r18, 0x03	; 3
    6400:	31 05       	cpc	r19, r1
    6402:	61 f7       	brne	.-40     	; 0x63dc <limits_go_home+0x230>
                  axislock &= ~(step_pin[idx]);
                #endif
              }
            }
          }
          sys.homing_axis_lock = axislock;
    6404:	d6 01       	movw	r26, r12
    6406:	16 96       	adiw	r26, 0x06	; 6
    6408:	1c 93       	st	X, r17
        }

        st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
    640a:	0e 94 22 1c 	call	0x3844	; 0x3844 <st_prep_buffer>

        // Exit routines: No time to run protocol_execute_realtime() in this loop.
        if (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET | EXEC_CYCLE_STOP)) {
    640e:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    6412:	84 73       	andi	r24, 0x34	; 52
    6414:	31 f1       	breq	.+76     	; 0x6462 <limits_go_home+0x2b6>
          uint8_t rt_exec = sys_rt_exec_state;
    6416:	10 91 31 0c 	lds	r17, 0x0C31	; 0x800c31 <sys_rt_exec_state>
          // Homing failure condition: Reset issued during cycle.
          if (rt_exec & EXEC_RESET) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_RESET); }
    641a:	14 ff       	sbrs	r17, 4
    641c:	03 c0       	rjmp	.+6      	; 0x6424 <limits_go_home+0x278>
    641e:	86 e0       	ldi	r24, 0x06	; 6
    6420:	0e 94 fd 3d 	call	0x7bfa	; 0x7bfa <system_set_exec_alarm>
          // Homing failure condition: Safety door was opened.
          if (rt_exec & EXEC_SAFETY_DOOR) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_DOOR); }
    6424:	15 ff       	sbrs	r17, 5
    6426:	03 c0       	rjmp	.+6      	; 0x642e <limits_go_home+0x282>
    6428:	87 e0       	ldi	r24, 0x07	; 7
    642a:	0e 94 fd 3d 	call	0x7bfa	; 0x7bfa <system_set_exec_alarm>
          // Homing failure condition: Limit switch still engaged after pull-off motion
          if (!approach && (limits_get_state() & cycle_mask)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_PULLOFF); }
    642e:	01 11       	cpse	r16, r1
    6430:	b9 c0       	rjmp	.+370    	; 0x65a4 <limits_go_home+0x3f8>
    6432:	21 de       	rcall	.-958    	; 0x6076 <limits_get_state>
    6434:	bf a1       	ldd	r27, Y+39	; 0x27
    6436:	8b 23       	and	r24, r27
    6438:	39 f0       	breq	.+14     	; 0x6448 <limits_go_home+0x29c>
    643a:	88 e0       	ldi	r24, 0x08	; 8
    643c:	0e 94 fd 3d 	call	0x7bfa	; 0x7bfa <system_set_exec_alarm>
    6440:	03 c0       	rjmp	.+6      	; 0x6448 <limits_go_home+0x29c>
          // Homing failure condition: Limit switch not found during approach.
          if (approach && (rt_exec & EXEC_CYCLE_STOP)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_APPROACH); }
    6442:	89 e0       	ldi	r24, 0x09	; 9
    6444:	0e 94 fd 3d 	call	0x7bfa	; 0x7bfa <system_set_exec_alarm>
          if (sys_rt_exec_alarm) {
    6448:	80 91 53 0c 	lds	r24, 0x0C53	; 0x800c53 <sys_rt_exec_alarm>
    644c:	88 23       	and	r24, r24
    644e:	29 f0       	breq	.+10     	; 0x645a <limits_go_home+0x2ae>
            mc_reset(); // Stop motors, if they are running.
    6450:	0e 94 2a 07 	call	0xe54	; 0xe54 <mc_reset>
            protocol_execute_realtime();
    6454:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <protocol_execute_realtime>
            return;
    6458:	a8 c0       	rjmp	.+336    	; 0x65aa <limits_go_home+0x3fe>
          } else {
            // Pull-off motion complete. Disable CYCLE_STOP from executing.
            system_clear_exec_state_flag(EXEC_CYCLE_STOP);
    645a:	84 e0       	ldi	r24, 0x04	; 4
    645c:	0e 94 f3 3d 	call	0x7be6	; 0x7be6 <system_clear_exec_state_flag>
            break;
    6460:	04 c0       	rjmp	.+8      	; 0x646a <limits_go_home+0x2be>
          }
        }

      } while (STEP_MASK & axislock);
    6462:	81 2f       	mov	r24, r17
    6464:	8c 71       	andi	r24, 0x1C	; 28
    6466:	09 f0       	breq	.+2      	; 0x646a <limits_go_home+0x2be>
    6468:	b0 cf       	rjmp	.-160    	; 0x63ca <limits_go_home+0x21e>
      st_reset(); // Immediately force kill steppers and reset step segment buffer.
    646a:	0e 94 af 1b 	call	0x375e	; 0x375e <st_reset>
      delay_ms(settings.homing_debounce_delay); // Delay to allow transient dynamics to dissipate.
    646e:	ef e1       	ldi	r30, 0x1F	; 31
    6470:	ff e0       	ldi	r31, 0x0F	; 15
    6472:	80 81       	ld	r24, Z
    6474:	91 81       	ldd	r25, Z+1	; 0x01
    6476:	ca dc       	rcall	.-1644   	; 0x5e0c <delay_ms>

      // Reverse direction and reset homing rate for locate cycle(s).
      approach = !approach;
    6478:	f1 e0       	ldi	r31, 0x01	; 1
    647a:	0f 27       	eor	r16, r31

      // After first cycle, homing enters locating phase. Shorten search to pull-off distance.
      if (approach) {
    647c:	d1 f0       	breq	.+52     	; 0x64b2 <limits_go_home+0x306>
        max_travel = settings.homing_pulloff*HOMING_AXIS_LOCATE_SCALAR;
    647e:	20 e0       	ldi	r18, 0x00	; 0
    6480:	30 e0       	ldi	r19, 0x00	; 0
    6482:	40 ea       	ldi	r20, 0xA0	; 160
    6484:	50 e4       	ldi	r21, 0x40	; 64
    6486:	a1 e2       	ldi	r26, 0x21	; 33
    6488:	bf e0       	ldi	r27, 0x0F	; 15
    648a:	6d 91       	ld	r22, X+
    648c:	7d 91       	ld	r23, X+
    648e:	8d 91       	ld	r24, X+
    6490:	9c 91       	ld	r25, X
    6492:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    6496:	2b 01       	movw	r4, r22
    6498:	3c 01       	movw	r6, r24
        homing_rate = settings.homing_feed_rate;
    649a:	a7 e1       	ldi	r26, 0x17	; 23
    649c:	bf e0       	ldi	r27, 0x0F	; 15
    649e:	8d 91       	ld	r24, X+
    64a0:	9d 91       	ld	r25, X+
    64a2:	0d 90       	ld	r0, X+
    64a4:	bc 91       	ld	r27, X
    64a6:	a0 2d       	mov	r26, r0
    64a8:	8f 8f       	std	Y+31, r24	; 0x1f
    64aa:	98 a3       	std	Y+32, r25	; 0x20
    64ac:	a9 a3       	std	Y+33, r26	; 0x21
    64ae:	ba a3       	std	Y+34, r27	; 0x22
    64b0:	11 c0       	rjmp	.+34     	; 0x64d4 <limits_go_home+0x328>
      } else {
        max_travel = settings.homing_pulloff;
    64b2:	e1 e2       	ldi	r30, 0x21	; 33
    64b4:	ff e0       	ldi	r31, 0x0F	; 15
    64b6:	40 80       	ld	r4, Z
    64b8:	51 80       	ldd	r5, Z+1	; 0x01
    64ba:	62 80       	ldd	r6, Z+2	; 0x02
    64bc:	73 80       	ldd	r7, Z+3	; 0x03
        homing_rate = settings.homing_seek_rate;
    64be:	ab e1       	ldi	r26, 0x1B	; 27
    64c0:	bf e0       	ldi	r27, 0x0F	; 15
    64c2:	8d 91       	ld	r24, X+
    64c4:	9d 91       	ld	r25, X+
    64c6:	0d 90       	ld	r0, X+
    64c8:	bc 91       	ld	r27, X
    64ca:	a0 2d       	mov	r26, r0
    64cc:	8f 8f       	std	Y+31, r24	; 0x1f
    64ce:	98 a3       	std	Y+32, r25	; 0x20
    64d0:	a9 a3       	std	Y+33, r26	; 0x21
    64d2:	ba a3       	std	Y+34, r27	; 0x22
    64d4:	bd 8d       	ldd	r27, Y+29	; 0x1d
    64d6:	b1 50       	subi	r27, 0x01	; 1
    64d8:	bd 8f       	std	Y+29, r27	; 0x1d
      }
    } while (n_cycle-- > 0);
    64da:	b1 11       	cpse	r27, r1
    64dc:	e9 ce       	rjmp	.-558    	; 0x62b0 <limits_go_home+0x104>
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
      #ifdef HOMING_FORCE_SET_ORIGIN
        set_axis_position = 0;
      #else
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    64de:	e0 90 16 0f 	lds	r14, 0x0F16	; 0x800f16 <settings+0x46>
    64e2:	f1 2c       	mov	r15, r1
          set_axis_position = lround((settings.max_travel[idx]+settings.homing_pulloff)*settings.steps_per_mm[idx]);
    64e4:	80 90 21 0f 	lds	r8, 0x0F21	; 0x800f21 <settings+0x51>
    64e8:	90 90 22 0f 	lds	r9, 0x0F22	; 0x800f22 <settings+0x52>
    64ec:	a0 90 23 0f 	lds	r10, 0x0F23	; 0x800f23 <settings+0x53>
    64f0:	b0 90 24 0f 	lds	r11, 0x0F24	; 0x800f24 <settings+0x54>
        } else {
          set_axis_position = lround(-settings.homing_pulloff*settings.steps_per_mm[idx]);
    64f4:	24 01       	movw	r4, r8
    64f6:	35 01       	movw	r6, r10
    64f8:	77 fa       	bst	r7, 7
    64fa:	70 94       	com	r7
    64fc:	77 f8       	bld	r7, 7
    64fe:	70 94       	com	r7
    6500:	00 e0       	ldi	r16, 0x00	; 0
    6502:	10 e0       	ldi	r17, 0x00	; 0
    6504:	cd a0       	ldd	r12, Y+37	; 0x25
    6506:	de a0       	ldd	r13, Y+38	; 0x26
  // triggering when hard limits are enabled or when more than one axes shares a limit pin.
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
    6508:	c1 01       	movw	r24, r2
    650a:	00 2e       	mov	r0, r16
    650c:	02 c0       	rjmp	.+4      	; 0x6512 <limits_go_home+0x366>
    650e:	95 95       	asr	r25
    6510:	87 95       	ror	r24
    6512:	0a 94       	dec	r0
    6514:	e2 f7       	brpl	.-8      	; 0x650e <limits_go_home+0x362>
    6516:	80 ff       	sbrs	r24, 0
    6518:	34 c0       	rjmp	.+104    	; 0x6582 <limits_go_home+0x3d6>
      #ifdef HOMING_FORCE_SET_ORIGIN
        set_axis_position = 0;
      #else
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    651a:	c7 01       	movw	r24, r14
    651c:	00 2e       	mov	r0, r16
    651e:	02 c0       	rjmp	.+4      	; 0x6524 <limits_go_home+0x378>
    6520:	95 95       	asr	r25
    6522:	87 95       	ror	r24
    6524:	0a 94       	dec	r0
    6526:	e2 f7       	brpl	.-8      	; 0x6520 <limits_go_home+0x374>
    6528:	80 ff       	sbrs	r24, 0
    652a:	15 c0       	rjmp	.+42     	; 0x6556 <limits_go_home+0x3aa>
          set_axis_position = lround((settings.max_travel[idx]+settings.homing_pulloff)*settings.steps_per_mm[idx]);
    652c:	eb a1       	ldd	r30, Y+35	; 0x23
    652e:	fc a1       	ldd	r31, Y+36	; 0x24
    6530:	24 a1       	ldd	r18, Z+36	; 0x24
    6532:	35 a1       	ldd	r19, Z+37	; 0x25
    6534:	46 a1       	ldd	r20, Z+38	; 0x26
    6536:	57 a1       	ldd	r21, Z+39	; 0x27
    6538:	c5 01       	movw	r24, r10
    653a:	b4 01       	movw	r22, r8
    653c:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    6540:	ab a1       	ldd	r26, Y+35	; 0x23
    6542:	bc a1       	ldd	r27, Y+36	; 0x24
    6544:	2d 91       	ld	r18, X+
    6546:	3d 91       	ld	r19, X+
    6548:	4d 91       	ld	r20, X+
    654a:	5c 91       	ld	r21, X
    654c:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    6550:	0e 94 73 41 	call	0x82e6	; 0x82e6 <lround>
    6554:	0c c0       	rjmp	.+24     	; 0x656e <limits_go_home+0x3c2>
        } else {
          set_axis_position = lround(-settings.homing_pulloff*settings.steps_per_mm[idx]);
    6556:	eb a1       	ldd	r30, Y+35	; 0x23
    6558:	fc a1       	ldd	r31, Y+36	; 0x24
    655a:	20 81       	ld	r18, Z
    655c:	31 81       	ldd	r19, Z+1	; 0x01
    655e:	42 81       	ldd	r20, Z+2	; 0x02
    6560:	53 81       	ldd	r21, Z+3	; 0x03
    6562:	c3 01       	movw	r24, r6
    6564:	b2 01       	movw	r22, r4
    6566:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    656a:	0e 94 73 41 	call	0x82e6	; 0x82e6 <lround>
          sys_position[B_MOTOR] = off_axis_position - set_axis_position;
        } else {
          sys_position[idx] = set_axis_position;
        }
      #else
        sys_position[idx] = set_axis_position;
    656e:	d6 01       	movw	r26, r12
    6570:	6c 93       	st	X, r22
    6572:	11 96       	adiw	r26, 0x01	; 1
    6574:	7c 93       	st	X, r23
    6576:	11 97       	sbiw	r26, 0x01	; 1
    6578:	12 96       	adiw	r26, 0x02	; 2
    657a:	8c 93       	st	X, r24
    657c:	12 97       	sbiw	r26, 0x02	; 2
    657e:	13 96       	adiw	r26, 0x03	; 3
    6580:	9c 93       	st	X, r25
    6582:	0f 5f       	subi	r16, 0xFF	; 255
    6584:	1f 4f       	sbci	r17, 0xFF	; 255
    6586:	b4 e0       	ldi	r27, 0x04	; 4
    6588:	cb 0e       	add	r12, r27
    658a:	d1 1c       	adc	r13, r1
    658c:	eb a1       	ldd	r30, Y+35	; 0x23
    658e:	fc a1       	ldd	r31, Y+36	; 0x24
    6590:	34 96       	adiw	r30, 0x04	; 4
    6592:	fc a3       	std	Y+36, r31	; 0x24
    6594:	eb a3       	std	Y+35, r30	; 0x23
  // set up pull-off maneuver from axes limit switches that have been homed. This provides
  // some initial clearance off the switches and should also help prevent them from falsely
  // triggering when hard limits are enabled or when more than one axes shares a limit pin.
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    6596:	03 30       	cpi	r16, 0x03	; 3
    6598:	11 05       	cpc	r17, r1
    659a:	09 f0       	breq	.+2      	; 0x659e <limits_go_home+0x3f2>
    659c:	b5 cf       	rjmp	.-150    	; 0x6508 <limits_go_home+0x35c>
        sys_position[idx] = set_axis_position;
      #endif

    }
  }
  sys.step_control = STEP_CONTROL_NORMAL_OP; // Return step control to normal operation.
    659e:	10 92 22 0c 	sts	0x0C22, r1	; 0x800c22 <sys+0x4>
    65a2:	03 c0       	rjmp	.+6      	; 0x65aa <limits_go_home+0x3fe>
          // Homing failure condition: Safety door was opened.
          if (rt_exec & EXEC_SAFETY_DOOR) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_DOOR); }
          // Homing failure condition: Limit switch still engaged after pull-off motion
          if (!approach && (limits_get_state() & cycle_mask)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_PULLOFF); }
          // Homing failure condition: Limit switch not found during approach.
          if (approach && (rt_exec & EXEC_CYCLE_STOP)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_APPROACH); }
    65a4:	12 ff       	sbrs	r17, 2
    65a6:	50 cf       	rjmp	.-352    	; 0x6448 <limits_go_home+0x29c>
    65a8:	4c cf       	rjmp	.-360    	; 0x6442 <limits_go_home+0x296>
      #endif

    }
  }
  sys.step_control = STEP_CONTROL_NORMAL_OP; // Return step control to normal operation.
}
    65aa:	a9 96       	adiw	r28, 0x29	; 41
    65ac:	0f b6       	in	r0, 0x3f	; 63
    65ae:	f8 94       	cli
    65b0:	de bf       	out	0x3e, r29	; 62
    65b2:	0f be       	out	0x3f, r0	; 63
    65b4:	cd bf       	out	0x3d, r28	; 61
    65b6:	df 91       	pop	r29
    65b8:	cf 91       	pop	r28
    65ba:	1f 91       	pop	r17
    65bc:	0f 91       	pop	r16
    65be:	ff 90       	pop	r15
    65c0:	ef 90       	pop	r14
    65c2:	df 90       	pop	r13
    65c4:	cf 90       	pop	r12
    65c6:	bf 90       	pop	r11
    65c8:	af 90       	pop	r10
    65ca:	9f 90       	pop	r9
    65cc:	8f 90       	pop	r8
    65ce:	7f 90       	pop	r7
    65d0:	6f 90       	pop	r6
    65d2:	5f 90       	pop	r5
    65d4:	4f 90       	pop	r4
    65d6:	3f 90       	pop	r3
    65d8:	2f 90       	pop	r2
    65da:	08 95       	ret

000065dc <limits_soft_check>:

// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
// NOTE: Used by jogging to limit travel within soft-limit volume.
void limits_soft_check(float *target)
{
    65dc:	cf 93       	push	r28
    65de:	df 93       	push	r29
  if (system_check_travel_limits(target)) {
    65e0:	0e 94 30 3b 	call	0x7660	; 0x7660 <system_check_travel_limits>
    65e4:	88 23       	and	r24, r24
    65e6:	d1 f0       	breq	.+52     	; 0x661c <limits_soft_check+0x40>
    sys.soft_limit = true;
    65e8:	ee e1       	ldi	r30, 0x1E	; 30
    65ea:	fc e0       	ldi	r31, 0x0C	; 12
    65ec:	81 e0       	ldi	r24, 0x01	; 1
    65ee:	83 83       	std	Z+3, r24	; 0x03
    // Force feed hold if cycle is active. All buffered blocks are guaranteed to be within
    // workspace volume so just come to a controlled stop so position is not lost. When complete
    // enter alarm mode.
    if (sys.state == STATE_CYCLE) {
    65f0:	80 81       	ld	r24, Z
    65f2:	88 30       	cpi	r24, 0x08	; 8
    65f4:	61 f4       	brne	.+24     	; 0x660e <limits_soft_check+0x32>
      system_set_exec_state_flag(EXEC_FEED_HOLD);
    65f6:	0e 94 95 3b 	call	0x772a	; 0x772a <system_set_exec_state_flag>
      do {
        protocol_execute_realtime();
        if (sys.abort) { return; }
    65fa:	ce e1       	ldi	r28, 0x1E	; 30
    65fc:	dc e0       	ldi	r29, 0x0C	; 12
    // workspace volume so just come to a controlled stop so position is not lost. When complete
    // enter alarm mode.
    if (sys.state == STATE_CYCLE) {
      system_set_exec_state_flag(EXEC_FEED_HOLD);
      do {
        protocol_execute_realtime();
    65fe:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <protocol_execute_realtime>
        if (sys.abort) { return; }
    6602:	89 81       	ldd	r24, Y+1	; 0x01
    6604:	81 11       	cpse	r24, r1
    6606:	0a c0       	rjmp	.+20     	; 0x661c <limits_soft_check+0x40>
      } while ( sys.state != STATE_IDLE );
    6608:	88 81       	ld	r24, Y
    660a:	81 11       	cpse	r24, r1
    660c:	f8 cf       	rjmp	.-16     	; 0x65fe <limits_soft_check+0x22>
    }
    mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
    660e:	0e 94 2a 07 	call	0xe54	; 0xe54 <mc_reset>
    system_set_exec_alarm(EXEC_ALARM_SOFT_LIMIT); // Indicate soft limit critical event
    6612:	82 e0       	ldi	r24, 0x02	; 2
    6614:	0e 94 fd 3d 	call	0x7bfa	; 0x7bfa <system_set_exec_alarm>
    protocol_execute_realtime(); // Execute to enter critical event loop and system abort
    6618:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <protocol_execute_realtime>
    return;
  }
}
    661c:	df 91       	pop	r29
    661e:	cf 91       	pop	r28
    6620:	08 95       	ret

00006622 <printString>:
      n /= 2;
  }

  for (; i > 0; i--)
      serial_write('0' + buf[i - 1]);
}
    6622:	cf 93       	push	r28
    6624:	df 93       	push	r29
    6626:	ec 01       	movw	r28, r24
    6628:	88 81       	ld	r24, Y
    662a:	88 23       	and	r24, r24
    662c:	31 f0       	breq	.+12     	; 0x663a <printString+0x18>
    662e:	21 96       	adiw	r28, 0x01	; 1
    6630:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    6634:	89 91       	ld	r24, Y+
    6636:	81 11       	cpse	r24, r1
    6638:	fb cf       	rjmp	.-10     	; 0x6630 <printString+0xe>
    663a:	df 91       	pop	r29
    663c:	cf 91       	pop	r28
    663e:	08 95       	ret

00006640 <printPgmString>:
    6640:	cf 93       	push	r28
    6642:	df 93       	push	r29
    6644:	ec 01       	movw	r28, r24
    6646:	21 96       	adiw	r28, 0x01	; 1
    6648:	fc 01       	movw	r30, r24
    664a:	84 91       	lpm	r24, Z
    664c:	88 23       	and	r24, r24
    664e:	39 f0       	breq	.+14     	; 0x665e <printPgmString+0x1e>
    6650:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    6654:	fe 01       	movw	r30, r28
    6656:	84 91       	lpm	r24, Z
    6658:	21 96       	adiw	r28, 0x01	; 1
    665a:	81 11       	cpse	r24, r1
    665c:	f9 cf       	rjmp	.-14     	; 0x6650 <printPgmString+0x10>
    665e:	df 91       	pop	r29
    6660:	cf 91       	pop	r28
    6662:	08 95       	ret

00006664 <print_uint8_base10>:
    6664:	cf 93       	push	r28
    6666:	df 93       	push	r29
    6668:	84 36       	cpi	r24, 0x64	; 100
    666a:	90 f0       	brcs	.+36     	; 0x6690 <print_uint8_base10+0x2c>
    666c:	9d ec       	ldi	r25, 0xCD	; 205
    666e:	89 9f       	mul	r24, r25
    6670:	91 2d       	mov	r25, r1
    6672:	11 24       	eor	r1, r1
    6674:	96 95       	lsr	r25
    6676:	96 95       	lsr	r25
    6678:	96 95       	lsr	r25
    667a:	39 2f       	mov	r19, r25
    667c:	33 0f       	add	r19, r19
    667e:	23 2f       	mov	r18, r19
    6680:	22 0f       	add	r18, r18
    6682:	22 0f       	add	r18, r18
    6684:	23 0f       	add	r18, r19
    6686:	82 1b       	sub	r24, r18
    6688:	d0 e3       	ldi	r29, 0x30	; 48
    668a:	d8 0f       	add	r29, r24
    668c:	89 2f       	mov	r24, r25
    668e:	01 c0       	rjmp	.+2      	; 0x6692 <print_uint8_base10+0x2e>
    6690:	d0 e0       	ldi	r29, 0x00	; 0
    6692:	8a 30       	cpi	r24, 0x0A	; 10
    6694:	f8 f0       	brcs	.+62     	; 0x66d4 <print_uint8_base10+0x70>
    6696:	9d ec       	ldi	r25, 0xCD	; 205
    6698:	89 9f       	mul	r24, r25
    669a:	91 2d       	mov	r25, r1
    669c:	11 24       	eor	r1, r1
    669e:	96 95       	lsr	r25
    66a0:	96 95       	lsr	r25
    66a2:	96 95       	lsr	r25
    66a4:	39 2f       	mov	r19, r25
    66a6:	33 0f       	add	r19, r19
    66a8:	23 2f       	mov	r18, r19
    66aa:	22 0f       	add	r18, r18
    66ac:	22 0f       	add	r18, r18
    66ae:	23 0f       	add	r18, r19
    66b0:	c8 2f       	mov	r28, r24
    66b2:	c2 1b       	sub	r28, r18
    66b4:	c0 5d       	subi	r28, 0xD0	; 208
    66b6:	80 e3       	ldi	r24, 0x30	; 48
    66b8:	89 0f       	add	r24, r25
    66ba:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    66be:	cc 23       	and	r28, r28
    66c0:	19 f0       	breq	.+6      	; 0x66c8 <print_uint8_base10+0x64>
    66c2:	8c 2f       	mov	r24, r28
    66c4:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    66c8:	dd 23       	and	r29, r29
    66ca:	41 f0       	breq	.+16     	; 0x66dc <print_uint8_base10+0x78>
    66cc:	8d 2f       	mov	r24, r29
    66ce:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    66d2:	04 c0       	rjmp	.+8      	; 0x66dc <print_uint8_base10+0x78>
    66d4:	80 5d       	subi	r24, 0xD0	; 208
    66d6:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    66da:	f6 cf       	rjmp	.-20     	; 0x66c8 <print_uint8_base10+0x64>
    66dc:	df 91       	pop	r29
    66de:	cf 91       	pop	r28
    66e0:	08 95       	ret

000066e2 <print_uint32_base10>:


void print_uint32_base10(uint32_t n)
{
    66e2:	8f 92       	push	r8
    66e4:	9f 92       	push	r9
    66e6:	af 92       	push	r10
    66e8:	bf 92       	push	r11
    66ea:	ef 92       	push	r14
    66ec:	ff 92       	push	r15
    66ee:	1f 93       	push	r17
    66f0:	cf 93       	push	r28
    66f2:	df 93       	push	r29
    66f4:	cd b7       	in	r28, 0x3d	; 61
    66f6:	de b7       	in	r29, 0x3e	; 62
    66f8:	2a 97       	sbiw	r28, 0x0a	; 10
    66fa:	0f b6       	in	r0, 0x3f	; 63
    66fc:	f8 94       	cli
    66fe:	de bf       	out	0x3e, r29	; 62
    6700:	0f be       	out	0x3f, r0	; 63
    6702:	cd bf       	out	0x3d, r28	; 61
  if (n == 0) {
    6704:	61 15       	cp	r22, r1
    6706:	71 05       	cpc	r23, r1
    6708:	81 05       	cpc	r24, r1
    670a:	91 05       	cpc	r25, r1
    670c:	21 f4       	brne	.+8      	; 0x6716 <print_uint32_base10+0x34>
    serial_write('0');
    670e:	80 e3       	ldi	r24, 0x30	; 48
    6710:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    6714:	2c c0       	rjmp	.+88     	; 0x676e <print_uint32_base10+0x8c>
    6716:	20 e0       	ldi	r18, 0x00	; 0

  unsigned char buf[10];
  uint8_t i = 0;

  while (n > 0) {
    buf[i++] = n % 10;
    6718:	0f 2e       	mov	r0, r31
    671a:	fa e0       	ldi	r31, 0x0A	; 10
    671c:	8f 2e       	mov	r8, r31
    671e:	91 2c       	mov	r9, r1
    6720:	a1 2c       	mov	r10, r1
    6722:	b1 2c       	mov	r11, r1
    6724:	f0 2d       	mov	r31, r0
    6726:	11 e0       	ldi	r17, 0x01	; 1
    6728:	12 0f       	add	r17, r18
    672a:	ee 24       	eor	r14, r14
    672c:	e3 94       	inc	r14
    672e:	f1 2c       	mov	r15, r1
    6730:	ec 0e       	add	r14, r28
    6732:	fd 1e       	adc	r15, r29
    6734:	e2 0e       	add	r14, r18
    6736:	f1 1c       	adc	r15, r1
    6738:	a5 01       	movw	r20, r10
    673a:	94 01       	movw	r18, r8
    673c:	0e 94 90 42 	call	0x8520	; 0x8520 <__udivmodsi4>
    6740:	f7 01       	movw	r30, r14
    6742:	60 83       	st	Z, r22
    n /= 10;
    6744:	62 2f       	mov	r22, r18
    6746:	73 2f       	mov	r23, r19
    6748:	84 2f       	mov	r24, r20
    674a:	95 2f       	mov	r25, r21

  unsigned char buf[10];
  uint8_t i = 0;

  while (n > 0) {
    buf[i++] = n % 10;
    674c:	21 2f       	mov	r18, r17
  }

  unsigned char buf[10];
  uint8_t i = 0;

  while (n > 0) {
    674e:	61 15       	cp	r22, r1
    6750:	71 05       	cpc	r23, r1
    6752:	81 05       	cpc	r24, r1
    6754:	91 05       	cpc	r25, r1
    6756:	39 f7       	brne	.-50     	; 0x6726 <print_uint32_base10+0x44>
    buf[i++] = n % 10;
    n /= 10;
  }

  for (; i > 0; i--)
    6758:	11 23       	and	r17, r17
    675a:	49 f0       	breq	.+18     	; 0x676e <print_uint32_base10+0x8c>
    serial_write('0' + buf[i-1]);
    675c:	fe 01       	movw	r30, r28
    675e:	e1 0f       	add	r30, r17
    6760:	f1 1d       	adc	r31, r1
    6762:	80 81       	ld	r24, Z
    6764:	80 5d       	subi	r24, 0xD0	; 208
    6766:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
  while (n > 0) {
    buf[i++] = n % 10;
    n /= 10;
  }

  for (; i > 0; i--)
    676a:	11 50       	subi	r17, 0x01	; 1
    676c:	b9 f7       	brne	.-18     	; 0x675c <print_uint32_base10+0x7a>
    serial_write('0' + buf[i-1]);
}
    676e:	2a 96       	adiw	r28, 0x0a	; 10
    6770:	0f b6       	in	r0, 0x3f	; 63
    6772:	f8 94       	cli
    6774:	de bf       	out	0x3e, r29	; 62
    6776:	0f be       	out	0x3f, r0	; 63
    6778:	cd bf       	out	0x3d, r28	; 61
    677a:	df 91       	pop	r29
    677c:	cf 91       	pop	r28
    677e:	1f 91       	pop	r17
    6780:	ff 90       	pop	r15
    6782:	ef 90       	pop	r14
    6784:	bf 90       	pop	r11
    6786:	af 90       	pop	r10
    6788:	9f 90       	pop	r9
    678a:	8f 90       	pop	r8
    678c:	08 95       	ret

0000678e <printInteger>:


void printInteger(long n)
{
    678e:	cf 92       	push	r12
    6790:	df 92       	push	r13
    6792:	ef 92       	push	r14
    6794:	ff 92       	push	r15
    6796:	6b 01       	movw	r12, r22
    6798:	7c 01       	movw	r14, r24
  if (n < 0) {
    679a:	99 23       	and	r25, r25
    679c:	64 f4       	brge	.+24     	; 0x67b6 <printInteger+0x28>
    serial_write('-');
    679e:	8d e2       	ldi	r24, 0x2D	; 45
    67a0:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    print_uint32_base10(-n);
    67a4:	66 27       	eor	r22, r22
    67a6:	77 27       	eor	r23, r23
    67a8:	cb 01       	movw	r24, r22
    67aa:	6c 19       	sub	r22, r12
    67ac:	7d 09       	sbc	r23, r13
    67ae:	8e 09       	sbc	r24, r14
    67b0:	9f 09       	sbc	r25, r15
    67b2:	97 df       	rcall	.-210    	; 0x66e2 <print_uint32_base10>
    67b4:	01 c0       	rjmp	.+2      	; 0x67b8 <printInteger+0x2a>
  } else {
    print_uint32_base10(n);
    67b6:	95 df       	rcall	.-214    	; 0x66e2 <print_uint32_base10>
    67b8:	ff 90       	pop	r15
  }
}
    67ba:	ef 90       	pop	r14
    67bc:	df 90       	pop	r13
    67be:	cf 90       	pop	r12
    67c0:	08 95       	ret

000067c2 <printFloat>:
    67c2:	8f 92       	push	r8
// more digits than a float. Number of decimal places, which are tracked by a counter,
// may be set by the user. The integer is then efficiently converted to a string.
// NOTE: AVR '%' and '/' integer operations are very efficient. Bitshifting speed-up
// techniques are actually just slightly slower. Found this out the hard way.
void printFloat(float n, uint8_t decimal_places)
{
    67c4:	9f 92       	push	r9
    67c6:	af 92       	push	r10
    67c8:	bf 92       	push	r11
    67ca:	cf 92       	push	r12
    67cc:	df 92       	push	r13
    67ce:	ef 92       	push	r14
    67d0:	ff 92       	push	r15
    67d2:	0f 93       	push	r16
    67d4:	1f 93       	push	r17
    67d6:	cf 93       	push	r28
    67d8:	df 93       	push	r29
    67da:	cd b7       	in	r28, 0x3d	; 61
    67dc:	de b7       	in	r29, 0x3e	; 62
    67de:	2d 97       	sbiw	r28, 0x0d	; 13
    67e0:	0f b6       	in	r0, 0x3f	; 63
    67e2:	f8 94       	cli
    67e4:	de bf       	out	0x3e, r29	; 62
    67e6:	0f be       	out	0x3f, r0	; 63
    67e8:	cd bf       	out	0x3d, r28	; 61
    67ea:	6b 01       	movw	r12, r22
    67ec:	7c 01       	movw	r14, r24
    67ee:	04 2f       	mov	r16, r20
  if (n < 0) {
    67f0:	20 e0       	ldi	r18, 0x00	; 0
    67f2:	30 e0       	ldi	r19, 0x00	; 0
    67f4:	a9 01       	movw	r20, r18
    67f6:	0e 94 65 3f 	call	0x7eca	; 0x7eca <__cmpsf2>
    67fa:	88 23       	and	r24, r24
    67fc:	3c f4       	brge	.+14     	; 0x680c <printFloat+0x4a>
    serial_write('-');
    67fe:	8d e2       	ldi	r24, 0x2D	; 45
    6800:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    n = -n;
    6804:	f7 fa       	bst	r15, 7
    6806:	f0 94       	com	r15
    6808:	f7 f8       	bld	r15, 7
    680a:	f0 94       	com	r15
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    680c:	02 30       	cpi	r16, 0x02	; 2
    680e:	88 f0       	brcs	.+34     	; 0x6832 <printFloat+0x70>
    6810:	10 2f       	mov	r17, r16
    n *= 100;
    6812:	20 e0       	ldi	r18, 0x00	; 0
    6814:	30 e0       	ldi	r19, 0x00	; 0
    6816:	48 ec       	ldi	r20, 0xC8	; 200
    6818:	52 e4       	ldi	r21, 0x42	; 66
    681a:	c7 01       	movw	r24, r14
    681c:	b6 01       	movw	r22, r12
    681e:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    6822:	6b 01       	movw	r12, r22
    6824:	7c 01       	movw	r14, r24
    decimals -= 2;
    6826:	12 50       	subi	r17, 0x02	; 2
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    6828:	12 30       	cpi	r17, 0x02	; 2
    682a:	98 f7       	brcc	.-26     	; 0x6812 <printFloat+0x50>
    682c:	80 2f       	mov	r24, r16
    682e:	81 70       	andi	r24, 0x01	; 1
    6830:	01 c0       	rjmp	.+2      	; 0x6834 <printFloat+0x72>
  if (n < 0) {
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
    6832:	80 2f       	mov	r24, r16
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    n *= 100;
    decimals -= 2;
  }
  if (decimals) { n *= 10; }
    6834:	88 23       	and	r24, r24
    6836:	51 f0       	breq	.+20     	; 0x684c <printFloat+0x8a>
    6838:	20 e0       	ldi	r18, 0x00	; 0
    683a:	30 e0       	ldi	r19, 0x00	; 0
    683c:	40 e2       	ldi	r20, 0x20	; 32
    683e:	51 e4       	ldi	r21, 0x41	; 65
    6840:	c7 01       	movw	r24, r14
    6842:	b6 01       	movw	r22, r12
    6844:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    6848:	6b 01       	movw	r12, r22
    684a:	7c 01       	movw	r14, r24
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.

  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
  uint32_t a = (long)n;
    684c:	20 e0       	ldi	r18, 0x00	; 0
    684e:	30 e0       	ldi	r19, 0x00	; 0
    6850:	40 e0       	ldi	r20, 0x00	; 0
    6852:	5f e3       	ldi	r21, 0x3F	; 63
    6854:	c7 01       	movw	r24, r14
    6856:	b6 01       	movw	r22, r12
    6858:	0e 94 8c 3e 	call	0x7d18	; 0x7d18 <__addsf3>
    685c:	0e 94 d4 3f 	call	0x7fa8	; 0x7fa8 <__fixsfsi>
  while(a > 0) {
    6860:	61 15       	cp	r22, r1
    6862:	71 05       	cpc	r23, r1
    6864:	81 05       	cpc	r24, r1
    6866:	91 05       	cpc	r25, r1
    6868:	19 f1       	breq	.+70     	; 0x68b0 <printFloat+0xee>
    686a:	20 e0       	ldi	r18, 0x00	; 0
    buf[i++] = (a % 10) + '0'; // Get digit
    686c:	0f 2e       	mov	r0, r31
    686e:	fa e0       	ldi	r31, 0x0A	; 10
    6870:	8f 2e       	mov	r8, r31
    6872:	91 2c       	mov	r9, r1
    6874:	a1 2c       	mov	r10, r1
    6876:	b1 2c       	mov	r11, r1
    6878:	f0 2d       	mov	r31, r0
    687a:	11 e0       	ldi	r17, 0x01	; 1
    687c:	12 0f       	add	r17, r18
    687e:	ee 24       	eor	r14, r14
    6880:	e3 94       	inc	r14
    6882:	f1 2c       	mov	r15, r1
    6884:	ec 0e       	add	r14, r28
    6886:	fd 1e       	adc	r15, r29
    6888:	e2 0e       	add	r14, r18
    688a:	f1 1c       	adc	r15, r1
    688c:	a5 01       	movw	r20, r10
    688e:	94 01       	movw	r18, r8
    6890:	0e 94 90 42 	call	0x8520	; 0x8520 <__udivmodsi4>
    6894:	60 5d       	subi	r22, 0xD0	; 208
    6896:	f7 01       	movw	r30, r14
    6898:	60 83       	st	Z, r22
    a /= 10;
    689a:	62 2f       	mov	r22, r18
    689c:	73 2f       	mov	r23, r19
    689e:	84 2f       	mov	r24, r20
    68a0:	95 2f       	mov	r25, r21
  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
  uint32_t a = (long)n;
  while(a > 0) {
    buf[i++] = (a % 10) + '0'; // Get digit
    68a2:	21 2f       	mov	r18, r17

  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
  uint32_t a = (long)n;
  while(a > 0) {
    68a4:	61 15       	cp	r22, r1
    68a6:	71 05       	cpc	r23, r1
    68a8:	81 05       	cpc	r24, r1
    68aa:	91 05       	cpc	r25, r1
    68ac:	31 f7       	brne	.-52     	; 0x687a <printFloat+0xb8>
    68ae:	01 c0       	rjmp	.+2      	; 0x68b2 <printFloat+0xf0>
  if (decimals) { n *= 10; }
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.

  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
    68b0:	10 e0       	ldi	r17, 0x00	; 0
  uint32_t a = (long)n;
  while(a > 0) {
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) {
    68b2:	10 17       	cp	r17, r16
    68b4:	60 f4       	brcc	.+24     	; 0x68ce <printFloat+0x10c>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
    68b6:	80 e3       	ldi	r24, 0x30	; 48
    68b8:	e1 e0       	ldi	r30, 0x01	; 1
    68ba:	f0 e0       	ldi	r31, 0x00	; 0
    68bc:	ec 0f       	add	r30, r28
    68be:	fd 1f       	adc	r31, r29
    68c0:	e1 0f       	add	r30, r17
    68c2:	f1 1d       	adc	r31, r1
    68c4:	80 83       	st	Z, r24
    68c6:	1f 5f       	subi	r17, 0xFF	; 255
  uint32_t a = (long)n;
  while(a > 0) {
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) {
    68c8:	01 13       	cpse	r16, r17
    68ca:	f6 cf       	rjmp	.-20     	; 0x68b8 <printFloat+0xf6>
    68cc:	02 c0       	rjmp	.+4      	; 0x68d2 <printFloat+0x110>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
  }
  if (i == decimal_places) { // Fill in leading zero, if needed.
    68ce:	01 13       	cpse	r16, r17
    68d0:	07 c0       	rjmp	.+14     	; 0x68e0 <printFloat+0x11e>
    buf[i++] = '0';
    68d2:	11 e0       	ldi	r17, 0x01	; 1
    68d4:	10 0f       	add	r17, r16
    68d6:	80 e3       	ldi	r24, 0x30	; 48
    68d8:	fe 01       	movw	r30, r28
    68da:	e0 0f       	add	r30, r16
    68dc:	f1 1d       	adc	r31, r1
    68de:	81 83       	std	Z+1, r24	; 0x01
  }

  // Print the generated string.
  for (; i > 0; i--) {
    68e0:	11 23       	and	r17, r17
    68e2:	69 f0       	breq	.+26     	; 0x68fe <printFloat+0x13c>
    if (i == decimal_places) { serial_write('.'); } // Insert decimal point in right place.
    68e4:	01 13       	cpse	r16, r17
    68e6:	03 c0       	rjmp	.+6      	; 0x68ee <printFloat+0x12c>
    68e8:	8e e2       	ldi	r24, 0x2E	; 46
    68ea:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    serial_write(buf[i-1]);
    68ee:	fe 01       	movw	r30, r28
    68f0:	e1 0f       	add	r30, r17
    68f2:	f1 1d       	adc	r31, r1
    68f4:	80 81       	ld	r24, Z
    68f6:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
  if (i == decimal_places) { // Fill in leading zero, if needed.
    buf[i++] = '0';
  }

  // Print the generated string.
  for (; i > 0; i--) {
    68fa:	11 50       	subi	r17, 0x01	; 1
    68fc:	99 f7       	brne	.-26     	; 0x68e4 <printFloat+0x122>
    if (i == decimal_places) { serial_write('.'); } // Insert decimal point in right place.
    serial_write(buf[i-1]);
  }
}
    68fe:	2d 96       	adiw	r28, 0x0d	; 13
    6900:	0f b6       	in	r0, 0x3f	; 63
    6902:	f8 94       	cli
    6904:	de bf       	out	0x3e, r29	; 62
    6906:	0f be       	out	0x3f, r0	; 63
    6908:	cd bf       	out	0x3d, r28	; 61
    690a:	df 91       	pop	r29
    690c:	cf 91       	pop	r28
    690e:	1f 91       	pop	r17
    6910:	0f 91       	pop	r16
    6912:	ff 90       	pop	r15
    6914:	ef 90       	pop	r14
    6916:	df 90       	pop	r13
    6918:	cf 90       	pop	r12
    691a:	bf 90       	pop	r11
    691c:	af 90       	pop	r10
    691e:	9f 90       	pop	r9
    6920:	8f 90       	pop	r8
    6922:	08 95       	ret

00006924 <printFloat_CoordValue>:
// Floating value printing handlers for special variables types used in Grbl and are defined
// in the config.h.
//  - CoordValue: Handles all position or coordinate values in inches or mm reporting.
//  - RateValue: Handles feed rate and current velocity in inches or mm reporting.
void printFloat_CoordValue(float n) {
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
    6924:	20 91 15 0f 	lds	r18, 0x0F15	; 0x800f15 <settings+0x45>
    6928:	20 ff       	sbrs	r18, 0
    692a:	09 c0       	rjmp	.+18     	; 0x693e <printFloat_CoordValue+0x1a>
    printFloat(n*INCH_PER_MM,N_DECIMAL_COORDVALUE_INCH);
    692c:	2b e8       	ldi	r18, 0x8B	; 139
    692e:	32 e4       	ldi	r19, 0x42	; 66
    6930:	41 e2       	ldi	r20, 0x21	; 33
    6932:	5d e3       	ldi	r21, 0x3D	; 61
    6934:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    6938:	44 e0       	ldi	r20, 0x04	; 4
    693a:	43 cf       	rjmp	.-378    	; 0x67c2 <printFloat>
    693c:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_COORDVALUE_MM);
    693e:	43 e0       	ldi	r20, 0x03	; 3
    6940:	40 cf       	rjmp	.-384    	; 0x67c2 <printFloat>
    6942:	08 95       	ret

00006944 <printFloat_RateValue>:
  }
}

void printFloat_RateValue(float n) {
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
    6944:	20 91 15 0f 	lds	r18, 0x0F15	; 0x800f15 <settings+0x45>
    6948:	20 ff       	sbrs	r18, 0
    694a:	09 c0       	rjmp	.+18     	; 0x695e <printFloat_RateValue+0x1a>
    printFloat(n*INCH_PER_MM,N_DECIMAL_RATEVALUE_INCH);
    694c:	2b e8       	ldi	r18, 0x8B	; 139
    694e:	32 e4       	ldi	r19, 0x42	; 66
    6950:	41 e2       	ldi	r20, 0x21	; 33
    6952:	5d e3       	ldi	r21, 0x3D	; 61
    6954:	0e 94 a3 41 	call	0x8346	; 0x8346 <__mulsf3>
    6958:	41 e0       	ldi	r20, 0x01	; 1
    695a:	33 cf       	rjmp	.-410    	; 0x67c2 <printFloat>
    695c:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_RATEVALUE_MM);
    695e:	40 e0       	ldi	r20, 0x00	; 0
    6960:	30 cf       	rjmp	.-416    	; 0x67c2 <printFloat>
    6962:	08 95       	ret

00006964 <probe_configure_invert_mask>:
// Called by probe_init() and the mc_probe() routines. Sets up the probe pin invert mask to
// appropriately set the pin logic according to setting for normal-high/normal-low operation
// and the probing cycle modes for toward-workpiece/away-from-workpiece.
void probe_configure_invert_mask(uint8_t is_probe_away)
{
  probe_invert_mask = 0; // Initialize as zero.
    6964:	10 92 25 0f 	sts	0x0F25, r1	; 0x800f25 <probe_invert_mask>
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_PROBE_PIN)) { probe_invert_mask ^= PROBE_MASK; }
    6968:	90 91 15 0f 	lds	r25, 0x0F15	; 0x800f15 <settings+0x45>
    696c:	99 23       	and	r25, r25
    696e:	1c f0       	brlt	.+6      	; 0x6976 <probe_configure_invert_mask+0x12>
    6970:	90 e8       	ldi	r25, 0x80	; 128
    6972:	90 93 25 0f 	sts	0x0F25, r25	; 0x800f25 <probe_invert_mask>
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
    6976:	88 23       	and	r24, r24
    6978:	29 f0       	breq	.+10     	; 0x6984 <probe_configure_invert_mask+0x20>
    697a:	80 91 25 0f 	lds	r24, 0x0F25	; 0x800f25 <probe_invert_mask>
    697e:	80 58       	subi	r24, 0x80	; 128
    6980:	80 93 25 0f 	sts	0x0F25, r24	; 0x800f25 <probe_invert_mask>
    6984:	08 95       	ret

00006986 <probe_init>:


// Probe pin initialization routine.
void probe_init()
{
  PROBE_DDR &= ~(PROBE_MASK); // Configure as input pins
    6986:	e7 e0       	ldi	r30, 0x07	; 7
    6988:	f1 e0       	ldi	r31, 0x01	; 1
    698a:	80 81       	ld	r24, Z
    698c:	8f 77       	andi	r24, 0x7F	; 127
    698e:	80 83       	st	Z, r24
  #ifdef DISABLE_PROBE_PIN_PULL_UP
    PROBE_PORT &= ~(PROBE_MASK); // Normal low operation. Requires external pull-down.
  #else
    PROBE_PORT |= PROBE_MASK;    // Enable internal pull-up resistors. Normal high operation.
    6990:	e8 e0       	ldi	r30, 0x08	; 8
    6992:	f1 e0       	ldi	r31, 0x01	; 1
    6994:	80 81       	ld	r24, Z
    6996:	80 68       	ori	r24, 0x80	; 128
    6998:	80 83       	st	Z, r24
  #endif
  probe_configure_invert_mask(false); // Initialize invert mask.
    699a:	80 e0       	ldi	r24, 0x00	; 0
    699c:	e3 cf       	rjmp	.-58     	; 0x6964 <probe_configure_invert_mask>
    699e:	08 95       	ret

000069a0 <probe_get_state>:
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
}


// Returns the probe pin state. Triggered = true. Called by gcode parser and probe state monitor.
uint8_t probe_get_state() { return((PROBE_PIN & PROBE_MASK) ^ probe_invert_mask); }
    69a0:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
    69a4:	80 78       	andi	r24, 0x80	; 128
    69a6:	90 91 25 0f 	lds	r25, 0x0F25	; 0x800f25 <probe_invert_mask>
    69aa:	89 27       	eor	r24, r25
    69ac:	08 95       	ret

000069ae <probe_state_monitor>:
// Monitors probe pin state and records the system position when detected. Called by the
// stepper ISR per ISR tick.
// NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
void probe_state_monitor()
{
  if (probe_get_state()) {
    69ae:	f8 df       	rcall	.-16     	; 0x69a0 <probe_get_state>
    69b0:	88 23       	and	r24, r24
    69b2:	81 f0       	breq	.+32     	; 0x69d4 <probe_state_monitor+0x26>
    sys_probe_state = PROBE_OFF;
    69b4:	10 92 32 0c 	sts	0x0C32, r1	; 0x800c32 <sys_probe_state>
    memcpy(sys_probe_position, sys_position, sizeof(sys_position));
    69b8:	8c e0       	ldi	r24, 0x0C	; 12
    69ba:	e3 e4       	ldi	r30, 0x43	; 67
    69bc:	fc e0       	ldi	r31, 0x0C	; 12
    69be:	a7 e3       	ldi	r26, 0x37	; 55
    69c0:	bc e0       	ldi	r27, 0x0C	; 12
    69c2:	01 90       	ld	r0, Z+
    69c4:	0d 92       	st	X+, r0
    69c6:	8a 95       	dec	r24
    69c8:	e1 f7       	brne	.-8      	; 0x69c2 <probe_state_monitor+0x14>
    bit_true(sys_rt_exec_state, EXEC_MOTION_CANCEL);
    69ca:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    69ce:	80 64       	ori	r24, 0x40	; 64
    69d0:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <sys_rt_exec_state>
    69d4:	08 95       	ret

000069d6 <report_util_line_feed>:
// and has been sent into protocol_execute_line() routine to be executed by Grbl.
void report_echo_line_received(char *line)
{
  printPgmString(PSTR("[echo: ")); printString(line);
  report_util_feedback_line_feed();
}
    69d6:	8f e1       	ldi	r24, 0x1F	; 31
    69d8:	95 e0       	ldi	r25, 0x05	; 5
    69da:	32 ce       	rjmp	.-924    	; 0x6640 <printPgmString>
    69dc:	08 95       	ret

000069de <report_util_feedback_line_feed>:
    69de:	8d e5       	ldi	r24, 0x5D	; 93
    69e0:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    69e4:	f8 cf       	rjmp	.-16     	; 0x69d6 <report_util_line_feed>
    69e6:	08 95       	ret

000069e8 <report_util_axis_values>:
    69e8:	0f 93       	push	r16
    69ea:	1f 93       	push	r17
    69ec:	cf 93       	push	r28
    69ee:	8c 01       	movw	r16, r24
    69f0:	c0 e0       	ldi	r28, 0x00	; 0
    69f2:	f8 01       	movw	r30, r16
    69f4:	61 91       	ld	r22, Z+
    69f6:	71 91       	ld	r23, Z+
    69f8:	81 91       	ld	r24, Z+
    69fa:	91 91       	ld	r25, Z+
    69fc:	8f 01       	movw	r16, r30
    69fe:	92 df       	rcall	.-220    	; 0x6924 <printFloat_CoordValue>
    6a00:	c2 30       	cpi	r28, 0x02	; 2
    6a02:	18 f4       	brcc	.+6      	; 0x6a0a <report_util_axis_values+0x22>
    6a04:	8c e2       	ldi	r24, 0x2C	; 44
    6a06:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    6a0a:	cf 5f       	subi	r28, 0xFF	; 255
    6a0c:	c3 30       	cpi	r28, 0x03	; 3
    6a0e:	89 f7       	brne	.-30     	; 0x69f2 <report_util_axis_values+0xa>
    6a10:	cf 91       	pop	r28
    6a12:	1f 91       	pop	r17
    6a14:	0f 91       	pop	r16
    6a16:	08 95       	ret

00006a18 <report_util_setting_prefix>:
    6a18:	cf 93       	push	r28
    6a1a:	c8 2f       	mov	r28, r24
    6a1c:	84 e2       	ldi	r24, 0x24	; 36
    6a1e:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    6a22:	8c 2f       	mov	r24, r28
    6a24:	1f de       	rcall	.-962    	; 0x6664 <print_uint8_base10>
    6a26:	8d e3       	ldi	r24, 0x3D	; 61
    6a28:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    6a2c:	cf 91       	pop	r28
    6a2e:	08 95       	ret

00006a30 <report_util_uint8_setting>:
    6a30:	cf 93       	push	r28
    6a32:	c6 2f       	mov	r28, r22
    6a34:	f1 df       	rcall	.-30     	; 0x6a18 <report_util_setting_prefix>
    6a36:	8c 2f       	mov	r24, r28
    6a38:	15 de       	rcall	.-982    	; 0x6664 <print_uint8_base10>
    6a3a:	cd df       	rcall	.-102    	; 0x69d6 <report_util_line_feed>
    6a3c:	cf 91       	pop	r28
    6a3e:	08 95       	ret

00006a40 <report_util_float_setting>:
    6a40:	cf 92       	push	r12
    6a42:	df 92       	push	r13
    6a44:	ef 92       	push	r14
    6a46:	ff 92       	push	r15
    6a48:	cf 93       	push	r28
    6a4a:	6a 01       	movw	r12, r20
    6a4c:	7b 01       	movw	r14, r22
    6a4e:	c2 2f       	mov	r28, r18
    6a50:	e3 df       	rcall	.-58     	; 0x6a18 <report_util_setting_prefix>
    6a52:	4c 2f       	mov	r20, r28
    6a54:	c7 01       	movw	r24, r14
    6a56:	b6 01       	movw	r22, r12
    6a58:	b4 de       	rcall	.-664    	; 0x67c2 <printFloat>
    6a5a:	bd df       	rcall	.-134    	; 0x69d6 <report_util_line_feed>
    6a5c:	cf 91       	pop	r28
    6a5e:	ff 90       	pop	r15
    6a60:	ef 90       	pop	r14
    6a62:	df 90       	pop	r13
    6a64:	cf 90       	pop	r12
    6a66:	08 95       	ret

00006a68 <report_status_message>:
    6a68:	cf 93       	push	r28
    6a6a:	c8 2f       	mov	r28, r24
    6a6c:	81 11       	cpse	r24, r1
    6a6e:	04 c0       	rjmp	.+8      	; 0x6a78 <report_status_message+0x10>
    6a70:	89 e2       	ldi	r24, 0x29	; 41
    6a72:	95 e0       	ldi	r25, 0x05	; 5
    6a74:	e5 dd       	rcall	.-1078   	; 0x6640 <printPgmString>
    6a76:	06 c0       	rjmp	.+12     	; 0x6a84 <report_status_message+0x1c>
    6a78:	82 e2       	ldi	r24, 0x22	; 34
    6a7a:	95 e0       	ldi	r25, 0x05	; 5
    6a7c:	e1 dd       	rcall	.-1086   	; 0x6640 <printPgmString>
    6a7e:	8c 2f       	mov	r24, r28
    6a80:	f1 dd       	rcall	.-1054   	; 0x6664 <print_uint8_base10>
    6a82:	a9 df       	rcall	.-174    	; 0x69d6 <report_util_line_feed>
    6a84:	cf 91       	pop	r28
    6a86:	08 95       	ret

00006a88 <report_alarm_message>:
    6a88:	cf 93       	push	r28
    6a8a:	c8 2f       	mov	r28, r24
    6a8c:	88 e1       	ldi	r24, 0x18	; 24
    6a8e:	95 e0       	ldi	r25, 0x05	; 5
    6a90:	d7 dd       	rcall	.-1106   	; 0x6640 <printPgmString>
    6a92:	8c 2f       	mov	r24, r28
    6a94:	e7 dd       	rcall	.-1074   	; 0x6664 <print_uint8_base10>
    6a96:	9f df       	rcall	.-194    	; 0x69d6 <report_util_line_feed>
    6a98:	84 ef       	ldi	r24, 0xF4	; 244
    6a9a:	91 e0       	ldi	r25, 0x01	; 1
    6a9c:	b7 d9       	rcall	.-3218   	; 0x5e0c <delay_ms>
    6a9e:	cf 91       	pop	r28
    6aa0:	08 95       	ret

00006aa2 <report_RPM_state>:
    6aa2:	cf 92       	push	r12
    6aa4:	df 92       	push	r13
    6aa6:	ef 92       	push	r14
    6aa8:	ff 92       	push	r15
    6aaa:	c0 90 1a 0c 	lds	r12, 0x0C1A	; 0x800c1a <sys_sync_time_passed>
    6aae:	d0 90 1b 0c 	lds	r13, 0x0C1B	; 0x800c1b <sys_sync_time_passed+0x1>
    6ab2:	e0 90 1c 0c 	lds	r14, 0x0C1C	; 0x800c1c <sys_sync_time_passed+0x2>
    6ab6:	f0 90 1d 0c 	lds	r15, 0x0C1D	; 0x800c1d <sys_sync_time_passed+0x3>
    6aba:	8a ef       	ldi	r24, 0xFA	; 250
    6abc:	94 e0       	ldi	r25, 0x04	; 4
    6abe:	c0 dd       	rcall	.-1152   	; 0x6640 <printPgmString>
    6ac0:	c7 01       	movw	r24, r14
    6ac2:	b6 01       	movw	r22, r12
    6ac4:	66 0f       	add	r22, r22
    6ac6:	77 1f       	adc	r23, r23
    6ac8:	88 1f       	adc	r24, r24
    6aca:	99 1f       	adc	r25, r25
    6acc:	66 0f       	add	r22, r22
    6ace:	77 1f       	adc	r23, r23
    6ad0:	88 1f       	adc	r24, r24
    6ad2:	99 1f       	adc	r25, r25
    6ad4:	0e 94 05 40 	call	0x800a	; 0x800a <__floatunsisf>
    6ad8:	9b 01       	movw	r18, r22
    6ada:	ac 01       	movw	r20, r24
    6adc:	60 ec       	ldi	r22, 0xC0	; 192
    6ade:	71 ee       	ldi	r23, 0xE1	; 225
    6ae0:	84 e6       	ldi	r24, 0x64	; 100
    6ae2:	9c e4       	ldi	r25, 0x4C	; 76
    6ae4:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__divsf3>
    6ae8:	43 e0       	ldi	r20, 0x03	; 3
    6aea:	6b de       	rcall	.-810    	; 0x67c2 <printFloat>
    6aec:	ff 90       	pop	r15
    6aee:	ef 90       	pop	r14
    6af0:	df 90       	pop	r13
    6af2:	cf 90       	pop	r12
    6af4:	08 95       	ret

00006af6 <report_synchronization_state>:
    6af6:	83 e1       	ldi	r24, 0x13	; 19
    6af8:	95 e0       	ldi	r25, 0x05	; 5
    6afa:	a2 dd       	rcall	.-1212   	; 0x6640 <printPgmString>
    6afc:	60 91 55 0c 	lds	r22, 0x0C55	; 0x800c55 <sys_index_pulse_count>
    6b00:	70 e0       	ldi	r23, 0x00	; 0
    6b02:	80 e0       	ldi	r24, 0x00	; 0
    6b04:	90 e0       	ldi	r25, 0x00	; 0
    6b06:	ed dd       	rcall	.-1062   	; 0x66e2 <print_uint32_base10>
    6b08:	8d e0       	ldi	r24, 0x0D	; 13
    6b0a:	95 e0       	ldi	r25, 0x05	; 5
    6b0c:	99 dd       	rcall	.-1230   	; 0x6640 <printPgmString>
    6b0e:	60 91 15 0c 	lds	r22, 0x0C15	; 0x800c15 <sys_synchronization_pulse_count>
    6b12:	70 91 16 0c 	lds	r23, 0x0C16	; 0x800c16 <sys_synchronization_pulse_count+0x1>
    6b16:	80 91 17 0c 	lds	r24, 0x0C17	; 0x800c17 <sys_synchronization_pulse_count+0x2>
    6b1a:	90 91 18 0c 	lds	r25, 0x0C18	; 0x800c18 <sys_synchronization_pulse_count+0x3>
    6b1e:	e1 dd       	rcall	.-1086   	; 0x66e2 <print_uint32_base10>
    6b20:	87 e0       	ldi	r24, 0x07	; 7
    6b22:	95 e0       	ldi	r25, 0x05	; 5
    6b24:	8d dd       	rcall	.-1254   	; 0x6640 <printPgmString>
    6b26:	60 91 4f 0c 	lds	r22, 0x0C4F	; 0x800c4f <sys_sync_time>
    6b2a:	70 91 50 0c 	lds	r23, 0x0C50	; 0x800c50 <sys_sync_time+0x1>
    6b2e:	80 91 51 0c 	lds	r24, 0x0C51	; 0x800c51 <sys_sync_time+0x2>
    6b32:	90 91 52 0c 	lds	r25, 0x0C52	; 0x800c52 <sys_sync_time+0x3>
    6b36:	d5 dd       	rcall	.-1110   	; 0x66e2 <print_uint32_base10>
    6b38:	81 e0       	ldi	r24, 0x01	; 1
    6b3a:	95 e0       	ldi	r25, 0x05	; 5
    6b3c:	81 dd       	rcall	.-1278   	; 0x6640 <printPgmString>
    6b3e:	60 91 1a 0c 	lds	r22, 0x0C1A	; 0x800c1a <sys_sync_time_passed>
    6b42:	70 91 1b 0c 	lds	r23, 0x0C1B	; 0x800c1b <sys_sync_time_passed+0x1>
    6b46:	80 91 1c 0c 	lds	r24, 0x0C1C	; 0x800c1c <sys_sync_time_passed+0x2>
    6b4a:	90 91 1d 0c 	lds	r25, 0x0C1D	; 0x800c1d <sys_sync_time_passed+0x3>
    6b4e:	c9 dd       	rcall	.-1134   	; 0x66e2 <print_uint32_base10>
    6b50:	a8 df       	rcall	.-176    	; 0x6aa2 <report_RPM_state>
    6b52:	41 cf       	rjmp	.-382    	; 0x69d6 <report_util_line_feed>
    6b54:	08 95       	ret

00006b56 <report_feedback_message>:
    6b56:	cf 93       	push	r28
    6b58:	c8 2f       	mov	r28, r24
    6b5a:	84 ef       	ldi	r24, 0xF4	; 244
    6b5c:	94 e0       	ldi	r25, 0x04	; 4
    6b5e:	70 dd       	rcall	.-1312   	; 0x6640 <printPgmString>
    6b60:	8c 2f       	mov	r24, r28
    6b62:	90 e0       	ldi	r25, 0x00	; 0
    6b64:	fc 01       	movw	r30, r24
    6b66:	31 97       	sbiw	r30, 0x01	; 1
    6b68:	eb 30       	cpi	r30, 0x0B	; 11
    6b6a:	f1 05       	cpc	r31, r1
    6b6c:	88 f5       	brcc	.+98     	; 0x6bd0 <report_feedback_message+0x7a>
    6b6e:	88 27       	eor	r24, r24
    6b70:	ec 5b       	subi	r30, 0xBC	; 188
    6b72:	fe 4f       	sbci	r31, 0xFE	; 254
    6b74:	8f 4f       	sbci	r24, 0xFF	; 255
    6b76:	0c 94 b2 42 	jmp	0x8564	; 0x8564 <__tablejump2__>
    6b7a:	82 ee       	ldi	r24, 0xE2	; 226
    6b7c:	94 e0       	ldi	r25, 0x04	; 4
    6b7e:	60 dd       	rcall	.-1344   	; 0x6640 <printPgmString>
    6b80:	27 c0       	rjmp	.+78     	; 0x6bd0 <report_feedback_message+0x7a>
    6b82:	8e ec       	ldi	r24, 0xCE	; 206
    6b84:	94 e0       	ldi	r25, 0x04	; 4
    6b86:	5c dd       	rcall	.-1352   	; 0x6640 <printPgmString>
    6b88:	23 c0       	rjmp	.+70     	; 0x6bd0 <report_feedback_message+0x7a>
    6b8a:	8c eb       	ldi	r24, 0xBC	; 188
    6b8c:	94 e0       	ldi	r25, 0x04	; 4
    6b8e:	58 dd       	rcall	.-1360   	; 0x6640 <printPgmString>
    6b90:	1f c0       	rjmp	.+62     	; 0x6bd0 <report_feedback_message+0x7a>
    6b92:	84 eb       	ldi	r24, 0xB4	; 180
    6b94:	94 e0       	ldi	r25, 0x04	; 4
    6b96:	54 dd       	rcall	.-1368   	; 0x6640 <printPgmString>
    6b98:	1b c0       	rjmp	.+54     	; 0x6bd0 <report_feedback_message+0x7a>
    6b9a:	8b ea       	ldi	r24, 0xAB	; 171
    6b9c:	94 e0       	ldi	r25, 0x04	; 4
    6b9e:	50 dd       	rcall	.-1376   	; 0x6640 <printPgmString>
    6ba0:	17 c0       	rjmp	.+46     	; 0x6bd0 <report_feedback_message+0x7a>
    6ba2:	80 ea       	ldi	r24, 0xA0	; 160
    6ba4:	94 e0       	ldi	r25, 0x04	; 4
    6ba6:	4c dd       	rcall	.-1384   	; 0x6640 <printPgmString>
    6ba8:	13 c0       	rjmp	.+38     	; 0x6bd0 <report_feedback_message+0x7a>
    6baa:	83 e9       	ldi	r24, 0x93	; 147
    6bac:	94 e0       	ldi	r25, 0x04	; 4
    6bae:	48 dd       	rcall	.-1392   	; 0x6640 <printPgmString>
    6bb0:	0f c0       	rjmp	.+30     	; 0x6bd0 <report_feedback_message+0x7a>
    6bb2:	8b e8       	ldi	r24, 0x8B	; 139
    6bb4:	94 e0       	ldi	r25, 0x04	; 4
    6bb6:	44 dd       	rcall	.-1400   	; 0x6640 <printPgmString>
    6bb8:	0b c0       	rjmp	.+22     	; 0x6bd0 <report_feedback_message+0x7a>
    6bba:	88 e7       	ldi	r24, 0x78	; 120
    6bbc:	94 e0       	ldi	r25, 0x04	; 4
    6bbe:	40 dd       	rcall	.-1408   	; 0x6640 <printPgmString>
    6bc0:	07 c0       	rjmp	.+14     	; 0x6bd0 <report_feedback_message+0x7a>
    6bc2:	86 e6       	ldi	r24, 0x66	; 102
    6bc4:	94 e0       	ldi	r25, 0x04	; 4
    6bc6:	3c dd       	rcall	.-1416   	; 0x6640 <printPgmString>
    6bc8:	03 c0       	rjmp	.+6      	; 0x6bd0 <report_feedback_message+0x7a>
    6bca:	8d e5       	ldi	r24, 0x5D	; 93
    6bcc:	94 e0       	ldi	r25, 0x04	; 4
    6bce:	38 dd       	rcall	.-1424   	; 0x6640 <printPgmString>
    6bd0:	06 df       	rcall	.-500    	; 0x69de <report_util_feedback_line_feed>
    6bd2:	cf 91       	pop	r28
    6bd4:	08 95       	ret

00006bd6 <report_init_message>:
    6bd6:	80 e4       	ldi	r24, 0x40	; 64
    6bd8:	94 e0       	ldi	r25, 0x04	; 4
    6bda:	32 cd       	rjmp	.-1436   	; 0x6640 <printPgmString>
    6bdc:	08 95       	ret

00006bde <report_grbl_help>:
    6bde:	86 ef       	ldi	r24, 0xF6	; 246
    6be0:	93 e0       	ldi	r25, 0x03	; 3
    6be2:	2e cd       	rjmp	.-1444   	; 0x6640 <printPgmString>
    6be4:	08 95       	ret

00006be6 <report_grbl_settings>:
    6be6:	ef 92       	push	r14
    6be8:	ff 92       	push	r15
    6bea:	0f 93       	push	r16
    6bec:	1f 93       	push	r17
    6bee:	cf 93       	push	r28
    6bf0:	df 93       	push	r29
    6bf2:	00 ed       	ldi	r16, 0xD0	; 208
    6bf4:	1e e0       	ldi	r17, 0x0E	; 14
    6bf6:	f8 01       	movw	r30, r16
    6bf8:	60 a9       	ldd	r22, Z+48	; 0x30
    6bfa:	70 e0       	ldi	r23, 0x00	; 0
    6bfc:	80 e0       	ldi	r24, 0x00	; 0
    6bfe:	18 df       	rcall	.-464    	; 0x6a30 <report_util_uint8_setting>
    6c00:	f8 01       	movw	r30, r16
    6c02:	63 a9       	ldd	r22, Z+51	; 0x33
    6c04:	70 e0       	ldi	r23, 0x00	; 0
    6c06:	81 e0       	ldi	r24, 0x01	; 1
    6c08:	13 df       	rcall	.-474    	; 0x6a30 <report_util_uint8_setting>
    6c0a:	f8 01       	movw	r30, r16
    6c0c:	61 a9       	ldd	r22, Z+49	; 0x31
    6c0e:	70 e0       	ldi	r23, 0x00	; 0
    6c10:	82 e0       	ldi	r24, 0x02	; 2
    6c12:	0e df       	rcall	.-484    	; 0x6a30 <report_util_uint8_setting>
    6c14:	f8 01       	movw	r30, r16
    6c16:	62 a9       	ldd	r22, Z+50	; 0x32
    6c18:	70 e0       	ldi	r23, 0x00	; 0
    6c1a:	83 e0       	ldi	r24, 0x03	; 3
    6c1c:	09 df       	rcall	.-494    	; 0x6a30 <report_util_uint8_setting>
    6c1e:	c5 e1       	ldi	r28, 0x15	; 21
    6c20:	df e0       	ldi	r29, 0x0F	; 15
    6c22:	68 81       	ld	r22, Y
    6c24:	62 fb       	bst	r22, 2
    6c26:	66 27       	eor	r22, r22
    6c28:	60 f9       	bld	r22, 0
    6c2a:	70 e0       	ldi	r23, 0x00	; 0
    6c2c:	84 e0       	ldi	r24, 0x04	; 4
    6c2e:	00 df       	rcall	.-512    	; 0x6a30 <report_util_uint8_setting>
    6c30:	68 81       	ld	r22, Y
    6c32:	66 fb       	bst	r22, 6
    6c34:	66 27       	eor	r22, r22
    6c36:	60 f9       	bld	r22, 0
    6c38:	70 e0       	ldi	r23, 0x00	; 0
    6c3a:	85 e0       	ldi	r24, 0x05	; 5
    6c3c:	f9 de       	rcall	.-526    	; 0x6a30 <report_util_uint8_setting>
    6c3e:	88 81       	ld	r24, Y
    6c40:	08 2e       	mov	r0, r24
    6c42:	00 0c       	add	r0, r0
    6c44:	99 0b       	sbc	r25, r25
    6c46:	69 2f       	mov	r22, r25
    6c48:	66 1f       	adc	r22, r22
    6c4a:	66 27       	eor	r22, r22
    6c4c:	66 1f       	adc	r22, r22
    6c4e:	70 e0       	ldi	r23, 0x00	; 0
    6c50:	86 e0       	ldi	r24, 0x06	; 6
    6c52:	ee de       	rcall	.-548    	; 0x6a30 <report_util_uint8_setting>
    6c54:	f8 01       	movw	r30, r16
    6c56:	64 a9       	ldd	r22, Z+52	; 0x34
    6c58:	70 e0       	ldi	r23, 0x00	; 0
    6c5a:	8a e0       	ldi	r24, 0x0A	; 10
    6c5c:	e9 de       	rcall	.-558    	; 0x6a30 <report_util_uint8_setting>
    6c5e:	f8 01       	movw	r30, r16
    6c60:	45 a9       	ldd	r20, Z+53	; 0x35
    6c62:	56 a9       	ldd	r21, Z+54	; 0x36
    6c64:	67 a9       	ldd	r22, Z+55	; 0x37
    6c66:	70 ad       	ldd	r23, Z+56	; 0x38
    6c68:	23 e0       	ldi	r18, 0x03	; 3
    6c6a:	8b e0       	ldi	r24, 0x0B	; 11
    6c6c:	e9 de       	rcall	.-558    	; 0x6a40 <report_util_float_setting>
    6c6e:	f8 01       	movw	r30, r16
    6c70:	41 ad       	ldd	r20, Z+57	; 0x39
    6c72:	52 ad       	ldd	r21, Z+58	; 0x3a
    6c74:	63 ad       	ldd	r22, Z+59	; 0x3b
    6c76:	74 ad       	ldd	r23, Z+60	; 0x3c
    6c78:	23 e0       	ldi	r18, 0x03	; 3
    6c7a:	8c e0       	ldi	r24, 0x0C	; 12
    6c7c:	e1 de       	rcall	.-574    	; 0x6a40 <report_util_float_setting>
    6c7e:	68 81       	ld	r22, Y
    6c80:	61 70       	andi	r22, 0x01	; 1
    6c82:	70 e0       	ldi	r23, 0x00	; 0
    6c84:	8d e0       	ldi	r24, 0x0D	; 13
    6c86:	d4 de       	rcall	.-600    	; 0x6a30 <report_util_uint8_setting>
    6c88:	68 81       	ld	r22, Y
    6c8a:	65 fb       	bst	r22, 5
    6c8c:	66 27       	eor	r22, r22
    6c8e:	60 f9       	bld	r22, 0
    6c90:	70 e0       	ldi	r23, 0x00	; 0
    6c92:	84 e1       	ldi	r24, 0x14	; 20
    6c94:	cd de       	rcall	.-614    	; 0x6a30 <report_util_uint8_setting>
    6c96:	68 81       	ld	r22, Y
    6c98:	63 fb       	bst	r22, 3
    6c9a:	66 27       	eor	r22, r22
    6c9c:	60 f9       	bld	r22, 0
    6c9e:	70 e0       	ldi	r23, 0x00	; 0
    6ca0:	85 e1       	ldi	r24, 0x15	; 21
    6ca2:	c6 de       	rcall	.-628    	; 0x6a30 <report_util_uint8_setting>
    6ca4:	68 81       	ld	r22, Y
    6ca6:	62 95       	swap	r22
    6ca8:	61 70       	andi	r22, 0x01	; 1
    6caa:	70 e0       	ldi	r23, 0x00	; 0
    6cac:	86 e1       	ldi	r24, 0x16	; 22
    6cae:	c0 de       	rcall	.-640    	; 0x6a30 <report_util_uint8_setting>
    6cb0:	60 91 16 0f 	lds	r22, 0x0F16	; 0x800f16 <settings+0x46>
    6cb4:	70 e0       	ldi	r23, 0x00	; 0
    6cb6:	87 e1       	ldi	r24, 0x17	; 23
    6cb8:	bb de       	rcall	.-650    	; 0x6a30 <report_util_uint8_setting>
    6cba:	40 91 17 0f 	lds	r20, 0x0F17	; 0x800f17 <settings+0x47>
    6cbe:	50 91 18 0f 	lds	r21, 0x0F18	; 0x800f18 <settings+0x48>
    6cc2:	60 91 19 0f 	lds	r22, 0x0F19	; 0x800f19 <settings+0x49>
    6cc6:	70 91 1a 0f 	lds	r23, 0x0F1A	; 0x800f1a <settings+0x4a>
    6cca:	23 e0       	ldi	r18, 0x03	; 3
    6ccc:	88 e1       	ldi	r24, 0x18	; 24
    6cce:	b8 de       	rcall	.-656    	; 0x6a40 <report_util_float_setting>
    6cd0:	40 91 1b 0f 	lds	r20, 0x0F1B	; 0x800f1b <settings+0x4b>
    6cd4:	50 91 1c 0f 	lds	r21, 0x0F1C	; 0x800f1c <settings+0x4c>
    6cd8:	60 91 1d 0f 	lds	r22, 0x0F1D	; 0x800f1d <settings+0x4d>
    6cdc:	70 91 1e 0f 	lds	r23, 0x0F1E	; 0x800f1e <settings+0x4e>
    6ce0:	23 e0       	ldi	r18, 0x03	; 3
    6ce2:	89 e1       	ldi	r24, 0x19	; 25
    6ce4:	ad de       	rcall	.-678    	; 0x6a40 <report_util_float_setting>
    6ce6:	60 91 1f 0f 	lds	r22, 0x0F1F	; 0x800f1f <settings+0x4f>
    6cea:	70 91 20 0f 	lds	r23, 0x0F20	; 0x800f20 <settings+0x50>
    6cee:	8a e1       	ldi	r24, 0x1A	; 26
    6cf0:	9f de       	rcall	.-706    	; 0x6a30 <report_util_uint8_setting>
    6cf2:	40 91 21 0f 	lds	r20, 0x0F21	; 0x800f21 <settings+0x51>
    6cf6:	50 91 22 0f 	lds	r21, 0x0F22	; 0x800f22 <settings+0x52>
    6cfa:	60 91 23 0f 	lds	r22, 0x0F23	; 0x800f23 <settings+0x53>
    6cfe:	70 91 24 0f 	lds	r23, 0x0F24	; 0x800f24 <settings+0x54>
    6d02:	23 e0       	ldi	r18, 0x03	; 3
    6d04:	8b e1       	ldi	r24, 0x1B	; 27
    6d06:	9c de       	rcall	.-712    	; 0x6a40 <report_util_float_setting>
    6d08:	40 91 0d 0f 	lds	r20, 0x0F0D	; 0x800f0d <settings+0x3d>
    6d0c:	50 91 0e 0f 	lds	r21, 0x0F0E	; 0x800f0e <settings+0x3e>
    6d10:	60 91 0f 0f 	lds	r22, 0x0F0F	; 0x800f0f <settings+0x3f>
    6d14:	70 91 10 0f 	lds	r23, 0x0F10	; 0x800f10 <settings+0x40>
    6d18:	20 e0       	ldi	r18, 0x00	; 0
    6d1a:	8e e1       	ldi	r24, 0x1E	; 30
    6d1c:	91 de       	rcall	.-734    	; 0x6a40 <report_util_float_setting>
    6d1e:	40 91 11 0f 	lds	r20, 0x0F11	; 0x800f11 <settings+0x41>
    6d22:	50 91 12 0f 	lds	r21, 0x0F12	; 0x800f12 <settings+0x42>
    6d26:	60 91 13 0f 	lds	r22, 0x0F13	; 0x800f13 <settings+0x43>
    6d2a:	70 91 14 0f 	lds	r23, 0x0F14	; 0x800f14 <settings+0x44>
    6d2e:	20 e0       	ldi	r18, 0x00	; 0
    6d30:	8f e1       	ldi	r24, 0x1F	; 31
    6d32:	86 de       	rcall	.-756    	; 0x6a40 <report_util_float_setting>
    6d34:	68 81       	ld	r22, Y
    6d36:	66 95       	lsr	r22
    6d38:	61 70       	andi	r22, 0x01	; 1
    6d3a:	70 e0       	ldi	r23, 0x00	; 0
    6d3c:	80 e2       	ldi	r24, 0x20	; 32
    6d3e:	78 de       	rcall	.-784    	; 0x6a30 <report_util_uint8_setting>
    6d40:	0f 2e       	mov	r0, r31
    6d42:	f4 e6       	ldi	r31, 0x64	; 100
    6d44:	ff 2e       	mov	r15, r31
    6d46:	f0 2d       	mov	r31, r0
    6d48:	d0 e0       	ldi	r29, 0x00	; 0
    6d4a:	3f c0       	rjmp	.+126    	; 0x6dca <report_grbl_settings+0x1e4>
    6d4c:	d1 30       	cpi	r29, 0x01	; 1
    6d4e:	79 f0       	breq	.+30     	; 0x6d6e <report_grbl_settings+0x188>
    6d50:	28 f0       	brcs	.+10     	; 0x6d5c <report_grbl_settings+0x176>
    6d52:	d2 30       	cpi	r29, 0x02	; 2
    6d54:	a9 f0       	breq	.+42     	; 0x6d80 <report_grbl_settings+0x19a>
    6d56:	d3 30       	cpi	r29, 0x03	; 3
    6d58:	21 f1       	breq	.+72     	; 0x6da2 <report_grbl_settings+0x1bc>
    6d5a:	2c c0       	rjmp	.+88     	; 0x6db4 <report_grbl_settings+0x1ce>
    6d5c:	f8 01       	movw	r30, r16
    6d5e:	40 81       	ld	r20, Z
    6d60:	51 81       	ldd	r21, Z+1	; 0x01
    6d62:	62 81       	ldd	r22, Z+2	; 0x02
    6d64:	73 81       	ldd	r23, Z+3	; 0x03
    6d66:	23 e0       	ldi	r18, 0x03	; 3
    6d68:	8c 2f       	mov	r24, r28
    6d6a:	6a de       	rcall	.-812    	; 0x6a40 <report_util_float_setting>
    6d6c:	23 c0       	rjmp	.+70     	; 0x6db4 <report_grbl_settings+0x1ce>
    6d6e:	f8 01       	movw	r30, r16
    6d70:	44 85       	ldd	r20, Z+12	; 0x0c
    6d72:	55 85       	ldd	r21, Z+13	; 0x0d
    6d74:	66 85       	ldd	r22, Z+14	; 0x0e
    6d76:	77 85       	ldd	r23, Z+15	; 0x0f
    6d78:	23 e0       	ldi	r18, 0x03	; 3
    6d7a:	8c 2f       	mov	r24, r28
    6d7c:	61 de       	rcall	.-830    	; 0x6a40 <report_util_float_setting>
    6d7e:	1a c0       	rjmp	.+52     	; 0x6db4 <report_grbl_settings+0x1ce>
    6d80:	20 e0       	ldi	r18, 0x00	; 0
    6d82:	30 e0       	ldi	r19, 0x00	; 0
    6d84:	41 e6       	ldi	r20, 0x61	; 97
    6d86:	55 e4       	ldi	r21, 0x45	; 69
    6d88:	f8 01       	movw	r30, r16
    6d8a:	60 8d       	ldd	r22, Z+24	; 0x18
    6d8c:	71 8d       	ldd	r23, Z+25	; 0x19
    6d8e:	82 8d       	ldd	r24, Z+26	; 0x1a
    6d90:	93 8d       	ldd	r25, Z+27	; 0x1b
    6d92:	0e 94 6c 3f 	call	0x7ed8	; 0x7ed8 <__divsf3>
    6d96:	ab 01       	movw	r20, r22
    6d98:	bc 01       	movw	r22, r24
    6d9a:	23 e0       	ldi	r18, 0x03	; 3
    6d9c:	8c 2f       	mov	r24, r28
    6d9e:	50 de       	rcall	.-864    	; 0x6a40 <report_util_float_setting>
    6da0:	09 c0       	rjmp	.+18     	; 0x6db4 <report_grbl_settings+0x1ce>
    6da2:	f8 01       	movw	r30, r16
    6da4:	44 a1       	ldd	r20, Z+36	; 0x24
    6da6:	55 a1       	ldd	r21, Z+37	; 0x25
    6da8:	66 a1       	ldd	r22, Z+38	; 0x26
    6daa:	77 a1       	ldd	r23, Z+39	; 0x27
    6dac:	70 58       	subi	r23, 0x80	; 128
    6dae:	23 e0       	ldi	r18, 0x03	; 3
    6db0:	8c 2f       	mov	r24, r28
    6db2:	46 de       	rcall	.-884    	; 0x6a40 <report_util_float_setting>
    6db4:	0c 5f       	subi	r16, 0xFC	; 252
    6db6:	1f 4f       	sbci	r17, 0xFF	; 255
    6db8:	cf 5f       	subi	r28, 0xFF	; 255
    6dba:	ce 11       	cpse	r28, r14
    6dbc:	c7 cf       	rjmp	.-114    	; 0x6d4c <report_grbl_settings+0x166>
    6dbe:	fa e0       	ldi	r31, 0x0A	; 10
    6dc0:	ff 0e       	add	r15, r31
    6dc2:	df 5f       	subi	r29, 0xFF	; 255
    6dc4:	8c e8       	ldi	r24, 0x8C	; 140
    6dc6:	f8 16       	cp	r15, r24
    6dc8:	49 f0       	breq	.+18     	; 0x6ddc <report_grbl_settings+0x1f6>
    6dca:	00 ed       	ldi	r16, 0xD0	; 208
    6dcc:	1e e0       	ldi	r17, 0x0E	; 14
    6dce:	0f 2e       	mov	r0, r31
    6dd0:	f3 e0       	ldi	r31, 0x03	; 3
    6dd2:	ef 2e       	mov	r14, r31
    6dd4:	f0 2d       	mov	r31, r0
    6dd6:	ef 0c       	add	r14, r15
    6dd8:	cf 2d       	mov	r28, r15
    6dda:	b8 cf       	rjmp	.-144    	; 0x6d4c <report_grbl_settings+0x166>
    6ddc:	df 91       	pop	r29
    6dde:	cf 91       	pop	r28
    6de0:	1f 91       	pop	r17
    6de2:	0f 91       	pop	r16
    6de4:	ff 90       	pop	r15
    6de6:	ef 90       	pop	r14
    6de8:	08 95       	ret

00006dea <report_probe_parameters>:
    6dea:	cf 93       	push	r28
    6dec:	df 93       	push	r29
    6dee:	cd b7       	in	r28, 0x3d	; 61
    6df0:	de b7       	in	r29, 0x3e	; 62
    6df2:	2c 97       	sbiw	r28, 0x0c	; 12
    6df4:	0f b6       	in	r0, 0x3f	; 63
    6df6:	f8 94       	cli
    6df8:	de bf       	out	0x3e, r29	; 62
    6dfa:	0f be       	out	0x3f, r0	; 63
    6dfc:	cd bf       	out	0x3d, r28	; 61
    6dfe:	80 ef       	ldi	r24, 0xF0	; 240
    6e00:	93 e0       	ldi	r25, 0x03	; 3
    6e02:	1e dc       	rcall	.-1988   	; 0x6640 <printPgmString>
    6e04:	67 e3       	ldi	r22, 0x37	; 55
    6e06:	7c e0       	ldi	r23, 0x0C	; 12
    6e08:	ce 01       	movw	r24, r28
    6e0a:	01 96       	adiw	r24, 0x01	; 1
    6e0c:	0f d4       	rcall	.+2078   	; 0x762c <system_convert_array_steps_to_mpos>
    6e0e:	ce 01       	movw	r24, r28
    6e10:	01 96       	adiw	r24, 0x01	; 1
    6e12:	ea dd       	rcall	.-1068   	; 0x69e8 <report_util_axis_values>
    6e14:	8a e3       	ldi	r24, 0x3A	; 58
    6e16:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    6e1a:	80 91 23 0c 	lds	r24, 0x0C23	; 0x800c23 <sys+0x5>
    6e1e:	22 dc       	rcall	.-1980   	; 0x6664 <print_uint8_base10>
    6e20:	de dd       	rcall	.-1092   	; 0x69de <report_util_feedback_line_feed>
    6e22:	2c 96       	adiw	r28, 0x0c	; 12
    6e24:	0f b6       	in	r0, 0x3f	; 63
    6e26:	f8 94       	cli
    6e28:	de bf       	out	0x3e, r29	; 62
    6e2a:	0f be       	out	0x3f, r0	; 63
    6e2c:	cd bf       	out	0x3d, r28	; 61
    6e2e:	df 91       	pop	r29
    6e30:	cf 91       	pop	r28
    6e32:	08 95       	ret

00006e34 <report_ngc_parameters>:
    6e34:	0f 93       	push	r16
    6e36:	1f 93       	push	r17
    6e38:	cf 93       	push	r28
    6e3a:	df 93       	push	r29
    6e3c:	cd b7       	in	r28, 0x3d	; 61
    6e3e:	de b7       	in	r29, 0x3e	; 62
    6e40:	2c 97       	sbiw	r28, 0x0c	; 12
    6e42:	0f b6       	in	r0, 0x3f	; 63
    6e44:	f8 94       	cli
    6e46:	de bf       	out	0x3e, r29	; 62
    6e48:	0f be       	out	0x3f, r0	; 63
    6e4a:	cd bf       	out	0x3d, r28	; 61
    6e4c:	01 e0       	ldi	r16, 0x01	; 1
    6e4e:	01 c0       	rjmp	.+2      	; 0x6e52 <report_ngc_parameters+0x1e>
    6e50:	0f 5f       	subi	r16, 0xFF	; 255
    6e52:	1f ef       	ldi	r17, 0xFF	; 255
    6e54:	10 0f       	add	r17, r16
    6e56:	be 01       	movw	r22, r28
    6e58:	6f 5f       	subi	r22, 0xFF	; 255
    6e5a:	7f 4f       	sbci	r23, 0xFF	; 255
    6e5c:	81 2f       	mov	r24, r17
    6e5e:	0e 94 f0 25 	call	0x4be0	; 0x4be0 <settings_read_coord_data>
    6e62:	81 11       	cpse	r24, r1
    6e64:	03 c0       	rjmp	.+6      	; 0x6e6c <report_ngc_parameters+0x38>
    6e66:	87 e0       	ldi	r24, 0x07	; 7
    6e68:	ff dd       	rcall	.-1026   	; 0x6a68 <report_status_message>
    6e6a:	40 c0       	rjmp	.+128    	; 0x6eec <report_ngc_parameters+0xb8>
    6e6c:	8d ee       	ldi	r24, 0xED	; 237
    6e6e:	93 e0       	ldi	r25, 0x03	; 3
    6e70:	e7 db       	rcall	.-2098   	; 0x6640 <printPgmString>
    6e72:	16 30       	cpi	r17, 0x06	; 6
    6e74:	19 f0       	breq	.+6      	; 0x6e7c <report_ngc_parameters+0x48>
    6e76:	17 30       	cpi	r17, 0x07	; 7
    6e78:	61 f0       	breq	.+24     	; 0x6e92 <report_ngc_parameters+0x5e>
    6e7a:	16 c0       	rjmp	.+44     	; 0x6ea8 <report_ngc_parameters+0x74>
    6e7c:	8a ee       	ldi	r24, 0xEA	; 234
    6e7e:	93 e0       	ldi	r25, 0x03	; 3
    6e80:	df db       	rcall	.-2114   	; 0x6640 <printPgmString>
    6e82:	8a e3       	ldi	r24, 0x3A	; 58
    6e84:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    6e88:	ce 01       	movw	r24, r28
    6e8a:	01 96       	adiw	r24, 0x01	; 1
    6e8c:	ad dd       	rcall	.-1190   	; 0x69e8 <report_util_axis_values>
    6e8e:	a7 dd       	rcall	.-1202   	; 0x69de <report_util_feedback_line_feed>
    6e90:	df cf       	rjmp	.-66     	; 0x6e50 <report_ngc_parameters+0x1c>
    6e92:	87 ee       	ldi	r24, 0xE7	; 231
    6e94:	93 e0       	ldi	r25, 0x03	; 3
    6e96:	d4 db       	rcall	.-2136   	; 0x6640 <printPgmString>
    6e98:	8a e3       	ldi	r24, 0x3A	; 58
    6e9a:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    6e9e:	ce 01       	movw	r24, r28
    6ea0:	01 96       	adiw	r24, 0x01	; 1
    6ea2:	a2 dd       	rcall	.-1212   	; 0x69e8 <report_util_axis_values>
    6ea4:	9c dd       	rcall	.-1224   	; 0x69de <report_util_feedback_line_feed>
    6ea6:	0d c0       	rjmp	.+26     	; 0x6ec2 <report_ngc_parameters+0x8e>
    6ea8:	85 e3       	ldi	r24, 0x35	; 53
    6eaa:	80 0f       	add	r24, r16
    6eac:	db db       	rcall	.-2122   	; 0x6664 <print_uint8_base10>
    6eae:	8a e3       	ldi	r24, 0x3A	; 58
    6eb0:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    6eb4:	ce 01       	movw	r24, r28
    6eb6:	01 96       	adiw	r24, 0x01	; 1
    6eb8:	97 dd       	rcall	.-1234   	; 0x69e8 <report_util_axis_values>
    6eba:	91 dd       	rcall	.-1246   	; 0x69de <report_util_feedback_line_feed>
    6ebc:	08 30       	cpi	r16, 0x08	; 8
    6ebe:	08 f4       	brcc	.+2      	; 0x6ec2 <report_ngc_parameters+0x8e>
    6ec0:	c7 cf       	rjmp	.-114    	; 0x6e50 <report_ngc_parameters+0x1c>
    6ec2:	81 ee       	ldi	r24, 0xE1	; 225
    6ec4:	93 e0       	ldi	r25, 0x03	; 3
    6ec6:	bc db       	rcall	.-2184   	; 0x6640 <printPgmString>
    6ec8:	86 e8       	ldi	r24, 0x86	; 134
    6eca:	9c e0       	ldi	r25, 0x0C	; 12
    6ecc:	8d dd       	rcall	.-1254   	; 0x69e8 <report_util_axis_values>
    6ece:	87 dd       	rcall	.-1266   	; 0x69de <report_util_feedback_line_feed>
    6ed0:	8b ed       	ldi	r24, 0xDB	; 219
    6ed2:	93 e0       	ldi	r25, 0x03	; 3
    6ed4:	b5 db       	rcall	.-2198   	; 0x6640 <printPgmString>
    6ed6:	60 91 92 0c 	lds	r22, 0x0C92	; 0x800c92 <gc_state+0x3c>
    6eda:	70 91 93 0c 	lds	r23, 0x0C93	; 0x800c93 <gc_state+0x3d>
    6ede:	80 91 94 0c 	lds	r24, 0x0C94	; 0x800c94 <gc_state+0x3e>
    6ee2:	90 91 95 0c 	lds	r25, 0x0C95	; 0x800c95 <gc_state+0x3f>
    6ee6:	1e dd       	rcall	.-1476   	; 0x6924 <printFloat_CoordValue>
    6ee8:	7a dd       	rcall	.-1292   	; 0x69de <report_util_feedback_line_feed>
    6eea:	7f df       	rcall	.-258    	; 0x6dea <report_probe_parameters>
    6eec:	2c 96       	adiw	r28, 0x0c	; 12
    6eee:	0f b6       	in	r0, 0x3f	; 63
    6ef0:	f8 94       	cli
    6ef2:	de bf       	out	0x3e, r29	; 62
    6ef4:	0f be       	out	0x3f, r0	; 63
    6ef6:	cd bf       	out	0x3d, r28	; 61
    6ef8:	df 91       	pop	r29
    6efa:	cf 91       	pop	r28
    6efc:	1f 91       	pop	r17
    6efe:	0f 91       	pop	r16
    6f00:	08 95       	ret

00006f02 <report_gcode_modes>:
    6f02:	cf 93       	push	r28
    6f04:	df 93       	push	r29
    6f06:	85 ed       	ldi	r24, 0xD5	; 213
    6f08:	93 e0       	ldi	r25, 0x03	; 3
    6f0a:	9a db       	rcall	.-2252   	; 0x6640 <printPgmString>
    6f0c:	80 91 56 0c 	lds	r24, 0x0C56	; 0x800c56 <gc_state>
    6f10:	8c 38       	cpi	r24, 0x8C	; 140
    6f12:	40 f0       	brcs	.+16     	; 0x6f24 <report_gcode_modes+0x22>
    6f14:	81 ed       	ldi	r24, 0xD1	; 209
    6f16:	93 e0       	ldi	r25, 0x03	; 3
    6f18:	93 db       	rcall	.-2266   	; 0x6640 <printPgmString>
    6f1a:	80 91 56 0c 	lds	r24, 0x0C56	; 0x800c56 <gc_state>
    6f1e:	8a 58       	subi	r24, 0x8A	; 138
    6f20:	a1 db       	rcall	.-2238   	; 0x6664 <print_uint8_base10>
    6f22:	01 c0       	rjmp	.+2      	; 0x6f26 <report_gcode_modes+0x24>
    6f24:	9f db       	rcall	.-2242   	; 0x6664 <print_uint8_base10>
    6f26:	85 ec       	ldi	r24, 0xC5	; 197
    6f28:	93 e0       	ldi	r25, 0x03	; 3
    6f2a:	8a db       	rcall	.-2284   	; 0x6640 <printPgmString>
    6f2c:	c6 e5       	ldi	r28, 0x56	; 86
    6f2e:	dc e0       	ldi	r29, 0x0C	; 12
    6f30:	8e 81       	ldd	r24, Y+6	; 0x06
    6f32:	8a 5c       	subi	r24, 0xCA	; 202
    6f34:	97 db       	rcall	.-2258   	; 0x6664 <print_uint8_base10>
    6f36:	85 ec       	ldi	r24, 0xC5	; 197
    6f38:	93 e0       	ldi	r25, 0x03	; 3
    6f3a:	82 db       	rcall	.-2300   	; 0x6640 <printPgmString>
    6f3c:	8c 81       	ldd	r24, Y+4	; 0x04
    6f3e:	8f 5e       	subi	r24, 0xEF	; 239
    6f40:	91 db       	rcall	.-2270   	; 0x6664 <print_uint8_base10>
    6f42:	85 ec       	ldi	r24, 0xC5	; 197
    6f44:	93 e0       	ldi	r25, 0x03	; 3
    6f46:	7c db       	rcall	.-2312   	; 0x6640 <printPgmString>
    6f48:	9a 81       	ldd	r25, Y+2	; 0x02
    6f4a:	85 e1       	ldi	r24, 0x15	; 21
    6f4c:	89 1b       	sub	r24, r25
    6f4e:	8a db       	rcall	.-2284   	; 0x6664 <print_uint8_base10>
    6f50:	85 ec       	ldi	r24, 0xC5	; 197
    6f52:	93 e0       	ldi	r25, 0x03	; 3
    6f54:	75 db       	rcall	.-2326   	; 0x6640 <printPgmString>
    6f56:	8b 81       	ldd	r24, Y+3	; 0x03
    6f58:	86 5a       	subi	r24, 0xA6	; 166
    6f5a:	84 db       	rcall	.-2296   	; 0x6664 <print_uint8_base10>
    6f5c:	85 ec       	ldi	r24, 0xC5	; 197
    6f5e:	93 e0       	ldi	r25, 0x03	; 3
    6f60:	6f db       	rcall	.-2338   	; 0x6640 <printPgmString>
    6f62:	99 81       	ldd	r25, Y+1	; 0x01
    6f64:	8e e5       	ldi	r24, 0x5E	; 94
    6f66:	89 1b       	sub	r24, r25
    6f68:	7d db       	rcall	.-2310   	; 0x6664 <print_uint8_base10>
    6f6a:	8f 81       	ldd	r24, Y+7	; 0x07
    6f6c:	88 23       	and	r24, r24
    6f6e:	89 f0       	breq	.+34     	; 0x6f92 <report_gcode_modes+0x90>
    6f70:	82 ec       	ldi	r24, 0xC2	; 194
    6f72:	93 e0       	ldi	r25, 0x03	; 3
    6f74:	65 db       	rcall	.-2358   	; 0x6640 <printPgmString>
    6f76:	80 91 5d 0c 	lds	r24, 0x0C5D	; 0x800c5d <gc_state+0x7>
    6f7a:	83 30       	cpi	r24, 0x03	; 3
    6f7c:	29 f0       	breq	.+10     	; 0x6f88 <report_gcode_modes+0x86>
    6f7e:	8e 31       	cpi	r24, 0x1E	; 30
    6f80:	39 f0       	breq	.+14     	; 0x6f90 <report_gcode_modes+0x8e>
    6f82:	82 30       	cpi	r24, 0x02	; 2
    6f84:	31 f4       	brne	.+12     	; 0x6f92 <report_gcode_modes+0x90>
    6f86:	04 c0       	rjmp	.+8      	; 0x6f90 <report_gcode_modes+0x8e>
    6f88:	80 e3       	ldi	r24, 0x30	; 48
    6f8a:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    6f8e:	01 c0       	rjmp	.+2      	; 0x6f92 <report_gcode_modes+0x90>
    6f90:	69 db       	rcall	.-2350   	; 0x6664 <print_uint8_base10>
    6f92:	82 ec       	ldi	r24, 0xC2	; 194
    6f94:	93 e0       	ldi	r25, 0x03	; 3
    6f96:	54 db       	rcall	.-2392   	; 0x6640 <printPgmString>
    6f98:	80 91 5f 0c 	lds	r24, 0x0C5F	; 0x800c5f <gc_state+0x9>
    6f9c:	80 31       	cpi	r24, 0x10	; 16
    6f9e:	29 f0       	breq	.+10     	; 0x6faa <report_gcode_modes+0xa8>
    6fa0:	80 32       	cpi	r24, 0x20	; 32
    6fa2:	39 f0       	breq	.+14     	; 0x6fb2 <report_gcode_modes+0xb0>
    6fa4:	81 11       	cpse	r24, r1
    6fa6:	0c c0       	rjmp	.+24     	; 0x6fc0 <report_gcode_modes+0xbe>
    6fa8:	08 c0       	rjmp	.+16     	; 0x6fba <report_gcode_modes+0xb8>
    6faa:	83 e3       	ldi	r24, 0x33	; 51
    6fac:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    6fb0:	07 c0       	rjmp	.+14     	; 0x6fc0 <report_gcode_modes+0xbe>
    6fb2:	84 e3       	ldi	r24, 0x34	; 52
    6fb4:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    6fb8:	03 c0       	rjmp	.+6      	; 0x6fc0 <report_gcode_modes+0xbe>
    6fba:	85 e3       	ldi	r24, 0x35	; 53
    6fbc:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    6fc0:	82 ec       	ldi	r24, 0xC2	; 194
    6fc2:	93 e0       	ldi	r25, 0x03	; 3
    6fc4:	3d db       	rcall	.-2438   	; 0x6640 <printPgmString>
    6fc6:	80 91 5e 0c 	lds	r24, 0x0C5E	; 0x800c5e <gc_state+0x8>
    6fca:	88 23       	and	r24, r24
    6fcc:	61 f0       	breq	.+24     	; 0x6fe6 <report_gcode_modes+0xe4>
    6fce:	1c f4       	brge	.+6      	; 0x6fd6 <report_gcode_modes+0xd4>
    6fd0:	87 e3       	ldi	r24, 0x37	; 55
    6fd2:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    6fd6:	80 91 5e 0c 	lds	r24, 0x0C5E	; 0x800c5e <gc_state+0x8>
    6fda:	86 ff       	sbrs	r24, 6
    6fdc:	07 c0       	rjmp	.+14     	; 0x6fec <report_gcode_modes+0xea>
    6fde:	88 e3       	ldi	r24, 0x38	; 56
    6fe0:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    6fe4:	03 c0       	rjmp	.+6      	; 0x6fec <report_gcode_modes+0xea>
    6fe6:	89 e3       	ldi	r24, 0x39	; 57
    6fe8:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    6fec:	8e ec       	ldi	r24, 0xCE	; 206
    6fee:	93 e0       	ldi	r25, 0x03	; 3
    6ff0:	27 db       	rcall	.-2482   	; 0x6640 <printPgmString>
    6ff2:	c6 e5       	ldi	r28, 0x56	; 86
    6ff4:	dc e0       	ldi	r29, 0x0C	; 12
    6ff6:	8b 89       	ldd	r24, Y+19	; 0x13
    6ff8:	35 db       	rcall	.-2454   	; 0x6664 <print_uint8_base10>
    6ffa:	8b ec       	ldi	r24, 0xCB	; 203
    6ffc:	93 e0       	ldi	r25, 0x03	; 3
    6ffe:	20 db       	rcall	.-2496   	; 0x6640 <printPgmString>
    7000:	6f 85       	ldd	r22, Y+15	; 0x0f
    7002:	78 89       	ldd	r23, Y+16	; 0x10
    7004:	89 89       	ldd	r24, Y+17	; 0x11
    7006:	9a 89       	ldd	r25, Y+18	; 0x12
    7008:	9d dc       	rcall	.-1734   	; 0x6944 <printFloat_RateValue>
    700a:	88 ec       	ldi	r24, 0xC8	; 200
    700c:	93 e0       	ldi	r25, 0x03	; 3
    700e:	18 db       	rcall	.-2512   	; 0x6640 <printPgmString>
    7010:	6b 85       	ldd	r22, Y+11	; 0x0b
    7012:	7c 85       	ldd	r23, Y+12	; 0x0c
    7014:	8d 85       	ldd	r24, Y+13	; 0x0d
    7016:	9e 85       	ldd	r25, Y+14	; 0x0e
    7018:	40 e0       	ldi	r20, 0x00	; 0
    701a:	d3 db       	rcall	.-2138   	; 0x67c2 <printFloat>
    701c:	e0 dc       	rcall	.-1600   	; 0x69de <report_util_feedback_line_feed>
    701e:	df 91       	pop	r29
    7020:	cf 91       	pop	r28
    7022:	08 95       	ret

00007024 <report_startup_line>:
    7024:	1f 93       	push	r17
    7026:	cf 93       	push	r28
    7028:	df 93       	push	r29
    702a:	18 2f       	mov	r17, r24
    702c:	eb 01       	movw	r28, r22
    702e:	8f eb       	ldi	r24, 0xBF	; 191
    7030:	93 e0       	ldi	r25, 0x03	; 3
    7032:	06 db       	rcall	.-2548   	; 0x6640 <printPgmString>
    7034:	81 2f       	mov	r24, r17
    7036:	16 db       	rcall	.-2516   	; 0x6664 <print_uint8_base10>
    7038:	8d e3       	ldi	r24, 0x3D	; 61
    703a:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    703e:	ce 01       	movw	r24, r28
    7040:	f0 da       	rcall	.-2592   	; 0x6622 <printString>
    7042:	c9 dc       	rcall	.-1646   	; 0x69d6 <report_util_line_feed>
    7044:	df 91       	pop	r29
    7046:	cf 91       	pop	r28
    7048:	1f 91       	pop	r17
    704a:	08 95       	ret

0000704c <report_execute_startup_message>:
    704c:	0f 93       	push	r16
    704e:	1f 93       	push	r17
    7050:	cf 93       	push	r28
    7052:	8c 01       	movw	r16, r24
    7054:	c6 2f       	mov	r28, r22
    7056:	8e e3       	ldi	r24, 0x3E	; 62
    7058:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    705c:	c8 01       	movw	r24, r16
    705e:	e1 da       	rcall	.-2622   	; 0x6622 <printString>
    7060:	8a e3       	ldi	r24, 0x3A	; 58
    7062:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    7066:	8c 2f       	mov	r24, r28
    7068:	ff dc       	rcall	.-1538   	; 0x6a68 <report_status_message>
    706a:	cf 91       	pop	r28
    706c:	1f 91       	pop	r17
    706e:	0f 91       	pop	r16
    7070:	08 95       	ret

00007072 <report_build_info>:
    7072:	cf 93       	push	r28
    7074:	df 93       	push	r29
    7076:	ec 01       	movw	r28, r24
    7078:	86 ea       	ldi	r24, 0xA6	; 166
    707a:	93 e0       	ldi	r25, 0x03	; 3
    707c:	e1 da       	rcall	.-2622   	; 0x6640 <printPgmString>
    707e:	ce 01       	movw	r24, r28
    7080:	d0 da       	rcall	.-2656   	; 0x6622 <printString>
    7082:	ad dc       	rcall	.-1702   	; 0x69de <report_util_feedback_line_feed>
    7084:	80 ea       	ldi	r24, 0xA0	; 160
    7086:	93 e0       	ldi	r25, 0x03	; 3
    7088:	db da       	rcall	.-2634   	; 0x6640 <printPgmString>
    708a:	86 e5       	ldi	r24, 0x56	; 86
    708c:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    7090:	8e e4       	ldi	r24, 0x4E	; 78
    7092:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    7096:	8d e4       	ldi	r24, 0x4D	; 77
    7098:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    709c:	8b e2       	ldi	r24, 0x2B	; 43
    709e:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    70a2:	88 e4       	ldi	r24, 0x48	; 72
    70a4:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    70a8:	83 e5       	ldi	r24, 0x53	; 83
    70aa:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    70ae:	8c e4       	ldi	r24, 0x4C	; 76
    70b0:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    70b4:	8c e2       	ldi	r24, 0x2C	; 44
    70b6:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    70ba:	83 e2       	ldi	r24, 0x23	; 35
    70bc:	d3 da       	rcall	.-2650   	; 0x6664 <print_uint8_base10>
    70be:	8c e2       	ldi	r24, 0x2C	; 44
    70c0:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    70c4:	8f ef       	ldi	r24, 0xFF	; 255
    70c6:	ce da       	rcall	.-2660   	; 0x6664 <print_uint8_base10>
    70c8:	8a dc       	rcall	.-1772   	; 0x69de <report_util_feedback_line_feed>
    70ca:	df 91       	pop	r29
    70cc:	cf 91       	pop	r28
    70ce:	08 95       	ret

000070d0 <report_realtime_status>:
 // and the actual location of the CNC machine. Users may change the following function to their
 // specific needs, but the desired real-time data report must be as short as possible. This is
 // requires as it minimizes the computational overhead and allows grbl to keep running smoothly,
 // especially during g-code programs with fast, short line segments and high frequency reports (5-20Hz).
void report_realtime_status()
{
    70d0:	4f 92       	push	r4
    70d2:	5f 92       	push	r5
    70d4:	6f 92       	push	r6
    70d6:	7f 92       	push	r7
    70d8:	8f 92       	push	r8
    70da:	9f 92       	push	r9
    70dc:	af 92       	push	r10
    70de:	bf 92       	push	r11
    70e0:	cf 92       	push	r12
    70e2:	df 92       	push	r13
    70e4:	ef 92       	push	r14
    70e6:	ff 92       	push	r15
    70e8:	0f 93       	push	r16
    70ea:	1f 93       	push	r17
    70ec:	cf 93       	push	r28
    70ee:	df 93       	push	r29
    70f0:	cd b7       	in	r28, 0x3d	; 61
    70f2:	de b7       	in	r29, 0x3e	; 62
    70f4:	a4 97       	sbiw	r28, 0x24	; 36
    70f6:	0f b6       	in	r0, 0x3f	; 63
    70f8:	f8 94       	cli
    70fa:	de bf       	out	0x3e, r29	; 62
    70fc:	0f be       	out	0x3f, r0	; 63
    70fe:	cd bf       	out	0x3d, r28	; 61
  uint8_t idx;
  int32_t current_position[N_AXIS]; // Copy current state of the system position variable
  memcpy(current_position,sys_position,sizeof(sys_position));
    7100:	8c e0       	ldi	r24, 0x0C	; 12
    7102:	e3 e4       	ldi	r30, 0x43	; 67
    7104:	fc e0       	ldi	r31, 0x0C	; 12
    7106:	de 01       	movw	r26, r28
    7108:	11 96       	adiw	r26, 0x01	; 1
    710a:	01 90       	ld	r0, Z+
    710c:	0d 92       	st	X+, r0
    710e:	8a 95       	dec	r24
    7110:	e1 f7       	brne	.-8      	; 0x710a <report_realtime_status+0x3a>
  float print_position[N_AXIS];
  system_convert_array_steps_to_mpos(print_position,current_position);
    7112:	be 01       	movw	r22, r28
    7114:	6f 5f       	subi	r22, 0xFF	; 255
    7116:	7f 4f       	sbci	r23, 0xFF	; 255
    7118:	ce 01       	movw	r24, r28
    711a:	0d 96       	adiw	r24, 0x0d	; 13
    711c:	87 d2       	rcall	.+1294   	; 0x762c <system_convert_array_steps_to_mpos>

  // Report current machine state and sub-states
  serial_write('<');
    711e:	8c e3       	ldi	r24, 0x3C	; 60
    7120:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
  switch (sys.state) {
    7124:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    7128:	88 30       	cpi	r24, 0x08	; 8
    712a:	c9 f0       	breq	.+50     	; 0x715e <report_realtime_status+0x8e>
    712c:	40 f4       	brcc	.+16     	; 0x713e <report_realtime_status+0x6e>
    712e:	81 30       	cpi	r24, 0x01	; 1
    7130:	a9 f1       	breq	.+106    	; 0x719c <report_realtime_status+0xcc>
    7132:	88 f0       	brcs	.+34     	; 0x7156 <report_realtime_status+0x86>
    7134:	82 30       	cpi	r24, 0x02	; 2
    7136:	b1 f1       	breq	.+108    	; 0x71a4 <report_realtime_status+0xd4>
    7138:	84 30       	cpi	r24, 0x04	; 4
    713a:	61 f1       	breq	.+88     	; 0x7194 <report_realtime_status+0xc4>
    713c:	55 c0       	rjmp	.+170    	; 0x71e8 <report_realtime_status+0x118>
    713e:	80 32       	cpi	r24, 0x20	; 32
    7140:	29 f1       	breq	.+74     	; 0x718c <report_realtime_status+0xbc>
    7142:	18 f4       	brcc	.+6      	; 0x714a <report_realtime_status+0x7a>
    7144:	80 31       	cpi	r24, 0x10	; 16
    7146:	79 f0       	breq	.+30     	; 0x7166 <report_realtime_status+0x96>
    7148:	4f c0       	rjmp	.+158    	; 0x71e8 <report_realtime_status+0x118>
    714a:	80 34       	cpi	r24, 0x40	; 64
    714c:	79 f1       	breq	.+94     	; 0x71ac <report_realtime_status+0xdc>
    714e:	80 38       	cpi	r24, 0x80	; 128
    7150:	09 f4       	brne	.+2      	; 0x7154 <report_realtime_status+0x84>
    7152:	47 c0       	rjmp	.+142    	; 0x71e2 <report_realtime_status+0x112>
    7154:	49 c0       	rjmp	.+146    	; 0x71e8 <report_realtime_status+0x118>
    case STATE_IDLE: printPgmString(PSTR("Idle")); break;
    7156:	8b e9       	ldi	r24, 0x9B	; 155
    7158:	93 e0       	ldi	r25, 0x03	; 3
    715a:	72 da       	rcall	.-2844   	; 0x6640 <printPgmString>
    715c:	45 c0       	rjmp	.+138    	; 0x71e8 <report_realtime_status+0x118>
    case STATE_CYCLE: printPgmString(PSTR("Run")); break;
    715e:	87 e9       	ldi	r24, 0x97	; 151
    7160:	93 e0       	ldi	r25, 0x03	; 3
    7162:	6e da       	rcall	.-2852   	; 0x6640 <printPgmString>
    7164:	41 c0       	rjmp	.+130    	; 0x71e8 <report_realtime_status+0x118>
    case STATE_HOLD:
      if (!(sys.suspend & SUSPEND_JOG_CANCEL)) {
    7166:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    716a:	88 23       	and	r24, r24
        printPgmString(PSTR("Hold:"));
    716c:	7c f0       	brlt	.+30     	; 0x718c <report_realtime_status+0xbc>
    716e:	81 e9       	ldi	r24, 0x91	; 145
    7170:	93 e0       	ldi	r25, 0x03	; 3
    7172:	66 da       	rcall	.-2868   	; 0x6640 <printPgmString>
        if (sys.suspend & SUSPEND_HOLD_COMPLETE) { serial_write('0'); } // Ready to resume
    7174:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
    7178:	80 ff       	sbrs	r24, 0
    717a:	04 c0       	rjmp	.+8      	; 0x7184 <report_realtime_status+0xb4>
    717c:	80 e3       	ldi	r24, 0x30	; 48
    717e:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    7182:	32 c0       	rjmp	.+100    	; 0x71e8 <report_realtime_status+0x118>
        else { serial_write('1'); } // Actively holding
    7184:	81 e3       	ldi	r24, 0x31	; 49
    7186:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
        break;
      } // Continues to print jog state during jog cancel.
    case STATE_JOG: printPgmString(PSTR("Jog")); break;
    718a:	2e c0       	rjmp	.+92     	; 0x71e8 <report_realtime_status+0x118>
    718c:	8d e8       	ldi	r24, 0x8D	; 141
    718e:	93 e0       	ldi	r25, 0x03	; 3
    7190:	57 da       	rcall	.-2898   	; 0x6640 <printPgmString>
    case STATE_HOMING: printPgmString(PSTR("Home")); break;
    7192:	2a c0       	rjmp	.+84     	; 0x71e8 <report_realtime_status+0x118>
    7194:	88 e8       	ldi	r24, 0x88	; 136
    7196:	93 e0       	ldi	r25, 0x03	; 3
    7198:	53 da       	rcall	.-2906   	; 0x6640 <printPgmString>
    case STATE_ALARM: printPgmString(PSTR("Alarm")); break;
    719a:	26 c0       	rjmp	.+76     	; 0x71e8 <report_realtime_status+0x118>
    719c:	82 e8       	ldi	r24, 0x82	; 130
    719e:	93 e0       	ldi	r25, 0x03	; 3
    71a0:	4f da       	rcall	.-2914   	; 0x6640 <printPgmString>
    case STATE_CHECK_MODE: printPgmString(PSTR("Check")); break;
    71a2:	22 c0       	rjmp	.+68     	; 0x71e8 <report_realtime_status+0x118>
    71a4:	8c e7       	ldi	r24, 0x7C	; 124
    71a6:	93 e0       	ldi	r25, 0x03	; 3
    71a8:	4b da       	rcall	.-2922   	; 0x6640 <printPgmString>
    71aa:	1e c0       	rjmp	.+60     	; 0x71e8 <report_realtime_status+0x118>
    case STATE_SAFETY_DOOR:
      printPgmString(PSTR("Door:"));
    71ac:	86 e7       	ldi	r24, 0x76	; 118
    71ae:	93 e0       	ldi	r25, 0x03	; 3
    71b0:	47 da       	rcall	.-2930   	; 0x6640 <printPgmString>
    71b2:	80 91 20 0c 	lds	r24, 0x0C20	; 0x800c20 <sys+0x2>
      if (sys.suspend & SUSPEND_INITIATE_RESTORE) {
    71b6:	83 ff       	sbrs	r24, 3
    71b8:	04 c0       	rjmp	.+8      	; 0x71c2 <report_realtime_status+0xf2>
    71ba:	83 e3       	ldi	r24, 0x33	; 51
        serial_write('3'); // Restoring
    71bc:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    71c0:	13 c0       	rjmp	.+38     	; 0x71e8 <report_realtime_status+0x118>
    71c2:	82 ff       	sbrs	r24, 2
      } else {
        if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
    71c4:	0a c0       	rjmp	.+20     	; 0x71da <report_realtime_status+0x10a>
    71c6:	85 ff       	sbrs	r24, 5
          if (sys.suspend & SUSPEND_SAFETY_DOOR_AJAR) {
    71c8:	04 c0       	rjmp	.+8      	; 0x71d2 <report_realtime_status+0x102>
    71ca:	81 e3       	ldi	r24, 0x31	; 49
            serial_write('1'); // Door ajar
    71cc:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    71d0:	0b c0       	rjmp	.+22     	; 0x71e8 <report_realtime_status+0x118>
    71d2:	80 e3       	ldi	r24, 0x30	; 48
          } else {
            serial_write('0');
    71d4:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    71d8:	07 c0       	rjmp	.+14     	; 0x71e8 <report_realtime_status+0x118>
          } // Door closed and ready to resume
        } else {
          serial_write('2'); // Retracting
    71da:	82 e3       	ldi	r24, 0x32	; 50
    71dc:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    71e0:	03 c0       	rjmp	.+6      	; 0x71e8 <report_realtime_status+0x118>
        }
      }
      break;
    case STATE_SLEEP: printPgmString(PSTR("Sleep")); break;
    71e2:	80 e7       	ldi	r24, 0x70	; 112
    71e4:	93 e0       	ldi	r25, 0x03	; 3
    71e6:	2c da       	rcall	.-2984   	; 0x6640 <printPgmString>
    71e8:	80 91 04 0f 	lds	r24, 0x0F04	; 0x800f04 <settings+0x34>
    71ec:	28 2f       	mov	r18, r24
  }

  float wco[N_AXIS];
  if (bit_isfalse(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE) ||
    71ee:	21 70       	andi	r18, 0x01	; 1
    71f0:	e2 2e       	mov	r14, r18
    71f2:	80 ff       	sbrs	r24, 0
    71f4:	04 c0       	rjmp	.+8      	; 0x71fe <report_realtime_status+0x12e>
    71f6:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <sys+0xc>
    71fa:	81 11       	cpse	r24, r1
    71fc:	52 c0       	rjmp	.+164    	; 0x72a2 <report_realtime_status+0x1d2>
    71fe:	40 90 92 0c 	lds	r4, 0x0C92	; 0x800c92 <gc_state+0x3c>
      (sys.report_wco_counter == 0) ) {
    for (idx=0; idx< N_AXIS; idx++) {
      // Apply work coordinate offsets and tool length offset to current position.
      wco[idx] = gc_state.coord_system[idx]+gc_state.coord_offset[idx];
      if (idx == TOOL_LENGTH_OFFSET_AXIS) { wco[idx] += gc_state.tool_length_offset; }
    7202:	50 90 93 0c 	lds	r5, 0x0C93	; 0x800c93 <gc_state+0x3d>
    7206:	60 90 94 0c 	lds	r6, 0x0C94	; 0x800c94 <gc_state+0x3e>
    720a:	70 90 95 0c 	lds	r7, 0x0C95	; 0x800c95 <gc_state+0x3f>
    720e:	0f 2e       	mov	r0, r31
    7210:	fa e7       	ldi	r31, 0x7A	; 122
    7212:	cf 2e       	mov	r12, r31
    7214:	fc e0       	ldi	r31, 0x0C	; 12
    7216:	df 2e       	mov	r13, r31
    7218:	f0 2d       	mov	r31, r0
    721a:	8e 01       	movw	r16, r28
    721c:	07 5e       	subi	r16, 0xE7	; 231
    721e:	1f 4f       	sbci	r17, 0xFF	; 255
    7220:	5e 01       	movw	r10, r28
    7222:	8d e0       	ldi	r24, 0x0D	; 13
    7224:	a8 0e       	add	r10, r24
    7226:	b1 1c       	adc	r11, r1
    7228:	f1 2c       	mov	r15, r1
    722a:	f6 01       	movw	r30, r12
  float wco[N_AXIS];
  if (bit_isfalse(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE) ||
      (sys.report_wco_counter == 0) ) {
    for (idx=0; idx< N_AXIS; idx++) {
      // Apply work coordinate offsets and tool length offset to current position.
      wco[idx] = gc_state.coord_system[idx]+gc_state.coord_offset[idx];
    722c:	61 91       	ld	r22, Z+
    722e:	71 91       	ld	r23, Z+
    7230:	81 91       	ld	r24, Z+
    7232:	91 91       	ld	r25, Z+
    7234:	6f 01       	movw	r12, r30
    7236:	20 85       	ldd	r18, Z+8	; 0x08
    7238:	31 85       	ldd	r19, Z+9	; 0x09
    723a:	42 85       	ldd	r20, Z+10	; 0x0a
    723c:	53 85       	ldd	r21, Z+11	; 0x0b
    723e:	6c d5       	rcall	.+2776   	; 0x7d18 <__addsf3>
    7240:	48 01       	movw	r8, r16
    7242:	f8 01       	movw	r30, r16
    7244:	60 83       	st	Z, r22
    7246:	71 83       	std	Z+1, r23	; 0x01
    7248:	82 83       	std	Z+2, r24	; 0x02
    724a:	93 83       	std	Z+3, r25	; 0x03
      if (idx == TOOL_LENGTH_OFFSET_AXIS) { wco[idx] += gc_state.tool_length_offset; }
    724c:	f2 e0       	ldi	r31, 0x02	; 2
    724e:	ff 12       	cpse	r15, r31
    7250:	0b c0       	rjmp	.+22     	; 0x7268 <report_realtime_status+0x198>
    7252:	a3 01       	movw	r20, r6
    7254:	92 01       	movw	r18, r4
    7256:	60 d5       	rcall	.+2752   	; 0x7d18 <__addsf3>
    7258:	f8 01       	movw	r30, r16
    725a:	60 83       	st	Z, r22
    725c:	71 83       	std	Z+1, r23	; 0x01
    725e:	82 83       	std	Z+2, r24	; 0x02
    7260:	93 83       	std	Z+3, r25	; 0x03
    7262:	e1 10       	cpse	r14, r1
      if (bit_isfalse(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE)) {
    7264:	1e c0       	rjmp	.+60     	; 0x72a2 <report_realtime_status+0x1d2>
    7266:	02 c0       	rjmp	.+4      	; 0x726c <report_realtime_status+0x19c>
    7268:	e1 10       	cpse	r14, r1
    726a:	10 c0       	rjmp	.+32     	; 0x728c <report_realtime_status+0x1bc>
        print_position[idx] -= wco[idx];
    726c:	f4 01       	movw	r30, r8
    726e:	20 81       	ld	r18, Z
    7270:	31 81       	ldd	r19, Z+1	; 0x01
    7272:	42 81       	ldd	r20, Z+2	; 0x02
    7274:	53 81       	ldd	r21, Z+3	; 0x03
    7276:	f5 01       	movw	r30, r10
    7278:	60 81       	ld	r22, Z
    727a:	71 81       	ldd	r23, Z+1	; 0x01
    727c:	82 81       	ldd	r24, Z+2	; 0x02
    727e:	93 81       	ldd	r25, Z+3	; 0x03
    7280:	4a d5       	rcall	.+2708   	; 0x7d16 <__subsf3>
    7282:	f5 01       	movw	r30, r10
    7284:	60 83       	st	Z, r22
    7286:	71 83       	std	Z+1, r23	; 0x01
    7288:	82 83       	std	Z+2, r24	; 0x02
    728a:	93 83       	std	Z+3, r25	; 0x03
    728c:	f3 94       	inc	r15
  }

  float wco[N_AXIS];
  if (bit_isfalse(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE) ||
      (sys.report_wco_counter == 0) ) {
    for (idx=0; idx< N_AXIS; idx++) {
    728e:	0c 5f       	subi	r16, 0xFC	; 252
    7290:	1f 4f       	sbci	r17, 0xFF	; 255
    7292:	f4 e0       	ldi	r31, 0x04	; 4
    7294:	af 0e       	add	r10, r31
    7296:	b1 1c       	adc	r11, r1
    7298:	23 e0       	ldi	r18, 0x03	; 3
    729a:	f2 12       	cpse	r15, r18
      }
    }
  }

  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_POSITION_TYPE)) {
    729c:	c6 cf       	rjmp	.-116    	; 0x722a <report_realtime_status+0x15a>
    729e:	ee 20       	and	r14, r14
    printPgmString(PSTR("|MPos:"));
    72a0:	21 f0       	breq	.+8      	; 0x72aa <report_realtime_status+0x1da>
    72a2:	89 e6       	ldi	r24, 0x69	; 105
    72a4:	93 e0       	ldi	r25, 0x03	; 3
    72a6:	cc d9       	rcall	.-3176   	; 0x6640 <printPgmString>
  } else {
    printPgmString(PSTR("|WPos:"));
    72a8:	03 c0       	rjmp	.+6      	; 0x72b0 <report_realtime_status+0x1e0>
    72aa:	82 e6       	ldi	r24, 0x62	; 98
    72ac:	93 e0       	ldi	r25, 0x03	; 3
  }
  report_util_axis_values(print_position);
    72ae:	c8 d9       	rcall	.-3184   	; 0x6640 <printPgmString>
    72b0:	ce 01       	movw	r24, r28
    72b2:	0d 96       	adiw	r24, 0x0d	; 13

  // Returns planner and serial read buffer states.
  #ifdef REPORT_FIELD_BUFFER_STATE
    if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_BUFFER_STATE)) {
    72b4:	99 db       	rcall	.-2254   	; 0x69e8 <report_util_axis_values>
    72b6:	80 91 04 0f 	lds	r24, 0x0F04	; 0x800f04 <settings+0x34>
    72ba:	81 ff       	sbrs	r24, 1
      printPgmString(PSTR("|Bf:"));
    72bc:	0c c0       	rjmp	.+24     	; 0x72d6 <report_realtime_status+0x206>
    72be:	8d e5       	ldi	r24, 0x5D	; 93
    72c0:	93 e0       	ldi	r25, 0x03	; 3
    72c2:	be d9       	rcall	.-3204   	; 0x6640 <printPgmString>
      print_uint8_base10(plan_get_block_buffer_available());
    72c4:	0e 94 ef 2d 	call	0x5bde	; 0x5bde <plan_get_block_buffer_available>
    72c8:	cd d9       	rcall	.-3174   	; 0x6664 <print_uint8_base10>
    72ca:	8c e2       	ldi	r24, 0x2C	; 44
      serial_write(',');
    72cc:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    72d0:	0e 94 da 13 	call	0x27b4	; 0x27b4 <serial_get_rx_buffer_available>
      print_uint8_base10(serial_get_rx_buffer_available());
    72d4:	c7 d9       	rcall	.-3186   	; 0x6664 <print_uint8_base10>
    72d6:	0e 94 5b 29 	call	0x52b6	; 0x52b6 <plan_get_current_block>
  #endif

  #ifdef REPORT_FIELD_LINE_NUMBERS
    // Report current line number
    plan_block_t * cur_block = plan_get_current_block();
    if (cur_block != NULL) {
    72da:	00 97       	sbiw	r24, 0x00	; 0
      uint32_t ln = cur_block->line_number;
    72dc:	81 f0       	breq	.+32     	; 0x72fe <report_realtime_status+0x22e>
    72de:	fc 01       	movw	r30, r24
    72e0:	c2 88       	ldd	r12, Z+18	; 0x12
    72e2:	d3 88       	ldd	r13, Z+19	; 0x13
      if (ln > 0) {
    72e4:	e4 88       	ldd	r14, Z+20	; 0x14
    72e6:	f5 88       	ldd	r15, Z+21	; 0x15
    72e8:	c1 14       	cp	r12, r1
    72ea:	d1 04       	cpc	r13, r1
    72ec:	e1 04       	cpc	r14, r1
        printPgmString(PSTR("|Ln:"));
    72ee:	f1 04       	cpc	r15, r1
    72f0:	31 f0       	breq	.+12     	; 0x72fe <report_realtime_status+0x22e>
    72f2:	88 e5       	ldi	r24, 0x58	; 88
    72f4:	93 e0       	ldi	r25, 0x03	; 3
        printInteger(ln);
    72f6:	a4 d9       	rcall	.-3256   	; 0x6640 <printPgmString>
    72f8:	c7 01       	movw	r24, r14
    72fa:	b6 01       	movw	r22, r12
    }
  #endif

  // Report realtime feed speed
  #ifdef REPORT_FIELD_CURRENT_FEED_SPEED
    printPgmString(PSTR("|FS:"));
    72fc:	48 da       	rcall	.-2928   	; 0x678e <printInteger>
    72fe:	83 e5       	ldi	r24, 0x53	; 83
    7300:	93 e0       	ldi	r25, 0x03	; 3
    printFloat_RateValue(st_get_realtime_rate());
    7302:	9e d9       	rcall	.-3268   	; 0x6640 <printPgmString>
    7304:	0e 94 6b 24 	call	0x48d6	; 0x48d6 <st_get_realtime_rate>
    7308:	1d db       	rcall	.-2502   	; 0x6944 <printFloat_RateValue>
    serial_write(',');
    730a:	8c e2       	ldi	r24, 0x2C	; 44
    730c:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    printFloat(sys.spindle_speed,N_DECIMAL_RPMVALUE);
    7310:	60 91 2c 0c 	lds	r22, 0x0C2C	; 0x800c2c <sys+0xe>
    7314:	70 91 2d 0c 	lds	r23, 0x0C2D	; 0x800c2d <sys+0xf>
    7318:	80 91 2e 0c 	lds	r24, 0x0C2E	; 0x800c2e <sys+0x10>
    731c:	90 91 2f 0c 	lds	r25, 0x0C2F	; 0x800c2f <sys+0x11>
    7320:	40 e0       	ldi	r20, 0x00	; 0
    7322:	4f da       	rcall	.-2914   	; 0x67c2 <printFloat>
  #endif

  #ifdef REPORT_FIELD_PIN_STATE
    uint8_t lim_pin_state = limits_get_state();
    7324:	0e 94 3b 30 	call	0x6076	; 0x6076 <limits_get_state>
    7328:	08 2f       	mov	r16, r24
    uint8_t ctrl_pin_state = system_control_get_state();
    732a:	d9 d0       	rcall	.+434    	; 0x74de <system_control_get_state>
    732c:	18 2f       	mov	r17, r24
    732e:	38 db       	rcall	.-2448   	; 0x69a0 <probe_get_state>
    uint8_t prb_pin_state = probe_get_state();
    7330:	f8 2e       	mov	r15, r24
    7332:	80 2f       	mov	r24, r16
    7334:	81 2b       	or	r24, r17
    if (lim_pin_state | ctrl_pin_state | prb_pin_state) {
    7336:	8f 29       	or	r24, r15
    7338:	79 f1       	breq	.+94     	; 0x7398 <report_realtime_status+0x2c8>
    733a:	8e e4       	ldi	r24, 0x4E	; 78
    733c:	93 e0       	ldi	r25, 0x03	; 3
      printPgmString(PSTR("|Pn:"));
    733e:	80 d9       	rcall	.-3328   	; 0x6640 <printPgmString>
    7340:	ff 20       	and	r15, r15
    7342:	19 f0       	breq	.+6      	; 0x734a <report_realtime_status+0x27a>
    7344:	80 e5       	ldi	r24, 0x50	; 80
      if (prb_pin_state) { serial_write('P'); }
    7346:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    734a:	00 23       	and	r16, r16
    734c:	79 f0       	breq	.+30     	; 0x736c <report_realtime_status+0x29c>
    734e:	00 ff       	sbrs	r16, 0
      if (lim_pin_state) {
    7350:	03 c0       	rjmp	.+6      	; 0x7358 <report_realtime_status+0x288>
    7352:	88 e5       	ldi	r24, 0x58	; 88
        if (bit_istrue(lim_pin_state,bit(X_AXIS))) { serial_write('X'); }
    7354:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    7358:	01 ff       	sbrs	r16, 1
    735a:	03 c0       	rjmp	.+6      	; 0x7362 <report_realtime_status+0x292>
    735c:	89 e5       	ldi	r24, 0x59	; 89
        if (bit_istrue(lim_pin_state,bit(Y_AXIS))) { serial_write('Y'); }
    735e:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    7362:	02 ff       	sbrs	r16, 2
    7364:	03 c0       	rjmp	.+6      	; 0x736c <report_realtime_status+0x29c>
    7366:	8a e5       	ldi	r24, 0x5A	; 90
        if (bit_istrue(lim_pin_state,bit(Z_AXIS))) { serial_write('Z'); }
    7368:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    736c:	11 23       	and	r17, r17
    736e:	a1 f0       	breq	.+40     	; 0x7398 <report_realtime_status+0x2c8>
    7370:	10 ff       	sbrs	r17, 0
      }
      if (ctrl_pin_state) {
    7372:	03 c0       	rjmp	.+6      	; 0x737a <report_realtime_status+0x2aa>
    7374:	84 e4       	ldi	r24, 0x44	; 68
        if (bit_istrue(ctrl_pin_state,CONTROL_PIN_INDEX_SAFETY_DOOR)) { serial_write('D'); }
    7376:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    737a:	11 ff       	sbrs	r17, 1
    737c:	03 c0       	rjmp	.+6      	; 0x7384 <report_realtime_status+0x2b4>
    737e:	82 e5       	ldi	r24, 0x52	; 82
        if (bit_istrue(ctrl_pin_state,CONTROL_PIN_INDEX_RESET)) { serial_write('R'); }
    7380:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    7384:	12 ff       	sbrs	r17, 2
    7386:	03 c0       	rjmp	.+6      	; 0x738e <report_realtime_status+0x2be>
    7388:	88 e4       	ldi	r24, 0x48	; 72
        if (bit_istrue(ctrl_pin_state,CONTROL_PIN_INDEX_FEED_HOLD)) { serial_write('H'); }
    738a:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    738e:	13 ff       	sbrs	r17, 3
    7390:	03 c0       	rjmp	.+6      	; 0x7398 <report_realtime_status+0x2c8>
    7392:	83 e5       	ldi	r24, 0x53	; 83
        if (bit_istrue(ctrl_pin_state,CONTROL_PIN_INDEX_CYCLE_START)) { serial_write('S'); }
    7394:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    7398:	80 91 2a 0c 	lds	r24, 0x0C2A	; 0x800c2a <sys+0xc>
    739c:	88 23       	and	r24, r24
      }
    }
  #endif

  #ifdef REPORT_FIELD_WORK_COORD_OFFSET
    if (sys.report_wco_counter > 0) { sys.report_wco_counter--; }
    739e:	21 f0       	breq	.+8      	; 0x73a8 <report_realtime_status+0x2d8>
    73a0:	81 50       	subi	r24, 0x01	; 1
    73a2:	80 93 2a 0c 	sts	0x0C2A, r24	; 0x800c2a <sys+0xc>
    73a6:	18 c0       	rjmp	.+48     	; 0x73d8 <report_realtime_status+0x308>
    73a8:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    else {
      if (sys.state & (STATE_HOMING | STATE_CYCLE | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)) {
    73ac:	8c 77       	andi	r24, 0x7C	; 124
    73ae:	21 f0       	breq	.+8      	; 0x73b8 <report_realtime_status+0x2e8>
    73b0:	8d e1       	ldi	r24, 0x1D	; 29
        sys.report_wco_counter = (REPORT_WCO_REFRESH_BUSY_COUNT-1); // Reset counter for slow refresh
    73b2:	80 93 2a 0c 	sts	0x0C2A, r24	; 0x800c2a <sys+0xc>
    73b6:	03 c0       	rjmp	.+6      	; 0x73be <report_realtime_status+0x2ee>
    73b8:	89 e0       	ldi	r24, 0x09	; 9
      } else { sys.report_wco_counter = (REPORT_WCO_REFRESH_IDLE_COUNT-1); }
    73ba:	80 93 2a 0c 	sts	0x0C2A, r24	; 0x800c2a <sys+0xc>
    73be:	80 91 29 0c 	lds	r24, 0x0C29	; 0x800c29 <sys+0xb>
      if (sys.report_ovr_counter == 0) { sys.report_ovr_counter = 1; } // Set override on next report.
    73c2:	81 11       	cpse	r24, r1
    73c4:	03 c0       	rjmp	.+6      	; 0x73cc <report_realtime_status+0x2fc>
    73c6:	81 e0       	ldi	r24, 0x01	; 1
    73c8:	80 93 29 0c 	sts	0x0C29, r24	; 0x800c29 <sys+0xb>
    73cc:	88 e4       	ldi	r24, 0x48	; 72
      printPgmString(PSTR("|WCO:"));
    73ce:	93 e0       	ldi	r25, 0x03	; 3
    73d0:	37 d9       	rcall	.-3474   	; 0x6640 <printPgmString>
    73d2:	ce 01       	movw	r24, r28
      report_util_axis_values(wco);
    73d4:	49 96       	adiw	r24, 0x19	; 25
    73d6:	08 db       	rcall	.-2544   	; 0x69e8 <report_util_axis_values>
    73d8:	80 91 29 0c 	lds	r24, 0x0C29	; 0x800c29 <sys+0xb>
    }
  #endif

  #ifdef REPORT_FIELD_OVERRIDES
    if (sys.report_ovr_counter > 0) { sys.report_ovr_counter--; }
    73dc:	88 23       	and	r24, r24
    73de:	21 f0       	breq	.+8      	; 0x73e8 <report_realtime_status+0x318>
    73e0:	81 50       	subi	r24, 0x01	; 1
    73e2:	80 93 29 0c 	sts	0x0C29, r24	; 0x800c29 <sys+0xb>
    73e6:	3b c0       	rjmp	.+118    	; 0x745e <report_realtime_status+0x38e>
    else {
      if (sys.state & (STATE_HOMING | STATE_CYCLE | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)) {
    73e8:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    73ec:	8c 77       	andi	r24, 0x7C	; 124
        sys.report_ovr_counter = (REPORT_OVR_REFRESH_BUSY_COUNT-1); // Reset counter for slow refresh
    73ee:	21 f0       	breq	.+8      	; 0x73f8 <report_realtime_status+0x328>
    73f0:	83 e1       	ldi	r24, 0x13	; 19
    73f2:	80 93 29 0c 	sts	0x0C29, r24	; 0x800c29 <sys+0xb>
      } else { sys.report_ovr_counter = (REPORT_OVR_REFRESH_IDLE_COUNT-1); }
    73f6:	03 c0       	rjmp	.+6      	; 0x73fe <report_realtime_status+0x32e>
    73f8:	89 e0       	ldi	r24, 0x09	; 9
    73fa:	80 93 29 0c 	sts	0x0C29, r24	; 0x800c29 <sys+0xb>
      printPgmString(PSTR("|Ov:"));
    73fe:	83 e4       	ldi	r24, 0x43	; 67
    7400:	93 e0       	ldi	r25, 0x03	; 3
    7402:	1e d9       	rcall	.-3524   	; 0x6640 <printPgmString>
      print_uint8_base10(sys.f_override);
    7404:	0e e1       	ldi	r16, 0x1E	; 30
    7406:	1c e0       	ldi	r17, 0x0C	; 12
    7408:	f8 01       	movw	r30, r16
    740a:	87 81       	ldd	r24, Z+7	; 0x07
    740c:	2b d9       	rcall	.-3498   	; 0x6664 <print_uint8_base10>
    740e:	8c e2       	ldi	r24, 0x2C	; 44
      serial_write(',');
    7410:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    7414:	f8 01       	movw	r30, r16
      print_uint8_base10(sys.r_override);
    7416:	80 85       	ldd	r24, Z+8	; 0x08
    7418:	25 d9       	rcall	.-3510   	; 0x6664 <print_uint8_base10>
    741a:	8c e2       	ldi	r24, 0x2C	; 44
    741c:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
      serial_write(',');
    7420:	f8 01       	movw	r30, r16
    7422:	81 85       	ldd	r24, Z+9	; 0x09
      print_uint8_base10(sys.spindle_speed_ovr);
    7424:	1f d9       	rcall	.-3522   	; 0x6664 <print_uint8_base10>
    7426:	0e 94 45 12 	call	0x248a	; 0x248a <spindle_get_state>
    742a:	08 2f       	mov	r16, r24

      uint8_t sp_state = spindle_get_state();
    742c:	0e 94 8f 13 	call	0x271e	; 0x271e <coolant_get_state>
    7430:	18 2f       	mov	r17, r24
      uint8_t cl_state = coolant_get_state();
    7432:	01 11       	cpse	r16, r1
    7434:	1d c0       	rjmp	.+58     	; 0x7470 <report_realtime_status+0x3a0>
      if (sp_state || cl_state) {
    7436:	81 11       	cpse	r24, r1
    7438:	21 c0       	rjmp	.+66     	; 0x747c <report_realtime_status+0x3ac>
    743a:	11 c0       	rjmp	.+34     	; 0x745e <report_realtime_status+0x38e>
        printPgmString(PSTR("|A:"));
        if (sp_state) { // != SPINDLE_STATE_DISABLE
          if (sp_state == SPINDLE_STATE_CW) { serial_write('S'); } // CW
    743c:	83 e5       	ldi	r24, 0x53	; 83
    743e:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
          else { serial_write('C'); } // CCW
    7442:	03 c0       	rjmp	.+6      	; 0x744a <report_realtime_status+0x37a>
    7444:	83 e4       	ldi	r24, 0x43	; 67
    7446:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
        }
        if (cl_state & COOLANT_STATE_FLOOD) { serial_write('F'); }
    744a:	16 ff       	sbrs	r17, 6
    744c:	03 c0       	rjmp	.+6      	; 0x7454 <report_realtime_status+0x384>
    744e:	86 e4       	ldi	r24, 0x46	; 70
    7450:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
        if (cl_state & COOLANT_STATE_MIST) { serial_write('M'); }
    7454:	11 23       	and	r17, r17
    7456:	1c f4       	brge	.+6      	; 0x745e <report_realtime_status+0x38e>
    7458:	8d e4       	ldi	r24, 0x4D	; 77
    745a:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
    }
  #endif
  
  #ifdef LATHE
  // Report realtime spindle speed when bit is set in report mask
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_RPM_STATE) ) {
    745e:	80 91 04 0f 	lds	r24, 0x0F04	; 0x800f04 <settings+0x34>
	  report_RPM_state();
    7462:	82 fd       	sbrc	r24, 2
    7464:	1e db       	rcall	.-2500   	; 0x6aa2 <report_RPM_state>
  }
  #endif

  serial_write('>');
    7466:	8e e3       	ldi	r24, 0x3E	; 62
    7468:	0e 94 f7 13 	call	0x27ee	; 0x27ee <serial_write>
  report_util_line_feed();
    746c:	b4 da       	rcall	.-2712   	; 0x69d6 <report_util_line_feed>
    746e:	0a c0       	rjmp	.+20     	; 0x7484 <report_realtime_status+0x3b4>
}
    7470:	8f e3       	ldi	r24, 0x3F	; 63
      print_uint8_base10(sys.spindle_speed_ovr);

      uint8_t sp_state = spindle_get_state();
      uint8_t cl_state = coolant_get_state();
      if (sp_state || cl_state) {
        printPgmString(PSTR("|A:"));
    7472:	93 e0       	ldi	r25, 0x03	; 3
    7474:	e5 d8       	rcall	.-3638   	; 0x6640 <printPgmString>
    7476:	01 30       	cpi	r16, 0x01	; 1
    7478:	29 f7       	brne	.-54     	; 0x7444 <report_realtime_status+0x374>
        if (sp_state) { // != SPINDLE_STATE_DISABLE
          if (sp_state == SPINDLE_STATE_CW) { serial_write('S'); } // CW
    747a:	e0 cf       	rjmp	.-64     	; 0x743c <report_realtime_status+0x36c>
    747c:	8f e3       	ldi	r24, 0x3F	; 63
    747e:	93 e0       	ldi	r25, 0x03	; 3
      print_uint8_base10(sys.spindle_speed_ovr);

      uint8_t sp_state = spindle_get_state();
      uint8_t cl_state = coolant_get_state();
      if (sp_state || cl_state) {
        printPgmString(PSTR("|A:"));
    7480:	df d8       	rcall	.-3650   	; 0x6640 <printPgmString>
    7482:	e3 cf       	rjmp	.-58     	; 0x744a <report_realtime_status+0x37a>
    7484:	a4 96       	adiw	r28, 0x24	; 36
    7486:	0f b6       	in	r0, 0x3f	; 63
    7488:	f8 94       	cli
  }
  #endif

  serial_write('>');
  report_util_line_feed();
}
    748a:	de bf       	out	0x3e, r29	; 62
    748c:	0f be       	out	0x3f, r0	; 63
    748e:	cd bf       	out	0x3d, r28	; 61
    7490:	df 91       	pop	r29
    7492:	cf 91       	pop	r28
    7494:	1f 91       	pop	r17
    7496:	0f 91       	pop	r16
    7498:	ff 90       	pop	r15
    749a:	ef 90       	pop	r14
    749c:	df 90       	pop	r13
    749e:	cf 90       	pop	r12
    74a0:	bf 90       	pop	r11
    74a2:	af 90       	pop	r10
    74a4:	9f 90       	pop	r9
    74a6:	8f 90       	pop	r8
    74a8:	7f 90       	pop	r7
    74aa:	6f 90       	pop	r6
    74ac:	5f 90       	pop	r5
    74ae:	4f 90       	pop	r4
    74b0:	08 95       	ret

000074b2 <report_realtime_debug>:
    74b2:	08 95       	ret

000074b4 <system_init>:
#include "grbl.h"


void system_init()
{
  CONTROL_DDR &= ~(CONTROL_MASK); // Configure as input pins
    74b4:	e7 e0       	ldi	r30, 0x07	; 7
    74b6:	f1 e0       	ldi	r31, 0x01	; 1
    74b8:	80 81       	ld	r24, Z
    74ba:	80 77       	andi	r24, 0x70	; 112
    74bc:	80 83       	st	Z, r24
  #ifdef DISABLE_CONTROL_PIN_PULL_UP
    CONTROL_PORT &= ~(CONTROL_MASK); // Normal low operation. Requires external pull-down.
  #else
    CONTROL_PORT |= CONTROL_MASK;   // Enable internal pull-up resistors. Normal high operation.
    74be:	e8 e0       	ldi	r30, 0x08	; 8
    74c0:	f1 e0       	ldi	r31, 0x01	; 1
    74c2:	80 81       	ld	r24, Z
    74c4:	8f 68       	ori	r24, 0x8F	; 143
    74c6:	80 83       	st	Z, r24
  #endif
  CONTROL_PCMSK |= CONTROL_MASK;  // Enable specific pins of the Pin Change Interrupt
    74c8:	ed e6       	ldi	r30, 0x6D	; 109
    74ca:	f0 e0       	ldi	r31, 0x00	; 0
    74cc:	80 81       	ld	r24, Z
    74ce:	8f 68       	ori	r24, 0x8F	; 143
    74d0:	80 83       	st	Z, r24
  PCICR |= (1 << CONTROL_INT);   // Enable Pin Change Interrupt
    74d2:	e8 e6       	ldi	r30, 0x68	; 104
    74d4:	f0 e0       	ldi	r31, 0x00	; 0
    74d6:	80 81       	ld	r24, Z
    74d8:	84 60       	ori	r24, 0x04	; 4
    74da:	80 83       	st	Z, r24
    74dc:	08 95       	ret

000074de <system_control_get_state>:
// triggered is 1 and not triggered is 0. Invert mask is applied. Bitfield organization is
// defined by the CONTROL_PIN_INDEX in the header file.
uint8_t system_control_get_state()
{
  uint8_t control_state = 0;
  uint8_t pin = (CONTROL_PIN & CONTROL_MASK);
    74de:	20 91 06 01 	lds	r18, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
    74e2:	32 2f       	mov	r19, r18
    74e4:	3f 78       	andi	r19, 0x8F	; 143
  #ifdef INVERT_CONTROL_PIN_MASK
    pin ^= INVERT_CONTROL_PIN_MASK;
  #endif
  if (pin) {
    74e6:	79 f0       	breq	.+30     	; 0x7506 <system_control_get_state+0x28>
// Returns control pin state as a uint8 bitfield. Each bit indicates the input pin state, where
// triggered is 1 and not triggered is 0. Invert mask is applied. Bitfield organization is
// defined by the CONTROL_PIN_INDEX in the header file.
uint8_t system_control_get_state()
{
  uint8_t control_state = 0;
    74e8:	23 fb       	bst	r18, 3
    74ea:	88 27       	eor	r24, r24
    74ec:	80 f9       	bld	r24, 0
    74ee:	91 e0       	ldi	r25, 0x01	; 1
    74f0:	89 27       	eor	r24, r25
  #ifdef INVERT_CONTROL_PIN_MASK
    pin ^= INVERT_CONTROL_PIN_MASK;
  #endif
  if (pin) {
    if (bit_isfalse(pin,(1<<CONTROL_SAFETY_DOOR_BIT))) { control_state |= CONTROL_PIN_INDEX_SAFETY_DOOR; }
    if (bit_isfalse(pin,(1<<CONTROL_RESET_BIT))) { control_state |= CONTROL_PIN_INDEX_RESET; }
    74f2:	20 ff       	sbrs	r18, 0
    74f4:	82 60       	ori	r24, 0x02	; 2
    if (bit_isfalse(pin,(1<<CONTROL_FEED_HOLD_BIT))) { control_state |= CONTROL_PIN_INDEX_FEED_HOLD; }
    74f6:	21 ff       	sbrs	r18, 1
    74f8:	84 60       	ori	r24, 0x04	; 4
    if (bit_isfalse(pin,(1<<CONTROL_CYCLE_START_BIT))) { control_state |= CONTROL_PIN_INDEX_CYCLE_START; }
    74fa:	22 ff       	sbrs	r18, 2
    74fc:	88 60       	ori	r24, 0x08	; 8
    if (bit_isfalse(pin,(1<<CONTROL_SPINDLE_SYNC_BIT))) { control_state |= CONTROL_PIN_INDEX_SPINDLE_SYNC; }
    74fe:	33 23       	and	r19, r19
    7500:	1c f0       	brlt	.+6      	; 0x7508 <system_control_get_state+0x2a>
    7502:	80 61       	ori	r24, 0x10	; 16
    7504:	08 95       	ret
// Returns control pin state as a uint8 bitfield. Each bit indicates the input pin state, where
// triggered is 1 and not triggered is 0. Invert mask is applied. Bitfield organization is
// defined by the CONTROL_PIN_INDEX in the header file.
uint8_t system_control_get_state()
{
  uint8_t control_state = 0;
    7506:	80 e0       	ldi	r24, 0x00	; 0
    if (bit_isfalse(pin,(1<<CONTROL_FEED_HOLD_BIT))) { control_state |= CONTROL_PIN_INDEX_FEED_HOLD; }
    if (bit_isfalse(pin,(1<<CONTROL_CYCLE_START_BIT))) { control_state |= CONTROL_PIN_INDEX_CYCLE_START; }
    if (bit_isfalse(pin,(1<<CONTROL_SPINDLE_SYNC_BIT))) { control_state |= CONTROL_PIN_INDEX_SPINDLE_SYNC; }
  }
  return(control_state);
}
    7508:	08 95       	ret

0000750a <__vector_11>:
// Pin change interrupt for pin-out commands, i.e. cycle start, feed hold, and reset. Sets
// only the realtime command execute variable to have the main program execute these when
// its ready. This works exactly like the character-based realtime commands when picked off
// directly from the incoming serial data stream.
ISR(CONTROL_INT_vect)
{
    750a:	1f 92       	push	r1
    750c:	0f 92       	push	r0
    750e:	0f b6       	in	r0, 0x3f	; 63
    7510:	0f 92       	push	r0
    7512:	11 24       	eor	r1, r1
    7514:	0b b6       	in	r0, 0x3b	; 59
    7516:	0f 92       	push	r0
    7518:	2f 93       	push	r18
    751a:	3f 93       	push	r19
    751c:	4f 93       	push	r20
    751e:	5f 93       	push	r21
    7520:	6f 93       	push	r22
    7522:	7f 93       	push	r23
    7524:	8f 93       	push	r24
    7526:	9f 93       	push	r25
    7528:	af 93       	push	r26
    752a:	bf 93       	push	r27
    752c:	ef 93       	push	r30
    752e:	ff 93       	push	r31
  uint8_t pin = system_control_get_state();
    7530:	d6 df       	rcall	.-84     	; 0x74de <system_control_get_state>
  if (pin) {
    7532:	88 23       	and	r24, r24
    7534:	21 f1       	breq	.+72     	; 0x757e <__vector_11+0x74>
    if (bit_istrue(pin,CONTROL_PIN_INDEX_RESET)) {
    7536:	81 ff       	sbrs	r24, 1
    7538:	03 c0       	rjmp	.+6      	; 0x7540 <__vector_11+0x36>
      mc_reset();
    753a:	0e 94 2a 07 	call	0xe54	; 0xe54 <mc_reset>
    753e:	1f c0       	rjmp	.+62     	; 0x757e <__vector_11+0x74>
    } else if (bit_istrue(pin,CONTROL_PIN_INDEX_CYCLE_START)) {
    7540:	83 ff       	sbrs	r24, 3
    7542:	06 c0       	rjmp	.+12     	; 0x7550 <__vector_11+0x46>
      bit_true(sys_rt_exec_state, EXEC_CYCLE_START);
    7544:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    7548:	82 60       	ori	r24, 0x02	; 2
    754a:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <sys_rt_exec_state>
    754e:	17 c0       	rjmp	.+46     	; 0x757e <__vector_11+0x74>
    } else if (bit_istrue(pin,CONTROL_PIN_INDEX_FEED_HOLD)) {
    7550:	82 ff       	sbrs	r24, 2
    7552:	06 c0       	rjmp	.+12     	; 0x7560 <__vector_11+0x56>
      bit_true(sys_rt_exec_state, EXEC_FEED_HOLD); 
    7554:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    7558:	88 60       	ori	r24, 0x08	; 8
    755a:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <sys_rt_exec_state>
    755e:	0f c0       	rjmp	.+30     	; 0x757e <__vector_11+0x74>
    } else if (bit_istrue(pin,CONTROL_PIN_INDEX_SAFETY_DOOR)) {
    7560:	80 ff       	sbrs	r24, 0
    7562:	06 c0       	rjmp	.+12     	; 0x7570 <__vector_11+0x66>
      bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
    7564:	80 91 31 0c 	lds	r24, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    7568:	80 62       	ori	r24, 0x20	; 32
    756a:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <sys_rt_exec_state>
    756e:	07 c0       	rjmp	.+14     	; 0x757e <__vector_11+0x74>
	} else if (bit_istrue(pin,CONTROL_PIN_INDEX_SPINDLE_SYNC)) {
    7570:	84 ff       	sbrs	r24, 4
    7572:	05 c0       	rjmp	.+10     	; 0x757e <__vector_11+0x74>
	 bit_true(sys_sync_state, EXEC_SPINDLE_SYNC);   } 
    7574:	80 91 14 0c 	lds	r24, 0x0C14	; 0x800c14 <sys_sync_state>
    7578:	82 60       	ori	r24, 0x02	; 2
    757a:	80 93 14 0c 	sts	0x0C14, r24	; 0x800c14 <sys_sync_state>
  }
}
    757e:	ff 91       	pop	r31
    7580:	ef 91       	pop	r30
    7582:	bf 91       	pop	r27
    7584:	af 91       	pop	r26
    7586:	9f 91       	pop	r25
    7588:	8f 91       	pop	r24
    758a:	7f 91       	pop	r23
    758c:	6f 91       	pop	r22
    758e:	5f 91       	pop	r21
    7590:	4f 91       	pop	r20
    7592:	3f 91       	pop	r19
    7594:	2f 91       	pop	r18
    7596:	0f 90       	pop	r0
    7598:	0b be       	out	0x3b, r0	; 59
    759a:	0f 90       	pop	r0
    759c:	0f be       	out	0x3f, r0	; 63
    759e:	0f 90       	pop	r0
    75a0:	1f 90       	pop	r1
    75a2:	18 95       	reti

000075a4 <system_check_safety_door_ajar>:


// Returns if safety door is ajar(T) or closed(F), based on pin state.
uint8_t system_check_safety_door_ajar()
{
    return(system_control_get_state() & CONTROL_PIN_INDEX_SAFETY_DOOR);
    75a4:	9c df       	rcall	.-200    	; 0x74de <system_control_get_state>
}
    75a6:	81 70       	andi	r24, 0x01	; 1
    75a8:	08 95       	ret

000075aa <system_execute_startup>:


// Executes user startup script, if stored.
void system_execute_startup(char *line)
{
    75aa:	0f 93       	push	r16
    75ac:	1f 93       	push	r17
    75ae:	cf 93       	push	r28
    75b0:	8c 01       	movw	r16, r24
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    75b2:	c0 e0       	ldi	r28, 0x00	; 0
    if (!(settings_read_startup_line(n, line))) {
    75b4:	b8 01       	movw	r22, r16
    75b6:	8c 2f       	mov	r24, r28
    75b8:	0e 94 bf 25 	call	0x4b7e	; 0x4b7e <settings_read_startup_line>
    75bc:	81 11       	cpse	r24, r1
    75be:	06 c0       	rjmp	.+12     	; 0x75cc <system_execute_startup+0x22>
      line[0] = 0;
    75c0:	f8 01       	movw	r30, r16
    75c2:	10 82       	st	Z, r1
      report_execute_startup_message(line,STATUS_SETTING_READ_FAIL);
    75c4:	67 e0       	ldi	r22, 0x07	; 7
    75c6:	c8 01       	movw	r24, r16
    75c8:	41 dd       	rcall	.-1406   	; 0x704c <report_execute_startup_message>
    75ca:	0a c0       	rjmp	.+20     	; 0x75e0 <system_execute_startup+0x36>
    } else {
      if (line[0] != 0) {
    75cc:	f8 01       	movw	r30, r16
    75ce:	80 81       	ld	r24, Z
    75d0:	88 23       	and	r24, r24
    75d2:	31 f0       	breq	.+12     	; 0x75e0 <system_execute_startup+0x36>
        uint8_t status_code = gc_execute_line(line);
    75d4:	c8 01       	movw	r24, r16
    75d6:	0e 94 67 07 	call	0xece	; 0xece <gc_execute_line>
        report_execute_startup_message(line,status_code);
    75da:	68 2f       	mov	r22, r24
    75dc:	c8 01       	movw	r24, r16
    75de:	36 dd       	rcall	.-1428   	; 0x704c <report_execute_startup_message>

// Executes user startup script, if stored.
void system_execute_startup(char *line)
{
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    75e0:	cf 5f       	subi	r28, 0xFF	; 255
    75e2:	c2 30       	cpi	r28, 0x02	; 2
    75e4:	39 f7       	brne	.-50     	; 0x75b4 <system_execute_startup+0xa>
        uint8_t status_code = gc_execute_line(line);
        report_execute_startup_message(line,status_code);
      }
    }
  }
}
    75e6:	cf 91       	pop	r28
    75e8:	1f 91       	pop	r17
    75ea:	0f 91       	pop	r16
    75ec:	08 95       	ret

000075ee <system_flag_wco_change>:


void system_flag_wco_change()
{
  #ifdef FORCE_BUFFER_SYNC_DURING_WCO_CHANGE
    protocol_buffer_synchronize();
    75ee:	0e 94 02 19 	call	0x3204	; 0x3204 <protocol_buffer_synchronize>
  #endif
  sys.report_wco_counter = 0;
    75f2:	10 92 2a 0c 	sts	0x0C2A, r1	; 0x800c2a <sys+0xc>
    75f6:	08 95       	ret

000075f8 <system_convert_axis_steps_to_mpos>:

// Returns machine position of axis 'idx'. Must be sent a 'step' array.
// NOTE: If motor steps and machine position are not in the same coordinate frame, this function
//   serves as a central place to compute the transformation.
float system_convert_axis_steps_to_mpos(int32_t *steps, uint8_t idx)
{
    75f8:	cf 93       	push	r28
    75fa:	df 93       	push	r29
      pos = (float)system_convert_corexy_to_y_axis_steps(steps) / settings.steps_per_mm[idx];
    } else {
      pos = steps[idx]/settings.steps_per_mm[idx];
    }
  #else
    pos = steps[idx]/settings.steps_per_mm[idx];
    75fc:	c6 2f       	mov	r28, r22
    75fe:	d0 e0       	ldi	r29, 0x00	; 0
    7600:	cc 0f       	add	r28, r28
    7602:	dd 1f       	adc	r29, r29
    7604:	cc 0f       	add	r28, r28
    7606:	dd 1f       	adc	r29, r29
    7608:	8c 0f       	add	r24, r28
    760a:	9d 1f       	adc	r25, r29
  #endif
  return(pos);
    760c:	fc 01       	movw	r30, r24
    760e:	60 81       	ld	r22, Z
    7610:	71 81       	ldd	r23, Z+1	; 0x01
    7612:	82 81       	ldd	r24, Z+2	; 0x02
    7614:	93 81       	ldd	r25, Z+3	; 0x03
    7616:	fb d4       	rcall	.+2550   	; 0x800e <__floatsisf>
      pos = (float)system_convert_corexy_to_y_axis_steps(steps) / settings.steps_per_mm[idx];
    } else {
      pos = steps[idx]/settings.steps_per_mm[idx];
    }
  #else
    pos = steps[idx]/settings.steps_per_mm[idx];
    7618:	c0 53       	subi	r28, 0x30	; 48
    761a:	d1 4f       	sbci	r29, 0xF1	; 241
  #endif
  return(pos);
    761c:	28 81       	ld	r18, Y
    761e:	39 81       	ldd	r19, Y+1	; 0x01
    7620:	4a 81       	ldd	r20, Y+2	; 0x02
    7622:	5b 81       	ldd	r21, Y+3	; 0x03
    7624:	59 d4       	rcall	.+2226   	; 0x7ed8 <__divsf3>
}
    7626:	df 91       	pop	r29
    7628:	cf 91       	pop	r28
    762a:	08 95       	ret

0000762c <system_convert_array_steps_to_mpos>:


void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
    762c:	ef 92       	push	r14
    762e:	ff 92       	push	r15
    7630:	0f 93       	push	r16
    7632:	1f 93       	push	r17
    7634:	cf 93       	push	r28
    7636:	7b 01       	movw	r14, r22
    7638:	8c 01       	movw	r16, r24
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    763a:	c0 e0       	ldi	r28, 0x00	; 0
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
    763c:	6c 2f       	mov	r22, r28
    763e:	c7 01       	movw	r24, r14
    7640:	db df       	rcall	.-74     	; 0x75f8 <system_convert_axis_steps_to_mpos>
    7642:	f8 01       	movw	r30, r16
    7644:	61 93       	st	Z+, r22
    7646:	71 93       	st	Z+, r23
    7648:	81 93       	st	Z+, r24
    764a:	91 93       	st	Z+, r25
    764c:	8f 01       	movw	r16, r30


void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    764e:	cf 5f       	subi	r28, 0xFF	; 255
    7650:	c3 30       	cpi	r28, 0x03	; 3
    7652:	a1 f7       	brne	.-24     	; 0x763c <system_convert_array_steps_to_mpos+0x10>
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
  }
  return;
}
    7654:	cf 91       	pop	r28
    7656:	1f 91       	pop	r17
    7658:	0f 91       	pop	r16
    765a:	ff 90       	pop	r15
    765c:	ef 90       	pop	r14
    765e:	08 95       	ret

00007660 <system_check_travel_limits>:
#endif


// Checks and reports if target array exceeds machine travel limits.
uint8_t system_check_travel_limits(float *target)
{
    7660:	cf 92       	push	r12
    7662:	df 92       	push	r13
    7664:	ef 92       	push	r14
    7666:	ff 92       	push	r15
    7668:	cf 93       	push	r28
    766a:	df 93       	push	r29
    766c:	ec 01       	movw	r28, r24
      } else {
        if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { return(true); }
      }
    #else
      // NOTE: max_travel is stored as negative
      if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { return(true); }
    766e:	c8 80       	ld	r12, Y
    7670:	d9 80       	ldd	r13, Y+1	; 0x01
    7672:	ea 80       	ldd	r14, Y+2	; 0x02
    7674:	fb 80       	ldd	r15, Y+3	; 0x03
    7676:	20 e0       	ldi	r18, 0x00	; 0
    7678:	30 e0       	ldi	r19, 0x00	; 0
    767a:	a9 01       	movw	r20, r18
    767c:	c7 01       	movw	r24, r14
    767e:	b6 01       	movw	r22, r12
    7680:	27 d6       	rcall	.+3150   	; 0x82d0 <__gesf2>
    7682:	18 16       	cp	r1, r24
    7684:	0c f4       	brge	.+2      	; 0x7688 <system_check_travel_limits+0x28>
    7686:	41 c0       	rjmp	.+130    	; 0x770a <system_check_travel_limits+0xaa>
    7688:	20 91 f4 0e 	lds	r18, 0x0EF4	; 0x800ef4 <settings+0x24>
    768c:	30 91 f5 0e 	lds	r19, 0x0EF5	; 0x800ef5 <settings+0x25>
    7690:	40 91 f6 0e 	lds	r20, 0x0EF6	; 0x800ef6 <settings+0x26>
    7694:	50 91 f7 0e 	lds	r21, 0x0EF7	; 0x800ef7 <settings+0x27>
    7698:	c7 01       	movw	r24, r14
    769a:	b6 01       	movw	r22, r12
    769c:	16 d4       	rcall	.+2092   	; 0x7eca <__cmpsf2>
    769e:	88 23       	and	r24, r24
    76a0:	b4 f1       	brlt	.+108    	; 0x770e <system_check_travel_limits+0xae>
    76a2:	cc 80       	ldd	r12, Y+4	; 0x04
    76a4:	dd 80       	ldd	r13, Y+5	; 0x05
    76a6:	ee 80       	ldd	r14, Y+6	; 0x06
    76a8:	ff 80       	ldd	r15, Y+7	; 0x07
    76aa:	20 e0       	ldi	r18, 0x00	; 0
    76ac:	30 e0       	ldi	r19, 0x00	; 0
    76ae:	a9 01       	movw	r20, r18
    76b0:	c7 01       	movw	r24, r14
    76b2:	b6 01       	movw	r22, r12
    76b4:	0d d6       	rcall	.+3098   	; 0x82d0 <__gesf2>
    76b6:	18 16       	cp	r1, r24
    76b8:	64 f1       	brlt	.+88     	; 0x7712 <system_check_travel_limits+0xb2>
    76ba:	20 91 f8 0e 	lds	r18, 0x0EF8	; 0x800ef8 <settings+0x28>
    76be:	30 91 f9 0e 	lds	r19, 0x0EF9	; 0x800ef9 <settings+0x29>
    76c2:	40 91 fa 0e 	lds	r20, 0x0EFA	; 0x800efa <settings+0x2a>
    76c6:	50 91 fb 0e 	lds	r21, 0x0EFB	; 0x800efb <settings+0x2b>
    76ca:	c7 01       	movw	r24, r14
    76cc:	b6 01       	movw	r22, r12
    76ce:	fd d3       	rcall	.+2042   	; 0x7eca <__cmpsf2>
    76d0:	88 23       	and	r24, r24
    76d2:	0c f1       	brlt	.+66     	; 0x7716 <system_check_travel_limits+0xb6>
    76d4:	c8 84       	ldd	r12, Y+8	; 0x08
    76d6:	d9 84       	ldd	r13, Y+9	; 0x09
    76d8:	ea 84       	ldd	r14, Y+10	; 0x0a
    76da:	fb 84       	ldd	r15, Y+11	; 0x0b
    76dc:	20 e0       	ldi	r18, 0x00	; 0
    76de:	30 e0       	ldi	r19, 0x00	; 0
    76e0:	a9 01       	movw	r20, r18
    76e2:	c7 01       	movw	r24, r14
    76e4:	b6 01       	movw	r22, r12
    76e6:	f4 d5       	rcall	.+3048   	; 0x82d0 <__gesf2>
    76e8:	18 16       	cp	r1, r24
    76ea:	bc f0       	brlt	.+46     	; 0x771a <system_check_travel_limits+0xba>
    76ec:	20 91 fc 0e 	lds	r18, 0x0EFC	; 0x800efc <settings+0x2c>
    76f0:	30 91 fd 0e 	lds	r19, 0x0EFD	; 0x800efd <settings+0x2d>
    76f4:	40 91 fe 0e 	lds	r20, 0x0EFE	; 0x800efe <settings+0x2e>
    76f8:	50 91 ff 0e 	lds	r21, 0x0EFF	; 0x800eff <settings+0x2f>
    76fc:	c7 01       	movw	r24, r14
    76fe:	b6 01       	movw	r22, r12
    7700:	e4 d3       	rcall	.+1992   	; 0x7eca <__cmpsf2>
    7702:	88 1f       	adc	r24, r24
    7704:	88 27       	eor	r24, r24
    7706:	88 1f       	adc	r24, r24
    7708:	09 c0       	rjmp	.+18     	; 0x771c <system_check_travel_limits+0xbc>
    770a:	81 e0       	ldi	r24, 0x01	; 1
    770c:	07 c0       	rjmp	.+14     	; 0x771c <system_check_travel_limits+0xbc>
    770e:	81 e0       	ldi	r24, 0x01	; 1
    7710:	05 c0       	rjmp	.+10     	; 0x771c <system_check_travel_limits+0xbc>
    7712:	81 e0       	ldi	r24, 0x01	; 1
    7714:	03 c0       	rjmp	.+6      	; 0x771c <system_check_travel_limits+0xbc>
    7716:	81 e0       	ldi	r24, 0x01	; 1
    7718:	01 c0       	rjmp	.+2      	; 0x771c <system_check_travel_limits+0xbc>
    771a:	81 e0       	ldi	r24, 0x01	; 1
    #endif
  }
  return(false);
}
    771c:	df 91       	pop	r29
    771e:	cf 91       	pop	r28
    7720:	ff 90       	pop	r15
    7722:	ef 90       	pop	r14
    7724:	df 90       	pop	r13
    7726:	cf 90       	pop	r12
    7728:	08 95       	ret

0000772a <system_set_exec_state_flag>:


// Special handlers for setting and clearing Grbl's real-time execution flags.
void system_set_exec_state_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    772a:	9f b7       	in	r25, 0x3f	; 63
  cli();
    772c:	f8 94       	cli
  sys_rt_exec_state |= (mask);
    772e:	20 91 31 0c 	lds	r18, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    7732:	82 2b       	or	r24, r18
    7734:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <sys_rt_exec_state>
  SREG = sreg;
    7738:	9f bf       	out	0x3f, r25	; 63
    773a:	08 95       	ret

0000773c <system_execute_line>:
// next line during a cycle, so for switches like block delete, the switch only effects
// the lines that are processed afterward, not necessarily real-time during a cycle,
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line)
{
    773c:	8f 92       	push	r8
    773e:	9f 92       	push	r9
    7740:	af 92       	push	r10
    7742:	bf 92       	push	r11
    7744:	cf 92       	push	r12
    7746:	df 92       	push	r13
    7748:	ef 92       	push	r14
    774a:	ff 92       	push	r15
    774c:	0f 93       	push	r16
    774e:	1f 93       	push	r17
    7750:	cf 93       	push	r28
    7752:	df 93       	push	r29
    7754:	cd b7       	in	r28, 0x3d	; 61
    7756:	de b7       	in	r29, 0x3e	; 62
    7758:	29 97       	sbiw	r28, 0x09	; 9
    775a:	0f b6       	in	r0, 0x3f	; 63
    775c:	f8 94       	cli
    775e:	de bf       	out	0x3e, r29	; 62
    7760:	0f be       	out	0x3f, r0	; 63
    7762:	cd bf       	out	0x3d, r28	; 61
    7764:	8c 01       	movw	r16, r24
  uint8_t char_counter = 1;
    7766:	81 e0       	ldi	r24, 0x01	; 1
    7768:	89 83       	std	Y+1, r24	; 0x01
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    776a:	f8 01       	movw	r30, r16
    776c:	81 81       	ldd	r24, Z+1	; 0x01
    776e:	83 34       	cpi	r24, 0x43	; 67
    7770:	09 f1       	breq	.+66     	; 0x77b4 <system_execute_line+0x78>
    7772:	30 f4       	brcc	.+12     	; 0x7780 <system_execute_line+0x44>
    7774:	88 23       	and	r24, r24
    7776:	61 f0       	breq	.+24     	; 0x7790 <system_execute_line+0x54>
    7778:	84 32       	cpi	r24, 0x24	; 36
    777a:	09 f0       	breq	.+2      	; 0x777e <system_execute_line+0x42>
    777c:	56 c0       	rjmp	.+172    	; 0x782a <system_execute_line+0xee>
    777e:	1a c0       	rjmp	.+52     	; 0x77b4 <system_execute_line+0x78>
    7780:	8a 34       	cpi	r24, 0x4A	; 74
    7782:	49 f0       	breq	.+18     	; 0x7796 <system_execute_line+0x5a>
    7784:	88 35       	cpi	r24, 0x58	; 88
    7786:	b1 f0       	breq	.+44     	; 0x77b4 <system_execute_line+0x78>
    7788:	87 34       	cpi	r24, 0x47	; 71
    778a:	09 f0       	breq	.+2      	; 0x778e <system_execute_line+0x52>
    778c:	4e c0       	rjmp	.+156    	; 0x782a <system_execute_line+0xee>
    778e:	12 c0       	rjmp	.+36     	; 0x77b4 <system_execute_line+0x78>
    case 0 : report_grbl_help(); break;
    7790:	26 da       	rcall	.-2996   	; 0x6bde <report_grbl_help>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7792:	f1 2c       	mov	r15, r1
{
  uint8_t char_counter = 1;
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    7794:	14 c2       	rjmp	.+1064   	; 0x7bbe <system_execute_line+0x482>
    case 'J' : // Jogging
      // Execute only if in IDLE or JOG states.
      if (sys.state != STATE_IDLE && sys.state != STATE_JOG) { return(STATUS_IDLE_ERROR); }
    7796:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    779a:	8f 7d       	andi	r24, 0xDF	; 223
    779c:	09 f0       	breq	.+2      	; 0x77a0 <system_execute_line+0x64>
    779e:	85 c1       	rjmp	.+778    	; 0x7aaa <system_execute_line+0x36e>
      if(line[2] != '=') { return(STATUS_INVALID_STATEMENT); }
    77a0:	f8 01       	movw	r30, r16
    77a2:	82 81       	ldd	r24, Z+2	; 0x02
    77a4:	8d 33       	cpi	r24, 0x3D	; 61
    77a6:	09 f0       	breq	.+2      	; 0x77aa <system_execute_line+0x6e>
    77a8:	84 c1       	rjmp	.+776    	; 0x7ab2 <system_execute_line+0x376>
      return(gc_execute_line(line)); // NOTE: $J= is ignored inside g-code parser and used to detect jog motions.
    77aa:	c8 01       	movw	r24, r16
    77ac:	0e 94 67 07 	call	0xece	; 0xece <gc_execute_line>
    77b0:	f8 2e       	mov	r15, r24
    77b2:	05 c2       	rjmp	.+1034   	; 0x7bbe <system_execute_line+0x482>
      break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    77b4:	f8 01       	movw	r30, r16
    77b6:	92 81       	ldd	r25, Z+2	; 0x02
    77b8:	91 11       	cpse	r25, r1
    77ba:	80 c1       	rjmp	.+768    	; 0x7abc <system_execute_line+0x380>
      switch( line[1] ) {
    77bc:	83 34       	cpi	r24, 0x43	; 67
    77be:	a1 f0       	breq	.+40     	; 0x77e8 <system_execute_line+0xac>
    77c0:	18 f4       	brcc	.+6      	; 0x77c8 <system_execute_line+0x8c>
    77c2:	84 32       	cpi	r24, 0x24	; 36
    77c4:	31 f0       	breq	.+12     	; 0x77d2 <system_execute_line+0x96>
    77c6:	7f c1       	rjmp	.+766    	; 0x7ac6 <system_execute_line+0x38a>
    77c8:	87 34       	cpi	r24, 0x47	; 71
    77ca:	59 f0       	breq	.+22     	; 0x77e2 <system_execute_line+0xa6>
    77cc:	88 35       	cpi	r24, 0x58	; 88
    77ce:	f9 f0       	breq	.+62     	; 0x780e <system_execute_line+0xd2>
    77d0:	7a c1       	rjmp	.+756    	; 0x7ac6 <system_execute_line+0x38a>
    77d2:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    77d6:	88 71       	andi	r24, 0x18	; 24
    77d8:	f8 2e       	mov	r15, r24
        case '$' : // Prints Grbl settings
          if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    77da:	09 f0       	breq	.+2      	; 0x77de <system_execute_line+0xa2>
          else { report_grbl_settings(); }
    77dc:	76 c1       	rjmp	.+748    	; 0x7aca <system_execute_line+0x38e>
          break;
    77de:	03 da       	rcall	.-3066   	; 0x6be6 <report_grbl_settings>
        case 'G' : // Prints gcode parser state
          // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
          report_gcode_modes();
    77e0:	ee c1       	rjmp	.+988    	; 0x7bbe <system_execute_line+0x482>
    77e2:	8f db       	rcall	.-2274   	; 0x6f02 <report_gcode_modes>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    77e4:	f1 2c       	mov	r15, r1
          else { report_grbl_settings(); }
          break;
        case 'G' : // Prints gcode parser state
          // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
          report_gcode_modes();
          break;
    77e6:	eb c1       	rjmp	.+982    	; 0x7bbe <system_execute_line+0x482>
        case 'C' : // Set check g-code mode [IDLE/CHECK]
          // Perform reset when toggling off. Check g-code mode should only work if Grbl
          // is idle and ready, regardless of alarm locks. This is mainly to keep things
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) {
    77e8:	f0 90 1e 0c 	lds	r15, 0x0C1E	; 0x800c1e <sys>
    77ec:	f2 e0       	ldi	r31, 0x02	; 2
    77ee:	ff 12       	cpse	r15, r31
    77f0:	06 c0       	rjmp	.+12     	; 0x77fe <system_execute_line+0xc2>
            mc_reset();
    77f2:	0e 94 2a 07 	call	0xe54	; 0xe54 <mc_reset>
            report_feedback_message(MESSAGE_DISABLED);
    77f6:	85 e0       	ldi	r24, 0x05	; 5
    77f8:	ae d9       	rcall	.-3236   	; 0x6b56 <report_feedback_message>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    77fa:	f1 2c       	mov	r15, r1
    77fc:	e0 c1       	rjmp	.+960    	; 0x7bbe <system_execute_line+0x482>
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) {
            mc_reset();
            report_feedback_message(MESSAGE_DISABLED);
          } else {
            if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    77fe:	f1 10       	cpse	r15, r1
    7800:	68 c1       	rjmp	.+720    	; 0x7ad2 <system_execute_line+0x396>
            sys.state = STATE_CHECK_MODE;
    7802:	82 e0       	ldi	r24, 0x02	; 2
    7804:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
            report_feedback_message(MESSAGE_ENABLED);
    7808:	84 e0       	ldi	r24, 0x04	; 4
    780a:	a5 d9       	rcall	.-3254   	; 0x6b56 <report_feedback_message>
    780c:	d8 c1       	rjmp	.+944    	; 0x7bbe <system_execute_line+0x482>
          }
          break;
        case 'X' : // Disable alarm lock [ALARM]
          if (sys.state == STATE_ALARM) {
    780e:	80 91 1e 0c 	lds	r24, 0x0C1E	; 0x800c1e <sys>
    7812:	81 30       	cpi	r24, 0x01	; 1
    7814:	09 f0       	breq	.+2      	; 0x7818 <system_execute_line+0xdc>
            // Block if safety door is ajar.
            if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); }
    7816:	61 c1       	rjmp	.+706    	; 0x7ada <system_execute_line+0x39e>
    7818:	c5 de       	rcall	.-630    	; 0x75a4 <system_check_safety_door_ajar>
    781a:	f8 2e       	mov	r15, r24
    781c:	81 11       	cpse	r24, r1
            report_feedback_message(MESSAGE_ALARM_UNLOCK);
    781e:	5f c1       	rjmp	.+702    	; 0x7ade <system_execute_line+0x3a2>
    7820:	83 e0       	ldi	r24, 0x03	; 3
    7822:	99 d9       	rcall	.-3278   	; 0x6b56 <report_feedback_message>
            sys.state = STATE_IDLE;
    7824:	10 92 1e 0c 	sts	0x0C1E, r1	; 0x800c1e <sys>
    7828:	ca c1       	rjmp	.+916    	; 0x7bbe <system_execute_line+0x482>
          break;
      }
      break;
    default :
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    782a:	90 91 1e 0c 	lds	r25, 0x0C1E	; 0x800c1e <sys>
    782e:	92 30       	cpi	r25, 0x02	; 2
    7830:	08 f0       	brcs	.+2      	; 0x7834 <system_execute_line+0xf8>
    7832:	5a c1       	rjmp	.+692    	; 0x7ae8 <system_execute_line+0x3ac>
      switch( line[1] ) {
    7834:	89 34       	cpi	r24, 0x49	; 73
    7836:	09 f4       	brne	.+2      	; 0x783a <system_execute_line+0xfe>
    7838:	5e c0       	rjmp	.+188    	; 0x78f6 <system_execute_line+0x1ba>
    783a:	28 f4       	brcc	.+10     	; 0x7846 <system_execute_line+0x10a>
    783c:	83 32       	cpi	r24, 0x23	; 35
    783e:	69 f0       	breq	.+26     	; 0x785a <system_execute_line+0x11e>
    7840:	88 34       	cpi	r24, 0x48	; 72
    7842:	91 f0       	breq	.+36     	; 0x7868 <system_execute_line+0x12c>
    7844:	c2 c0       	rjmp	.+388    	; 0x79ca <system_execute_line+0x28e>
    7846:	82 35       	cpi	r24, 0x52	; 82
    7848:	09 f4       	brne	.+2      	; 0x784c <system_execute_line+0x110>
    784a:	77 c0       	rjmp	.+238    	; 0x793a <system_execute_line+0x1fe>
    784c:	83 35       	cpi	r24, 0x53	; 83
    784e:	09 f4       	brne	.+2      	; 0x7852 <system_execute_line+0x116>
    7850:	42 c0       	rjmp	.+132    	; 0x78d6 <system_execute_line+0x19a>
    7852:	8e 34       	cpi	r24, 0x4E	; 78
    7854:	09 f0       	breq	.+2      	; 0x7858 <system_execute_line+0x11c>
    7856:	b9 c0       	rjmp	.+370    	; 0x79ca <system_execute_line+0x28e>
    7858:	9a c0       	rjmp	.+308    	; 0x798e <system_execute_line+0x252>
        case '#' : // Print Grbl NGC parameters
          if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    785a:	f8 01       	movw	r30, r16
    785c:	82 81       	ldd	r24, Z+2	; 0x02
    785e:	81 11       	cpse	r24, r1
          else { report_ngc_parameters(); }
    7860:	47 c1       	rjmp	.+654    	; 0x7af0 <system_execute_line+0x3b4>
    7862:	e8 da       	rcall	.-2608   	; 0x6e34 <report_ngc_parameters>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7864:	f1 2c       	mov	r15, r1
        case '#' : // Print Grbl NGC parameters
          if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
          else { report_ngc_parameters(); }
          break;
        case 'H' : // Perform homing cycle [IDLE/ALARM]
          if (bit_isfalse(settings.flags,BITFLAG_HOMING_ENABLE)) {return(STATUS_SETTING_DISABLED); }
    7866:	ab c1       	rjmp	.+854    	; 0x7bbe <system_execute_line+0x482>
    7868:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    786c:	84 ff       	sbrs	r24, 4
          if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); } // Block if safety door is ajar.
    786e:	45 c1       	rjmp	.+650    	; 0x7afa <system_execute_line+0x3be>
    7870:	99 de       	rcall	.-718    	; 0x75a4 <system_check_safety_door_ajar>
    7872:	e8 2e       	mov	r14, r24
    7874:	81 11       	cpse	r24, r1
    7876:	46 c1       	rjmp	.+652    	; 0x7b04 <system_execute_line+0x3c8>
          sys.state = STATE_HOMING; // Set system state variable
    7878:	84 e0       	ldi	r24, 0x04	; 4
    787a:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
          if (line[2] == 0) {
    787e:	f8 01       	movw	r30, r16
    7880:	82 81       	ldd	r24, Z+2	; 0x02
    7882:	81 11       	cpse	r24, r1
    7884:	03 c0       	rjmp	.+6      	; 0x788c <system_execute_line+0x150>
            mc_homing_cycle(HOMING_CYCLE_ALL);
    7886:	0e 94 98 06 	call	0xd30	; 0xd30 <mc_homing_cycle>
    788a:	16 c0       	rjmp	.+44     	; 0x78b8 <system_execute_line+0x17c>
          #ifdef HOMING_SINGLE_AXIS_COMMANDS
            } else if (line[3] == 0) {
    788c:	f8 01       	movw	r30, r16
    788e:	93 81       	ldd	r25, Z+3	; 0x03
    7890:	91 11       	cpse	r25, r1
    7892:	3d c1       	rjmp	.+634    	; 0x7b0e <system_execute_line+0x3d2>
              switch (line[2]) {
    7894:	89 35       	cpi	r24, 0x59	; 89
    7896:	49 f0       	breq	.+18     	; 0x78aa <system_execute_line+0x16e>
    7898:	8a 35       	cpi	r24, 0x5A	; 90
    789a:	59 f0       	breq	.+22     	; 0x78b2 <system_execute_line+0x176>
    789c:	88 35       	cpi	r24, 0x58	; 88
    789e:	09 f0       	breq	.+2      	; 0x78a2 <system_execute_line+0x166>
    78a0:	3b c1       	rjmp	.+630    	; 0x7b18 <system_execute_line+0x3dc>
                case 'X': mc_homing_cycle(HOMING_CYCLE_X); break;
    78a2:	81 e0       	ldi	r24, 0x01	; 1
    78a4:	0e 94 98 06 	call	0xd30	; 0xd30 <mc_homing_cycle>
    78a8:	07 c0       	rjmp	.+14     	; 0x78b8 <system_execute_line+0x17c>
                case 'Y': mc_homing_cycle(HOMING_CYCLE_Y); break;
    78aa:	82 e0       	ldi	r24, 0x02	; 2
    78ac:	0e 94 98 06 	call	0xd30	; 0xd30 <mc_homing_cycle>
    78b0:	03 c0       	rjmp	.+6      	; 0x78b8 <system_execute_line+0x17c>
                case 'Z': mc_homing_cycle(HOMING_CYCLE_Z); break;
    78b2:	84 e0       	ldi	r24, 0x04	; 4
    78b4:	0e 94 98 06 	call	0xd30	; 0xd30 <mc_homing_cycle>
                default: return(STATUS_INVALID_STATEMENT);
              }
          #endif
          } else { return(STATUS_INVALID_STATEMENT); }
          if (!sys.abort) {  // Execute startup scripts after successful homing.
    78b8:	f0 90 1f 0c 	lds	r15, 0x0C1F	; 0x800c1f <sys+0x1>
    78bc:	f1 10       	cpse	r15, r1
    78be:	31 c1       	rjmp	.+610    	; 0x7b22 <system_execute_line+0x3e6>
            sys.state = STATE_IDLE; // Set to IDLE when complete.
    78c0:	10 92 1e 0c 	sts	0x0C1E, r1	; 0x800c1e <sys>
            st_go_idle(); // Set steppers to the settings idle state before returning.
    78c4:	0e 94 2d 19 	call	0x325a	; 0x325a <st_go_idle>
            if (line[2] == 0) { system_execute_startup(line); }
    78c8:	f8 01       	movw	r30, r16
    78ca:	82 81       	ldd	r24, Z+2	; 0x02
    78cc:	81 11       	cpse	r24, r1
    78ce:	77 c1       	rjmp	.+750    	; 0x7bbe <system_execute_line+0x482>
    78d0:	c8 01       	movw	r24, r16
    78d2:	6b de       	rcall	.-810    	; 0x75aa <system_execute_startup>
    78d4:	74 c1       	rjmp	.+744    	; 0x7bbe <system_execute_line+0x482>
          }
          break;
        case 'S' : // Puts Grbl to sleep [IDLE/ALARM]
          if ((line[2] != 'L') || (line[3] != 'P') || (line[4] != 0)) { return(STATUS_INVALID_STATEMENT); }
    78d6:	f8 01       	movw	r30, r16
    78d8:	82 81       	ldd	r24, Z+2	; 0x02
    78da:	8c 34       	cpi	r24, 0x4C	; 76
    78dc:	09 f0       	breq	.+2      	; 0x78e0 <system_execute_line+0x1a4>
    78de:	23 c1       	rjmp	.+582    	; 0x7b26 <system_execute_line+0x3ea>
    78e0:	83 81       	ldd	r24, Z+3	; 0x03
    78e2:	80 35       	cpi	r24, 0x50	; 80
    78e4:	09 f0       	breq	.+2      	; 0x78e8 <system_execute_line+0x1ac>
    78e6:	24 c1       	rjmp	.+584    	; 0x7b30 <system_execute_line+0x3f4>
    78e8:	84 81       	ldd	r24, Z+4	; 0x04
    78ea:	81 11       	cpse	r24, r1
          system_set_exec_state_flag(EXEC_SLEEP); // Set to execute sleep mode immediately
    78ec:	26 c1       	rjmp	.+588    	; 0x7b3a <system_execute_line+0x3fe>
    78ee:	80 e8       	ldi	r24, 0x80	; 128
    78f0:	1c df       	rcall	.-456    	; 0x772a <system_set_exec_state_flag>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    78f2:	f1 2c       	mov	r15, r1
          }
          break;
        case 'S' : // Puts Grbl to sleep [IDLE/ALARM]
          if ((line[2] != 'L') || (line[3] != 'P') || (line[4] != 0)) { return(STATUS_INVALID_STATEMENT); }
          system_set_exec_state_flag(EXEC_SLEEP); // Set to execute sleep mode immediately
          break;
    78f4:	64 c1       	rjmp	.+712    	; 0x7bbe <system_execute_line+0x482>
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) {
    78f6:	82 e0       	ldi	r24, 0x02	; 2
    78f8:	89 83       	std	Y+1, r24	; 0x01
    78fa:	f8 01       	movw	r30, r16
    78fc:	82 81       	ldd	r24, Z+2	; 0x02
    78fe:	81 11       	cpse	r24, r1
            settings_read_build_info(line);
    7900:	07 c0       	rjmp	.+14     	; 0x7910 <system_execute_line+0x1d4>
    7902:	c8 01       	movw	r24, r16
    7904:	0e 94 dd 25 	call	0x4bba	; 0x4bba <settings_read_build_info>
            report_build_info(line);
    7908:	c8 01       	movw	r24, r16
    790a:	b3 db       	rcall	.-2202   	; 0x7072 <report_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    790c:	f1 2c       	mov	r15, r1
    790e:	57 c1       	rjmp	.+686    	; 0x7bbe <system_execute_line+0x482>
          if ( line[++char_counter] == 0 ) {
            settings_read_build_info(line);
            report_build_info(line);
          #ifdef ENABLE_BUILD_INFO_WRITE_COMMAND
            } else { // Store startup line [IDLE/ALARM]
              if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    7910:	8d 33       	cpi	r24, 0x3D	; 61
    7912:	09 f0       	breq	.+2      	; 0x7916 <system_execute_line+0x1da>
    7914:	17 c1       	rjmp	.+558    	; 0x7b44 <system_execute_line+0x408>
    7916:	83 e0       	ldi	r24, 0x03	; 3
              helper_var = char_counter; // Set helper variable as counter to start of user info line.
              do {
                line[char_counter-helper_var] = line[char_counter];
    7918:	f8 01       	movw	r30, r16
    791a:	e8 0f       	add	r30, r24
    791c:	f1 1d       	adc	r31, r1
    791e:	90 81       	ld	r25, Z
    7920:	df 01       	movw	r26, r30
    7922:	13 97       	sbiw	r26, 0x03	; 3
    7924:	9c 93       	st	X, r25
              } while (line[char_counter++] != 0);
    7926:	8f 5f       	subi	r24, 0xFF	; 255
    7928:	90 81       	ld	r25, Z
    792a:	91 11       	cpse	r25, r1
    792c:	f5 cf       	rjmp	.-22     	; 0x7918 <system_execute_line+0x1dc>
    792e:	89 83       	std	Y+1, r24	; 0x01
              settings_store_build_info(line);
    7930:	c8 01       	movw	r24, r16
    7932:	0e 94 46 25 	call	0x4a8c	; 0x4a8c <settings_store_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7936:	f1 2c       	mov	r15, r1
    7938:	42 c1       	rjmp	.+644    	; 0x7bbe <system_execute_line+0x482>
              settings_store_build_info(line);
          #endif
          }
          break;
        case 'R' : // Restore defaults [IDLE/ALARM]
          if ((line[2] != 'S') || (line[3] != 'T') || (line[4] != '=') || (line[6] != 0)) { return(STATUS_INVALID_STATEMENT); }
    793a:	f8 01       	movw	r30, r16
    793c:	82 81       	ldd	r24, Z+2	; 0x02
    793e:	83 35       	cpi	r24, 0x53	; 83
    7940:	09 f0       	breq	.+2      	; 0x7944 <system_execute_line+0x208>
    7942:	05 c1       	rjmp	.+522    	; 0x7b4e <system_execute_line+0x412>
    7944:	83 81       	ldd	r24, Z+3	; 0x03
    7946:	84 35       	cpi	r24, 0x54	; 84
    7948:	09 f0       	breq	.+2      	; 0x794c <system_execute_line+0x210>
    794a:	06 c1       	rjmp	.+524    	; 0x7b58 <system_execute_line+0x41c>
    794c:	84 81       	ldd	r24, Z+4	; 0x04
    794e:	8d 33       	cpi	r24, 0x3D	; 61
    7950:	09 f0       	breq	.+2      	; 0x7954 <system_execute_line+0x218>
    7952:	07 c1       	rjmp	.+526    	; 0x7b62 <system_execute_line+0x426>
    7954:	86 81       	ldd	r24, Z+6	; 0x06
    7956:	81 11       	cpse	r24, r1
    7958:	09 c1       	rjmp	.+530    	; 0x7b6c <system_execute_line+0x430>
          switch (line[5]) {
    795a:	85 81       	ldd	r24, Z+5	; 0x05
    795c:	84 32       	cpi	r24, 0x24	; 36
    795e:	31 f0       	breq	.+12     	; 0x796c <system_execute_line+0x230>
    7960:	8a 32       	cpi	r24, 0x2A	; 42
    7962:	61 f0       	breq	.+24     	; 0x797c <system_execute_line+0x240>
    7964:	83 32       	cpi	r24, 0x23	; 35
    7966:	09 f0       	breq	.+2      	; 0x796a <system_execute_line+0x22e>
    7968:	06 c1       	rjmp	.+524    	; 0x7b76 <system_execute_line+0x43a>
    796a:	04 c0       	rjmp	.+8      	; 0x7974 <system_execute_line+0x238>
            #ifdef ENABLE_RESTORE_EEPROM_DEFAULT_SETTINGS
              case '$': settings_restore(SETTINGS_RESTORE_DEFAULTS); break;
    796c:	81 e0       	ldi	r24, 0x01	; 1
    796e:	0e 94 6d 25 	call	0x4ada	; 0x4ada <settings_restore>
            #endif
            #ifdef ENABLE_RESTORE_EEPROM_CLEAR_PARAMETERS
              case '#': settings_restore(SETTINGS_RESTORE_PARAMETERS); break;
    7972:	07 c0       	rjmp	.+14     	; 0x7982 <system_execute_line+0x246>
    7974:	82 e0       	ldi	r24, 0x02	; 2
    7976:	0e 94 6d 25 	call	0x4ada	; 0x4ada <settings_restore>
            #endif
            #ifdef ENABLE_RESTORE_EEPROM_WIPE_ALL
              case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
    797a:	03 c0       	rjmp	.+6      	; 0x7982 <system_execute_line+0x246>
    797c:	8f ef       	ldi	r24, 0xFF	; 255
    797e:	0e 94 6d 25 	call	0x4ada	; 0x4ada <settings_restore>
            #endif
            default: return(STATUS_INVALID_STATEMENT);
          }
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
    7982:	89 e0       	ldi	r24, 0x09	; 9
    7984:	e8 d8       	rcall	.-3632   	; 0x6b56 <report_feedback_message>
          mc_reset(); // Force reset to ensure settings are initialized correctly.
    7986:	0e 94 2a 07 	call	0xe54	; 0xe54 <mc_reset>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    798a:	f1 2c       	mov	r15, r1
            #endif
            default: return(STATUS_INVALID_STATEMENT);
          }
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
          mc_reset(); // Force reset to ensure settings are initialized correctly.
          break;
    798c:	18 c1       	rjmp	.+560    	; 0x7bbe <system_execute_line+0x482>
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
    798e:	82 e0       	ldi	r24, 0x02	; 2
    7990:	89 83       	std	Y+1, r24	; 0x01
    7992:	f8 01       	movw	r30, r16
    7994:	82 81       	ldd	r24, Z+2	; 0x02
    7996:	81 11       	cpse	r24, r1
    7998:	13 c0       	rjmp	.+38     	; 0x79c0 <system_execute_line+0x284>
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
              if (!(settings_read_startup_line(helper_var, line))) {
    799a:	f1 2c       	mov	r15, r1
    799c:	b8 01       	movw	r22, r16
    799e:	8f 2d       	mov	r24, r15
    79a0:	0e 94 bf 25 	call	0x4b7e	; 0x4b7e <settings_read_startup_line>
                report_status_message(STATUS_SETTING_READ_FAIL);
    79a4:	81 11       	cpse	r24, r1
    79a6:	03 c0       	rjmp	.+6      	; 0x79ae <system_execute_line+0x272>
    79a8:	87 e0       	ldi	r24, 0x07	; 7
    79aa:	5e d8       	rcall	.-3908   	; 0x6a68 <report_status_message>
              } else {
                report_startup_line(helper_var,line);
    79ac:	03 c0       	rjmp	.+6      	; 0x79b4 <system_execute_line+0x278>
    79ae:	b8 01       	movw	r22, r16
    79b0:	8f 2d       	mov	r24, r15
    79b2:	38 db       	rcall	.-2448   	; 0x7024 <report_startup_line>
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
          mc_reset(); // Force reset to ensure settings are initialized correctly.
          break;
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
    79b4:	f3 94       	inc	r15
    79b6:	f2 e0       	ldi	r31, 0x02	; 2
    79b8:	ff 12       	cpse	r15, r31
    79ba:	f0 cf       	rjmp	.-32     	; 0x799c <system_execute_line+0x260>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    79bc:	f1 2c       	mov	r15, r1
    79be:	ff c0       	rjmp	.+510    	; 0x7bbe <system_execute_line+0x482>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    79c0:	91 11       	cpse	r25, r1
    79c2:	de c0       	rjmp	.+444    	; 0x7b80 <system_execute_line+0x444>
            helper_var = true;  // Set helper_var to flag storing method.
    79c4:	ff 24       	eor	r15, r15
    79c6:	f3 94       	inc	r15
    79c8:	01 c0       	rjmp	.+2      	; 0x79cc <system_execute_line+0x290>
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line)
{
  uint8_t char_counter = 1;
  uint8_t helper_var = 0; // Helper variable
    79ca:	f1 2c       	mov	r15, r1
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
            helper_var = true;  // Set helper_var to flag storing method.
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    79cc:	ae 01       	movw	r20, r28
    79ce:	4e 5f       	subi	r20, 0xFE	; 254
    79d0:	5f 4f       	sbci	r21, 0xFF	; 255
    79d2:	be 01       	movw	r22, r28
    79d4:	6f 5f       	subi	r22, 0xFF	; 255
    79d6:	7f 4f       	sbci	r23, 0xFF	; 255
    79d8:	c8 01       	movw	r24, r16
    79da:	0e 94 03 2e 	call	0x5c06	; 0x5c06 <read_float>
    79de:	88 23       	and	r24, r24
    79e0:	09 f4       	brne	.+2      	; 0x79e4 <system_execute_line+0x2a8>
    79e2:	d2 c0       	rjmp	.+420    	; 0x7b88 <system_execute_line+0x44c>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    79e4:	89 81       	ldd	r24, Y+1	; 0x01
    79e6:	41 e0       	ldi	r20, 0x01	; 1
    79e8:	48 0f       	add	r20, r24
    79ea:	49 83       	std	Y+1, r20	; 0x01
    79ec:	f8 01       	movw	r30, r16
    79ee:	e8 0f       	add	r30, r24
    79f0:	f1 1d       	adc	r31, r1
    79f2:	80 81       	ld	r24, Z
    79f4:	8d 33       	cpi	r24, 0x3D	; 61
    79f6:	09 f0       	breq	.+2      	; 0x79fa <system_execute_line+0x2be>
    79f8:	cb c0       	rjmp	.+406    	; 0x7b90 <system_execute_line+0x454>
          if (helper_var) { // Store startup line
    79fa:	ff 20       	and	r15, r15
    79fc:	39 f1       	breq	.+78     	; 0x7a4c <system_execute_line+0x310>
    79fe:	24 2f       	mov	r18, r20
            // Prepare sending gcode block to gcode parser by shifting all characters
            helper_var = char_counter; // Set helper variable as counter to start of gcode block
            do {
              line[char_counter-helper_var] = line[char_counter];
    7a00:	50 e0       	ldi	r21, 0x00	; 0
    7a02:	82 2f       	mov	r24, r18
    7a04:	90 e0       	ldi	r25, 0x00	; 0
    7a06:	d8 01       	movw	r26, r16
    7a08:	a8 0f       	add	r26, r24
    7a0a:	b9 1f       	adc	r27, r25
    7a0c:	3c 91       	ld	r19, X
    7a0e:	84 1b       	sub	r24, r20
    7a10:	95 0b       	sbc	r25, r21
    7a12:	f8 01       	movw	r30, r16
    7a14:	e8 0f       	add	r30, r24
    7a16:	f9 1f       	adc	r31, r25
    7a18:	30 83       	st	Z, r19
            } while (line[char_counter++] != 0);
    7a1a:	2f 5f       	subi	r18, 0xFF	; 255
    7a1c:	8c 91       	ld	r24, X
    7a1e:	81 11       	cpse	r24, r1
    7a20:	f0 cf       	rjmp	.-32     	; 0x7a02 <system_execute_line+0x2c6>
    7a22:	29 83       	std	Y+1, r18	; 0x01
            if (char_counter > EEPROM_LINE_SIZE) { return(STATUS_LINE_LENGTH_EXCEEDED); }
    7a24:	21 35       	cpi	r18, 0x51	; 81
    7a26:	08 f0       	brcs	.+2      	; 0x7a2a <system_execute_line+0x2ee>
    7a28:	b8 c0       	rjmp	.+368    	; 0x7b9a <system_execute_line+0x45e>
            // Execute gcode block to ensure block is valid.
            helper_var = gc_execute_line(line); // Set helper_var to returned status code.
    7a2a:	c8 01       	movw	r24, r16
    7a2c:	0e 94 67 07 	call	0xece	; 0xece <gc_execute_line>
            if (helper_var) { return(helper_var); }
    7a30:	f8 2e       	mov	r15, r24
            else {
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
    7a32:	81 11       	cpse	r24, r1
    7a34:	c4 c0       	rjmp	.+392    	; 0x7bbe <system_execute_line+0x482>
    7a36:	6a 81       	ldd	r22, Y+2	; 0x02
    7a38:	7b 81       	ldd	r23, Y+3	; 0x03
    7a3a:	8c 81       	ldd	r24, Y+4	; 0x04
    7a3c:	9d 81       	ldd	r25, Y+5	; 0x05
              settings_store_startup_line(helper_var,line);
    7a3e:	51 d5       	rcall	.+2722   	; 0x84e2 <trunc>
    7a40:	b8 d2       	rcall	.+1392   	; 0x7fb2 <__fixunssfsi>
    7a42:	86 2f       	mov	r24, r22
    7a44:	b8 01       	movw	r22, r16
    7a46:	0e 94 2f 25 	call	0x4a5e	; 0x4a5e <settings_store_startup_line>
    7a4a:	b9 c0       	rjmp	.+370    	; 0x7bbe <system_execute_line+0x482>
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    7a4c:	ae 01       	movw	r20, r28
    7a4e:	4a 5f       	subi	r20, 0xFA	; 250
    7a50:	5f 4f       	sbci	r21, 0xFF	; 255
    7a52:	be 01       	movw	r22, r28
    7a54:	6f 5f       	subi	r22, 0xFF	; 255
    7a56:	7f 4f       	sbci	r23, 0xFF	; 255
    7a58:	c8 01       	movw	r24, r16
    7a5a:	0e 94 03 2e 	call	0x5c06	; 0x5c06 <read_float>
    7a5e:	88 23       	and	r24, r24
    7a60:	09 f4       	brne	.+2      	; 0x7a64 <system_execute_line+0x328>
    7a62:	a0 c0       	rjmp	.+320    	; 0x7ba4 <system_execute_line+0x468>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    7a64:	89 81       	ldd	r24, Y+1	; 0x01
    7a66:	f8 01       	movw	r30, r16
    7a68:	e8 0f       	add	r30, r24
    7a6a:	f1 1d       	adc	r31, r1
    7a6c:	80 81       	ld	r24, Z
    7a6e:	81 11       	cpse	r24, r1
    7a70:	9d c0       	rjmp	.+314    	; 0x7bac <system_execute_line+0x470>
    7a72:	ca 80       	ldd	r12, Y+2	; 0x02
    7a74:	db 80       	ldd	r13, Y+3	; 0x03
    7a76:	ec 80       	ldd	r14, Y+4	; 0x04
    7a78:	fd 80       	ldd	r15, Y+5	; 0x05
    7a7a:	20 e0       	ldi	r18, 0x00	; 0
    7a7c:	30 e0       	ldi	r19, 0x00	; 0
    7a7e:	4f e7       	ldi	r20, 0x7F	; 127
    7a80:	53 e4       	ldi	r21, 0x43	; 67
    7a82:	c7 01       	movw	r24, r14
    7a84:	b6 01       	movw	r22, r12
    7a86:	24 d4       	rcall	.+2120   	; 0x82d0 <__gesf2>
    7a88:	18 16       	cp	r1, r24
    7a8a:	0c f4       	brge	.+2      	; 0x7a8e <system_execute_line+0x352>
            return(settings_store_global_setting((uint8_t)parameter, value));
    7a8c:	94 c0       	rjmp	.+296    	; 0x7bb6 <system_execute_line+0x47a>
    7a8e:	8e 80       	ldd	r8, Y+6	; 0x06
    7a90:	9f 80       	ldd	r9, Y+7	; 0x07
    7a92:	a8 84       	ldd	r10, Y+8	; 0x08
    7a94:	b9 84       	ldd	r11, Y+9	; 0x09
    7a96:	c7 01       	movw	r24, r14
    7a98:	b6 01       	movw	r22, r12
    7a9a:	8b d2       	rcall	.+1302   	; 0x7fb2 <__fixunssfsi>
    7a9c:	86 2f       	mov	r24, r22
    7a9e:	b5 01       	movw	r22, r10
    7aa0:	a4 01       	movw	r20, r8
    7aa2:	0e 94 23 26 	call	0x4c46	; 0x4c46 <settings_store_global_setting>
    7aa6:	f8 2e       	mov	r15, r24
    7aa8:	8a c0       	rjmp	.+276    	; 0x7bbe <system_execute_line+0x482>
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    case 'J' : // Jogging
      // Execute only if in IDLE or JOG states.
      if (sys.state != STATE_IDLE && sys.state != STATE_JOG) { return(STATUS_IDLE_ERROR); }
    7aaa:	68 94       	set
    7aac:	ff 24       	eor	r15, r15
    7aae:	f3 f8       	bld	r15, 3
    7ab0:	86 c0       	rjmp	.+268    	; 0x7bbe <system_execute_line+0x482>
      if(line[2] != '=') { return(STATUS_INVALID_STATEMENT); }
    7ab2:	0f 2e       	mov	r0, r31
    7ab4:	f3 e0       	ldi	r31, 0x03	; 3
    7ab6:	ff 2e       	mov	r15, r31
    7ab8:	f0 2d       	mov	r31, r0
    7aba:	81 c0       	rjmp	.+258    	; 0x7bbe <system_execute_line+0x482>
      return(gc_execute_line(line)); // NOTE: $J= is ignored inside g-code parser and used to detect jog motions.
      break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7abc:	0f 2e       	mov	r0, r31
    7abe:	f3 e0       	ldi	r31, 0x03	; 3
    7ac0:	ff 2e       	mov	r15, r31
    7ac2:	f0 2d       	mov	r31, r0
    7ac4:	7c c0       	rjmp	.+248    	; 0x7bbe <system_execute_line+0x482>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7ac6:	f1 2c       	mov	r15, r1
    7ac8:	7a c0       	rjmp	.+244    	; 0x7bbe <system_execute_line+0x482>
      break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
      switch( line[1] ) {
        case '$' : // Prints Grbl settings
          if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    7aca:	68 94       	set
    7acc:	ff 24       	eor	r15, r15
    7ace:	f3 f8       	bld	r15, 3
    7ad0:	76 c0       	rjmp	.+236    	; 0x7bbe <system_execute_line+0x482>
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) {
            mc_reset();
            report_feedback_message(MESSAGE_DISABLED);
          } else {
            if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    7ad2:	68 94       	set
    7ad4:	ff 24       	eor	r15, r15
    7ad6:	f3 f8       	bld	r15, 3
    7ad8:	72 c0       	rjmp	.+228    	; 0x7bbe <system_execute_line+0x482>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7ada:	f1 2c       	mov	r15, r1
    7adc:	70 c0       	rjmp	.+224    	; 0x7bbe <system_execute_line+0x482>
          }
          break;
        case 'X' : // Disable alarm lock [ALARM]
          if (sys.state == STATE_ALARM) {
            // Block if safety door is ajar.
            if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); }
    7ade:	0f 2e       	mov	r0, r31
    7ae0:	fd e0       	ldi	r31, 0x0D	; 13
    7ae2:	ff 2e       	mov	r15, r31
    7ae4:	f0 2d       	mov	r31, r0
    7ae6:	6b c0       	rjmp	.+214    	; 0x7bbe <system_execute_line+0x482>
          break;
      }
      break;
    default :
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    7ae8:	68 94       	set
    7aea:	ff 24       	eor	r15, r15
    7aec:	f3 f8       	bld	r15, 3
    7aee:	67 c0       	rjmp	.+206    	; 0x7bbe <system_execute_line+0x482>
      switch( line[1] ) {
        case '#' : // Print Grbl NGC parameters
          if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7af0:	0f 2e       	mov	r0, r31
    7af2:	f3 e0       	ldi	r31, 0x03	; 3
    7af4:	ff 2e       	mov	r15, r31
    7af6:	f0 2d       	mov	r31, r0
    7af8:	62 c0       	rjmp	.+196    	; 0x7bbe <system_execute_line+0x482>
          else { report_ngc_parameters(); }
          break;
        case 'H' : // Perform homing cycle [IDLE/ALARM]
          if (bit_isfalse(settings.flags,BITFLAG_HOMING_ENABLE)) {return(STATUS_SETTING_DISABLED); }
    7afa:	0f 2e       	mov	r0, r31
    7afc:	f5 e0       	ldi	r31, 0x05	; 5
    7afe:	ff 2e       	mov	r15, r31
    7b00:	f0 2d       	mov	r31, r0
    7b02:	5d c0       	rjmp	.+186    	; 0x7bbe <system_execute_line+0x482>
          if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); } // Block if safety door is ajar.
    7b04:	0f 2e       	mov	r0, r31
    7b06:	fd e0       	ldi	r31, 0x0D	; 13
    7b08:	ff 2e       	mov	r15, r31
    7b0a:	f0 2d       	mov	r31, r0
    7b0c:	58 c0       	rjmp	.+176    	; 0x7bbe <system_execute_line+0x482>
                case 'Y': mc_homing_cycle(HOMING_CYCLE_Y); break;
                case 'Z': mc_homing_cycle(HOMING_CYCLE_Z); break;
                default: return(STATUS_INVALID_STATEMENT);
              }
          #endif
          } else { return(STATUS_INVALID_STATEMENT); }
    7b0e:	0f 2e       	mov	r0, r31
    7b10:	f3 e0       	ldi	r31, 0x03	; 3
    7b12:	ff 2e       	mov	r15, r31
    7b14:	f0 2d       	mov	r31, r0
    7b16:	53 c0       	rjmp	.+166    	; 0x7bbe <system_execute_line+0x482>
            } else if (line[3] == 0) {
              switch (line[2]) {
                case 'X': mc_homing_cycle(HOMING_CYCLE_X); break;
                case 'Y': mc_homing_cycle(HOMING_CYCLE_Y); break;
                case 'Z': mc_homing_cycle(HOMING_CYCLE_Z); break;
                default: return(STATUS_INVALID_STATEMENT);
    7b18:	0f 2e       	mov	r0, r31
    7b1a:	f3 e0       	ldi	r31, 0x03	; 3
    7b1c:	ff 2e       	mov	r15, r31
    7b1e:	f0 2d       	mov	r31, r0
    7b20:	4e c0       	rjmp	.+156    	; 0x7bbe <system_execute_line+0x482>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7b22:	fe 2c       	mov	r15, r14
    7b24:	4c c0       	rjmp	.+152    	; 0x7bbe <system_execute_line+0x482>
            st_go_idle(); // Set steppers to the settings idle state before returning.
            if (line[2] == 0) { system_execute_startup(line); }
          }
          break;
        case 'S' : // Puts Grbl to sleep [IDLE/ALARM]
          if ((line[2] != 'L') || (line[3] != 'P') || (line[4] != 0)) { return(STATUS_INVALID_STATEMENT); }
    7b26:	0f 2e       	mov	r0, r31
    7b28:	f3 e0       	ldi	r31, 0x03	; 3
    7b2a:	ff 2e       	mov	r15, r31
    7b2c:	f0 2d       	mov	r31, r0
    7b2e:	47 c0       	rjmp	.+142    	; 0x7bbe <system_execute_line+0x482>
    7b30:	0f 2e       	mov	r0, r31
    7b32:	f3 e0       	ldi	r31, 0x03	; 3
    7b34:	ff 2e       	mov	r15, r31
    7b36:	f0 2d       	mov	r31, r0
    7b38:	42 c0       	rjmp	.+132    	; 0x7bbe <system_execute_line+0x482>
    7b3a:	0f 2e       	mov	r0, r31
    7b3c:	f3 e0       	ldi	r31, 0x03	; 3
    7b3e:	ff 2e       	mov	r15, r31
    7b40:	f0 2d       	mov	r31, r0
    7b42:	3d c0       	rjmp	.+122    	; 0x7bbe <system_execute_line+0x482>
          if ( line[++char_counter] == 0 ) {
            settings_read_build_info(line);
            report_build_info(line);
          #ifdef ENABLE_BUILD_INFO_WRITE_COMMAND
            } else { // Store startup line [IDLE/ALARM]
              if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    7b44:	0f 2e       	mov	r0, r31
    7b46:	f3 e0       	ldi	r31, 0x03	; 3
    7b48:	ff 2e       	mov	r15, r31
    7b4a:	f0 2d       	mov	r31, r0
    7b4c:	38 c0       	rjmp	.+112    	; 0x7bbe <system_execute_line+0x482>
              settings_store_build_info(line);
          #endif
          }
          break;
        case 'R' : // Restore defaults [IDLE/ALARM]
          if ((line[2] != 'S') || (line[3] != 'T') || (line[4] != '=') || (line[6] != 0)) { return(STATUS_INVALID_STATEMENT); }
    7b4e:	0f 2e       	mov	r0, r31
    7b50:	f3 e0       	ldi	r31, 0x03	; 3
    7b52:	ff 2e       	mov	r15, r31
    7b54:	f0 2d       	mov	r31, r0
    7b56:	33 c0       	rjmp	.+102    	; 0x7bbe <system_execute_line+0x482>
    7b58:	0f 2e       	mov	r0, r31
    7b5a:	f3 e0       	ldi	r31, 0x03	; 3
    7b5c:	ff 2e       	mov	r15, r31
    7b5e:	f0 2d       	mov	r31, r0
    7b60:	2e c0       	rjmp	.+92     	; 0x7bbe <system_execute_line+0x482>
    7b62:	0f 2e       	mov	r0, r31
    7b64:	f3 e0       	ldi	r31, 0x03	; 3
    7b66:	ff 2e       	mov	r15, r31
    7b68:	f0 2d       	mov	r31, r0
    7b6a:	29 c0       	rjmp	.+82     	; 0x7bbe <system_execute_line+0x482>
    7b6c:	0f 2e       	mov	r0, r31
    7b6e:	f3 e0       	ldi	r31, 0x03	; 3
    7b70:	ff 2e       	mov	r15, r31
    7b72:	f0 2d       	mov	r31, r0
    7b74:	24 c0       	rjmp	.+72     	; 0x7bbe <system_execute_line+0x482>
              case '#': settings_restore(SETTINGS_RESTORE_PARAMETERS); break;
            #endif
            #ifdef ENABLE_RESTORE_EEPROM_WIPE_ALL
              case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
            #endif
            default: return(STATUS_INVALID_STATEMENT);
    7b76:	0f 2e       	mov	r0, r31
    7b78:	f3 e0       	ldi	r31, 0x03	; 3
    7b7a:	ff 2e       	mov	r15, r31
    7b7c:	f0 2d       	mov	r31, r0
    7b7e:	1f c0       	rjmp	.+62     	; 0x7bbe <system_execute_line+0x482>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    7b80:	68 94       	set
    7b82:	ff 24       	eor	r15, r15
    7b84:	f3 f8       	bld	r15, 3
    7b86:	1b c0       	rjmp	.+54     	; 0x7bbe <system_execute_line+0x482>
            helper_var = true;  // Set helper_var to flag storing method.
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    7b88:	68 94       	set
    7b8a:	ff 24       	eor	r15, r15
    7b8c:	f1 f8       	bld	r15, 1
    7b8e:	17 c0       	rjmp	.+46     	; 0x7bbe <system_execute_line+0x482>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    7b90:	0f 2e       	mov	r0, r31
    7b92:	f3 e0       	ldi	r31, 0x03	; 3
    7b94:	ff 2e       	mov	r15, r31
    7b96:	f0 2d       	mov	r31, r0
    7b98:	12 c0       	rjmp	.+36     	; 0x7bbe <system_execute_line+0x482>
            // Prepare sending gcode block to gcode parser by shifting all characters
            helper_var = char_counter; // Set helper variable as counter to start of gcode block
            do {
              line[char_counter-helper_var] = line[char_counter];
            } while (line[char_counter++] != 0);
            if (char_counter > EEPROM_LINE_SIZE) { return(STATUS_LINE_LENGTH_EXCEEDED); }
    7b9a:	0f 2e       	mov	r0, r31
    7b9c:	fe e0       	ldi	r31, 0x0E	; 14
    7b9e:	ff 2e       	mov	r15, r31
    7ba0:	f0 2d       	mov	r31, r0
    7ba2:	0d c0       	rjmp	.+26     	; 0x7bbe <system_execute_line+0x482>
            else {
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
              settings_store_startup_line(helper_var,line);
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    7ba4:	68 94       	set
    7ba6:	ff 24       	eor	r15, r15
    7ba8:	f1 f8       	bld	r15, 1
    7baa:	09 c0       	rjmp	.+18     	; 0x7bbe <system_execute_line+0x482>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    7bac:	0f 2e       	mov	r0, r31
    7bae:	f3 e0       	ldi	r31, 0x03	; 3
    7bb0:	ff 2e       	mov	r15, r31
    7bb2:	f0 2d       	mov	r31, r0
    7bb4:	04 c0       	rjmp	.+8      	; 0x7bbe <system_execute_line+0x482>
    7bb6:	0f 2e       	mov	r0, r31
    7bb8:	f3 e0       	ldi	r31, 0x03	; 3
    7bba:	ff 2e       	mov	r15, r31
    7bbc:	f0 2d       	mov	r31, r0
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
}
    7bbe:	8f 2d       	mov	r24, r15
    7bc0:	29 96       	adiw	r28, 0x09	; 9
    7bc2:	0f b6       	in	r0, 0x3f	; 63
    7bc4:	f8 94       	cli
    7bc6:	de bf       	out	0x3e, r29	; 62
    7bc8:	0f be       	out	0x3f, r0	; 63
    7bca:	cd bf       	out	0x3d, r28	; 61
    7bcc:	df 91       	pop	r29
    7bce:	cf 91       	pop	r28
    7bd0:	1f 91       	pop	r17
    7bd2:	0f 91       	pop	r16
    7bd4:	ff 90       	pop	r15
    7bd6:	ef 90       	pop	r14
    7bd8:	df 90       	pop	r13
    7bda:	cf 90       	pop	r12
    7bdc:	bf 90       	pop	r11
    7bde:	af 90       	pop	r10
    7be0:	9f 90       	pop	r9
    7be2:	8f 90       	pop	r8
    7be4:	08 95       	ret

00007be6 <system_clear_exec_state_flag>:
  sys_rt_exec_state |= (mask);
  SREG = sreg;
}

void system_clear_exec_state_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    7be6:	2f b7       	in	r18, 0x3f	; 63
  cli();
    7be8:	f8 94       	cli
  sys_rt_exec_state &= ~(mask);
    7bea:	90 91 31 0c 	lds	r25, 0x0C31	; 0x800c31 <sys_rt_exec_state>
    7bee:	80 95       	com	r24
    7bf0:	89 23       	and	r24, r25
    7bf2:	80 93 31 0c 	sts	0x0C31, r24	; 0x800c31 <sys_rt_exec_state>
  SREG = sreg;
    7bf6:	2f bf       	out	0x3f, r18	; 63
    7bf8:	08 95       	ret

00007bfa <system_set_exec_alarm>:
}

void system_set_exec_alarm(uint8_t code) {
  uint8_t sreg = SREG;
    7bfa:	9f b7       	in	r25, 0x3f	; 63
  cli();
    7bfc:	f8 94       	cli
  sys_rt_exec_alarm = code;
    7bfe:	80 93 53 0c 	sts	0x0C53, r24	; 0x800c53 <sys_rt_exec_alarm>
  SREG = sreg;
    7c02:	9f bf       	out	0x3f, r25	; 63
    7c04:	08 95       	ret

00007c06 <system_clear_exec_alarm>:
}

void system_clear_exec_alarm() {
  uint8_t sreg = SREG;
    7c06:	8f b7       	in	r24, 0x3f	; 63
  cli();
    7c08:	f8 94       	cli
  sys_rt_exec_alarm = 0;
    7c0a:	10 92 53 0c 	sts	0x0C53, r1	; 0x800c53 <sys_rt_exec_alarm>
  SREG = sreg;
    7c0e:	8f bf       	out	0x3f, r24	; 63
    7c10:	08 95       	ret

00007c12 <system_set_exec_motion_override_flag>:
}

void system_set_exec_motion_override_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    7c12:	9f b7       	in	r25, 0x3f	; 63
  cli();
    7c14:	f8 94       	cli
  sys_rt_exec_motion_override |= (mask);
    7c16:	20 91 19 0c 	lds	r18, 0x0C19	; 0x800c19 <sys_rt_exec_motion_override>
    7c1a:	82 2b       	or	r24, r18
    7c1c:	80 93 19 0c 	sts	0x0C19, r24	; 0x800c19 <sys_rt_exec_motion_override>
  SREG = sreg;
    7c20:	9f bf       	out	0x3f, r25	; 63
    7c22:	08 95       	ret

00007c24 <system_set_exec_accessory_override_flag>:
}

void system_set_exec_accessory_override_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    7c24:	9f b7       	in	r25, 0x3f	; 63
  cli();
    7c26:	f8 94       	cli
  sys_rt_exec_accessory_override |= (mask);
    7c28:	20 91 30 0c 	lds	r18, 0x0C30	; 0x800c30 <sys_rt_exec_accessory_override>
    7c2c:	82 2b       	or	r24, r18
    7c2e:	80 93 30 0c 	sts	0x0C30, r24	; 0x800c30 <sys_rt_exec_accessory_override>
  SREG = sreg;
    7c32:	9f bf       	out	0x3f, r25	; 63
    7c34:	08 95       	ret

00007c36 <system_clear_exec_motion_overrides>:
}

void system_clear_exec_motion_overrides() {
  uint8_t sreg = SREG;
    7c36:	8f b7       	in	r24, 0x3f	; 63
  cli();
    7c38:	f8 94       	cli
  sys_rt_exec_motion_override = 0;
    7c3a:	10 92 19 0c 	sts	0x0C19, r1	; 0x800c19 <sys_rt_exec_motion_override>
  SREG = sreg;
    7c3e:	8f bf       	out	0x3f, r24	; 63
    7c40:	08 95       	ret

00007c42 <system_clear_exec_accessory_overrides>:
}

void system_clear_exec_accessory_overrides() {
  uint8_t sreg = SREG;
    7c42:	8f b7       	in	r24, 0x3f	; 63
  cli();
    7c44:	f8 94       	cli
  sys_rt_exec_accessory_override = 0;
    7c46:	10 92 30 0c 	sts	0x0C30, r1	; 0x800c30 <sys_rt_exec_accessory_override>
  SREG = sreg;
    7c4a:	8f bf       	out	0x3f, r24	; 63
    7c4c:	08 95       	ret

00007c4e <sleep_init>:
// Initialization routine for sleep timer.
void sleep_init()
{
  // Configure Timer 3: Sleep Counter Overflow Interrupt
  // NOTE: By using an overflow interrupt, the timer is automatically reloaded upon overflow.
  TCCR3B = 0; // Normal operation. Overflow.
    7c4e:	e1 e9       	ldi	r30, 0x91	; 145
    7c50:	f0 e0       	ldi	r31, 0x00	; 0
    7c52:	10 82       	st	Z, r1
  TCCR3A = 0;
    7c54:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
  TCCR3B = (TCCR3B & ~((1<<CS32) | (1<<CS31))) | (1<<CS30); // Stop timer
    7c58:	80 81       	ld	r24, Z
    7c5a:	88 7f       	andi	r24, 0xF8	; 248
    7c5c:	81 60       	ori	r24, 0x01	; 1
    7c5e:	80 83       	st	Z, r24
  // TCCR3B |= (1<<CS32); // Enable timer with 1/256 prescaler. ~4.4min max with uint8 and 1.05sec/tick
  // TCCR3B |= (1<<CS31); // Enable timer with 1/8 prescaler. ~8.3sec max with uint8 and 32.7msec/tick
  TCCR3B |= (1<<CS31)|(1<<CS30); // Enable timer with 1/64 prescaler. ~66.8sec max with uint8 and 0.262sec/tick
    7c60:	80 81       	ld	r24, Z
    7c62:	83 60       	ori	r24, 0x03	; 3
    7c64:	80 83       	st	Z, r24
  TIMSK3 |= (1<<TOIE3); // Enable timer3 overflow interrupt
} 


// Disable sleep timer.
static void sleep_disable() {  TIMSK3 &= ~(1<<TOIE3); } // Disable timer overflow interrupt
    7c66:	e1 e7       	ldi	r30, 0x71	; 113
    7c68:	f0 e0       	ldi	r31, 0x00	; 0
    7c6a:	80 81       	ld	r24, Z
    7c6c:	8e 7f       	andi	r24, 0xFE	; 254
    7c6e:	80 83       	st	Z, r24
    7c70:	08 95       	ret

00007c72 <__vector_35>:
  sleep_disable();
}


// Increment sleep counter with each timer overflow.
ISR(TIMER3_OVF_vect) { sleep_counter++; }
    7c72:	1f 92       	push	r1
    7c74:	0f 92       	push	r0
    7c76:	0f b6       	in	r0, 0x3f	; 63
    7c78:	0f 92       	push	r0
    7c7a:	11 24       	eor	r1, r1
    7c7c:	8f 93       	push	r24
    7c7e:	80 91 26 0f 	lds	r24, 0x0F26	; 0x800f26 <sleep_counter>
    7c82:	8f 5f       	subi	r24, 0xFF	; 255
    7c84:	80 93 26 0f 	sts	0x0F26, r24	; 0x800f26 <sleep_counter>
    7c88:	8f 91       	pop	r24
    7c8a:	0f 90       	pop	r0
    7c8c:	0f be       	out	0x3f, r0	; 63
    7c8e:	0f 90       	pop	r0
    7c90:	1f 90       	pop	r1
    7c92:	18 95       	reti

00007c94 <jog_execute>:
#include "grbl.h"


// Sets up valid jog motion received from g-code parser, checks for soft-limits, and executes the jog.
uint8_t jog_execute(plan_line_data_t *pl_data, parser_block_t *gc_block)
{
    7c94:	0f 93       	push	r16
    7c96:	1f 93       	push	r17
    7c98:	cf 93       	push	r28
    7c9a:	df 93       	push	r29
    7c9c:	ec 01       	movw	r28, r24
    7c9e:	8b 01       	movw	r16, r22
  // Initialize planner data struct for jogging motions.
  // NOTE: Spindle and coolant are allowed to fully function with overrides during a jog.
  pl_data->feed_rate = gc_block->values.f;
    7ca0:	fb 01       	movw	r30, r22
    7ca2:	84 85       	ldd	r24, Z+12	; 0x0c
    7ca4:	95 85       	ldd	r25, Z+13	; 0x0d
    7ca6:	a6 85       	ldd	r26, Z+14	; 0x0e
    7ca8:	b7 85       	ldd	r27, Z+15	; 0x0f
    7caa:	88 83       	st	Y, r24
    7cac:	99 83       	std	Y+1, r25	; 0x01
    7cae:	aa 83       	std	Y+2, r26	; 0x02
    7cb0:	bb 83       	std	Y+3, r27	; 0x03
  pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
    7cb2:	8c 85       	ldd	r24, Y+12	; 0x0c
    7cb4:	84 60       	ori	r24, 0x04	; 4
    7cb6:	8c 87       	std	Y+12, r24	; 0x0c
  pl_data->line_number = gc_block->values.n;
    7cb8:	85 8d       	ldd	r24, Z+29	; 0x1d
    7cba:	96 8d       	ldd	r25, Z+30	; 0x1e
    7cbc:	a7 8d       	ldd	r26, Z+31	; 0x1f
    7cbe:	b0 a1       	ldd	r27, Z+32	; 0x20
    7cc0:	88 87       	std	Y+8, r24	; 0x08
    7cc2:	99 87       	std	Y+9, r25	; 0x09
    7cc4:	aa 87       	std	Y+10, r26	; 0x0a
    7cc6:	bb 87       	std	Y+11, r27	; 0x0b

  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
    7cc8:	80 91 15 0f 	lds	r24, 0x0F15	; 0x800f15 <settings+0x45>
    7ccc:	85 ff       	sbrs	r24, 5
    7cce:	05 c0       	rjmp	.+10     	; 0x7cda <jog_execute+0x46>
    if (system_check_travel_limits(gc_block->values.xyz)) { return(STATUS_TRAVEL_EXCEEDED); }
    7cd0:	cb 01       	movw	r24, r22
    7cd2:	8e 96       	adiw	r24, 0x2e	; 46
    7cd4:	c5 dc       	rcall	.-1654   	; 0x7660 <system_check_travel_limits>
    7cd6:	81 11       	cpse	r24, r1
    7cd8:	15 c0       	rjmp	.+42     	; 0x7d04 <jog_execute+0x70>
  }

  // Valid jog command. Plan, set state, and execute.
  mc_line(gc_block->values.xyz,pl_data);
    7cda:	be 01       	movw	r22, r28
    7cdc:	c8 01       	movw	r24, r16
    7cde:	8e 96       	adiw	r24, 0x2e	; 46
    7ce0:	0e 94 62 03 	call	0x6c4	; 0x6c4 <mc_line>
  if (sys.state == STATE_IDLE) {
    7ce4:	c0 91 1e 0c 	lds	r28, 0x0C1E	; 0x800c1e <sys>
    7ce8:	c1 11       	cpse	r28, r1
    7cea:	0e c0       	rjmp	.+28     	; 0x7d08 <jog_execute+0x74>
    if (plan_get_current_block() != NULL) { // Check if there is a block to execute.
    7cec:	0e 94 5b 29 	call	0x52b6	; 0x52b6 <plan_get_current_block>
    7cf0:	89 2b       	or	r24, r25
    7cf2:	59 f0       	breq	.+22     	; 0x7d0a <jog_execute+0x76>
      sys.state = STATE_JOG;
    7cf4:	80 e2       	ldi	r24, 0x20	; 32
    7cf6:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <sys>
      st_prep_buffer();
    7cfa:	0e 94 22 1c 	call	0x3844	; 0x3844 <st_prep_buffer>
      st_wake_up();  // NOTE: Manual start. No state machine required.
    7cfe:	0e 94 15 19 	call	0x322a	; 0x322a <st_wake_up>
    7d02:	03 c0       	rjmp	.+6      	; 0x7d0a <jog_execute+0x76>
  pl_data->feed_rate = gc_block->values.f;
  pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
  pl_data->line_number = gc_block->values.n;

  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
    if (system_check_travel_limits(gc_block->values.xyz)) { return(STATUS_TRAVEL_EXCEEDED); }
    7d04:	cf e0       	ldi	r28, 0x0F	; 15
    7d06:	01 c0       	rjmp	.+2      	; 0x7d0a <jog_execute+0x76>
      st_prep_buffer();
      st_wake_up();  // NOTE: Manual start. No state machine required.
    }
  }

  return(STATUS_OK);
    7d08:	c0 e0       	ldi	r28, 0x00	; 0
}
    7d0a:	8c 2f       	mov	r24, r28
    7d0c:	df 91       	pop	r29
    7d0e:	cf 91       	pop	r28
    7d10:	1f 91       	pop	r17
    7d12:	0f 91       	pop	r16
    7d14:	08 95       	ret

00007d16 <__subsf3>:
    7d16:	50 58       	subi	r21, 0x80	; 128

00007d18 <__addsf3>:
    7d18:	bb 27       	eor	r27, r27
    7d1a:	aa 27       	eor	r26, r26
    7d1c:	0e d0       	rcall	.+28     	; 0x7d3a <__addsf3x>
    7d1e:	76 c2       	rjmp	.+1260   	; 0x820c <__fp_round>
    7d20:	3f d2       	rcall	.+1150   	; 0x81a0 <__fp_pscA>
    7d22:	30 f0       	brcs	.+12     	; 0x7d30 <__addsf3+0x18>
    7d24:	44 d2       	rcall	.+1160   	; 0x81ae <__fp_pscB>
    7d26:	20 f0       	brcs	.+8      	; 0x7d30 <__addsf3+0x18>
    7d28:	31 f4       	brne	.+12     	; 0x7d36 <__addsf3+0x1e>
    7d2a:	9f 3f       	cpi	r25, 0xFF	; 255
    7d2c:	11 f4       	brne	.+4      	; 0x7d32 <__addsf3+0x1a>
    7d2e:	1e f4       	brtc	.+6      	; 0x7d36 <__addsf3+0x1e>
    7d30:	0f c2       	rjmp	.+1054   	; 0x8150 <__fp_nan>
    7d32:	0e f4       	brtc	.+2      	; 0x7d36 <__addsf3+0x1e>
    7d34:	e0 95       	com	r30
    7d36:	e7 fb       	bst	r30, 7
    7d38:	dc c1       	rjmp	.+952    	; 0x80f2 <__fp_inf>

00007d3a <__addsf3x>:
    7d3a:	e9 2f       	mov	r30, r25
    7d3c:	89 d2       	rcall	.+1298   	; 0x8250 <__fp_split3>
    7d3e:	80 f3       	brcs	.-32     	; 0x7d20 <__addsf3+0x8>
    7d40:	ba 17       	cp	r27, r26
    7d42:	62 07       	cpc	r22, r18
    7d44:	73 07       	cpc	r23, r19
    7d46:	84 07       	cpc	r24, r20
    7d48:	95 07       	cpc	r25, r21
    7d4a:	18 f0       	brcs	.+6      	; 0x7d52 <__addsf3x+0x18>
    7d4c:	71 f4       	brne	.+28     	; 0x7d6a <__addsf3x+0x30>
    7d4e:	9e f5       	brtc	.+102    	; 0x7db6 <__addsf3x+0x7c>
    7d50:	b8 c2       	rjmp	.+1392   	; 0x82c2 <__fp_zero>
    7d52:	0e f4       	brtc	.+2      	; 0x7d56 <__addsf3x+0x1c>
    7d54:	e0 95       	com	r30
    7d56:	0b 2e       	mov	r0, r27
    7d58:	ba 2f       	mov	r27, r26
    7d5a:	a0 2d       	mov	r26, r0
    7d5c:	0b 01       	movw	r0, r22
    7d5e:	b9 01       	movw	r22, r18
    7d60:	90 01       	movw	r18, r0
    7d62:	0c 01       	movw	r0, r24
    7d64:	ca 01       	movw	r24, r20
    7d66:	a0 01       	movw	r20, r0
    7d68:	11 24       	eor	r1, r1
    7d6a:	ff 27       	eor	r31, r31
    7d6c:	59 1b       	sub	r21, r25
    7d6e:	99 f0       	breq	.+38     	; 0x7d96 <__addsf3x+0x5c>
    7d70:	59 3f       	cpi	r21, 0xF9	; 249
    7d72:	50 f4       	brcc	.+20     	; 0x7d88 <__addsf3x+0x4e>
    7d74:	50 3e       	cpi	r21, 0xE0	; 224
    7d76:	68 f1       	brcs	.+90     	; 0x7dd2 <__addsf3x+0x98>
    7d78:	1a 16       	cp	r1, r26
    7d7a:	f0 40       	sbci	r31, 0x00	; 0
    7d7c:	a2 2f       	mov	r26, r18
    7d7e:	23 2f       	mov	r18, r19
    7d80:	34 2f       	mov	r19, r20
    7d82:	44 27       	eor	r20, r20
    7d84:	58 5f       	subi	r21, 0xF8	; 248
    7d86:	f3 cf       	rjmp	.-26     	; 0x7d6e <__addsf3x+0x34>
    7d88:	46 95       	lsr	r20
    7d8a:	37 95       	ror	r19
    7d8c:	27 95       	ror	r18
    7d8e:	a7 95       	ror	r26
    7d90:	f0 40       	sbci	r31, 0x00	; 0
    7d92:	53 95       	inc	r21
    7d94:	c9 f7       	brne	.-14     	; 0x7d88 <__addsf3x+0x4e>
    7d96:	7e f4       	brtc	.+30     	; 0x7db6 <__addsf3x+0x7c>
    7d98:	1f 16       	cp	r1, r31
    7d9a:	ba 0b       	sbc	r27, r26
    7d9c:	62 0b       	sbc	r22, r18
    7d9e:	73 0b       	sbc	r23, r19
    7da0:	84 0b       	sbc	r24, r20
    7da2:	ba f0       	brmi	.+46     	; 0x7dd2 <__addsf3x+0x98>
    7da4:	91 50       	subi	r25, 0x01	; 1
    7da6:	a1 f0       	breq	.+40     	; 0x7dd0 <__addsf3x+0x96>
    7da8:	ff 0f       	add	r31, r31
    7daa:	bb 1f       	adc	r27, r27
    7dac:	66 1f       	adc	r22, r22
    7dae:	77 1f       	adc	r23, r23
    7db0:	88 1f       	adc	r24, r24
    7db2:	c2 f7       	brpl	.-16     	; 0x7da4 <__addsf3x+0x6a>
    7db4:	0e c0       	rjmp	.+28     	; 0x7dd2 <__addsf3x+0x98>
    7db6:	ba 0f       	add	r27, r26
    7db8:	62 1f       	adc	r22, r18
    7dba:	73 1f       	adc	r23, r19
    7dbc:	84 1f       	adc	r24, r20
    7dbe:	48 f4       	brcc	.+18     	; 0x7dd2 <__addsf3x+0x98>
    7dc0:	87 95       	ror	r24
    7dc2:	77 95       	ror	r23
    7dc4:	67 95       	ror	r22
    7dc6:	b7 95       	ror	r27
    7dc8:	f7 95       	ror	r31
    7dca:	9e 3f       	cpi	r25, 0xFE	; 254
    7dcc:	08 f0       	brcs	.+2      	; 0x7dd0 <__addsf3x+0x96>
    7dce:	b3 cf       	rjmp	.-154    	; 0x7d36 <__addsf3+0x1e>
    7dd0:	93 95       	inc	r25
    7dd2:	88 0f       	add	r24, r24
    7dd4:	08 f0       	brcs	.+2      	; 0x7dd8 <__addsf3x+0x9e>
    7dd6:	99 27       	eor	r25, r25
    7dd8:	ee 0f       	add	r30, r30
    7dda:	97 95       	ror	r25
    7ddc:	87 95       	ror	r24
    7dde:	08 95       	ret
    7de0:	df d1       	rcall	.+958    	; 0x81a0 <__fp_pscA>
    7de2:	58 f0       	brcs	.+22     	; 0x7dfa <__addsf3x+0xc0>
    7de4:	80 e8       	ldi	r24, 0x80	; 128
    7de6:	91 e0       	ldi	r25, 0x01	; 1
    7de8:	09 f4       	brne	.+2      	; 0x7dec <__addsf3x+0xb2>
    7dea:	9e ef       	ldi	r25, 0xFE	; 254
    7dec:	e0 d1       	rcall	.+960    	; 0x81ae <__fp_pscB>
    7dee:	28 f0       	brcs	.+10     	; 0x7dfa <__addsf3x+0xc0>
    7df0:	40 e8       	ldi	r20, 0x80	; 128
    7df2:	51 e0       	ldi	r21, 0x01	; 1
    7df4:	59 f4       	brne	.+22     	; 0x7e0c <atan2+0xe>
    7df6:	5e ef       	ldi	r21, 0xFE	; 254
    7df8:	09 c0       	rjmp	.+18     	; 0x7e0c <atan2+0xe>
    7dfa:	aa c1       	rjmp	.+852    	; 0x8150 <__fp_nan>
    7dfc:	62 c2       	rjmp	.+1220   	; 0x82c2 <__fp_zero>

00007dfe <atan2>:
    7dfe:	e9 2f       	mov	r30, r25
    7e00:	e0 78       	andi	r30, 0x80	; 128
    7e02:	26 d2       	rcall	.+1100   	; 0x8250 <__fp_split3>
    7e04:	68 f3       	brcs	.-38     	; 0x7de0 <__addsf3x+0xa6>
    7e06:	09 2e       	mov	r0, r25
    7e08:	05 2a       	or	r0, r21
    7e0a:	c1 f3       	breq	.-16     	; 0x7dfc <__addsf3x+0xc2>
    7e0c:	26 17       	cp	r18, r22
    7e0e:	37 07       	cpc	r19, r23
    7e10:	48 07       	cpc	r20, r24
    7e12:	59 07       	cpc	r21, r25
    7e14:	38 f0       	brcs	.+14     	; 0x7e24 <atan2+0x26>
    7e16:	0e 2e       	mov	r0, r30
    7e18:	07 f8       	bld	r0, 7
    7e1a:	e0 25       	eor	r30, r0
    7e1c:	69 f0       	breq	.+26     	; 0x7e38 <atan2+0x3a>
    7e1e:	e0 25       	eor	r30, r0
    7e20:	e0 64       	ori	r30, 0x40	; 64
    7e22:	0a c0       	rjmp	.+20     	; 0x7e38 <atan2+0x3a>
    7e24:	ef 63       	ori	r30, 0x3F	; 63
    7e26:	07 f8       	bld	r0, 7
    7e28:	00 94       	com	r0
    7e2a:	07 fa       	bst	r0, 7
    7e2c:	db 01       	movw	r26, r22
    7e2e:	b9 01       	movw	r22, r18
    7e30:	9d 01       	movw	r18, r26
    7e32:	dc 01       	movw	r26, r24
    7e34:	ca 01       	movw	r24, r20
    7e36:	ad 01       	movw	r20, r26
    7e38:	ef 93       	push	r30
    7e3a:	5d d0       	rcall	.+186    	; 0x7ef6 <__divsf3_pse>
    7e3c:	e7 d1       	rcall	.+974    	; 0x820c <__fp_round>
    7e3e:	0a d0       	rcall	.+20     	; 0x7e54 <atan>
    7e40:	5f 91       	pop	r21
    7e42:	55 23       	and	r21, r21
    7e44:	31 f0       	breq	.+12     	; 0x7e52 <atan2+0x54>
    7e46:	2b ed       	ldi	r18, 0xDB	; 219
    7e48:	3f e0       	ldi	r19, 0x0F	; 15
    7e4a:	49 e4       	ldi	r20, 0x49	; 73
    7e4c:	50 fd       	sbrc	r21, 0
    7e4e:	49 ec       	ldi	r20, 0xC9	; 201
    7e50:	63 cf       	rjmp	.-314    	; 0x7d18 <__addsf3>
    7e52:	08 95       	ret

00007e54 <atan>:
    7e54:	df 93       	push	r29
    7e56:	dd 27       	eor	r29, r29
    7e58:	b9 2f       	mov	r27, r25
    7e5a:	bf 77       	andi	r27, 0x7F	; 127
    7e5c:	40 e8       	ldi	r20, 0x80	; 128
    7e5e:	5f e3       	ldi	r21, 0x3F	; 63
    7e60:	16 16       	cp	r1, r22
    7e62:	17 06       	cpc	r1, r23
    7e64:	48 07       	cpc	r20, r24
    7e66:	5b 07       	cpc	r21, r27
    7e68:	10 f4       	brcc	.+4      	; 0x7e6e <atan+0x1a>
    7e6a:	d9 2f       	mov	r29, r25
    7e6c:	35 d2       	rcall	.+1130   	; 0x82d8 <inverse>
    7e6e:	9f 93       	push	r25
    7e70:	8f 93       	push	r24
    7e72:	7f 93       	push	r23
    7e74:	6f 93       	push	r22
    7e76:	32 d3       	rcall	.+1636   	; 0x84dc <square>
    7e78:	ee e9       	ldi	r30, 0x9E	; 158
    7e7a:	f2 e0       	ldi	r31, 0x02	; 2
    7e7c:	6c d1       	rcall	.+728    	; 0x8156 <__fp_powser>
    7e7e:	c6 d1       	rcall	.+908    	; 0x820c <__fp_round>
    7e80:	2f 91       	pop	r18
    7e82:	3f 91       	pop	r19
    7e84:	4f 91       	pop	r20
    7e86:	5f 91       	pop	r21
    7e88:	6a d2       	rcall	.+1236   	; 0x835e <__mulsf3x>
    7e8a:	dd 23       	and	r29, r29
    7e8c:	49 f0       	breq	.+18     	; 0x7ea0 <atan+0x4c>
    7e8e:	90 58       	subi	r25, 0x80	; 128
    7e90:	a2 ea       	ldi	r26, 0xA2	; 162
    7e92:	2a ed       	ldi	r18, 0xDA	; 218
    7e94:	3f e0       	ldi	r19, 0x0F	; 15
    7e96:	49 ec       	ldi	r20, 0xC9	; 201
    7e98:	5f e3       	ldi	r21, 0x3F	; 63
    7e9a:	d0 78       	andi	r29, 0x80	; 128
    7e9c:	5d 27       	eor	r21, r29
    7e9e:	4d df       	rcall	.-358    	; 0x7d3a <__addsf3x>
    7ea0:	df 91       	pop	r29
    7ea2:	b4 c1       	rjmp	.+872    	; 0x820c <__fp_round>

00007ea4 <ceil>:
    7ea4:	f7 d1       	rcall	.+1006   	; 0x8294 <__fp_trunc>
    7ea6:	80 f0       	brcs	.+32     	; 0x7ec8 <ceil+0x24>
    7ea8:	9f 37       	cpi	r25, 0x7F	; 127
    7eaa:	40 f4       	brcc	.+16     	; 0x7ebc <ceil+0x18>
    7eac:	91 11       	cpse	r25, r1
    7eae:	0e f4       	brtc	.+2      	; 0x7eb2 <ceil+0xe>
    7eb0:	09 c2       	rjmp	.+1042   	; 0x82c4 <__fp_szero>
    7eb2:	60 e0       	ldi	r22, 0x00	; 0
    7eb4:	70 e0       	ldi	r23, 0x00	; 0
    7eb6:	80 e8       	ldi	r24, 0x80	; 128
    7eb8:	9f e3       	ldi	r25, 0x3F	; 63
    7eba:	08 95       	ret
    7ebc:	26 f0       	brts	.+8      	; 0x7ec6 <ceil+0x22>
    7ebe:	1b 16       	cp	r1, r27
    7ec0:	61 1d       	adc	r22, r1
    7ec2:	71 1d       	adc	r23, r1
    7ec4:	81 1d       	adc	r24, r1
    7ec6:	1b c1       	rjmp	.+566    	; 0x80fe <__fp_mintl>
    7ec8:	35 c1       	rjmp	.+618    	; 0x8134 <__fp_mpack>

00007eca <__cmpsf2>:
    7eca:	ef d0       	rcall	.+478    	; 0x80aa <__fp_cmp>
    7ecc:	08 f4       	brcc	.+2      	; 0x7ed0 <__cmpsf2+0x6>
    7ece:	81 e0       	ldi	r24, 0x01	; 1
    7ed0:	08 95       	ret

00007ed2 <cos>:
    7ed2:	75 d1       	rcall	.+746    	; 0x81be <__fp_rempio2>
    7ed4:	e3 95       	inc	r30
    7ed6:	ab c1       	rjmp	.+854    	; 0x822e <__fp_sinus>

00007ed8 <__divsf3>:
    7ed8:	0c d0       	rcall	.+24     	; 0x7ef2 <__divsf3x>
    7eda:	98 c1       	rjmp	.+816    	; 0x820c <__fp_round>
    7edc:	68 d1       	rcall	.+720    	; 0x81ae <__fp_pscB>
    7ede:	40 f0       	brcs	.+16     	; 0x7ef0 <__divsf3+0x18>
    7ee0:	5f d1       	rcall	.+702    	; 0x81a0 <__fp_pscA>
    7ee2:	30 f0       	brcs	.+12     	; 0x7ef0 <__divsf3+0x18>
    7ee4:	21 f4       	brne	.+8      	; 0x7eee <__divsf3+0x16>
    7ee6:	5f 3f       	cpi	r21, 0xFF	; 255
    7ee8:	19 f0       	breq	.+6      	; 0x7ef0 <__divsf3+0x18>
    7eea:	03 c1       	rjmp	.+518    	; 0x80f2 <__fp_inf>
    7eec:	51 11       	cpse	r21, r1
    7eee:	ea c1       	rjmp	.+980    	; 0x82c4 <__fp_szero>
    7ef0:	2f c1       	rjmp	.+606    	; 0x8150 <__fp_nan>

00007ef2 <__divsf3x>:
    7ef2:	ae d1       	rcall	.+860    	; 0x8250 <__fp_split3>
    7ef4:	98 f3       	brcs	.-26     	; 0x7edc <__divsf3+0x4>

00007ef6 <__divsf3_pse>:
    7ef6:	99 23       	and	r25, r25
    7ef8:	c9 f3       	breq	.-14     	; 0x7eec <__divsf3+0x14>
    7efa:	55 23       	and	r21, r21
    7efc:	b1 f3       	breq	.-20     	; 0x7eea <__divsf3+0x12>
    7efe:	95 1b       	sub	r25, r21
    7f00:	55 0b       	sbc	r21, r21
    7f02:	bb 27       	eor	r27, r27
    7f04:	aa 27       	eor	r26, r26
    7f06:	62 17       	cp	r22, r18
    7f08:	73 07       	cpc	r23, r19
    7f0a:	84 07       	cpc	r24, r20
    7f0c:	38 f0       	brcs	.+14     	; 0x7f1c <__divsf3_pse+0x26>
    7f0e:	9f 5f       	subi	r25, 0xFF	; 255
    7f10:	5f 4f       	sbci	r21, 0xFF	; 255
    7f12:	22 0f       	add	r18, r18
    7f14:	33 1f       	adc	r19, r19
    7f16:	44 1f       	adc	r20, r20
    7f18:	aa 1f       	adc	r26, r26
    7f1a:	a9 f3       	breq	.-22     	; 0x7f06 <__divsf3_pse+0x10>
    7f1c:	33 d0       	rcall	.+102    	; 0x7f84 <__divsf3_pse+0x8e>
    7f1e:	0e 2e       	mov	r0, r30
    7f20:	3a f0       	brmi	.+14     	; 0x7f30 <__divsf3_pse+0x3a>
    7f22:	e0 e8       	ldi	r30, 0x80	; 128
    7f24:	30 d0       	rcall	.+96     	; 0x7f86 <__divsf3_pse+0x90>
    7f26:	91 50       	subi	r25, 0x01	; 1
    7f28:	50 40       	sbci	r21, 0x00	; 0
    7f2a:	e6 95       	lsr	r30
    7f2c:	00 1c       	adc	r0, r0
    7f2e:	ca f7       	brpl	.-14     	; 0x7f22 <__divsf3_pse+0x2c>
    7f30:	29 d0       	rcall	.+82     	; 0x7f84 <__divsf3_pse+0x8e>
    7f32:	fe 2f       	mov	r31, r30
    7f34:	27 d0       	rcall	.+78     	; 0x7f84 <__divsf3_pse+0x8e>
    7f36:	66 0f       	add	r22, r22
    7f38:	77 1f       	adc	r23, r23
    7f3a:	88 1f       	adc	r24, r24
    7f3c:	bb 1f       	adc	r27, r27
    7f3e:	26 17       	cp	r18, r22
    7f40:	37 07       	cpc	r19, r23
    7f42:	48 07       	cpc	r20, r24
    7f44:	ab 07       	cpc	r26, r27
    7f46:	b0 e8       	ldi	r27, 0x80	; 128
    7f48:	09 f0       	breq	.+2      	; 0x7f4c <__divsf3_pse+0x56>
    7f4a:	bb 0b       	sbc	r27, r27
    7f4c:	80 2d       	mov	r24, r0
    7f4e:	bf 01       	movw	r22, r30
    7f50:	ff 27       	eor	r31, r31
    7f52:	93 58       	subi	r25, 0x83	; 131
    7f54:	5f 4f       	sbci	r21, 0xFF	; 255
    7f56:	2a f0       	brmi	.+10     	; 0x7f62 <__divsf3_pse+0x6c>
    7f58:	9e 3f       	cpi	r25, 0xFE	; 254
    7f5a:	51 05       	cpc	r21, r1
    7f5c:	68 f0       	brcs	.+26     	; 0x7f78 <__divsf3_pse+0x82>
    7f5e:	c9 c0       	rjmp	.+402    	; 0x80f2 <__fp_inf>
    7f60:	b1 c1       	rjmp	.+866    	; 0x82c4 <__fp_szero>
    7f62:	5f 3f       	cpi	r21, 0xFF	; 255
    7f64:	ec f3       	brlt	.-6      	; 0x7f60 <__divsf3_pse+0x6a>
    7f66:	98 3e       	cpi	r25, 0xE8	; 232
    7f68:	dc f3       	brlt	.-10     	; 0x7f60 <__divsf3_pse+0x6a>
    7f6a:	86 95       	lsr	r24
    7f6c:	77 95       	ror	r23
    7f6e:	67 95       	ror	r22
    7f70:	b7 95       	ror	r27
    7f72:	f7 95       	ror	r31
    7f74:	9f 5f       	subi	r25, 0xFF	; 255
    7f76:	c9 f7       	brne	.-14     	; 0x7f6a <__divsf3_pse+0x74>
    7f78:	88 0f       	add	r24, r24
    7f7a:	91 1d       	adc	r25, r1
    7f7c:	96 95       	lsr	r25
    7f7e:	87 95       	ror	r24
    7f80:	97 f9       	bld	r25, 7
    7f82:	08 95       	ret
    7f84:	e1 e0       	ldi	r30, 0x01	; 1
    7f86:	66 0f       	add	r22, r22
    7f88:	77 1f       	adc	r23, r23
    7f8a:	88 1f       	adc	r24, r24
    7f8c:	bb 1f       	adc	r27, r27
    7f8e:	62 17       	cp	r22, r18
    7f90:	73 07       	cpc	r23, r19
    7f92:	84 07       	cpc	r24, r20
    7f94:	ba 07       	cpc	r27, r26
    7f96:	20 f0       	brcs	.+8      	; 0x7fa0 <__divsf3_pse+0xaa>
    7f98:	62 1b       	sub	r22, r18
    7f9a:	73 0b       	sbc	r23, r19
    7f9c:	84 0b       	sbc	r24, r20
    7f9e:	ba 0b       	sbc	r27, r26
    7fa0:	ee 1f       	adc	r30, r30
    7fa2:	88 f7       	brcc	.-30     	; 0x7f86 <__divsf3_pse+0x90>
    7fa4:	e0 95       	com	r30
    7fa6:	08 95       	ret

00007fa8 <__fixsfsi>:
    7fa8:	04 d0       	rcall	.+8      	; 0x7fb2 <__fixunssfsi>
    7faa:	68 94       	set
    7fac:	b1 11       	cpse	r27, r1
    7fae:	8a c1       	rjmp	.+788    	; 0x82c4 <__fp_szero>
    7fb0:	08 95       	ret

00007fb2 <__fixunssfsi>:
    7fb2:	56 d1       	rcall	.+684    	; 0x8260 <__fp_splitA>
    7fb4:	88 f0       	brcs	.+34     	; 0x7fd8 <__fixunssfsi+0x26>
    7fb6:	9f 57       	subi	r25, 0x7F	; 127
    7fb8:	90 f0       	brcs	.+36     	; 0x7fde <__fixunssfsi+0x2c>
    7fba:	b9 2f       	mov	r27, r25
    7fbc:	99 27       	eor	r25, r25
    7fbe:	b7 51       	subi	r27, 0x17	; 23
    7fc0:	a0 f0       	brcs	.+40     	; 0x7fea <__fixunssfsi+0x38>
    7fc2:	d1 f0       	breq	.+52     	; 0x7ff8 <__fixunssfsi+0x46>
    7fc4:	66 0f       	add	r22, r22
    7fc6:	77 1f       	adc	r23, r23
    7fc8:	88 1f       	adc	r24, r24
    7fca:	99 1f       	adc	r25, r25
    7fcc:	1a f0       	brmi	.+6      	; 0x7fd4 <__fixunssfsi+0x22>
    7fce:	ba 95       	dec	r27
    7fd0:	c9 f7       	brne	.-14     	; 0x7fc4 <__fixunssfsi+0x12>
    7fd2:	12 c0       	rjmp	.+36     	; 0x7ff8 <__fixunssfsi+0x46>
    7fd4:	b1 30       	cpi	r27, 0x01	; 1
    7fd6:	81 f0       	breq	.+32     	; 0x7ff8 <__fixunssfsi+0x46>
    7fd8:	74 d1       	rcall	.+744    	; 0x82c2 <__fp_zero>
    7fda:	b1 e0       	ldi	r27, 0x01	; 1
    7fdc:	08 95       	ret
    7fde:	71 c1       	rjmp	.+738    	; 0x82c2 <__fp_zero>
    7fe0:	67 2f       	mov	r22, r23
    7fe2:	78 2f       	mov	r23, r24
    7fe4:	88 27       	eor	r24, r24
    7fe6:	b8 5f       	subi	r27, 0xF8	; 248
    7fe8:	39 f0       	breq	.+14     	; 0x7ff8 <__fixunssfsi+0x46>
    7fea:	b9 3f       	cpi	r27, 0xF9	; 249
    7fec:	cc f3       	brlt	.-14     	; 0x7fe0 <__fixunssfsi+0x2e>
    7fee:	86 95       	lsr	r24
    7ff0:	77 95       	ror	r23
    7ff2:	67 95       	ror	r22
    7ff4:	b3 95       	inc	r27
    7ff6:	d9 f7       	brne	.-10     	; 0x7fee <__fixunssfsi+0x3c>
    7ff8:	3e f4       	brtc	.+14     	; 0x8008 <__fixunssfsi+0x56>
    7ffa:	90 95       	com	r25
    7ffc:	80 95       	com	r24
    7ffe:	70 95       	com	r23
    8000:	61 95       	neg	r22
    8002:	7f 4f       	sbci	r23, 0xFF	; 255
    8004:	8f 4f       	sbci	r24, 0xFF	; 255
    8006:	9f 4f       	sbci	r25, 0xFF	; 255
    8008:	08 95       	ret

0000800a <__floatunsisf>:
    800a:	e8 94       	clt
    800c:	09 c0       	rjmp	.+18     	; 0x8020 <__floatsisf+0x12>

0000800e <__floatsisf>:
    800e:	97 fb       	bst	r25, 7
    8010:	3e f4       	brtc	.+14     	; 0x8020 <__floatsisf+0x12>
    8012:	90 95       	com	r25
    8014:	80 95       	com	r24
    8016:	70 95       	com	r23
    8018:	61 95       	neg	r22
    801a:	7f 4f       	sbci	r23, 0xFF	; 255
    801c:	8f 4f       	sbci	r24, 0xFF	; 255
    801e:	9f 4f       	sbci	r25, 0xFF	; 255
    8020:	99 23       	and	r25, r25
    8022:	a9 f0       	breq	.+42     	; 0x804e <__floatsisf+0x40>
    8024:	f9 2f       	mov	r31, r25
    8026:	96 e9       	ldi	r25, 0x96	; 150
    8028:	bb 27       	eor	r27, r27
    802a:	93 95       	inc	r25
    802c:	f6 95       	lsr	r31
    802e:	87 95       	ror	r24
    8030:	77 95       	ror	r23
    8032:	67 95       	ror	r22
    8034:	b7 95       	ror	r27
    8036:	f1 11       	cpse	r31, r1
    8038:	f8 cf       	rjmp	.-16     	; 0x802a <__floatsisf+0x1c>
    803a:	fa f4       	brpl	.+62     	; 0x807a <__floatsisf+0x6c>
    803c:	bb 0f       	add	r27, r27
    803e:	11 f4       	brne	.+4      	; 0x8044 <__floatsisf+0x36>
    8040:	60 ff       	sbrs	r22, 0
    8042:	1b c0       	rjmp	.+54     	; 0x807a <__floatsisf+0x6c>
    8044:	6f 5f       	subi	r22, 0xFF	; 255
    8046:	7f 4f       	sbci	r23, 0xFF	; 255
    8048:	8f 4f       	sbci	r24, 0xFF	; 255
    804a:	9f 4f       	sbci	r25, 0xFF	; 255
    804c:	16 c0       	rjmp	.+44     	; 0x807a <__floatsisf+0x6c>
    804e:	88 23       	and	r24, r24
    8050:	11 f0       	breq	.+4      	; 0x8056 <__floatsisf+0x48>
    8052:	96 e9       	ldi	r25, 0x96	; 150
    8054:	11 c0       	rjmp	.+34     	; 0x8078 <__floatsisf+0x6a>
    8056:	77 23       	and	r23, r23
    8058:	21 f0       	breq	.+8      	; 0x8062 <__floatsisf+0x54>
    805a:	9e e8       	ldi	r25, 0x8E	; 142
    805c:	87 2f       	mov	r24, r23
    805e:	76 2f       	mov	r23, r22
    8060:	05 c0       	rjmp	.+10     	; 0x806c <__floatsisf+0x5e>
    8062:	66 23       	and	r22, r22
    8064:	71 f0       	breq	.+28     	; 0x8082 <__floatsisf+0x74>
    8066:	96 e8       	ldi	r25, 0x86	; 134
    8068:	86 2f       	mov	r24, r22
    806a:	70 e0       	ldi	r23, 0x00	; 0
    806c:	60 e0       	ldi	r22, 0x00	; 0
    806e:	2a f0       	brmi	.+10     	; 0x807a <__floatsisf+0x6c>
    8070:	9a 95       	dec	r25
    8072:	66 0f       	add	r22, r22
    8074:	77 1f       	adc	r23, r23
    8076:	88 1f       	adc	r24, r24
    8078:	da f7       	brpl	.-10     	; 0x8070 <__floatsisf+0x62>
    807a:	88 0f       	add	r24, r24
    807c:	96 95       	lsr	r25
    807e:	87 95       	ror	r24
    8080:	97 f9       	bld	r25, 7
    8082:	08 95       	ret

00008084 <floor>:
    8084:	07 d1       	rcall	.+526    	; 0x8294 <__fp_trunc>
    8086:	80 f0       	brcs	.+32     	; 0x80a8 <floor+0x24>
    8088:	9f 37       	cpi	r25, 0x7F	; 127
    808a:	40 f4       	brcc	.+16     	; 0x809c <floor+0x18>
    808c:	91 11       	cpse	r25, r1
    808e:	0e f0       	brts	.+2      	; 0x8092 <floor+0xe>
    8090:	19 c1       	rjmp	.+562    	; 0x82c4 <__fp_szero>
    8092:	60 e0       	ldi	r22, 0x00	; 0
    8094:	70 e0       	ldi	r23, 0x00	; 0
    8096:	80 e8       	ldi	r24, 0x80	; 128
    8098:	9f eb       	ldi	r25, 0xBF	; 191
    809a:	08 95       	ret
    809c:	26 f4       	brtc	.+8      	; 0x80a6 <floor+0x22>
    809e:	1b 16       	cp	r1, r27
    80a0:	61 1d       	adc	r22, r1
    80a2:	71 1d       	adc	r23, r1
    80a4:	81 1d       	adc	r24, r1
    80a6:	2b c0       	rjmp	.+86     	; 0x80fe <__fp_mintl>
    80a8:	45 c0       	rjmp	.+138    	; 0x8134 <__fp_mpack>

000080aa <__fp_cmp>:
    80aa:	99 0f       	add	r25, r25
    80ac:	00 08       	sbc	r0, r0
    80ae:	55 0f       	add	r21, r21
    80b0:	aa 0b       	sbc	r26, r26
    80b2:	e0 e8       	ldi	r30, 0x80	; 128
    80b4:	fe ef       	ldi	r31, 0xFE	; 254
    80b6:	16 16       	cp	r1, r22
    80b8:	17 06       	cpc	r1, r23
    80ba:	e8 07       	cpc	r30, r24
    80bc:	f9 07       	cpc	r31, r25
    80be:	c0 f0       	brcs	.+48     	; 0x80f0 <__fp_cmp+0x46>
    80c0:	12 16       	cp	r1, r18
    80c2:	13 06       	cpc	r1, r19
    80c4:	e4 07       	cpc	r30, r20
    80c6:	f5 07       	cpc	r31, r21
    80c8:	98 f0       	brcs	.+38     	; 0x80f0 <__fp_cmp+0x46>
    80ca:	62 1b       	sub	r22, r18
    80cc:	73 0b       	sbc	r23, r19
    80ce:	84 0b       	sbc	r24, r20
    80d0:	95 0b       	sbc	r25, r21
    80d2:	39 f4       	brne	.+14     	; 0x80e2 <__fp_cmp+0x38>
    80d4:	0a 26       	eor	r0, r26
    80d6:	61 f0       	breq	.+24     	; 0x80f0 <__fp_cmp+0x46>
    80d8:	23 2b       	or	r18, r19
    80da:	24 2b       	or	r18, r20
    80dc:	25 2b       	or	r18, r21
    80de:	21 f4       	brne	.+8      	; 0x80e8 <__fp_cmp+0x3e>
    80e0:	08 95       	ret
    80e2:	0a 26       	eor	r0, r26
    80e4:	09 f4       	brne	.+2      	; 0x80e8 <__fp_cmp+0x3e>
    80e6:	a1 40       	sbci	r26, 0x01	; 1
    80e8:	a6 95       	lsr	r26
    80ea:	8f ef       	ldi	r24, 0xFF	; 255
    80ec:	81 1d       	adc	r24, r1
    80ee:	81 1d       	adc	r24, r1
    80f0:	08 95       	ret

000080f2 <__fp_inf>:
    80f2:	97 f9       	bld	r25, 7
    80f4:	9f 67       	ori	r25, 0x7F	; 127
    80f6:	80 e8       	ldi	r24, 0x80	; 128
    80f8:	70 e0       	ldi	r23, 0x00	; 0
    80fa:	60 e0       	ldi	r22, 0x00	; 0
    80fc:	08 95       	ret

000080fe <__fp_mintl>:
    80fe:	88 23       	and	r24, r24
    8100:	71 f4       	brne	.+28     	; 0x811e <__fp_mintl+0x20>
    8102:	77 23       	and	r23, r23
    8104:	21 f0       	breq	.+8      	; 0x810e <__fp_mintl+0x10>
    8106:	98 50       	subi	r25, 0x08	; 8
    8108:	87 2b       	or	r24, r23
    810a:	76 2f       	mov	r23, r22
    810c:	07 c0       	rjmp	.+14     	; 0x811c <__fp_mintl+0x1e>
    810e:	66 23       	and	r22, r22
    8110:	11 f4       	brne	.+4      	; 0x8116 <__fp_mintl+0x18>
    8112:	99 27       	eor	r25, r25
    8114:	0d c0       	rjmp	.+26     	; 0x8130 <__fp_mintl+0x32>
    8116:	90 51       	subi	r25, 0x10	; 16
    8118:	86 2b       	or	r24, r22
    811a:	70 e0       	ldi	r23, 0x00	; 0
    811c:	60 e0       	ldi	r22, 0x00	; 0
    811e:	2a f0       	brmi	.+10     	; 0x812a <__fp_mintl+0x2c>
    8120:	9a 95       	dec	r25
    8122:	66 0f       	add	r22, r22
    8124:	77 1f       	adc	r23, r23
    8126:	88 1f       	adc	r24, r24
    8128:	da f7       	brpl	.-10     	; 0x8120 <__fp_mintl+0x22>
    812a:	88 0f       	add	r24, r24
    812c:	96 95       	lsr	r25
    812e:	87 95       	ror	r24
    8130:	97 f9       	bld	r25, 7
    8132:	08 95       	ret

00008134 <__fp_mpack>:
    8134:	9f 3f       	cpi	r25, 0xFF	; 255
    8136:	31 f0       	breq	.+12     	; 0x8144 <__fp_mpack_finite+0xc>

00008138 <__fp_mpack_finite>:
    8138:	91 50       	subi	r25, 0x01	; 1
    813a:	20 f4       	brcc	.+8      	; 0x8144 <__fp_mpack_finite+0xc>
    813c:	87 95       	ror	r24
    813e:	77 95       	ror	r23
    8140:	67 95       	ror	r22
    8142:	b7 95       	ror	r27
    8144:	88 0f       	add	r24, r24
    8146:	91 1d       	adc	r25, r1
    8148:	96 95       	lsr	r25
    814a:	87 95       	ror	r24
    814c:	97 f9       	bld	r25, 7
    814e:	08 95       	ret

00008150 <__fp_nan>:
    8150:	9f ef       	ldi	r25, 0xFF	; 255
    8152:	80 ec       	ldi	r24, 0xC0	; 192
    8154:	08 95       	ret

00008156 <__fp_powser>:
    8156:	df 93       	push	r29
    8158:	cf 93       	push	r28
    815a:	1f 93       	push	r17
    815c:	0f 93       	push	r16
    815e:	ff 92       	push	r15
    8160:	ef 92       	push	r14
    8162:	df 92       	push	r13
    8164:	7b 01       	movw	r14, r22
    8166:	8c 01       	movw	r16, r24
    8168:	68 94       	set
    816a:	05 c0       	rjmp	.+10     	; 0x8176 <__fp_powser+0x20>
    816c:	da 2e       	mov	r13, r26
    816e:	ef 01       	movw	r28, r30
    8170:	f6 d0       	rcall	.+492    	; 0x835e <__mulsf3x>
    8172:	fe 01       	movw	r30, r28
    8174:	e8 94       	clt
    8176:	a5 91       	lpm	r26, Z+
    8178:	25 91       	lpm	r18, Z+
    817a:	35 91       	lpm	r19, Z+
    817c:	45 91       	lpm	r20, Z+
    817e:	55 91       	lpm	r21, Z+
    8180:	ae f3       	brts	.-22     	; 0x816c <__fp_powser+0x16>
    8182:	ef 01       	movw	r28, r30
    8184:	da dd       	rcall	.-1100   	; 0x7d3a <__addsf3x>
    8186:	fe 01       	movw	r30, r28
    8188:	97 01       	movw	r18, r14
    818a:	a8 01       	movw	r20, r16
    818c:	da 94       	dec	r13
    818e:	79 f7       	brne	.-34     	; 0x816e <__fp_powser+0x18>
    8190:	df 90       	pop	r13
    8192:	ef 90       	pop	r14
    8194:	ff 90       	pop	r15
    8196:	0f 91       	pop	r16
    8198:	1f 91       	pop	r17
    819a:	cf 91       	pop	r28
    819c:	df 91       	pop	r29
    819e:	08 95       	ret

000081a0 <__fp_pscA>:
    81a0:	00 24       	eor	r0, r0
    81a2:	0a 94       	dec	r0
    81a4:	16 16       	cp	r1, r22
    81a6:	17 06       	cpc	r1, r23
    81a8:	18 06       	cpc	r1, r24
    81aa:	09 06       	cpc	r0, r25
    81ac:	08 95       	ret

000081ae <__fp_pscB>:
    81ae:	00 24       	eor	r0, r0
    81b0:	0a 94       	dec	r0
    81b2:	12 16       	cp	r1, r18
    81b4:	13 06       	cpc	r1, r19
    81b6:	14 06       	cpc	r1, r20
    81b8:	05 06       	cpc	r0, r21
    81ba:	08 95       	ret
    81bc:	c9 cf       	rjmp	.-110    	; 0x8150 <__fp_nan>

000081be <__fp_rempio2>:
    81be:	50 d0       	rcall	.+160    	; 0x8260 <__fp_splitA>
    81c0:	e8 f3       	brcs	.-6      	; 0x81bc <__fp_pscB+0xe>
    81c2:	e8 94       	clt
    81c4:	e0 e0       	ldi	r30, 0x00	; 0
    81c6:	bb 27       	eor	r27, r27
    81c8:	9f 57       	subi	r25, 0x7F	; 127
    81ca:	f0 f0       	brcs	.+60     	; 0x8208 <__fp_rempio2+0x4a>
    81cc:	2a ed       	ldi	r18, 0xDA	; 218
    81ce:	3f e0       	ldi	r19, 0x0F	; 15
    81d0:	49 ec       	ldi	r20, 0xC9	; 201
    81d2:	06 c0       	rjmp	.+12     	; 0x81e0 <__fp_rempio2+0x22>
    81d4:	ee 0f       	add	r30, r30
    81d6:	bb 0f       	add	r27, r27
    81d8:	66 1f       	adc	r22, r22
    81da:	77 1f       	adc	r23, r23
    81dc:	88 1f       	adc	r24, r24
    81de:	28 f0       	brcs	.+10     	; 0x81ea <__fp_rempio2+0x2c>
    81e0:	b2 3a       	cpi	r27, 0xA2	; 162
    81e2:	62 07       	cpc	r22, r18
    81e4:	73 07       	cpc	r23, r19
    81e6:	84 07       	cpc	r24, r20
    81e8:	28 f0       	brcs	.+10     	; 0x81f4 <__fp_rempio2+0x36>
    81ea:	b2 5a       	subi	r27, 0xA2	; 162
    81ec:	62 0b       	sbc	r22, r18
    81ee:	73 0b       	sbc	r23, r19
    81f0:	84 0b       	sbc	r24, r20
    81f2:	e3 95       	inc	r30
    81f4:	9a 95       	dec	r25
    81f6:	72 f7       	brpl	.-36     	; 0x81d4 <__fp_rempio2+0x16>
    81f8:	80 38       	cpi	r24, 0x80	; 128
    81fa:	30 f4       	brcc	.+12     	; 0x8208 <__fp_rempio2+0x4a>
    81fc:	9a 95       	dec	r25
    81fe:	bb 0f       	add	r27, r27
    8200:	66 1f       	adc	r22, r22
    8202:	77 1f       	adc	r23, r23
    8204:	88 1f       	adc	r24, r24
    8206:	d2 f7       	brpl	.-12     	; 0x81fc <__fp_rempio2+0x3e>
    8208:	90 48       	sbci	r25, 0x80	; 128
    820a:	96 cf       	rjmp	.-212    	; 0x8138 <__fp_mpack_finite>

0000820c <__fp_round>:
    820c:	09 2e       	mov	r0, r25
    820e:	03 94       	inc	r0
    8210:	00 0c       	add	r0, r0
    8212:	11 f4       	brne	.+4      	; 0x8218 <__fp_round+0xc>
    8214:	88 23       	and	r24, r24
    8216:	52 f0       	brmi	.+20     	; 0x822c <__fp_round+0x20>
    8218:	bb 0f       	add	r27, r27
    821a:	40 f4       	brcc	.+16     	; 0x822c <__fp_round+0x20>
    821c:	bf 2b       	or	r27, r31
    821e:	11 f4       	brne	.+4      	; 0x8224 <__fp_round+0x18>
    8220:	60 ff       	sbrs	r22, 0
    8222:	04 c0       	rjmp	.+8      	; 0x822c <__fp_round+0x20>
    8224:	6f 5f       	subi	r22, 0xFF	; 255
    8226:	7f 4f       	sbci	r23, 0xFF	; 255
    8228:	8f 4f       	sbci	r24, 0xFF	; 255
    822a:	9f 4f       	sbci	r25, 0xFF	; 255
    822c:	08 95       	ret

0000822e <__fp_sinus>:
    822e:	ef 93       	push	r30
    8230:	e0 ff       	sbrs	r30, 0
    8232:	06 c0       	rjmp	.+12     	; 0x8240 <__fp_sinus+0x12>
    8234:	a2 ea       	ldi	r26, 0xA2	; 162
    8236:	2a ed       	ldi	r18, 0xDA	; 218
    8238:	3f e0       	ldi	r19, 0x0F	; 15
    823a:	49 ec       	ldi	r20, 0xC9	; 201
    823c:	5f eb       	ldi	r21, 0xBF	; 191
    823e:	7d dd       	rcall	.-1286   	; 0x7d3a <__addsf3x>
    8240:	e5 df       	rcall	.-54     	; 0x820c <__fp_round>
    8242:	0f 90       	pop	r0
    8244:	03 94       	inc	r0
    8246:	01 fc       	sbrc	r0, 1
    8248:	90 58       	subi	r25, 0x80	; 128
    824a:	eb ec       	ldi	r30, 0xCB	; 203
    824c:	f2 e0       	ldi	r31, 0x02	; 2
    824e:	57 c1       	rjmp	.+686    	; 0x84fe <__fp_powsodd>

00008250 <__fp_split3>:
    8250:	57 fd       	sbrc	r21, 7
    8252:	90 58       	subi	r25, 0x80	; 128
    8254:	44 0f       	add	r20, r20
    8256:	55 1f       	adc	r21, r21
    8258:	59 f0       	breq	.+22     	; 0x8270 <__fp_splitA+0x10>
    825a:	5f 3f       	cpi	r21, 0xFF	; 255
    825c:	71 f0       	breq	.+28     	; 0x827a <__fp_splitA+0x1a>
    825e:	47 95       	ror	r20

00008260 <__fp_splitA>:
    8260:	88 0f       	add	r24, r24
    8262:	97 fb       	bst	r25, 7
    8264:	99 1f       	adc	r25, r25
    8266:	61 f0       	breq	.+24     	; 0x8280 <__fp_splitA+0x20>
    8268:	9f 3f       	cpi	r25, 0xFF	; 255
    826a:	79 f0       	breq	.+30     	; 0x828a <__fp_splitA+0x2a>
    826c:	87 95       	ror	r24
    826e:	08 95       	ret
    8270:	12 16       	cp	r1, r18
    8272:	13 06       	cpc	r1, r19
    8274:	14 06       	cpc	r1, r20
    8276:	55 1f       	adc	r21, r21
    8278:	f2 cf       	rjmp	.-28     	; 0x825e <__fp_split3+0xe>
    827a:	46 95       	lsr	r20
    827c:	f1 df       	rcall	.-30     	; 0x8260 <__fp_splitA>
    827e:	08 c0       	rjmp	.+16     	; 0x8290 <__fp_splitA+0x30>
    8280:	16 16       	cp	r1, r22
    8282:	17 06       	cpc	r1, r23
    8284:	18 06       	cpc	r1, r24
    8286:	99 1f       	adc	r25, r25
    8288:	f1 cf       	rjmp	.-30     	; 0x826c <__fp_splitA+0xc>
    828a:	86 95       	lsr	r24
    828c:	71 05       	cpc	r23, r1
    828e:	61 05       	cpc	r22, r1
    8290:	08 94       	sec
    8292:	08 95       	ret

00008294 <__fp_trunc>:
    8294:	e5 df       	rcall	.-54     	; 0x8260 <__fp_splitA>
    8296:	a0 f0       	brcs	.+40     	; 0x82c0 <__fp_trunc+0x2c>
    8298:	be e7       	ldi	r27, 0x7E	; 126
    829a:	b9 17       	cp	r27, r25
    829c:	88 f4       	brcc	.+34     	; 0x82c0 <__fp_trunc+0x2c>
    829e:	bb 27       	eor	r27, r27
    82a0:	9f 38       	cpi	r25, 0x8F	; 143
    82a2:	60 f4       	brcc	.+24     	; 0x82bc <__fp_trunc+0x28>
    82a4:	16 16       	cp	r1, r22
    82a6:	b1 1d       	adc	r27, r1
    82a8:	67 2f       	mov	r22, r23
    82aa:	78 2f       	mov	r23, r24
    82ac:	88 27       	eor	r24, r24
    82ae:	98 5f       	subi	r25, 0xF8	; 248
    82b0:	f7 cf       	rjmp	.-18     	; 0x82a0 <__fp_trunc+0xc>
    82b2:	86 95       	lsr	r24
    82b4:	77 95       	ror	r23
    82b6:	67 95       	ror	r22
    82b8:	b1 1d       	adc	r27, r1
    82ba:	93 95       	inc	r25
    82bc:	96 39       	cpi	r25, 0x96	; 150
    82be:	c8 f3       	brcs	.-14     	; 0x82b2 <__fp_trunc+0x1e>
    82c0:	08 95       	ret

000082c2 <__fp_zero>:
    82c2:	e8 94       	clt

000082c4 <__fp_szero>:
    82c4:	bb 27       	eor	r27, r27
    82c6:	66 27       	eor	r22, r22
    82c8:	77 27       	eor	r23, r23
    82ca:	cb 01       	movw	r24, r22
    82cc:	97 f9       	bld	r25, 7
    82ce:	08 95       	ret

000082d0 <__gesf2>:
    82d0:	ec de       	rcall	.-552    	; 0x80aa <__fp_cmp>
    82d2:	08 f4       	brcc	.+2      	; 0x82d6 <__gesf2+0x6>
    82d4:	8f ef       	ldi	r24, 0xFF	; 255
    82d6:	08 95       	ret

000082d8 <inverse>:
    82d8:	9b 01       	movw	r18, r22
    82da:	ac 01       	movw	r20, r24
    82dc:	60 e0       	ldi	r22, 0x00	; 0
    82de:	70 e0       	ldi	r23, 0x00	; 0
    82e0:	80 e8       	ldi	r24, 0x80	; 128
    82e2:	9f e3       	ldi	r25, 0x3F	; 63
    82e4:	f9 cd       	rjmp	.-1038   	; 0x7ed8 <__divsf3>

000082e6 <lround>:
    82e6:	bc df       	rcall	.-136    	; 0x8260 <__fp_splitA>
    82e8:	58 f1       	brcs	.+86     	; 0x8340 <lround+0x5a>
    82ea:	9e 57       	subi	r25, 0x7E	; 126
    82ec:	58 f1       	brcs	.+86     	; 0x8344 <lround+0x5e>
    82ee:	98 51       	subi	r25, 0x18	; 24
    82f0:	a0 f0       	brcs	.+40     	; 0x831a <lround+0x34>
    82f2:	e9 f0       	breq	.+58     	; 0x832e <lround+0x48>
    82f4:	98 30       	cpi	r25, 0x08	; 8
    82f6:	20 f5       	brcc	.+72     	; 0x8340 <lround+0x5a>
    82f8:	09 2e       	mov	r0, r25
    82fa:	99 27       	eor	r25, r25
    82fc:	66 0f       	add	r22, r22
    82fe:	77 1f       	adc	r23, r23
    8300:	88 1f       	adc	r24, r24
    8302:	99 1f       	adc	r25, r25
    8304:	0a 94       	dec	r0
    8306:	d1 f7       	brne	.-12     	; 0x82fc <lround+0x16>
    8308:	12 c0       	rjmp	.+36     	; 0x832e <lround+0x48>
    830a:	06 2e       	mov	r0, r22
    830c:	67 2f       	mov	r22, r23
    830e:	78 2f       	mov	r23, r24
    8310:	88 27       	eor	r24, r24
    8312:	98 5f       	subi	r25, 0xF8	; 248
    8314:	11 f4       	brne	.+4      	; 0x831a <lround+0x34>
    8316:	00 0c       	add	r0, r0
    8318:	07 c0       	rjmp	.+14     	; 0x8328 <lround+0x42>
    831a:	99 3f       	cpi	r25, 0xF9	; 249
    831c:	b4 f3       	brlt	.-20     	; 0x830a <lround+0x24>
    831e:	86 95       	lsr	r24
    8320:	77 95       	ror	r23
    8322:	67 95       	ror	r22
    8324:	93 95       	inc	r25
    8326:	d9 f7       	brne	.-10     	; 0x831e <lround+0x38>
    8328:	61 1d       	adc	r22, r1
    832a:	71 1d       	adc	r23, r1
    832c:	81 1d       	adc	r24, r1
    832e:	3e f4       	brtc	.+14     	; 0x833e <lround+0x58>
    8330:	90 95       	com	r25
    8332:	80 95       	com	r24
    8334:	70 95       	com	r23
    8336:	61 95       	neg	r22
    8338:	7f 4f       	sbci	r23, 0xFF	; 255
    833a:	8f 4f       	sbci	r24, 0xFF	; 255
    833c:	9f 4f       	sbci	r25, 0xFF	; 255
    833e:	08 95       	ret
    8340:	68 94       	set
    8342:	c0 cf       	rjmp	.-128    	; 0x82c4 <__fp_szero>
    8344:	be cf       	rjmp	.-132    	; 0x82c2 <__fp_zero>

00008346 <__mulsf3>:
    8346:	0b d0       	rcall	.+22     	; 0x835e <__mulsf3x>
    8348:	61 cf       	rjmp	.-318    	; 0x820c <__fp_round>
    834a:	2a df       	rcall	.-428    	; 0x81a0 <__fp_pscA>
    834c:	28 f0       	brcs	.+10     	; 0x8358 <__mulsf3+0x12>
    834e:	2f df       	rcall	.-418    	; 0x81ae <__fp_pscB>
    8350:	18 f0       	brcs	.+6      	; 0x8358 <__mulsf3+0x12>
    8352:	95 23       	and	r25, r21
    8354:	09 f0       	breq	.+2      	; 0x8358 <__mulsf3+0x12>
    8356:	cd ce       	rjmp	.-614    	; 0x80f2 <__fp_inf>
    8358:	fb ce       	rjmp	.-522    	; 0x8150 <__fp_nan>
    835a:	11 24       	eor	r1, r1
    835c:	b3 cf       	rjmp	.-154    	; 0x82c4 <__fp_szero>

0000835e <__mulsf3x>:
    835e:	78 df       	rcall	.-272    	; 0x8250 <__fp_split3>
    8360:	a0 f3       	brcs	.-24     	; 0x834a <__mulsf3+0x4>

00008362 <__mulsf3_pse>:
    8362:	95 9f       	mul	r25, r21
    8364:	d1 f3       	breq	.-12     	; 0x835a <__mulsf3+0x14>
    8366:	95 0f       	add	r25, r21
    8368:	50 e0       	ldi	r21, 0x00	; 0
    836a:	55 1f       	adc	r21, r21
    836c:	62 9f       	mul	r22, r18
    836e:	f0 01       	movw	r30, r0
    8370:	72 9f       	mul	r23, r18
    8372:	bb 27       	eor	r27, r27
    8374:	f0 0d       	add	r31, r0
    8376:	b1 1d       	adc	r27, r1
    8378:	63 9f       	mul	r22, r19
    837a:	aa 27       	eor	r26, r26
    837c:	f0 0d       	add	r31, r0
    837e:	b1 1d       	adc	r27, r1
    8380:	aa 1f       	adc	r26, r26
    8382:	64 9f       	mul	r22, r20
    8384:	66 27       	eor	r22, r22
    8386:	b0 0d       	add	r27, r0
    8388:	a1 1d       	adc	r26, r1
    838a:	66 1f       	adc	r22, r22
    838c:	82 9f       	mul	r24, r18
    838e:	22 27       	eor	r18, r18
    8390:	b0 0d       	add	r27, r0
    8392:	a1 1d       	adc	r26, r1
    8394:	62 1f       	adc	r22, r18
    8396:	73 9f       	mul	r23, r19
    8398:	b0 0d       	add	r27, r0
    839a:	a1 1d       	adc	r26, r1
    839c:	62 1f       	adc	r22, r18
    839e:	83 9f       	mul	r24, r19
    83a0:	a0 0d       	add	r26, r0
    83a2:	61 1d       	adc	r22, r1
    83a4:	22 1f       	adc	r18, r18
    83a6:	74 9f       	mul	r23, r20
    83a8:	33 27       	eor	r19, r19
    83aa:	a0 0d       	add	r26, r0
    83ac:	61 1d       	adc	r22, r1
    83ae:	23 1f       	adc	r18, r19
    83b0:	84 9f       	mul	r24, r20
    83b2:	60 0d       	add	r22, r0
    83b4:	21 1d       	adc	r18, r1
    83b6:	82 2f       	mov	r24, r18
    83b8:	76 2f       	mov	r23, r22
    83ba:	6a 2f       	mov	r22, r26
    83bc:	11 24       	eor	r1, r1
    83be:	9f 57       	subi	r25, 0x7F	; 127
    83c0:	50 40       	sbci	r21, 0x00	; 0
    83c2:	8a f0       	brmi	.+34     	; 0x83e6 <__mulsf3_pse+0x84>
    83c4:	e1 f0       	breq	.+56     	; 0x83fe <__mulsf3_pse+0x9c>
    83c6:	88 23       	and	r24, r24
    83c8:	4a f0       	brmi	.+18     	; 0x83dc <__mulsf3_pse+0x7a>
    83ca:	ee 0f       	add	r30, r30
    83cc:	ff 1f       	adc	r31, r31
    83ce:	bb 1f       	adc	r27, r27
    83d0:	66 1f       	adc	r22, r22
    83d2:	77 1f       	adc	r23, r23
    83d4:	88 1f       	adc	r24, r24
    83d6:	91 50       	subi	r25, 0x01	; 1
    83d8:	50 40       	sbci	r21, 0x00	; 0
    83da:	a9 f7       	brne	.-22     	; 0x83c6 <__mulsf3_pse+0x64>
    83dc:	9e 3f       	cpi	r25, 0xFE	; 254
    83de:	51 05       	cpc	r21, r1
    83e0:	70 f0       	brcs	.+28     	; 0x83fe <__mulsf3_pse+0x9c>
    83e2:	87 ce       	rjmp	.-754    	; 0x80f2 <__fp_inf>
    83e4:	6f cf       	rjmp	.-290    	; 0x82c4 <__fp_szero>
    83e6:	5f 3f       	cpi	r21, 0xFF	; 255
    83e8:	ec f3       	brlt	.-6      	; 0x83e4 <__mulsf3_pse+0x82>
    83ea:	98 3e       	cpi	r25, 0xE8	; 232
    83ec:	dc f3       	brlt	.-10     	; 0x83e4 <__mulsf3_pse+0x82>
    83ee:	86 95       	lsr	r24
    83f0:	77 95       	ror	r23
    83f2:	67 95       	ror	r22
    83f4:	b7 95       	ror	r27
    83f6:	f7 95       	ror	r31
    83f8:	e7 95       	ror	r30
    83fa:	9f 5f       	subi	r25, 0xFF	; 255
    83fc:	c1 f7       	brne	.-16     	; 0x83ee <__mulsf3_pse+0x8c>
    83fe:	fe 2b       	or	r31, r30
    8400:	88 0f       	add	r24, r24
    8402:	91 1d       	adc	r25, r1
    8404:	96 95       	lsr	r25
    8406:	87 95       	ror	r24
    8408:	97 f9       	bld	r25, 7
    840a:	08 95       	ret

0000840c <round>:
    840c:	29 df       	rcall	.-430    	; 0x8260 <__fp_splitA>
    840e:	e0 f0       	brcs	.+56     	; 0x8448 <round+0x3c>
    8410:	9e 37       	cpi	r25, 0x7E	; 126
    8412:	d8 f0       	brcs	.+54     	; 0x844a <round+0x3e>
    8414:	96 39       	cpi	r25, 0x96	; 150
    8416:	b8 f4       	brcc	.+46     	; 0x8446 <round+0x3a>
    8418:	9e 38       	cpi	r25, 0x8E	; 142
    841a:	48 f4       	brcc	.+18     	; 0x842e <round+0x22>
    841c:	67 2f       	mov	r22, r23
    841e:	78 2f       	mov	r23, r24
    8420:	88 27       	eor	r24, r24
    8422:	98 5f       	subi	r25, 0xF8	; 248
    8424:	f9 cf       	rjmp	.-14     	; 0x8418 <round+0xc>
    8426:	86 95       	lsr	r24
    8428:	77 95       	ror	r23
    842a:	67 95       	ror	r22
    842c:	93 95       	inc	r25
    842e:	95 39       	cpi	r25, 0x95	; 149
    8430:	d0 f3       	brcs	.-12     	; 0x8426 <round+0x1a>
    8432:	b6 2f       	mov	r27, r22
    8434:	b1 70       	andi	r27, 0x01	; 1
    8436:	6b 0f       	add	r22, r27
    8438:	71 1d       	adc	r23, r1
    843a:	81 1d       	adc	r24, r1
    843c:	20 f4       	brcc	.+8      	; 0x8446 <round+0x3a>
    843e:	87 95       	ror	r24
    8440:	77 95       	ror	r23
    8442:	67 95       	ror	r22
    8444:	93 95       	inc	r25
    8446:	5b ce       	rjmp	.-842    	; 0x80fe <__fp_mintl>
    8448:	75 ce       	rjmp	.-790    	; 0x8134 <__fp_mpack>
    844a:	3c cf       	rjmp	.-392    	; 0x82c4 <__fp_szero>

0000844c <sin>:
    844c:	9f 93       	push	r25
    844e:	b7 de       	rcall	.-658    	; 0x81be <__fp_rempio2>
    8450:	0f 90       	pop	r0
    8452:	07 fc       	sbrc	r0, 7
    8454:	ee 5f       	subi	r30, 0xFE	; 254
    8456:	eb ce       	rjmp	.-554    	; 0x822e <__fp_sinus>
    8458:	11 f4       	brne	.+4      	; 0x845e <sin+0x12>
    845a:	0e f4       	brtc	.+2      	; 0x845e <sin+0x12>
    845c:	79 ce       	rjmp	.-782    	; 0x8150 <__fp_nan>
    845e:	6a ce       	rjmp	.-812    	; 0x8134 <__fp_mpack>

00008460 <sqrt>:
    8460:	ff de       	rcall	.-514    	; 0x8260 <__fp_splitA>
    8462:	d0 f3       	brcs	.-12     	; 0x8458 <sin+0xc>
    8464:	99 23       	and	r25, r25
    8466:	d9 f3       	breq	.-10     	; 0x845e <sin+0x12>
    8468:	ce f3       	brts	.-14     	; 0x845c <sin+0x10>
    846a:	9f 57       	subi	r25, 0x7F	; 127
    846c:	55 0b       	sbc	r21, r21
    846e:	87 ff       	sbrs	r24, 7
    8470:	3f d0       	rcall	.+126    	; 0x84f0 <__fp_norm2>
    8472:	00 24       	eor	r0, r0
    8474:	a0 e6       	ldi	r26, 0x60	; 96
    8476:	40 ea       	ldi	r20, 0xA0	; 160
    8478:	90 01       	movw	r18, r0
    847a:	80 58       	subi	r24, 0x80	; 128
    847c:	56 95       	lsr	r21
    847e:	97 95       	ror	r25
    8480:	28 f4       	brcc	.+10     	; 0x848c <sqrt+0x2c>
    8482:	80 5c       	subi	r24, 0xC0	; 192
    8484:	66 0f       	add	r22, r22
    8486:	77 1f       	adc	r23, r23
    8488:	88 1f       	adc	r24, r24
    848a:	20 f0       	brcs	.+8      	; 0x8494 <sqrt+0x34>
    848c:	26 17       	cp	r18, r22
    848e:	37 07       	cpc	r19, r23
    8490:	48 07       	cpc	r20, r24
    8492:	30 f4       	brcc	.+12     	; 0x84a0 <sqrt+0x40>
    8494:	62 1b       	sub	r22, r18
    8496:	73 0b       	sbc	r23, r19
    8498:	84 0b       	sbc	r24, r20
    849a:	20 29       	or	r18, r0
    849c:	31 29       	or	r19, r1
    849e:	4a 2b       	or	r20, r26
    84a0:	a6 95       	lsr	r26
    84a2:	17 94       	ror	r1
    84a4:	07 94       	ror	r0
    84a6:	20 25       	eor	r18, r0
    84a8:	31 25       	eor	r19, r1
    84aa:	4a 27       	eor	r20, r26
    84ac:	58 f7       	brcc	.-42     	; 0x8484 <sqrt+0x24>
    84ae:	66 0f       	add	r22, r22
    84b0:	77 1f       	adc	r23, r23
    84b2:	88 1f       	adc	r24, r24
    84b4:	20 f0       	brcs	.+8      	; 0x84be <sqrt+0x5e>
    84b6:	26 17       	cp	r18, r22
    84b8:	37 07       	cpc	r19, r23
    84ba:	48 07       	cpc	r20, r24
    84bc:	30 f4       	brcc	.+12     	; 0x84ca <sqrt+0x6a>
    84be:	62 0b       	sbc	r22, r18
    84c0:	73 0b       	sbc	r23, r19
    84c2:	84 0b       	sbc	r24, r20
    84c4:	20 0d       	add	r18, r0
    84c6:	31 1d       	adc	r19, r1
    84c8:	41 1d       	adc	r20, r1
    84ca:	a0 95       	com	r26
    84cc:	81 f7       	brne	.-32     	; 0x84ae <sqrt+0x4e>
    84ce:	b9 01       	movw	r22, r18
    84d0:	84 2f       	mov	r24, r20
    84d2:	91 58       	subi	r25, 0x81	; 129
    84d4:	88 0f       	add	r24, r24
    84d6:	96 95       	lsr	r25
    84d8:	87 95       	ror	r24
    84da:	08 95       	ret

000084dc <square>:
    84dc:	9b 01       	movw	r18, r22
    84de:	ac 01       	movw	r20, r24
    84e0:	32 cf       	rjmp	.-412    	; 0x8346 <__mulsf3>

000084e2 <trunc>:
    84e2:	d8 de       	rcall	.-592    	; 0x8294 <__fp_trunc>
    84e4:	20 f0       	brcs	.+8      	; 0x84ee <trunc+0xc>
    84e6:	9f 37       	cpi	r25, 0x7F	; 127
    84e8:	08 f4       	brcc	.+2      	; 0x84ec <trunc+0xa>
    84ea:	ec ce       	rjmp	.-552    	; 0x82c4 <__fp_szero>
    84ec:	08 ce       	rjmp	.-1008   	; 0x80fe <__fp_mintl>
    84ee:	22 ce       	rjmp	.-956    	; 0x8134 <__fp_mpack>

000084f0 <__fp_norm2>:
    84f0:	91 50       	subi	r25, 0x01	; 1
    84f2:	50 40       	sbci	r21, 0x00	; 0
    84f4:	66 0f       	add	r22, r22
    84f6:	77 1f       	adc	r23, r23
    84f8:	88 1f       	adc	r24, r24
    84fa:	d2 f7       	brpl	.-12     	; 0x84f0 <__fp_norm2>
    84fc:	08 95       	ret

000084fe <__fp_powsodd>:
    84fe:	9f 93       	push	r25
    8500:	8f 93       	push	r24
    8502:	7f 93       	push	r23
    8504:	6f 93       	push	r22
    8506:	ff 93       	push	r31
    8508:	ef 93       	push	r30
    850a:	9b 01       	movw	r18, r22
    850c:	ac 01       	movw	r20, r24
    850e:	1b df       	rcall	.-458    	; 0x8346 <__mulsf3>
    8510:	ef 91       	pop	r30
    8512:	ff 91       	pop	r31
    8514:	20 de       	rcall	.-960    	; 0x8156 <__fp_powser>
    8516:	2f 91       	pop	r18
    8518:	3f 91       	pop	r19
    851a:	4f 91       	pop	r20
    851c:	5f 91       	pop	r21
    851e:	13 cf       	rjmp	.-474    	; 0x8346 <__mulsf3>

00008520 <__udivmodsi4>:
    8520:	a1 e2       	ldi	r26, 0x21	; 33
    8522:	1a 2e       	mov	r1, r26
    8524:	aa 1b       	sub	r26, r26
    8526:	bb 1b       	sub	r27, r27
    8528:	fd 01       	movw	r30, r26
    852a:	0d c0       	rjmp	.+26     	; 0x8546 <__udivmodsi4_ep>

0000852c <__udivmodsi4_loop>:
    852c:	aa 1f       	adc	r26, r26
    852e:	bb 1f       	adc	r27, r27
    8530:	ee 1f       	adc	r30, r30
    8532:	ff 1f       	adc	r31, r31
    8534:	a2 17       	cp	r26, r18
    8536:	b3 07       	cpc	r27, r19
    8538:	e4 07       	cpc	r30, r20
    853a:	f5 07       	cpc	r31, r21
    853c:	20 f0       	brcs	.+8      	; 0x8546 <__udivmodsi4_ep>
    853e:	a2 1b       	sub	r26, r18
    8540:	b3 0b       	sbc	r27, r19
    8542:	e4 0b       	sbc	r30, r20
    8544:	f5 0b       	sbc	r31, r21

00008546 <__udivmodsi4_ep>:
    8546:	66 1f       	adc	r22, r22
    8548:	77 1f       	adc	r23, r23
    854a:	88 1f       	adc	r24, r24
    854c:	99 1f       	adc	r25, r25
    854e:	1a 94       	dec	r1
    8550:	69 f7       	brne	.-38     	; 0x852c <__udivmodsi4_loop>
    8552:	60 95       	com	r22
    8554:	70 95       	com	r23
    8556:	80 95       	com	r24
    8558:	90 95       	com	r25
    855a:	9b 01       	movw	r18, r22
    855c:	ac 01       	movw	r20, r24
    855e:	bd 01       	movw	r22, r26
    8560:	cf 01       	movw	r24, r30
    8562:	08 95       	ret

00008564 <__tablejump2__>:
    8564:	ee 0f       	add	r30, r30
    8566:	ff 1f       	adc	r31, r31
    8568:	88 1f       	adc	r24, r24
    856a:	8b bf       	out	0x3b, r24	; 59
    856c:	07 90       	elpm	r0, Z+
    856e:	f6 91       	elpm	r31, Z
    8570:	e0 2d       	mov	r30, r0
    8572:	19 94       	eijmp

00008574 <__umulhisi3>:
    8574:	a2 9f       	mul	r26, r18
    8576:	b0 01       	movw	r22, r0
    8578:	b3 9f       	mul	r27, r19
    857a:	c0 01       	movw	r24, r0
    857c:	a3 9f       	mul	r26, r19
    857e:	70 0d       	add	r23, r0
    8580:	81 1d       	adc	r24, r1
    8582:	11 24       	eor	r1, r1
    8584:	91 1d       	adc	r25, r1
    8586:	b2 9f       	mul	r27, r18
    8588:	70 0d       	add	r23, r0
    858a:	81 1d       	adc	r24, r1
    858c:	11 24       	eor	r1, r1
    858e:	91 1d       	adc	r25, r1
    8590:	08 95       	ret

00008592 <memcmp>:
    8592:	fb 01       	movw	r30, r22
    8594:	dc 01       	movw	r26, r24
    8596:	04 c0       	rjmp	.+8      	; 0x85a0 <memcmp+0xe>
    8598:	8d 91       	ld	r24, X+
    859a:	01 90       	ld	r0, Z+
    859c:	80 19       	sub	r24, r0
    859e:	21 f4       	brne	.+8      	; 0x85a8 <memcmp+0x16>
    85a0:	41 50       	subi	r20, 0x01	; 1
    85a2:	50 40       	sbci	r21, 0x00	; 0
    85a4:	c8 f7       	brcc	.-14     	; 0x8598 <memcmp+0x6>
    85a6:	88 1b       	sub	r24, r24
    85a8:	99 0b       	sbc	r25, r25
    85aa:	08 95       	ret

000085ac <_exit>:
    85ac:	f8 94       	cli

000085ae <__stop_program>:
    85ae:	ff cf       	rjmp	.-2      	; 0x85ae <__stop_program>
